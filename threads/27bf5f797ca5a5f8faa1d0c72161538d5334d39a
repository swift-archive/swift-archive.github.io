<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 12, 2016 at 08:00:00pm</p></header><div class="content"><p>Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br></p><p>1st a demonstration of the current situation of invariant generics:<br></p><p>    // Current system<br>    class Top {}<br>    class Bottom: Top {}<br></p><p>    struct Box&lt;T: AnyObject&gt; {<br>        var value: T<br>        init(_ initialValue: T) {<br>            value = initialValue;<br>        }<br>    }<br></p><p>    let boxB = Box(Bottom())<br>    // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br></p><p>The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br></p><p>I am suggesting:<br></p><p>1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>2. An implementation that allows the above covariance.<br>3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br></p><p>    // Proposal:<br>    // 1. No change to Box, i.e. programmer would just write Box as before<br>    // 2. Code transformed by comiler with write check for each specific, generic type instance<br>    // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br></p><p>    // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>    // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>    struct BoxAnyObject {<br>        // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>        let T: AnyObject.Type // Store the actual type.<br>        <br>        // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>        private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>        var value: AnyObject {<br>            get {<br>                return _value<br>            }<br>            set {<br>                // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>                // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>                // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>                precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>                _value = newValue<br>            }<br>        }<br>        <br>        // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>        init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>            T = lowestCommonDeclaredT<br>            _value = initialValue<br>        }<br>    }<br></p><p>    // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>    // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>    var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>    bT.T // Top.Type<br>    sizeofValue(bT) // 16<br></p><p>    var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>    bB.T // Bottom.Type<br>    sizeofValue(bB) // 16<br></p><p>    // Demonstration covariance.<br>    bT = bB // Compiler would check covariance of declared generic types.<br>    bT.T // Bottom.Type<br></p><p>    // Demonstrate generic returned type<br>    // Compiler would add cast to declared, generic type.<br>    bB.value as! Bottom // In practice user would write `bB.value`.<br></p><p>    // Demonstrate type safety<br>    bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>    bT.value = Top() // OK<br>    // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>    // bB.value = Top() // Runtime error - wrong type<br></p><p>The implications of this proposal are:<br></p><p>1. The compiler can statically type check a read from a stored property.<br>2. A write to a stored property is type checked at runtime.<br>3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br></p><p>Advantages:<br></p><p>1. Covariant generics are a powerful addition to the language.<br>2. Generics’ invariance are inconsistent with the rest of the language.<br>3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br></p><p>Compatibility:<br></p><p>1. This would be a major change since associated types in protocols would be replaced by generics.<br>2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br></p><p>Disadvantages:<br></p><p>1. Major change.<br>2. Object size increases.<br></p><p>Thanks in advance for any comments,<br></p><p>  — Howard.<br></p><p>PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/27bfd39a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 12, 2016 at 08:00:00am</p></header><div class="content"><p>Strong -1, covariance on generics should be explicitly opt-in. Also -1 on generics replacing associated types in protocols.<br></p><p>Austin<br></p><p>&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br>&gt; <br>&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt; <br>&gt;     // Current system<br>&gt;     class Top {}<br>&gt;     class Bottom: Top {}<br>&gt; <br>&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;         var value: T<br>&gt;         init(_ initialValue: T) {<br>&gt;             value = initialValue;<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     let boxB = Box(Bottom())<br>&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt; <br>&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br>&gt; <br>&gt; I am suggesting:<br>&gt; <br>&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt; 2. An implementation that allows the above covariance.<br>&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br>&gt; <br>&gt;     // Proposal:<br>&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;     // 2. Code transformed by comiler with write check for each specific, generic type instance<br>&gt;     // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br>&gt; <br>&gt;     // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;     struct BoxAnyObject {<br>&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;         <br>&gt;         // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;         private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>&gt;         var value: AnyObject {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>&gt;                 // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>&gt;                 // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>&gt;                 _value = newValue<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>&gt;             T = lowestCommonDeclaredT<br>&gt;             _value = initialValue<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>&gt;     // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>&gt;     bT.T // Top.Type<br>&gt;     sizeofValue(bT) // 16<br>&gt; <br>&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>&gt;     bB.T // Bottom.Type<br>&gt;     sizeofValue(bB) // 16<br>&gt; <br>&gt;     // Demonstration covariance.<br>&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;     bT.T // Bottom.Type<br>&gt; <br>&gt;     // Demonstrate generic returned type<br>&gt;     // Compiler would add cast to declared, generic type.<br>&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt; <br>&gt;     // Demonstrate type safety<br>&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>&gt;     bT.value = Top() // OK<br>&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt; <br>&gt; The implications of this proposal are:<br>&gt; <br>&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt; 2. A write to a stored property is type checked at runtime.<br>&gt; 3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>&gt; 4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>&gt; 5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt; <br>&gt; Advantages:<br>&gt; <br>&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt; 3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>&gt; 4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br>&gt; <br>&gt; Compatibility:<br>&gt; <br>&gt; 1. This would be a major change since associated types in protocols would be replaced by generics.<br>&gt; 2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br>&gt; <br>&gt; Disadvantages:<br>&gt; <br>&gt; 1. Major change.<br>&gt; 2. Object size increases.<br>&gt; <br>&gt; Thanks in advance for any comments,<br>&gt; <br>&gt;   — Howard.<br>&gt; <br>&gt; PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/2cc001b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 12, 2016 at 10:00:00am</p></header><div class="content"><p>Agreed on both counts. Generics are more familiar but don&#39;t actually cover the use cases where the associated type is not independent of the model object (like a Sequence&#39;s Generator or a Collection&#39;s Index). Dropping that information results in a lot of extra indirection at runtime, which we don&#39;t want.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on generics replacing associated types in protocols.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br>&gt;&gt; <br>&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt; <br>&gt;&gt;     // Current system<br>&gt;&gt;     class Top {}<br>&gt;&gt;     class Bottom: Top {}<br>&gt;&gt; <br>&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;         var value: T<br>&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;             value = initialValue;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt; <br>&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br>&gt;&gt; <br>&gt;&gt; I am suggesting:<br>&gt;&gt; <br>&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br>&gt;&gt; <br>&gt;&gt;     // Proposal:<br>&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;&gt;     // 2. Code transformed by comiler with write check for each specific, generic type instance<br>&gt;&gt;     // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br>&gt;&gt; <br>&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;         <br>&gt;&gt;         // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>&gt;&gt;         var value: AnyObject {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>&gt;&gt;                 // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;             _value = initialValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt; <br>&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt; <br>&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt; <br>&gt;&gt; The implications of this proposal are:<br>&gt;&gt; <br>&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt; 3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; <br>&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br>&gt;&gt; <br>&gt;&gt; Compatibility:<br>&gt;&gt; <br>&gt;&gt; 1. This would be a major change since associated types in protocols would be replaced by generics.<br>&gt;&gt; 2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; <br>&gt;&gt; 1. Major change.<br>&gt;&gt; 2. Object size increases.<br>&gt;&gt; <br>&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt; <br>&gt;&gt;   — Howard.<br>&gt;&gt; <br>&gt;&gt; PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/c07a37f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>1+ for adding generics to protocols.<br></p><p>What about generics in protocols which are only a view to its associated types or generics which create/are associated types?<br></p><p>Example of a simple protocol which models a node of a tree:<br></p><p>// Before<br></p><p>// NodeType can be anything<br>// currently Swift doesn&#39;t allow<br>// `typealias NodeType: Node`<br>//<br>// or even where clauses <br>// `typealias NodeType: Node where NodeType.T == T`<br>protocol Node {<br>	typealias T<br>	typealias NodeType<br>	<br>	var value: T { get }<br>	var nodes: [NodeType] { get }<br>}<br></p><p>// After<br>protocol Node&lt;T&gt; {<br>	typealias T // probably remove this declaration<br>	var value: T { get }<br>	var nodes: [Node&lt;T&gt;] { get }<br>}<br></p><p>So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br></p><p>In order to let<br></p><p>	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br></p><p>still compile there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br></p><p>The function declaration above could be rewritten to using function like parameter syntax:<br></p><p>    func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;, SubSequence: _&gt;){}<br>    // or omitting `SubSequence: _` since the type is already unambiguous<br>    func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;&gt;){}<br></p><p>in this case there is almost no win. But as you can see in the example with the protocol, generics allow for much better abstraction.<br></p><p>Also where clauses could be used in generic parameter declarations which are disallowed for associated types.<br></p><p><br>Maximilian<br></p><p>&gt; Am 12.01.2016 um 19:19 schrieb Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually cover the use cases where the associated type is not independent of the model object (like a Sequence&#39;s Generator or a Collection&#39;s Index). Dropping that information results in a lot of extra indirection at runtime, which we don&#39;t want.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on generics replacing associated types in protocols.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Current system<br>&gt;&gt;&gt;     class Top {}<br>&gt;&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;&gt;         var value: T<br>&gt;&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;&gt;             value = initialValue;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am suggesting:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Proposal:<br>&gt;&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;&gt;&gt;     // 2. Code transformed by comiler with write check for each specific, generic type instance<br>&gt;&gt;&gt;     // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>&gt;&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;         private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>&gt;&gt;&gt;         var value: AnyObject {<br>&gt;&gt;&gt;             get {<br>&gt;&gt;&gt;                 return _value<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             set {<br>&gt;&gt;&gt;                 // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>&gt;&gt;&gt;                 // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>&gt;&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>&gt;&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>&gt;&gt;&gt;                 _value = newValue<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         <br>&gt;&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>&gt;&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;&gt;             _value = initialValue<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>&gt;&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>&gt;&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>&gt;&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>&gt;&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>&gt;&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>&gt;&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The implications of this proposal are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt;&gt; 3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>&gt;&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>&gt;&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>&gt;&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>&gt;&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Advantages:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>&gt;&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Compatibility:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. This would be a major change since associated types in protocols would be replaced by generics.<br>&gt;&gt;&gt; 2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Disadvantages:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Major change.<br>&gt;&gt;&gt; 2. Object size increases.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   — Howard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/594754ef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 12, 2016 at 01:00:00pm</p></header><div class="content"><p>AFAIK traits in Rust can have both associated types and generic type<br>parameters. I think a corresponding feature for Swift would be a net<br>positive, albeit I haven&#39;t examined the tradeoffs and advantages in any<br>detail yet.<br></p><p>Austin<br></p><p>On Tue, Jan 12, 2016 at 1:16 PM, Maximilian Hünenberger &lt;<br>m.huenenberger at me.com&gt; wrote:<br></p><p>&gt; 1+ for adding generics to protocols.<br>&gt;<br>&gt; What about generics in protocols which are only a view to its associated<br>&gt; types or generics which create/are associated types?<br>&gt;<br>&gt; Example of a simple protocol which models a node of a tree:<br>&gt;<br>&gt; // Before<br>&gt;<br>&gt; // NodeType can be anything<br>&gt; // currently Swift doesn&#39;t allow<br>&gt; // `typealias NodeType: Node`<br>&gt; //<br>&gt; // or even where clauses<br>&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt; protocol Node {<br>&gt; typealias T<br>&gt; typealias NodeType<br>&gt;<br>&gt;<br>&gt; var value: T { get }<br>&gt; var nodes: [NodeType] { get }<br>&gt; }<br>&gt;<br>&gt; // After<br>&gt; protocol Node&lt;T&gt; {<br>&gt; typealias T // probably remove this declaration<br>&gt; var value: T { get }<br>&gt; var nodes: [Node&lt;T&gt;] { get }<br>&gt; }<br>&gt;<br>&gt; So a generic parameter is placed after the protocol name. Therefore a<br>&gt; corresponding associated type could be synthesized making its declaration<br>&gt; in the body of the protocol unnecessary.<br>&gt;<br>&gt; In order to let<br>&gt;<br>&gt; func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;<br>&gt; still compile there could be a general Swift feature to get the generic<br>&gt; type by dot syntax (e.g. synthesized typealiases for every generic<br>&gt; parameter).<br>&gt;<br>&gt; The function declaration above could be rewritten to using function like<br>&gt; parameter syntax:<br>&gt;<br>&gt;     func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;,<br>&gt; SubSequence: _&gt;){}<br>&gt;     // or omitting `SubSequence: _` since the type is already unambiguous<br>&gt;     func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;&gt;){}<br>&gt;<br>&gt; in this case there is almost no win. But as you can see in the example<br>&gt; with the protocol, generics allow for much better abstraction.<br>&gt;<br>&gt; Also where clauses could be used in generic parameter declarations which<br>&gt; are disallowed for associated types.<br>&gt;<br>&gt;<br>&gt; Maximilian<br>&gt;<br>&gt; Am 12.01.2016 um 19:19 schrieb Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually cover<br>&gt; the use cases where the associated type is *not* independent of the model<br>&gt; object (like a Sequence&#39;s Generator or a Collection&#39;s Index). Dropping that<br>&gt; information results in a lot of extra indirection at runtime, which we<br>&gt; don&#39;t want.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on<br>&gt; generics replacing associated types in protocols.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt; changed then they can be made covariant and that this will add considerable<br>&gt; utility to Swift generics.<br>&gt;<br>&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;<br>&gt;     // Current system<br>&gt;     class Top {}<br>&gt;     class Bottom: Top {}<br>&gt;<br>&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;         var value: T<br>&gt;         init(_ initialValue: T) {<br>&gt;             value = initialValue;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     let boxB = Box(Bottom())<br>&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;<br>&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt; `Box&lt;Top&gt;`.<br>&gt;<br>&gt; I am suggesting:<br>&gt;<br>&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt; 2. An implementation that allows the above covariance.<br>&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T {<br>&gt; get set } }` and that this mechanism replaces associated types for<br>&gt; protocols.<br>&gt;<br>&gt;     // Proposal:<br>&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;     // 2. Code transformed by comiler with write check for each specific,<br>&gt; generic type instance<br>&gt;     // Best approximation of resulting code in current Swift to<br>&gt; demonstrate spirit of idea:<br>&gt;<br>&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt; the underlyting representation).<br>&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;     struct BoxAnyObject {<br>&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;<br>&gt;         // Generated from stored property `var value: T` and noting that<br>&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;         private var _value: AnyObject // Access the stored property<br>&gt; through a setter so that type can be checked<br>&gt;         var value: AnyObject {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 // In all functions check that args declared as `T` are<br>&gt; actually a `T` or a sub-type.<br>&gt;                 // Note: `is` only works with type literal and there is<br>&gt; no `&gt;=` operator for types :(.<br>&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt; nearest at moment `==`.<br>&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of<br>&gt; newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(<br>&gt; T)&quot;)<br>&gt;                 _value = newValue<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s<br>&gt; upper bound is `AnyObject`.<br>&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt; AnyObject) {<br>&gt;             T = lowestCommonDeclaredT<br>&gt;             _value = initialValue<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt; be bitwise copied<br>&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt; the `T`s in the `init` call.<br>&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt; write `let bT = Box(Top())`.<br>&gt;     bT.T // Top.Type<br>&gt;     sizeofValue(bT) // 16<br>&gt;<br>&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt; would write `let bB = Box(Bottom())`.<br>&gt;     bB.T // Bottom.Type<br>&gt;     sizeofValue(bB) // 16<br>&gt;<br>&gt;     // Demonstration covariance.<br>&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;     bT.T // Bottom.Type<br>&gt;<br>&gt;     // Demonstrate generic returned type<br>&gt;     // Compiler would add cast to declared, generic type.<br>&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;<br>&gt;     // Demonstrate type safety<br>&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt; `bT = Box(Top())`.<br>&gt;     bT.value = Top() // OK<br>&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt; for types, but would work in practice<br>&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;<br>&gt; The implications of this proposal are:<br>&gt;<br>&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt; 2. A write to a stored property is type checked at runtime.<br>&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt; then they become a proper type with dynamic dispatch.<br>&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt; a generic constraint.<br>&gt; 5. The awkwardness of dealing with associated type generics is replaced by<br>&gt; a more powerful and easier to understand semantic of a type, just like the<br>&gt; other types.<br>&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt; be unnecessary.<br>&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt; arrays and fields of a generic protocol.<br>&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt; understand.<br>&gt;<br>&gt; Compatibility:<br>&gt;<br>&gt; 1. This would be a major change since associated types in protocols would<br>&gt; be replaced by generics.<br>&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt; object because the class will have extra fields, one for each generic type,<br>&gt; and therefore will be larger.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; 1. Major change.<br>&gt; 2. Object size increases.<br>&gt;<br>&gt; Thanks in advance for any comments,<br>&gt;<br>&gt;   — Howard.<br>&gt;<br>&gt; PS This is part of a collection of proposals previously presented as<br>&gt; “Protocols on Steroids”.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/c736388f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Would the optimisation I suggested in previous email address your concern<br>of needing both associated types and generics in protocols?<br></p><p>  -- Howard.<br></p><p>On 13 January 2016 at 08:31, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; AFAIK traits in Rust can have both associated types and generic type<br>&gt; parameters. I think a corresponding feature for Swift would be a net<br>&gt; positive, albeit I haven&#39;t examined the tradeoffs and advantages in any<br>&gt; detail yet.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, Jan 12, 2016 at 1:16 PM, Maximilian Hünenberger &lt;<br>&gt; m.huenenberger at me.com&gt; wrote:<br>&gt;<br>&gt;&gt; 1+ for adding generics to protocols.<br>&gt;&gt;<br>&gt;&gt; What about generics in protocols which are only a view to its associated<br>&gt;&gt; types or generics which create/are associated types?<br>&gt;&gt;<br>&gt;&gt; Example of a simple protocol which models a node of a tree:<br>&gt;&gt;<br>&gt;&gt; // Before<br>&gt;&gt;<br>&gt;&gt; // NodeType can be anything<br>&gt;&gt; // currently Swift doesn&#39;t allow<br>&gt;&gt; // `typealias NodeType: Node`<br>&gt;&gt; //<br>&gt;&gt; // or even where clauses<br>&gt;&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt;&gt; protocol Node {<br>&gt;&gt; typealias T<br>&gt;&gt; typealias NodeType<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; var value: T { get }<br>&gt;&gt; var nodes: [NodeType] { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // After<br>&gt;&gt; protocol Node&lt;T&gt; {<br>&gt;&gt; typealias T // probably remove this declaration<br>&gt;&gt; var value: T { get }<br>&gt;&gt; var nodes: [Node&lt;T&gt;] { get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; So a generic parameter is placed after the protocol name. Therefore a<br>&gt;&gt; corresponding associated type could be synthesized making its declaration<br>&gt;&gt; in the body of the protocol unnecessary.<br>&gt;&gt;<br>&gt;&gt; In order to let<br>&gt;&gt;<br>&gt;&gt; func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;&gt;<br>&gt;&gt; still compile there could be a general Swift feature to get the generic<br>&gt;&gt; type by dot syntax (e.g. synthesized typealiases for every generic<br>&gt;&gt; parameter).<br>&gt;&gt;<br>&gt;&gt; The function declaration above could be rewritten to using function like<br>&gt;&gt; parameter syntax:<br>&gt;&gt;<br>&gt;&gt;     func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;,<br>&gt;&gt; SubSequence: _&gt;){}<br>&gt;&gt;     // or omitting `SubSequence: _` since the type is already unambiguous<br>&gt;&gt;     func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;<br>&gt;&gt; in this case there is almost no win. But as you can see in the example<br>&gt;&gt; with the protocol, generics allow for much better abstraction.<br>&gt;&gt;<br>&gt;&gt; Also where clauses could be used in generic parameter declarations which<br>&gt;&gt; are disallowed for associated types.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Maximilian<br>&gt;&gt;<br>&gt;&gt; Am 12.01.2016 um 19:19 schrieb Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually<br>&gt;&gt; cover the use cases where the associated type is *not* independent of<br>&gt;&gt; the model object (like a Sequence&#39;s Generator or a Collection&#39;s Index).<br>&gt;&gt; Dropping that information results in a lot of extra indirection at runtime,<br>&gt;&gt; which we don&#39;t want.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on<br>&gt;&gt; generics replacing associated types in protocols.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt;&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt;&gt; changed then they can be made covariant and that this will add considerable<br>&gt;&gt; utility to Swift generics.<br>&gt;&gt;<br>&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;<br>&gt;&gt;     // Current system<br>&gt;&gt;     class Top {}<br>&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;<br>&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;         var value: T<br>&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;             value = initialValue;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;<br>&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt;&gt; `Box&lt;Top&gt;`.<br>&gt;&gt;<br>&gt;&gt; I am suggesting:<br>&gt;&gt;<br>&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T<br>&gt;&gt; { get set } }` and that this mechanism replaces associated types for<br>&gt;&gt; protocols.<br>&gt;&gt;<br>&gt;&gt;     // Proposal:<br>&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as<br>&gt;&gt; before<br>&gt;&gt;     // 2. Code transformed by comiler with write check for each<br>&gt;&gt; specific, generic type instance<br>&gt;&gt;     // Best approximation of resulting code in current Swift to<br>&gt;&gt; demonstrate spirit of idea:<br>&gt;&gt;<br>&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt;&gt; the underlyting representation).<br>&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt;&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;<br>&gt;&gt;         // Generated from stored property `var value: T` and noting that<br>&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         private var _value: AnyObject // Access the stored property<br>&gt;&gt; through a setter so that type can be checked<br>&gt;&gt;         var value: AnyObject {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 // In all functions check that args declared as `T` are<br>&gt;&gt; actually a `T` or a sub-type.<br>&gt;&gt;                 // Note: `is` only works with type literal and there is<br>&gt;&gt; no `&gt;=` operator for types :(.<br>&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt;&gt; nearest at moment `==`.<br>&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type<br>&gt;&gt; of newValue, \(newValue.dynamicType), is not a sub-type of generic type<br>&gt;&gt; T, \(T)&quot;)<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that<br>&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt;&gt; AnyObject) {<br>&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;             _value = initialValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt;&gt; be bitwise copied<br>&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt;&gt; the `T`s in the `init` call.<br>&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt;&gt; write `let bT = Box(Top())`.<br>&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;<br>&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt;&gt; would write `let bB = Box(Bottom())`.<br>&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;<br>&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt;&gt; `bT = Box(Top())`.<br>&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt;&gt; for types, but would work in practice<br>&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;<br>&gt;&gt; The implications of this proposal are:<br>&gt;&gt;<br>&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt;&gt; then they become a proper type with dynamic dispatch.<br>&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt;&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt;&gt; a generic constraint.<br>&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced<br>&gt;&gt; by a more powerful and easier to understand semantic of a type, just like<br>&gt;&gt; the other types.<br>&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt;&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt;&gt; be unnecessary.<br>&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt;&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;<br>&gt;&gt; Advantages:<br>&gt;&gt;<br>&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt;&gt; arrays and fields of a generic protocol.<br>&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt;&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt;&gt; understand.<br>&gt;&gt;<br>&gt;&gt; Compatibility:<br>&gt;&gt;<br>&gt;&gt; 1. This would be a major change since associated types in protocols would<br>&gt;&gt; be replaced by generics.<br>&gt;&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt;&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt;&gt; object because the class will have extra fields, one for each generic type,<br>&gt;&gt; and therefore will be larger.<br>&gt;&gt;<br>&gt;&gt; Disadvantages:<br>&gt;&gt;<br>&gt;&gt; 1. Major change.<br>&gt;&gt; 2. Object size increases.<br>&gt;&gt;<br>&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;<br>&gt;&gt;   — Howard.<br>&gt;&gt;<br>&gt;&gt; PS This is part of a collection of proposals previously presented as<br>&gt;&gt; “Protocols on Steroids”.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/9f86c33d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>@Maximilian,<br></p><p>You can hand code your `Node` example using the conversions I outlined<br>(this is what I do in my code):<br></p><p>protocol Node {<br>var T: Any.Type<br>var value: T { get }<br>var nodeLeft: Node { get } // Changed to nodeLeft and nodeRight because<br>arrays aren&#39;t covariant!<br>var nodeRight: Node { get } // Changed to nodeLeft and nodeRight because<br>arrays aren&#39;t covariant!<br></p><p>        // One of the benefits of the proposal is that arrays would become<br>covariant.<br></p><p>}<br></p><p><br>Then when you want a `NodeInt` you would write:<br></p><p>struct GenericNodeInt: Node {<br>var T: Any.Type {<br></p><p>            return Int.self<br>        }<br></p><p>let value: Any<br></p><p>let nodeLeft: Node<br></p><p>let nodeRight: Node<br></p><p>        init(value: Any, nodeLeft: Node, nodeRight: Node) {<br></p><p>      precondition(value is Int, &quot;Type of value, \(newValue.dynamicType),<br>is not \(Int.self)&quot;)<br></p><p>      self.value = value<br></p><p>      precondition(nodeLeft.T is Int, &quot;Type of nodeLeft.T, \(newValue.<br>dynamicType), is not \(Int.self)&quot;)<br></p><p>      self.nodeLeft = nodeLeft<br></p><p>      precondition(nodeRight.T is Int, &quot;Type of nodeRight.T, \(newValue.<br>dynamicType), is not \(Int.self)&quot;)<br></p><p>      self.nodeRight = nodeRight<br></p><p>        }<br></p><p>}<br></p><p><br>If performance was an issue you would also write:<br></p><p>struct NodeInt {<br>var T: Int.Type {<br></p><p>            return Int.self<br>        }<br></p><p>let value: Int<br></p><p>let nodeLeft: NodeInt<br></p><p>let nodeRight: NodeInt<br></p><p>        var toGenericNodeInt: GenericNodeInt {<br></p><p>      return GenericNodeInt(value: value, nodeLeft: nodeLeft, nodeRight:<br>nodeRight)<br></p><p>        }<br></p><p>}<br></p><p>And use `NodeInt` everywhere accept when you need the genericity and then<br>call `toGenericNodeInt`.<br></p><p>If the proposal was accepted it would take all this boilerplate code out :)<br></p><p><br>On 13 January 2016 at 08:16, Maximilian Hünenberger &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; 1+ for adding generics to protocols.<br>&gt;<br>&gt; What about generics in protocols which are only a view to its associated<br>&gt; types or generics which create/are associated types?<br>&gt;<br>&gt; Example of a simple protocol which models a node of a tree:<br>&gt;<br>&gt; // Before<br>&gt;<br>&gt; // NodeType can be anything<br>&gt; // currently Swift doesn&#39;t allow<br>&gt; // `typealias NodeType: Node`<br>&gt; //<br>&gt; // or even where clauses<br>&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt; protocol Node {<br>&gt; typealias T<br>&gt; typealias NodeType<br>&gt;<br>&gt;<br>&gt; var value: T { get }<br>&gt; var nodes: [NodeType] { get }<br>&gt; }<br>&gt;<br>&gt; // After<br>&gt; protocol Node&lt;T&gt; {<br>&gt; typealias T // probably remove this declaration<br>&gt; var value: T { get }<br>&gt; var nodes: [Node&lt;T&gt;] { get }<br>&gt; }<br>&gt;<br>&gt; So a generic parameter is placed after the protocol name. Therefore a<br>&gt; corresponding associated type could be synthesized making its declaration<br>&gt; in the body of the protocol unnecessary.<br>&gt;<br>&gt; In order to let<br>&gt;<br>&gt; func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;<br>&gt; still compile there could be a general Swift feature to get the generic<br>&gt; type by dot syntax (e.g. synthesized typealiases for every generic<br>&gt; parameter).<br>&gt;<br>&gt; The function declaration above could be rewritten to using function like<br>&gt; parameter syntax:<br>&gt;<br>&gt;     func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;,<br>&gt; SubSequence: _&gt;){}<br>&gt;     // or omitting `SubSequence: _` since the type is already unambiguous<br>&gt;     func afunction(s: SequenceType&lt;Generator: GeneratorType&lt;Int&gt;&gt;){}<br>&gt;<br>&gt; in this case there is almost no win. But as you can see in the example<br>&gt; with the protocol, generics allow for much better abstraction.<br>&gt;<br>&gt; Also where clauses could be used in generic parameter declarations which<br>&gt; are disallowed for associated types.<br>&gt;<br>&gt;<br>&gt; Maximilian<br>&gt;<br>&gt; Am 12.01.2016 um 19:19 schrieb Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually cover<br>&gt; the use cases where the associated type is *not* independent of the model<br>&gt; object (like a Sequence&#39;s Generator or a Collection&#39;s Index). Dropping that<br>&gt; information results in a lot of extra indirection at runtime, which we<br>&gt; don&#39;t want.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on<br>&gt; generics replacing associated types in protocols.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt; changed then they can be made covariant and that this will add considerable<br>&gt; utility to Swift generics.<br>&gt;<br>&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;<br>&gt;     // Current system<br>&gt;     class Top {}<br>&gt;     class Bottom: Top {}<br>&gt;<br>&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;         var value: T<br>&gt;         init(_ initialValue: T) {<br>&gt;             value = initialValue;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     let boxB = Box(Bottom())<br>&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;<br>&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt; `Box&lt;Top&gt;`.<br>&gt;<br>&gt; I am suggesting:<br>&gt;<br>&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt; 2. An implementation that allows the above covariance.<br>&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T {<br>&gt; get set } }` and that this mechanism replaces associated types for<br>&gt; protocols.<br>&gt;<br>&gt;     // Proposal:<br>&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;     // 2. Code transformed by comiler with write check for each specific,<br>&gt; generic type instance<br>&gt;     // Best approximation of resulting code in current Swift to<br>&gt; demonstrate spirit of idea:<br>&gt;<br>&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt; the underlyting representation).<br>&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;     struct BoxAnyObject {<br>&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;<br>&gt;         // Generated from stored property `var value: T` and noting that<br>&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;         private var _value: AnyObject // Access the stored property<br>&gt; through a setter so that type can be checked<br>&gt;         var value: AnyObject {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 // In all functions check that args declared as `T` are<br>&gt; actually a `T` or a sub-type.<br>&gt;                 // Note: `is` only works with type literal and there is<br>&gt; no `&gt;=` operator for types :(.<br>&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt; nearest at moment `==`.<br>&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of<br>&gt; newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(<br>&gt; T)&quot;)<br>&gt;                 _value = newValue<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s<br>&gt; upper bound is `AnyObject`.<br>&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt; AnyObject) {<br>&gt;             T = lowestCommonDeclaredT<br>&gt;             _value = initialValue<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt; be bitwise copied<br>&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt; the `T`s in the `init` call.<br>&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt; write `let bT = Box(Top())`.<br>&gt;     bT.T // Top.Type<br>&gt;     sizeofValue(bT) // 16<br>&gt;<br>&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt; would write `let bB = Box(Bottom())`.<br>&gt;     bB.T // Bottom.Type<br>&gt;     sizeofValue(bB) // 16<br>&gt;<br>&gt;     // Demonstration covariance.<br>&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;     bT.T // Bottom.Type<br>&gt;<br>&gt;     // Demonstrate generic returned type<br>&gt;     // Compiler would add cast to declared, generic type.<br>&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;<br>&gt;     // Demonstrate type safety<br>&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt; `bT = Box(Top())`.<br>&gt;     bT.value = Top() // OK<br>&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt; for types, but would work in practice<br>&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;<br>&gt; The implications of this proposal are:<br>&gt;<br>&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt; 2. A write to a stored property is type checked at runtime.<br>&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt; then they become a proper type with dynamic dispatch.<br>&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt; a generic constraint.<br>&gt; 5. The awkwardness of dealing with associated type generics is replaced by<br>&gt; a more powerful and easier to understand semantic of a type, just like the<br>&gt; other types.<br>&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt; be unnecessary.<br>&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt; arrays and fields of a generic protocol.<br>&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt; understand.<br>&gt;<br>&gt; Compatibility:<br>&gt;<br>&gt; 1. This would be a major change since associated types in protocols would<br>&gt; be replaced by generics.<br>&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt; object because the class will have extra fields, one for each generic type,<br>&gt; and therefore will be larger.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; 1. Major change.<br>&gt; 2. Object size increases.<br>&gt;<br>&gt; Thanks in advance for any comments,<br>&gt;<br>&gt;   — Howard.<br>&gt;<br>&gt; PS This is part of a collection of proposals previously presented as<br>&gt; “Protocols on Steroids”.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/a0cbf4d8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 12:00:00pm</p></header><div class="content"><p>@Jordan &amp; Austin,<br></p><p>You raise two issues covariance and overhead of generic protocols instead<br>of associated types in protocols.<br></p><p>Having used opt in covariance in other languages, Java &amp; Scala, I am not a<br>fan. You end up littering all your code with a covariance annotation. Just<br>look at any Java or Scala code, look at their libraries. Also when Sun ran<br>there project coin, vaguely similar to swift-evolution, there was a ton of<br>correspondence saying that people wanted covariance by default. The<br>official answer from Oracle was that they wished they had made covariance<br>the default but it was now too late to change; therefore there is strong<br>presidency for covariance by default.<br></p><p>There is some overhead with the approach I suggested, however I think that<br>the compiler can eliminate it. I will use the measure `sizeofValue` as a<br>proxy for any type of overhead (space or time). I chose this because it is<br>easy and because it is likely to be true that if `sizeofValue` return the<br>same size then the overhead is likely the same. Consider a `Boxable`<br>protocol and then an `Int` specialisation of that protocol.<br></p><p>User writes:<br></p><p>    protocol Boxable&lt;T&gt; {<br></p><p>        var value: Any { get set }<br></p><p>    }<br></p><p>This gets translated, as per proposal, into:<br></p><p>    // Size test for a generic protocol and generic struct as per proposal<br>and optimisation<br></p><p>    protocol Boxable { // User would write `protocol Boxable&lt;T&gt; { var<br>value: T { get set } }`.<br></p><p>        var T: Any.Type { get }<br></p><p>        var value: Any { get set }<br></p><p>    }<br></p><p><br>Then the user wants an `Int` specialisation:<br></p><p>    struct BoxInt: Boxable&lt;T&gt; {<br></p><p>        var value: Int<br></p><p>    }<br></p><p><br>This gets translated, as per proposal, into:<br></p><p>    struct BoxInt: Boxable { // User would write `struct BoxInt:<br>Boxable&lt;Int&gt; { var value: Int }`.<br></p><p>        // No need for a stored property becuse `Int` is a struct and<br>cannot be sub-classed.<br></p><p>        var T: Any.Type { // Compiler generated, user would not write<br>anything<br></p><p>            return Int.self<br></p><p>        }<br></p><p><br></p><p>        var _value: Any // From user written `var value: Int`.<br></p><p>        var value: Any {<br></p><p>            get {<br></p><p>                return _value<br></p><p>            }<br></p><p>            set {<br></p><p>                precondition(newValue is Int, &quot;Type of newValue, \(newValue.<br>dynamicType), is not \(Int.self)&quot;)<br></p><p>                _value = newValue<br></p><p>            }<br></p><p>        }<br></p><p><br></p><p>        // No need for `lowestCommonDeclaredT` arg becuse `Int` is a struct<br>and cannot be sub-classed.<br></p><p>        init(value: Any) { // Compiler generated, user would not write<br>anything<br></p><p>            _value = value<br></p><p>        }<br></p><p>    }<br></p><p><br>There is some overhead:<br></p><p><br>    let bI = BoxInt(value: 1)<br></p><p>    sizeofValue(bI) // 32, i.e. `BoxInt (due to `value: Any`) has overhead<br>since an `Int` size is 8<br></p><p>    let boxable: Boxable = bI<br></p><p>    sizeofValue(boxable) // 40, i.e. generic protocol has same overhead as<br>non-generic protocol<br></p><p><br>Encouragingly, once you type as a protocol, whether the protocol is a<br>proposed generic protocol or a non-generic protocol the overhead in the<br>same. However `BoxInt` is certainly more overhead than `Int`.<br></p><p>Fortunately the compiler can optimise it away:<br></p><p><br>    struct NonGenericBoxInt { // Also generated from `struct BoxInt:<br>Boxable&lt;Int&gt; { var value: Int }`<br></p><p>        var value: Int<br></p><p>        var toBoxInt: BoxInt {<br></p><p>            return BoxInt(value: value)<br></p><p>        }<br></p><p>    }<br></p><p><br>    let nGBI = NonGenericBoxInt(value: 1)<br></p><p>    sizeofValue(nGBI) // 8, i.e. `NonGenericBoxInt has zero overhead<br></p><p>When the user writes `BoxInt` the compiler substitutes `NonGenericBoxInt`<br>and when the user covariantly assigns to the protocol `Boxable` the<br>compiler calls `toBoxInt`.<br></p><p>Therefore the original proposal could be extended to include this<br>optimisation.<br></p><p>Hopefully therefore this `efficiency` question is addressed?<br></p><p>Thanks for the feedback,<br></p><p>  -- Howard.<br></p><p>On 13 January 2016 at 05:19, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually cover<br>&gt; the use cases where the associated type is *not* independent of the model<br>&gt; object (like a Sequence&#39;s Generator or a Collection&#39;s Index). Dropping that<br>&gt; information results in a lot of extra indirection at runtime, which we<br>&gt; don&#39;t want.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on<br>&gt; generics replacing associated types in protocols.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt; changed then they can be made covariant and that this will add considerable<br>&gt; utility to Swift generics.<br>&gt;<br>&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;<br>&gt;     // Current system<br>&gt;     class Top {}<br>&gt;     class Bottom: Top {}<br>&gt;<br>&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;         var value: T<br>&gt;         init(_ initialValue: T) {<br>&gt;             value = initialValue;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     let boxB = Box(Bottom())<br>&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;<br>&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt; `Box&lt;Top&gt;`.<br>&gt;<br>&gt; I am suggesting:<br>&gt;<br>&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt; 2. An implementation that allows the above covariance.<br>&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T {<br>&gt; get set } }` and that this mechanism replaces associated types for<br>&gt; protocols.<br>&gt;<br>&gt;     // Proposal:<br>&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;     // 2. Code transformed by comiler with write check for each specific,<br>&gt; generic type instance<br>&gt;     // Best approximation of resulting code in current Swift to<br>&gt; demonstrate spirit of idea:<br>&gt;<br>&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt; the underlyting representation).<br>&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;     struct BoxAnyObject {<br>&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;<br>&gt;         // Generated from stored property `var value: T` and noting that<br>&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;         private var _value: AnyObject // Access the stored property<br>&gt; through a setter so that type can be checked<br>&gt;         var value: AnyObject {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 // In all functions check that args declared as `T` are<br>&gt; actually a `T` or a sub-type.<br>&gt;                 // Note: `is` only works with type literal and there is<br>&gt; no `&gt;=` operator for types :(.<br>&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt; nearest at moment `==`.<br>&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of<br>&gt; newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(<br>&gt; T)&quot;)<br>&gt;                 _value = newValue<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s<br>&gt; upper bound is `AnyObject`.<br>&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt; AnyObject) {<br>&gt;             T = lowestCommonDeclaredT<br>&gt;             _value = initialValue<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt; be bitwise copied<br>&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt; the `T`s in the `init` call.<br>&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt; write `let bT = Box(Top())`.<br>&gt;     bT.T // Top.Type<br>&gt;     sizeofValue(bT) // 16<br>&gt;<br>&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt; would write `let bB = Box(Bottom())`.<br>&gt;     bB.T // Bottom.Type<br>&gt;     sizeofValue(bB) // 16<br>&gt;<br>&gt;     // Demonstration covariance.<br>&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;     bT.T // Bottom.Type<br>&gt;<br>&gt;     // Demonstrate generic returned type<br>&gt;     // Compiler would add cast to declared, generic type.<br>&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;<br>&gt;     // Demonstrate type safety<br>&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt; `bT = Box(Top())`.<br>&gt;     bT.value = Top() // OK<br>&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt; for types, but would work in practice<br>&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;<br>&gt; The implications of this proposal are:<br>&gt;<br>&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt; 2. A write to a stored property is type checked at runtime.<br>&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt; then they become a proper type with dynamic dispatch.<br>&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt; a generic constraint.<br>&gt; 5. The awkwardness of dealing with associated type generics is replaced by<br>&gt; a more powerful and easier to understand semantic of a type, just like the<br>&gt; other types.<br>&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt; be unnecessary.<br>&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt; arrays and fields of a generic protocol.<br>&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt; understand.<br>&gt;<br>&gt; Compatibility:<br>&gt;<br>&gt; 1. This would be a major change since associated types in protocols would<br>&gt; be replaced by generics.<br>&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt; object because the class will have extra fields, one for each generic type,<br>&gt; and therefore will be larger.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; 1. Major change.<br>&gt; 2. Object size increases.<br>&gt;<br>&gt; Thanks in advance for any comments,<br>&gt;<br>&gt;   — Howard.<br>&gt;<br>&gt; PS This is part of a collection of proposals previously presented as<br>&gt; “Protocols on Steroids”.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/91fbc45d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 12, 2016 at 05:00:00pm</p></header><div class="content"><p>I posted this in your original thread; I am strongly against the notion<br>that slightly prettier code is worth making the type system unsound, nor is<br>it worth the performance hit from the necessary runtime checks (even if<br>some fraction of them can be optimized out by the compiler).<br></p><p>In terms of getting rid of associated types, I think that any such proposal<br>should also include a description of how SequenceType is to be rewritten<br>using the new system, both in terms of implementation as well as usage in<br>APIs.<br></p><p>Austin<br></p><p>On Tue, Jan 12, 2016 at 5:31 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>wrote:<br></p><p>&gt; @Jordan &amp; Austin,<br>&gt;<br>&gt; You raise two issues covariance and overhead of generic protocols instead<br>&gt; of associated types in protocols.<br>&gt;<br>&gt; Having used opt in covariance in other languages, Java &amp; Scala, I am not a<br>&gt; fan. You end up littering all your code with a covariance annotation. Just<br>&gt; look at any Java or Scala code, look at their libraries. Also when Sun ran<br>&gt; there project coin, vaguely similar to swift-evolution, there was a ton of<br>&gt; correspondence saying that people wanted covariance by default. The<br>&gt; official answer from Oracle was that they wished they had made covariance<br>&gt; the default but it was now too late to change; therefore there is strong<br>&gt; presidency for covariance by default.<br>&gt;<br>&gt; There is some overhead with the approach I suggested, however I think that<br>&gt; the compiler can eliminate it. I will use the measure `sizeofValue` as a<br>&gt; proxy for any type of overhead (space or time). I chose this because it is<br>&gt; easy and because it is likely to be true that if `sizeofValue` return the<br>&gt; same size then the overhead is likely the same. Consider a `Boxable`<br>&gt; protocol and then an `Int` specialisation of that protocol.<br>&gt;<br>&gt; User writes:<br>&gt;<br>&gt;     protocol Boxable&lt;T&gt; {<br>&gt;<br>&gt;         var value: Any { get set }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; This gets translated, as per proposal, into:<br>&gt;<br>&gt;     // Size test for a generic protocol and generic struct as per proposal<br>&gt; and optimisation<br>&gt;<br>&gt;     protocol Boxable { // User would write `protocol Boxable&lt;T&gt; { var<br>&gt; value: T { get set } }`.<br>&gt;<br>&gt;         var T: Any.Type { get }<br>&gt;<br>&gt;         var value: Any { get set }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; Then the user wants an `Int` specialisation:<br>&gt;<br>&gt;     struct BoxInt: Boxable&lt;T&gt; {<br>&gt;<br>&gt;         var value: Int<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; This gets translated, as per proposal, into:<br>&gt;<br>&gt;     struct BoxInt: Boxable { // User would write `struct BoxInt:<br>&gt; Boxable&lt;Int&gt; { var value: Int }`.<br>&gt;<br>&gt;         // No need for a stored property becuse `Int` is a struct and<br>&gt; cannot be sub-classed.<br>&gt;<br>&gt;         var T: Any.Type { // Compiler generated, user would not write<br>&gt; anything<br>&gt;<br>&gt;             return Int.self<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;<br>&gt;         var _value: Any // From user written `var value: Int`.<br>&gt;<br>&gt;         var value: Any {<br>&gt;<br>&gt;             get {<br>&gt;<br>&gt;                 return _value<br>&gt;<br>&gt;             }<br>&gt;<br>&gt;             set {<br>&gt;<br>&gt;                 precondition(newValue is Int, &quot;Type of newValue, \(<br>&gt; newValue.dynamicType), is not \(Int.self)&quot;)<br>&gt;<br>&gt;                 _value = newValue<br>&gt;<br>&gt;             }<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;<br>&gt;         // No need for `lowestCommonDeclaredT` arg becuse `Int` is a<br>&gt; struct and cannot be sub-classed.<br>&gt;<br>&gt;         init(value: Any) { // Compiler generated, user would not write<br>&gt; anything<br>&gt;<br>&gt;             _value = value<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt; There is some overhead:<br>&gt;<br>&gt;<br>&gt;     let bI = BoxInt(value: 1)<br>&gt;<br>&gt;     sizeofValue(bI) // 32, i.e. `BoxInt (due to `value: Any`) has<br>&gt; overhead since an `Int` size is 8<br>&gt;<br>&gt;     let boxable: Boxable = bI<br>&gt;<br>&gt;     sizeofValue(boxable) // 40, i.e. generic protocol has same overhead<br>&gt; as non-generic protocol<br>&gt;<br>&gt;<br>&gt; Encouragingly, once you type as a protocol, whether the protocol is a<br>&gt; proposed generic protocol or a non-generic protocol the overhead in the<br>&gt; same. However `BoxInt` is certainly more overhead than `Int`.<br>&gt;<br>&gt; Fortunately the compiler can optimise it away:<br>&gt;<br>&gt;<br>&gt;     struct NonGenericBoxInt { // Also generated from `struct BoxInt:<br>&gt; Boxable&lt;Int&gt; { var value: Int }`<br>&gt;<br>&gt;         var value: Int<br>&gt;<br>&gt;         var toBoxInt: BoxInt {<br>&gt;<br>&gt;             return BoxInt(value: value)<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     let nGBI = NonGenericBoxInt(value: 1)<br>&gt;<br>&gt;     sizeofValue(nGBI) // 8, i.e. `NonGenericBoxInt has zero overhead<br>&gt;<br>&gt; When the user writes `BoxInt` the compiler substitutes `NonGenericBoxInt`<br>&gt; and when the user covariantly assigns to the protocol `Boxable` the<br>&gt; compiler calls `toBoxInt`.<br>&gt;<br>&gt; Therefore the original proposal could be extended to include this<br>&gt; optimisation.<br>&gt;<br>&gt; Hopefully therefore this `efficiency` question is addressed?<br>&gt;<br>&gt; Thanks for the feedback,<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 13 January 2016 at 05:19, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually<br>&gt;&gt; cover the use cases where the associated type is *not* independent of<br>&gt;&gt; the model object (like a Sequence&#39;s Generator or a Collection&#39;s Index).<br>&gt;&gt; Dropping that information results in a lot of extra indirection at runtime,<br>&gt;&gt; which we don&#39;t want.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1 on<br>&gt;&gt; generics replacing associated types in protocols.<br>&gt;&gt;<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt;&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt;&gt; changed then they can be made covariant and that this will add considerable<br>&gt;&gt; utility to Swift generics.<br>&gt;&gt;<br>&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;<br>&gt;&gt;     // Current system<br>&gt;&gt;     class Top {}<br>&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;<br>&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;         var value: T<br>&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;             value = initialValue;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;<br>&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt;&gt; `Box&lt;Top&gt;`.<br>&gt;&gt;<br>&gt;&gt; I am suggesting:<br>&gt;&gt;<br>&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T<br>&gt;&gt; { get set } }` and that this mechanism replaces associated types for<br>&gt;&gt; protocols.<br>&gt;&gt;<br>&gt;&gt;     // Proposal:<br>&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as<br>&gt;&gt; before<br>&gt;&gt;     // 2. Code transformed by comiler with write check for each<br>&gt;&gt; specific, generic type instance<br>&gt;&gt;     // Best approximation of resulting code in current Swift to<br>&gt;&gt; demonstrate spirit of idea:<br>&gt;&gt;<br>&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt;&gt; the underlyting representation).<br>&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt;&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;<br>&gt;&gt;         // Generated from stored property `var value: T` and noting that<br>&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         private var _value: AnyObject // Access the stored property<br>&gt;&gt; through a setter so that type can be checked<br>&gt;&gt;         var value: AnyObject {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 // In all functions check that args declared as `T` are<br>&gt;&gt; actually a `T` or a sub-type.<br>&gt;&gt;                 // Note: `is` only works with type literal and there is<br>&gt;&gt; no `&gt;=` operator for types :(.<br>&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt;&gt; nearest at moment `==`.<br>&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type<br>&gt;&gt; of newValue, \(newValue.dynamicType), is not a sub-type of generic type<br>&gt;&gt; T, \(T)&quot;)<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that<br>&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt;&gt; AnyObject) {<br>&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;             _value = initialValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt;&gt; be bitwise copied<br>&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt;&gt; the `T`s in the `init` call.<br>&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt;&gt; write `let bT = Box(Top())`.<br>&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;<br>&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt;&gt; would write `let bB = Box(Bottom())`.<br>&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;<br>&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt;&gt; `bT = Box(Top())`.<br>&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt;&gt; for types, but would work in practice<br>&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;<br>&gt;&gt; The implications of this proposal are:<br>&gt;&gt;<br>&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt;&gt; then they become a proper type with dynamic dispatch.<br>&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt;&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt;&gt; a generic constraint.<br>&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced<br>&gt;&gt; by a more powerful and easier to understand semantic of a type, just like<br>&gt;&gt; the other types.<br>&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt;&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt;&gt; be unnecessary.<br>&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt;&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;<br>&gt;&gt; Advantages:<br>&gt;&gt;<br>&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt;&gt; arrays and fields of a generic protocol.<br>&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt;&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt;&gt; understand.<br>&gt;&gt;<br>&gt;&gt; Compatibility:<br>&gt;&gt;<br>&gt;&gt; 1. This would be a major change since associated types in protocols would<br>&gt;&gt; be replaced by generics.<br>&gt;&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt;&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt;&gt; object because the class will have extra fields, one for each generic type,<br>&gt;&gt; and therefore will be larger.<br>&gt;&gt;<br>&gt;&gt; Disadvantages:<br>&gt;&gt;<br>&gt;&gt; 1. Major change.<br>&gt;&gt; 2. Object size increases.<br>&gt;&gt;<br>&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;<br>&gt;&gt;   — Howard.<br>&gt;&gt;<br>&gt;&gt; PS This is part of a collection of proposals previously presented as<br>&gt;&gt; “Protocols on Steroids”.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/a3dfe5e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>@Austin,<br></p><p>I don&#39;t see a problem with the collections in general, that&#39;s why I chose<br>`Box` as an example - the smallest possible collection!<br></p><p>Is this what you had in mind?<br></p><p>//: Use a Box as an example of a minimal collection, a colection of exactly<br>one value!<br></p><p><br>//: - note:<br></p><p>//: In earlier examples I used the generic type name as the feild name<br>directly, in practice you need a unique name.<br></p><p>//: I would propose TypeName.GenericName for the unique name?<br></p><p>//: In examples below I have used TypeNameGenericName as the nearest<br>approximation possible at present.<br></p><p>//: I chose upper case, but maybe lower case better?<br></p><p>//: Maybe the syntax without a . is good enough?<br></p><p><br>//:     protocol Boxable&lt;T&gt; { var value: T { get set } }<br></p><p>protocol Boxable {<br></p><p>    var BoxableT: Any.Type { get }<br></p><p>    var value: Any { get set }<br></p><p>}<br></p><p><br>//:     protocol Generatable&lt;T&gt; { var generator: Generator&lt;T&gt; { get } }<br></p><p>protocol Generatable {<br></p><p>    var GeneratableT: Any.Type { get }<br></p><p>    var generator: Generator { get }<br></p><p>}<br></p><p><br>//:     struct Box&lt;T&gt;: Boxable&lt;T&gt;, Generatable&lt;T&gt; {<br></p><p>//:         var value: T<br></p><p>//:         var generator: Generator&lt;T&gt; { return BoxGenerator(box: self) }<br></p><p>//:     }<br></p><p>struct Box: Boxable, Generatable {<br></p><p>    let BoxT: Any.Type // Box only has one &#39;real&#39; generic type BoxT<br></p><p>    var BoxableT: Any.Type { // BoxableT declared as same as BoxT<br>(Boxable&lt;T&gt;)<br></p><p>        return BoxT<br></p><p>    }<br></p><p>    var GeneratableT: Any.Type { // GeneratableT declared as same as BoxT<br>(Generatable&lt;T&gt;)<br></p><p>        return BoxT<br></p><p>    }<br></p><p><br></p><p>    private var _value: Any<br></p><p>    var value: Any {<br></p><p>        get {<br></p><p>            return _value<br></p><p>        }<br></p><p>        set {<br></p><p>            precondition(BoxT == /* &gt;= */ newValue.dynamicType, &quot;Type of<br>newValue, \(newValue.dynamicType), is not a sub-type of generic type BoxT, \<br>(BoxT)&quot;)<br></p><p>            _value = newValue<br></p><p>        }<br></p><p>    }<br></p><p><br></p><p>    var generator: Generator {<br></p><p>        return BoxGenerator(BoxT, box: self)<br></p><p>    }<br></p><p><br></p><p>    // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper<br>bound is `AnyObject`.<br></p><p>    init(_ lowestCommonDeclaredT: Any.Type, value: Any) {<br></p><p>        BoxT = lowestCommonDeclaredT<br></p><p>        _value = value<br></p><p>    }<br></p><p>}<br></p><p><br>//:     protocol Generator&lt;T&gt; { var next: T? { get } }<br></p><p>protocol Generator {<br></p><p>    var GeneratorT: Any.Type { get }<br></p><p>    var next: Any? { get }<br></p><p>}<br></p><p><br>//:     class BoxGenerator&lt;T&gt;: Generator&lt;T&gt; {<br></p><p>//:         private var isFinished = false<br></p><p>//:         private let box: Box&lt;t&gt;<br></p><p>//:         var next: T? {<br></p><p>//:             if isFinished { return nil }<br></p><p>//:             isFinished = true<br></p><p>//:             return box.value<br></p><p>//:         }<br></p><p>//:         init(box: Box&lt;T&gt;) {<br></p><p>//:             self.box = box<br></p><p>//:         }<br></p><p>//:     }<br></p><p>class BoxGenerator: Generator {<br></p><p>    let BoxGeneratorT: Any.Type<br></p><p>    var GeneratorT: Any.Type {<br></p><p>        return BoxGeneratorT<br></p><p>    }<br></p><p>    private var isFinished = false<br></p><p>    private let box: Box<br></p><p>    var next: Any? {<br></p><p>        if isFinished { return nil }<br></p><p>        isFinished = true<br></p><p>        return box.value<br></p><p>    }<br></p><p>    init(_ lowestCommonDeclaredT: Any.Type, box: Box) {<br></p><p>        self.BoxGeneratorT = lowestCommonDeclaredT<br></p><p>        self.box = box<br></p><p>    }<br></p><p>}<br></p><p><br>//:     let ints = Box(value: 1)<br></p><p>let ints = Box(Int.self, value: 1) // Box&lt;Int&gt;, compiler determins declared<br>type<br></p><p>sizeofValue(ints) // 40<br></p><p>let intsGen = ints.generator // BoxGenerator&lt;Int&gt;<br></p><p>sizeofValue(intsGen) // 40<br></p><p>intsGen.next as! Int? // 1, compiler adds cast<br></p><p>intsGen.next as! Int? // nil, compiler adds cast<br></p><p><br>Do you have something else in mind? Happy to take a look at *short*<br>examples?<br></p><p> -- Howard.<br></p><p>On 13 January 2016 at 12:37, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; I posted this in your original thread; I am strongly against the notion<br>&gt; that slightly prettier code is worth making the type system unsound, nor is<br>&gt; it worth the performance hit from the necessary runtime checks (even if<br>&gt; some fraction of them can be optimized out by the compiler).<br>&gt;<br>&gt; In terms of getting rid of associated types, I think that any such<br>&gt; proposal should also include a description of how SequenceType is to be<br>&gt; rewritten using the new system, both in terms of implementation as well as<br>&gt; usage in APIs.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, Jan 12, 2016 at 5:31 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; @Jordan &amp; Austin,<br>&gt;&gt;<br>&gt;&gt; You raise two issues covariance and overhead of generic protocols instead<br>&gt;&gt; of associated types in protocols.<br>&gt;&gt;<br>&gt;&gt; Having used opt in covariance in other languages, Java &amp; Scala, I am not<br>&gt;&gt; a fan. You end up littering all your code with a covariance annotation.<br>&gt;&gt; Just look at any Java or Scala code, look at their libraries. Also when Sun<br>&gt;&gt; ran there project coin, vaguely similar to swift-evolution, there was a ton<br>&gt;&gt; of correspondence saying that people wanted covariance by default. The<br>&gt;&gt; official answer from Oracle was that they wished they had made covariance<br>&gt;&gt; the default but it was now too late to change; therefore there is strong<br>&gt;&gt; presidency for covariance by default.<br>&gt;&gt;<br>&gt;&gt; There is some overhead with the approach I suggested, however I think<br>&gt;&gt; that the compiler can eliminate it. I will use the measure `sizeofValue` as<br>&gt;&gt; a proxy for any type of overhead (space or time). I chose this because it<br>&gt;&gt; is easy and because it is likely to be true that if `sizeofValue` return<br>&gt;&gt; the same size then the overhead is likely the same. Consider a `Boxable`<br>&gt;&gt; protocol and then an `Int` specialisation of that protocol.<br>&gt;&gt;<br>&gt;&gt; User writes:<br>&gt;&gt;<br>&gt;&gt;     protocol Boxable&lt;T&gt; {<br>&gt;&gt;<br>&gt;&gt;         var value: Any { get set }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; This gets translated, as per proposal, into:<br>&gt;&gt;<br>&gt;&gt;     // Size test for a generic protocol and generic struct as per<br>&gt;&gt; proposal and optimisation<br>&gt;&gt;<br>&gt;&gt;     protocol Boxable { // User would write `protocol Boxable&lt;T&gt; { var<br>&gt;&gt; value: T { get set } }`.<br>&gt;&gt;<br>&gt;&gt;         var T: Any.Type { get }<br>&gt;&gt;<br>&gt;&gt;         var value: Any { get set }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Then the user wants an `Int` specialisation:<br>&gt;&gt;<br>&gt;&gt;     struct BoxInt: Boxable&lt;T&gt; {<br>&gt;&gt;<br>&gt;&gt;         var value: Int<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This gets translated, as per proposal, into:<br>&gt;&gt;<br>&gt;&gt;     struct BoxInt: Boxable { // User would write `struct BoxInt:<br>&gt;&gt; Boxable&lt;Int&gt; { var value: Int }`.<br>&gt;&gt;<br>&gt;&gt;         // No need for a stored property becuse `Int` is a struct and<br>&gt;&gt; cannot be sub-classed.<br>&gt;&gt;<br>&gt;&gt;         var T: Any.Type { // Compiler generated, user would not write<br>&gt;&gt; anything<br>&gt;&gt;<br>&gt;&gt;             return Int.self<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         var _value: Any // From user written `var value: Int`.<br>&gt;&gt;<br>&gt;&gt;         var value: Any {<br>&gt;&gt;<br>&gt;&gt;             get {<br>&gt;&gt;<br>&gt;&gt;                 return _value<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;             set {<br>&gt;&gt;<br>&gt;&gt;                 precondition(newValue is Int, &quot;Type of newValue, \(<br>&gt;&gt; newValue.dynamicType), is not \(Int.self)&quot;)<br>&gt;&gt;<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         // No need for `lowestCommonDeclaredT` arg becuse `Int` is a<br>&gt;&gt; struct and cannot be sub-classed.<br>&gt;&gt;<br>&gt;&gt;         init(value: Any) { // Compiler generated, user would not write<br>&gt;&gt; anything<br>&gt;&gt;<br>&gt;&gt;             _value = value<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There is some overhead:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     let bI = BoxInt(value: 1)<br>&gt;&gt;<br>&gt;&gt;     sizeofValue(bI) // 32, i.e. `BoxInt (due to `value: Any`) has<br>&gt;&gt; overhead since an `Int` size is 8<br>&gt;&gt;<br>&gt;&gt;     let boxable: Boxable = bI<br>&gt;&gt;<br>&gt;&gt;     sizeofValue(boxable) // 40, i.e. generic protocol has same overhead<br>&gt;&gt; as non-generic protocol<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Encouragingly, once you type as a protocol, whether the protocol is a<br>&gt;&gt; proposed generic protocol or a non-generic protocol the overhead in the<br>&gt;&gt; same. However `BoxInt` is certainly more overhead than `Int`.<br>&gt;&gt;<br>&gt;&gt; Fortunately the compiler can optimise it away:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     struct NonGenericBoxInt { // Also generated from `struct BoxInt:<br>&gt;&gt; Boxable&lt;Int&gt; { var value: Int }`<br>&gt;&gt;<br>&gt;&gt;         var value: Int<br>&gt;&gt;<br>&gt;&gt;         var toBoxInt: BoxInt {<br>&gt;&gt;<br>&gt;&gt;             return BoxInt(value: value)<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     let nGBI = NonGenericBoxInt(value: 1)<br>&gt;&gt;<br>&gt;&gt;     sizeofValue(nGBI) // 8, i.e. `NonGenericBoxInt has zero overhead<br>&gt;&gt;<br>&gt;&gt; When the user writes `BoxInt` the compiler substitutes `NonGenericBoxInt`<br>&gt;&gt; and when the user covariantly assigns to the protocol `Boxable` the<br>&gt;&gt; compiler calls `toBoxInt`.<br>&gt;&gt;<br>&gt;&gt; Therefore the original proposal could be extended to include this<br>&gt;&gt; optimisation.<br>&gt;&gt;<br>&gt;&gt; Hopefully therefore this `efficiency` question is addressed?<br>&gt;&gt;<br>&gt;&gt; Thanks for the feedback,<br>&gt;&gt;<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; On 13 January 2016 at 05:19, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Agreed on both counts. Generics are more familiar but don&#39;t actually<br>&gt;&gt;&gt; cover the use cases where the associated type is *not* independent of<br>&gt;&gt;&gt; the model object (like a Sequence&#39;s Generator or a Collection&#39;s Index).<br>&gt;&gt;&gt; Dropping that information results in a lot of extra indirection at runtime,<br>&gt;&gt;&gt; which we don&#39;t want.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 12, 2016, at 8:17, Austin Zheng via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Strong -1, covariance on generics should be explicitly opt-in. Also -1<br>&gt;&gt;&gt; on generics replacing associated types in protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 12, 2016, at 1:45 AM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt;&gt;&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt;&gt;&gt; changed then they can be made covariant and that this will add considerable<br>&gt;&gt;&gt; utility to Swift generics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Current system<br>&gt;&gt;&gt;     class Top {}<br>&gt;&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;&gt;         var value: T<br>&gt;&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;&gt;             value = initialValue;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not*<br>&gt;&gt;&gt; a `Box&lt;Top&gt;`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am suggesting:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T<br>&gt;&gt;&gt; { get set } }` and that this mechanism replaces associated types for<br>&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Proposal:<br>&gt;&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as<br>&gt;&gt;&gt; before<br>&gt;&gt;&gt;     // 2. Code transformed by comiler with write check for each<br>&gt;&gt;&gt; specific, generic type instance<br>&gt;&gt;&gt;     // Best approximation of resulting code in current Swift to<br>&gt;&gt;&gt; demonstrate spirit of idea:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Compiler writes a universal form using the upper bound (it<br>&gt;&gt;&gt; writes the underlyting representation).<br>&gt;&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject`<br>&gt;&gt;&gt; to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // Generated from stored property `var value: T` and noting<br>&gt;&gt;&gt; that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;         private var _value: AnyObject // Access the stored property<br>&gt;&gt;&gt; through a setter so that type can be checked<br>&gt;&gt;&gt;         var value: AnyObject {<br>&gt;&gt;&gt;             get {<br>&gt;&gt;&gt;                 return _value<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             set {<br>&gt;&gt;&gt;                 // In all functions check that args declared as `T` are<br>&gt;&gt;&gt; actually a `T` or a sub-type.<br>&gt;&gt;&gt;                 // Note: `is` only works with type literal and there is<br>&gt;&gt;&gt; no `&gt;=` operator for types :(.<br>&gt;&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt;&gt;&gt; nearest at moment `==`.<br>&gt;&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type<br>&gt;&gt;&gt; of newValue, \(newValue.dynamicType), is not a sub-type of generic type<br>&gt;&gt;&gt; T, \(T)&quot;)<br>&gt;&gt;&gt;                 _value = newValue<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that<br>&gt;&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt;&gt;&gt; AnyObject) {<br>&gt;&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;&gt;             _value = initialValue<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt;&gt;&gt; be bitwise copied<br>&gt;&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt;&gt;&gt; the `T`s in the `init` call.<br>&gt;&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt;&gt;&gt; write `let bT = Box(Top())`.<br>&gt;&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt;&gt;&gt; would write `let bB = Box(Bottom())`.<br>&gt;&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;&gt;     bT = bB // Compiler would check covariance of declared generic<br>&gt;&gt;&gt; types.<br>&gt;&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt;&gt;&gt; `bT = Box(Top())`.<br>&gt;&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt;&gt;&gt; for types, but would work in practice<br>&gt;&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The implications of this proposal are:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt;&gt; 3. Protocols can be made generic instead of having an associated type<br>&gt;&gt;&gt; and then they become a proper type with dynamic dispatch.<br>&gt;&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt;&gt;&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt;&gt;&gt; a generic constraint.<br>&gt;&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced<br>&gt;&gt;&gt; by a more powerful and easier to understand semantic of a type, just like<br>&gt;&gt;&gt; the other types.<br>&gt;&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt;&gt;&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt;&gt;&gt; be unnecessary.<br>&gt;&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that<br>&gt;&gt;&gt; would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Advantages:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt;&gt;&gt; arrays and fields of a generic protocol.<br>&gt;&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols<br>&gt;&gt;&gt; can be made into a ‘proper’ type or at least a concept that is easier to<br>&gt;&gt;&gt; understand.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Compatibility:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. This would be a major change since associated types in protocols<br>&gt;&gt;&gt; would be replaced by generics.<br>&gt;&gt;&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt;&gt;&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt;&gt;&gt; object because the class will have extra fields, one for each generic type,<br>&gt;&gt;&gt; and therefore will be larger.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Disadvantages:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Major change.<br>&gt;&gt;&gt; 2. Object size increases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   — Howard.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; PS This is part of a collection of proposals previously presented as<br>&gt;&gt;&gt; “Protocols on Steroids”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/287d5346/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 13, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Howard,<br></p><p>I appreciate the amount of thought and detail you&#39;ve put into both the proposal and these replies.<br></p><p>However, the fundamental objection I have is that this proposal makes the type system unsound. More specifically, all your examples contain calls to precondition() and force casts, because it would become possible to write incorrectly typed code that nevertheless passes the type checker. The idea that user-level code would have to pervasively perform type checking at runtime when using generic code or risk causing a program-terminating exception goes against the design philosophy the core team has articulated for the language. Optionals and non-nullable types are (at least at first) a pain to use for a programmer used to working in a language where nil/null is a bottom type, but their presence isolates the possibility of NPEs to code that is clearly delineated by &#39;!&#39;. In my opinion (and others may not share this opinion), the programmer convenience gained over a system where variance is annotated explicitly is not worth introducing ways to express a new category of bugs.<br></p><p>Going by your implementation below:<br></p><p>let intBox = Box(1) // intBox is of type Box&lt;Int&gt;<br>var someBox : Box&lt;Any&gt; = intBox // since covariance, this is an upcast; succeeds unconditionally; could do this with a class hierarchy as well<br>// someBox is a copy of intBox, which means although the type system thinks it&#39;s a Box&lt;Any&gt;, its BoxT is still Int&#39;s type<br>// ...<br>// much later<br>let value : Any = &quot;hello&quot;<br>someBox.value = value // Box&lt;Any&gt; should accept an Any, but this will cause the precondition to fail and the program to crash<br>// *any* time you mutate a Box whose value isn&#39;t a bottom type your code needs to do a typecheck, or your program dies<br></p><p>Note that arrays in Swift are actually a covariant generic type already, but because of the way their value semantics work they are immune to this problem.<br></p><p>You can try to paper over this problem by introducing (e.g.) compiler magic which adjusts the metatype properties in conjunction with upcasts and downcasts, but what happens when the covariant generic type is a class and you can&#39;t rely on copy-on-assignment behavior? etc.<br></p><p>There are other languages that have chosen to make generic types pervasively covariant (e.g. https://www.dartlang.org/articles/why-dart-types/ &lt;https://www.dartlang.org/articles/why-dart-types/&gt;), but each language has its own design philosophy and I don&#39;t think this is the right direction for Swift. I think once the case has been made as to why this Swift-specific convenience-over-safety tradeoff should favor convenience, it&#39;ll be easier to discuss additional pros and cons of your specific implementation.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jan 12, 2016, at 11:22 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; @Austin,<br>&gt; <br>&gt; I don&#39;t see a problem with the collections in general, that&#39;s why I chose `Box` as an example - the smallest possible collection! <br>&gt; <br>&gt; Is this what you had in mind?<br>&gt; <br>&gt; //: Use a Box as an example of a minimal collection, a colection of exactly one value!<br>&gt; <br>&gt; //: - note:<br>&gt; //: In earlier examples I used the generic type name as the feild name directly, in practice you need a unique name.<br>&gt; //: I would propose TypeName.GenericName for the unique name?<br>&gt; //: In examples below I have used TypeNameGenericName as the nearest approximation possible at present.<br>&gt; //: I chose upper case, but maybe lower case better?<br>&gt; //: Maybe the syntax without a . is good enough?<br>&gt; <br>&gt; //:     protocol Boxable&lt;T&gt; { var value: T { get set } }<br>&gt; protocol Boxable {<br>&gt;     var BoxableT: Any.Type { get }<br>&gt;     var value: Any { get set }<br>&gt; }<br>&gt; <br>&gt; //:     protocol Generatable&lt;T&gt; { var generator: Generator&lt;T&gt; { get } }<br>&gt; protocol Generatable {<br>&gt;     var GeneratableT: Any.Type { get }<br>&gt;     var generator: Generator { get }<br>&gt; }<br>&gt; <br>&gt; //:     struct Box&lt;T&gt;: Boxable&lt;T&gt;, Generatable&lt;T&gt; {<br>&gt; //:         var value: T<br>&gt; //:         var generator: Generator&lt;T&gt; { return BoxGenerator(box: self) }<br>&gt; //:     }<br>&gt; struct Box: Boxable, Generatable {<br>&gt;     let BoxT: Any.Type // Box only has one &#39;real&#39; generic type BoxT<br>&gt;     var BoxableT: Any.Type { // BoxableT declared as same as BoxT (Boxable&lt;T&gt;)<br>&gt;         return BoxT<br>&gt;     }<br>&gt;     var GeneratableT: Any.Type { // GeneratableT declared as same as BoxT (Generatable&lt;T&gt;)<br>&gt;         return BoxT<br>&gt;     }<br>&gt;     <br>&gt;     private var _value: Any<br>&gt;     var value: Any {<br>&gt;         get {<br>&gt;             return _value<br>&gt;         }<br>&gt;         set {<br>&gt;             precondition(BoxT == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type BoxT, \(BoxT)&quot;)<br>&gt;             _value = newValue<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var generator: Generator {<br>&gt;         return BoxGenerator(BoxT, box: self)<br>&gt;     }<br>&gt;     <br>&gt;     // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;     init(_ lowestCommonDeclaredT: Any.Type, value: Any) {<br>&gt;         BoxT = lowestCommonDeclaredT<br>&gt;         _value = value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; //:     protocol Generator&lt;T&gt; { var next: T? { get } }<br>&gt; protocol Generator {<br>&gt;     var GeneratorT: Any.Type { get }<br>&gt;     var next: Any? { get }<br>&gt; }<br>&gt; <br>&gt; //:     class BoxGenerator&lt;T&gt;: Generator&lt;T&gt; {<br>&gt; //:         private var isFinished = false<br>&gt; //:         private let box: Box&lt;t&gt;<br>&gt; //:         var next: T? {<br>&gt; //:             if isFinished { return nil }<br>&gt; //:             isFinished = true<br>&gt; //:             return box.value<br>&gt; //:         }<br>&gt; //:         init(box: Box&lt;T&gt;) {<br>&gt; //:             self.box = box<br>&gt; //:         }<br>&gt; //:     }<br>&gt; class BoxGenerator: Generator {<br>&gt;     let BoxGeneratorT: Any.Type<br>&gt;     var GeneratorT: Any.Type {<br>&gt;         return BoxGeneratorT<br>&gt;     }<br>&gt;     private var isFinished = false<br>&gt;     private let box: Box<br>&gt;     var next: Any? {<br>&gt;         if isFinished { return nil }<br>&gt;         isFinished = true<br>&gt;         return box.value<br>&gt;     }<br>&gt;     init(_ lowestCommonDeclaredT: Any.Type, box: Box) {<br>&gt;         self.BoxGeneratorT = lowestCommonDeclaredT<br>&gt;         self.box = box<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; //:     let ints = Box(value: 1)<br>&gt; let ints = Box(Int.self, value: 1) // Box&lt;Int&gt;, compiler determins declared type<br>&gt; sizeofValue(ints) // 40<br>&gt; let intsGen = ints.generator // BoxGenerator&lt;Int&gt;<br>&gt; sizeofValue(intsGen) // 40<br>&gt; intsGen.next as! Int? // 1, compiler adds cast<br>&gt; intsGen.next as! Int? // nil, compiler adds cast<br>&gt; <br>&gt; <br>&gt; Do you have something else in mind? Happy to take a look at *short* examples?<br>&gt; <br>&gt;  -- Howard.<br>&gt;  ...<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/ce979866/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>January 13, 2016 at 11:00:00am</p></header><div class="content"><p>The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is indeed not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal attempts to get around this difference with a runtime failure but this would result in very fragile code - you get passed a Box&lt;Top&gt; and want to pass it a subclass of Top, will it succeed, who knows. You probably would be able to check the types but the complier wouldn’t highlight that this is an operation that could potentially fail.<br></p><p>This seems to be very much against Swift’s goal of safety being enforced by the compiler as much as possible.<br></p><p>Java uses the wildcard syntax to highlight this conceptual and behavioural difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but rather with Box&lt;? extends Top&gt;. The compiler can then enforce that a programmer doesn’t try to pass an incompatible type to a variable of such type. Even though this is a complication to the language (many Java programmers struggle with correctly using the wildcard syntax) I don’t see covariance for generics being added to Swift in a robust manner without some kind of similar syntax.<br></p><p>-Simon<br></p><p>&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br>&gt; <br>&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt; <br>&gt;     // Current system<br>&gt;     class Top {}<br>&gt;     class Bottom: Top {}<br>&gt; <br>&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;         var value: T<br>&gt;         init(_ initialValue: T) {<br>&gt;             value = initialValue;<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     let boxB = Box(Bottom())<br>&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt; <br>&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br>&gt; <br>&gt; I am suggesting:<br>&gt; <br>&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt; 2. An implementation that allows the above covariance.<br>&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br>&gt; <br>&gt;     // Proposal:<br>&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;     // 2. Code transformed by comiler with write check for each specific, generic type instance<br>&gt;     // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br>&gt; <br>&gt;     // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;     struct BoxAnyObject {<br>&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;         <br>&gt;         // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;         private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>&gt;         var value: AnyObject {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>&gt;                 // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>&gt;                 // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>&gt;                 _value = newValue<br>&gt;             }<br>&gt;         }<br>&gt;         <br>&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>&gt;             T = lowestCommonDeclaredT<br>&gt;             _value = initialValue<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>&gt;     // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>&gt;     bT.T // Top.Type<br>&gt;     sizeofValue(bT) // 16<br>&gt; <br>&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>&gt;     bB.T // Bottom.Type<br>&gt;     sizeofValue(bB) // 16<br>&gt; <br>&gt;     // Demonstration covariance.<br>&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;     bT.T // Bottom.Type<br>&gt; <br>&gt;     // Demonstrate generic returned type<br>&gt;     // Compiler would add cast to declared, generic type.<br>&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt; <br>&gt;     // Demonstrate type safety<br>&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>&gt;     bT.value = Top() // OK<br>&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt; <br>&gt; The implications of this proposal are:<br>&gt; <br>&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt; 2. A write to a stored property is type checked at runtime.<br>&gt; 3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>&gt; 4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>&gt; 5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt; <br>&gt; Advantages:<br>&gt; <br>&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt; 3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>&gt; 4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br>&gt; <br>&gt; Compatibility:<br>&gt; <br>&gt; 1. This would be a major change since associated types in protocols would be replaced by generics.<br>&gt; 2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br>&gt; <br>&gt; Disadvantages:<br>&gt; <br>&gt; 1. Major change.<br>&gt; 2. Object size increases.<br>&gt; <br>&gt; Thanks in advance for any comments,<br>&gt; <br>&gt;   — Howard.<br>&gt; <br>&gt; PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/d55afa5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes you can annotate for covariance, invariance, and contravariance, both<br>Java and Scala, allow all three. The problem is that the code becomes<br>splattered with variance annotations. The Java people themselves have<br>publicly regretted this and wished that they had made covariance the<br>default. If you look at generic code invariance and covariance are by far<br>the most common requirements; this proposal would address these common use<br>case without burdening the programmer.<br></p><p>Swift, and no usable language, is completely statically typed. Examples in<br>Swift of runtime type checking are array out of bounds and casts. There are<br>other examples of non-type related runtime checks is Swift: numerical<br>overflow, throws, using optionals to signal errors, and using enums to<br>signal errors. I say use what is appropriate, static type checking if it is<br>easy to do, otherwise runtime type checking. Note I am not proposing an<br>unsafe language like C, it is still type checked.<br></p><p>There is a strong positive precedence for a type check on write, Java<br>arrays (not Java `List`s). Arrays in Java may be passed covariantly, and<br>this is extensively used. However if you attempt to write the wrong type<br>into the array you will get an `ArrayStoreException`. In practice you don&#39;t<br>get many `ArrayStoreException`, non of my code has ever had one. Its just<br>not something you do in practice, as noted before contravariance is rare.<br></p><p>Thanks for you comments and I hope this eases your concerns,<br></p><p>  -- Howard.<br></p><p><br>On 13 January 2016 at 11:33, Simon Pilkington &lt;simonmpilkington at icloud.com&gt;<br>wrote:<br></p><p>&gt; The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is indeed<br>&gt; not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal<br>&gt; attempts to get around this difference with a runtime failure but this<br>&gt; would result in very fragile code - you get passed a Box&lt;Top&gt; and want to<br>&gt; pass it a subclass of Top, will it succeed, who knows. You probably would<br>&gt; be able to check the types but the complier wouldn’t highlight that this is<br>&gt; an operation that could potentially fail.<br>&gt;<br>&gt; This seems to be very much against Swift’s goal of safety being enforced<br>&gt; by the compiler as much as possible.<br>&gt;<br>&gt; Java uses the wildcard syntax to highlight this conceptual and behavioural<br>&gt; difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but rather with<br>&gt; Box&lt;? extends Top&gt;. The compiler can then enforce that a programmer doesn’t<br>&gt; try to pass an incompatible type to a variable of such type. Even though<br>&gt; this is a complication to the language (many Java programmers struggle with<br>&gt; correctly using the wildcard syntax) I don’t see covariance for generics<br>&gt; being added to Swift in a robust manner without some kind of similar syntax.<br>&gt;<br>&gt; -Simon<br>&gt;<br>&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt; changed then they can be made covariant and that this will add considerable<br>&gt; utility to Swift generics.<br>&gt;<br>&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;<br>&gt;     // Current system<br>&gt;     class Top {}<br>&gt;     class Bottom: Top {}<br>&gt;<br>&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;         var value: T<br>&gt;         init(_ initialValue: T) {<br>&gt;             value = initialValue;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     let boxB = Box(Bottom())<br>&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;<br>&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt; `Box&lt;Top&gt;`.<br>&gt;<br>&gt; I am suggesting:<br>&gt;<br>&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt; 2. An implementation that allows the above covariance.<br>&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T {<br>&gt; get set } }` and that this mechanism replaces associated types for<br>&gt; protocols.<br>&gt;<br>&gt;     // Proposal:<br>&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;     // 2. Code transformed by comiler with write check for each specific,<br>&gt; generic type instance<br>&gt;     // Best approximation of resulting code in current Swift to<br>&gt; demonstrate spirit of idea:<br>&gt;<br>&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt; the underlyting representation).<br>&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;     struct BoxAnyObject {<br>&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;<br>&gt;         // Generated from stored property `var value: T` and noting that<br>&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;         private var _value: AnyObject // Access the stored property<br>&gt; through a setter so that type can be checked<br>&gt;         var value: AnyObject {<br>&gt;             get {<br>&gt;                 return _value<br>&gt;             }<br>&gt;             set {<br>&gt;                 // In all functions check that args declared as `T` are<br>&gt; actually a `T` or a sub-type.<br>&gt;                 // Note: `is` only works with type literal and there is<br>&gt; no `&gt;=` operator for types :(.<br>&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt; nearest at moment `==`.<br>&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of<br>&gt; newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(<br>&gt; T)&quot;)<br>&gt;                 _value = newValue<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s<br>&gt; upper bound is `AnyObject`.<br>&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt; AnyObject) {<br>&gt;             T = lowestCommonDeclaredT<br>&gt;             _value = initialValue<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt; be bitwise copied<br>&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt; the `T`s in the `init` call.<br>&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt; write `let bT = Box(Top())`.<br>&gt;     bT.T // Top.Type<br>&gt;     sizeofValue(bT) // 16<br>&gt;<br>&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt; would write `let bB = Box(Bottom())`.<br>&gt;     bB.T // Bottom.Type<br>&gt;     sizeofValue(bB) // 16<br>&gt;<br>&gt;     // Demonstration covariance.<br>&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;     bT.T // Bottom.Type<br>&gt;<br>&gt;     // Demonstrate generic returned type<br>&gt;     // Compiler would add cast to declared, generic type.<br>&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;<br>&gt;     // Demonstrate type safety<br>&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt; `bT = Box(Top())`.<br>&gt;     bT.value = Top() // OK<br>&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt; for types, but would work in practice<br>&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;<br>&gt; The implications of this proposal are:<br>&gt;<br>&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt; 2. A write to a stored property is type checked at runtime.<br>&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt; then they become a proper type with dynamic dispatch.<br>&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt; a generic constraint.<br>&gt; 5. The awkwardness of dealing with associated type generics is replaced by<br>&gt; a more powerful and easier to understand semantic of a type, just like the<br>&gt; other types.<br>&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt; be unnecessary.<br>&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;<br>&gt; Advantages:<br>&gt;<br>&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt; arrays and fields of a generic protocol.<br>&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt; understand.<br>&gt;<br>&gt; Compatibility:<br>&gt;<br>&gt; 1. This would be a major change since associated types in protocols would<br>&gt; be replaced by generics.<br>&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt; object because the class will have extra fields, one for each generic type,<br>&gt; and therefore will be larger.<br>&gt;<br>&gt; Disadvantages:<br>&gt;<br>&gt; 1. Major change.<br>&gt; 2. Object size increases.<br>&gt;<br>&gt; Thanks in advance for any comments,<br>&gt;<br>&gt;   — Howard.<br>&gt;<br>&gt; PS This is part of a collection of proposals previously presented as<br>&gt; “Protocols on Steroids”.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/6280b264/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 12, 2016 at 07:00:00pm</p></header><div class="content"><p>Java only has invariance at the generic type definition level. They allow you to use wildcards as another option to generic constraints for instance references. In effect, variance is faked by the user of a type, not defined by the author of the type.<br></p><p>The dynamic and unreified nature of java generics is such that several valid systems I have encountered are impossible to properly express. Likewise, several systems I have tried to debug using generics have been found to have unsound generic type systems due to the language not enforcing proper static typing.<br></p><p>IMHO Java is not a good language to use as an example when trying to make a case for changing the behavior of generics.<br></p><p>-DW<br></p><p>&gt; On Jan 12, 2016, at 6:47 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations. The Java people themselves have publicly regretted this and wished that they had made covariance the default. If you look at generic code invariance and covariance are by far the most common requirements; this proposal would address these common use case without burdening the programmer.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/694f4ace/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>What uses do you see for covariance defined by the author of a type?<br></p><p>Also I agree with you about Java; in particular for me the combination of covariance, Raw Types and Type Erasure create a very confusing system which sometimes seems to be of little benefit.<br></p><p>-Simon<br></p><p><br>&gt; On 13 Jan 2016, at 1:07 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; Java only has invariance at the generic type definition level. They allow you to use wildcards as another option to generic constraints for instance references. In effect, variance is faked by the user of a type, not defined by the author of the type.<br>&gt; <br>&gt; The dynamic and unreified nature of java generics is such that several valid systems I have encountered are impossible to properly express. Likewise, several systems I have tried to debug using generics have been found to have unsound generic type systems due to the language not enforcing proper static typing.<br>&gt; <br>&gt; IMHO Java is not a good language to use as an example when trying to make a case for changing the behavior of generics.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 6:47 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations. The Java people themselves have publicly regretted this and wished that they had made covariance the default. If you look at generic code invariance and covariance are by far the most common requirements; this proposal would address these common use case without burdening the programmer.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/dc8c3aac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 13, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 13.01.2016 um 04:08 schrieb Simon Pilkington via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; What uses do you see for covariance defined by the author of a type?<br></p><p>Just chiming in although I&#39;m not David: you could have producer and consumer ointerfaces e.g. for collection types.<br></p><p>&gt; Also I agree with you about Java; in particular for me the combination of covariance, Raw Types and Type Erasure create a very confusing system which sometimes seems to be of little benefit.<br></p><p>Yes, for most questions about the type system Java is a bad example...<br></p><p>Scala uses definition site variance annotations instead of use site annotations (like Java&#39;s wildcards). Ceylon actually does both but has a strong preference on definition site variance annotations, see http://ceylon-lang.org/documentation/1.2/tour/generics/<br></p><p>-Thorsten<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>I should be clear, I am not proposing the Java way. I haven&#39;t seen a<br>language that uses the system I am proposing where the instance carries a<br>field that says what type it accepts and that is checked at runtime. From<br>using this pattern in my own code it seems to work better than either the<br>current associated types and also the Haskel/Java/Scala type erasure<br>systems.<br></p><p>However since it is only tested in the sort of code I write it could be<br>that I haven&#39;t turned up all the problems. Do you have a *short* example of<br>where a Java system failed so that I can see how it would go using this<br>approach?<br></p><p>Hope you can find a suitable example,<br></p><p> -- Howard.<br></p><p>On 13 January 2016 at 13:07, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; Java only has invariance at the generic type definition level. They allow<br>&gt; you to use wildcards as another option to generic constraints for instance<br>&gt; references. In effect, variance is faked by the user of a type, not defined<br>&gt; by the author of the type.<br>&gt;<br>&gt; The dynamic and unreified nature of java generics is such that several<br>&gt; valid systems I have encountered are impossible to properly express.<br>&gt; Likewise, several systems I have tried to debug using generics have been<br>&gt; found to have unsound generic type systems due to the language not<br>&gt; enforcing proper static typing.<br>&gt;<br>&gt; IMHO Java is not a good language to use as an example when trying to make<br>&gt; a case for changing the behavior of generics.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Jan 12, 2016, at 6:47 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes you can annotate for covariance, invariance, and contravariance, both<br>&gt; Java and Scala, allow all three. The problem is that the code becomes<br>&gt; splattered with variance annotations. The Java people themselves have<br>&gt; publicly regretted this and wished that they had made covariance the<br>&gt; default. If you look at generic code invariance and covariance are by far<br>&gt; the most common requirements; this proposal would address these common use<br>&gt; case without burdening the programmer.<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/76b9789d/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0ab9e40f73106b42eaa9724c02b6ad8?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Simon Pilkington</string> &lt;simonmpilkington at icloud.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>I’d be interested in reading up on what the Oracle response was if you have links.<br></p><p>As you mentioned even Swift doesn’t get away from runtime type checking but in the two examples you mentioned - array out of bounds and casts - Swift makes use of the Optionals system to highlight that an operation may fail and allows the user to handle that failure. Covariance should have similar syntax support (for example use of optional chaining similar to optional protocol requirements to indicate that a call may fail due to incorrect types). For the compiler to understand when such failure is possible, some kind of covariance syntax would be required.<br></p><p>As a related question, do you see covariance syntax as such a burden?<br></p><p>-Simon<br></p><p><br>&gt; On 13 Jan 2016, at 12:47 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations. The Java people themselves have publicly regretted this and wished that they had made covariance the default. If you look at generic code invariance and covariance are by far the most common requirements; this proposal would address these common use case without burdening the programmer.<br>&gt; <br>&gt; Swift, and no usable language, is completely statically typed. Examples in Swift of runtime type checking are array out of bounds and casts. There are other examples of non-type related runtime checks is Swift: numerical overflow, throws, using optionals to signal errors, and using enums to signal errors. I say use what is appropriate, static type checking if it is easy to do, otherwise runtime type checking. Note I am not proposing an unsafe language like C, it is still type checked.<br>&gt; <br>&gt; There is a strong positive precedence for a type check on write, Java arrays (not Java `List`s). Arrays in Java may be passed covariantly, and this is extensively used. However if you attempt to write the wrong type into the array you will get an `ArrayStoreException`. In practice you don&#39;t get many `ArrayStoreException`, non of my code has ever had one. Its just not something you do in practice, as noted before contravariance is rare.<br>&gt; <br>&gt; Thanks for you comments and I hope this eases your concerns,<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; <br>&gt; On 13 January 2016 at 11:33, Simon Pilkington &lt;simonmpilkington at icloud.com &lt;mailto:simonmpilkington at icloud.com&gt;&gt; wrote:<br>&gt; The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is indeed not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal attempts to get around this difference with a runtime failure but this would result in very fragile code - you get passed a Box&lt;Top&gt; and want to pass it a subclass of Top, will it succeed, who knows. You probably would be able to check the types but the complier wouldn’t highlight that this is an operation that could potentially fail.<br>&gt; <br>&gt; This seems to be very much against Swift’s goal of safety being enforced by the compiler as much as possible.<br>&gt; <br>&gt; Java uses the wildcard syntax to highlight this conceptual and behavioural difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but rather with Box&lt;? extends Top&gt;. The compiler can then enforce that a programmer doesn’t try to pass an incompatible type to a variable of such type. Even though this is a complication to the language (many Java programmers struggle with correctly using the wildcard syntax) I don’t see covariance for generics being added to Swift in a robust manner without some kind of similar syntax.<br>&gt; <br>&gt; -Simon<br>&gt; <br>&gt;&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br>&gt;&gt; <br>&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt; <br>&gt;&gt;     // Current system<br>&gt;&gt;     class Top {}<br>&gt;&gt;     class Bottom: Top {}<br>&gt;&gt; <br>&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;         var value: T<br>&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;             value = initialValue;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt; <br>&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br>&gt;&gt; <br>&gt;&gt; I am suggesting:<br>&gt;&gt; <br>&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br>&gt;&gt; <br>&gt;&gt;     // Proposal:<br>&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;&gt;     // 2. Code transformed by comiler with write check for each specific, generic type instance<br>&gt;&gt;     // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br>&gt;&gt; <br>&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;         <br>&gt;&gt;         // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>&gt;&gt;         var value: AnyObject {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>&gt;&gt;                 // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;             _value = initialValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt; <br>&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt; <br>&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt; <br>&gt;&gt; The implications of this proposal are:<br>&gt;&gt; <br>&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt; 3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; <br>&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br>&gt;&gt; <br>&gt;&gt; Compatibility:<br>&gt;&gt; <br>&gt;&gt; 1. This would be a major change since associated types in protocols would be replaced by generics.<br>&gt;&gt; 2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; <br>&gt;&gt; 1. Major change.<br>&gt;&gt; 2. Object size increases.<br>&gt;&gt; <br>&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt; <br>&gt;&gt;   — Howard.<br>&gt;&gt; <br>&gt;&gt; PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/0f38ab1a/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 08:00:00am</p></header><div class="content"><p>@Simon,<br></p><p>In the Swift code below:<br></p><p>    let array = [1]<br></p><p>    array[0] // 1, OK<br></p><p>    array[1] // Error not detected by compiler but detected at runtime<br></p><p>you have an example of an error detected at runtime that terminates program<br>execution, it doesn&#39;t return an optional.<br></p><p>In other languages this would be a type error, these languages are usually<br>described as dependent type (https://en.wikipedia.org/wiki/Dependent_type).<br>An example of the advantage of this would be vector (or matrix<br>multiplication), e.g. imagine that Swift had dependent types:<br></p><p>    let row = RowVec(1, 2) // Type: matrix of int with 1 row and 0 columns<br>(note size is part of the type)<br></p><p>    let col = ColVec(3) // Type: matrix of int with 0 rows and 1 column<br></p><p>    let scaler = row * col // Compile time error because both vectors<br>should be the same length<br></p><p>At the moment if you wrote a matrix package in Swift the above example<br>would be a runtime error and not a compile time error, but with dependent<br>typing it would be a compile time error.<br></p><p>There is another discussion of Swift Evolution on calculable types that are<br>closely related to dependent typing.<br></p><p>To me you just strike the balance, sometimes static checking is best<br>sometimes runtime. You strike the balance by how practical it is to do the<br>static checking, if the burden that the static checking adds to the users<br>then it isn&#39;t worth it. This is the case with annotated variance in<br>languages like Java and Scala, the annotations do not add much. Hence I am<br>suggesting system that is simple to use, much like Swift arrays are easy to<br>use but not totally, but largely, statically typed.<br></p><p>Hope that explains my reasoning for making most type error compile time<br>checked but a small subset runtime checked,<br></p><p> -- Howard.<br></p><p><br>On 13 January 2016 at 14:01, Simon Pilkington &lt;simonmpilkington at icloud.com&gt;<br>wrote:<br></p><p>&gt; I’d be interested in reading up on what the Oracle response was if you<br>&gt; have links.<br>&gt;<br>&gt; As you mentioned even Swift doesn’t get away from runtime type checking<br>&gt; but in the two examples you mentioned - array out of bounds and casts -<br>&gt; Swift makes use of the Optionals system to highlight that an operation may<br>&gt; fail and allows the user to handle that failure. Covariance should have<br>&gt; similar syntax support (for example use of optional chaining similar to<br>&gt; optional protocol requirements to indicate that a call may fail due to<br>&gt; incorrect types). For the compiler to understand when such failure is<br>&gt; possible, some kind of covariance syntax would be required.<br>&gt;<br>&gt; As a related question, do you see covariance syntax as such a burden?<br>&gt;<br>&gt; -Simon<br>&gt;<br>&gt;<br>&gt; On 13 Jan 2016, at 12:47 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Yes you can annotate for covariance, invariance, and contravariance, both<br>&gt; Java and Scala, allow all three. The problem is that the code becomes<br>&gt; splattered with variance annotations. The Java people themselves have<br>&gt; publicly regretted this and wished that they had made covariance the<br>&gt; default. If you look at generic code invariance and covariance are by far<br>&gt; the most common requirements; this proposal would address these common use<br>&gt; case without burdening the programmer.<br>&gt;<br>&gt; Swift, and no usable language, is completely statically typed. Examples in<br>&gt; Swift of runtime type checking are array out of bounds and casts. There are<br>&gt; other examples of non-type related runtime checks is Swift: numerical<br>&gt; overflow, throws, using optionals to signal errors, and using enums to<br>&gt; signal errors. I say use what is appropriate, static type checking if it is<br>&gt; easy to do, otherwise runtime type checking. Note I am not proposing an<br>&gt; unsafe language like C, it is still type checked.<br>&gt;<br>&gt; There is a strong positive precedence for a type check on write, Java<br>&gt; arrays (not Java `List`s). Arrays in Java may be passed covariantly, and<br>&gt; this is extensively used. However if you attempt to write the wrong type<br>&gt; into the array you will get an `ArrayStoreException`. In practice you don&#39;t<br>&gt; get many `ArrayStoreException`, non of my code has ever had one. Its just<br>&gt; not something you do in practice, as noted before contravariance is rare.<br>&gt;<br>&gt; Thanks for you comments and I hope this eases your concerns,<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt; On 13 January 2016 at 11:33, Simon Pilkington &lt;simonmpilkington at icloud.com<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is indeed<br>&gt;&gt; not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal<br>&gt;&gt; attempts to get around this difference with a runtime failure but this<br>&gt;&gt; would result in very fragile code - you get passed a Box&lt;Top&gt; and want to<br>&gt;&gt; pass it a subclass of Top, will it succeed, who knows. You probably would<br>&gt;&gt; be able to check the types but the complier wouldn’t highlight that this is<br>&gt;&gt; an operation that could potentially fail.<br>&gt;&gt;<br>&gt;&gt; This seems to be very much against Swift’s goal of safety being enforced<br>&gt;&gt; by the compiler as much as possible.<br>&gt;&gt;<br>&gt;&gt; Java uses the wildcard syntax to highlight this conceptual and<br>&gt;&gt; behavioural difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but<br>&gt;&gt; rather with Box&lt;? extends Top&gt;. The compiler can then enforce that a<br>&gt;&gt; programmer doesn’t try to pass an incompatible type to a variable of such<br>&gt;&gt; type. Even though this is a complication to the language (many Java<br>&gt;&gt; programmers struggle with correctly using the wildcard syntax) I don’t see<br>&gt;&gt; covariance for generics being added to Swift in a robust manner without<br>&gt;&gt; some kind of similar syntax.<br>&gt;&gt;<br>&gt;&gt; -Simon<br>&gt;&gt;<br>&gt;&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt;&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt;&gt; changed then they can be made covariant and that this will add considerable<br>&gt;&gt; utility to Swift generics.<br>&gt;&gt;<br>&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;<br>&gt;&gt;     // Current system<br>&gt;&gt;     class Top {}<br>&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;<br>&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;         var value: T<br>&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;             value = initialValue;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;<br>&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a<br>&gt;&gt; `Box&lt;Top&gt;`.<br>&gt;&gt;<br>&gt;&gt; I am suggesting:<br>&gt;&gt;<br>&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T<br>&gt;&gt; { get set } }` and that this mechanism replaces associated types for<br>&gt;&gt; protocols.<br>&gt;&gt;<br>&gt;&gt;     // Proposal:<br>&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as<br>&gt;&gt; before<br>&gt;&gt;     // 2. Code transformed by comiler with write check for each<br>&gt;&gt; specific, generic type instance<br>&gt;&gt;     // Best approximation of resulting code in current Swift to<br>&gt;&gt; demonstrate spirit of idea:<br>&gt;&gt;<br>&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes<br>&gt;&gt; the underlyting representation).<br>&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to<br>&gt;&gt; indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;<br>&gt;&gt;         // Generated from stored property `var value: T` and noting that<br>&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         private var _value: AnyObject // Access the stored property<br>&gt;&gt; through a setter so that type can be checked<br>&gt;&gt;         var value: AnyObject {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 // In all functions check that args declared as `T` are<br>&gt;&gt; actually a `T` or a sub-type.<br>&gt;&gt;                 // Note: `is` only works with type literal and there is<br>&gt;&gt; no `&gt;=` operator for types :(.<br>&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt;&gt; nearest at moment `==`.<br>&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type<br>&gt;&gt; of newValue, \(newValue.dynamicType), is not a sub-type of generic type<br>&gt;&gt; T, \(T)&quot;)<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that<br>&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt;&gt; AnyObject) {<br>&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;             _value = initialValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt;&gt; be bitwise copied<br>&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt;&gt; the `T`s in the `init` call.<br>&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt;&gt; write `let bT = Box(Top())`.<br>&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;<br>&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt;&gt; would write `let bB = Box(Bottom())`.<br>&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;<br>&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;<br>&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt;&gt; `bT = Box(Top())`.<br>&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt;&gt; for types, but would work in practice<br>&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;<br>&gt;&gt; The implications of this proposal are:<br>&gt;&gt;<br>&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt; 3. Protocols can be made generic instead of having an associated type and<br>&gt;&gt; then they become a proper type with dynamic dispatch.<br>&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt;&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt;&gt; a generic constraint.<br>&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced<br>&gt;&gt; by a more powerful and easier to understand semantic of a type, just like<br>&gt;&gt; the other types.<br>&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt;&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt;&gt; be unnecessary.<br>&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would<br>&gt;&gt; be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;<br>&gt;&gt; Advantages:<br>&gt;&gt;<br>&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt;&gt; arrays and fields of a generic protocol.<br>&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can<br>&gt;&gt; be made into a ‘proper’ type or at least a concept that is easier to<br>&gt;&gt; understand.<br>&gt;&gt;<br>&gt;&gt; Compatibility:<br>&gt;&gt;<br>&gt;&gt; 1. This would be a major change since associated types in protocols would<br>&gt;&gt; be replaced by generics.<br>&gt;&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt;&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt;&gt; object because the class will have extra fields, one for each generic type,<br>&gt;&gt; and therefore will be larger.<br>&gt;&gt;<br>&gt;&gt; Disadvantages:<br>&gt;&gt;<br>&gt;&gt; 1. Major change.<br>&gt;&gt; 2. Object size increases.<br>&gt;&gt;<br>&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;<br>&gt;&gt;   — Howard.<br>&gt;&gt;<br>&gt;&gt; PS This is part of a collection of proposals previously presented as<br>&gt;&gt; “Protocols on Steroids”.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/b5d8e246/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Howard,<br></p><p>Making generics covariant by default would add even more of a burden to<br>users. They would need to check the type property of a generic object any<br>time they wanted to mutate that generic object or risk their program<br>terminating.<br></p><p>I don&#39;t think the fact that array accesses are checked at runtime is a good<br>example:<br></p><p>1. The Swift team has stated that subscripting into an array returns a<br>non-optional at least in part because of performance issues.<br>(Unfortunately, I think this was mentioned on the old Apple developer<br>forums, which are now inaccessible, so don&#39;t take my word for it until<br>someone with more insight says so one way or another :).<br>2. The fact that this specific aspect of Swift is checked at runtime<br>doesn&#39;t provide insight as to whether or not another aspect of Swift should<br>be compile-time or runtime-checked; it just indicates that there exists the<br>possibility of some checks being done at runtime (and every mainstream<br>statically typed language performs runtime checks to some extent, this<br>isn&#39;t a novel conclusion).<br>3. Checking that an array access is in bounds is trivial from a conceptual<br>standpoint. The index needs to be at least 0 and at most the length of the<br>array - 1.<br>4. The length of a Swift array is not part of the type contract, whereas<br>the type enclosed within a generic type is. Swift doesn&#39;t have fixed-length<br>arrays.<br></p><p>I think a proposal to get rid of optionals and non-nullable types would be<br>a better analogy. Here is a comparison to that hypothetical proposal:<br></p><p>1. The most popular objection to Swift&#39;s optional system seems to be either<br>clutter (from the ?, ! sigils) and ease of use. (Your proposal cites the<br>ugliness of variance annotations in other languages as a primary<br>motivation.)<br>2. Removing the optional system would result in moving a compile-time check<br>to a run-time check. (Your proposal states that the burden of ensuring the<br>access is valid lies at the use site, which introduces the possibility of<br>runtime failures that cannot be currently expressed.)<br>3. Removing optionals would keep the language type-safe, as an exception<br>would occur whenever calling a method on nil occurred at runtime (your<br>proposal also keeps the language type-safe, in the formal sense).<br>4. The possibility of a run-time check failing and terminating the program<br>with an NPE can be mitigated by user code performing an explicit check for<br>nil at the use site. (Your proposal would require user code to check<br>against the metatype property whenever a generic type is mutated to ensure<br>that no preconditions can fail.)<br>5. Removing the optional system would cause the type system to be more<br>imprecise, since a variable of type T would contain either an instance of T<br>or nil. (Your proposal would cause the type system to be more imprecise,<br>since a T&lt;U&gt; might actually be a T&lt;V&gt;, where V is a subtype of U, in a<br>context where V cannot substitute for U.)<br></p><p>I hope this explains my objections (and those expressed elsewhere within<br>this thread) more clearly.<br></p><p>Best,<br>Austin<br></p><p><br>On Wed, Jan 13, 2016 at 1:54 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; @Simon,<br>&gt;<br>&gt; In the Swift code below:<br>&gt;<br>&gt;     let array = [1]<br>&gt;<br>&gt;     array[0] // 1, OK<br>&gt;<br>&gt;     array[1] // Error not detected by compiler but detected at runtime<br>&gt;<br>&gt; you have an example of an error detected at runtime that terminates<br>&gt; program execution, it doesn&#39;t return an optional.<br>&gt;<br>&gt; In other languages this would be a type error, these languages are usually<br>&gt; described as dependent type (https://en.wikipedia.org/wiki/Dependent_type).<br>&gt; An example of the advantage of this would be vector (or matrix<br>&gt; multiplication), e.g. imagine that Swift had dependent types:<br>&gt;<br>&gt;     let row = RowVec(1, 2) // Type: matrix of int with 1 row and 0<br>&gt; columns (note size is part of the type)<br>&gt;<br>&gt;     let col = ColVec(3) // Type: matrix of int with 0 rows and 1 column<br>&gt;<br>&gt;     let scaler = row * col // Compile time error because both vectors<br>&gt; should be the same length<br>&gt;<br>&gt; At the moment if you wrote a matrix package in Swift the above example<br>&gt; would be a runtime error and not a compile time error, but with dependent<br>&gt; typing it would be a compile time error.<br>&gt;<br>&gt; There is another discussion of Swift Evolution on calculable types that<br>&gt; are closely related to dependent typing.<br>&gt;<br>&gt; To me you just strike the balance, sometimes static checking is best<br>&gt; sometimes runtime. You strike the balance by how practical it is to do the<br>&gt; static checking, if the burden that the static checking adds to the users<br>&gt; then it isn&#39;t worth it. This is the case with annotated variance in<br>&gt; languages like Java and Scala, the annotations do not add much. Hence I am<br>&gt; suggesting system that is simple to use, much like Swift arrays are easy to<br>&gt; use but not totally, but largely, statically typed.<br>&gt;<br>&gt; Hope that explains my reasoning for making most type error compile time<br>&gt; checked but a small subset runtime checked,<br>&gt;<br>&gt;  -- Howard.<br>&gt;<br>&gt;<br>&gt; On 13 January 2016 at 14:01, Simon Pilkington &lt;simonmpilkington at icloud.com<br>&gt; &gt; wrote:<br>&gt;<br>&gt;&gt; I’d be interested in reading up on what the Oracle response was if you<br>&gt;&gt; have links.<br>&gt;&gt;<br>&gt;&gt; As you mentioned even Swift doesn’t get away from runtime type checking<br>&gt;&gt; but in the two examples you mentioned - array out of bounds and casts -<br>&gt;&gt; Swift makes use of the Optionals system to highlight that an operation may<br>&gt;&gt; fail and allows the user to handle that failure. Covariance should have<br>&gt;&gt; similar syntax support (for example use of optional chaining similar to<br>&gt;&gt; optional protocol requirements to indicate that a call may fail due to<br>&gt;&gt; incorrect types). For the compiler to understand when such failure is<br>&gt;&gt; possible, some kind of covariance syntax would be required.<br>&gt;&gt;<br>&gt;&gt; As a related question, do you see covariance syntax as such a burden?<br>&gt;&gt;<br>&gt;&gt; -Simon<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 13 Jan 2016, at 12:47 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yes you can annotate for covariance, invariance, and contravariance, both<br>&gt;&gt; Java and Scala, allow all three. The problem is that the code becomes<br>&gt;&gt; splattered with variance annotations. The Java people themselves have<br>&gt;&gt; publicly regretted this and wished that they had made covariance the<br>&gt;&gt; default. If you look at generic code invariance and covariance are by far<br>&gt;&gt; the most common requirements; this proposal would address these common use<br>&gt;&gt; case without burdening the programmer.<br>&gt;&gt;<br>&gt;&gt; Swift, and no usable language, is completely statically typed. Examples<br>&gt;&gt; in Swift of runtime type checking are array out of bounds and casts. There<br>&gt;&gt; are other examples of non-type related runtime checks is Swift: numerical<br>&gt;&gt; overflow, throws, using optionals to signal errors, and using enums to<br>&gt;&gt; signal errors. I say use what is appropriate, static type checking if it is<br>&gt;&gt; easy to do, otherwise runtime type checking. Note I am not proposing an<br>&gt;&gt; unsafe language like C, it is still type checked.<br>&gt;&gt;<br>&gt;&gt; There is a strong positive precedence for a type check on write, Java<br>&gt;&gt; arrays (not Java `List`s). Arrays in Java may be passed covariantly, and<br>&gt;&gt; this is extensively used. However if you attempt to write the wrong type<br>&gt;&gt; into the array you will get an `ArrayStoreException`. In practice you don&#39;t<br>&gt;&gt; get many `ArrayStoreException`, non of my code has ever had one. Its just<br>&gt;&gt; not something you do in practice, as noted before contravariance is rare.<br>&gt;&gt;<br>&gt;&gt; Thanks for you comments and I hope this eases your concerns,<br>&gt;&gt;<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 13 January 2016 at 11:33, Simon Pilkington &lt;<br>&gt;&gt; simonmpilkington at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is<br>&gt;&gt;&gt; indeed not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal<br>&gt;&gt;&gt; attempts to get around this difference with a runtime failure but this<br>&gt;&gt;&gt; would result in very fragile code - you get passed a Box&lt;Top&gt; and want to<br>&gt;&gt;&gt; pass it a subclass of Top, will it succeed, who knows. You probably would<br>&gt;&gt;&gt; be able to check the types but the complier wouldn’t highlight that this is<br>&gt;&gt;&gt; an operation that could potentially fail.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This seems to be very much against Swift’s goal of safety being enforced<br>&gt;&gt;&gt; by the compiler as much as possible.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Java uses the wildcard syntax to highlight this conceptual and<br>&gt;&gt;&gt; behavioural difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but<br>&gt;&gt;&gt; rather with Box&lt;? extends Top&gt;. The compiler can then enforce that a<br>&gt;&gt;&gt; programmer doesn’t try to pass an incompatible type to a variable of such<br>&gt;&gt;&gt; type. Even though this is a complication to the language (many Java<br>&gt;&gt;&gt; programmers struggle with correctly using the wildcard syntax) I don’t see<br>&gt;&gt;&gt; covariance for generics being added to Swift in a robust manner without<br>&gt;&gt;&gt; some kind of similar syntax.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Simon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt;&gt;&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt;&gt;&gt; changed then they can be made covariant and that this will add considerable<br>&gt;&gt;&gt; utility to Swift generics.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Current system<br>&gt;&gt;&gt;     class Top {}<br>&gt;&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;&gt;         var value: T<br>&gt;&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;&gt;             value = initialValue;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not*<br>&gt;&gt;&gt; a `Box&lt;Top&gt;`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am suggesting:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T<br>&gt;&gt;&gt; { get set } }` and that this mechanism replaces associated types for<br>&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Proposal:<br>&gt;&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as<br>&gt;&gt;&gt; before<br>&gt;&gt;&gt;     // 2. Code transformed by comiler with write check for each<br>&gt;&gt;&gt; specific, generic type instance<br>&gt;&gt;&gt;     // Best approximation of resulting code in current Swift to<br>&gt;&gt;&gt; demonstrate spirit of idea:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Compiler writes a universal form using the upper bound (it<br>&gt;&gt;&gt; writes the underlyting representation).<br>&gt;&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject`<br>&gt;&gt;&gt; to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // Generated from stored property `var value: T` and noting<br>&gt;&gt;&gt; that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;         private var _value: AnyObject // Access the stored property<br>&gt;&gt;&gt; through a setter so that type can be checked<br>&gt;&gt;&gt;         var value: AnyObject {<br>&gt;&gt;&gt;             get {<br>&gt;&gt;&gt;                 return _value<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;             set {<br>&gt;&gt;&gt;                 // In all functions check that args declared as `T` are<br>&gt;&gt;&gt; actually a `T` or a sub-type.<br>&gt;&gt;&gt;                 // Note: `is` only works with type literal and there is<br>&gt;&gt;&gt; no `&gt;=` operator for types :(.<br>&gt;&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt;&gt;&gt; nearest at moment `==`.<br>&gt;&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type<br>&gt;&gt;&gt; of newValue, \(newValue.dynamicType), is not a sub-type of generic type<br>&gt;&gt;&gt; T, \(T)&quot;)<br>&gt;&gt;&gt;                 _value = newValue<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that<br>&gt;&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt;&gt;&gt; AnyObject) {<br>&gt;&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;&gt;             _value = initialValue<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can<br>&gt;&gt;&gt; be bitwise copied<br>&gt;&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt;&gt;&gt; the `T`s in the `init` call.<br>&gt;&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt;&gt;&gt; write `let bT = Box(Top())`.<br>&gt;&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt;&gt;&gt; would write `let bB = Box(Bottom())`.<br>&gt;&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;&gt;     bT = bB // Compiler would check covariance of declared generic<br>&gt;&gt;&gt; types.<br>&gt;&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt;&gt;&gt; `bT = Box(Top())`.<br>&gt;&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=`<br>&gt;&gt;&gt; for types, but would work in practice<br>&gt;&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The implications of this proposal are:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt;&gt; 3. Protocols can be made generic instead of having an associated type<br>&gt;&gt;&gt; and then they become a proper type with dynamic dispatch.<br>&gt;&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt;&gt;&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt;&gt;&gt; a generic constraint.<br>&gt;&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced<br>&gt;&gt;&gt; by a more powerful and easier to understand semantic of a type, just like<br>&gt;&gt;&gt; the other types.<br>&gt;&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that<br>&gt;&gt;&gt; use a `where` clause to constrain an associated type protocol, this would<br>&gt;&gt;&gt; be unnecessary.<br>&gt;&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that<br>&gt;&gt;&gt; would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Advantages:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt;&gt;&gt; arrays and fields of a generic protocol.<br>&gt;&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols<br>&gt;&gt;&gt; can be made into a ‘proper’ type or at least a concept that is easier to<br>&gt;&gt;&gt; understand.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Compatibility:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. This would be a major change since associated types in protocols<br>&gt;&gt;&gt; would be replaced by generics.<br>&gt;&gt;&gt; 2. The new implementation of generics might break some existing `struct`<br>&gt;&gt;&gt; and `class` code, for example if it is dependent on the exact size of an<br>&gt;&gt;&gt; object because the class will have extra fields, one for each generic type,<br>&gt;&gt;&gt; and therefore will be larger.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Disadvantages:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Major change.<br>&gt;&gt;&gt; 2. Object size increases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   — Howard.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; PS This is part of a collection of proposals previously presented as<br>&gt;&gt;&gt; “Protocols on Steroids”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/2315f180/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 13, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 4:02 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Howard,<br>&gt; <br>&gt; Making generics covariant by default would add even more of a burden to users. They would need to check the type property of a generic object any time they wanted to mutate that generic object or risk their program terminating.<br>&gt; <br>&gt; I don&#39;t think the fact that array accesses are checked at runtime is a good example:<br>&gt; <br>&gt; 1. The Swift team has stated that subscripting into an array returns a non-optional at least in part because of performance issues. (Unfortunately, I think this was mentioned on the old Apple developer forums, which are now inaccessible, so don&#39;t take my word for it until someone with more insight says so one way or another :).<br>&gt; 2. The fact that this specific aspect of Swift is checked at runtime doesn&#39;t provide insight as to whether or not another aspect of Swift should be compile-time or runtime-checked; it just indicates that there exists the possibility of some checks being done at runtime (and every mainstream statically typed language performs runtime checks to some extent, this isn&#39;t a novel conclusion).<br>&gt; 3. Checking that an array access is in bounds is trivial from a conceptual standpoint. The index needs to be at least 0 and at most the length of the array - 1.<br>&gt; 4. The length of a Swift array is not part of the type contract, whereas the type enclosed within a generic type is. Swift doesn&#39;t have fixed-length arrays.<br></p><p>One might even argue the array length check is a precondition rather than a dynamic behavior. A developer is forced not to rely upon the bounds checking behavior, because an out-of-bounds error crashes the application. “Code crashes” is not a useful dynamic behavior and probably should not be used as an example for other behavior except in limited “developer messed up” scenarios.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/5a13c98c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 02:00:00pm</p></header><div class="content"><p>@David,<br></p><p>You said &quot;developer messed up&quot; for runtime crashes. The developer messed up<br>when the compiler finds a problem also. Its the same thing; if the compiler<br>statically finds a problem or the runtime finds a problem, in both cases<br>the &quot;developer messed up&quot;. The only difference is that one is found at<br>compile time and the other is found at runtime.<br></p><p>My own guide in order of importance is:<br></p><p> 1. Ideally it should be type safe, i.e. the error is found either by the<br>runtime of the compiler. Obviously some languages, C, Obj-C, C++, are not<br>type safe, and you can write great programs in all 3 and therefore you<br>can&#39;t say that type safe is mandatory. By extension calls in Swift to C<br>etc. are not type safe and there are many such calls in any realistic Swift<br>program, is this a problem? Not really.<br> 2. Ideally the compiler will catch errors. Ideally, because this saves on<br>testing. However if this burdens the programmer greatly you have to<br>consider is it worth while. Many people prefer dynamically typed languages<br>for exactly this reason, they find declaring types more trouble than it is<br>worth. IE they feel the extra time spent annotating with type information<br>is not paid back in terms of reduced testing. This &#39;explicitly typing is a<br>pain&#39; meme is common these days and has resulted in languages like Swift<br>that infer the type.<br></p><p>Combining these 2 points leads me to conclude that you should stick with<br>type safety were you can, infer type were you can, and only annotate extra<br>type information if that annotation increases programmer productivity.<br></p><p>Hence the proposal: its type safe, it infers type when it can, and for the<br>stuff that isn&#39;t worth annotating for it runtime checks.<br></p><p>Does that explain my reasoning?<br></p><p> -- Howard.<br></p><p>On 14 January 2016 at 10:13, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On Jan 13, 2016, at 4:02 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi Howard,<br>&gt;<br>&gt; Making generics covariant by default would add even more of a burden to<br>&gt; users. They would need to check the type property of a generic object any<br>&gt; time they wanted to mutate that generic object or risk their program<br>&gt; terminating.<br>&gt;<br>&gt; I don&#39;t think the fact that array accesses are checked at runtime is a<br>&gt; good example:<br>&gt;<br>&gt; 1. The Swift team has stated that subscripting into an array returns a<br>&gt; non-optional at least in part because of performance issues.<br>&gt; (Unfortunately, I think this was mentioned on the old Apple developer<br>&gt; forums, which are now inaccessible, so don&#39;t take my word for it until<br>&gt; someone with more insight says so one way or another :).<br>&gt; 2. The fact that this specific aspect of Swift is checked at runtime<br>&gt; doesn&#39;t provide insight as to whether or not another aspect of Swift should<br>&gt; be compile-time or runtime-checked; it just indicates that there exists the<br>&gt; possibility of some checks being done at runtime (and every mainstream<br>&gt; statically typed language performs runtime checks to some extent, this<br>&gt; isn&#39;t a novel conclusion).<br>&gt; 3. Checking that an array access is in bounds is trivial from a conceptual<br>&gt; standpoint. The index needs to be at least 0 and at most the length of the<br>&gt; array - 1.<br>&gt; 4. The length of a Swift array is not part of the type contract, whereas<br>&gt; the type enclosed within a generic type is. Swift doesn&#39;t have fixed-length<br>&gt; arrays.<br>&gt;<br>&gt;<br>&gt; One might even argue the array length check is a precondition rather than<br>&gt; a dynamic behavior. A developer is forced not to rely upon the bounds<br>&gt; checking behavior, because an out-of-bounds error crashes the application.<br>&gt; “Code crashes” is not a useful dynamic behavior and probably should not be<br>&gt; used as an example for other behavior except in limited “developer messed<br>&gt; up” scenarios.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/788e1ee8/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 3:02 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Howard,<br>&gt; <br>&gt; Making generics covariant by default would add even more of a burden to users. They would need to check the type property of a generic object any time they wanted to mutate that generic object or risk their program terminating.<br>&gt; <br>&gt; I don&#39;t think the fact that array accesses are checked at runtime is a good example:<br>&gt; <br>&gt; 1. The Swift team has stated that subscripting into an array returns a non-optional at least in part because of performance issues. (Unfortunately, I think this was mentioned on the old Apple developer forums, which are now inaccessible, so don&#39;t take my word for it until someone with more insight says so one way or another :).<br></p><p>To clarify, the reason that array indexes don’t take and produce an optional is a bit more subtle than that.<br></p><p>1) subscripts have to be uniform for their getting and setter.  It would be weird &amp; very confusing for &quot;A[i] = nil” to work, given that you can’t remove an element from an array.<br></p><p>2) Integer array indexes are almost always derived from some other value that is in range.  Having to deal with the optional produced by a getter would almost always be noise.  That noise would force a lot of pointless optional manipulation, and would end up as a lot of !’s.  This would water down the optional model by making “!” a common thing, and be seen as less scary.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>@ Austin,<br></p><p>Comments inline below.<br></p><p>On 14 January 2016 at 10:02, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; Hi Howard,<br>&gt;<br>&gt; Making generics covariant by default would add even more of a burden to<br>&gt; users. They would need to check the type property of a generic object any<br>&gt; time they wanted to mutate that generic object or risk their program<br>&gt; terminating.<br>&gt;<br></p><p>Its a matter of balance, is that checking necessary. You certainly don&#39;t<br>see it with Java arrays and this isn&#39;t a problem in practice. If you burden<br>everyone with an annotation and in real programs that imperceptibly reduces<br>the number of error then it was a bad call. The Java use case indicates<br>that it is a bad call.<br></p><p><br>&gt;<br>&gt; I don&#39;t think the fact that array accesses are checked at runtime is a<br>&gt; good example:<br>&gt;<br>&gt; 1. The Swift team has stated that subscripting into an array returns a<br>&gt; non-optional at least in part because of performance issues.<br>&gt; (Unfortunately, I think this was mentioned on the old Apple developer<br>&gt; forums, which are now inaccessible, so don&#39;t take my word for it until<br>&gt; someone with more insight says so one way or another :).<br>&gt;<br></p><p>What about write to an array, you still have to check bounds. An optional<br>won&#39;t help.<br></p><p><br>&gt; 2. The fact that this specific aspect of Swift is checked at runtime<br>&gt; doesn&#39;t provide insight as to whether or not another aspect of Swift should<br>&gt; be compile-time or runtime-checked; it just indicates that there exists the<br>&gt; possibility of some checks being done at runtime (and every mainstream<br>&gt; statically typed language performs runtime checks to some extent, this<br>&gt; isn&#39;t a novel conclusion).<br>&gt;<br></p><p>Yes it says that they are making pragmatic choices, the designers will be<br>well aware of type systems that check array bounds but chose, in my opinion<br>correctly, to go down the path of a runtime check for reasons of<br>practicality. The dependant type system or similar does not pay for itself<br>in terms of improved programmer productivity and application reliability.<br></p><p><br>&gt; 3. Checking that an array access is in bounds is trivial from a conceptual<br>&gt; standpoint. The index needs to be at least 0 and at most the length of the<br>&gt; array - 1.<br>&gt;<br></p><p>Type checking is equally trivial and can often be optimised away.<br></p><p><br>&gt; 4. The length of a Swift array is not part of the type contract, whereas<br>&gt; the type enclosed within a generic type is. Swift doesn&#39;t have fixed-length<br>&gt; arrays.<br>&gt;<br></p><p>Well it isn&#39;t in Swift, but in some languages it is. Proponents of these<br>languages would point to a matrix math API and note how the compiler can<br>check matrix size for conformance at compile time. Whereas in Swift that is<br>a runtime check. The proponents would point to the inefficiency of runtime<br>checking and the fact that you now need to test the code. I think the Swift<br>team have taken the right approach and are saying typing the size of an<br>array is not worth it.<br></p><p><br>&gt;<br>&gt; I think a proposal to get rid of optionals and non-nullable types would be<br>&gt; a better analogy. Here is a comparison to that hypothetical proposal:<br>&gt;<br>&gt; 1. The most popular objection to Swift&#39;s optional system seems to be<br>&gt; either clutter (from the ?, ! sigils) and ease of use. (Your proposal cites<br>&gt; the ugliness of variance annotations in other languages as a primary<br>&gt; motivation.)<br>&gt;<br></p><p>Not really, you are not comparing like with like. If Swift didn&#39;t have<br>explicit optionals it would most likely have implicit optionals like Obj-C<br>and Java. IE everything is an optional. I like Swift&#39;s solution since most<br>things aren&#39;t actually optional and therefore overall it reduces the burden<br>on the programmer (in other systems you are continuously testing for nil).<br>In terms of variance for generics if there were a method of giving static<br>type checking without burdening the programmer with annotations then I<br>would be in favour (unfortunately I do not know of such a system).<br></p><p><br>&gt; 2. Removing the optional system would result in moving a compile-time<br>&gt; check to a run-time check. (Your proposal states that the burden of<br>&gt; ensuring the access is valid lies at the use site, which introduces the<br>&gt; possibility of runtime failures that cannot be currently expressed.)<br>&gt;<br></p><p>No it would most likely mean that there were nil checks everywhere, just<br>like Java and to some extent Obj-C. IE an overall increase in programmer<br>burden.<br></p><p><br>&gt; 3. Removing optionals would keep the language type-safe, as an exception<br>&gt; would occur whenever calling a method on nil occurred at runtime (your<br>&gt; proposal also keeps the language type-safe, in the formal sense).<br>&gt;<br></p><p>Yes. Whether you have explicit optionals or implicit optionals it is still<br>type safe.<br></p><p><br>&gt; 4. The possibility of a run-time check failing and terminating the program<br>&gt; with an NPE can be mitigated by user code performing an explicit check for<br>&gt; nil at the use site. (Your proposal would require user code to check<br>&gt; against the metatype property whenever a generic type is mutated to ensure<br>&gt; that no preconditions can fail.)<br>&gt;<br></p><p>Yes, you see a lot of that for implicit optionals. But tellingly not for<br>Java arrays. Therefore the decision as to whether a type check should be<br>static or dynamic should be based on the use case. You cannot simply say<br>that everything should be static, it places enormous burden on the<br>programmer. People do say that everything should be dynamic though! Myself,<br>I think static is good if it is easy to do.<br></p><p>In practice you don&#39;t see runtime type checking in Java array code,<br>therefore I don&#39;t think there is any evidence to suggest you would in<br>Swift. Why would the two be different? Therefore I think runtime type<br>errors due to incorrect writes to Java generics would not be a problem in<br>practice.<br></p><p><br>&gt; 5. Removing the optional system would cause the type system to be more<br>&gt; imprecise, since a variable of type T would contain either an instance of T<br>&gt; or nil. (Your proposal would cause the type system to be more imprecise,<br>&gt; since a T&lt;U&gt; might actually be a T&lt;V&gt;, where V is a subtype of U, in a<br>&gt; context where V cannot substitute for U.)<br>&gt;<br></p><p>Sure, but for optionals that is a trade off well worth taking. The<br>alternative is nil checks everywhere.<br></p><p>The trade off made at the moment of using associated types is a great<br>burden on the programmer. Take a look at all the complexity in the<br>collections library at present. To give an idea of how complicated this is<br>take a look at the playground you can download from<br>https://github.com/rnapier/MyAnySequence. Its mightily complicated compared<br>to my proposal! Therefore I don&#39;t  think the current trade off is optimum.<br>Its always a trade off, the trick is to make the best.<br></p><p><br>Is that giving you an idea of where I am coming from?<br></p><p>  -- Howard.<br></p><p><br>&gt;<br>&gt; I hope this explains my objections (and those expressed elsewhere within<br>&gt; this thread) more clearly.<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 13, 2016 at 1:54 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; @Simon,<br>&gt;&gt;<br>&gt;&gt; In the Swift code below:<br>&gt;&gt;<br>&gt;&gt;     let array = [1]<br>&gt;&gt;<br>&gt;&gt;     array[0] // 1, OK<br>&gt;&gt;<br>&gt;&gt;     array[1] // Error not detected by compiler but detected at runtime<br>&gt;&gt;<br>&gt;&gt; you have an example of an error detected at runtime that terminates<br>&gt;&gt; program execution, it doesn&#39;t return an optional.<br>&gt;&gt;<br>&gt;&gt; In other languages this would be a type error, these languages are<br>&gt;&gt; usually described as dependent type (<br>&gt;&gt; https://en.wikipedia.org/wiki/Dependent_type). An example of the<br>&gt;&gt; advantage of this would be vector (or matrix multiplication), e.g. imagine<br>&gt;&gt; that Swift had dependent types:<br>&gt;&gt;<br>&gt;&gt;     let row = RowVec(1, 2) // Type: matrix of int with 1 row and 0<br>&gt;&gt; columns (note size is part of the type)<br>&gt;&gt;<br>&gt;&gt;     let col = ColVec(3) // Type: matrix of int with 0 rows and 1 column<br>&gt;&gt;<br>&gt;&gt;     let scaler = row * col // Compile time error because both vectors<br>&gt;&gt; should be the same length<br>&gt;&gt;<br>&gt;&gt; At the moment if you wrote a matrix package in Swift the above example<br>&gt;&gt; would be a runtime error and not a compile time error, but with dependent<br>&gt;&gt; typing it would be a compile time error.<br>&gt;&gt;<br>&gt;&gt; There is another discussion of Swift Evolution on calculable types that<br>&gt;&gt; are closely related to dependent typing.<br>&gt;&gt;<br>&gt;&gt; To me you just strike the balance, sometimes static checking is best<br>&gt;&gt; sometimes runtime. You strike the balance by how practical it is to do the<br>&gt;&gt; static checking, if the burden that the static checking adds to the users<br>&gt;&gt; then it isn&#39;t worth it. This is the case with annotated variance in<br>&gt;&gt; languages like Java and Scala, the annotations do not add much. Hence I am<br>&gt;&gt; suggesting system that is simple to use, much like Swift arrays are easy to<br>&gt;&gt; use but not totally, but largely, statically typed.<br>&gt;&gt;<br>&gt;&gt; Hope that explains my reasoning for making most type error compile time<br>&gt;&gt; checked but a small subset runtime checked,<br>&gt;&gt;<br>&gt;&gt;  -- Howard.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 13 January 2016 at 14:01, Simon Pilkington &lt;<br>&gt;&gt; simonmpilkington at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I’d be interested in reading up on what the Oracle response was if you<br>&gt;&gt;&gt; have links.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As you mentioned even Swift doesn’t get away from runtime type checking<br>&gt;&gt;&gt; but in the two examples you mentioned - array out of bounds and casts -<br>&gt;&gt;&gt; Swift makes use of the Optionals system to highlight that an operation may<br>&gt;&gt;&gt; fail and allows the user to handle that failure. Covariance should have<br>&gt;&gt;&gt; similar syntax support (for example use of optional chaining similar to<br>&gt;&gt;&gt; optional protocol requirements to indicate that a call may fail due to<br>&gt;&gt;&gt; incorrect types). For the compiler to understand when such failure is<br>&gt;&gt;&gt; possible, some kind of covariance syntax would be required.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As a related question, do you see covariance syntax as such a burden?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Simon<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 Jan 2016, at 12:47 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes you can annotate for covariance, invariance, and contravariance,<br>&gt;&gt;&gt; both Java and Scala, allow all three. The problem is that the code becomes<br>&gt;&gt;&gt; splattered with variance annotations. The Java people themselves have<br>&gt;&gt;&gt; publicly regretted this and wished that they had made covariance the<br>&gt;&gt;&gt; default. If you look at generic code invariance and covariance are by far<br>&gt;&gt;&gt; the most common requirements; this proposal would address these common use<br>&gt;&gt;&gt; case without burdening the programmer.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift, and no usable language, is completely statically typed. Examples<br>&gt;&gt;&gt; in Swift of runtime type checking are array out of bounds and casts. There<br>&gt;&gt;&gt; are other examples of non-type related runtime checks is Swift: numerical<br>&gt;&gt;&gt; overflow, throws, using optionals to signal errors, and using enums to<br>&gt;&gt;&gt; signal errors. I say use what is appropriate, static type checking if it is<br>&gt;&gt;&gt; easy to do, otherwise runtime type checking. Note I am not proposing an<br>&gt;&gt;&gt; unsafe language like C, it is still type checked.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is a strong positive precedence for a type check on write, Java<br>&gt;&gt;&gt; arrays (not Java `List`s). Arrays in Java may be passed covariantly, and<br>&gt;&gt;&gt; this is extensively used. However if you attempt to write the wrong type<br>&gt;&gt;&gt; into the array you will get an `ArrayStoreException`. In practice you don&#39;t<br>&gt;&gt;&gt; get many `ArrayStoreException`, non of my code has ever had one. Its just<br>&gt;&gt;&gt; not something you do in practice, as noted before contravariance is rare.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks for you comments and I hope this eases your concerns,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 13 January 2016 at 11:33, Simon Pilkington &lt;<br>&gt;&gt;&gt; simonmpilkington at icloud.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is<br>&gt;&gt;&gt;&gt; indeed not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal<br>&gt;&gt;&gt;&gt; attempts to get around this difference with a runtime failure but this<br>&gt;&gt;&gt;&gt; would result in very fragile code - you get passed a Box&lt;Top&gt; and want to<br>&gt;&gt;&gt;&gt; pass it a subclass of Top, will it succeed, who knows. You probably would<br>&gt;&gt;&gt;&gt; be able to check the types but the complier wouldn’t highlight that this is<br>&gt;&gt;&gt;&gt; an operation that could potentially fail.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This seems to be very much against Swift’s goal of safety being<br>&gt;&gt;&gt;&gt; enforced by the compiler as much as possible.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Java uses the wildcard syntax to highlight this conceptual and<br>&gt;&gt;&gt;&gt; behavioural difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but<br>&gt;&gt;&gt;&gt; rather with Box&lt;? extends Top&gt;. The compiler can then enforce that a<br>&gt;&gt;&gt;&gt; programmer doesn’t try to pass an incompatible type to a variable of such<br>&gt;&gt;&gt;&gt; type. Even though this is a complication to the language (many Java<br>&gt;&gt;&gt;&gt; programmers struggle with correctly using the wildcard syntax) I don’t see<br>&gt;&gt;&gt;&gt; covariance for generics being added to Swift in a robust manner without<br>&gt;&gt;&gt;&gt; some kind of similar syntax.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Simon<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently you generics are invariant whereas function arguments etc.<br>&gt;&gt;&gt;&gt; are covariant. I am suggesting that if the way generics are implemented is<br>&gt;&gt;&gt;&gt; changed then they can be made covariant and that this will add considerable<br>&gt;&gt;&gt;&gt; utility to Swift generics.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Current system<br>&gt;&gt;&gt;&gt;     class Top {}<br>&gt;&gt;&gt;&gt;     class Bottom: Top {}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;&gt;&gt;         var value: T<br>&gt;&gt;&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;&gt;&gt;             value = initialValue;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not*<br>&gt;&gt;&gt;&gt; a `Box&lt;Top&gt;`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I am suggesting:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt;&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt;&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value:<br>&gt;&gt;&gt;&gt; T { get set } }` and that this mechanism replaces associated types for<br>&gt;&gt;&gt;&gt; protocols.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Proposal:<br>&gt;&gt;&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as<br>&gt;&gt;&gt;&gt; before<br>&gt;&gt;&gt;&gt;     // 2. Code transformed by comiler with write check for each<br>&gt;&gt;&gt;&gt; specific, generic type instance<br>&gt;&gt;&gt;&gt;     // Best approximation of resulting code in current Swift to<br>&gt;&gt;&gt;&gt; demonstrate spirit of idea:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Compiler writes a universal form using the upper bound (it<br>&gt;&gt;&gt;&gt; writes the underlyting representation).<br>&gt;&gt;&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject`<br>&gt;&gt;&gt;&gt; to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         // Generated from stored property `var value: T` and noting<br>&gt;&gt;&gt;&gt; that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;&gt;         private var _value: AnyObject // Access the stored property<br>&gt;&gt;&gt;&gt; through a setter so that type can be checked<br>&gt;&gt;&gt;&gt;         var value: AnyObject {<br>&gt;&gt;&gt;&gt;             get {<br>&gt;&gt;&gt;&gt;                 return _value<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;             set {<br>&gt;&gt;&gt;&gt;                 // In all functions check that args declared as `T`<br>&gt;&gt;&gt;&gt; are actually a `T` or a sub-type.<br>&gt;&gt;&gt;&gt;                 // Note: `is` only works with type literal and there<br>&gt;&gt;&gt;&gt; is no `&gt;=` operator for types :(.<br>&gt;&gt;&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding,<br>&gt;&gt;&gt;&gt; nearest at moment `==`.<br>&gt;&gt;&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type<br>&gt;&gt;&gt;&gt; of newValue, \(newValue.dynamicType), is not a sub-type of generic<br>&gt;&gt;&gt;&gt; type T, \(T)&quot;)<br>&gt;&gt;&gt;&gt;                 _value = newValue<br>&gt;&gt;&gt;&gt;             }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that<br>&gt;&gt;&gt;&gt; `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue:<br>&gt;&gt;&gt;&gt; AnyObject) {<br>&gt;&gt;&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;&gt;&gt;             _value = initialValue<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore<br>&gt;&gt;&gt;&gt; can be bitwise copied<br>&gt;&gt;&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all<br>&gt;&gt;&gt;&gt; the `T`s in the `init` call.<br>&gt;&gt;&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would<br>&gt;&gt;&gt;&gt; write `let bT = Box(Top())`.<br>&gt;&gt;&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user<br>&gt;&gt;&gt;&gt; would write `let bB = Box(Bottom())`.<br>&gt;&gt;&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;&gt;&gt;     bT = bB // Compiler would check covariance of declared generic<br>&gt;&gt;&gt;&gt; types.<br>&gt;&gt;&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write<br>&gt;&gt;&gt;&gt; `bT = Box(Top())`.<br>&gt;&gt;&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need<br>&gt;&gt;&gt;&gt; `&gt;=` for types, but would work in practice<br>&gt;&gt;&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The implications of this proposal are:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt;&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt;&gt;&gt; 3. Protocols can be made generic instead of having an associated type<br>&gt;&gt;&gt;&gt; and then they become a proper type with dynamic dispatch.<br>&gt;&gt;&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols,<br>&gt;&gt;&gt;&gt; structs, and classes and unlike associated type protocols that can only be<br>&gt;&gt;&gt;&gt; a generic constraint.<br>&gt;&gt;&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced<br>&gt;&gt;&gt;&gt; by a more powerful and easier to understand semantic of a type, just like<br>&gt;&gt;&gt;&gt; the other types.<br>&gt;&gt;&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`,<br>&gt;&gt;&gt;&gt; that use a `where` clause to constrain an associated type protocol, this<br>&gt;&gt;&gt;&gt; would be unnecessary.<br>&gt;&gt;&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that<br>&gt;&gt;&gt;&gt; would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Advantages:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt;&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt;&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have<br>&gt;&gt;&gt;&gt; arrays and fields of a generic protocol.<br>&gt;&gt;&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols<br>&gt;&gt;&gt;&gt; can be made into a ‘proper’ type or at least a concept that is easier to<br>&gt;&gt;&gt;&gt; understand.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Compatibility:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. This would be a major change since associated types in protocols<br>&gt;&gt;&gt;&gt; would be replaced by generics.<br>&gt;&gt;&gt;&gt; 2. The new implementation of generics might break some existing<br>&gt;&gt;&gt;&gt; `struct` and `class` code, for example if it is dependent on the exact size<br>&gt;&gt;&gt;&gt; of an object because the class will have extra fields, one for each generic<br>&gt;&gt;&gt;&gt; type, and therefore will be larger.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Disadvantages:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Major change.<br>&gt;&gt;&gt;&gt; 2. Object size increases.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   — Howard.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; PS This is part of a collection of proposals previously presented as<br>&gt;&gt;&gt;&gt; “Protocols on Steroids”.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/6be0c4f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Howard,<br></p><p>&gt; On Jan 13, 2016, at 8:35 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; @ Austin,<br>&gt; <br>&gt; Comments inline below.<br>&gt; <br>&gt; On 14 January 2016 at 10:02, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; Hi Howard,<br>&gt; <br>&gt; Making generics covariant by default would add even more of a burden to users. They would need to check the type property of a generic object any time they wanted to mutate that generic object or risk their program terminating.<br>&gt; <br>&gt; Its a matter of balance, is that checking necessary. You certainly don&#39;t see it with Java arrays and this isn&#39;t a problem in practice. If you burden everyone with an annotation and in real programs that imperceptibly reduces the number of error then it was a bad call. The Java use case indicates that it is a bad call.<br></p><p>I don&#39;t agree. Java Lists are generic and invariant; AFAICT they are preferred over arrays in many cases except when primitives are being stored et al. I suspect this is why the number of errors is &quot;imperceptible&quot; (if it actually is; is there any data on the subject?), because people are using the (sound) abstraction.<br> <br>&gt; <br>&gt; I don&#39;t think the fact that array accesses are checked at runtime is a good example:<br>&gt; <br>&gt; 1. The Swift team has stated that subscripting into an array returns a non-optional at least in part because of performance issues. (Unfortunately, I think this was mentioned on the old Apple developer forums, which are now inaccessible, so don&#39;t take my word for it until someone with more insight says so one way or another :).<br>&gt; <br>&gt; What about write to an array, you still have to check bounds. An optional won&#39;t help.<br></p><p>I don&#39;t think it&#39;s relevant. Checking the bounds before writing to an array is still trivial.<br></p><p>&gt;  <br>&gt; 2. The fact that this specific aspect of Swift is checked at runtime doesn&#39;t provide insight as to whether or not another aspect of Swift should be compile-time or runtime-checked; it just indicates that there exists the possibility of some checks being done at runtime (and every mainstream statically typed language performs runtime checks to some extent, this isn&#39;t a novel conclusion).<br>&gt; <br>&gt; Yes it says that they are making pragmatic choices, the designers will be well aware of type systems that check array bounds but chose, in my opinion correctly, to go down the path of a runtime check for reasons of practicality. The dependant type system or similar does not pay for itself in terms of improved programmer productivity and application reliability.<br></p><p>Dependent types have nothing to do with this; the point of the Swift array is to model a collection of items whose size is not known at compile-time and therefore must be checked at runtime. This is distinct from a fixed-length array or some other type of construct where the size and/or bounds are known at compile time and can reasonably be checked then.<br></p><p>&gt;  <br>&gt; 3. Checking that an array access is in bounds is trivial from a conceptual standpoint. The index needs to be at least 0 and at most the length of the array - 1.<br>&gt; <br>&gt; Type checking is equally trivial and can often be optimised away.<br></p><p>No it&#39;s not. Maybe if you think your type is a bottom type you can reason away the type checks. But if your bottom type is a protocol or non-final class, and code in a dependency inherits from that class or protocol, suddenly code you thought was sound might start breaking. This is a far cry from a binary &#39;nil or not nil&#39; type of check.<br></p><p>&gt;  <br>&gt; 4. The length of a Swift array is not part of the type contract, whereas the type enclosed within a generic type is. Swift doesn&#39;t have fixed-length arrays.<br>&gt; <br>&gt; Well it isn&#39;t in Swift, but in some languages it is. Proponents of these languages would point to a matrix math API and note how the compiler can check matrix size for conformance at compile time. Whereas in Swift that is a runtime check. The proponents would point to the inefficiency of runtime checking and the fact that you now need to test the code. I think the Swift team have taken the right approach and are saying typing the size of an array is not worth it.<br></p><p>There&#39;s a discussion going on right now about what it would take to add compile-time dimensional analysis to the language. Engineers have expressed interest in things like fixed-length arrays and non-type generic parameters to support exactly such a use case. I wouldn&#39;t read too much into what the current capabilities and limitations of Array mean and don&#39;t mean in terms of Swift&#39;s future design, although a core team member is free to pop in and clear things up again :).<br></p><p>&gt; <br>&gt; <br>&gt; I think a proposal to get rid of optionals and non-nullable types would be a better analogy. Here is a comparison to that hypothetical proposal:<br>&gt; <br>&gt; 1. The most popular objection to Swift&#39;s optional system seems to be either clutter (from the ?, ! sigils) and ease of use. (Your proposal cites the ugliness of variance annotations in other languages as a primary motivation.)<br>&gt; <br>&gt; Not really, you are not comparing like with like. If Swift didn&#39;t have explicit optionals it would most likely have implicit optionals like Obj-C and Java. IE everything is an optional. I like Swift&#39;s solution since most things aren&#39;t actually optional and therefore overall it reduces the burden on the programmer (in other systems you are continuously testing for nil). In terms of variance for generics if there were a method of giving static type checking without burdening the programmer with annotations then I would be in favour (unfortunately I do not know of such a system).<br></p><p>The whole point is that declarations of optionality at the definition site are analogous to declarations of variance at the definition site (rather than checking at the use site). In Swift&#39;s system every single variable, property, parameter, return type needs to be annotated with whether or not it is nullable. If annotating variance is a burden but annotating nullability isn&#39;t then we probably have two fundamentally incompatible ideas of what burdensomeness entails.<br></p><p>&gt;  <br>&gt; 2. Removing the optional system would result in moving a compile-time check to a run-time check. (Your proposal states that the burden of ensuring the access is valid lies at the use site, which introduces the possibility of runtime failures that cannot be currently expressed.)<br>&gt; <br>&gt; No it would most likely mean that there were nil checks everywhere, just like Java and to some extent Obj-C. IE an overall increase in programmer burden.<br></p><p>Yes, and the argument is that I shouldn&#39;t have to worry about whether one of my Foo&lt;Bar&gt;s is actually a Foo&lt;Bar&gt; or a Foo&lt;Baz&gt; that will crash my program if I don&#39;t explicitly check and guess wrong, because the language&#39;s variance rules allow two incompatible kinds of objects to be represented by the same type. Just like I shouldn&#39;t have to worry about whether or not my Qux instance is actually a Qux or a null pointer because the language&#39;s optionality rules allow two incompatible kinds of objects to be represented by the same type, and I didn&#39;t explicitly check and guessed wrong.<br></p><p>&gt;  <br>&gt; 3. Removing optionals would keep the language type-safe, as an exception would occur whenever calling a method on nil occurred at runtime (your proposal also keeps the language type-safe, in the formal sense). <br>&gt; <br>&gt; Yes. Whether you have explicit optionals or implicit optionals it is still type safe.<br>&gt;  <br>&gt; 4. The possibility of a run-time check failing and terminating the program with an NPE can be mitigated by user code performing an explicit check for nil at the use site. (Your proposal would require user code to check against the metatype property whenever a generic type is mutated to ensure that no preconditions can fail.)<br>&gt; <br>&gt; Yes, you see a lot of that for implicit optionals. But tellingly not for Java arrays. Therefore the decision as to whether a type check should be static or dynamic should be based on the use case. You cannot simply say that everything should be static, it places enormous burden on the programmer. People do say that everything should be dynamic though! Myself, I think static is good if it is easy to do.<br>&gt; <br>&gt; In practice you don&#39;t see runtime type checking in Java array code, therefore I don&#39;t think there is any evidence to suggest you would in Swift. Why would the two be different? Therefore I think runtime type errors due to incorrect writes to Java generics would not be a problem in practice.<br></p><p>Nobody is saying that everything should be static, that is a straw man. There is a perfectly good solution, which is to expose whatever mechanism Swift uses to internally mark things like Array&lt;T&gt; as covariant, and leave the default as invariant, which gives you both the flexibility of user-defined variance and the safety that Swift has right now. Whether or not something is covariant or contravariant rather than invariant should depend entirely on its semantics.<br></p><p>&gt;  <br>&gt; 5. Removing the optional system would cause the type system to be more imprecise, since a variable of type T would contain either an instance of T or nil. (Your proposal would cause the type system to be more imprecise, since a T&lt;U&gt; might actually be a T&lt;V&gt;, where V is a subtype of U, in a context where V cannot substitute for U.)<br>&gt; <br>&gt; Sure, but for optionals that is a trade off well worth taking. The alternative is nil checks everywhere.<br>&gt; <br>&gt; The trade off made at the moment of using associated types is a great burden on the programmer. Take a look at all the complexity in the collections library at present. To give an idea of how complicated this is take a look at the playground you can download from https://github.com/rnapier/MyAnySequence &lt;https://github.com/rnapier/MyAnySequence&gt;. Its mightily complicated compared to my proposal! Therefore I don&#39;t  think the current trade off is optimum. Its always a trade off, the trick is to make the best.<br></p><p>Removing associated types and making generics covariant are two different topics, although your proposal seems to have linked them. I&#39;m only concerned about the covariance aspect right now, because if that were dropped the proposed impl would have to be modified anyways.<br></p><p>&gt; <br>&gt; <br>&gt; Is that giving you an idea of where I am coming from?<br></p><p>I understand exactly where you are coming from. What I, and many other people in this thread are saying, is that we do not want to make the language less safe in order to spare the programmer the pain of typing out explicit variance annotations.<br></p><p>Arguing that some runtime checks for other things exist in Swift, therefore this unrelated specific thing should also be deferred to a runtime check, is not persuasive. Like you said, compile-time safety is a matter of balance; where I fall on that spectrum is a different point than where you fall. To you, the trade-off is worth it; to me (and the other people making the same arguments), it is not. To you, writing out your abstractions using associated types is painful; I haven&#39;t felt the same way.<br></p><p>In the end, this is just my opinion, I don&#39;t have any special veto powers, and I wouldn&#39;t want to bore you by restating my points again and again. If you can convince the core team and the other participants in the group that the trade-off is worth it and drive a proposal through to acceptance, all the better.<br></p><p>Best,<br>Austin<br></p><p>&gt; <br>&gt;   -- Howard.<br>&gt;  <br>&gt; <br>&gt; I hope this explains my objections (and those expressed elsewhere within this thread) more clearly.<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Wed, Jan 13, 2016 at 1:54 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; @Simon,<br>&gt; <br>&gt; In the Swift code below:<br>&gt; <br>&gt;     let array = [1]<br>&gt;     array[0] // 1, OK<br>&gt;     array[1] // Error not detected by compiler but detected at runtime<br>&gt; <br>&gt; you have an example of an error detected at runtime that terminates program execution, it doesn&#39;t return an optional.<br>&gt; <br>&gt; In other languages this would be a type error, these languages are usually described as dependent type (https://en.wikipedia.org/wiki/Dependent_type &lt;https://en.wikipedia.org/wiki/Dependent_type&gt;). An example of the advantage of this would be vector (or matrix multiplication), e.g. imagine that Swift had dependent types:<br>&gt; <br>&gt;     let row = RowVec(1, 2) // Type: matrix of int with 1 row and 0 columns (note size is part of the type)<br>&gt;     let col = ColVec(3) // Type: matrix of int with 0 rows and 1 column<br>&gt;     let scaler = row * col // Compile time error because both vectors should be the same length<br>&gt; <br>&gt; At the moment if you wrote a matrix package in Swift the above example would be a runtime error and not a compile time error, but with dependent typing it would be a compile time error.<br>&gt; <br>&gt; There is another discussion of Swift Evolution on calculable types that are closely related to dependent typing.<br>&gt; <br>&gt; To me you just strike the balance, sometimes static checking is best sometimes runtime. You strike the balance by how practical it is to do the static checking, if the burden that the static checking adds to the users then it isn&#39;t worth it. This is the case with annotated variance in languages like Java and Scala, the annotations do not add much. Hence I am suggesting system that is simple to use, much like Swift arrays are easy to use but not totally, but largely, statically typed.<br>&gt; <br>&gt; Hope that explains my reasoning for making most type error compile time checked but a small subset runtime checked,<br>&gt; <br>&gt;  -- Howard.<br>&gt; <br>&gt; <br>&gt; On 13 January 2016 at 14:01, Simon Pilkington &lt;simonmpilkington at icloud.com &lt;mailto:simonmpilkington at icloud.com&gt;&gt; wrote:<br>&gt; I’d be interested in reading up on what the Oracle response was if you have links.<br>&gt; <br>&gt; As you mentioned even Swift doesn’t get away from runtime type checking but in the two examples you mentioned - array out of bounds and casts - Swift makes use of the Optionals system to highlight that an operation may fail and allows the user to handle that failure. Covariance should have similar syntax support (for example use of optional chaining similar to optional protocol requirements to indicate that a call may fail due to incorrect types). For the compiler to understand when such failure is possible, some kind of covariance syntax would be required.<br>&gt; <br>&gt; As a related question, do you see covariance syntax as such a burden?<br>&gt; <br>&gt; -Simon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/402b604b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 13, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:11 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Howard,<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 8:35 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; @ Austin,<br>&gt;&gt; <br>&gt;&gt; Comments inline below.<br>&gt;&gt; <br>&gt;&gt; On 14 January 2016 at 10:02, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Hi Howard,<br>&gt;&gt; <br>&gt;&gt; Making generics covariant by default would add even more of a burden to users. They would need to check the type property of a generic object any time they wanted to mutate that generic object or risk their program terminating.<br>&gt;&gt; <br>&gt;&gt; Its a matter of balance, is that checking necessary. You certainly don&#39;t see it with Java arrays and this isn&#39;t a problem in practice. If you burden everyone with an annotation and in real programs that imperceptibly reduces the number of error then it was a bad call. The Java use case indicates that it is a bad call.<br>&gt; <br></p><p>[snip]<br></p><p>&gt; <br>&gt;&gt; 4. The length of a Swift array is not part of the type contract, whereas the type enclosed within a generic type is. Swift doesn&#39;t have fixed-length arrays.<br>&gt;&gt; <br>&gt;&gt; Well it isn&#39;t in Swift, but in some languages it is. Proponents of these languages would point to a matrix math API and note how the compiler can check matrix size for conformance at compile time. Whereas in Swift that is a runtime check. The proponents would point to the inefficiency of runtime checking and the fact that you now need to test the code. I think the Swift team have taken the right approach and are saying typing the size of an array is not worth it.<br>&gt; <br>&gt; There&#39;s a discussion going on right now about what it would take to add compile-time dimensional analysis to the language. Engineers have expressed interest in things like fixed-length arrays and non-type generic parameters to support exactly such a use case. I wouldn&#39;t read too much into what the current capabilities and limitations of Array mean and don&#39;t mean in terms of Swift&#39;s future design, although a core team member is free to pop in and clear things up again :).<br></p><p>Fixed-length arrays have come up a number of time in core team discussions, and would be a reasonable future extension to Swift. If nothing else, it’s important for C interoperability (have you seen the awful things we do when importing C structs containing array members?) and comes up almost immediately whenever someone talks about “low-level” Swift.<br></p><p>Non-type generic parameters is another thing that comes up from time to time in core team discussions. It’s usually motivated by fixed-length arrays (because *clearly* we would want to implement a fixed-size array in the standard library, not as a compiler hack, and that probably means non-type generic parameters), fixed-length vector types, or dimensional analysis. The discussion usually stops when we realize that we either need to design a model for constant expressions or admit some form of dependent typing in the language, both of which are major endeavors that are well out of scope for Swift 3.<br></p><p>&gt;&gt; Is that giving you an idea of where I am coming from?<br>&gt; <br>&gt; I understand exactly where you are coming from. What I, and many other people in this thread are saying, is that we do not want to make the language less safe in order to spare the programmer the pain of typing out explicit variance annotations.<br>&gt; <br>&gt; Arguing that some runtime checks for other things exist in Swift, therefore this unrelated specific thing should also be deferred to a runtime check, is not persuasive. Like you said, compile-time safety is a matter of balance; where I fall on that spectrum is a different point than where you fall. To you, the trade-off is worth it; to me (and the other people making the same arguments), it is not. To you, writing out your abstractions using associated types is painful; I haven&#39;t felt the same way.<br>&gt; <br>&gt; In the end, this is just my opinion, I don&#39;t have any special veto powers, and I wouldn&#39;t want to bore you by restating my points again and again. If you can convince the core team and the other participants in the group that the trade-off is worth it and drive a proposal through to acceptance, all the better.<br></p><p>I don’t speak for the core team as a whole (i.e., we have not discussed this specifically), but my personal opinion aligns with what Austin is saying: this isn’t the right set of trade-offs for Swift.<br></p><p>I consider covariant generic parameters *by default* to be a non-starter. Outside of collection types, I wouldn’t expect the vast majority of generics to behave covariantly. Swift is fairly rigid about type soundness—if you’re going to do something that can break soundness, it’s going to require some explicit syntax involving a cast or *unsafe* component—so introducing this kind of runtime-enforced soundness by default would be going against the spirit of Swift.<br></p><p>As for opt-in variance, I’m predisposed against it (and I know of another core team member who doesn’t think it’s a worthwhile feature in a mainstream language). It’s not that it’s a foreign concept: we included variance in the Objective-C generics system because it was important for subtyping of the immutable collections. However, it’s important to note there that it is *not* the default: only immutable collections opt in to covariant generic parameters. The mutable collections (NSMutableArray, NSMutableSet, etc.) have invariant generic parameters, because we (a group that included the Swift core team) opted for a more sound static type-checking model (modulo Objective-C’s type erasure).<br></p><p>It’s also important to note that variance is not free in Swift the way it is in Java. If I have<br></p><p>  struct X&lt;covariant T&gt; { var t: T }<br></p><p>then someone coming from a Java background might expect that implicitly converting X&lt;Int&gt; to an X&lt;Any&gt; would effectively be free at runtime, because in Java an instance of T would always be an object and all objects have the same layout. However, this is not the case in Swift: an X&lt;Int&gt; directly stores an Int (1 word) while X&lt;Any&gt; directly stores an Any (4 words), so there’s a nontrivial cost in performing that conversion.<br></p><p>As I noted in my other reply, Swift’s value-semantic collections are covariant in their generic parameters, which we do through some fairly tight coupling between the compiler and standard library. From a theoretical standpoint, I’m very happy with the way value-semantic collections provide subtyping and mutation while maintaining soundness (== no runtime checks needed), and for me I would consider it “enough” if we were to formalize that compiler/collection type interaction with some kind of protocol so other collection types could opt in to subtyping, because I don’t think variance—as a language feature—carries its weight outside of the fairly narrow collection-subtyping cases. It would take a significant body of real-world evidence of important non-collection generic types that benefit from variance for me to reconsider my position against adding variance into the language.<br></p><p>From a practical standpoint, I’m not completely convinced that collection subtyping is all that important. I *love* the feature for its theoretical beauty with value semantics, but it has a cost (in complexity and in runtime performance) that I’m not sure is paid for by its uses in the real world. It’s something I’d like to investigate further before we dive into the generalization the feature for other collections.<br></p><p>	- Doug<br></p><p>[*] Accessing @objc members on AnyObject is the major exception that I can think of.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/ea0e24f3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 13, 2016 at 06:00:00am</p></header><div class="content"><p>Strong -1 from me as well for making the type system unsound.<br></p><p>&gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations<br></p><p>Ceylon uses a different approach which is variance annotations at the definition site.<br>This restricts the possible usage of the type parameters to appropriately variant positions.<br></p><p>This migt be a better way to deal with variance.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>@Thorsten,<br></p><p>It doesn&#39;t make the type system unsound; the types are mostly checked at<br>compile time but some are runtime checked, either way the types are checked<br>and therefore the type system is sound. I have posted an example of array<br>runtime type checking in a previous response.<br></p><p>You can annotate variance, but this generally adds a lot of clutter to the<br>code (see some typical Java code that uses generics you will see stuff like<br>? extends Type everywhere). In other languages like Scala the annotation is<br>less visually intrusive, because they use shorter syntax and because it is<br>annotated at declaration site rather than use site, but it is still there.<br></p><p>I think Swift arrays are a good example of partially static and partially<br>runtime checked. The content is statically typed but the size is runtime<br>typed. Other languages do type both the content and the size (see Dependent<br>Typing on Wiki), however at some considerable burden on the programmer.<br></p><p>Hope this explains the thought process,<br></p><p> -- Howard.<br></p><p>On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;<br>&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance,<br>&gt; both Java and Scala, allow all three. The problem is that the code becomes<br>&gt; splattered with variance annotations<br>&gt;<br>&gt; Ceylon uses a different approach which is variance annotations at the<br>&gt; definition site.<br>&gt; This restricts the possible usage of the type parameters to appropriately<br>&gt; variant positions.<br>&gt;<br>&gt; This migt be a better way to deal with variance.<br>&gt;<br>&gt; -Thorsten<br></p><p><br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/5031ea36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 13, 2016 at 05:00:00pm</p></header><div class="content"><p>It does indeed make the type system unsound in some cases.  You have chosen one particular variance direction because it is convenient. A classic counterexample is Java making Arrays covariant by default.  So this works<br></p><p>Integer[] arr = [2, 4, 6, 8, 10];<br>Object[] orr = arr;<br>orr[0] = &quot;crash bang&quot;;<br></p><p>And crashes at runtime.  For that, I must give this part of the proposal a strong -1.  Any amount of type safety I have to give up in the name of convenience is far too much.<br></p><p>I am, however, a fan of generic protocols.  They seem like an orthogonal concept given the first part here though.<br></p><p>~Robert Widmann<br></p><p>2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; @Thorsten,<br>&gt; <br>&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound. I have posted an example of array runtime type checking in a previous response.<br>&gt; <br>&gt; You can annotate variance, but this generally adds a lot of clutter to the code (see some typical Java code that uses generics you will see stuff like ? extends Type everywhere). In other languages like Scala the annotation is less visually intrusive, because they use shorter syntax and because it is annotated at declaration site rather than use site, but it is still there.<br>&gt; <br>&gt; I think Swift arrays are a good example of partially static and partially runtime checked. The content is statically typed but the size is runtime typed. Other languages do type both the content and the size (see Dependent Typing on Wiki), however at some considerable burden on the programmer. <br>&gt; <br>&gt; Hope this explains the thought process,<br>&gt; <br>&gt;  -- Howard.<br>&gt; <br>&gt;&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt; <br>&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations<br>&gt;&gt; <br>&gt;&gt; Ceylon uses a different approach which is variance annotations at the definition site.<br>&gt;&gt; This restricts the possible usage of the type parameters to appropriately variant positions.<br>&gt;&gt; <br>&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/5447ba4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 12:00:00pm</p></header><div class="content"><p>@Robert,<br></p><p>The behaviour you show for Java arrays is what I am proposing, but that<br>isn&#39;t type unsafe. The type error is detected at runtime and is flagged<br>with an ArrayStoreException. This is unlike C for example that would allow<br>the store, at least with a cast,  and would put into the array the address<br>of the string. Therefore neither the proposal or Java is type unsafe, both<br>are type safe and both detect type errors at runtime.<br></p><p>The question is whether protecting against this is worthwhile, not whether<br>it can be protected against or not (it can be). Arrays are a good example,<br>Swift takes the approach (like most languages) of checking the array size<br>at runtime. But languages with dependent typing check the array size at<br>compile time, i.e. a dependently typed language would detect this error:<br></p><p>let array = [1]<br></p><p>array[0] // 1, OK<br></p><p>array[1] // Error not detected by compiler but detected at runtime<br></p><p>because in such a language array would be typed as int array of size one,<br>not int array of any size.<br></p><p>So the real question is in a language like Java, how many times do you get<br>ArrayStoreException? In my own code I have never seen an array store<br>exception! Why? Because contravariant writes are very rare. If you were to<br>protect against contravariant writes you would be complicating the language<br>for no practical gain, which I think is a bad trade off.<br></p><p>Hope this explains the reasoning,<br></p><p> -- Howard.<br></p><p>On 14 January 2016 at 09:21, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p>&gt; It does indeed make the type system unsound in some cases.  You have<br>&gt; chosen one particular variance direction because it is convenient. A<br>&gt; classic counterexample is Java making Arrays covariant by default.  So this<br>&gt; works<br>&gt;<br>&gt; Integer[] arr = [2, 4, 6, 8, 10];<br>&gt; Object[] orr = arr;<br>&gt; orr[0] = &quot;crash bang&quot;;<br>&gt;<br>&gt; And crashes at runtime.  For that, I must give this part of the proposal a<br>&gt; strong -1.  Any amount of type safety I have to give up in the name of<br>&gt; convenience is far too much.<br>&gt;<br>&gt; I am, however, a fan of generic protocols.  They seem like an orthogonal<br>&gt; concept given the first part here though.<br>&gt;<br>&gt; ~Robert Widmann<br>&gt;<br>&gt; 2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; @Thorsten,<br>&gt;<br>&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at<br>&gt; compile time but some are runtime checked, either way the types are checked<br>&gt; and therefore the type system is sound. I have posted an example of array<br>&gt; runtime type checking in a previous response.<br>&gt;<br>&gt; You can annotate variance, but this generally adds a lot of clutter to the<br>&gt; code (see some typical Java code that uses generics you will see stuff like<br>&gt; ? extends Type everywhere). In other languages like Scala the annotation is<br>&gt; less visually intrusive, because they use shorter syntax and because it is<br>&gt; annotated at declaration site rather than use site, but it is still there.<br>&gt;<br>&gt; I think Swift arrays are a good example of partially static and partially<br>&gt; runtime checked. The content is statically typed but the size is runtime<br>&gt; typed. Other languages do type both the content and the size (see Dependent<br>&gt; Typing on Wiki), however at some considerable burden on the programmer.<br>&gt;<br>&gt; Hope this explains the thought process,<br>&gt;<br>&gt;  -- Howard.<br>&gt;<br>&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt;<br>&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance,<br>&gt;&gt; both Java and Scala, allow all three. The problem is that the code becomes<br>&gt;&gt; splattered with variance annotations<br>&gt;&gt;<br>&gt;&gt; Ceylon uses a different approach which is variance annotations at the<br>&gt;&gt; definition site.<br>&gt;&gt; This restricts the possible usage of the type parameters to appropriately<br>&gt;&gt; variant positions.<br>&gt;&gt;<br>&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/34b782d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>I think this is missing the point of type safety.  Whether checking occurs at runtime or compile time is irrelevant.  What I want is a programming language whose well-typed programs “don’t go wrong” (in the Robin Milner sense), not one that allows me to discover its own definition for “wrong”.  What you call type safety is really just deferring errors until runtime, which defeats the purpose of even having one in the first place in my opinion.  Java made a horrendous mistake in this case, regardless of how common is may be in actual programs, and I don’t think Swift needs to make the same.  <br></p><p>I’ll put it simply: I would rather have a language that allows me to write a smaller class of safer programs than one that allows a larger class of flat-out wrong ones.<br></p><p>&gt; On Jan 13, 2016, at 8:05 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; @Robert,<br>&gt; <br>&gt; The behaviour you show for Java arrays is what I am proposing, but that isn&#39;t type unsafe. The type error is detected at runtime and is flagged with an ArrayStoreException. This is unlike C for example that would allow the store, at least with a cast,  and would put into the array the address of the string. Therefore neither the proposal or Java is type unsafe, both are type safe and both detect type errors at runtime.<br>&gt; <br>&gt; The question is whether protecting against this is worthwhile, not whether it can be protected against or not (it can be). Arrays are a good example, Swift takes the approach (like most languages) of checking the array size at runtime. But languages with dependent typing check the array size at compile time, i.e. a dependently typed language would detect this error:<br>&gt; <br>&gt; let array = [1]<br>&gt; array[0] // 1, OK<br>&gt; array[1] // Error not detected by compiler but detected at runtime<br>&gt; <br>&gt; because in such a language array would be typed as int array of size one, not int array of any size.<br>&gt; <br>&gt; So the real question is in a language like Java, how many times do you get ArrayStoreException? In my own code I have never seen an array store exception! Why? Because contravariant writes are very rare. If you were to protect against contravariant writes you would be complicating the language for no practical gain, which I think is a bad trade off.<br>&gt; <br>&gt; Hope this explains the reasoning,<br>&gt; <br>&gt;  -- Howard.<br>&gt; <br>&gt; On 14 January 2016 at 09:21, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt; It does indeed make the type system unsound in some cases.  You have chosen one particular variance direction because it is convenient. A classic counterexample is Java making Arrays covariant by default.  So this works<br>&gt; <br>&gt; Integer[] arr = [2, 4, 6, 8, 10];<br>&gt; Object[] orr = arr;<br>&gt; orr[0] = &quot;crash bang&quot;;<br>&gt; <br>&gt; And crashes at runtime.  For that, I must give this part of the proposal a strong -1.  Any amount of type safety I have to give up in the name of convenience is far too much.<br>&gt; <br>&gt; I am, however, a fan of generic protocols.  They seem like an orthogonal concept given the first part here though.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; @Thorsten,<br>&gt;&gt; <br>&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound. I have posted an example of array runtime type checking in a previous response.<br>&gt;&gt; <br>&gt;&gt; You can annotate variance, but this generally adds a lot of clutter to the code (see some typical Java code that uses generics you will see stuff like ? extends Type everywhere). In other languages like Scala the annotation is less visually intrusive, because they use shorter syntax and because it is annotated at declaration site rather than use site, but it is still there.<br>&gt;&gt; <br>&gt;&gt; I think Swift arrays are a good example of partially static and partially runtime checked. The content is statically typed but the size is runtime typed. Other languages do type both the content and the size (see Dependent Typing on Wiki), however at some considerable burden on the programmer. <br>&gt;&gt; <br>&gt;&gt; Hope this explains the thought process,<br>&gt;&gt; <br>&gt;&gt;  -- Howard.<br>&gt;&gt; <br>&gt;&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt; <br>&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations<br>&gt;&gt; <br>&gt;&gt; Ceylon uses a different approach which is variance annotations at the definition site.<br>&gt;&gt; This restricts the possible usage of the type parameters to appropriately variant positions.<br>&gt;&gt; <br>&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/96175f41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 03:00:00pm</p></header><div class="content"><p>@Developer,<br></p><p>I doubt you really mean:<br></p><p>&quot;I’ll put it simply: I would rather have a language that allows me to write<br>a smaller class of safer programs than one that allows a larger class of<br>flat-out wrong ones.&quot;<br></p><p>I doubt what you say because if that were the case in Swift you would<br>manually check for overflow and use the &amp;+ operator instead of the +<br>operator, because the + operator overflows with a runtime exception.<br></p><p>All practical programming languages and all programmers even when given the<br>choice, e.g. + or &amp;+ in Swift, will make a pragmatic choice:<br></p><p> 1. Is that compile time check worth it?<br> 2. Is that runtime check worth it?<br> 3. Or should I just cover this with a test case?<br></p><p>Its all a matter of balance,<br></p><p> -- Howard.<br></p><p>On 14 January 2016 at 12:09, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br></p><p>&gt; I think this is missing the point of type safety.  Whether checking occurs<br>&gt; at runtime or compile time is irrelevant.  What I want is a programming<br>&gt; language whose well-typed programs “don’t go wrong” (in the Robin Milner<br>&gt; sense), not one that allows me to discover its own definition for “wrong”.<br>&gt; What you call type safety is really just deferring errors until runtime,<br>&gt; which defeats the purpose of even having one in the first place in my<br>&gt; opinion.  Java made a horrendous mistake in this case, regardless of how<br>&gt; common is may be in actual programs, and I don’t think Swift needs to make<br>&gt; the same.<br>&gt;<br>&gt; I’ll put it simply: I would rather have a language that allows me to write<br>&gt; a smaller class of safer programs than one that allows a larger class of<br>&gt; flat-out wrong ones.<br>&gt;<br>&gt; On Jan 13, 2016, at 8:05 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; @Robert,<br>&gt;<br>&gt; The behaviour you show for Java arrays is what I am proposing, but that<br>&gt; isn&#39;t type unsafe. The type error is detected at runtime and is flagged<br>&gt; with an ArrayStoreException. This is unlike C for example that would allow<br>&gt; the store, at least with a cast,  and would put into the array the address<br>&gt; of the string. Therefore neither the proposal or Java is type unsafe, both<br>&gt; are type safe and both detect type errors at runtime.<br>&gt;<br>&gt; The question is whether protecting against this is worthwhile, not whether<br>&gt; it can be protected against or not (it can be). Arrays are a good example,<br>&gt; Swift takes the approach (like most languages) of checking the array size<br>&gt; at runtime. But languages with dependent typing check the array size at<br>&gt; compile time, i.e. a dependently typed language would detect this error:<br>&gt;<br>&gt; let array = [1]<br>&gt; array[0] // 1, OK<br>&gt; array[1] // Error not detected by compiler but detected at runtime<br>&gt;<br>&gt; because in such a language array would be typed as int array of size one,<br>&gt; not int array of any size.<br>&gt;<br>&gt; So the real question is in a language like Java, how many times do you get<br>&gt; ArrayStoreException? In my own code I have never seen an array store<br>&gt; exception! Why? Because contravariant writes are very rare. If you were to<br>&gt; protect against contravariant writes you would be complicating the language<br>&gt; for no practical gain, which I think is a bad trade off.<br>&gt;<br>&gt; Hope this explains the reasoning,<br>&gt;<br>&gt;  -- Howard.<br>&gt;<br>&gt; On 14 January 2016 at 09:21, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; It does indeed make the type system unsound in some cases.  You have<br>&gt;&gt; chosen one particular variance direction because it is convenient. A<br>&gt;&gt; classic counterexample is Java making Arrays covariant by default.  So this<br>&gt;&gt; works<br>&gt;&gt;<br>&gt;&gt; Integer[] arr = [2, 4, 6, 8, 10];<br>&gt;&gt; Object[] orr = arr;<br>&gt;&gt; orr[0] = &quot;crash bang&quot;;<br>&gt;&gt;<br>&gt;&gt; And crashes at runtime.  For that, I must give this part of the proposal<br>&gt;&gt; a strong -1.  Any amount of type safety I have to give up in the name of<br>&gt;&gt; convenience is far too much.<br>&gt;&gt;<br>&gt;&gt; I am, however, a fan of generic protocols.  They seem like an orthogonal<br>&gt;&gt; concept given the first part here though.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; @Thorsten,<br>&gt;&gt;<br>&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at<br>&gt;&gt; compile time but some are runtime checked, either way the types are checked<br>&gt;&gt; and therefore the type system is sound. I have posted an example of array<br>&gt;&gt; runtime type checking in a previous response.<br>&gt;&gt;<br>&gt;&gt; You can annotate variance, but this generally adds a lot of clutter to<br>&gt;&gt; the code (see some typical Java code that uses generics you will see stuff<br>&gt;&gt; like ? extends Type everywhere). In other languages like Scala the<br>&gt;&gt; annotation is less visually intrusive, because they use shorter syntax and<br>&gt;&gt; because it is annotated at declaration site rather than use site, but it is<br>&gt;&gt; still there.<br>&gt;&gt;<br>&gt;&gt; I think Swift arrays are a good example of partially static and partially<br>&gt;&gt; runtime checked. The content is statically typed but the size is runtime<br>&gt;&gt; typed. Other languages do type both the content and the size (see Dependent<br>&gt;&gt; Typing on Wiki), however at some considerable burden on the programmer.<br>&gt;&gt;<br>&gt;&gt; Hope this explains the thought process,<br>&gt;&gt;<br>&gt;&gt;  -- Howard.<br>&gt;&gt;<br>&gt;&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance,<br>&gt;&gt;&gt; both Java and Scala, allow all three. The problem is that the code becomes<br>&gt;&gt;&gt; splattered with variance annotations<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ceylon uses a different approach which is variance annotations at the<br>&gt;&gt;&gt; definition site.<br>&gt;&gt;&gt; This restricts the possible usage of the type parameters to<br>&gt;&gt;&gt; appropriately variant positions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/ef54c4a7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jan 13, 2016, at 5:05 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; @Robert,<br>&gt; <br>&gt; The behaviour you show for Java arrays is what I am proposing, but that isn&#39;t type unsafe. The type error is detected at runtime and is flagged with an ArrayStoreException. This is unlike C for example that would allow the store, at least with a cast,  and would put into the array the address of the string. Therefore neither the proposal or Java is type unsafe, both are type safe and both detect type errors at runtime.<br></p><p>In case you hadn&#39;t noticed, Swift provides a basic form of covariance for the collections in the standard library... And it does so without the need for runtime checking, because value semantics allow safe mutation and collection covariance.<br></p><p>  - Doug<br></p><p><br>&gt; <br>&gt; The question is whether protecting against this is worthwhile, not whether it can be protected against or not (it can be). Arrays are a good example, Swift takes the approach (like most languages) of checking the array size at runtime. But languages with dependent typing check the array size at compile time, i.e. a dependently typed language would detect this error:<br>&gt; <br>&gt; let array = [1]<br>&gt; array[0] // 1, OK<br>&gt; array[1] // Error not detected by compiler but detected at runtime<br>&gt; <br>&gt; because in such a language array would be typed as int array of size one, not int array of any size.<br>&gt; <br>&gt; So the real question is in a language like Java, how many times do you get ArrayStoreException? In my own code I have never seen an array store exception! Why? Because contravariant writes are very rare. If you were to protect against contravariant writes you would be complicating the language for no practical gain, which I think is a bad trade off.<br>&gt; <br>&gt; Hope this explains the reasoning,<br>&gt; <br>&gt;  -- Howard.<br>&gt; <br>&gt;&gt; On 14 January 2016 at 09:21, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;&gt; It does indeed make the type system unsound in some cases.  You have chosen one particular variance direction because it is convenient. A classic counterexample is Java making Arrays covariant by default.  So this works<br>&gt;&gt; <br>&gt;&gt; Integer[] arr = [2, 4, 6, 8, 10];<br>&gt;&gt; Object[] orr = arr;<br>&gt;&gt; orr[0] = &quot;crash bang&quot;;<br>&gt;&gt; <br>&gt;&gt; And crashes at runtime.  For that, I must give this part of the proposal a strong -1.  Any amount of type safety I have to give up in the name of convenience is far too much.<br>&gt;&gt; <br>&gt;&gt; I am, however, a fan of generic protocols.  They seem like an orthogonal concept given the first part here though.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; @Thorsten,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound. I have posted an example of array runtime type checking in a previous response.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can annotate variance, but this generally adds a lot of clutter to the code (see some typical Java code that uses generics you will see stuff like ? extends Type everywhere). In other languages like Scala the annotation is less visually intrusive, because they use shorter syntax and because it is annotated at declaration site rather than use site, but it is still there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Swift arrays are a good example of partially static and partially runtime checked. The content is statically typed but the size is runtime typed. Other languages do type both the content and the size (see Dependent Typing on Wiki), however at some considerable burden on the programmer. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hope this explains the thought process,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  -- Howard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ceylon uses a different approach which is variance annotations at the definition site.<br>&gt;&gt;&gt;&gt; This restricts the possible usage of the type parameters to appropriately variant positions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/6d205261/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 04:00:00pm</p></header><div class="content"><p>@Douglas,<br></p><p>Sure you can use SequenceType and constrain its associated types in where<br>clauses. But it is hard work :(. When you write your own stuff you end up<br>writing the equivalent of AnySequence and AnyGenerator as well, also hard<br>work.<br></p><p>I am proposing something that reduces programmer burden and strikes a<br>different balance,<br></p><p> -- Howard.<br></p><p>On 14 January 2016 at 15:38, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jan 13, 2016, at 5:05 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; @Robert,<br>&gt;<br>&gt; The behaviour you show for Java arrays is what I am proposing, but that<br>&gt; isn&#39;t type unsafe. The type error is detected at runtime and is flagged<br>&gt; with an ArrayStoreException. This is unlike C for example that would allow<br>&gt; the store, at least with a cast,  and would put into the array the address<br>&gt; of the string. Therefore neither the proposal or Java is type unsafe, both<br>&gt; are type safe and both detect type errors at runtime.<br>&gt;<br>&gt;<br>&gt; In case you hadn&#39;t noticed, Swift provides a basic form of covariance for<br>&gt; the collections in the standard library... And it does so without the need<br>&gt; for runtime checking, because value semantics allow safe mutation and<br>&gt; collection covariance.<br>&gt;<br>&gt;   - Doug<br>&gt;<br>&gt;<br>&gt;<br>&gt; The question is whether protecting against this is worthwhile, not whether<br>&gt; it can be protected against or not (it can be). Arrays are a good example,<br>&gt; Swift takes the approach (like most languages) of checking the array size<br>&gt; at runtime. But languages with dependent typing check the array size at<br>&gt; compile time, i.e. a dependently typed language would detect this error:<br>&gt;<br>&gt; let array = [1]<br>&gt;<br>&gt; array[0] // 1, OK<br>&gt;<br>&gt; array[1] // Error not detected by compiler but detected at runtime<br>&gt;<br>&gt; because in such a language array would be typed as int array of size one,<br>&gt; not int array of any size.<br>&gt;<br>&gt; So the real question is in a language like Java, how many times do you get<br>&gt; ArrayStoreException? In my own code I have never seen an array store<br>&gt; exception! Why? Because contravariant writes are very rare. If you were to<br>&gt; protect against contravariant writes you would be complicating the language<br>&gt; for no practical gain, which I think is a bad trade off.<br>&gt;<br>&gt; Hope this explains the reasoning,<br>&gt;<br>&gt;  -- Howard.<br>&gt;<br>&gt; On 14 January 2016 at 09:21, Developer &lt;devteam.codafi at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; It does indeed make the type system unsound in some cases.  You have<br>&gt;&gt; chosen one particular variance direction because it is convenient. A<br>&gt;&gt; classic counterexample is Java making Arrays covariant by default.  So this<br>&gt;&gt; works<br>&gt;&gt;<br>&gt;&gt; Integer[] arr = [2, 4, 6, 8, 10];<br>&gt;&gt; Object[] orr = arr;<br>&gt;&gt; orr[0] = &quot;crash bang&quot;;<br>&gt;&gt;<br>&gt;&gt; And crashes at runtime.  For that, I must give this part of the proposal<br>&gt;&gt; a strong -1.  Any amount of type safety I have to give up in the name of<br>&gt;&gt; convenience is far too much.<br>&gt;&gt;<br>&gt;&gt; I am, however, a fan of generic protocols.  They seem like an orthogonal<br>&gt;&gt; concept given the first part here though.<br>&gt;&gt;<br>&gt;&gt; ~Robert Widmann<br>&gt;&gt;<br>&gt;&gt; 2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;<br>&gt;&gt; @Thorsten,<br>&gt;&gt;<br>&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at<br>&gt;&gt; compile time but some are runtime checked, either way the types are checked<br>&gt;&gt; and therefore the type system is sound. I have posted an example of array<br>&gt;&gt; runtime type checking in a previous response.<br>&gt;&gt;<br>&gt;&gt; You can annotate variance, but this generally adds a lot of clutter to<br>&gt;&gt; the code (see some typical Java code that uses generics you will see stuff<br>&gt;&gt; like ? extends Type everywhere). In other languages like Scala the<br>&gt;&gt; annotation is less visually intrusive, because they use shorter syntax and<br>&gt;&gt; because it is annotated at declaration site rather than use site, but it is<br>&gt;&gt; still there.<br>&gt;&gt;<br>&gt;&gt; I think Swift arrays are a good example of partially static and partially<br>&gt;&gt; runtime checked. The content is statically typed but the size is runtime<br>&gt;&gt; typed. Other languages do type both the content and the size (see Dependent<br>&gt;&gt; Typing on Wiki), however at some considerable burden on the programmer.<br>&gt;&gt;<br>&gt;&gt; Hope this explains the thought process,<br>&gt;&gt;<br>&gt;&gt;  -- Howard.<br>&gt;&gt;<br>&gt;&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance,<br>&gt;&gt;&gt; both Java and Scala, allow all three. The problem is that the code becomes<br>&gt;&gt;&gt; splattered with variance annotations<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ceylon uses a different approach which is variance annotations at the<br>&gt;&gt;&gt; definition site.<br>&gt;&gt;&gt; This restricts the possible usage of the type parameters to<br>&gt;&gt;&gt; appropriately variant positions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/83acb011/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 13, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 9:07 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; @Douglas,<br>&gt; <br>&gt; Sure you can use SequenceType and constrain its associated types in where clauses. But it is hard work :(. When you write your own stuff you end up writing the equivalent of AnySequence and AnyGenerator as well, also hard work.<br>&gt; <br>&gt; I am proposing something that reduces programmer burden and strikes a different balance,<br></p><p>That’s not what my comment was about :)<br></p><p>You brought up the way Java handles subtyping of arrays:<br></p><p>	There is a strong positive precedence for a type check on write, Java arrays (not Java `List`s). Arrays in Java may be passed covariantly, and this is extensively used. However if you attempt to write the wrong type into the array you will get an `ArrayStoreException`. In practice you don&#39;t get many `ArrayStoreException`, non of my code has ever had one. Its just not something you do in practice, as noted before contravariance is rare.<br></p><p>I’ve always considered that behavior to be a flaw in Java’s design, and the kind of thing that one typically relies on in a language that lacks generics. I’m not totally alone in this—the third hit Google returns when I search for “java type hole” is<br></p><p>	http://c2.com/cgi/wiki?JavaArraysBreakTypeSafety<br></p><p>Also, I don’t know to what extent your claim that subtyping of arrays is used extensively in Java is true. If you have data, I would *love* to see it.<br></p><p>Back to my actual point, Swift implements subtyping of arrays without introducing dynamic checks. Consider this code:<br></p><p>	class Base { }<br>	class Derived : Base { }<br></p><p>	var arrayOfDerived: [Derived] = [Derived(), Derived(), Derived()]<br>	var arrayOfBase: [Base] = arrayOfDerived<br>	arrayOfBase[0] = Base()<br></p><p>It compiles, it runs, and it doesn’t break because arrays have value semantics in Swift. The corresponding reference-semantic arrays (as in Java) require dynamic checking because the underlying array of Derived’s is being shared, so the assignment would fail with an ArrayStoreException. That’s not the case in Swift, because there’s no (logical) sharing between the array of Derived values and the array of Base values. For me, realizing that value semantics made subtyping of collections just work was a minor epiphany.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;  -- Howard.<br>&gt; <br>&gt; On 14 January 2016 at 15:38, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jan 13, 2016, at 5:05 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; @Robert,<br>&gt;&gt; <br>&gt;&gt; The behaviour you show for Java arrays is what I am proposing, but that isn&#39;t type unsafe. The type error is detected at runtime and is flagged with an ArrayStoreException. This is unlike C for example that would allow the store, at least with a cast,  and would put into the array the address of the string. Therefore neither the proposal or Java is type unsafe, both are type safe and both detect type errors at runtime.<br>&gt; <br>&gt; In case you hadn&#39;t noticed, Swift provides a basic form of covariance for the collections in the standard library... And it does so without the need for runtime checking, because value semantics allow safe mutation and collection covariance.<br>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The question is whether protecting against this is worthwhile, not whether it can be protected against or not (it can be). Arrays are a good example, Swift takes the approach (like most languages) of checking the array size at runtime. But languages with dependent typing check the array size at compile time, i.e. a dependently typed language would detect this error:<br>&gt;&gt; <br>&gt;&gt; let array = [1]<br>&gt;&gt; array[0] // 1, OK<br>&gt;&gt; array[1] // Error not detected by compiler but detected at runtime<br>&gt;&gt; <br>&gt;&gt; because in such a language array would be typed as int array of size one, not int array of any size.<br>&gt;&gt; <br>&gt;&gt; So the real question is in a language like Java, how many times do you get ArrayStoreException? In my own code I have never seen an array store exception! Why? Because contravariant writes are very rare. If you were to protect against contravariant writes you would be complicating the language for no practical gain, which I think is a bad trade off.<br>&gt;&gt; <br>&gt;&gt; Hope this explains the reasoning,<br>&gt;&gt; <br>&gt;&gt;  -- Howard.<br>&gt;&gt; <br>&gt;&gt; On 14 January 2016 at 09:21, Developer &lt;devteam.codafi at gmail.com &lt;mailto:devteam.codafi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; It does indeed make the type system unsound in some cases.  You have chosen one particular variance direction because it is convenient. A classic counterexample is Java making Arrays covariant by default.  So this works<br>&gt;&gt; <br>&gt;&gt; Integer[] arr = [2, 4, 6, 8, 10];<br>&gt;&gt; Object[] orr = arr;<br>&gt;&gt; orr[0] = &quot;crash bang&quot;;<br>&gt;&gt; <br>&gt;&gt; And crashes at runtime.  For that, I must give this part of the proposal a strong -1.  Any amount of type safety I have to give up in the name of convenience is far too much.<br>&gt;&gt; <br>&gt;&gt; I am, however, a fan of generic protocols.  They seem like an orthogonal concept given the first part here though.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/01/13 17:03、Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; @Thorsten,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound. I have posted an example of array runtime type checking in a previous response.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can annotate variance, but this generally adds a lot of clutter to the code (see some typical Java code that uses generics you will see stuff like ? extends Type everywhere). In other languages like Scala the annotation is less visually intrusive, because they use shorter syntax and because it is annotated at declaration site rather than use site, but it is still there.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think Swift arrays are a good example of partially static and partially runtime checked. The content is statically typed but the size is runtime typed. Other languages do type both the content and the size (see Dependent Typing on Wiki), however at some considerable burden on the programmer. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hope this explains the thought process,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  -- Howard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 13 January 2016 at 16:50, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Strong -1 from me as well for making the type system unsound.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Am 13.01.2016 um 02:47 schrieb Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Yes you can annotate for covariance, invariance, and contravariance, both Java and Scala, allow all three. The problem is that the code becomes splattered with variance annotations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ceylon uses a different approach which is variance annotations at the definition site.<br>&gt;&gt;&gt; This restricts the possible usage of the type parameters to appropriately variant positions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This migt be a better way to deal with variance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt;   -- Howard.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/c14273e1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 14, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound.<br></p><p>Runtime type checking is not an adequate replacement for compile-time type checking. Runtime type checking ensures your code does not continue to run if it encounters a type error; compile-time type checking ensures your code is *incapable of encountering* a type error. This is a bit like saying that it&#39;s okay to drive drunk because seatbelts and airbags will mitigate the injuries caused if you crash.<br></p><p>Swift has a lovely property where, if your code is typed strongly enough and compiles without errors, it&#39;s probably pretty close to working. I would hate to see that watered down.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January 14, 2016 at 09:00:00am</p></header><div class="content"><p>Hello Brent,<br></p><p>To be fair this is not the first nor the last time people wonder if static typing gives an overvalued sense of security while making prototyping and gluing different part of the app together more difficult (https://channel9.msdn.com/Blogs/Charles/JAOO-2007-Bob-Martin-and-Chad-Fowler-Debating-Static-versus-Dynamic-Typing), if the language/compiler should protect you from yourself and if so just how much. Also, still in the interest of fairness, type safety is one of the many things you need when trying to deterministically ensure program safety (Midori post mortem):  http://joeduffyblog.com/2015/11/03/a-tale-of-three-safeties/<br></p><p>Still, the ship with Swift has clearly sailed towards static typing with Swift, I think we should work on the other two categories of safety. Waiting next year to deal with concurrency makes sense as we do not want to rush things, but it probably w much hotter topic than static typing in a lot of fields today and if you compare what C++ has available from developers (see Intel Threading Building Blocks for example) shows that there is plenty of exciting stuff ahead :).<br></p><p>Sent from my iPhone<br></p><p>On 14 Jan 2016, at 08:39, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound.<br>&gt; <br>&gt; Runtime type checking is not an adequate replacement for compile-time type checking. Runtime type checking ensures your code does not continue to run if it encounters a type error; compile-time type checking ensures your code is *incapable of encountering* a type error. This is a bit like saying that it&#39;s okay to drive drunk because seatbelts and airbags will mitigate the injuries caused if you crash.<br>&gt; <br>&gt; Swift has a lovely property where, if your code is typed strongly enough and compiles without errors, it&#39;s probably pretty close to working. I would hate to see that watered down.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/8526179b/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 14, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jan 14, 2016, at 2:39 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound.<br>&gt; <br>&gt; Runtime type checking is not an adequate replacement for compile-time type checking. Runtime type checking ensures your code does not continue to run if it encounters a type error; compile-time type checking ensures your code is *incapable of encountering* a type error. This is a bit like saying that it&#39;s okay to drive drunk because seatbelts and airbags will mitigate the injuries caused if you crash.<br>&gt; <br>&gt; Swift has a lovely property where, if your code is typed strongly enough and compiles without errors, it&#39;s probably pretty close to working. I would hate to see that watered down.<br></p><p>+1.  Swift&#39;s type system is very well thought out.  It is going to get even better with the generics enhancements in Swift 3, removing many of the current limitations.  We are heading down the right path.  Changing course and introducing runtime checks where static checks are possible is a bad idea.<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 14.01.2016 um 14:57 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Jan 14, 2016, at 2:39 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; It doesn&#39;t make the type system unsound; the types are mostly checked at compile time but some are runtime checked, either way the types are checked and therefore the type system is sound.<br>&gt;&gt; <br>&gt;&gt; Runtime type checking is not an adequate replacement for compile-time type checking. Runtime type checking ensures your code does not continue to run if it encounters a type error; compile-time type checking ensures your code is *incapable of encountering* a type error. This is a bit like saying that it&#39;s okay to drive drunk because seatbelts and airbags will mitigate the injuries caused if you crash.<br>&gt;&gt; <br>&gt;&gt; Swift has a lovely property where, if your code is typed strongly enough and compiles without errors, it&#39;s probably pretty close to working. I would hate to see that watered down.<br>&gt; <br>&gt; +1.  Swift&#39;s type system is very well thought out.  It is going to get even better with the generics enhancements in Swift 3, removing many of the current limitations.  We are heading down the right path.  Changing course and introducing runtime checks where static checks are possible is a bad idea.<br></p><p>Big +1 from me!<br></p><p>-Thorsten<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 12, 2016 at 06:00:00pm</p></header><div class="content"><p>What if the “casted” value was treated as an implicitly-defined computed property? Something like this, maybe?<br>struct Box&lt;T: AnyObject&gt; {<br>    var value: T<br>    init(_ initialValue: T) {<br>        value = initialValue;<br>    }<br>} as T {<br>    get { return self.value }<br>    set { self.value = newValue }<br>}<br></p><p>The behavior is opt-in, simple, concise, and would allow for non-trivial cases if you were doing it for more than one type:<br>struct DoubleBox&lt;T: AnyObject, U: AnyObject&gt; {<br>    var t: T<br>    var u: U<br>    init(_ t: T, _: u: U) {<br>        self.t = t<br>        self.u = u<br>    }<br>} as T {<br>    get { return self.t }<br>    set { self.t = newValue }<br>} as U { return self.u } // is read-only when accessed as a U<br>- Dave<br></p><p>PS: Actually, in this case, since your boxed type has to be a class anyway (T: AnyObject vs T) you can *almost* do this now, if you’re willing to write some boilerplate and kind of abuse the Objective-C Bridging system:<br>extension Box: _ObjectiveCBridgeable {<br>    typealias _ObjectiveCType = T // the protocol says _ObjectiveCType: AnyObject, so any class will do<br>    <br>    static func _isBridgedToObjectiveC() -&gt; Bool { return true }<br>    static func _getObjectiveCType() -&gt; Any.Type { return _ObjectiveCType.self }<br>    static func _forceBridgeFromObjectiveC(source: _ObjectiveCType, inout result: Box?) { result = Box(source) }<br>    static func _conditionallyBridgeFromObjectiveC(source: _ObjectiveCType, inout result: Box?) -&gt; Bool {<br>        _forceBridgeFromObjectiveC(source, result: &amp;result)<br>        return result != nil<br>    }<br>    func _bridgeToObjectiveC() -&gt; _ObjectiveCType { return self.value }<br>}<br>Then this works now in the current version of Xcode:<br>let box = Box(Bottom())<br>let bottom = box as Bottom<br></p><p>Although, I’m not sure how long it will keep working, since _ObjectiveCBridgeable should probably constrain _ObjectiveCType to NSObject rather than AnyObject. Also, going the other way — converting from Bottom to Box&lt;Bottom&gt; — using this technique gives an error. It works with the non-generic types I was playing around with earlier, though… Maybe it’s something to do with compiler assumptions and differences between Swift’s and Objective-C’s generics system, or maybe I’m getting the function signatures close enough to satisfy the protocol requirements but somehow subtly wrong (which wouldn’t surprise me at all… sometimes I have trouble getting the details right when I’m dealing with generics in protocols).<br></p><p>&gt; On Jan 12, 2016, at 16:33, Simon Pilkington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The problem is that conceptually and behaviourally Box&lt;Bottom&gt; *is indeed not* a Box&lt;Top&gt; and cannot be treated the same as one. The proposal attempts to get around this difference with a runtime failure but this would result in very fragile code - you get passed a Box&lt;Top&gt; and want to pass it a subclass of Top, will it succeed, who knows. You probably would be able to check the types but the complier wouldn’t highlight that this is an operation that could potentially fail.<br>&gt; <br>&gt; This seems to be very much against Swift’s goal of safety being enforced by the compiler as much as possible.<br>&gt; <br>&gt; Java uses the wildcard syntax to highlight this conceptual and behavioural difference - Box&lt;Bottom&gt; is not covariant with Box&lt;Top&gt; but rather with Box&lt;? extends Top&gt;. The compiler can then enforce that a programmer doesn’t try to pass an incompatible type to a variable of such type. Even though this is a complication to the language (many Java programmers struggle with correctly using the wildcard syntax) I don’t see covariance for generics being added to Swift in a robust manner without some kind of similar syntax.<br>&gt; <br>&gt; -Simon<br>&gt; <br>&gt;&gt; On 12 Jan 2016, at 8:45 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br>&gt;&gt; <br>&gt;&gt; 1st a demonstration of the current situation of invariant generics:<br>&gt;&gt; <br>&gt;&gt;     // Current system<br>&gt;&gt;     class Top {}<br>&gt;&gt;     class Bottom: Top {}<br>&gt;&gt; <br>&gt;&gt;     struct Box&lt;T: AnyObject&gt; {<br>&gt;&gt;         var value: T<br>&gt;&gt;         init(_ initialValue: T) {<br>&gt;&gt;             value = initialValue;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     let boxB = Box(Bottom())<br>&gt;&gt;     // let boxT: Box&lt;Top&gt; = boxB // Covariance currently not allowed<br>&gt;&gt; <br>&gt;&gt; The key point is although `Bottom` &#39;is a’ `Top`, `Box&lt;Bottom&gt;` *is not* a `Box&lt;Top&gt;`.<br>&gt;&gt; <br>&gt;&gt; I am suggesting:<br>&gt;&gt; <br>&gt;&gt; 1. That `Box&lt;Bottom&gt;` should be a `Box&lt;Top&gt;` (covariance).<br>&gt;&gt; 2. An implementation that allows the above covariance.<br>&gt;&gt; 3. That protocols are made generic, i.e. `protocol Box&lt;T&gt; { var value: T { get set } }` and that this mechanism replaces associated types for protocols.<br>&gt;&gt; <br>&gt;&gt;     // Proposal:<br>&gt;&gt;     // 1. No change to Box, i.e. programmer would just write Box as before<br>&gt;&gt;     // 2. Code transformed by comiler with write check for each specific, generic type instance<br>&gt;&gt;     // Best approximation of resulting code in current Swift to demonstrate spirit of idea:<br>&gt;&gt; <br>&gt;&gt;     // Compiler writes a universal form using the upper bound (it writes the underlyting representation).<br>&gt;&gt;     // In practice this would be called `Box` but used `BoxAnyObject` to indicate that it has a generic argument bounded by `AnyObject`.<br>&gt;&gt;     struct BoxAnyObject {<br>&gt;&gt;         // Generated from generic argument `&lt;T: AnyObject&gt;`.<br>&gt;&gt;         let T: AnyObject.Type // Store the actual type.<br>&gt;&gt;         <br>&gt;&gt;         // Generated from stored property `var value: T` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         private var _value: AnyObject // Access the stored property through a setter so that type can be checked<br>&gt;&gt;         var value: AnyObject {<br>&gt;&gt;             get {<br>&gt;&gt;                 return _value<br>&gt;&gt;             }<br>&gt;&gt;             set {<br>&gt;&gt;                 // In all functions check that args declared as `T` are actually a `T` or a sub-type.<br>&gt;&gt;                 // Note: `is` only works with type literal and there is no `&gt;=` operator for types :(.<br>&gt;&gt;                 // `is` would need changing or `&gt;=` for types adding, nearest at moment `==`.<br>&gt;&gt;                 precondition(T == /* &gt;= */ newValue.dynamicType, &quot;Type of newValue, \(newValue.dynamicType), is not a sub-type of generic type T, \(T)&quot;)<br>&gt;&gt;                 _value = newValue<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;         <br>&gt;&gt;         // Generated from `init(_ initialValue: T)` and noting that `T`&#39;s upper bound is `AnyObject`.<br>&gt;&gt;         init(_ lowestCommonDeclaredT: AnyObject.Type, _ initialValue: AnyObject) {<br>&gt;&gt;             T = lowestCommonDeclaredT<br>&gt;&gt;             _value = initialValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate that all `Box`es are the same size and therefore can be bitwise copied<br>&gt;&gt;     // Compiler supplies lowest-common, declared, generic type for all the `T`s in the `init` call.<br>&gt;&gt;     var bT = BoxAnyObject(Top.self, Top()) // In practice user would write `let bT = Box(Top())`.<br>&gt;&gt;     bT.T // Top.Type<br>&gt;&gt;     sizeofValue(bT) // 16<br>&gt;&gt; <br>&gt;&gt;     var bB = BoxAnyObject(Bottom.self, Bottom()) // In practice user would write `let bB = Box(Bottom())`.<br>&gt;&gt;     bB.T // Bottom.Type<br>&gt;&gt;     sizeofValue(bB) // 16<br>&gt;&gt; <br>&gt;&gt;     // Demonstration covariance.<br>&gt;&gt;     bT = bB // Compiler would check covariance of declared generic types.<br>&gt;&gt;     bT.T // Bottom.Type<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate generic returned type<br>&gt;&gt;     // Compiler would add cast to declared, generic type.<br>&gt;&gt;     bB.value as! Bottom // In practice user would write `bB.value`.<br>&gt;&gt; <br>&gt;&gt;     // Demonstrate type safety<br>&gt;&gt;     bT = BoxAnyObject(Top.self, Top()) // In practice user would write `bT = Box(Top())`.<br>&gt;&gt;     bT.value = Top() // OK<br>&gt;&gt;     // bT.value = Bottom() // Doesn&#39;t work at present because need `&gt;=` for types, but would work in practice<br>&gt;&gt;     // bB.value = Top() // Runtime error - wrong type<br>&gt;&gt; <br>&gt;&gt; The implications of this proposal are:<br>&gt;&gt; <br>&gt;&gt; 1. The compiler can statically type check a read from a stored property.<br>&gt;&gt; 2. A write to a stored property is type checked at runtime.<br>&gt;&gt; 3. Protocols can be made generic instead of having an associated type and then they become a proper type with dynamic dispatch.<br>&gt;&gt; 4. Generic protocols can be a type just like non-generic protocols, structs, and classes and unlike associated type protocols that can only be a generic constraint.<br>&gt;&gt; 5. The awkwardness of dealing with associated type generics is replaced by a more powerful and easier to understand semantic of a type, just like the other types.<br>&gt;&gt; 6. There is a lot of ‘non-obvoius’, long code, for example `inits`, that use a `where` clause to constrain an associated type protocol, this would be unnecessary.<br>&gt;&gt; 7. There are whole types, `AnySequence`, `AnyGenerator`, etc., that would be replaced by a generic protocols, `Sequence`, `Generator`, etc.<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; <br>&gt;&gt; 1. Covariant generics are a powerful addition to the language.<br>&gt;&gt; 2. Generics’ invariance are inconsistent with the rest of the language.<br>&gt;&gt; 3. Generic protocols would become a ‘proper’ type and you could have arrays and fields of a generic protocol.<br>&gt;&gt; 4. There are many threads on swift-evolution looking at how protocols can be made into a ‘proper’ type or at least a concept that is easier to understand.<br>&gt;&gt; <br>&gt;&gt; Compatibility:<br>&gt;&gt; <br>&gt;&gt; 1. This would be a major change since associated types in protocols would be replaced by generics.<br>&gt;&gt; 2. The new implementation of generics might break some existing `struct` and `class` code, for example if it is dependent on the exact size of an object because the class will have extra fields, one for each generic type, and therefore will be larger.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; <br>&gt;&gt; 1. Major change.<br>&gt;&gt; 2. Object size increases.<br>&gt;&gt; <br>&gt;&gt; Thanks in advance for any comments,<br>&gt;&gt; <br>&gt;&gt;   — Howard.<br>&gt;&gt; <br>&gt;&gt; PS This is part of a collection of proposals previously presented as “Protocols on Steroids”.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/90831461/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>January 13, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 12 Jan 2016, at 10:45, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently you generics are invariant whereas function arguments etc. are covariant. I am suggesting that if the way generics are implemented is changed then they can be made covariant and that this will add considerable utility to Swift generics.<br></p><p>What about contravariant scenarios? Examples from C#:<br></p><p>IEnumerable&lt;out T&gt; // covariant<br>since if S : T then we want IEnumerable&lt;S&gt; : IEnumerable&lt;T&gt;<br></p><p>because IEnumerable&lt;T&gt; only returns T’s.<br></p><p>but then<br></p><p>IComparable&lt;in T&gt; // contravariant<br>since if S : T we definitely want IComparable&lt;T&gt; : IComparable&lt;S&gt;<br></p><p>because IComparable&lt;T&gt; only takes T’s as input.<br></p><p>reversing either of the above would make the type system unsound.<br>Any variance be default can’t be sound, and I am strongly opposed to that.<br></p><p>-Sune<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/45941320/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>@Sune,<br></p><p>Yes you can annotate in a C#/Scala fashion. But you have burdened the<br>programmer and haven&#39;t added much. In almost all cases you want covariant<br>and I am proposing that that requirement is so pervasive that we can just<br>ignore the rest. At present in Swift you only have invariant and that is<br>usable, if inconvenient at times.<br></p><p>Lets take your example of IComparable&lt;in T&gt; from C#. On the web page for<br>this, https://msdn.microsoft.com/en-us/library/4d7sx9hd(v=vs.110).aspx,<br>there is an example of temperature comparisons. Their own example is<br>invariant, because almost all comparisons will be invariant.<br></p><p>Furthermore Microsoft chose to make Equatable&lt;T&gt; invariant. A strange<br>choice heh. How come comparing using IComparable behaves differently than<br>using Equatable? If you implement both, which Microsoft recommends, then<br>you get invariance, because Equatable is invariant.<br></p><p>In Swift there is a strong emphasis on final classes and structs (that are<br>final). Therefore you can&#39;t use contravariance with these final types.<br>Therefore virtually everything is covered by covariance and I am proposing<br>that this should be the default. If it is found latter that there are uses<br>for invariant and contra variant then annotations for these could be added,<br>however I am suggesting that since covariant is overwhelmingly the most<br>useful then it should be the default.<br></p><p>Hope this explains my reasoning,<br></p><p> -- Howard.<br></p><p>On 14 January 2016 at 07:10, Sune Foldager &lt;cyano at me.com&gt; wrote:<br></p><p>&gt;<br>&gt; On 12 Jan 2016, at 10:45, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Currently you generics are invariant whereas function arguments etc. are<br>&gt; covariant. I am suggesting that if the way generics are implemented is<br>&gt; changed then they can be made covariant and that this will add considerable<br>&gt; utility to Swift generics.<br>&gt;<br>&gt;<br>&gt; What about contravariant scenarios? Examples from C#:<br>&gt;<br>&gt; IEnumerable&lt;out T&gt; // covariant<br>&gt; since if S : T then we want IEnumerable&lt;S&gt; : IEnumerable&lt;T&gt;<br>&gt;<br>&gt; because IEnumerable&lt;T&gt; only returns T’s.<br>&gt;<br>&gt; but then<br>&gt;<br>&gt; IComparable&lt;in T&gt; // contravariant<br>&gt; since if S : T we definitely want IComparable&lt;T&gt; : IComparable&lt;S&gt;<br>&gt;<br>&gt; because IComparable&lt;T&gt; only takes T’s as input.<br>&gt;<br>&gt; reversing either of the above would make the type system unsound.<br>&gt; Any variance be default can’t be sound, and I am strongly opposed to that.<br>&gt;<br>&gt; -Sune<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/ff4c0f1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1696913cf1335685a75e63e11b459ae3?s=50"></div><header><strong>Make generics covariant and add generics to protocols</strong> from <string>Sune Foldager</string> &lt;cyano at me.com&gt;<p>January 18, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 14 Jan 2016, at 00:02, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Furthermore Microsoft chose to make Equatable&lt;T&gt; invariant. A strange choice heh. How come comparing using IComparable behaves differently than using Equatable? If you implement both, which Microsoft recommends, then you get invariance, because Equatable is invariant.<br></p><p>Actually, only the equality comparison part will be invariant. Generally, the APIs which call the IComparable and IEquatable methods are disjunct, so it’s not a problem in practice at all (comparable is almost only for sorting, equatable for putting in dictionaries and many other things). The reasoning for making Equatable invariant is explained on MSDN, but it has to do with what being equals means. It’s always a choice, of course.<br></p><p>At any rate, contravariance is definitely sometimes useful, and, I’d argue, just as often as covariance. Most of the time you don’t need either.<br></p><p>I personally regret that C# arrays are covariant (and so do the designers of C#), because it means more errors at runtime, maybe when the code is in production.<br></p><p>-Sune<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/a1da0043/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
