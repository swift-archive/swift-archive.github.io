<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>access control proposal</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 10, 2015 at 12:00:00pm</p></header><div class="content"><p>The discussion so far seems to be between folks who think the existing model is obviously complete vs folks who think that it obviously isn’t, but there isn’t a lot of talk about the specific motivation for the feature.<br></p><p> I know a new access control modifier *looks like* a bell/whistle, but I believe *in practice* it is a *safety* feature, on the level of type safety or array-out-of-bounds.  This result is counterintuitive.<br>   I’d like to present my motivation, which I think is pretty compelling.  In several codebases, I have<br>&gt; final private class Foo { //this class is an implementation detail of Bar and is declared ‘private&#39;<br>&gt;    private var _children : [Next] = [] //access only from special queue, as required by $EXTERNAL_REQUIREMENT<br>&gt;    let queue: dispatch_queue_t = dispatch_queue_create(“specialQueue&quot;, DISPATCH_QUEUE_SERIAL)<br>&gt;       func appendChild(n: Next) {<br>&gt;            dispatch_sync(queue) { _children.append(n) }<br>&gt;       }<br>&gt; }<br>&gt; <br>&gt; final class Bar {<br>&gt;    let f = Foo()<br>&gt;    init() {<br>&gt; 	f.appendChild(…)<br>&gt;        f._children[0].baz() //whoops: race condition<br>&gt;    }<br>&gt; }<br>   In words, the problem here is that:<br>   1.  Foo is an implementation detail of Bar, and so Foo should be private<br></p><p>- Ignored:<br>   2.  Foo has its own implementation detail, _children<br>   3.  Because Foo is already private, _children cannot be “more” private<br>   4.  Thus _children must be visible at the file level<br>   5.  Since it is visible at the file level, it may be used<br>   6.  If it is used, it will most likely cause a race condition<br>   7.  Race conditions are very hard to debug and I need all the help I can get not to write them in the first place<br></p><p>   The solutions I see for this problem are as follows:<br></p><p>   1.  This thread’s proposal (e.g., to invent a new access modifier, restricting _children to visibility below the file level)<br>   2.  Vend a framework / module just for these two classes.  I present this as silly for many realistic sizes of Foo and Bar.<br>   3.  Promote Foo to internal visibility, when it is really a private implementation detail<br>   4.  What I actually do in this codelisting, which is to use underscores as a naming convention, and pray nobody on the team screws it up, because the compiler is no help.<br></p><p>   I would like to hear from the folks who don’t see the need of another access modifier, what solution to this problem they plan to maintain in their own projects.  Because this design pattern (queue-controlled ivar) is not uncommon, and the lack of a fourth access control keyword has produced real race conditions that I have spent real time debugging, that is completely avoidable via a keyword like classified/local/secret.<br></p><p>   Drew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>access control proposal</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 12, 2015 at 05:00:00am</p></header><div class="content"><p>&gt;   I would like to hear from the folks who don’t see the need of another access modifier, what solution to this problem they plan to maintain in their own projects.  Because this design pattern (queue-controlled ivar) is not uncommon, and the lack of a fourth access control keyword has produced real race conditions that I have spent real time debugging, that is completely avoidable via a keyword like classified/local/secret.<br></p><p>My solution is to be careful when I’m writing code.<br></p><p>I mean, look, you’re right. In your case, three access modifiers isn’t enough to prevent this mistake; you need four. But, given four, you could provide an example that needs five. Given five, you could come up with one for six. Given N access modifiers, you can write a case where you need N + 1.<br></p><p>There will never be enough. At some point, you just have to draw the line and say “this is enough; beyond here, you’re just going to have to take responsibility for your code.” Swift draws the line at a single file, a cohesive unit of code that’s all visible at once (at least with scrolling), but which still can contain things with no direct relationship. Small enough that you ought to be able to keep the outline of it in your head, but large enough that there’s still plenty of flexibility.<br></p><p>This is absolutely a judgement call that reasonable people can disagree on. But personally, my judgement is that `private` is private enough.<br></p><p>ADDENDUM:<br></p><p>Actually, for this case, there *is* a way to achieve better safety without additional access modifiers. Create a new file and call it Synchronized.swift:<br></p><p>	// This could be a struct, but that leads to some odd copying semantics.<br>	final class Synchronized&lt;Value&gt; {<br>		private var value: Value<br>		private let queue = dispatch_queue_create(“specialQueue&quot;, DISPATCH_QUEUE_SERIAL)<br>		<br>		init(value: Value) {<br>			self.value = value<br>		}<br>		<br>		mutating func withValue&lt;R&gt;(closure: (inout value: T) -&gt; R) -&gt; R {<br>			var returnValue: R?<br>			dispatch_sync(queue) {<br>				returnValue = closure(value)<br>			}<br>			return returnValue!<br>		}<br>	}<br></p><p>Now in your original file, you write:<br></p><p>	final private class Foo { //this class is an implementation detail of Bar and is declared ‘private&#39;<br>	  private var _children = Synchronized(value: [] as [Next]) //access only from special queue, as required by $EXTERNAL_REQUIREMENT<br>	     func appendChild(n: Next) {<br>	          _children.withValue { (inout children: [Next]) in<br>			children.append(n)<br>		}<br>	     }<br>	}<br>	<br>	final class Bar {<br>	  let f = Foo()<br>	  init() {<br>	      f.appendChild(…)<br>	      f._children[0].baz() // error—_children can’t do this directly, you need to call .withValue()<br>	      f._children.value[0].baz() // error—value is private and inaccessible from here<br>	  }<br>	}<br></p><p>Synchronized can, of course, be modified to support all sorts of other cases: shared queues, parallel read-only access, etc. The general concept of using *another* file’s `private` modifier to protect *this* file’s data can be used in many cases, and I think it’s a pretty good solution to problems like these.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>access control proposal</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 12, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; I mean, look, you’re right. In your case, three access modifiers isn’t enough to prevent this mistake; you need four. But,<br>&gt; given four, you could provide an example that needs five. Given five, you could come up with one for six. Given N access modifiers, you can write a case where you need N + 1.<br></p><p>Nope.  What we&#39;re talking about (what I&#39;m talking about, anyway) is a syntactically scoped access modifier.  There is no N+1 case.  There is no &quot;even more scoped&quot;.  There is no inductive case.<br></p><p>I mean, it is possible to write a troll proposal for an access modifier visible to the 3 lines before and after the declaration, or something.  That much I grant.  But troll proposals aside, a scoped access modifier is the quark of the access modifiers; there is no sensible way to go halvsies.<br></p><p>&gt; Actually, for this case, there *is* a way to achieve better safety without additional access modifiers. Create a new file and call it Synchronized.swift:<br></p><p>This is the solution that I ship.  I think if we don&#39;t add a new visibility modifier, we should definitely do this in the standard library, because &quot;resource synchronization&quot; is a problem most modern programs have.<br></p><p>This particular implementation is insufficiently general, however--there are more ways to synchronize a resource than on a GCD dispatch queue.  I do agree that a general solution can be constructed out of this example, and reasonable people can disagree about whether adding local or adding a more-general Synchronized is a better solution to this problem.<br></p><p>&gt; My solution is to be careful when I’m writing code.<br></p><p>It is actually *this* statement which is weak to an induction attack.  We can *always* be more careful writing code.  Why do we need typechecking, why do we need integer overflow trapping, why do we need array out of bounds exceptions?  The C developer says they do not need half of Swift because their solution is to be more careful writing code.  The C developer is naive.<br></p><p>But in *this* language, we adopt zero and low-cost abstractions in the name of safety.  A scoped access modifier is a zero-cost abstraction that makes the language safer.  We should adopt it.  If for no other reason, than consistency with the other aspects of the language design.  Either that or we should move integer overflow checks into the standard library for consistency with Synchronized, which I present as a troll proposal.<br></p><p>I mean, I don&#39;t know about you, but I get called in to look at projects regularly that have a MainViewController.swift that weighs 10KLOC.  I didn&#39;t write it.  I didn&#39;t make the mess.  I just want tools to help me clean it up.  &#39;private&#39; is useless in that context, and it&#39;s a (sadly) typical context in iOS.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; I mean, I don&#39;t know about you, but I get called in to look at projects regularly that have a MainViewController.swift that weighs 10KLOC.  I didn&#39;t write it.  I didn&#39;t make the mess.  I just want tools to help me clean it up.  &#39;private&#39; is useless in that context, and it&#39;s a (sadly) typical context in iOS.<br></p><p>+1.  Messes like this are all too common in the real world.  <br></p><p>Even worse, they often involve poorly thought out uses of uses of inheritance.  We need tools to help clean them up and also a language designed to make it more difficult to unintentionally create them in the first place.  This is a very non-trivial part of the argument for making final the default IMO.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 13, 2015 at 12:00:00am</p></header><div class="content"><p>+1 on both comments.<br></p><p>--<br>Ilya Belenkiy<br>On Sat, Dec 12, 2015 at 6:20 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; I mean, I don&#39;t know about you, but I get called in to look at projects<br>&gt; regularly that have a MainViewController.swift that weighs 10KLOC.  I<br>&gt; didn&#39;t write it.  I didn&#39;t make the mess.  I just want tools to help me<br>&gt; clean it up.  &#39;private&#39; is useless in that context, and it&#39;s a (sadly)<br>&gt; typical context in iOS.<br>&gt;<br>&gt; +1.  Messes like this are all too common in the real world.<br>&gt;<br>&gt; Even worse, they often involve poorly thought out uses of uses of<br>&gt; inheritance.  We need tools to help clean them up and also a language<br>&gt; designed to make it more difficult to unintentionally create them in the<br>&gt; first place.  This is a very non-trivial part of the argument for making<br>&gt; final the default IMO.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/c770475c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>access control proposal</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 13, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt;&gt; I mean, look, you’re right. In your case, three access modifiers isn’t enough to prevent this mistake; you need four. But,<br>&gt;&gt; given four, you could provide an example that needs five. Given five, you could come up with one for six. Given N access modifiers, you can write a case where you need N + 1.<br>&gt; <br>&gt; Nope.  What we&#39;re talking about (what I&#39;m talking about, anyway) is a syntactically scoped access modifier.  There is no N+1 case.  There is no &quot;even more scoped&quot;.  There is no inductive case.<br>&gt; <br>&gt; I mean, it is possible to write a troll proposal for an access modifier visible to the 3 lines before and after the declaration, or something.  That much I grant.  But troll proposals aside, a scoped access modifier is the quark of the access modifiers; there is no sensible way to go halvsies.<br></p><p>I actually immediately thought of several things you might want:<br></p><p>• You have two logical “groups” of properties and methods in a type, and you want to only permit access within a group. But both groups have stored properties, so they must be defined in the scope of the main type definition.<br>• You have types nested within your type. You want methods in your own type to have access, but not methods in those nested types.<br>• Alternatively, you have types nested within your type. You want the outer type to have access to things in the nested type, but not any other type.<br></p><p>I don’t think these are troll proposals. They *are* a little more limited, a little more esoteric, but you could say the same thing about `local` vs. `private`. And in some cases you can emulate some of these with the four access modifiers you want, but again, you could say the same thing about `local` vs. `private`.<br></p><p>&gt;&gt; Actually, for this case, there *is* a way to achieve better safety without additional access modifiers. Create a new file and call it Synchronized.swift:<br>&gt; <br>&gt; This is the solution that I ship.  I think if we don&#39;t add a new visibility modifier, we should definitely do this in the standard library, because &quot;resource synchronization&quot; is a problem most modern programs have.<br></p><p>This is not a bad idea. The only potential issue I can see with it is that, if it’s made too general, it might be difficult to construct a Synchronized instance correctly.<br></p><p>&gt;&gt; My solution is to be careful when I’m writing code.<br>&gt; <br>&gt; It is actually *this* statement which is weak to an induction attack.  We can *always* be more careful writing code.  Why do we need typechecking, why do we need integer overflow trapping, why do we need array out of bounds exceptions?  The C developer says they do not need half of Swift because their solution is to be more careful writing code.  The C developer is naive.<br>&gt; <br>&gt; But in *this* language, we adopt zero and low-cost abstractions in the name of safety.  A scoped access modifier is a zero-cost abstraction that makes the language safer.  We should adopt it.  If for no other reason, than consistency with the other aspects of the language design.  Either that or we should move integer overflow checks into the standard library for consistency with Synchronized, which I present as a troll proposal.<br></p><p>But it’s not zero-cost. It’s another thing to learn, another thing to think about, another way you have to mentally analyze your code. It has to be balanced against the goal of keeping the language small and simple. And many people, when they do that, find this idea wanting.<br></p><p>&gt; I mean, I don&#39;t know about you, but I get called in to look at projects regularly that have a MainViewController.swift that weighs 10KLOC.  I didn&#39;t write it.  I didn&#39;t make the mess.  I just want tools to help me clean it up.  &#39;private&#39; is useless in that context, and it&#39;s a (sadly) typical context in iOS.<br></p><p>`local` is going to be equally useless in this context, because MainViewController.swift will almost certainly contain one 9.999KLOC `class` block. Cleaning up is, practically by definition, messy and tiring.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>access control proposal</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 3:57 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I don’t think these are troll proposals. They *are* a little more limited, a little more esoteric, but you could say the same thing about `local` vs. `private`. And in some cases you can emulate some of these with the four access modifiers you want, but again, you could say the same thing about `local` vs. `private`.<br></p><p>You&#39;re right.  Your examples have convinced me of this point.  There exist non-troll proposals for further access modifiers.<br></p><p>&gt; But it’s not zero-cost. It’s another thing to learn, another thing to think about, another way you have to mentally analyze your code.<br></p><p>I meant zero performance cost.  Of course all features have &quot;cost&quot; if we mean &quot;cognitive overhead&quot;.  Type safety for example has a huge cognitive overhead.  Think back to the days of &quot;Bool is not an NSString&quot;.  But the benefit of typesafety is large.  <br></p><p>In this case, the cognitive overhead is small, and so is the benefit.  But I think the value-per-unit-cost is similar.  In both cases the compiler helps you not do something very very bad, that is hard to debug in ObjC.<br></p><p>&gt; many people, when they do that, find this idea wanting.<br></p><p>Who?  You?  Then build an argument around that.  I don&#39;t know who &quot;many people&quot; are or what their justification is.<br></p><p>My justification is essentially that A) something like Synchronized is a problem nearly everybody has and B) the difficulty of defining a class-based solution in an optimal way.<br></p><p>On B, we seem to agree:<br></p><p>&gt;  it might be difficult to construct a Synchronized instance correctly.<br></p><p>So I can only conclude you disagree about A.  However, I think my A is much stronger than is strictly necessary to demand a language feature.  There are plenty of language features that not everyone uses, so the fact that you don&#39;t have a need for it (or even &quot;many people&quot;) is not really a counterargument I am able to understand.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/85158d27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; I don’t think these are troll proposals. They *are* a little more limited, a little more esoteric, but you could say the same thing about `local` vs. `private`. And in some cases you can emulate some of these with the four access modifiers you want, but again, you could say the same thing about `local` vs. `private`.<br>&gt; <br>&gt; You&#39;re right.  Your examples have convinced me of this point.  There exist non-troll proposals for further access modifiers.<br></p><p>There are definitely further refinements to access control that could be desired.  I have given them some thought as this thread has proceeded.  There would be ways to accommodate them through refinement of the &#39;scope&#39; access level.  <br></p><p>For example, we could allow a syntactic &#39;scope {}&#39; block which would be transparent for all purposes except introducing a scope for access control.  We could also allow labeled scopes and allow the &#39;scope&#39; access control level to specify a label, for example to allow an inner type to expose scoped members to the outer type but not other code in the same file.<br></p><p>While this potential exists I think it introduces complexity that is probably not worth it.  I am only mentioning these ideas to demonstrate that a &#39;scope&#39; access modifier is something that can be refined to provide more control if enough compelling use cases were identified.  We wouldn&#39;t need to add entirely new access modifiers to address such use cases.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151213/52853d31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>These are very nice refinements if we set a goal to make those scenarios<br>work. I think that they they would just need to be refactored though. If<br>the access level is so convoluted, there is something wrong with the API.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Sun, Dec 13, 2015 at 6:53 PM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; I don’t think these are troll proposals. They *are* a little more limited,<br>&gt; a little more esoteric, but you could say the same thing about `local` vs.<br>&gt; `private`. And in some cases you can emulate some of these with the four<br>&gt; access modifiers you want, but again, you could say the same thing about<br>&gt; `local` vs. `private`.<br>&gt;<br>&gt;<br>&gt; You&#39;re right.  Your examples have convinced me of this point.  There exist<br>&gt; non-troll proposals for further access modifiers.<br>&gt;<br>&gt;<br>&gt; There are definitely further refinements to access control that could be<br>&gt; desired.  I have given them some thought as this thread has proceeded.<br>&gt; There would be ways to accommodate them through refinement of the &#39;scope&#39;<br>&gt; access level.<br>&gt;<br>&gt; For example, we could allow a syntactic &#39;scope {}&#39; block which would be<br>&gt; transparent for all purposes except introducing a scope for access<br>&gt; control.  We could also allow labeled scopes and allow the &#39;scope&#39; access<br>&gt; control level to specify a label, for example to allow an inner type to<br>&gt; expose scoped members to the outer type but not other code in the same file.<br>&gt;<br>&gt; While this potential exists I think it introduces complexity that is<br>&gt; probably not worth it.  I am only mentioning these ideas to demonstrate<br>&gt; that a &#39;scope&#39; access modifier is something that can be refined to provide<br>&gt; more control if enough compelling use cases were identified.  We wouldn&#39;t<br>&gt; need to add entirely new access modifiers to address such use cases.<br>&gt;<br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/bc6c7adb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>access control proposal</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 13, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt;&gt; But it’s not zero-cost. It’s another thing to learn, another thing to think about, another way you have to mentally analyze your code.<br>&gt; <br>&gt; I meant zero performance cost.  Of course all features have &quot;cost&quot; if we mean &quot;cognitive overhead&quot;.  Type safety for example has a huge cognitive overhead.  Think back to the days of &quot;Bool is not an NSString&quot;.  But the benefit of typesafety is large.  <br>&gt; <br>&gt; In this case, the cognitive overhead is small, and so is the benefit.  But I think the value-per-unit-cost is similar.  In both cases the compiler helps you not do something very very bad, that is hard to debug in ObjC.<br></p><p>And I’m saying that I think the benefit is even smaller than you think it is, because you can usually get the same benefits by other means, and the resulting code will be *even safer* than `local` would give you. Again, consider the “value protected by a queue” case. Using `local` here limits the amount of code which could contain an access-without-synchronization bug, but `Synchronized` *completely eliminates* that class of bugs. Synchronized is a *better*, *safer* solution than `local`.<br></p><p>I believe that *most*—certainly not all, but most—uses of `local` are like this. `local` would improve the code&#39;s safety, but some sort of refactoring would be even better. Because of that, I don’t think `local` is as valuable as you think it is.<br></p><p>&gt;&gt; many people, when they do that, find this idea wanting.<br>&gt; <br>&gt; Who?  You?  Then build an argument around that.  I don&#39;t know who &quot;many people&quot; are or what their justification is.<br></p><p>I’m sorry, I don’t mean to make it sound like I’m speaking for some big, ill-defined posse. I just mean that different people will draw the line on the necessary cost-to-benefit in different places, and for some, this feature will fall on the wrong side of the line. People who don’t like this feature don’t misunderstand it; they just have a different subjective assessment of its value.<br></p><p>&gt; My justification is essentially that A) something like Synchronized is a problem nearly everybody has and B) the difficulty of defining a class-based solution in an optimal way.<br>&gt; <br>&gt; On B, we seem to agree:<br>&gt; <br>&gt;&gt;  it might be difficult to construct a Synchronized instance correctly.<br>&gt; <br>&gt; So I can only conclude you disagree about A.  However, I think my A is much stronger than is strictly necessary to demand a language feature.  There are plenty of language features that not everyone uses, so the fact that you don&#39;t have a need for it (or even &quot;many people&quot;) is not really a counterargument I am able to understand.<br></p><p>As far as a standard Synchronized is concerned, I agree with you that it’s a good idea. I am simply *worried* that we may have trouble coming up with a design that’s flexible enough to accommodate multiple synchronization methods, but still makes it easy to create a properly-configured Synchronized object. For example, something like this would be so complicated to configure that it would virtually defeat the purpose of having a Synchronized type:<br></p><p>	class Synchronized&lt;Value&gt; {<br>		init(value: Value, mutableRunner: (Void -&gt; Void) -&gt; Void, immutableRunner: (Void -&gt; Void) -&gt; Void) { … }<br>		…<br>	}<br></p><p>So I’m going to think out loud about this for a minute. All code was written in Mail.app and is untested.<br></p><p>I suppose we start with a protocol. The ideal interface for Synchronized would look something like this:<br></p><p>	protocol SynchronizedType: class {<br>		typealias Value<br>		func withMutableValue&lt;R&gt;(mutator: (inout Value) throws -&gt; R) rethrows -&gt; R<br>		func withValue&lt;R&gt;(accessor: Value throws -&gt; R) rethrows -&gt; R<br>	}<br></p><p>You could obviously write separate types like:<br></p><p>	class QueueSynchronized&lt;Value&gt;: SynchronizedType {<br>		private var value: Value<br>		private let queue: dispatch_queue_t<br>		<br>		init(value: Value, queue: dispatch_queue_t = dispatch_queue_create(“QueueSynchronized”, DISPATCH_QUEUE_CONCURRENT)) {<br>			self.value = value<br>			self.queue = queue<br>		}<br>		<br>		func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value) throws -&gt; R) rethrows -&gt; R {<br>			var ret: R?<br>			var blockError: NSError?<br>			dispatch_barrier_sync(queue) {<br>				do {<br>					ret = try mutator(&amp;value)<br>				}<br>				catch {<br>					blockError = error<br>				}<br>			}<br>			if let error = blockError {<br>				throw error<br>			}<br>			return ret!<br>		}<br>		<br>		func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R) rethrows -&gt; R {<br>			var ret: R?<br>			var blockError: NSError?<br>			dispatch_sync(queue) {<br>				do {<br>					ret = try accessor(value)<br>				}<br>				catch {<br>					blockError = error<br>				}<br>			}<br>			if let error = blockError {<br>				throw error<br>			}<br>			return ret!<br>		}<br>	}<br></p><p>and:<br></p><p>	class NSLockSynchronized&lt;Value&gt;: SynchronizedType {<br>		private var value: Value<br>		private var lock: NSLock<br>		<br>		init(value: Value, lock: NSLock = NSLock()) {<br>			self.value = value<br>			self.lock = lock<br>		}<br>		<br>		func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value) throws -&gt; R) rethrows -&gt; R {<br>			lock.lock()<br>			defer { lock.unlock() }<br></p><p>			return try mutator(&amp;value)<br>		}<br>		<br>		func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R) rethrows -&gt; R {<br>			// XXX I don’t know how to get concurrent reads with Cocoa locks.<br>			lock.lock()<br>			defer { lock.unlock() }<br></p><p>			return try accessor(value)<br>		}<br>	}<br></p><p>But that’s not a very satisfying design—so much boilerplate. Maybe we make the thing you’re synchronizing *on* be the protocol?<br></p><p>	protocol SynchronizerType: class {<br>		func synchronizeForReading(@noescape accessor: Void -&gt; Void)<br>		func synchronizeForWriting(@noescape mutator: Void -&gt; Void)<br>	}<br>	<br>	final class Synchronized&lt;Value&gt; {<br>		private var value = Value<br>		private let synchronizer: SynchronizerType<br>		<br>		init(value: Value, on synchronizer: SynchronizerType) {<br>			self.value = value<br>			self.synchronizer = synchronizer<br>		}<br></p><p>		func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value) throws -&gt; R) rethrows -&gt; R {<br>			var ret: R?<br>			var blockError: NSError?<br>			synchronizer.synchronizeForWriting {<br>				do {<br>					ret = try mutator(&amp;value)<br>				}<br>				catch {<br>					blockError = error<br>				}<br>			}<br>			if let error = blockError {<br>				throw error<br>			}<br>			return ret!<br>		}<br>		<br>		func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R) rethrows -&gt; R {<br>			var ret: R?<br>			var blockError: NSError?<br>			synchronizer.synchronizeForReading {<br>				do {<br>					ret = try accessor(value)<br>				}<br>				catch {<br>					blockError = error<br>				}<br>			}<br>			if let error = blockError {<br>				throw error<br>			}<br>			return ret!<br>		}<br>	}<br></p><p>	extension dispatch_queue: SynchronizerType {<br>		func synchronizeForReading(@noescape accessor: Void -&gt; Void) {<br>			dispatch_sync(self, accessor)<br>		}<br>		<br>		func synchronizeForWriting(@noescape mutator: Void -&gt; Void) {<br>			dispatch_barrier_sync(self, mutator)<br>		}<br>	}<br>	<br>	extension NSLock: SynchronizerType {<br>		func synchronizeForReading(@noescape accessor: Void -&gt; Void) {<br>			// XXX I don’t know how to get concurrent reads with Cocoa locks.<br>			lock()<br>			accessor()<br>			unlock()<br>		}<br>		<br>		func synchronizeForWriting(@noescape mutator: Void -&gt; Void) {<br>			lock()<br>			mutator()<br>			unlock()<br>		}<br>	}<br></p><p>Huh. That’s…actually pretty clean. And I suppose if you want it to default to using a dispatch queue, that’s just a default value on Synchronized.init(value:on:), or a new init(value:) added in an extension in LibDispatch. I thought this would be a lot hairier.<br></p><p>So, yeah, I guess I like the idea of a standard Synchronized. A well-designed version (one with something like SynchronizerType) can work with multiple locking mechanisms, without resorting to something error-prone like passing in closures. +1 for that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>access control proposal</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; I believe that *most*—certainly not all, but most—uses of `local` are<br>like this. `local` would improve the code&#39;s safety, but some sort of<br>refactoring would be even better. Because of that, I don’t think `local` is<br>as valuable as you think it is.<br></p><p>+1.<br></p><p>Let&#39;s try to promote existing access mechanisms, such as separating code<br>into a number of files, first, before deciding that we need new keywords.<br></p><p>On Mon, Dec 14, 2015 at 4:53 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; But it’s not zero-cost. It’s another thing to learn, another thing to<br>&gt; think about, another way you have to mentally analyze your code.<br>&gt; &gt;<br>&gt; &gt; I meant zero performance cost.  Of course all features have &quot;cost&quot; if we<br>&gt; mean &quot;cognitive overhead&quot;.  Type safety for example has a huge cognitive<br>&gt; overhead.  Think back to the days of &quot;Bool is not an NSString&quot;.  But the<br>&gt; benefit of typesafety is large.<br>&gt; &gt;<br>&gt; &gt; In this case, the cognitive overhead is small, and so is the benefit.<br>&gt; But I think the value-per-unit-cost is similar.  In both cases the compiler<br>&gt; helps you not do something very very bad, that is hard to debug in ObjC.<br>&gt;<br>&gt; And I’m saying that I think the benefit is even smaller than you think it<br>&gt; is, because you can usually get the same benefits by other means, and the<br>&gt; resulting code will be *even safer* than `local` would give you. Again,<br>&gt; consider the “value protected by a queue” case. Using `local` here limits<br>&gt; the amount of code which could contain an access-without-synchronization<br>&gt; bug, but `Synchronized` *completely eliminates* that class of bugs.<br>&gt; Synchronized is a *better*, *safer* solution than `local`.<br>&gt;<br>&gt; I believe that *most*—certainly not all, but most—uses of `local` are like<br>&gt; this. `local` would improve the code&#39;s safety, but some sort of refactoring<br>&gt; would be even better. Because of that, I don’t think `local` is as valuable<br>&gt; as you think it is.<br>&gt;<br>&gt; &gt;&gt; many people, when they do that, find this idea wanting.<br>&gt; &gt;<br>&gt; &gt; Who?  You?  Then build an argument around that.  I don&#39;t know who &quot;many<br>&gt; people&quot; are or what their justification is.<br>&gt;<br>&gt; I’m sorry, I don’t mean to make it sound like I’m speaking for some big,<br>&gt; ill-defined posse. I just mean that different people will draw the line on<br>&gt; the necessary cost-to-benefit in different places, and for some, this<br>&gt; feature will fall on the wrong side of the line. People who don’t like this<br>&gt; feature don’t misunderstand it; they just have a different subjective<br>&gt; assessment of its value.<br>&gt;<br>&gt; &gt; My justification is essentially that A) something like Synchronized is a<br>&gt; problem nearly everybody has and B) the difficulty of defining a<br>&gt; class-based solution in an optimal way.<br>&gt; &gt;<br>&gt; &gt; On B, we seem to agree:<br>&gt; &gt;<br>&gt; &gt;&gt;  it might be difficult to construct a Synchronized instance correctly.<br>&gt; &gt;<br>&gt; &gt; So I can only conclude you disagree about A.  However, I think my A is<br>&gt; much stronger than is strictly necessary to demand a language feature.<br>&gt; There are plenty of language features that not everyone uses, so the fact<br>&gt; that you don&#39;t have a need for it (or even &quot;many people&quot;) is not really a<br>&gt; counterargument I am able to understand.<br>&gt;<br>&gt; As far as a standard Synchronized is concerned, I agree with you that it’s<br>&gt; a good idea. I am simply *worried* that we may have trouble coming up with<br>&gt; a design that’s flexible enough to accommodate multiple synchronization<br>&gt; methods, but still makes it easy to create a properly-configured<br>&gt; Synchronized object. For example, something like this would be so<br>&gt; complicated to configure that it would virtually defeat the purpose of<br>&gt; having a Synchronized type:<br>&gt;<br>&gt;         class Synchronized&lt;Value&gt; {<br>&gt;                 init(value: Value, mutableRunner: (Void -&gt; Void) -&gt; Void,<br>&gt; immutableRunner: (Void -&gt; Void) -&gt; Void) { … }<br>&gt;                 …<br>&gt;         }<br>&gt;<br>&gt; So I’m going to think out loud about this for a minute. All code was<br>&gt; written in Mail.app and is untested.<br>&gt;<br>&gt; I suppose we start with a protocol. The ideal interface for Synchronized<br>&gt; would look something like this:<br>&gt;<br>&gt;         protocol SynchronizedType: class {<br>&gt;                 typealias Value<br>&gt;                 func withMutableValue&lt;R&gt;(mutator: (inout Value) throws -&gt;<br>&gt; R) rethrows -&gt; R<br>&gt;                 func withValue&lt;R&gt;(accessor: Value throws -&gt; R) rethrows -&gt;<br>&gt; R<br>&gt;         }<br>&gt;<br>&gt; You could obviously write separate types like:<br>&gt;<br>&gt;         class QueueSynchronized&lt;Value&gt;: SynchronizedType {<br>&gt;                 private var value: Value<br>&gt;                 private let queue: dispatch_queue_t<br>&gt;<br>&gt;                 init(value: Value, queue: dispatch_queue_t =<br>&gt; dispatch_queue_create(“QueueSynchronized”, DISPATCH_QUEUE_CONCURRENT)) {<br>&gt;                         self.value = value<br>&gt;                         self.queue = queue<br>&gt;                 }<br>&gt;<br>&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         dispatch_barrier_sync(queue) {<br>&gt;                                 do {<br>&gt;                                         ret = try mutator(&amp;value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;<br>&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt; rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         dispatch_sync(queue) {<br>&gt;                                 do {<br>&gt;                                         ret = try accessor(value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt;         class NSLockSynchronized&lt;Value&gt;: SynchronizedType {<br>&gt;                 private var value: Value<br>&gt;                 private var lock: NSLock<br>&gt;<br>&gt;                 init(value: Value, lock: NSLock = NSLock()) {<br>&gt;                         self.value = value<br>&gt;                         self.lock = lock<br>&gt;                 }<br>&gt;<br>&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;                         lock.lock()<br>&gt;                         defer { lock.unlock() }<br>&gt;<br>&gt;                         return try mutator(&amp;value)<br>&gt;                 }<br>&gt;<br>&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt; rethrows -&gt; R {<br>&gt;                         // XXX I don’t know how to get concurrent reads<br>&gt; with Cocoa locks.<br>&gt;                         lock.lock()<br>&gt;                         defer { lock.unlock() }<br>&gt;<br>&gt;                         return try accessor(value)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; But that’s not a very satisfying design—so much boilerplate. Maybe we make<br>&gt; the thing you’re synchronizing *on* be the protocol?<br>&gt;<br>&gt;         protocol SynchronizerType: class {<br>&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt; Void)<br>&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt; Void)<br>&gt;         }<br>&gt;<br>&gt;         final class Synchronized&lt;Value&gt; {<br>&gt;                 private var value = Value<br>&gt;                 private let synchronizer: SynchronizerType<br>&gt;<br>&gt;                 init(value: Value, on synchronizer: SynchronizerType) {<br>&gt;                         self.value = value<br>&gt;                         self.synchronizer = synchronizer<br>&gt;                 }<br>&gt;<br>&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         synchronizer.synchronizeForWriting {<br>&gt;                                 do {<br>&gt;                                         ret = try mutator(&amp;value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;<br>&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt; rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         synchronizer.synchronizeForReading {<br>&gt;                                 do {<br>&gt;                                         ret = try accessor(value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         extension dispatch_queue: SynchronizerType {<br>&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt; Void) {<br>&gt;                         dispatch_sync(self, accessor)<br>&gt;                 }<br>&gt;<br>&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt; Void) {<br>&gt;                         dispatch_barrier_sync(self, mutator)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         extension NSLock: SynchronizerType {<br>&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt; Void) {<br>&gt;                         // XXX I don’t know how to get concurrent reads<br>&gt; with Cocoa locks.<br>&gt;                         lock()<br>&gt;                         accessor()<br>&gt;                         unlock()<br>&gt;                 }<br>&gt;<br>&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt; Void) {<br>&gt;                         lock()<br>&gt;                         mutator()<br>&gt;                         unlock()<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; Huh. That’s…actually pretty clean. And I suppose if you want it to default<br>&gt; to using a dispatch queue, that’s just a default value on<br>&gt; Synchronized.init(value:on:), or a new init(value:) added in an extension<br>&gt; in LibDispatch. I thought this would be a lot hairier.<br>&gt;<br>&gt; So, yeah, I guess I like the idea of a standard Synchronized. A<br>&gt; well-designed version (one with something like SynchronizerType) can work<br>&gt; with multiple locking mechanisms, without resorting to something<br>&gt; error-prone like passing in closures. +1 for that.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/6de5175a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>If you were writing a book, would you want to put every paragraph into a<br>separate file?<br></p><p>On Mon, Dec 14, 2015 at 2:49 AM ilya via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; I believe that *most*—certainly not all, but most—uses of `local` are<br>&gt; like this. `local` would improve the code&#39;s safety, but some sort of<br>&gt; refactoring would be even better. Because of that, I don’t think `local` is<br>&gt; as valuable as you think it is.<br>&gt;<br>&gt; +1.<br>&gt;<br>&gt; Let&#39;s try to promote existing access mechanisms, such as separating code<br>&gt; into a number of files, first, before deciding that we need new keywords.<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 4:53 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt;&gt; But it’s not zero-cost. It’s another thing to learn, another thing to<br>&gt;&gt; think about, another way you have to mentally analyze your code.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I meant zero performance cost.  Of course all features have &quot;cost&quot; if<br>&gt;&gt; we mean &quot;cognitive overhead&quot;.  Type safety for example has a huge cognitive<br>&gt;&gt; overhead.  Think back to the days of &quot;Bool is not an NSString&quot;.  But the<br>&gt;&gt; benefit of typesafety is large.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In this case, the cognitive overhead is small, and so is the benefit.<br>&gt;&gt; But I think the value-per-unit-cost is similar.  In both cases the compiler<br>&gt;&gt; helps you not do something very very bad, that is hard to debug in ObjC.<br>&gt;&gt;<br>&gt;&gt; And I’m saying that I think the benefit is even smaller than you think it<br>&gt;&gt; is, because you can usually get the same benefits by other means, and the<br>&gt;&gt; resulting code will be *even safer* than `local` would give you. Again,<br>&gt;&gt; consider the “value protected by a queue” case. Using `local` here limits<br>&gt;&gt; the amount of code which could contain an access-without-synchronization<br>&gt;&gt; bug, but `Synchronized` *completely eliminates* that class of bugs.<br>&gt;&gt; Synchronized is a *better*, *safer* solution than `local`.<br>&gt;&gt;<br>&gt;&gt; I believe that *most*—certainly not all, but most—uses of `local` are<br>&gt;&gt; like this. `local` would improve the code&#39;s safety, but some sort of<br>&gt;&gt; refactoring would be even better. Because of that, I don’t think `local` is<br>&gt;&gt; as valuable as you think it is.<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; many people, when they do that, find this idea wanting.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Who?  You?  Then build an argument around that.  I don&#39;t know who &quot;many<br>&gt;&gt; people&quot; are or what their justification is.<br>&gt;&gt;<br>&gt;&gt; I’m sorry, I don’t mean to make it sound like I’m speaking for some big,<br>&gt;&gt; ill-defined posse. I just mean that different people will draw the line on<br>&gt;&gt; the necessary cost-to-benefit in different places, and for some, this<br>&gt;&gt; feature will fall on the wrong side of the line. People who don’t like this<br>&gt;&gt; feature don’t misunderstand it; they just have a different subjective<br>&gt;&gt; assessment of its value.<br>&gt;&gt;<br>&gt;&gt; &gt; My justification is essentially that A) something like Synchronized is<br>&gt;&gt; a problem nearly everybody has and B) the difficulty of defining a<br>&gt;&gt; class-based solution in an optimal way.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On B, we seem to agree:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;  it might be difficult to construct a Synchronized instance correctly.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So I can only conclude you disagree about A.  However, I think my A is<br>&gt;&gt; much stronger than is strictly necessary to demand a language feature.<br>&gt;&gt; There are plenty of language features that not everyone uses, so the fact<br>&gt;&gt; that you don&#39;t have a need for it (or even &quot;many people&quot;) is not really a<br>&gt;&gt; counterargument I am able to understand.<br>&gt;&gt;<br>&gt;&gt; As far as a standard Synchronized is concerned, I agree with you that<br>&gt;&gt; it’s a good idea. I am simply *worried* that we may have trouble coming up<br>&gt;&gt; with a design that’s flexible enough to accommodate multiple<br>&gt;&gt; synchronization methods, but still makes it easy to create a<br>&gt;&gt; properly-configured Synchronized object. For example, something like this<br>&gt;&gt; would be so complicated to configure that it would virtually defeat the<br>&gt;&gt; purpose of having a Synchronized type:<br>&gt;&gt;<br>&gt;&gt;         class Synchronized&lt;Value&gt; {<br>&gt;&gt;                 init(value: Value, mutableRunner: (Void -&gt; Void) -&gt; Void,<br>&gt;&gt; immutableRunner: (Void -&gt; Void) -&gt; Void) { … }<br>&gt;&gt;                 …<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; So I’m going to think out loud about this for a minute. All code was<br>&gt;&gt; written in Mail.app and is untested.<br>&gt;&gt;<br>&gt;&gt; I suppose we start with a protocol. The ideal interface for Synchronized<br>&gt;&gt; would look something like this:<br>&gt;&gt;<br>&gt;&gt;         protocol SynchronizedType: class {<br>&gt;&gt;                 typealias Value<br>&gt;&gt;                 func withMutableValue&lt;R&gt;(mutator: (inout Value) throws -&gt;<br>&gt;&gt; R) rethrows -&gt; R<br>&gt;&gt;                 func withValue&lt;R&gt;(accessor: Value throws -&gt; R) rethrows<br>&gt;&gt; -&gt; R<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; You could obviously write separate types like:<br>&gt;&gt;<br>&gt;&gt;         class QueueSynchronized&lt;Value&gt;: SynchronizedType {<br>&gt;&gt;                 private var value: Value<br>&gt;&gt;                 private let queue: dispatch_queue_t<br>&gt;&gt;<br>&gt;&gt;                 init(value: Value, queue: dispatch_queue_t =<br>&gt;&gt; dispatch_queue_create(“QueueSynchronized”, DISPATCH_QUEUE_CONCURRENT)) {<br>&gt;&gt;                         self.value = value<br>&gt;&gt;                         self.queue = queue<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt;&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;&gt;                         var ret: R?<br>&gt;&gt;                         var blockError: NSError?<br>&gt;&gt;                         dispatch_barrier_sync(queue) {<br>&gt;&gt;                                 do {<br>&gt;&gt;                                         ret = try mutator(&amp;value)<br>&gt;&gt;                                 }<br>&gt;&gt;                                 catch {<br>&gt;&gt;                                         blockError = error<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         if let error = blockError {<br>&gt;&gt;                                 throw error<br>&gt;&gt;                         }<br>&gt;&gt;                         return ret!<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt;&gt; rethrows -&gt; R {<br>&gt;&gt;                         var ret: R?<br>&gt;&gt;                         var blockError: NSError?<br>&gt;&gt;                         dispatch_sync(queue) {<br>&gt;&gt;                                 do {<br>&gt;&gt;                                         ret = try accessor(value)<br>&gt;&gt;                                 }<br>&gt;&gt;                                 catch {<br>&gt;&gt;                                         blockError = error<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         if let error = blockError {<br>&gt;&gt;                                 throw error<br>&gt;&gt;                         }<br>&gt;&gt;                         return ret!<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; and:<br>&gt;&gt;<br>&gt;&gt;         class NSLockSynchronized&lt;Value&gt;: SynchronizedType {<br>&gt;&gt;                 private var value: Value<br>&gt;&gt;                 private var lock: NSLock<br>&gt;&gt;<br>&gt;&gt;                 init(value: Value, lock: NSLock = NSLock()) {<br>&gt;&gt;                         self.value = value<br>&gt;&gt;                         self.lock = lock<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt;&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;&gt;                         lock.lock()<br>&gt;&gt;                         defer { lock.unlock() }<br>&gt;&gt;<br>&gt;&gt;                         return try mutator(&amp;value)<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt;&gt; rethrows -&gt; R {<br>&gt;&gt;                         // XXX I don’t know how to get concurrent reads<br>&gt;&gt; with Cocoa locks.<br>&gt;&gt;                         lock.lock()<br>&gt;&gt;                         defer { lock.unlock() }<br>&gt;&gt;<br>&gt;&gt;                         return try accessor(value)<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; But that’s not a very satisfying design—so much boilerplate. Maybe we<br>&gt;&gt; make the thing you’re synchronizing *on* be the protocol?<br>&gt;&gt;<br>&gt;&gt;         protocol SynchronizerType: class {<br>&gt;&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt;&gt; Void)<br>&gt;&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt;&gt; Void)<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         final class Synchronized&lt;Value&gt; {<br>&gt;&gt;                 private var value = Value<br>&gt;&gt;                 private let synchronizer: SynchronizerType<br>&gt;&gt;<br>&gt;&gt;                 init(value: Value, on synchronizer: SynchronizerType) {<br>&gt;&gt;                         self.value = value<br>&gt;&gt;                         self.synchronizer = synchronizer<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt;&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;&gt;                         var ret: R?<br>&gt;&gt;                         var blockError: NSError?<br>&gt;&gt;                         synchronizer.synchronizeForWriting {<br>&gt;&gt;                                 do {<br>&gt;&gt;                                         ret = try mutator(&amp;value)<br>&gt;&gt;                                 }<br>&gt;&gt;                                 catch {<br>&gt;&gt;                                         blockError = error<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         if let error = blockError {<br>&gt;&gt;                                 throw error<br>&gt;&gt;                         }<br>&gt;&gt;                         return ret!<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt;&gt; rethrows -&gt; R {<br>&gt;&gt;                         var ret: R?<br>&gt;&gt;                         var blockError: NSError?<br>&gt;&gt;                         synchronizer.synchronizeForReading {<br>&gt;&gt;                                 do {<br>&gt;&gt;                                         ret = try accessor(value)<br>&gt;&gt;                                 }<br>&gt;&gt;                                 catch {<br>&gt;&gt;                                         blockError = error<br>&gt;&gt;                                 }<br>&gt;&gt;                         }<br>&gt;&gt;                         if let error = blockError {<br>&gt;&gt;                                 throw error<br>&gt;&gt;                         }<br>&gt;&gt;                         return ret!<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension dispatch_queue: SynchronizerType {<br>&gt;&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt;&gt; Void) {<br>&gt;&gt;                         dispatch_sync(self, accessor)<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt;&gt; Void) {<br>&gt;&gt;                         dispatch_barrier_sync(self, mutator)<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension NSLock: SynchronizerType {<br>&gt;&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt;&gt; Void) {<br>&gt;&gt;                         // XXX I don’t know how to get concurrent reads<br>&gt;&gt; with Cocoa locks.<br>&gt;&gt;                         lock()<br>&gt;&gt;                         accessor()<br>&gt;&gt;                         unlock()<br>&gt;&gt;                 }<br>&gt;&gt;<br>&gt;&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt;&gt; Void) {<br>&gt;&gt;                         lock()<br>&gt;&gt;                         mutator()<br>&gt;&gt;                         unlock()<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; Huh. That’s…actually pretty clean. And I suppose if you want it to<br>&gt;&gt; default to using a dispatch queue, that’s just a default value on<br>&gt;&gt; Synchronized.init(value:on:), or a new init(value:) added in an extension<br>&gt;&gt; in LibDispatch. I thought this would be a lot hairier.<br>&gt;&gt;<br>&gt;&gt; So, yeah, I guess I like the idea of a standard Synchronized. A<br>&gt;&gt; well-designed version (one with something like SynchronizerType) can work<br>&gt;&gt; with multiple locking mechanisms, without resorting to something<br>&gt;&gt; error-prone like passing in closures. +1 for that.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/93473192/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&quot;I’m sorry, I don’t mean to make it sound like I’m speaking for some big,<br>ill-defined posse. I just mean that different people will draw the line on<br>the necessary cost-to-benefit in different places, and for some, this<br>feature will fall on the wrong side of the line. People who don’t like this<br>feature don’t misunderstand it; they just have a different subjective<br>assessment of its value.&quot;<br></p><p>I am not sure that this is true. Do you really see no value in completely<br>hiding implementation details of an API and making it enforceable by the<br>compiler?<br></p><p>On Sun, Dec 13, 2015 at 8:53 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; But it’s not zero-cost. It’s another thing to learn, another thing to<br>&gt; think about, another way you have to mentally analyze your code.<br>&gt; &gt;<br>&gt; &gt; I meant zero performance cost.  Of course all features have &quot;cost&quot; if we<br>&gt; mean &quot;cognitive overhead&quot;.  Type safety for example has a huge cognitive<br>&gt; overhead.  Think back to the days of &quot;Bool is not an NSString&quot;.  But the<br>&gt; benefit of typesafety is large.<br>&gt; &gt;<br>&gt; &gt; In this case, the cognitive overhead is small, and so is the benefit.<br>&gt; But I think the value-per-unit-cost is similar.  In both cases the compiler<br>&gt; helps you not do something very very bad, that is hard to debug in ObjC.<br>&gt;<br>&gt; And I’m saying that I think the benefit is even smaller than you think it<br>&gt; is, because you can usually get the same benefits by other means, and the<br>&gt; resulting code will be *even safer* than `local` would give you. Again,<br>&gt; consider the “value protected by a queue” case. Using `local` here limits<br>&gt; the amount of code which could contain an access-without-synchronization<br>&gt; bug, but `Synchronized` *completely eliminates* that class of bugs.<br>&gt; Synchronized is a *better*, *safer* solution than `local`.<br>&gt;<br>&gt; I believe that *most*—certainly not all, but most—uses of `local` are like<br>&gt; this. `local` would improve the code&#39;s safety, but some sort of refactoring<br>&gt; would be even better. Because of that, I don’t think `local` is as valuable<br>&gt; as you think it is.<br>&gt;<br>&gt; &gt;&gt; many people, when they do that, find this idea wanting.<br>&gt; &gt;<br>&gt; &gt; Who?  You?  Then build an argument around that.  I don&#39;t know who &quot;many<br>&gt; people&quot; are or what their justification is.<br>&gt;<br>&gt; I’m sorry, I don’t mean to make it sound like I’m speaking for some big,<br>&gt; ill-defined posse. I just mean that different people will draw the line on<br>&gt; the necessary cost-to-benefit in different places, and for some, this<br>&gt; feature will fall on the wrong side of the line. People who don’t like this<br>&gt; feature don’t misunderstand it; they just have a different subjective<br>&gt; assessment of its value.<br>&gt;<br>&gt; &gt; My justification is essentially that A) something like Synchronized is a<br>&gt; problem nearly everybody has and B) the difficulty of defining a<br>&gt; class-based solution in an optimal way.<br>&gt; &gt;<br>&gt; &gt; On B, we seem to agree:<br>&gt; &gt;<br>&gt; &gt;&gt;  it might be difficult to construct a Synchronized instance correctly.<br>&gt; &gt;<br>&gt; &gt; So I can only conclude you disagree about A.  However, I think my A is<br>&gt; much stronger than is strictly necessary to demand a language feature.<br>&gt; There are plenty of language features that not everyone uses, so the fact<br>&gt; that you don&#39;t have a need for it (or even &quot;many people&quot;) is not really a<br>&gt; counterargument I am able to understand.<br>&gt;<br>&gt; As far as a standard Synchronized is concerned, I agree with you that it’s<br>&gt; a good idea. I am simply *worried* that we may have trouble coming up with<br>&gt; a design that’s flexible enough to accommodate multiple synchronization<br>&gt; methods, but still makes it easy to create a properly-configured<br>&gt; Synchronized object. For example, something like this would be so<br>&gt; complicated to configure that it would virtually defeat the purpose of<br>&gt; having a Synchronized type:<br>&gt;<br>&gt;         class Synchronized&lt;Value&gt; {<br>&gt;                 init(value: Value, mutableRunner: (Void -&gt; Void) -&gt; Void,<br>&gt; immutableRunner: (Void -&gt; Void) -&gt; Void) { … }<br>&gt;                 …<br>&gt;         }<br>&gt;<br>&gt; So I’m going to think out loud about this for a minute. All code was<br>&gt; written in Mail.app and is untested.<br>&gt;<br>&gt; I suppose we start with a protocol. The ideal interface for Synchronized<br>&gt; would look something like this:<br>&gt;<br>&gt;         protocol SynchronizedType: class {<br>&gt;                 typealias Value<br>&gt;                 func withMutableValue&lt;R&gt;(mutator: (inout Value) throws -&gt;<br>&gt; R) rethrows -&gt; R<br>&gt;                 func withValue&lt;R&gt;(accessor: Value throws -&gt; R) rethrows -&gt;<br>&gt; R<br>&gt;         }<br>&gt;<br>&gt; You could obviously write separate types like:<br>&gt;<br>&gt;         class QueueSynchronized&lt;Value&gt;: SynchronizedType {<br>&gt;                 private var value: Value<br>&gt;                 private let queue: dispatch_queue_t<br>&gt;<br>&gt;                 init(value: Value, queue: dispatch_queue_t =<br>&gt; dispatch_queue_create(“QueueSynchronized”, DISPATCH_QUEUE_CONCURRENT)) {<br>&gt;                         self.value = value<br>&gt;                         self.queue = queue<br>&gt;                 }<br>&gt;<br>&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         dispatch_barrier_sync(queue) {<br>&gt;                                 do {<br>&gt;                                         ret = try mutator(&amp;value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;<br>&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt; rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         dispatch_sync(queue) {<br>&gt;                                 do {<br>&gt;                                         ret = try accessor(value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt;         class NSLockSynchronized&lt;Value&gt;: SynchronizedType {<br>&gt;                 private var value: Value<br>&gt;                 private var lock: NSLock<br>&gt;<br>&gt;                 init(value: Value, lock: NSLock = NSLock()) {<br>&gt;                         self.value = value<br>&gt;                         self.lock = lock<br>&gt;                 }<br>&gt;<br>&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;                         lock.lock()<br>&gt;                         defer { lock.unlock() }<br>&gt;<br>&gt;                         return try mutator(&amp;value)<br>&gt;                 }<br>&gt;<br>&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt; rethrows -&gt; R {<br>&gt;                         // XXX I don’t know how to get concurrent reads<br>&gt; with Cocoa locks.<br>&gt;                         lock.lock()<br>&gt;                         defer { lock.unlock() }<br>&gt;<br>&gt;                         return try accessor(value)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; But that’s not a very satisfying design—so much boilerplate. Maybe we make<br>&gt; the thing you’re synchronizing *on* be the protocol?<br>&gt;<br>&gt;         protocol SynchronizerType: class {<br>&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt; Void)<br>&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt; Void)<br>&gt;         }<br>&gt;<br>&gt;         final class Synchronized&lt;Value&gt; {<br>&gt;                 private var value = Value<br>&gt;                 private let synchronizer: SynchronizerType<br>&gt;<br>&gt;                 init(value: Value, on synchronizer: SynchronizerType) {<br>&gt;                         self.value = value<br>&gt;                         self.synchronizer = synchronizer<br>&gt;                 }<br>&gt;<br>&gt;                 func withMutableValue&lt;R&gt;(@noescape mutator: (inout Value)<br>&gt; throws -&gt; R) rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         synchronizer.synchronizeForWriting {<br>&gt;                                 do {<br>&gt;                                         ret = try mutator(&amp;value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;<br>&gt;                 func withValue&lt;R&gt;(@noescape accessor: Value throws -&gt; R)<br>&gt; rethrows -&gt; R {<br>&gt;                         var ret: R?<br>&gt;                         var blockError: NSError?<br>&gt;                         synchronizer.synchronizeForReading {<br>&gt;                                 do {<br>&gt;                                         ret = try accessor(value)<br>&gt;                                 }<br>&gt;                                 catch {<br>&gt;                                         blockError = error<br>&gt;                                 }<br>&gt;                         }<br>&gt;                         if let error = blockError {<br>&gt;                                 throw error<br>&gt;                         }<br>&gt;                         return ret!<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         extension dispatch_queue: SynchronizerType {<br>&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt; Void) {<br>&gt;                         dispatch_sync(self, accessor)<br>&gt;                 }<br>&gt;<br>&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt; Void) {<br>&gt;                         dispatch_barrier_sync(self, mutator)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt;         extension NSLock: SynchronizerType {<br>&gt;                 func synchronizeForReading(@noescape accessor: Void -&gt;<br>&gt; Void) {<br>&gt;                         // XXX I don’t know how to get concurrent reads<br>&gt; with Cocoa locks.<br>&gt;                         lock()<br>&gt;                         accessor()<br>&gt;                         unlock()<br>&gt;                 }<br>&gt;<br>&gt;                 func synchronizeForWriting(@noescape mutator: Void -&gt;<br>&gt; Void) {<br>&gt;                         lock()<br>&gt;                         mutator()<br>&gt;                         unlock()<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; Huh. That’s…actually pretty clean. And I suppose if you want it to default<br>&gt; to using a dispatch queue, that’s just a default value on<br>&gt; Synchronized.init(value:on:), or a new init(value:) added in an extension<br>&gt; in LibDispatch. I thought this would be a lot hairier.<br>&gt;<br>&gt; So, yeah, I guess I like the idea of a standard Synchronized. A<br>&gt; well-designed version (one with something like SynchronizerType) can work<br>&gt; with multiple locking mechanisms, without resorting to something<br>&gt; error-prone like passing in closures. +1 for that.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/f4c7a062/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>access control proposal</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 14, 2015 at 06:00:00am</p></header><div class="content"><p>&gt; Do you really see no value in completely hiding implementation details of an API and making it enforceable by the compiler?<br></p><p>On the contrary, I see great value in hiding implementation details. But, as I’ve previously explained, I don’t think adding a slew of different levels of access is the answer here. In many cases where `local` appears to be valuable, the real problem is that several concerns are being mixed together. That’s what’s wrong in the _queue/_children case: the concern of synchronizing access to _children has been improperly mixed with the concern of actually manipulating the _children array. Only by properly separating those concerns can you actually prevent bugs when accessing _children—and that separation is easily achieved with a separate file and `private`.<br></p><p>I’ve seen you make this argument several times:<br></p><p>&gt; If you were writing a book, would you want to put every paragraph into a separate file?<br></p><p><br>But that’s not what we’re actually contemplating here. A software project is a bit like an encyclopedia. Each article covers one subject, and not all subjects are the same. Some articles are short; some are long. But you would never glom several short articles together if they were about different subjects.<br></p><p>Similarly, each file in a project should handle one concern. And it is concerns—not types, not scopes—which have implementation details that should be hidden from the outside world. Almost by definition, if there’s something in one part of a file that shouldn’t be accessed by another part, those two don’t belong in the same file. It doesn’t matter if some of the resulting files are only ten lines—you’re not going to run out of inode numbers, are you?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 02:00:00pm</p></header><div class="content"><p>I am not going to run out of space, but I&#39;d rather not have 10000000 files.<br>Also, i think that concern is too abstract to be useful. Implementation<br>details that are hidden by a public API is much more concrete. And as soon<br>as it is stated that way, there is often a lot of value in grouping related<br>APIs and implementations into one file:<br></p><p>- consistent APIs<br>- consistent implementations<br></p><p>For example, it may make sense to put all array based implementations of<br>data structures into one file or put related data structures in one file<br>(or both).<br></p><p>The language shouldn&#39;t dictate how to organize code. The existing solution<br>is great for modules and libraries, but it doesn&#39;t work well at the level<br>of a specific API.<br></p><p>The analogy of an encyclopedia can work in favor of local. If you look at<br>Wikipedia, it doesn&#39;t put every section of an article into a separate page.<br>It&#39;s all in one place.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 9:02 AM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Do you really see no value in completely hiding implementation details<br>&gt; of an API and making it enforceable by the compiler?<br>&gt;<br>&gt; On the contrary, I see great value in hiding implementation details. But,<br>&gt; as I’ve previously explained, I don’t think adding a slew of different<br>&gt; levels of access is the answer here. In many cases where `local` appears to<br>&gt; be valuable, the real problem is that several concerns are being mixed<br>&gt; together. That’s what’s wrong in the _queue/_children case: the concern of<br>&gt; synchronizing access to _children has been improperly mixed with the<br>&gt; concern of actually manipulating the _children array. Only by properly<br>&gt; separating those concerns can you actually prevent bugs when accessing<br>&gt; _children—and that separation is easily achieved with a separate file and<br>&gt; `private`.<br>&gt;<br>&gt; I’ve seen you make this argument several times:<br>&gt;<br>&gt; &gt; If you were writing a book, would you want to put every paragraph into a<br>&gt; separate file?<br>&gt;<br>&gt;<br>&gt; But that’s not what we’re actually contemplating here. A software project<br>&gt; is a bit like an encyclopedia. Each article covers one subject, and not all<br>&gt; subjects are the same. Some articles are short; some are long. But you<br>&gt; would never glom several short articles together if they were about<br>&gt; different subjects.<br>&gt;<br>&gt; Similarly, each file in a project should handle one concern. And it is<br>&gt; concerns—not types, not scopes—which have implementation details that<br>&gt; should be hidden from the outside world. Almost by definition, if there’s<br>&gt; something in one part of a file that shouldn’t be accessed by another part,<br>&gt; those two don’t belong in the same file. It doesn’t matter if some of the<br>&gt; resulting files are only ten lines—you’re not going to run out of inode<br>&gt; numbers, are you?<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/c218513c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; <br>&gt; The language shouldn&#39;t dictate how to organize code. The existing solution is great for modules and libraries, but it doesn&#39;t work well at the level of a specific API.<br></p><p>+1.  One of my favorite things about Swift is much more flexible physical code organization and an established practice of moving away from one file per class and towards placing related code together regardless for various sense of “related”.  <br></p><p>For example, one may choose to place extensions to a number of types adding conformances to the same protocol in a single file.  I imagine physical layout like this is not uncommon in Swift code.  This does not necessarily mean you want these extensions to see implementation details of each other.  By adding a ‘scope’ access modifier we are able to properly hide these implementation details regardless of physical layout.  <br></p><p>This also improves robustness if you later decide to modify the physical organization of your code without changing visibility of the implementation details of the extensions.<br></p><p>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/c8163a02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>access control proposal</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 14, 2015 at 08:00:00am</p></header><div class="content"><p>Let’s take this it’s next logical conclusion: I have two types that need to access each other’s members for some significant performance gain. Let’s call these types A and B. Now, A also needs access to the inner members for C for the same reason (but note that B does not). I currently have other related types all in the same file, let’s say D and E.<br></p><p>Now, all members should be “local” to the types, but remember, A needs to access B&#39;s and C&#39;s members and the other types do not. Also, I can’t simply move the them to different files because they have non-overlapping “local” usage requirements. So do I need to create a “local friend” modifier so only particular types can access the inner details?<br></p><p>There’s a line somewhere where complexity becomes more burdensome. I’m not sure if “local” is that line, but I absolutely do know that “local friend” is across that line (because of course we’ll need private friend and internal friend modifiers as well…).<br></p><p>&gt; I imagine physical layout like this is not uncommon in Swift code.  This does not necessarily mean you want these extensions to see implementation details of each other.  By adding a ‘scope’ access modifier we are able to properly hide these implementation details regardless of physical layout.  <br></p><p>As mentioned above, what if you only want to make them available to some of the extensions?<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/0a3f244d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 10:00:00am</p></header><div class="content"><p>I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br></p><p>IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br></p><p>Matthew<br></p><p>&gt; On Dec 14, 2015, at 10:52 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Let’s take this it’s next logical conclusion: I have two types that need to access each other’s members for some significant performance gain. Let’s call these types A and B. Now, A also needs access to the inner members for C for the same reason (but note that B does not). I currently have other related types all in the same file, let’s say D and E.<br>&gt; <br>&gt; Now, all members should be “local” to the types, but remember, A needs to access B&#39;s and C&#39;s members and the other types do not. Also, I can’t simply move the them to different files because they have non-overlapping “local” usage requirements. So do I need to create a “local friend” modifier so only particular types can access the inner details?<br>&gt; <br>&gt; There’s a line somewhere where complexity becomes more burdensome. I’m not sure if “local” is that line, but I absolutely do know that “local friend” is across that line (because of course we’ll need private friend and internal friend modifiers as well…).<br>&gt; <br>&gt;&gt; I imagine physical layout like this is not uncommon in Swift code.  This does not necessarily mean you want these extensions to see implementation details of each other.  By adding a ‘scope’ access modifier we are able to properly hide these implementation details regardless of physical layout.  <br>&gt; <br>&gt; As mentioned above, what if you only want to make them available to some of the extensions?<br>&gt; <br>&gt; -David<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/fbb2a540/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>access control proposal</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>Isn&#39;t declaring &quot;scope&quot; access for a type at file-level effectively the<br>same as &quot;internal&quot;?<br>All symbols I declare at top-level of a file have &quot;internal&quot; access by<br>default.<br></p><p>For me &quot;public&quot;, &quot;internal&quot; and &quot;private&quot; ARE access *scopes* so adding<br>&quot;scope&quot; as an additional access scope is somehow confusing.<br></p><p><br>On Mon, Dec 14, 2015 at 5:58 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree that you can concoct arbitrarily complex scenarios and a line must<br>&gt; be drawn somewhere.  IMO the best place to draw the line is when you start<br>&gt; considering something that is not super straightforward to explain and is<br>&gt; not a natural extension of the obviously necessary access modifiers.<br>&gt;<br>&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt; complex is unlikely to pass such a test.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Dec 14, 2015, at 10:52 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;<br>&gt; Let’s take this it’s next logical conclusion: I have two types that need<br>&gt; to access each other’s members for some significant performance gain. Let’s<br>&gt; call these types A and B. Now, A also needs access to the inner members for<br>&gt; C for the same reason (but note that B does not). I currently have other<br>&gt; related types all in the same file, let’s say D and E.<br>&gt;<br>&gt; Now, all members should be “local” to the types, but remember, A needs to<br>&gt; access B&#39;s and C&#39;s members and the other types do not. Also, I can’t simply<br>&gt; move the them to different files because they have non-overlapping “local”<br>&gt; usage requirements. So do I need to create a “local friend” modifier so<br>&gt; only particular types can access the inner details?<br>&gt;<br>&gt; There’s a line somewhere where complexity becomes more burdensome. I’m not<br>&gt; sure if “local” is that line, but I absolutely do know that “local friend”<br>&gt; is across that line (because of course we’ll need private friend and<br>&gt; internal friend modifiers as well…).<br>&gt;<br>&gt; I imagine physical layout like this is not uncommon in Swift code.  This<br>&gt; does not necessarily mean you want these extensions to see implementation<br>&gt; details of each other.  By adding a ‘scope’ access modifier we are able to<br>&gt; properly hide these implementation details regardless of physical layout.<br>&gt;<br>&gt;<br>&gt; As mentioned above, what if you only want to make them available to *some* of<br>&gt; the extensions?<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/f5d4b8cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>Yes, declaring it for a top level type in a file doesn&#39;t make sense. It&#39;s<br>really for anything inside a scope that this scope is hiding. That&#39;s why I<br>prefer to call it local. The name doesn&#39;t matter too much to me (as long as<br>as it&#39;s reasonable). The important thing is that there is a way to<br>completely hide implementation details inside s scope (a type or an<br>extension) that does not force me to put every such scope into a separate<br>file.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 12:05 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; Isn&#39;t declaring &quot;scope&quot; access for a type at file-level effectively the<br>&gt; same as &quot;internal&quot;?<br>&gt; All symbols I declare at top-level of a file have &quot;internal&quot; access by<br>&gt; default.<br>&gt;<br>&gt; For me &quot;public&quot;, &quot;internal&quot; and &quot;private&quot; ARE access *scopes* so adding<br>&gt; &quot;scope&quot; as an additional access scope is somehow confusing.<br>&gt;<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 5:58 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 10:52 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Let’s take this it’s next logical conclusion: I have two types that need<br>&gt;&gt; to access each other’s members for some significant performance gain. Let’s<br>&gt;&gt; call these types A and B. Now, A also needs access to the inner members for<br>&gt;&gt; C for the same reason (but note that B does not). I currently have other<br>&gt;&gt; related types all in the same file, let’s say D and E.<br>&gt;&gt;<br>&gt;&gt; Now, all members should be “local” to the types, but remember, A needs to<br>&gt;&gt; access B&#39;s and C&#39;s members and the other types do not. Also, I can’t simply<br>&gt;&gt; move the them to different files because they have non-overlapping “local”<br>&gt;&gt; usage requirements. So do I need to create a “local friend” modifier so<br>&gt;&gt; only particular types can access the inner details?<br>&gt;&gt;<br>&gt;&gt; There’s a line somewhere where complexity becomes more burdensome. I’m<br>&gt;&gt; not sure if “local” is that line, but I absolutely do know that “local<br>&gt;&gt; friend” is across that line (because of course we’ll need private friend<br>&gt;&gt; and internal friend modifiers as well…).<br>&gt;&gt;<br>&gt;&gt; I imagine physical layout like this is not uncommon in Swift code.  This<br>&gt;&gt; does not necessarily mean you want these extensions to see implementation<br>&gt;&gt; details of each other.  By adding a ‘scope’ access modifier we are able to<br>&gt;&gt; properly hide these implementation details regardless of physical layout.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; As mentioned above, what if you only want to make them available to<br>&gt;&gt; *some* of the extensions?<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/e5161845/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; <br>&gt; Yes, declaring it for a top level type in a file doesn&#39;t make sense. It&#39;s really for anything inside a scope that this scope is hiding. That&#39;s why I prefer to call it local. The name doesn&#39;t matter too much to me (as long as as it&#39;s reasonable). The important thing is that there is a way to completely hide implementation details inside s scope (a type or an extension) that does not force me to put every such scope into a separate file.<br></p><p>The name doesn’t matter much to me either.  We discussed the reasons why ‘local’ is not a good name several days ago.  At the time everyone involved in the discussion seemed to understand ‘scope’ but it may also be confusing to enough people that we should find something else.  I will give this some further thought.<br></p><p>Matthew<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>access control proposal</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December 14, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt; <br>&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br></p><p>I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br></p><p>Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br></p><p>I think “local” fits this definition:<br></p><p>&gt; IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br></p><p>It’s not an obviously necessary modifier as it’s usage is extremely limited and requires to be bounced up a level is a lot of design considerations, such as extensions and subclasses. There are certainly times where “local” could be used, but my opinion is that it’s not worth complexity for the limited value that it actually brings to the table.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/b26fed54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>access control proposal</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>What about &quot;more private&quot; or &quot;really private&quot;? :)<br>j/k<br></p><p>I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>means.<br>Maybe &quot;my&quot;?  my var xyz = …<br></p><p>On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I agree that you can concoct arbitrarily complex scenarios and a line must<br>&gt; be drawn somewhere.  IMO the best place to draw the line is when you start<br>&gt; considering something that is not super straightforward to explain and is<br>&gt; not a natural extension of the obviously necessary access modifiers.<br>&gt;<br>&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt; complex is unlikely to pass such a test.<br>&gt;<br>&gt;<br>&gt; I think the simplest counter-example is your own example for extensions.<br>&gt; Each extensions will need access to different internals of the the type<br>&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt; forced to promote the access control from “local” to “private”.<br>&gt;<br>&gt; Another straight-forward one is a subclass. Since “local” would be “scope”<br>&gt; based, a subclass would also knot have access to those members defined as<br>&gt; local in the super class, so they’d have to be promoted to private and thus<br>&gt; available to all code within the file.<br>&gt;<br>&gt; I think “local” fits this definition:<br>&gt;<br>&gt; IMO the best place to draw the line is when you start considering<br>&gt; something that is not super straightforward to explain and is not a natural<br>&gt; extension of the obviously necessary access modifiers.<br>&gt;<br>&gt;<br>&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt; limited and requires to be bounced up a level is a lot of design<br>&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt; complexity for the limited value that it actually brings to the table.<br>&gt;<br>&gt; -David<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/1abed117/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt; j/k<br>&gt; <br>&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that means.<br>&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br>&gt;&gt; <br>&gt;&gt; I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt; <br>&gt;&gt; Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br>&gt;&gt; <br>&gt;&gt; I think “local” fits this definition:<br>&gt;&gt; <br>&gt;&gt;&gt; IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt; <br>&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely limited and requires to be bounced up a level is a lot of design considerations, such as extensions and subclasses. There are certainly times where “local” could be used, but my opinion is that it’s not worth complexity for the limited value that it actually brings to the table.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/eb3c0c53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>access control proposal</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>Even the Swift documentation refers uses the terms &quot;scope&quot; and &quot;scoped&quot; to<br>refer to the access *scope* a symbol has.<br>https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3<br></p><p>It&#39;s unlikely that an access modifier will ever be called like that since<br>it&#39;s just bogus and confusing.<br></p><p>On Mon, Dec 14, 2015 at 6:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt; j/k<br>&gt;<br>&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt; means.<br>&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think the simplest counter-example is your own example for extensions.<br>&gt;&gt; Each extensions will need access to different internals of the the type<br>&gt;&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt;&gt; forced to promote the access control from “local” to “private”.<br>&gt;&gt;<br>&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;<br>&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;<br>&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/ef7db2c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>If only the name is a problem, I am sure that we can come up with a good<br>name. scoped and local are just 2 potentially good names (and the<br>documentation could be updated if it&#39;s decided to use scoped).<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 14, 2015 at 12:31 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; Even the Swift documentation refers uses the terms &quot;scope&quot; and &quot;scoped&quot; to<br>&gt; refer to the access *scope* a symbol has.<br>&gt;<br>&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/AccessControl.html#//apple_ref/doc/uid/TP40014097-CH41-ID3<br>&gt;<br>&gt; It&#39;s unlikely that an access modifier will ever be called like that since<br>&gt; it&#39;s just bogus and confusing.<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 6:25 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt; j/k<br>&gt;&gt;<br>&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt;&gt; means.<br>&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions.<br>&gt;&gt;&gt; Each extensions will need access to different internals of the the type<br>&gt;&gt;&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt;&gt;&gt; forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/d05a14e0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>I missed it. I am not attached to it, but I wish I could see where it<br>happened. Can you point me to the emails?<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt; j/k<br>&gt;<br>&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt; means.<br>&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think the simplest counter-example is your own example for extensions.<br>&gt;&gt; Each extensions will need access to different internals of the the type<br>&gt;&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt;&gt; forced to promote the access control from “local” to “private”.<br>&gt;&gt;<br>&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;<br>&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;<br>&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;<br>&gt;&gt; -David<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/6b3ddcd0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>It was an exchange John McCall and I had on the 9th.<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html&gt;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001300.html<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html&gt;<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001305.html<br></p><p>Matthew<br></p><p>&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; I missed it. I am not attached to it, but I wish I could see where it happened. Can you point me to the emails?<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; <br>&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt; j/k<br>&gt;&gt; <br>&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that means.<br>&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br>&gt;&gt; <br>&gt;&gt; I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt; <br>&gt;&gt; Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br>&gt;&gt; <br>&gt;&gt; I think “local” fits this definition:<br>&gt;&gt; <br>&gt;&gt;&gt; IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt; <br>&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely limited and requires to be bounced up a level is a lot of design considerations, such as extensions and subclasses. There are certainly times where “local” could be used, but my opinion is that it’s not worth complexity for the limited value that it actually brings to the table.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/2b791ca6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>access control proposal</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>To sum up (what I understand) the new access modifier<br></p><p>   - can be used only on type members (properties, methods, initializers,<br>   subscripts and nested types) - so not at file-level<br>   - grants access to that symbol to<br>      - the containing type<br>      - (nested types)?<br>      - extension in the same file<br>   - and does not grant access to<br>      - extensions declared in a different file<br>      - subclasses<br>      - other locations in the same file as the ones granted above<br></p><p>Did I forget anything?<br></p><p>On Mon, Dec 14, 2015 at 6:53 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; It was an exchange John McCall and I had on the 9th.<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001300.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001305.html<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I missed it. I am not attached to it, but I wish I could see where it<br>&gt; happened. Can you point me to the emails?<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt; j/k<br>&gt;&gt;<br>&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt;&gt; means.<br>&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions.<br>&gt;&gt;&gt; Each extensions will need access to different internals of the the type<br>&gt;&gt;&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt;&gt;&gt; forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/e79f48d8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>No, it grants the use only in the syntactic scope in which the symbol is<br>defined. So if it&#39;s defined in an extension, only the other members inside<br>those curly braces can access it.<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 14, 2015 at 12:58 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; To sum up (what I understand) the new access modifier<br>&gt;<br>&gt;    - can be used only on type members (properties, methods, initializers,<br>&gt;    subscripts and nested types) - so not at file-level<br>&gt;    - grants access to that symbol to<br>&gt;       - the containing type<br>&gt;       - (nested types)?<br>&gt;       - extension in the same file<br>&gt;    - and does not grant access to<br>&gt;       - extensions declared in a different file<br>&gt;       - subclasses<br>&gt;       - other locations in the same file as the ones granted above<br>&gt;<br>&gt; Did I forget anything?<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 6:53 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; It was an exchange John McCall and I had on the 9th.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001300.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001305.html<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I missed it. I am not attached to it, but I wish I could see where it<br>&gt;&gt; happened. Can you point me to the emails?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt;&gt; j/k<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt;&gt;&gt; means.<br>&gt;&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt;&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt;&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt;&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt;&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think the simplest counter-example is your own example for<br>&gt;&gt;&gt;&gt; extensions. Each extensions will need access to different internals of the<br>&gt;&gt;&gt;&gt; the type it’s applied to. So when it comes time to add that extension,<br>&gt;&gt;&gt;&gt; you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/bee9ada2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>access control proposal</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>If the use case is about combining several private implementations into a<br>single file, I have a simpler suggestion: allow a &quot;private boundary&quot;,<br>something like:<br></p><p><br></p><p>// MARK: some extension<br></p><p>extension Something {<br>private func foo() ...<br></p><p>}<br></p><p>break private<br></p><p>// MARK: another extension<br></p><p>extension Another {<br>private func bar() ...<br>// has no access to Something.foo<br>}<br></p><p><br></p><p>Or perhaps<br></p><p><br></p><p>private namespace {<br>extension Something ...<br>}<br></p><p><br>On Mon, Dec 14, 2015 at 21:05 Ilya Belenkiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; No, it grants the use only in the syntactic scope in which the symbol is<br>&gt; defined. So if it&#39;s defined in an extension, only the other members inside<br>&gt; those curly braces can access it.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 14, 2015 at 12:58 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; To sum up (what I understand) the new access modifier<br>&gt;&gt;<br>&gt;&gt;    - can be used only on type members (properties, methods,<br>&gt;&gt;    initializers, subscripts and nested types) - so not at file-level<br>&gt;&gt;    - grants access to that symbol to<br>&gt;&gt;       - the containing type<br>&gt;&gt;       - (nested types)?<br>&gt;&gt;       - extension in the same file<br>&gt;&gt;    - and does not grant access to<br>&gt;&gt;       - extensions declared in a different file<br>&gt;&gt;       - subclasses<br>&gt;&gt;       - other locations in the same file as the ones granted above<br>&gt;&gt;<br>&gt;&gt; Did I forget anything?<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 6:53 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; It was an exchange John McCall and I had on the 9th.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001300.html<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001305.html<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I missed it. I am not attached to it, but I wish I could see where it<br>&gt;&gt;&gt; happened. Can you point me to the emails?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt;&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt;&gt;&gt; j/k<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly<br>&gt;&gt;&gt;&gt; that means.<br>&gt;&gt;&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples<br>&gt;&gt;&gt;&gt;&gt; do not.  It is the logical conclusion of a simple narrowing of visibility<br>&gt;&gt;&gt;&gt;&gt; from “everyone” to “module” to “file” to “scope”.  It is simple to explain<br>&gt;&gt;&gt;&gt;&gt; and understand.  Those who don’t like it don’t need to use it.  Anything<br>&gt;&gt;&gt;&gt;&gt; more complex is unlikely to pass such a test.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think the simplest counter-example is your own example for<br>&gt;&gt;&gt;&gt;&gt; extensions. Each extensions will need access to different internals of the<br>&gt;&gt;&gt;&gt;&gt; the type it’s applied to. So when it comes time to add that extension,<br>&gt;&gt;&gt;&gt;&gt; you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/214dfad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>I do not like the idea of a &quot;boundary&quot; or &quot;break private&quot; at all.<br></p><p>I think a number of objections are due to not understanding what we&#39;re talking about properly.  It has not been explained clearly and concisely in a formal proposal and this discussion has been going for a week or so.<br></p><p>Other objections have to do with confusion around or dislike of the keyword.<br></p><p>There are also some objections to the concept itself, but I believe anyone objecting to that will also object to any alternative proposals.<br></p><p>I think it&#39;s best to let the discussion die off until we have a clear and concise explanation in a draft of a proposal.  Ideally we can find a keyword that doesn&#39;t have potential for confusion as well.<br></p><p>Matthew<br></p><p><br>Sent from my iPad<br></p><p>&gt; On Dec 14, 2015, at 12:16 PM, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; If the use case is about combining several private implementations into a single file, I have a simpler suggestion: allow a &quot;private boundary&quot;, something like:<br>&gt; <br>&gt; <br>&gt; <br>&gt; // MARK: some extension<br>&gt; <br>&gt; extension Something {<br>&gt; private func foo() ...<br>&gt; <br>&gt; }<br>&gt; <br>&gt; break private<br>&gt; <br>&gt; // MARK: another extension<br>&gt; <br>&gt; extension Another {<br>&gt; private func bar() ...<br>&gt; // has no access to Something.foo<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; Or perhaps <br>&gt; <br>&gt; <br>&gt; <br>&gt; private namespace {<br>&gt; extension Something ... <br>&gt; } <br>&gt; <br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 21:05 Ilya Belenkiy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; No, it grants the use only in the syntactic scope in which the symbol is defined. So if it&#39;s defined in an extension, only the other members inside those curly braces can access it.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; On Mon, Dec 14, 2015 at 12:58 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt; To sum up (what I understand) the new access modifier<br>&gt;&gt;&gt; can be used only on type members (properties, methods, initializers, subscripts and nested types) - so not at file-level<br>&gt;&gt;&gt; grants access to that symbol to<br>&gt;&gt;&gt; the containing type<br>&gt;&gt;&gt; (nested types)?<br>&gt;&gt;&gt; extension in the same file<br>&gt;&gt;&gt; and does not grant access to<br>&gt;&gt;&gt; extensions declared in a different file<br>&gt;&gt;&gt; subclasses<br>&gt;&gt;&gt; other locations in the same file as the ones granted above<br>&gt;&gt;&gt; Did I forget anything?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:53 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; It was an exchange John McCall and I had on the 9th.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001300.html<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html<br>&gt;&gt;&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001305.html<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I missed it. I am not attached to it, but I wish I could see where it happened. Can you point me to the emails?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; j/k<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that means.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely limited and requires to be bounced up a level is a lot of design considerations, such as extensions and subclasses. There are certainly times where “local” could be used, but my opinion is that it’s not worth complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/462a0ae9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 14, 2015, at 11:58 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; To sum up (what I understand) the new access modifier<br>&gt; can be used only on type members (properties, methods, initializers, subscripts and nested types) - so not at file-level<br>&gt; grants access to that symbol to<br>&gt; the containing type<br>&gt; (nested types)?<br>&gt; extension in the same file<br>&gt; and does not grant access to<br>&gt; extensions declared in a different file<br>&gt; subclasses<br>&gt; other locations in the same file as the ones granted above<br>&gt; Did I forget anything?<br></p><p>This is *not* correct.  It only grants access to other members declared within the same body.  Some examples may help clarify the concept:<br></p><p>struct S {<br>    // visible within the struct declaration only and *nowhere* else<br>    scoped let foo: String<br></p><p>    struct T {<br>        // still within the scope of S so foo is still visible here<br>        // buzz is only visible within the inner type, buzz is not visible to members of S<br>        scoped let buzz: String<br>    }<br>}<br></p><p>// in same file<br>extension S {<br>    // foo is not visible here<br>    // bar is visible only within the extension in which it is declared and *nowhere* else<br>    scoped fun bar() -&gt; String<br>}<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/65e72a44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>access control proposal</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>Well that would break the pattern where you split the implementation of a<br>type across several extensions in the same file.<br>This is also often done when declaring protocol conformance to break down<br>the type into logical pieces.<br>I don&#39;t want to be forced to squeeze everything into the same body and<br>declare a list of a dozen protocol conformance at once.<br>On Dec 14, 2015 19:10, &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 14, 2015, at 11:58 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt; To sum up (what I understand) the new access modifier<br>&gt;<br>&gt;    - can be used only on type members (properties, methods, initializers,<br>&gt;    subscripts and nested types) - so not at file-level<br>&gt;    - grants access to that symbol to<br>&gt;       - the containing type<br>&gt;       - (nested types)?<br>&gt;       - extension in the same file<br>&gt;    - and does not grant access to<br>&gt;       - extensions declared in a different file<br>&gt;       - subclasses<br>&gt;       - other locations in the same file as the ones granted above<br>&gt;<br>&gt; Did I forget anything?<br>&gt;<br>&gt;<br>&gt; This is *not* correct.  It only grants access to other members declared<br>&gt; within the same body.  Some examples may help clarify the concept:<br>&gt;<br>&gt; struct S {<br>&gt;     // visible within the struct declaration only and *nowhere* else<br>&gt;     scoped let foo: String<br>&gt;<br>&gt;     struct T {<br>&gt;         // still within the scope of S so foo is still visible here<br>&gt;         // buzz is only visible within the inner type, buzz is not visible<br>&gt; to members of S<br>&gt;         scoped let buzz: String<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; // in same file<br>&gt; extension S {<br>&gt;     // foo is not visible here<br>&gt;     // bar is visible only within the extension in which it is declared<br>&gt; and *nowhere* else<br>&gt;     scoped fun bar() -&gt; String<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/83ae5a00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; Well that would break the pattern where you split the implementation of a type across several extensions in the same file.<br>&gt; This is also often done when declaring protocol conformance to break down the type into logical pieces. <br>&gt; I don&#39;t want to be forced to squeeze everything into the same body and declare a list of a dozen protocol conformance at once.<br>&gt; <br>No, it doesn&#39;t break that pattern at all.   In that case you already need to declare members visible to all extensions internal.  Nothing in this proposal will prevent you from doing that.  We are discussing use cases where a *single* extension, etc has implementation details it wants to keep hidden from *everything* outside that single extension.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/74a99fee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>access control proposal</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>This is not true. Extensions in the same file as the type they extend can<br>see all members of that type. They don&#39;t have to be internal.<br>On Dec 14, 2015 7:29 PM, &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com&gt; wrote:<br></p><p>&gt;<br>&gt; Well that would break the pattern where you split the implementation of a<br>&gt; type across several extensions in the same file.<br>&gt; This is also often done when declaring protocol conformance to break down<br>&gt; the type into logical pieces.<br>&gt; I don&#39;t want to be forced to squeeze everything into the same body and<br>&gt; declare a list of a dozen protocol conformance at once.<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; No, it doesn&#39;t break that pattern at all.   In that case you already need<br>&gt; to declare members visible to all extensions internal.  Nothing in this<br>&gt; proposal will prevent you from doing that.  We are discussing use cases<br>&gt; where a *single* extension, etc has implementation details it wants to keep<br>&gt; hidden from *everything* outside that single extension.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/a2e5e026/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>Yes. The proposal is about providing a more limited access that hides<br>implementation details for an API. So anything that uses the API whether it<br>is in the same file or not cannot see (and potentially misuse) the<br>implementation of the API.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 1:40 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; This is not true. Extensions in the same file as the type they extend can<br>&gt; see all members of that type. They don&#39;t have to be internal.<br>&gt; On Dec 14, 2015 7:29 PM, &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Well that would break the pattern where you split the implementation of a<br>&gt;&gt; type across several extensions in the same file.<br>&gt;&gt; This is also often done when declaring protocol conformance to break down<br>&gt;&gt; the type into logical pieces.<br>&gt;&gt; I don&#39;t want to be forced to squeeze everything into the same body and<br>&gt;&gt; declare a list of a dozen protocol conformance at once.<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; No, it doesn&#39;t break that pattern at all.   In that case you already<br>&gt;&gt; need to declare members visible to all extensions internal.  Nothing in<br>&gt;&gt; this proposal will prevent you from doing that.  We are discussing use<br>&gt;&gt; cases where a *single* extension, etc has implementation details it wants<br>&gt;&gt; to keep hidden from *everything* outside that single extension.<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/3415d0be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>You are right.  I misread your comment and thought you were referring to extensions in different files.  For extensions in the same file substitute private for internal in my reply and it holds.  We are not proposing to take away private.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 14, 2015, at 12:40 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; This is not true. Extensions in the same file as the type they extend can see all members of that type. They don&#39;t have to be internal.<br>&gt; <br>&gt;&gt; On Dec 14, 2015 7:29 PM, &quot;Matthew Johnson&quot; &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Well that would break the pattern where you split the implementation of a type across several extensions in the same file.<br>&gt;&gt;&gt; This is also often done when declaring protocol conformance to break down the type into logical pieces. <br>&gt;&gt;&gt; I don&#39;t want to be forced to squeeze everything into the same body and declare a list of a dozen protocol conformance at once.<br>&gt;&gt;&gt; <br>&gt;&gt; No, it doesn&#39;t break that pattern at all.   In that case you already need to declare members visible to all extensions internal.  Nothing in this proposal will prevent you from doing that.  We are discussing use cases where a *single* extension, etc has implementation details it wants to keep hidden from *everything* outside that single extension.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/6b6bf6ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>I see. I read those emails, and I think I replied as well. My take on it is<br>that it is no more confusing than using private to not mean the access<br>level that we are discussing right now. If private is already taken and we<br>cannot rename things, I&#39;d say that local is my next choice. I also like<br>scoped.<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 14, 2015 at 12:53 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; It was an exchange John McCall and I had on the 9th.<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001296.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001300.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001304.html<br>&gt;<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001305.html<br>&gt;<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I missed it. I am not attached to it, but I wish I could see where it<br>&gt; happened. Can you point me to the emails?<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt; j/k<br>&gt;&gt;<br>&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt;&gt; means.<br>&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions.<br>&gt;&gt;&gt; Each extensions will need access to different internals of the the type<br>&gt;&gt;&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt;&gt;&gt; forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/38a32efb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>I have been brainstorming other ideas for naming the keyword.  One that comes to mind is &#39;lexical&#39;.  Not sure I like it but thought it was worth mentioning.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; I missed it. I am not attached to it, but I wish I could see where it happened. Can you point me to the emails?<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; <br>&gt;&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt;&gt; j/k<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that means.<br>&gt;&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely limited and requires to be bounced up a level is a lot of design considerations, such as extensions and subclasses. There are certainly times where “local” could be used, but my opinion is that it’s not worth complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/95b07c7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 06:00:00pm</p></header><div class="content"><p>That works too.<br></p><p>--<br>Ilya Belenkiy<br>On Mon, Dec 14, 2015 at 1:30 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt; I have been brainstorming other ideas for naming the keyword.  One that<br>&gt; comes to mind is &#39;lexical&#39;.  Not sure I like it but thought it was worth<br>&gt; mentioning.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I missed it. I am not attached to it, but I wish I could see where it<br>&gt; happened. Can you point me to the emails?<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt;<br>&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt; j/k<br>&gt;&gt;<br>&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt;&gt; means.<br>&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions.<br>&gt;&gt;&gt; Each extensions will need access to different internals of the the type<br>&gt;&gt;&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt;&gt;&gt; forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/f1747c1f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 01:00:00pm</p></header><div class="content"><p>I thought of another I am not at all sure of, but in the spirit of open brainstorming here it is: &#39;enclosed&#39;.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 14, 2015, at 12:42 PM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt; <br>&gt; That works too.<br>&gt; <br>&gt; --<br>&gt; Ilya Belenkiy <br>&gt;&gt; On Mon, Dec 14, 2015 at 1:30 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; I have been brainstorming other ideas for naming the keyword.  One that comes to mind is &#39;lexical&#39;.  Not sure I like it but thought it was worth mentioning.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; I missed it. I am not attached to it, but I wish I could see where it happened. Can you point me to the emails?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Ilya Belenkiy<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt;&gt;&gt;&gt; j/k<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that means.<br>&gt;&gt;&gt;&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line must be drawn somewhere.  IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do not.  It is the logical conclusion of a simple narrowing of visibility from “everyone” to “module” to “file” to “scope”.  It is simple to explain and understand.  Those who don’t like it don’t need to use it.  Anything more complex is unlikely to pass such a test.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMO the best place to draw the line is when you start considering something that is not super straightforward to explain and is not a natural extension of the obviously necessary access modifiers.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely limited and requires to be bounced up a level is a lot of design considerations, such as extensions and subclasses. There are certainly times where “local” could be used, but my opinion is that it’s not worth complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/e067ebf3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>access control proposal</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 07:00:00pm</p></header><div class="content"><p>How about<br></p><p>private enclosed {<br>private func foo()<br>}<br></p><p>func bar() {<br>// no access to foo()<br>}<br></p><p>And there will be no need for new keywords.<br></p><p>On Mon, Dec 14, 2015 at 22:28 Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I thought of another I am not at all sure of, but in the spirit of open<br>&gt; brainstorming here it is: &#39;enclosed&#39;.<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Dec 14, 2015, at 12:42 PM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; That works too.<br>&gt;<br>&gt; --<br>&gt; Ilya Belenkiy<br>&gt; On Mon, Dec 14, 2015 at 1:30 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I have been brainstorming other ideas for naming the keyword.  One that<br>&gt;&gt; comes to mind is &#39;lexical&#39;.  Not sure I like it but thought it was worth<br>&gt;&gt; mentioning.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Dec 14, 2015, at 11:49 AM, Ilya Belenkiy &lt;ilya.belenkiy at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I missed it. I am not attached to it, but I wish I could see where it<br>&gt;&gt; happened. Can you point me to the emails?<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Ilya Belenkiy<br>&gt;&gt;<br>&gt;&gt; On Mon, Dec 14, 2015 at 12:25 PM Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; The idea of calling this &#39;local&#39; was abandoned a long time ago.  Any<br>&gt;&gt;&gt; proposal around this will be using &#39;scope&#39; or &#39;scoped&#39;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 14, 2015, at 11:22 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What about &quot;more private&quot; or &quot;really private&quot;? :)<br>&gt;&gt;&gt; j/k<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also thought about &quot;local&quot; but it&#39;s also not obvious what exactly that<br>&gt;&gt;&gt; means.<br>&gt;&gt;&gt; Maybe &quot;my&quot;?  my var xyz = …<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mon, Dec 14, 2015 at 6:17 PM, David Owens II via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I agree that you can concoct arbitrarily complex scenarios and a line<br>&gt;&gt;&gt;&gt; must be drawn somewhere.  IMO the best place to draw the line is when you<br>&gt;&gt;&gt;&gt; start considering something that is not super straightforward to explain<br>&gt;&gt;&gt;&gt; and is not a natural extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt;&gt;&gt;&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt;&gt;&gt;&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt;&gt;&gt;&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt;&gt;&gt;&gt; complex is unlikely to pass such a test.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think the simplest counter-example is your own example for<br>&gt;&gt;&gt;&gt; extensions. Each extensions will need access to different internals of the<br>&gt;&gt;&gt;&gt; the type it’s applied to. So when it comes time to add that extension,<br>&gt;&gt;&gt;&gt; you’ll be forced to promote the access control from “local” to “private”.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Another straight-forward one is a subclass. Since “local” would be<br>&gt;&gt;&gt;&gt; “scope” based, a subclass would also knot have access to those members<br>&gt;&gt;&gt;&gt; defined as local in the super class, so they’d have to be promoted to<br>&gt;&gt;&gt;&gt; private and thus available to all code within the file.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think “local” fits this definition:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMO the best place to draw the line is when you start considering<br>&gt;&gt;&gt;&gt; something that is not super straightforward to explain and is not a natural<br>&gt;&gt;&gt;&gt; extension of the obviously necessary access modifiers.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt;&gt;&gt;&gt; limited and requires to be bounced up a level is a lot of design<br>&gt;&gt;&gt;&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt;&gt;&gt;&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt;&gt;&gt;&gt; complexity for the limited value that it actually brings to the table.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/8b4bf6a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>access control proposal</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 14, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; <br>&gt; I think the simplest counter-example is your own example for extensions. Each extensions will need access to different internals of the the type it’s applied to. So when it comes time to add that extension, you’ll be forced to promote the access control from “local” to “private”.<br></p><p>I was referring specifically to extensions that *do not* require private access to the type, but rather work exclusively with its internal or public members.  Extensions such as this are not uncommon and may have implementation details of their own which do not need to be visible outside the extension.<br></p><p>&gt; <br>&gt; Another straight-forward one is a subclass. Since “local” would be “scope” based, a subclass would also knot have access to those members defined as local in the super class, so they’d have to be promoted to private and thus available to all code within the file.<br></p><p>We are not discussing protected access here.  I don’t like it and would not support adding it to Swift.<br></p><p>Matthew<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>If something is not an implementation detail and should be shared, local<br>doesn&#39;t apply. This applies equally to types and extensions. Subclasses may<br>or may not need access to the internals of a class. If the class can share<br>those implementation details, they should not be local (really called<br>private in many other languages). But they can and should be hidden most of<br>the time -- it&#39;s just part of designing a good APIs that implementations<br>hide behind small, focused, and convenient interfaces. Local will help<br>enforce it.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 12:17 PM David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 14, 2015, at 8:58 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; I agree that you can concoct arbitrarily complex scenarios and a line must<br>&gt; be drawn somewhere.  IMO the best place to draw the line is when you start<br>&gt; considering something that is not super straightforward to explain and is<br>&gt; not a natural extension of the obviously necessary access modifiers.<br>&gt;<br>&gt; IMO ‘scope’ passes this test and all of the complex counter-examples do<br>&gt; not.  It is the logical conclusion of a simple narrowing of visibility from<br>&gt; “everyone” to “module” to “file” to “scope”.  It is simple to explain and<br>&gt; understand.  Those who don’t like it don’t need to use it.  Anything more<br>&gt; complex is unlikely to pass such a test.<br>&gt;<br>&gt;<br>&gt; I think the simplest counter-example is your own example for extensions.<br>&gt; Each extensions will need access to different internals of the the type<br>&gt; it’s applied to. So when it comes time to add that extension, you’ll be<br>&gt; forced to promote the access control from “local” to “private”.<br>&gt;<br>&gt; Another straight-forward one is a subclass. Since “local” would be “scope”<br>&gt; based, a subclass would also knot have access to those members defined as<br>&gt; local in the super class, so they’d have to be promoted to private and thus<br>&gt; available to all code within the file.<br>&gt;<br>&gt; I think “local” fits this definition:<br>&gt;<br>&gt; IMO the best place to draw the line is when you start considering<br>&gt; something that is not super straightforward to explain and is not a natural<br>&gt; extension of the obviously necessary access modifiers.<br>&gt;<br>&gt;<br>&gt; It’s not an obviously necessary modifier as it’s usage is extremely<br>&gt; limited and requires to be bounced up a level is a lot of design<br>&gt; considerations, such as extensions and subclasses. There are certainly<br>&gt; times where “local” could be used, but my opinion is that it’s not worth<br>&gt; complexity for the limited value that it actually brings to the table.<br>&gt;<br>&gt; -David<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/ee81efb5/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 05:00:00pm</p></header><div class="content"><p>As soon as we say that we need to allow access for performance, scope or<br>local is not applicable. For that, private is perfect. But it should be a<br>rare exception and an alarm for anyone reading the code that the API<br>invariant could be broken by something else in the file. Most APIs don&#39;t<br>need this and should completely hide their implementation details. Local is<br>for that case. Distinguishing these cases helps clarifying the intent for<br>whoever is reading the code. The most important part though is that the<br>compiler enforces that intent.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Mon, Dec 14, 2015 at 11:52 AM David Owens II &lt;david at owensd.io&gt; wrote:<br></p><p>&gt; Let’s take this it’s next logical conclusion: I have two types that need<br>&gt; to access each other’s members for some significant performance gain. Let’s<br>&gt; call these types A and B. Now, A also needs access to the inner members for<br>&gt; C for the same reason (but note that B does not). I currently have other<br>&gt; related types all in the same file, let’s say D and E.<br>&gt;<br>&gt; Now, all members should be “local” to the types, but remember, A needs to<br>&gt; access B&#39;s and C&#39;s members and the other types do not. Also, I can’t simply<br>&gt; move the them to different files because they have non-overlapping “local”<br>&gt; usage requirements. So do I need to create a “local friend” modifier so<br>&gt; only particular types can access the inner details?<br>&gt;<br>&gt; There’s a line somewhere where complexity becomes more burdensome. I’m not<br>&gt; sure if “local” is that line, but I absolutely do know that “local friend”<br>&gt; is across that line (because of course we’ll need private friend and<br>&gt; internal friend modifiers as well…).<br>&gt;<br>&gt; I imagine physical layout like this is not uncommon in Swift code.  This<br>&gt; does not necessarily mean you want these extensions to see implementation<br>&gt; details of each other.  By adding a ‘scope’ access modifier we are able to<br>&gt; properly hide these implementation details regardless of physical layout.<br>&gt;<br>&gt;<br>&gt; As mentioned above, what if you only want to make them available to *some* of<br>&gt; the extensions?<br>&gt;<br>&gt; -David<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/97620137/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>access control proposal</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>All of these examples for more access control could and should be<br>refactored to have simple interfaces with completely hidden implementation<br>details.<br></p><p>The discussion has become unnecessarily complicated. This proposal is about<br>a fundamental concept of software engineering: provide a small and simple<br>interface that serves a particular purpose and hide implementation details.<br></p><p>Implementation details need to be hidden for several reasons:<br>- ensure that the invariant of the public API holds true regardless of how<br>the public API is used. For example, a stack&#39;s element count and relative<br>order changes only with push() and pop().<br>- the implementation could be changed without affecting how the API is<br>used. For example, a stack backed by an array could turn into a stack<br>backed by a linked list.<br>- the API that the user has to deal with is small. If the user can see the<br>internals, he has to constantly separate what&#39;s public (and allowed) and<br>what is private (and could change).<br></p><p>Currently, the only 2 ways to express this concept in Swift are<br>1) use private and put the implementation  into a separate file<br>2) use _ or some other convention to distinguish public APIs from the<br>functions that are used for implementation<br></p><p>Using separate files works, but it doesn&#39;t work well for related concepts.<br>It often makes sense to group similar concepts / interfaces / APIs in one<br>file. This solution comes at the expense of not being able to do this,<br>which I find extremely limiting. An analogy: it makes sense to put separate<br>chapters of a book into different files, but a file per paragraph is<br>extremely inconvenient.<br></p><p>Using _ also helps, but it&#39;s coding by convention. It is still possible and<br>easy to break it and break the code. And we see it all the time with ObjC<br>developers trying to use private APIs to fix a bug or add functionality<br>that is not public. It also forces the programmer to sort through all the _<br>in search for the APIs that he can use. And if he first sees a similar<br>private API, it takes a mental strain not to use it and keep searching for<br>the pubic version (if there is one).<br></p><p>Using local solves the problem an all accounts:<br>- the compiler enforces that the invariant holds true (as long as the<br>implementation is correct)<br>- the auto completion shows only the methods that are available instead of<br>showing the APIs that the user should not use<br>- the code can be organized in a way that makes sense with grouping of<br>related code into one file without introducing oversharing of APIs.<br></p><p>Local is also very much in line with Swift&#39;s focus on strong type system,<br>elimination of accidental mistakes, and code clarity. If we have guard that<br>can be easily replaced by an if statement, I don&#39;t see how local is a<br>problem. If you say &quot;but guard helps eliminate lots of nested if<br>statements&quot;, I can reply &quot;but local helps eliminate lots of tiny files&quot;.<br>Any arguments about cognitive overhead, making language bigger, etc. can be<br>argued the same way. The biggest difference though is that local is not<br>only about clarity and convenience, it&#39;s also about correctness. I would<br>even argue that local should be the default and that any other access level<br>modifier should be a deliberate choice by the programmer.<br></p><p>--<br>Ilya Belenkiy<br></p><p>On Sun, Dec 13, 2015 at 4:58 PM Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; I mean, look, you’re right. In your case, three access modifiers isn’t<br>&gt; enough to prevent this mistake; you need four. But,<br>&gt; &gt;&gt; given four, you could provide an example that needs five. Given five,<br>&gt; you could come up with one for six. Given N access modifiers, you can write<br>&gt; a case where you need N + 1.<br>&gt; &gt;<br>&gt; &gt; Nope.  What we&#39;re talking about (what I&#39;m talking about, anyway) is a<br>&gt; syntactically scoped access modifier.  There is no N+1 case.  There is no<br>&gt; &quot;even more scoped&quot;.  There is no inductive case.<br>&gt; &gt;<br>&gt; &gt; I mean, it is possible to write a troll proposal for an access modifier<br>&gt; visible to the 3 lines before and after the declaration, or something.<br>&gt; That much I grant.  But troll proposals aside, a scoped access modifier is<br>&gt; the quark of the access modifiers; there is no sensible way to go halvsies.<br>&gt;<br>&gt; I actually immediately thought of several things you might want:<br>&gt;<br>&gt; • You have two logical “groups” of properties and methods in a type, and<br>&gt; you want to only permit access within a group. But both groups have stored<br>&gt; properties, so they must be defined in the scope of the main type<br>&gt; definition.<br>&gt; • You have types nested within your type. You want methods in your own<br>&gt; type to have access, but not methods in those nested types.<br>&gt; • Alternatively, you have types nested within your type. You want the<br>&gt; outer type to have access to things in the nested type, but not any other<br>&gt; type.<br>&gt;<br>&gt; I don’t think these are troll proposals. They *are* a little more limited,<br>&gt; a little more esoteric, but you could say the same thing about `local` vs.<br>&gt; `private`. And in some cases you can emulate some of these with the four<br>&gt; access modifiers you want, but again, you could say the same thing about<br>&gt; `local` vs. `private`.<br>&gt;<br>&gt; &gt;&gt; Actually, for this case, there *is* a way to achieve better safety<br>&gt; without additional access modifiers. Create a new file and call it<br>&gt; Synchronized.swift:<br>&gt; &gt;<br>&gt; &gt; This is the solution that I ship.  I think if we don&#39;t add a new<br>&gt; visibility modifier, we should definitely do this in the standard library,<br>&gt; because &quot;resource synchronization&quot; is a problem most modern programs have.<br>&gt;<br>&gt; This is not a bad idea. The only potential issue I can see with it is<br>&gt; that, if it’s made too general, it might be difficult to construct a<br>&gt; Synchronized instance correctly.<br>&gt;<br>&gt; &gt;&gt; My solution is to be careful when I’m writing code.<br>&gt; &gt;<br>&gt; &gt; It is actually *this* statement which is weak to an induction attack.<br>&gt; We can *always* be more careful writing code.  Why do we need typechecking,<br>&gt; why do we need integer overflow trapping, why do we need array out of<br>&gt; bounds exceptions?  The C developer says they do not need half of Swift<br>&gt; because their solution is to be more careful writing code.  The C developer<br>&gt; is naive.<br>&gt; &gt;<br>&gt; &gt; But in *this* language, we adopt zero and low-cost abstractions in the<br>&gt; name of safety.  A scoped access modifier is a zero-cost abstraction that<br>&gt; makes the language safer.  We should adopt it.  If for no other reason,<br>&gt; than consistency with the other aspects of the language design.  Either<br>&gt; that or we should move integer overflow checks into the standard library<br>&gt; for consistency with Synchronized, which I present as a troll proposal.<br>&gt;<br>&gt; But it’s not zero-cost. It’s another thing to learn, another thing to<br>&gt; think about, another way you have to mentally analyze your code. It has to<br>&gt; be balanced against the goal of keeping the language small and simple. And<br>&gt; many people, when they do that, find this idea wanting.<br>&gt;<br>&gt; &gt; I mean, I don&#39;t know about you, but I get called in to look at projects<br>&gt; regularly that have a MainViewController.swift that weighs 10KLOC.  I<br>&gt; didn&#39;t write it.  I didn&#39;t make the mess.  I just want tools to help me<br>&gt; clean it up.  &#39;private&#39; is useless in that context, and it&#39;s a (sadly)<br>&gt; typical context in iOS.<br>&gt;<br>&gt; `local` is going to be equally useless in this context, because<br>&gt; MainViewController.swift will almost certainly contain one 9.999KLOC<br>&gt; `class` block. Cleaning up is, practically by definition, messy and tiring.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/f205db12/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
