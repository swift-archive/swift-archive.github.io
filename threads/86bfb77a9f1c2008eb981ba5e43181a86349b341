<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>My biggest concern with the proposal is the lack of data regarding<br>equivalents for existing C-style for loops.  Note that I&#39;m not talking<br>about code that uses C-style for loops in cases where a superior<br>construct exists in Swift, for example, `for i in myArray.indices`.<br>I&#39;m interested in seeing cases not covered by that.<br></p><p>For example, it would be good if someone took a look at &quot;git grep &#39;for<br>var&#39; stdlib/&quot; and submitted a PR that converts all those loops.  If<br>that results in readability improvements, it would be a great PR<br>regardless of the decision on this proposal.<br></p><p>Another concern of mine is the equivalent of C-style for loops with<br>&#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>can think of duplicates the increment portion of the loop.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>December  7, 2015 at 04:00:00pm</p></header><div class="content"><p>It looks like the standard library has between ten and twenty &quot;for var&quot; instances (depends on if you count before or after de-gybbing), that fall into four categories:<br></p><p>1) for var i = 0; i &lt; length; i++ { ...<br></p><p>These are the most prevalent (and would be everywhere else), and are easily replaced by &quot;for i in 0 ..&lt; length&quot; or &quot;for i in x.indices&quot;.<br></p><p>2) for var i = length; --i &gt;= 0; { ...<br></p><p>This is a &quot;count-down&quot; loop, and isn&#39;t handled that well in Swift. The &quot;guessing&quot; translation is both wrong and fails to compile (&quot;for i in length ... 0&quot;), another attempt compiles but is easy to get wrong:<br></p><p>for length.stride(to: 0, by: -1) { // wrong, includes length but not zero<br>for length.stride(through: 0, by: -1) { // wrong, still includes length<br>for (length - 1).stride(through: 0, by: -1) { // works, but people have switched back to Java by now<br></p><p>Probably the best practice is to use reverse() on the range, since then you&#39;d be using the same method on a &quot;range literal&quot;, the indices range, or a collection:<br></p><p>for (0 ..&lt; length).reverse() { ...<br></p><p>3) for var i = 0; i != n &amp;&amp; p != limit; i++ { ...<br></p><p>This style *looks* like #1 but hides a second condition -- it&#39;s very easy for a newcomer to come to code with this construct and miss second part of the termination case. Far better to refactor this so the second condition is explicit:<br></p><p>for i in 0 ..&lt; n {<br> guard p != limit else { break }<br> ...<br>}<br></p><p>4) for var x = foo(y); x.isNotFinished(); x = foo(x) { ...<br></p><p>These can be refactored into while loops without much trouble. Your concern below about continue statements is well-founded. What we might call a &quot;while-defer&quot; loop solves that (though I&#39;m not crazy about the construct):<br></p><p>var x = foo(y)<br>while x.isNotFinished() {<br> defer { x = foo(x) }<br> ...<br>}<br></p><p>That method has the added benefit of putting the test and the &quot;increment&quot; right in one place at the top of the loop. There&#39;s a slight difference in that the deferred increment gets executed after a &quot;break&quot;, unlike the last statement of a &quot;for var ; ;&quot; loop.<br></p><p>Nate<br></p><p><br>&gt; On Dec 7, 2015, at 3:07 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; My biggest concern with the proposal is the lack of data regarding<br>&gt; equivalents for existing C-style for loops.  Note that I&#39;m not talking<br>&gt; about code that uses C-style for loops in cases where a superior<br>&gt; construct exists in Swift, for example, `for i in myArray.indices`.<br>&gt; I&#39;m interested in seeing cases not covered by that.<br>&gt; <br>&gt; For example, it would be good if someone took a look at &quot;git grep &#39;for<br>&gt; var&#39; stdlib/&quot; and submitted a PR that converts all those loops.  If<br>&gt; that results in readability improvements, it would be a great PR<br>&gt; regardless of the decision on this proposal.<br>&gt; <br>&gt; Another concern of mine is the equivalent of C-style for loops with<br>&gt; &#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>&gt; can think of duplicates the increment portion of the loop.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December  7, 2015 at 05:00:00pm</p></header><div class="content"><p>On Mon, Dec 7, 2015, at 01:07 PM, Dmitri Gribenko via swift-evolution<br>wrote:<br>&gt; Another concern of mine is the equivalent of C-style for loops with<br>&gt; &#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>&gt; can think of duplicates the increment portion of the loop.<br></p><p>As has been pointed out in other threads on this topic, you can use a<br>defer statement to avoid duplicating the increment portion:<br></p><p>var i = initial<br>while cond(i) {<br>    defer { i = increment(i) }<br>    // ...<br>    if frob {<br>        continue // defer will execute<br>    }<br>}<br></p><p>-Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  7, 2015 at 08:00:00pm</p></header><div class="content"><p>Le 7 dÃ©c. 2015 Ã  20:29, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a Ã©crit :<br></p><p>&gt; On Mon, Dec 7, 2015, at 01:07 PM, Dmitri Gribenko via swift-evolution<br>&gt; wrote:<br>&gt;&gt; Another concern of mine is the equivalent of C-style for loops with<br>&gt;&gt; &#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>&gt;&gt; can think of duplicates the increment portion of the loop.<br>&gt; <br>&gt; As has been pointed out in other threads on this topic, you can use a<br>&gt; defer statement to avoid duplicating the increment portion:<br>&gt; <br>&gt; var i = initial<br>&gt; while cond(i) {<br>&gt;    defer { i = increment(i) }<br>&gt;    // ...<br>&gt;    if frob {<br>&gt;        continue // defer will execute<br>&gt;    }<br>&gt; }<br></p><p>Which is a dangerous substitute, because it also does the wrong thing with break and throw:<br></p><p>	var i = initial<br>	while cond(i) {<br>		defer { i = increment(i) }<br>		// ...<br>		if frob {<br>			continue // defer will execute<br>		} else if blob {<br>			break // defer will execute!!!<br>		} else if plob {<br>			throw MyError // defer will execute!!!<br>		}<br>	}<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  7, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:58 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Le 7 dÃ©c. 2015 Ã  20:29, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a Ã©crit :<br>&gt; <br>&gt;&gt; On Mon, Dec 7, 2015, at 01:07 PM, Dmitri Gribenko via swift-evolution<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; Another concern of mine is the equivalent of C-style for loops with<br>&gt;&gt;&gt; &#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>&gt;&gt;&gt; can think of duplicates the increment portion of the loop.<br>&gt;&gt; <br>&gt;&gt; As has been pointed out in other threads on this topic, you can use a<br>&gt;&gt; defer statement to avoid duplicating the increment portion:<br>&gt;&gt; <br>&gt;&gt; var i = initial<br>&gt;&gt; while cond(i) {<br>&gt;&gt;   defer { i = increment(i) }<br>&gt;&gt;   // ...<br>&gt;&gt;   if frob {<br>&gt;&gt;       continue // defer will execute<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Which is a dangerous substitute, because it also does the wrong thing with break and throw:<br>&gt; <br>&gt; 	var i = initial<br>&gt; 	while cond(i) {<br>&gt; 		defer { i = increment(i) }<br>&gt; 		// ...<br>&gt; 		if frob {<br>&gt; 			continue // defer will execute<br>&gt; 		} else if blob {<br>&gt; 			break // defer will execute!!!<br>&gt; 		} else if plob {<br>&gt; 			throw MyError // defer will execute!!!<br>&gt; 		}<br>&gt; 	}<br></p><p><br>A more accurate (but not particularly pretty) substitution would be to perform the increment as part of the condition:<br></p><p>while { i = increment(i); return cond(i) }() {<br>}<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/3a55a745/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  7, 2015 at 10:00:00pm</p></header><div class="content"><p>Le 7 dÃ©c. 2015 Ã  21:03, Joe Groff &lt;jgroff at apple.com&gt; a Ã©crit :<br>&gt; A more accurate (but not particularly pretty) substitution would be to perform the increment as part of the condition:<br>&gt; <br>&gt; while { i = increment(i); return cond(i) }() {<br>&gt; }<br></p><p>That&#39;s buggy (and also does not compile). What you want is this:<br></p><p>var i = 0<br>var first = true<br>while ({ () -&gt; Bool in if first { first = false } else { i = increment(i) }; return cond(i) }()) {<br>}<br></p><p>Interestingly, this behaves correctly with both continue, break, and throw. It&#39;s not pretty, but this struct will make a little bit easier on the eye:<br></p><p>/// Provide a suitable condition for recreating the control flow of a C-style `for`<br>/// loop within a `while` loop.<br>///<br>///     var loop = CForLoop()<br>///     var i = 0<br>///     while loop.test(i &lt; 2, {i += 1}) { ... }<br>///<br>/// - Note: You have to make a new controller each time you start a loop.<br>struct CForLoop {<br></p><p>	/// Flag to prevent the increment part from executing on the first iteration of <br>	/// the loop.<br>	private var first = true<br></p><p>	/// If this is the first call of test, simply evaluate `predicate` and return<br>	/// its value. Subsequent calls will execute `increment` before evaluating<br>	/// `predicate`.<br>	/// - Parameter predicate: The test condition that must be true for the loop to<br>	///   continue. This is the second statement in a C-style `for` loop.<br>	/// - Parameter increment: The code to execute just before re-evaluating the<br>	///   predicate at the end of one loop iteration. This is the third statement<br>	///   of a C-style `for` loop.<br>	/// - Returns: The value returned by predicate. This value should be used as<br>	///   the condition in a `while` loop.<br>	mutating func test(@autoclosure predicate: () -&gt; Bool, _ increment: () -&gt; ()) -&gt; Bool {<br>		if first {<br>			first = false<br>		} else {<br>			increment()<br>		}<br>		return predicate()<br>	}<br>}<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bab03b11d4cd60804cf4a6ba68589430?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Kevin Lundberg</string> &lt;kevin at klundberg.com&gt;<p>December  7, 2015 at 09:00:00pm</p></header><div class="content"><p>For throw, if incrementing i has no external side effects, then there shouldnâ€™t be any issue since i will be thrown away anyways when the error is thrown. <br></p><p>For break, it can be considered dangerous, but if your while loops are written semantically like the old c-style for loop, the counter shouldnâ€™t be used outside the scope of the loop anyways. If that matters to whomever may write code like this, then manual incrementing at each point where loop scope breaks is necessary (though I imagine such cases are likely rare).<br>--<br>Kevin Lundberg<br></p><p>&gt; On Dec 7, 2015, at 8:58 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Le 7 dÃ©c. 2015 Ã  20:29, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a Ã©crit :<br>&gt; <br>&gt;&gt; On Mon, Dec 7, 2015, at 01:07 PM, Dmitri Gribenko via swift-evolution<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; Another concern of mine is the equivalent of C-style for loops with<br>&gt;&gt;&gt; &#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>&gt;&gt;&gt; can think of duplicates the increment portion of the loop.<br>&gt;&gt; <br>&gt;&gt; As has been pointed out in other threads on this topic, you can use a<br>&gt;&gt; defer statement to avoid duplicating the increment portion:<br>&gt;&gt; <br>&gt;&gt; var i = initial<br>&gt;&gt; while cond(i) {<br>&gt;&gt;   defer { i = increment(i) }<br>&gt;&gt;   // ...<br>&gt;&gt;   if frob {<br>&gt;&gt;       continue // defer will execute<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt; <br>&gt; Which is a dangerous substitute, because it also does the wrong thing with break and throw:<br>&gt; <br>&gt; 	var i = initial<br>&gt; 	while cond(i) {<br>&gt; 		defer { i = increment(i) }<br>&gt; 		// ...<br>&gt; 		if frob {<br>&gt; 			continue // defer will execute<br>&gt; 		} else if blob {<br>&gt; 			break // defer will execute!!!<br>&gt; 		} else if plob {<br>&gt; 			throw MyError // defer will execute!!!<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Michel Fortin<br>&gt; michel.fortin at michelf.ca &lt;mailto:michel.fortin at michelf.ca&gt;<br>&gt; https://michelf.ca &lt;https://michelf.ca/&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/fd7c243c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8a24682926961206ad452d8455b09457?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>thorsten at portableinnovations.de</string> &lt;thorsten at portableinnovations.de&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>As the removal of the c-style for-loop is supposed to make things easier to understand I&#39;m a bit worried about the replacements for corner cases of the c-style for-loop.<br></p><p>Defer is simply wrong and dangerous and putting the increment into the condition is even uglier than the c-style for-loop ðŸ˜•<br></p><p>Because of that I&#39;d like to repeat my proposal of a modernized syntax for the c-style for-loop which gets rid of the c-style and might be preferable for those corner cases.<br></p><p>for var i=0 while i &lt; limit next i += 1 { ... }<br></p><p>together with its companion<br></p><p>for var i=0 until i == limit next i += 1 { ... }<br></p><p>-Thorsten<br></p><p>&gt; Am 08.12.2015 um 03:04 schrieb Kevin Lundberg via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; For throw, if incrementing i has no external side effects, then there shouldnâ€™t be any issue since i will be thrown away anyways when the error is thrown. <br>&gt; <br>&gt; For break, it can be considered dangerous, but if your while loops are written semantically like the old c-style for loop, the counter shouldnâ€™t be used outside the scope of the loop anyways. If that matters to whomever may write code like this, then manual incrementing at each point where loop scope breaks is necessary (though I imagine such cases are likely rare).<br>&gt; --<br>&gt; Kevin Lundberg<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 8:58 PM, Michel Fortin via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Le 7 dÃ©c. 2015 Ã  20:29, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; a Ã©crit :<br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Dec 7, 2015, at 01:07 PM, Dmitri Gribenko via swift-evolution<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Another concern of mine is the equivalent of C-style for loops with<br>&gt;&gt;&gt;&gt; &#39;continue&#39; statements in them.  The only equivalent based on &#39;while&#39; I<br>&gt;&gt;&gt;&gt; can think of duplicates the increment portion of the loop.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As has been pointed out in other threads on this topic, you can use a<br>&gt;&gt;&gt; defer statement to avoid duplicating the increment portion:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var i = initial<br>&gt;&gt;&gt; while cond(i) {<br>&gt;&gt;&gt;   defer { i = increment(i) }<br>&gt;&gt;&gt;   // ...<br>&gt;&gt;&gt;   if frob {<br>&gt;&gt;&gt;       continue // defer will execute<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Which is a dangerous substitute, because it also does the wrong thing with break and throw:<br>&gt;&gt; <br>&gt;&gt; 	var i = initial<br>&gt;&gt; 	while cond(i) {<br>&gt;&gt; 		defer { i = increment(i) }<br>&gt;&gt; 		// ...<br>&gt;&gt; 		if frob {<br>&gt;&gt; 			continue // defer will execute<br>&gt;&gt; 		} else if blob {<br>&gt;&gt; 			break // defer will execute!!!<br>&gt;&gt; 		} else if plob {<br>&gt;&gt; 			throw MyError // defer will execute!!!<br>&gt;&gt; 		}<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Michel Fortin<br>&gt;&gt; michel.fortin at michelf.ca<br>&gt;&gt; https://michelf.ca<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/339b5a65/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>December  8, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 7, 2015, at 5:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; var i = initial<br>&gt; while cond(i) {<br>&gt;    defer { i = increment(i) }<br></p><p>Strange. Can the compiler optimizer handle that efficiently?<br></p><p><br>&gt; Michel Fortin wrote:<br>&gt; <br>&gt; var i = 0<br>&gt; var first = true<br>&gt; while ({ () -&gt; Bool in if first { first = false } else { i = increment(i) }; return cond(i) }()) {<br>&gt; }<br></p><p>I fear that teaching the C-style for loop is easier than teaching that.<br></p><p><br>The C-style for loop has the great advantage that it can express a large number of loop constructs concisely. Most or all of the loop logic is collected in one place. It is also familiar to many developers via other languages.<br></p><p>Proposal:<br>1. Keep the C-style for loop.<br>2. Discourage use of the C-style for loop in simple cases with a compiler warning and fix-it to a for..in loop. This would be analogous to the existing warning of &quot;variable was never mutated; consider changing to &#39;let&#39; constant&quot;.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Review for: Remove C-style for-loops with conditions and incrementers</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; Le 9 dÃ©c. 2015 Ã  2:04, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; a Ã©crit :<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 5:29 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; var i = initial<br>&gt;&gt; while cond(i) {<br>&gt;&gt;   defer { i = increment(i) }<br>&gt; <br>&gt; Strange. Can the compiler optimizer handle that efficiently?<br>&gt; <br>&gt; <br>&gt;&gt; Michel Fortin wrote:<br>&gt;&gt; <br>&gt;&gt; var i = 0<br>&gt;&gt; var first = true<br>&gt;&gt; while ({ () -&gt; Bool in if first { first = false } else { i = increment(i) }; return cond(i) }()) {<br>&gt;&gt; }<br>&gt; <br>&gt; I fear that teaching the C-style for loop is easier than teaching that.<br></p><p>True. But if the C-style for loop was not part of the language, would you feel obligated to teach an equivalent like the above?<br></p><p>Here&#39;s another idea though. We could have a while loop that looks like this:<br></p><p>	var i = 0<br>	while i &lt; 5 reloop i += 1 {<br>	}<br></p><p>The reloop part would be executed upon reaching the end of the loop block, or whenever a continue is encountered: always just before reevaluating the condition. Unlike defer, the reloop part does not execute on break, return or throw.<br></p><p>It works just like a C-style for loop, minus the oddity regarding the scope of the loop variable.<br></p><p><br>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
