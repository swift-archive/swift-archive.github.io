<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/103be3d621a18672689c11b23568b38a?s=50"></div><header><strong>Class scoped access level</strong> from <string>Tom Bates</string> &lt;tbatesuk at gmail.com&gt;<p>September  9, 2016 at 03:00:00pm</p></header><div class="content"><p>There is currently no way of accessing &quot;shared code&quot; from extensions<br>declared outside the base .swift file<br></p><p>I would love to see along side the new fileprivate access level a<br>classprivate access level that would allow any extension declared outside<br>of the original .swift file to access these properties and functions in an<br>attempt to reuse code.<br></p><p>an example is below...<br></p><p>=================<br>//MyClass.swift<br>public class MyClass {<br></p><p>classprivate func sharedFunction() {<br>  self.function1()<br>  self.function2()<br>}<br></p><p>fileprivate func function1() {}<br>fileprivate func function2() {}<br>}<br>=================<br></p><p>=================<br>//MyClass+Save.swift<br>extension MyClass {<br></p><p>public func save() {<br>  self.someFunction()<br>  self.sharedFunction()<br>}<br></p><p>fileprivate func someFunction() {}<br>}<br>=================<br></p><p>Currently to achieve anything like this you would have to make the &quot;core&quot;<br>functions public or internal or write the whole thing in a single file<br>which as I understand it is not optimal for the compile speed and can get<br>unmanageable for large classes. This would allow a more managed file<br>structure and the separation of related functions from the core declaration.<br></p><p>There would be no migration needed I don&#39;t think as the impact on current<br>code would be zero until the developer adopts the new access level<br></p><p>Regards,<br>Tom<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/e732f8bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Class scoped access level</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September  9, 2016 at 06:00:00pm</p></header><div class="content"><p>There must be a better solution to this problem, because you might also extend value types from different files. That would mean, we&#39;d need `structprivate` `protocolprivate` etc. <br></p><p>How about: `internal(class)` etc. ? Or something like `internal(private)` to rule them all (I don&#39;t like the last name, but something that would rule them all would be nice to have)! <br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail <br></p><p>Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) schrieb:<br></p><p>&gt; <br>&gt; There is currently no way of accessing &quot;shared code&quot; from extensions declared outside the base .swift file<br>&gt; <br>&gt; I would love to see along side the new fileprivate access level a classprivate access level that would allow any extension declared outside of the original .swift file to access these properties and functions in an attempt to reuse code. <br>&gt; <br>&gt; an example is below...<br>&gt; <br>&gt; =================<br>&gt; //MyClass.swift<br>&gt; public class MyClass {<br>&gt; <br>&gt; classprivate func sharedFunction() {<br>&gt; self.function1()<br>&gt; self.function2()<br>&gt; }<br>&gt; <br>&gt; fileprivate func function1() {}<br>&gt; fileprivate func function2() {}<br>&gt; }<br>&gt; =================<br>&gt; <br>&gt; =================<br>&gt; //MyClass+Save.swift<br>&gt; extension MyClass {<br>&gt; <br>&gt; public func save() {<br>&gt; self.someFunction()<br>&gt; self.sharedFunction()<br>&gt; }<br>&gt; <br>&gt; fileprivate func someFunction() {}<br>&gt; } <br>&gt; =================<br>&gt; <br>&gt; Currently to achieve anything like this you would have to make the &quot;core&quot; functions public or internal or write the whole thing in a single file which as I understand it is not optimal for the compile speed and can get unmanageable for large classes. This would allow a more managed file structure and the separation of related functions from the core declaration. <br>&gt; <br>&gt; There would be no migration needed I don&#39;t think as the impact on current code would be zero until the developer adopts the new access level <br>&gt; <br>&gt; Regards, <br>&gt; Tom<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/403f2803/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Class scoped access level</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Isn&#39;t the general solution to this problem submodules? In any case, seems<br>like it&#39;d be out of scope for Swift 4 phase 1.<br></p><p><br>On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There must be a better solution to this problem, because you might also<br>&gt; extend value types from different files. That would mean, we&#39;d need<br>&gt; `structprivate` `protocolprivate` etc.<br>&gt;<br>&gt; How about: `internal(class)` etc. ? Or something like `internal(private)`<br>&gt; to rule them all (I don&#39;t like the last name, but something that would rule<br>&gt; them all would be nice to have)!<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt;&gt; declared outside the base .swift file<br>&gt;&gt;<br>&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt;&gt; classprivate access level that would allow any extension declared outside<br>&gt;&gt; of the original .swift file to access these properties and functions in an<br>&gt;&gt; attempt to reuse code.<br>&gt;&gt;<br>&gt;&gt; an example is below...<br>&gt;&gt;<br>&gt;&gt; =================<br>&gt;&gt; //MyClass.swift<br>&gt;&gt; public class MyClass {<br>&gt;&gt;<br>&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;   self.function1()<br>&gt;&gt;   self.function2()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; fileprivate func function1() {}<br>&gt;&gt; fileprivate func function2() {}<br>&gt;&gt; }<br>&gt;&gt; =================<br>&gt;&gt;<br>&gt;&gt; =================<br>&gt;&gt; //MyClass+Save.swift<br>&gt;&gt; extension MyClass {<br>&gt;&gt;<br>&gt;&gt; public func save() {<br>&gt;&gt;   self.someFunction()<br>&gt;&gt;   self.sharedFunction()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt; }<br>&gt;&gt; =================<br>&gt;&gt;<br>&gt;&gt; Currently to achieve anything like this you would have to make the &quot;core&quot;<br>&gt;&gt; functions public or internal or write the whole thing in a single file<br>&gt;&gt; which as I understand it is not optimal for the compile speed and can get<br>&gt;&gt; unmanageable for large classes. This would allow a more managed file<br>&gt;&gt; structure and the separation of related functions from the core declaration.<br>&gt;&gt;<br>&gt;&gt; There would be no migration needed I don&#39;t think as the impact on current<br>&gt;&gt; code would be zero until the developer adopts the new access level<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt; Tom<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160909/a3578e6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Class scoped access level</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 10, 2016 at 08:00:00am</p></header><div class="content"><p>I don&#39;t think submodules would solve it nicely. Each module/submodule will require it&#39;s own namespace + it feels like an overkill to create submodules for a few types. `internal(xyz)` seems to me like a better solution. And yes this is purely additional and nothing for phase 1. <br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail <br></p><p>Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com(mailto:xiaodi.wu at gmail.com)) schrieb:<br></p><p>&gt; <br>&gt; Isn&#39;t the general solution to this problem submodules? In any case, seems like it&#39;d be out of scope for Swift 4 phase 1. <br>&gt; <br>&gt; <br>&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt; wrote:<br>&gt; &gt; There must be a better solution to this problem, because you might also extend value types from different files. That would mean, we&#39;d need `structprivate` `protocolprivate` etc. <br>&gt; &gt; <br>&gt; &gt; How about: `internal(class)` etc. ? Or something like `internal(private)` to rule them all (I don&#39;t like the last name, but something that would rule them all would be nice to have)! <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; -- <br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail <br>&gt; &gt; <br>&gt; &gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (swift-evolution at swift.org(mailto:swift-evolution at swift.org)) schrieb:<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; There is currently no way of accessing &quot;shared code&quot; from extensions declared outside the base .swift file<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; I would love to see along side the new fileprivate access level a classprivate access level that would allow any extension declared outside of the original .swift file to access these properties and functions in an attempt to reuse code. <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; an example is below...<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; =================<br>&gt; &gt; &gt; //MyClass.swift<br>&gt; &gt; &gt; public class MyClass {<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; classprivate func sharedFunction() {<br>&gt; &gt; &gt; self.function1()<br>&gt; &gt; &gt; self.function2()<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; fileprivate func function1() {}<br>&gt; &gt; &gt; fileprivate func function2() {}<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; =================<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; =================<br>&gt; &gt; &gt; //MyClass+Save.swift<br>&gt; &gt; &gt; extension MyClass {<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; public func save() {<br>&gt; &gt; &gt; self.someFunction()<br>&gt; &gt; &gt; self.sharedFunction()<br>&gt; &gt; &gt; }<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; fileprivate func someFunction() {}<br>&gt; &gt; &gt; } <br>&gt; &gt; &gt; =================<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Currently to achieve anything like this you would have to make the &quot;core&quot; functions public or internal or write the whole thing in a single file which as I understand it is not optimal for the compile speed and can get unmanageable for large classes. This would allow a more managed file structure and the separation of related functions from the core declaration. <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; There would be no migration needed I don&#39;t think as the impact on current code would be zero until the developer adopts the new access level <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Regards, <br>&gt; &gt; &gt; Tom<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/caf179c2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/103be3d621a18672689c11b23568b38a?s=50"></div><header><strong>Class scoped access level</strong> from <string>Tom Bates</string> &lt;tbatesuk at gmail.com&gt;<p>September 10, 2016 at 09:00:00am</p></header><div class="content"><p>I agree that classprivate would probably not work, maybe constructprivate?<br>but then you are leaving our enum etc.<br>With the `internal(class)` suggestion, if declaring a var such as `<br>internal(set) var name: String?` would this become `internal(class, set) var<br> name: String?`<br>Also there would need to be some kind of compile check either way because<br>if you declared an enum for example outside of a constructor you would not<br>be able to mark it as our new constructor only access level or it would<br>become inaccessible throughout the project.<br></p><p>Re: submodules, they are indeed overkill for this. As you would need a<br>separate submodule for each class you wanted to do this with and then run<br>the risk of inter coupling lots of different really small submodules.<br></p><p>Suggestions so far:<br>`classprivate`<br>`constructprivate`<br>`private(instance)`, `private(instance, set)` - problem -&gt; how would this<br>work? `public private(instance, set)`<br>`internal(class)`<br></p><p>Personally I think a name like `classprivate` or `constructprivate`,<br>although not particularly well named would reduce complexities with private<br>setters syntax and keep migrations much simpler.<br></p><p><br>On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t think submodules would solve it nicely. Each module/submodule will<br>&gt; require it&#39;s own namespace + it feels like an overkill to create submodules<br>&gt; for a few types. `internal(xyz)` seems to me like a better solution. And<br>&gt; yes this is purely additional and nothing for phase 1.<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com) schrieb:<br>&gt;<br>&gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case, seems<br>&gt;&gt; like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; There must be a better solution to this problem, because you might also<br>&gt;&gt;&gt; extend value types from different files. That would mean, we&#39;d need<br>&gt;&gt;&gt; `structprivate` `protocolprivate` etc.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; How about: `internal(class)` etc. ? Or something like<br>&gt;&gt;&gt; `internal(private)` to rule them all (I don&#39;t like the last name, but<br>&gt;&gt;&gt; something that would rule them all would be nice to have)!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt;&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt;&gt;&gt;&gt; declared outside the base .swift file<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt;&gt;&gt;&gt; classprivate access level that would allow any extension declared outside<br>&gt;&gt;&gt;&gt; of the original .swift file to access these properties and functions in an<br>&gt;&gt;&gt;&gt; attempt to reuse code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; an example is below...<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt; //MyClass.swift<br>&gt;&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;&gt;&gt;   self.function1()<br>&gt;&gt;&gt;&gt;   self.function2()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; public func save() {<br>&gt;&gt;&gt;&gt;   self.someFunction()<br>&gt;&gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Currently to achieve anything like this you would have to make the<br>&gt;&gt;&gt;&gt; &quot;core&quot; functions public or internal or write the whole thing in a single<br>&gt;&gt;&gt;&gt; file which as I understand it is not optimal for the compile speed and can<br>&gt;&gt;&gt;&gt; get unmanageable for large classes. This would allow a more managed file<br>&gt;&gt;&gt;&gt; structure and the separation of related functions from the core declaration.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on<br>&gt;&gt;&gt;&gt; current code would be zero until the developer adopts the new access level<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt; Tom<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/0676b243/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Class scoped access level</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>September 10, 2016 at 08:00:00am</p></header><div class="content"><p>I am firmly against this. The 5 levels that we have cover us well and have<br>enough complexity already.<br></p><p>On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree that classprivate would probably not work, maybe constructprivate?<br>&gt; but then you are leaving our enum etc.<br>&gt; With the `internal(class)` suggestion, if declaring a var such as `<br>&gt; internal(set) var name: String?` would this become `internal(class, set)<br>&gt; var name: String?`<br>&gt; Also there would need to be some kind of compile check either way because<br>&gt; if you declared an enum for example outside of a constructor you would not<br>&gt; be able to mark it as our new constructor only access level or it would<br>&gt; become inaccessible throughout the project.<br>&gt;<br>&gt; Re: submodules, they are indeed overkill for this. As you would need a<br>&gt; separate submodule for each class you wanted to do this with and then run<br>&gt; the risk of inter coupling lots of different really small submodules.<br>&gt;<br>&gt; Suggestions so far:<br>&gt; `classprivate`<br>&gt; `constructprivate`<br>&gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would this<br>&gt; work? `public private(instance, set)`<br>&gt; `internal(class)`<br>&gt;<br>&gt; Personally I think a name like `classprivate` or `constructprivate`,<br>&gt; although not particularly well named would reduce complexities with private<br>&gt; setters syntax and keep migrations much simpler.<br>&gt;<br>&gt;<br>&gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I don&#39;t think submodules would solve it nicely. Each module/submodule<br>&gt;&gt; will require it&#39;s own namespace + it feels like an overkill to create<br>&gt;&gt; submodules for a few types. `internal(xyz)` seems to me like a better<br>&gt;&gt; solution. And yes this is purely additional and nothing for phase 1.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt;<br>&gt;&gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com)<br>&gt;&gt; schrieb:<br>&gt;&gt;<br>&gt;&gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case,<br>&gt;&gt;&gt; seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; There must be a better solution to this problem, because you might also<br>&gt;&gt;&gt;&gt; extend value types from different files. That would mean, we&#39;d need<br>&gt;&gt;&gt;&gt; `structprivate` `protocolprivate` etc.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; How about: `internal(class)` etc. ? Or something like<br>&gt;&gt;&gt;&gt; `internal(private)` to rule them all (I don&#39;t like the last name, but<br>&gt;&gt;&gt;&gt; something that would rule them all would be nice to have)!<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt;&gt;&gt;&gt;&gt; declared outside the base .swift file<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt;&gt;&gt;&gt;&gt; classprivate access level that would allow any extension declared outside<br>&gt;&gt;&gt;&gt;&gt; of the original .swift file to access these properties and functions in an<br>&gt;&gt;&gt;&gt;&gt; attempt to reuse code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; an example is below...<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt; //MyClass.swift<br>&gt;&gt;&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;&gt;&gt;&gt;   self.function1()<br>&gt;&gt;&gt;&gt;&gt;   self.function2()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt;&gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt;&gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; public func save() {<br>&gt;&gt;&gt;&gt;&gt;   self.someFunction()<br>&gt;&gt;&gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Currently to achieve anything like this you would have to make the<br>&gt;&gt;&gt;&gt;&gt; &quot;core&quot; functions public or internal or write the whole thing in a single<br>&gt;&gt;&gt;&gt;&gt; file which as I understand it is not optimal for the compile speed and can<br>&gt;&gt;&gt;&gt;&gt; get unmanageable for large classes. This would allow a more managed file<br>&gt;&gt;&gt;&gt;&gt; structure and the separation of related functions from the core declaration.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on<br>&gt;&gt;&gt;&gt;&gt; current code would be zero until the developer adopts the new access level<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt; Tom<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/c42d8529/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Class scoped access level</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>September 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 10 Sep 2016, at 14:16, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am firmly against this. The 5 levels that we have cover us well and have enough complexity already.<br></p><p>You can say that again! It seems the compiler has become much stricter about it very recently.<br></p><p>I was recently writing a Tab-bar UIViewcontroller and because I like to keep my internal API clean, I’ve had to stick 4 massive related classes and various extensions in the same file. It’s an unreadable, unmaintainable nightmare.<br>I would support abolishing the ‘fileprivate’ level for some kind of more loosely-defined virtual scope, such as friend classes or submodules.<br></p><p>OP is correct that Swift is currently incongruous - on the one hand, we have extensions allowing you to break up definitions in to relatable groups, and on the other hand we force you to jam everything in to one file if you want a clean internal API. It feels like they are pulling in opposite directions.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Class scoped access level</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 10, 2016 at 01:00:00pm</p></header><div class="content"><p>I am not fully sure all of this was worth it over protected, private, public... we will see ;).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 10 Sep 2016, at 13:16, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am firmly against this. The 5 levels that we have cover us well and have enough complexity already.<br>&gt; <br>&gt;&gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I agree that classprivate would probably not work, maybe constructprivate? but then you are leaving our enum etc.<br>&gt;&gt; With the `internal(class)` suggestion, if declaring a var such as `internal(set) var name: String?` would this become `internal(class, set) var name: String?`<br>&gt;&gt; Also there would need to be some kind of compile check either way because if you declared an enum for example outside of a constructor you would not be able to mark it as our new constructor only access level or it would become inaccessible throughout the project.<br>&gt;&gt; <br>&gt;&gt; Re: submodules, they are indeed overkill for this. As you would need a separate submodule for each class you wanted to do this with and then run the risk of inter coupling lots of different really small submodules.<br>&gt;&gt; <br>&gt;&gt; Suggestions so far:<br>&gt;&gt; `classprivate`<br>&gt;&gt; `constructprivate`<br>&gt;&gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would this work? `public private(instance, set)`<br>&gt;&gt; `internal(class)`<br>&gt;&gt; <br>&gt;&gt; Personally I think a name like `classprivate` or `constructprivate`, although not particularly well named would reduce complexities with private setters syntax and keep migrations much simpler.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I don&#39;t think submodules would solve it nicely. Each module/submodule will require it&#39;s own namespace + it feels like an overkill to create submodules for a few types. `internal(xyz)` seems to me like a better solution. And yes this is purely additional and nothing for phase 1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case, seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; There must be a better solution to this problem, because you might also extend value types from different files. That would mean, we&#39;d need `structprivate` `protocolprivate` etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; How about: `internal(class)` etc. ? Or something like `internal(private)` to rule them all (I don&#39;t like the last name, but something that would rule them all would be nice to have)!<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions declared outside the base .swift file<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I would love to see along side the new fileprivate access level a classprivate access level that would allow any extension declared outside of the original .swift file to access these properties and functions in an attempt to reuse code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; an example is below...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt; //MyClass.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.function1()<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.function2()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public func save() {<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.someFunction()<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently to achieve anything like this you would have to make the &quot;core&quot; functions public or internal or write the whole thing in a single file which as I understand it is not optimal for the compile speed and can get unmanageable for large classes. This would allow a more managed file structure and the separation of related functions from the core declaration.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on current code would be zero until the developer adopts the new access level<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; Tom<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/6f940441/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/103be3d621a18672689c11b23568b38a?s=50"></div><header><strong>Class scoped access level</strong> from <string>Tom Bates</string> &lt;tbatesuk at gmail.com&gt;<p>September 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Reading between the line of what T.J has said I can see he is keen to see<br>this become reality!<br></p><p>It is very easy to come across examples where the current access level do<br>NOT work well and are inhibiting clean, readable code. Which, in my<br>opinion, when considering any kind of scale is probably the most important<br>thing to be able to maintain, extend and ultimately reduce bugs.<br></p><p>I agree that the obvious concern would be complexity.<br>One solution that would eliminate any extra complexity would be to allow<br>extensions to access all private variables and functions from it&#39;s initial<br>declaration.<br>This would only be the case when the extension&#39;s declaration is within the<br>defining module (prevents people accessing private variables when using<br>submodules)<br>To restrict access to extensions of the class you would use the<br>`fileprivate` access control.<br>If you want access to a var or func outside the defining module then it has<br>to be public as is the case now.<br></p><p>Again, this would require no migrations to existing code that I can see.<br></p><p><br>On Sat, 10 Sep 2016 at 13:17 T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; I am firmly against this. The 5 levels that we have cover us well and have<br>&gt; enough complexity already.<br>&gt;<br>&gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree that classprivate would probably not work, maybe<br>&gt;&gt; constructprivate? but then you are leaving our enum etc.<br>&gt;&gt; With the `internal(class)` suggestion, if declaring a var such as `<br>&gt;&gt; internal(set) var name: String?` would this become `internal(class, set)<br>&gt;&gt; var name: String?`<br>&gt;&gt; Also there would need to be some kind of compile check either way because<br>&gt;&gt; if you declared an enum for example outside of a constructor you would not<br>&gt;&gt; be able to mark it as our new constructor only access level or it would<br>&gt;&gt; become inaccessible throughout the project.<br>&gt;&gt;<br>&gt;&gt; Re: submodules, they are indeed overkill for this. As you would need a<br>&gt;&gt; separate submodule for each class you wanted to do this with and then run<br>&gt;&gt; the risk of inter coupling lots of different really small submodules.<br>&gt;&gt;<br>&gt;&gt; Suggestions so far:<br>&gt;&gt; `classprivate`<br>&gt;&gt; `constructprivate`<br>&gt;&gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would this<br>&gt;&gt; work? `public private(instance, set)`<br>&gt;&gt; `internal(class)`<br>&gt;&gt;<br>&gt;&gt; Personally I think a name like `classprivate` or `constructprivate`,<br>&gt;&gt; although not particularly well named would reduce complexities with private<br>&gt;&gt; setters syntax and keep migrations much simpler.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think submodules would solve it nicely. Each module/submodule<br>&gt;&gt;&gt; will require it&#39;s own namespace + it feels like an overkill to create<br>&gt;&gt;&gt; submodules for a few types. `internal(xyz)` seems to me like a better<br>&gt;&gt;&gt; solution. And yes this is purely additional and nothing for phase 1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com)<br>&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case,<br>&gt;&gt;&gt;&gt; seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; There must be a better solution to this problem, because you might<br>&gt;&gt;&gt;&gt;&gt; also extend value types from different files. That would mean, we&#39;d need<br>&gt;&gt;&gt;&gt;&gt; `structprivate` `protocolprivate` etc.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; How about: `internal(class)` etc. ? Or something like<br>&gt;&gt;&gt;&gt;&gt; `internal(private)` to rule them all (I don&#39;t like the last name, but<br>&gt;&gt;&gt;&gt;&gt; something that would rule them all would be nice to have)!<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt;&gt;&gt;&gt;&gt;&gt; declared outside the base .swift file<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt;&gt;&gt;&gt;&gt;&gt; classprivate access level that would allow any extension declared outside<br>&gt;&gt;&gt;&gt;&gt;&gt; of the original .swift file to access these properties and functions in an<br>&gt;&gt;&gt;&gt;&gt;&gt; attempt to reuse code.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; an example is below...<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt; //MyClass.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.function1()<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.function2()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; public func save() {<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.someFunction()<br>&gt;&gt;&gt;&gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; =================<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Currently to achieve anything like this you would have to make the<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;core&quot; functions public or internal or write the whole thing in a single<br>&gt;&gt;&gt;&gt;&gt;&gt; file which as I understand it is not optimal for the compile speed and can<br>&gt;&gt;&gt;&gt;&gt;&gt; get unmanageable for large classes. This would allow a more managed file<br>&gt;&gt;&gt;&gt;&gt;&gt; structure and the separation of related functions from the core declaration.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on<br>&gt;&gt;&gt;&gt;&gt;&gt; current code would be zero until the developer adopts the new access level<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; Tom<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/3afac8b3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>Class scoped access level</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>September 10, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 10 Sep 2016, at 14:16, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I am firmly against this. The 5 levels that we have cover us well and have enough complexity already.<br></p><p>Agree.<br></p><p><br></p><p>&gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I agree that classprivate would probably not work, maybe constructprivate? but then you are leaving our enum etc.<br>&gt; With the `internal(class)` suggestion, if declaring a var such as `internal(set) var name: String?` would this become `internal(class, set) var name: String?`<br>&gt; Also there would need to be some kind of compile check either way because if you declared an enum for example outside of a constructor you would not be able to mark it as our new constructor only access level or it would become inaccessible throughout the project.<br>&gt; <br>&gt; Re: submodules, they are indeed overkill for this. As you would need a separate submodule for each class you wanted to do this with and then run the risk of inter coupling lots of different really small submodules.<br>&gt; <br>&gt; Suggestions so far:<br>&gt; `classprivate`<br>&gt; `constructprivate`<br>&gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would this work? `public private(instance, set)`<br>&gt; `internal(class)`<br>&gt; <br>&gt; Personally I think a name like `classprivate` or `constructprivate`, although not particularly well named would reduce complexities with private setters syntax and keep migrations much simpler.<br>&gt; <br>&gt; <br>&gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I don&#39;t think submodules would solve it nicely. Each module/submodule will require it&#39;s own namespace + it feels like an overkill to create submodules for a few types. `internal(xyz)` seems to me like a better solution. And yes this is purely additional and nothing for phase 1.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com) schrieb:<br>&gt; <br>&gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case, seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; There must be a better solution to this problem, because you might also extend value types from different files. That would mean, we&#39;d need `structprivate` `protocolprivate` etc.<br>&gt;&gt; <br>&gt;&gt; How about: `internal(class)` etc. ? Or something like `internal(private)` to rule them all (I don&#39;t like the last name, but something that would rule them all would be nice to have)!<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (swift-evolution at swift.org) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions declared outside the base .swift file<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would love to see along side the new fileprivate access level a classprivate access level that would allow any extension declared outside of the original .swift file to access these properties and functions in an attempt to reuse code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; an example is below...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; =================<br>&gt;&gt;&gt; //MyClass.swift<br>&gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;&gt;   self.function1()<br>&gt;&gt;&gt;   self.function2()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; =================<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; =================<br>&gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func save() {<br>&gt;&gt;&gt;   self.someFunction()<br>&gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; =================<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently to achieve anything like this you would have to make the &quot;core&quot; functions public or internal or write the whole thing in a single file which as I understand it is not optimal for the compile speed and can get unmanageable for large classes. This would allow a more managed file structure and the separation of related functions from the core declaration.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on current code would be zero until the developer adopts the new access level<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; Tom<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Class scoped access level</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>September 10, 2016 at 10:00:00am</p></header><div class="content"><p>Indeed, I find it rather less convenient to write “fileprivate” in many<br>places I previously would use “private”, and unfortunate that I must choose<br>between aggregating many pieces into a single lengthy file or else<br>polluting the module scope with implementation details.<br></p><p>I agree with Xiaodi that submodules are a far cleaner design, and I would<br>very much like to replace “fileprivate” with a short word that implies<br>“private to the submodule”. Then by default each file could be its own<br>submodule, and a developer could opt into having more files in a submodule<br>if they so desire.<br></p><p>Count me as opposed to any sort of “class scoped” access level.<br></p><p>Nevin<br></p><p><br></p><p>On Sat, Sep 10, 2016 at 10:01 AM, Rien via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On 10 Sep 2016, at 14:16, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I am firmly against this. The 5 levels that we have cover us well and<br>&gt; have enough complexity already.<br>&gt;<br>&gt; Agree.<br>&gt;<br>&gt;<br>&gt;<br>&gt; &gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I agree that classprivate would probably not work, maybe<br>&gt; constructprivate? but then you are leaving our enum etc.<br>&gt; &gt; With the `internal(class)` suggestion, if declaring a var such as<br>&gt; `internal(set) var name: String?` would this become `internal(class, set)<br>&gt; var name: String?`<br>&gt; &gt; Also there would need to be some kind of compile check either way<br>&gt; because if you declared an enum for example outside of a constructor you<br>&gt; would not be able to mark it as our new constructor only access level or it<br>&gt; would become inaccessible throughout the project.<br>&gt; &gt;<br>&gt; &gt; Re: submodules, they are indeed overkill for this. As you would need a<br>&gt; separate submodule for each class you wanted to do this with and then run<br>&gt; the risk of inter coupling lots of different really small submodules.<br>&gt; &gt;<br>&gt; &gt; Suggestions so far:<br>&gt; &gt; `classprivate`<br>&gt; &gt; `constructprivate`<br>&gt; &gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would<br>&gt; this work? `public private(instance, set)`<br>&gt; &gt; `internal(class)`<br>&gt; &gt;<br>&gt; &gt; Personally I think a name like `classprivate` or `constructprivate`,<br>&gt; although not particularly well named would reduce complexities with private<br>&gt; setters syntax and keep migrations much simpler.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; I don&#39;t think submodules would solve it nicely. Each module/submodule<br>&gt; will require it&#39;s own namespace + it feels like an overkill to create<br>&gt; submodules for a few types. `internal(xyz)` seems to me like a better<br>&gt; solution. And yes this is purely additional and nothing for phase 1.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com)<br>&gt; schrieb:<br>&gt; &gt;<br>&gt; &gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case,<br>&gt; seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; There must be a better solution to this problem, because you might also<br>&gt; extend value types from different files. That would mean, we&#39;d need<br>&gt; `structprivate` `protocolprivate` etc.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; How about: `internal(class)` etc. ? Or something like<br>&gt; `internal(private)` to rule them all (I don&#39;t like the last name, but<br>&gt; something that would rule them all would be nice to have)!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Adrian Zubarev<br>&gt; &gt;&gt; Sent with Airmail<br>&gt; &gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt; declared outside the base .swift file<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt; classprivate access level that would allow any extension declared outside<br>&gt; of the original .swift file to access these properties and functions in an<br>&gt; attempt to reuse code.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; an example is below...<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt; //MyClass.swift<br>&gt; &gt;&gt;&gt; public class MyClass {<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt; &gt;&gt;&gt;   self.function1()<br>&gt; &gt;&gt;&gt;   self.function2()<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate func function1() {}<br>&gt; &gt;&gt;&gt; fileprivate func function2() {}<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt; //MyClass+Save.swift<br>&gt; &gt;&gt;&gt; extension MyClass {<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public func save() {<br>&gt; &gt;&gt;&gt;   self.someFunction()<br>&gt; &gt;&gt;&gt;   self.sharedFunction()<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Currently to achieve anything like this you would have to make the<br>&gt; &quot;core&quot; functions public or internal or write the whole thing in a single<br>&gt; file which as I understand it is not optimal for the compile speed and can<br>&gt; get unmanageable for large classes. This would allow a more managed file<br>&gt; structure and the separation of related functions from the core declaration.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on<br>&gt; current code would be zero until the developer adopts the new access level<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Regards,<br>&gt; &gt;&gt;&gt; Tom<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/1f163bd1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Class scoped access level</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Agreed.<br></p><p>Swift&#39;s access levels are deliberately defined in terms of contiguous<br>blocks of written code [this is inelegantly phrased, but I think you see<br>what I mean]. As such, neither a &quot;class scoped&quot; level nor a level shared<br>between a type and its extensions would fit in such a scheme.<br></p><p>Such an addition would fundamentally counter the existing design of Swift,<br>open the door for compensating features such as &quot;friend classes&quot; that<br>(IIUC) were deliberately avoided, and fails to compose with existing access<br>levels as inevitably there will be proposals to do. By that I mean, why<br>should a &quot;class scoped&quot; member always be limited in visibility to the same<br>module? This satisfies your particular motivating use case, but someone<br>else will want the same kind of class scoping but also allow a member to be<br>accessed by extensions outside the module (classpublic, if you will); still<br>others will want a member to be overridable outside the module (classopen);<br>for good measure, some will want access limited to only extensions and not<br>other types in the same file (classfileprivate; it is not out of the<br>question for someone to raise this point, since it is a close cousin of the<br>argument for distinguishing private and fileprivate).<br></p><p>If I had my druthers, it&#39;d be nice to have exactly something like Nevin&#39;s<br>idea, a terse way to group related files into submodules, and a keyword<br>like `subinternal` that restricts visibility to that group of files. It<br>would satisfy the motivating use case here while preserving the deliberate<br>design decision that Swift access levels do not pick and choose<br>non-contiguous chunks of multiple files.<br></p><p>In any case, let&#39;s postpone this discussion until it comes into scope at a<br>later phase of Swift evolution. The core team and other experts would no<br>doubt have much to contribute at that time.<br></p><p><br>On Sat, Sep 10, 2016 at 09:31 Nevin Brackett-Rozinsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Indeed, I find it rather less convenient to write “fileprivate” in many<br>&gt; places I previously would use “private”, and unfortunate that I must choose<br>&gt; between aggregating many pieces into a single lengthy file or else<br>&gt; polluting the module scope with implementation details.<br>&gt;<br>&gt; I agree with Xiaodi that submodules are a far cleaner design, and I would<br>&gt; very much like to replace “fileprivate” with a short word that implies<br>&gt; “private to the submodule”. Then by default each file could be its own<br>&gt; submodule, and a developer could opt into having more files in a submodule<br>&gt; if they so desire.<br>&gt;<br>&gt; Count me as opposed to any sort of “class scoped” access level.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Sep 10, 2016 at 10:01 AM, Rien via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; On 10 Sep 2016, at 14:16, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I am firmly against this. The 5 levels that we have cover us well and<br>&gt;&gt; have enough complexity already.<br>&gt;&gt;<br>&gt;&gt; Agree.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I agree that classprivate would probably not work, maybe<br>&gt;&gt; constructprivate? but then you are leaving our enum etc.<br>&gt;&gt; &gt; With the `internal(class)` suggestion, if declaring a var such as<br>&gt;&gt; `internal(set) var name: String?` would this become `internal(class, set)<br>&gt;&gt; var name: String?`<br>&gt;&gt; &gt; Also there would need to be some kind of compile check either way<br>&gt;&gt; because if you declared an enum for example outside of a constructor you<br>&gt;&gt; would not be able to mark it as our new constructor only access level or it<br>&gt;&gt; would become inaccessible throughout the project.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Re: submodules, they are indeed overkill for this. As you would need a<br>&gt;&gt; separate submodule for each class you wanted to do this with and then run<br>&gt;&gt; the risk of inter coupling lots of different really small submodules.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Suggestions so far:<br>&gt;&gt; &gt; `classprivate`<br>&gt;&gt; &gt; `constructprivate`<br>&gt;&gt; &gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would<br>&gt;&gt; this work? `public private(instance, set)`<br>&gt;&gt; &gt; `internal(class)`<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Personally I think a name like `classprivate` or `constructprivate`,<br>&gt;&gt; although not particularly well named would reduce complexities with private<br>&gt;&gt; setters syntax and keep migrations much simpler.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; I don&#39;t think submodules would solve it nicely. Each module/submodule<br>&gt;&gt; will require it&#39;s own namespace + it feels like an overkill to create<br>&gt;&gt; submodules for a few types. `internal(xyz)` seems to me like a better<br>&gt;&gt; solution. And yes this is purely additional and nothing for phase 1.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Adrian Zubarev<br>&gt;&gt; &gt; Sent with Airmail<br>&gt;&gt; &gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com)<br>&gt;&gt; schrieb:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case,<br>&gt;&gt; seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; There must be a better solution to this problem, because you might<br>&gt;&gt; also extend value types from different files. That would mean, we&#39;d need<br>&gt;&gt; `structprivate` `protocolprivate` etc.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; How about: `internal(class)` etc. ? Or something like<br>&gt;&gt; `internal(private)` to rule them all (I don&#39;t like the last name, but<br>&gt;&gt; something that would rule them all would be nice to have)!<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Adrian Zubarev<br>&gt;&gt; &gt;&gt; Sent with Airmail<br>&gt;&gt; &gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt;&gt; declared outside the base .swift file<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt;&gt; classprivate access level that would allow any extension declared outside<br>&gt;&gt; of the original .swift file to access these properties and functions in an<br>&gt;&gt; attempt to reuse code.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; an example is below...<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt; &gt;&gt;&gt; //MyClass.swift<br>&gt;&gt; &gt;&gt;&gt; public class MyClass {<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt; &gt;&gt;&gt;   self.function1()<br>&gt;&gt; &gt;&gt;&gt;   self.function2()<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt; &gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt; &gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt; &gt;&gt;&gt; extension MyClass {<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; public func save() {<br>&gt;&gt; &gt;&gt;&gt;   self.someFunction()<br>&gt;&gt; &gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Currently to achieve anything like this you would have to make the<br>&gt;&gt; &quot;core&quot; functions public or internal or write the whole thing in a single<br>&gt;&gt; file which as I understand it is not optimal for the compile speed and can<br>&gt;&gt; get unmanageable for large classes. This would allow a more managed file<br>&gt;&gt; structure and the separation of related functions from the core declaration.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on<br>&gt;&gt; current code would be zero until the developer adopts the new access level<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; Regards,<br>&gt;&gt; &gt;&gt;&gt; Tom<br>&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/f4e58620/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Class scoped access level</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September 10, 2016 at 02:00:00pm</p></header><div class="content"><p>I do certainly agree that 5 access levels are _plenty_, C++ “friend” is no great friend to me, and I too not want to see another one access level added. However, I do think there’s a related problem here worth solving.<br></p><p>Sometimes, trying to break apart a large type using extensions, I encounter this pattern:<br></p><p>class Thingamer {<br>    private var doodads: [Doodad]<br></p><p>    // All of these use the doodads var:<br></p><p>    public func mangleDoodads() { … }<br>    public func fungeDoodads() { … }<br>    public func renoberateDoodads() { … }<br>    private func doodadHelper() { … }<br></p><p>    // …and no other methods touch it<br>}<br></p><p>My first instinct in this situation is to pull all the doodad-related stuff into a separate type, but sometimes that’s the wrong solution. Perhaps the public API gets messy or nonsensical if those public doodad-related methods aren’t on Thingamer. Perhaps other Thingamer methods use those doodad methods, even if they don’t use the private var. Perhaps there’s still coupling to Thingamer through other class properties. And so forth.<br></p><p>It would be great to group all the doodad-stuff into an extension. The inability of extensions to use class-private vars is the barrier. My usual solution is to make the doodads var internal, and then try to remember not to use it outside of the extension — which looks a lot like “fake friend”.<br></p><p>It would be nice if Swift extensions let us encapsulate state+behavior relationships without having to create new type boundaries.<br></p><p>IIRC, there was talk of extensions being able to add properties to an existing type. It seems like this would be feasible, at least for types within the same module? Perhaps there’s another better way?<br></p><p>Cheers,<br></p><p>Paul<br></p><p>&gt; On Sep 10, 2016, at 11:28 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Agreed.<br>&gt; <br>&gt; Swift&#39;s access levels are deliberately defined in terms of contiguous blocks of written code [this is inelegantly phrased, but I think you see what I mean]. As such, neither a &quot;class scoped&quot; level nor a level shared between a type and its extensions would fit in such a scheme.<br>&gt; <br>&gt; Such an addition would fundamentally counter the existing design of Swift, open the door for compensating features such as &quot;friend classes&quot; that (IIUC) were deliberately avoided, and fails to compose with existing access levels as inevitably there will be proposals to do. By that I mean, why should a &quot;class scoped&quot; member always be limited in visibility to the same module? This satisfies your particular motivating use case, but someone else will want the same kind of class scoping but also allow a member to be accessed by extensions outside the module (classpublic, if you will); still others will want a member to be overridable outside the module (classopen); for good measure, some will want access limited to only extensions and not other types in the same file (classfileprivate; it is not out of the question for someone to raise this point, since it is a close cousin of the argument for distinguishing private and fileprivate).<br>&gt; <br>&gt; If I had my druthers, it&#39;d be nice to have exactly something like Nevin&#39;s idea, a terse way to group related files into submodules, and a keyword like `subinternal` that restricts visibility to that group of files. It would satisfy the motivating use case here while preserving the deliberate design decision that Swift access levels do not pick and choose non-contiguous chunks of multiple files.<br>&gt; <br>&gt; In any case, let&#39;s postpone this discussion until it comes into scope at a later phase of Swift evolution. The core team and other experts would no doubt have much to contribute at that time.<br>&gt; <br>&gt; <br>&gt; On Sat, Sep 10, 2016 at 09:31 Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Indeed, I find it rather less convenient to write “fileprivate” in many places I previously would use “private”, and unfortunate that I must choose between aggregating many pieces into a single lengthy file or else polluting the module scope with implementation details.<br>&gt; <br>&gt; I agree with Xiaodi that submodules are a far cleaner design, and I would very much like to replace “fileprivate” with a short word that implies “private to the submodule”. Then by default each file could be its own submodule, and a developer could opt into having more files in a submodule if they so desire.<br>&gt; <br>&gt; Count me as opposed to any sort of “class scoped” access level.<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sat, Sep 10, 2016 at 10:01 AM, Rien via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; On 10 Sep 2016, at 14:16, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I am firmly against this. The 5 levels that we have cover us well and have enough complexity already.<br>&gt; <br>&gt; Agree.<br>&gt; <br>&gt; <br>&gt; <br>&gt; &gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I agree that classprivate would probably not work, maybe constructprivate? but then you are leaving our enum etc.<br>&gt; &gt; With the `internal(class)` suggestion, if declaring a var such as `internal(set) var name: String?` would this become `internal(class, set) var name: String?`<br>&gt; &gt; Also there would need to be some kind of compile check either way because if you declared an enum for example outside of a constructor you would not be able to mark it as our new constructor only access level or it would become inaccessible throughout the project.<br>&gt; &gt;<br>&gt; &gt; Re: submodules, they are indeed overkill for this. As you would need a separate submodule for each class you wanted to do this with and then run the risk of inter coupling lots of different really small submodules.<br>&gt; &gt;<br>&gt; &gt; Suggestions so far:<br>&gt; &gt; `classprivate`<br>&gt; &gt; `constructprivate`<br>&gt; &gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would this work? `public private(instance, set)`<br>&gt; &gt; `internal(class)`<br>&gt; &gt;<br>&gt; &gt; Personally I think a name like `classprivate` or `constructprivate`, although not particularly well named would reduce complexities with private setters syntax and keep migrations much simpler.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; I don&#39;t think submodules would solve it nicely. Each module/submodule will require it&#39;s own namespace + it feels like an overkill to create submodules for a few types. `internal(xyz)` seems to me like a better solution. And yes this is purely additional and nothing for phase 1.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Adrian Zubarev<br>&gt; &gt; Sent with Airmail<br>&gt; &gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;) schrieb:<br>&gt; &gt;<br>&gt; &gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case, seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt; There must be a better solution to this problem, because you might also extend value types from different files. That would mean, we&#39;d need `structprivate` `protocolprivate` etc.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; How about: `internal(class)` etc. ? Or something like `internal(private)` to rule them all (I don&#39;t like the last name, but something that would rule them all would be nice to have)!<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Adrian Zubarev<br>&gt; &gt;&gt; Sent with Airmail<br>&gt; &gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) schrieb:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions declared outside the base .swift file<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I would love to see along side the new fileprivate access level a classprivate access level that would allow any extension declared outside of the original .swift file to access these properties and functions in an attempt to reuse code.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; an example is below...<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt; //MyClass.swift<br>&gt; &gt;&gt;&gt; public class MyClass {<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt; &gt;&gt;&gt;   self.function1()<br>&gt; &gt;&gt;&gt;   self.function2()<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate func function1() {}<br>&gt; &gt;&gt;&gt; fileprivate func function2() {}<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt; //MyClass+Save.swift<br>&gt; &gt;&gt;&gt; extension MyClass {<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; public func save() {<br>&gt; &gt;&gt;&gt;   self.someFunction()<br>&gt; &gt;&gt;&gt;   self.sharedFunction()<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; =================<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Currently to achieve anything like this you would have to make the &quot;core&quot; functions public or internal or write the whole thing in a single file which as I understand it is not optimal for the compile speed and can get unmanageable for large classes. This would allow a more managed file structure and the separation of related functions from the core declaration.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on current code would be zero until the developer adopts the new access level<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Regards,<br>&gt; &gt;&gt;&gt; Tom<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/e58ce698/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Class scoped access level</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Is that (i.e. having properties in extensions) listed in the completing<br>generics manifesto? It certainly seems like it&#39;d be a worthwhile feature to<br>consider under that umbrella.<br></p><p>The one place where it will complicate matters is in the use of protocol<br>extensions as traits, since what I know of traits is that they should not<br>encapsulate state.<br></p><p><br>On Sat, Sep 10, 2016 at 14:13 Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br></p><p>&gt; I do certainly agree that 5 access levels are _plenty_, C++ “friend” is no<br>&gt; great friend to me, and I too not want to see another one access level<br>&gt; added. However, I do think there’s a related problem here worth solving.<br>&gt;<br>&gt; Sometimes, trying to break apart a large type using extensions, I<br>&gt; encounter this pattern:<br>&gt;<br>&gt; class Thingamer {<br>&gt;     private var doodads: [Doodad]<br>&gt;<br>&gt;     // All of these use the doodads var:<br>&gt;<br>&gt;     public func mangleDoodads() { … }<br>&gt;     public func fungeDoodads() { … }<br>&gt;     public func renoberateDoodads() { … }<br>&gt;     private func doodadHelper() { … }<br>&gt;<br>&gt;     // …and no other methods touch it<br>&gt; }<br>&gt;<br>&gt; My first instinct in this situation is to pull all the doodad-related<br>&gt; stuff into a separate type, but sometimes that’s the wrong solution.<br>&gt; Perhaps the public API gets messy or nonsensical if those public<br>&gt; doodad-related methods aren’t on Thingamer. Perhaps other Thingamer methods<br>&gt; use those doodad methods, even if they don’t use the private var. Perhaps<br>&gt; there’s still coupling to Thingamer through other class properties. And so<br>&gt; forth.<br>&gt;<br>&gt; It would be great to group all the doodad-stuff into an extension. The<br>&gt; inability of extensions to use class-private vars is the barrier. My usual<br>&gt; solution is to make the doodads var internal, and then try to remember not<br>&gt; to use it outside of the extension — which looks a lot like “fake friend”.<br>&gt;<br>&gt; It would be nice if Swift extensions let us encapsulate state+behavior<br>&gt; relationships without having to create new type boundaries.<br>&gt;<br>&gt; IIRC, there was talk of extensions being able to add properties to an<br>&gt; existing type. It seems like this would be feasible, at least for types<br>&gt; within the same module? Perhaps there’s another better way?<br>&gt;<br>&gt; Cheers,<br>&gt;<br>&gt; Paul<br>&gt;<br>&gt; On Sep 10, 2016, at 11:28 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Agreed.<br>&gt;<br>&gt; Swift&#39;s access levels are deliberately defined in terms of contiguous<br>&gt; blocks of written code [this is inelegantly phrased, but I think you see<br>&gt; what I mean]. As such, neither a &quot;class scoped&quot; level nor a level shared<br>&gt; between a type and its extensions would fit in such a scheme.<br>&gt;<br>&gt; Such an addition would fundamentally counter the existing design of Swift,<br>&gt; open the door for compensating features such as &quot;friend classes&quot; that<br>&gt; (IIUC) were deliberately avoided, and fails to compose with existing access<br>&gt; levels as inevitably there will be proposals to do. By that I mean, why<br>&gt; should a &quot;class scoped&quot; member always be limited in visibility to the same<br>&gt; module? This satisfies your particular motivating use case, but someone<br>&gt; else will want the same kind of class scoping but also allow a member to be<br>&gt; accessed by extensions outside the module (classpublic, if you will); still<br>&gt; others will want a member to be overridable outside the module (classopen);<br>&gt; for good measure, some will want access limited to only extensions and not<br>&gt; other types in the same file (classfileprivate; it is not out of the<br>&gt; question for someone to raise this point, since it is a close cousin of the<br>&gt; argument for distinguishing private and fileprivate).<br>&gt;<br>&gt; If I had my druthers, it&#39;d be nice to have exactly something like Nevin&#39;s<br>&gt; idea, a terse way to group related files into submodules, and a keyword<br>&gt; like `subinternal` that restricts visibility to that group of files. It<br>&gt; would satisfy the motivating use case here while preserving the deliberate<br>&gt; design decision that Swift access levels do not pick and choose<br>&gt; non-contiguous chunks of multiple files.<br>&gt;<br>&gt; In any case, let&#39;s postpone this discussion until it comes into scope at a<br>&gt; later phase of Swift evolution. The core team and other experts would no<br>&gt; doubt have much to contribute at that time.<br>&gt;<br>&gt;<br>&gt; On Sat, Sep 10, 2016 at 09:31 Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Indeed, I find it rather less convenient to write “fileprivate” in many<br>&gt;&gt; places I previously would use “private”, and unfortunate that I must choose<br>&gt;&gt; between aggregating many pieces into a single lengthy file or else<br>&gt;&gt; polluting the module scope with implementation details.<br>&gt;&gt;<br>&gt;&gt; I agree with Xiaodi that submodules are a far cleaner design, and I would<br>&gt;&gt; very much like to replace “fileprivate” with a short word that implies<br>&gt;&gt; “private to the submodule”. Then by default each file could be its own<br>&gt;&gt; submodule, and a developer could opt into having more files in a submodule<br>&gt;&gt; if they so desire.<br>&gt;&gt;<br>&gt;&gt; Count me as opposed to any sort of “class scoped” access level.<br>&gt;&gt;<br>&gt;&gt; Nevin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Sep 10, 2016 at 10:01 AM, Rien via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; On 10 Sep 2016, at 14:16, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I am firmly against this. The 5 levels that we have cover us well and<br>&gt;&gt;&gt; have enough complexity already.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Agree.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Sat, Sep 10, 2016 at 5:23 AM, Tom Bates via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I agree that classprivate would probably not work, maybe<br>&gt;&gt;&gt; constructprivate? but then you are leaving our enum etc.<br>&gt;&gt;&gt; &gt; With the `internal(class)` suggestion, if declaring a var such as<br>&gt;&gt;&gt; `internal(set) var name: String?` would this become `internal(class, set)<br>&gt;&gt;&gt; var name: String?`<br>&gt;&gt;&gt; &gt; Also there would need to be some kind of compile check either way<br>&gt;&gt;&gt; because if you declared an enum for example outside of a constructor you<br>&gt;&gt;&gt; would not be able to mark it as our new constructor only access level or it<br>&gt;&gt;&gt; would become inaccessible throughout the project.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Re: submodules, they are indeed overkill for this. As you would need a<br>&gt;&gt;&gt; separate submodule for each class you wanted to do this with and then run<br>&gt;&gt;&gt; the risk of inter coupling lots of different really small submodules.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Suggestions so far:<br>&gt;&gt;&gt; &gt; `classprivate`<br>&gt;&gt;&gt; &gt; `constructprivate`<br>&gt;&gt;&gt; &gt; `private(instance)`, `private(instance, set)` - problem -&gt; how would<br>&gt;&gt;&gt; this work? `public private(instance, set)`<br>&gt;&gt;&gt; &gt; `internal(class)`<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Personally I think a name like `classprivate` or `constructprivate`,<br>&gt;&gt;&gt; although not particularly well named would reduce complexities with private<br>&gt;&gt;&gt; setters syntax and keep migrations much simpler.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; On Sat, 10 Sep 2016 at 07:09 Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; I don&#39;t think submodules would solve it nicely. Each module/submodule<br>&gt;&gt;&gt; will require it&#39;s own namespace + it feels like an overkill to create<br>&gt;&gt;&gt; submodules for a few types. `internal(xyz)` seems to me like a better<br>&gt;&gt;&gt; solution. And yes this is purely additional and nothing for phase 1.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; --<br>&gt;&gt;&gt; &gt; Adrian Zubarev<br>&gt;&gt;&gt; &gt; Sent with Airmail<br>&gt;&gt;&gt; &gt; Am 9. September 2016 um 19:09:12, Xiaodi Wu (xiaodi.wu at gmail.com)<br>&gt;&gt;&gt; schrieb:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; Isn&#39;t the general solution to this problem submodules? In any case,<br>&gt;&gt;&gt; seems like it&#39;d be out of scope for Swift 4 phase 1.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; On Fri, Sep 9, 2016 at 11:34 AM, Adrian Zubarev via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; There must be a better solution to this problem, because you might<br>&gt;&gt;&gt; also extend value types from different files. That would mean, we&#39;d need<br>&gt;&gt;&gt; `structprivate` `protocolprivate` etc.<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; How about: `internal(class)` etc. ? Or something like<br>&gt;&gt;&gt; `internal(private)` to rule them all (I don&#39;t like the last name, but<br>&gt;&gt;&gt; something that would rule them all would be nice to have)!<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; --<br>&gt;&gt;&gt; &gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; &gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; &gt;&gt; Am 9. September 2016 um 17:49:29, Tom Bates via swift-evolution (<br>&gt;&gt;&gt; swift-evolution at swift.org) schrieb:<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; There is currently no way of accessing &quot;shared code&quot; from extensions<br>&gt;&gt;&gt; declared outside the base .swift file<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; I would love to see along side the new fileprivate access level a<br>&gt;&gt;&gt; classprivate access level that would allow any extension declared outside<br>&gt;&gt;&gt; of the original .swift file to access these properties and functions in an<br>&gt;&gt;&gt; attempt to reuse code.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; an example is below...<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt;&gt; &gt;&gt;&gt; //MyClass.swift<br>&gt;&gt;&gt; &gt;&gt;&gt; public class MyClass {<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; classprivate func sharedFunction() {<br>&gt;&gt;&gt; &gt;&gt;&gt;   self.function1()<br>&gt;&gt;&gt; &gt;&gt;&gt;   self.function2()<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; fileprivate func function1() {}<br>&gt;&gt;&gt; &gt;&gt;&gt; fileprivate func function2() {}<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt;&gt; &gt;&gt;&gt; //MyClass+Save.swift<br>&gt;&gt;&gt; &gt;&gt;&gt; extension MyClass {<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; public func save() {<br>&gt;&gt;&gt; &gt;&gt;&gt;   self.someFunction()<br>&gt;&gt;&gt; &gt;&gt;&gt;   self.sharedFunction()<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; fileprivate func someFunction() {}<br>&gt;&gt;&gt; &gt;&gt;&gt; }<br>&gt;&gt;&gt; &gt;&gt;&gt; =================<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Currently to achieve anything like this you would have to make the<br>&gt;&gt;&gt; &quot;core&quot; functions public or internal or write the whole thing in a single<br>&gt;&gt;&gt; file which as I understand it is not optimal for the compile speed and can<br>&gt;&gt;&gt; get unmanageable for large classes. This would allow a more managed file<br>&gt;&gt;&gt; structure and the separation of related functions from the core declaration.<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; There would be no migration needed I don&#39;t think as the impact on<br>&gt;&gt;&gt; current code would be zero until the developer adopts the new access level<br>&gt;&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; Regards,<br>&gt;&gt;&gt; &gt;&gt;&gt; Tom<br>&gt;&gt;&gt; &gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; _______________________________________________<br>&gt;&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/8d5dd39b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Class scoped access level</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>September 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Sep 10, 2016, at 2:52 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Is that (i.e. having properties in extensions) listed in the completing generics manifesto? It certainly seems like it&#39;d be a worthwhile feature to consider under that umbrella.<br></p><p>I think that came up at some point, but was deemed not to be implementable in a sufficiently performant way.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160910/2702de30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Class scoped access level</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>September 12, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Sep 10, 2016, at 5:25 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sep 10, 2016, at 2:52 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Is that (i.e. having properties in extensions) listed in the completing generics manifesto? It certainly seems like it&#39;d be a worthwhile feature to consider under that umbrella.<br>&gt; <br>&gt; I think that came up at some point, but was deemed not to be implementable in a sufficiently performant way.<br></p><p>It seems like it ought to be implementable for _in-module_ extensions, since presumably the memory layout of each type is fungible until the module is compiled.<br></p><p>In-module extensions address the use case I had in mind, namely breaking apart a large type by isolating some private properties within extensions. It seems like the possible and the desirable may actually intersect here.<br></p><p>P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160912/b6c7bcd0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
