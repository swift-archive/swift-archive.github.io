<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 14, 2016 at 04:00:00pm</p></header><div class="content"><p>Enhanced floating-point protocols<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Stephen Canon &lt;https://github.com/stephentyrone&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#introduction&gt;Introduction<br></p><p>The current FloatingPoint protocol is quite limited, and provides only a small subset of the features expected of an IEEE 754 conforming type. This proposal expands the protocol to cover most of the expected basic operations, and adds a second protocol, BinaryFloatingPoint, that provides a number of useful tools for generic programming with the most commonly used types.<br></p><p> &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#motivation&gt;Motivation<br></p><p>Beside the high-level motivation provided by the introduction, the proposed prototype schema addresses a number of issues and requests that we&#39;ve received from programmers:<br></p><p>FloatingPoint should conform to Equatable, and Comparable<br>FloatingPoint should conform to FloatLiteralConvertible<br>Deprecate the % operator for floating-point types<br>Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>Make Float80 conform to FloatingPoint<br>It also puts FloatingPoint much more tightly in sync with the work that is being done on protocols for Integers, which will make it easier to provide a uniform interface for arithmetic scalar types.<br></p><p> &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#detailed-design&gt;Detailed design<br></p><p>A new protocol, Arithmetic, is introduced that provides the most basic operations (add, subtract, multiply and divide) as well as Equatable and IntegerLiteralConvertible, and is conformed to by both integer and floating- point types.<br></p><p>There has been some resistance to adding such a protocol, owing to differences in behavior between floating point and integer arithmetic. While these differences make it difficult to write correct generic code that operates on all &quot;arithmetic&quot; types, it is nonetheless convenient to provide a single protocol that guarantees the availability of these basic operations. It is intended that &quot;number-like&quot; types should provide these APIs.<br></p><p>/// Arithmetic protocol declares methods backing binary arithmetic operators,<br>/// such as  `+`, `-` and `*`; and their mutating counterparts.  These methods<br>/// operate on arguments of the same type.<br>///<br>/// Both mutating and non-mutating operations are declared in the protocol, but<br>/// only the mutating ones are required.  Should conforming type omit<br>/// non-mutating implementations, they will be provided by a protocol extension.<br>/// Implementation in that case will copy `self`, perform a mutating operation<br>/// on it and return the resulting value.<br>public protocol Arithmetic: Equatable, IntegerLiteralConvertible {<br>  /// Initialize to zero<br>  init()<br></p><p>  /// The sum of `self` and `rhs`.<br>  //  Arithmetic provides a default implementation of this method in terms<br>  //  of the mutating `add` operation.<br>  @warn_unused_result<br>  func adding(rhs: Self) -&gt; Self<br></p><p>  /// Adds `rhs` to `self`.<br>  mutating func add(rhs: Self)<br></p><p>  /// The result of subtracting `rhs` from `self`.<br>  //  Arithmetic provides a default implementation of this method in terms<br>  //  of the mutating `subtract` operation.<br>  @warn_unused_result<br>  func subtracting(rhs: Self) -&gt; Self<br></p><p>  /// Subtracts `rhs` from `self`.<br>  mutating func subtract(rhs: Self)<br></p><p>  /// The product of `self` and `rhs`.<br>  //  Arithmetic provides a default implementation of this method in terms<br>  //  of the mutating `multiply` operation.<br>  @warn_unused_result<br>  func multiplied(by rhs: Self) -&gt; Self<br></p><p>  /// Multiplies `self` by `rhs`.<br>  mutating func multiply(by rhs: Self)<br></p><p>  /// The quotient of `self` dividing by `rhs`.<br>  //  Arithmetic provides a default implementation of this method in terms<br>  //  of the mutating `divide` operation.<br>  @warn_unused_result<br>  func divided(by rhs: Self) -&gt; Self<br></p><p>  /// Divides `self` by `rhs`.<br>  mutating func divide(by rhs: Self)<br>}<br></p><p>/// SignedArithmetic protocol will only be conformed to by signed numbers,<br>/// otherwise it would be possible to negate an unsigned value.<br>///<br>/// The only method of this protocol has the default implementation in an<br>/// extension, that uses a parameterless initializer and subtraction.<br>public protocol SignedArithmetic : Arithmetic {<br>  func negate() -&gt; Self<br>}<br>The usual arithmetic operators are then defined in terms of the implementation hooks provided by Arithmetic and SignedArithmetic, so providing those operations are all that is necessary for a type to present a &quot;number-like&quot; interface.<br></p><p>The FloatingPoint protocol is split into two parts; FloatingPoint and BinaryFloatingPoint, which conforms to FloatingPoint. If decimal types were added at some future point, they would conform to DecimalFloatingPoint.<br></p><p>FloatingPoint is expanded to contain most of the IEEE 754 basic operations, as well as conformance to SignedArithmetic and Comparable.<br></p><p>/// A floating-point type that provides most of the IEEE 754 basic (clause 5)<br>/// operations.  The base, precision, and exponent range are not fixed in<br>/// any way by this protocol, but it enforces the basic requirements of<br>/// any IEEE 754 floating-point type.<br>///<br>/// The BinaryFloatingPoint protocol refines these requirements and provides<br>/// some additional useful operations as well.<br>public protocol FloatingPoint: SignedArithmetic, Comparable {<br></p><p>  /// An unsigned integer type that can represent the significand of any value.<br>  ///<br>  /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently<br>  /// also called the &quot;mantissa&quot;, but this terminology is slightly incorrect<br>  /// (see the &quot;Use of &#39;mantissa&#39;&quot; section on the linked Wikipedia page for<br>  /// more details).  &quot;Significand&quot; is the preferred terminology in IEEE 754.<br>  associatedtype RawSignificand: UnsignedInteger<br></p><p>  /// 2 for binary floating-point types, 10 for decimal.<br>  ///<br>  /// A conforming type may use any integer radix, but values other than<br>  /// 2 or 10 are extraordinarily rare in practice.<br>  static var radix: Int { get }<br></p><p>  /// Positive infinity.  Compares greater than all finite numbers.<br>  static var infinity: Self { get }<br></p><p>  /// A quiet NaN (not-a-number).  Compares not equal to every value,<br>  /// including itself.<br>  static var nan: Self { get }<br></p><p>  /// NaN with specified `payload`.<br>  ///<br>  /// Compares not equal to every value, including itself.  Most operations<br>  /// with a NaN operand will produce a NaN result.  Note that it is generally<br>  /// not the case that all possible significand values are valid<br>  /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>  /// payloads as zero, or mask them to create an admissible payload.<br>  @warn_unused_result<br>  static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br></p><p>  /// The greatest finite number.<br>  ///<br>  /// Compares greater than or equal to all finite numbers, but less than<br>  /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.<br>  /// The naming of those macros is slightly misleading, because infinity<br>  /// is greater than this value.<br>  static var greatestFiniteMagnitude: Self { get }<br></p><p>  // NOTE: Rationale for &quot;ulp&quot; instead of &quot;epsilon&quot;:<br>  // We do not use that name because it is ambiguous at best and misleading<br>  // at worst:<br>  //<br>  // - Historically several definitions of &quot;machine epsilon&quot; have commonly<br>  //   been used, which differ by up to a factor of two or so.  By contrast<br>  //   &quot;ulp&quot; is a term with a specific unambiguous definition.<br>  //<br>  // - Some languages have used &quot;epsilon&quot; to refer to wildly different values,<br>  //   such as `leastMagnitude`.<br>  //<br>  // - Inexperienced users often believe that &quot;epsilon&quot; should be used as a<br>  //   tolerance for floating-point comparisons, because of the name.  It is<br>  //   nearly always the wrong value to use for this purpose.<br></p><p>  /// The unit in the last place of 1.0.<br>  ///<br>  /// This is the weight of the least significant bit of the significand of 1.0,<br>  /// or the positive difference between 1.0 and the next greater representable<br>  /// number.  Corresponds to the C macros `FLT_EPSILON`, `DBL_EPSILON`, etc.<br>  static var ulp: Self { get }<br></p><p>  /// The unit in the last place of `self`.<br>  ///<br>  /// This is the unit of the least significant digit in the significand of<br>  /// `self`.  For most numbers `x`, this is the difference between `x` and<br>  /// the next greater (in magnitude) representable number.  There are some<br>  /// edge cases to be aware of:<br>  ///<br>  /// - `greatestFiniteMagnitude.ulp` is a finite number, even though<br>  ///   the next greater representable value is `infinity`.<br>  /// - `x.ulp` is `NaN` if `x` is not a finite number.<br>  /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal<br>  ///   number.  On targets that do not support subnormals, `x.ulp` may be<br>  ///   flushed to zero.<br>  ///<br>  /// This quantity, or a related quantity is sometimes called &quot;epsilon&quot; or<br>  /// &quot;machine epsilon&quot;.  We avoid that name because it has different meanings<br>  /// in different languages, which can lead to confusion, and because it<br>  /// suggests that it is an good tolerance to use for comparisons,<br>  /// which is almost never is.<br>  ///<br>  /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)<br>  var ulp: Self { get }<br></p><p>  /// The least positive normal number.<br>  ///<br>  /// Compares less than or equal to all positive normal numbers.  There may<br>  /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>  /// they are represented with less precision than normal numbers.<br>  /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of<br>  /// those macros is slightly misleading, because subnormals, zeros, and<br>  /// negative numbers are smaller than this value.<br>  static var leastNormalMagnitude: Self { get }<br></p><p>  /// The least positive number.<br>  ///<br>  /// Compares less than or equal to all positive numbers, but greater than<br>  /// zero.  If the target supports subnormal values, this is smaller than<br>  /// `leastNormalMagnitude`; otherwise they are equal.<br>  static var leastMagnitude: Self { get }<br></p><p>  /// `true` iff the signbit of `self` is set.  Implements the IEEE 754<br>  /// `signbit` operation.<br>  ///<br>  /// Note that this is not the same as `self &lt; 0`.  In particular, this<br>  /// property is true for `-0` and some NaNs, both of which compare not<br>  /// less than zero.<br>  //  TODO: strictly speaking a bit and a bool are slightly different<br>  //  concepts.  Is another name more appropriate for this property?<br>  //  `isNegative` is incorrect because of -0 and NaN.  `isSignMinus` might<br>  //  be acceptable, but isn&#39;t great.  `signBit` is the IEEE 754 name.<br>  var signBit: Bool { get }<br></p><p>  /// The integer part of the base-r logarithm of the magnitude of `self`,<br>  /// where r is the radix (2 for binary, 10 for decimal).  Implements the<br>  /// IEEE 754 `logB` operation.<br>  ///<br>  /// Edge cases:<br>  ///<br>  /// - If `x` is zero, then `x.exponent` is `Int.min`.<br>  /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`<br>  var exponent: Int { get }<br></p><p>  /// The significand satisfies:<br>  ///<br>  /// ~~~<br>  /// self = (signBit ? -1 : 1) * significand * radix**exponent<br>  /// ~~~<br>  ///<br>  /// If radix is 2 (the most common case), then for finite non-zero numbers<br>  /// `1 &lt;= significand` and `significand &lt; 2`.  For other values of `x`,<br>  /// `x.significand` is defined as follows:<br>  ///<br>  /// - If `x` is zero, then `x.significand` is 0.0.<br>  /// - If `x` is infinity, then `x.significand` is 1.0.<br>  /// - If `x` is NaN, then `x.significand` is NaN.<br>  ///<br>  /// For all floating-point `x`, if we define y by:<br>  ///<br>  /// ~~~<br>  /// let y = Self(signBit: x.signBit, exponent: x.exponent,<br>  ///              significand: x.significand)<br>  /// ~~~<br>  ///<br>  /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.<br>  var significand: Self { get }<br></p><p>  /// Initialize from signBit, exponent, and significand.<br>  ///<br>  /// The result is:<br>  ///<br>  /// ~~~<br>  /// (signBit ? -1 : 1) * significand * radix**exponent<br>  /// ~~~<br>  ///<br>  /// (where `**` is exponentiation) computed as if by a single correctly-<br>  /// rounded floating-point operation.  If this value is outside the<br>  /// representable range of the type, overflow or underflow occurs, and zero,<br>  /// a subnormal value, or infinity may result, as with any basic operation.<br>  /// Other edge cases:<br>  ///<br>  /// - If `significand` is zero or infinite, the result is zero or infinite,<br>  ///   regardless of the value of `exponent`.<br>  ///<br>  /// - If `significand` is NaN, the result is NaN.<br>  ///<br>  /// Note that for any floating-point `x` the result of<br>  ///<br>  ///   `Self(signBit: x.signBit,<br>  ///         exponent: x.exponent,<br>  ///         significand: x.significand)`<br>  ///<br>  /// is &quot;the same&quot; as `x`; it is `x` canonicalized.<br>  ///<br>  /// Because of these properties, this initializer implements the IEEE 754<br>  /// `scaleB` operation.<br>  init(signBit: Bool, exponent: Int, significand: Self)<br></p><p>  /// A floating point value whose exponent and signficand are taken from<br>  /// `magnitude` and whose signBit is taken from `signOf`.  Implements the<br>  /// IEEE 754 `copysign` operation.<br>  //  TODO: better argument names would be great.<br>  init(magnitudeOf magnitude: Self, signOf: Self)<br></p><p>  /// The least representable value that compares greater than `self`.<br>  ///<br>  /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.<br>  /// - If `x` is `-leastMagnitude`, then `x.nextUp` is `-0.0`.<br>  /// - If `x` is zero, then `x.nextUp` is `leastMagnitude`.<br>  /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.<br>  /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.<br>  var nextUp: Self { get }<br></p><p>  /// The greatest representable value that compares less than `self`.<br>  ///<br>  /// `x.nextDown` is equivalent to `-(-x).nextUp`<br>  var nextDown: Self { get }<br></p><p>  /// Remainder of `self` divided by `other`.<br>  ///<br>  /// For finite `self` and `other`, the remainder `r` is defined by<br>  /// `r = self - other*n`, where `n` is the integer nearest to `self/other`.<br>  /// (Note that `n` is *not* `self/other` computed in floating-point<br>  /// arithmetic, and that `n` may not even be representable in any available<br>  /// integer type).  If `self/other` is exactly halfway between two integers,<br>  /// `n` is chosen to be even.<br>  ///<br>  /// It follows that if `self` and `other` are finite numbers, the remainder<br>  /// `r` satisfies `-|other|/2 &lt;= r` and `r &lt;= |other|/2`.<br>  ///<br>  /// `formRemainder` is always exact, and therefore is not affected by<br>  /// rounding modes.<br>  mutating func formRemainder(dividingBy other: Self)<br></p><p>  /// Remainder of `self` divided by `other` using truncating division.<br>  ///<br>  /// If `self` and `other` are finite numbers, the truncating remainder<br>  /// `r` has the same sign as `other` and is strictly smaller in magnitude.<br>  /// It satisfies `r = self - other*n`, where `n` is the integral part<br>  /// of `self/other`.<br>  ///<br>  /// `formTruncatingRemainder` is always exact, and therefore is not<br>  /// affected by rounding modes.<br>  mutating func formTruncatingRemainder(dividingBy other: Self)<br></p><p>  /// Mutating form of square root.<br>  mutating func formSquareRoot( )<br></p><p>  /// Fused multiply-add, accumulating the product of `lhs` and `rhs` to `self`.<br>  mutating func addProduct(lhs: Self, _ rhs: Self)<br></p><p>  /// Remainder of `self` divided by `other`.<br>  @warn_unused_result<br>  func remainder(dividingBy other: Self) -&gt; Self<br></p><p>  /// Remainder of `self` divided by `other` using truncating division.<br>  @warn_unused_result<br>  func truncatingRemainder(dividingBy other: Self) -&gt; Self<br></p><p>  /// Square root of `self`.<br>  @warn_unused_result<br>  func squareRoot( ) -&gt; Self<br></p><p>  /// `self + lhs*rhs` computed without intermediate rounding.<br>  @warn_unused_result<br>  func addingProduct(lhs: Self, _ rhs: Self) -&gt; Self<br></p><p>  /// The minimum of `x` and `y`.  Implements the IEEE 754 `minNum` operation.<br>  ///<br>  /// Returns `x` if `x &lt;= y`, `y` if `y &lt; x`, and whichever of `x` or `y`<br>  /// is a number if the other is NaN.  The result is NaN only if both <br>  /// arguments are NaN.<br>  ///<br>  /// This function is an implementation hook to be used by the free function<br>  /// min(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>  /// to NaNs.<br>  @warn_unused_result<br>  static func minimum(x: Self, _ y: Self) -&gt; Self<br></p><p>  /// The maximum of `x` and `y`.  Implements the IEEE 754 `maxNum` operation.<br>  ///<br>  /// Returns `x` if `x &gt;= y`, `y` if `y &gt; x`, and whichever of `x` or `y`<br>  /// is a number if the other is NaN.  The result is NaN only if both<br>  /// arguments are NaN.<br>  ///<br>  /// This function is an implementation hook to be used by the free function<br>  /// max(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>  /// to NaNs.<br>  @warn_unused_result<br>  static func maximum(x: Self, _ y: Self) -&gt; Self<br></p><p>  /// Whichever of `x` or `y` has lesser magnitude.  Implements the IEEE 754<br>  /// `minNumMag` operation.<br>  ///<br>  /// Returns `x` if abs(x) &lt;= abs(y), `y` if abs(y) &lt; abs(x), and whichever of<br>  /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>  /// only if both arguments are NaN.<br>  @warn_unused_result<br>  static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self<br></p><p>  /// Whichever of `x` or `y` has greater magnitude.  Implements the IEEE 754<br>  /// `maxNumMag` operation.<br>  ///<br>  /// Returns `x` if abs(x) &gt;= abs(y), `y` if abs(y) &gt; abs(x), and whichever of<br>  /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>  /// only if both arguments are NaN.<br>  @warn_unused_result<br>  static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self<br></p><p>  /// IEEE 754 equality predicate.<br>  ///<br>  /// -0 compares equal to +0, and NaN compares not equal to anything,<br>  /// including itself.<br>  @warn_unused_result<br>  func isEqual(to other: Self) -&gt; Bool<br></p><p>  /// IEEE 754 less-than predicate.<br>  ///<br>  /// NaN compares not less than anything.  -infinity compares less than<br>  /// all values except for itself and NaN.  Everything except for NaN and<br>  /// +infinity compares less than +infinity.<br>  @warn_unused_result<br>  func isLess(than other: Self) -&gt; Bool<br></p><p>  /// IEEE 754 less-than-or-equal predicate.<br>  ///<br>  /// NaN compares not less than or equal to anything, including itself.<br>  /// -infinity compares less than or equal to everything except NaN.<br>  /// Everything except NaN compares less than or equal to +infinity.<br>  ///<br>  /// Because of the existence of NaN in FloatingPoint types, trichotomy does<br>  /// not hold, which means that `x &lt; y` and `!(y &lt;= x)` are not equivalent.<br>  /// This is why `isLessThanOrEqual(to:)` is a separate implementation hook<br>  /// in the protocol.<br>  ///<br>  /// Note that this predicate does not impose a total order.  The `totalOrder`<br>  /// predicate provides a refinement satisfying that criteria.<br>  @warn_unused_result<br>  func isLessThanOrEqual(to other: Self) -&gt; Bool<br></p><p>  /// IEEE 754 unordered predicate.  True if either `self` or `other` is NaN,<br>  /// and false otherwise.<br>  @warn_unused_result<br>  func isUnordered(with other: Self) -&gt; Bool<br></p><p>  /// True if and only if `self` is normal.<br>  ///<br>  /// A normal number uses the full precision available in the format.  Zero<br>  /// is not a normal number.<br>  var isNormal: Bool { get }<br></p><p>  /// True if and only if `self` is finite.<br>  ///<br>  /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or<br>  /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNan` are<br>  /// `false`.<br>  var isFinite: Bool { get }<br></p><p>  /// True iff `self` is zero.  Equivalent to `self == 0`.<br>  var isZero: Bool { get }<br></p><p>  /// True if and only if `self` is subnormal.<br>  ///<br>  /// A subnormal number does not use the full precision available to normal<br>  /// numbers of the same format.  Zero is not a subnormal number.<br>  var isSubnormal: Bool { get }<br></p><p>  /// True if and only if `self` is infinite.<br>  ///<br>  /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because<br>  /// they are not total.  If `x` is `NaN`, then both properties are `false`.<br>  var isInfinite: Bool { get }<br></p><p>  /// True if and only if `self` is NaN (&quot;not a number&quot;).<br>  var isNan: Bool { get }<br></p><p>  /// True if and only if `self` is a signaling NaN.<br>  var isSignalingNan: Bool { get }<br></p><p>  /// The IEEE 754 &quot;class&quot; of this type.<br>  var floatingPointClass: FloatingPointClassification { get }<br></p><p>  /// True if and only if `self` is canonical.<br>  ///<br>  /// Every floating-point value of type Float or Double is canonical, but<br>  /// non-canonical values of type Float80 exist, and non-canonical values<br>  /// may exist for other types that conform to FloatingPoint.<br>  ///<br>  /// The non-canonical Float80 values are known as &quot;pseudo-denormal&quot;,<br>  /// &quot;unnormal&quot;, &quot;pseudo-infinity&quot;, and &quot;pseudo-NaN&quot;.<br>  /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)<br>  var isCanonical: Bool { get }<br></p><p>  /// True if and only if `self` preceeds `other` in the IEEE 754 total order<br>  /// relation.<br>  ///<br>  /// This relation is a refinement of `&lt;=` that provides a total order on all<br>  /// values of type `Self`, including non-canonical encodings, signed zeros,<br>  /// and NaNs.  Because it is used much less frequently than the usual<br>  /// comparisons, there is no operator form of this relation.<br>  @warn_unused_result<br>  func totalOrder(with other: Self) -&gt; Bool<br></p><p>  /// True if and only if `abs(self)` preceeds `abs(other)` in the IEEE 754<br>  /// total order relation.<br>  @warn_unused_result<br>  func totalOrderMagnitude(with other: Self) -&gt; Bool<br></p><p>  /// The closest representable value to the argument.<br>  init&lt;Source: Integer&gt;(_ value: Source)<br></p><p>  /// Fails if the argument cannot be exactly represented.<br>  init?&lt;Source: Integer&gt;(exactly value: Source)<br>}<br>The BinaryFloatingPoint protocol provides a number of additional APIs that only make sense for types with fixed radix 2:<br></p><p>/// A radix-2 (binary) floating-point type that follows the IEEE 754 encoding<br>/// conventions.<br>public protocol BinaryFloatingPoint: FloatingPoint {<br></p><p>  /// The number of bits used to represent the exponent.<br>  ///<br>  /// Following IEEE 754 encoding convention, the exponent bias is:<br>  ///<br>  ///   bias = 2**(exponentBitCount-1) - 1<br>  ///<br>  /// The least normal exponent is `1-bias` and the largest finite exponent<br>  /// is `bias`.  The all-zeros exponent is reserved for subnormals and zeros,<br>  /// and the all-ones exponent is reserved for infinities and NaNs.<br>  static var exponentBitCount: Int { get }<br></p><p>  /// For fixed-width floating-point types, this is the number of fractional<br>  /// significand bits.<br>  ///<br>  /// For extensible floating-point types, `significandBitCount` should be<br>  /// the maximum allowed significand width (without counting any leading<br>  /// integral bit of the significand).  If there is no upper limit, then<br>  /// `significandBitCount` should be `Int.max`.<br>  ///<br>  /// Note that `Float80.significandBitCount` is 63, even though 64 bits<br>  /// are used to store the significand in the memory representation of a<br>  /// `Float80` (unlike other floating-point types, `Float80` explicitly<br>  /// stores the leading integral significand bit, but the<br>  /// `BinaryFloatingPoint` APIs provide an abstraction so that users don&#39;t<br>  /// need to be aware of this detail).<br>  static var significandBitCount: Int { get }<br></p><p>  /// The raw encoding of the exponent field of the floating-point value.<br>  var exponentBitPattern: UInt { get }<br></p><p>  /// The raw encoding of the significand field of the floating-point value.<br>  ///<br>  /// `significandBitPattern` does *not* include the leading integral bit of<br>  /// the significand, even for types like `Float80` that store it explicitly.<br>  var significandBitPattern: RawSignificand { get }<br></p><p>  /// Combines `signBit`, `exponent` and `significand` bit patterns to produce<br>  /// a floating-point value.<br>  init(signBit: Bool,<br>       exponentBitPattern: UInt,<br>       significandBitPattern: RawSignificand)<br></p><p>  /// The least-magnitude member of the binade of `self`.<br>  ///<br>  /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is<br>  /// `+/- 2**exponent`; i.e. the floating point number with the same sign<br>  /// and exponent, but with a significand of 1.0.<br>  var binade: Self { get }<br></p><p>  /// The number of bits required to represent significand.<br>  ///<br>  /// If `self` is not a finite non-zero number, `significandWidth` is<br>  /// `-1`.  Otherwise, it is the number of bits required to represent the<br>  /// significand exactly (less `1` because common formats represent one bit<br>  /// implicitly).<br>  var significandWidth: Int { get }<br></p><p>  @warn_unused_result<br>  func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br></p><p>  @warn_unused_result<br>  func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool<br></p><p>  @warn_unused_result<br>  func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br></p><p>  @warn_unused_result<br>  func isUnordered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br></p><p>  @warn_unused_result<br>  func totalOrder&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br></p><p>  /// `value` rounded to the closest representable value.<br>  init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source)<br></p><p>  /// Fails if `value` cannot be represented exactly as `Self`.<br>  init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source)<br>}<br>Float, Double, Float80 and CGFloat will conform to all of these protocols.<br></p><p>A small portion of the implementation of these APIs is dependent on new Integer protocols that will be proposed separately. Everything else is implemented in draft form on the branch floating-point-revision of my fork &lt;https://github.com/stephentyrone/swift&gt;.<br></p><p> &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>The % operator is no longer available for FloatingPoint types. We don&#39;t believe that it was widely used correctly, and the operation is still available via the formTruncatingRemainder method for people who need it.<br></p><p>To follow the naming guidelines, NaN and isNaN are replaced with nan and isNan.<br></p><p>The redundant property quietNaN is removed.<br></p><p>isSignaling is renamed isSignalingNan.<br></p><p> &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#alternatives-considered&gt;Alternatives considered<br></p><p>N/A.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/29392fdb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 07:00:00pm</p></header><div class="content"><p>* I do use % for floating point but not as much as I first thought before I started searching through my code after reading your e-mail. But when I do use it, it&#39;s nice to have a really familiar symbol rather than a big word. What were the ways that it was used incorrectly? Do you have some examples?<br></p><p>* I don&#39;t quite get how equatable is going to work. Do you mind explaining that in more detail?<br></p><p>-- E<br></p><p>&gt; On Apr 14, 2016, at 5:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Impact on existing code<br>&gt; <br>&gt; The % operator is no longer available for FloatingPoint types. We don&#39;t believe that it was widely used correctly, and the operation is still available via the formTruncatingRemainder method for people who need it.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/6b100774/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi Erica, thanks for the feedback.<br></p><p>&gt; On Apr 14, 2016, at 6:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; * I do use % for floating point but not as much as I first thought before I started searching through my code after reading your e-mail. But when I do use it, it&#39;s nice to have a really familiar symbol rather than a big word. What were the ways that it was used incorrectly? Do you have some examples?<br></p><p>As it happens, I have a rationale sitting around from an earlier (internal) discussion:<br></p><p>While C and C++ do not provide the “%” operator for floating-point types, many newer languages do (Java, C#, and Python, to name just a few).  Superficially this seems reasonable, but there are severe gotchas when % is applied to floating-point data, and the results are often extremely surprising to unwary users.  C and C++ omitted this operator for good reason.  Even if you think you want this operator, it is probably doing the wrong thing in subtle ways that will cause trouble for you in the future.<br></p><p>The % operator on integer types satisfies the division algorithm axiom: If b is non-zero and q = a/b, r = a%b, then a = q*b + r.  This property does not hold for floating-point types, because a/b does not produce an integral value.  If it did produce an integral value, it would need to be a bignum type of some sort (the integral part of DBL_MAX / DBL_MIN, for example, has over 2000 bits or 600 decimal digits).<br></p><p>Even if a bignum type were returned, or if we ignore the loss of the division algorithm axiom, % would still be deeply flawed.  Whereas people are generally used to modest rounding errors in floating-point arithmetic, because % is not continuous small errors are frequently enormously magnified with catastrophic results:<br></p><p>	(swift) 10.0 % 0.1<br>    // r0 : Double = 0.0999999999999995 // What?!<br></p><p>[Explanation: 0.1 cannot be exactly represented in binary floating point; the actual value of “0.1” is 0.1000000000000000055511151231257827021181583404541015625.  Other than that rounding, the entire computation is exact.]<br></p><p>Proposed Approach:<br>Remove the “%” operator for floating-point types.  The operation is still be available via the C standard library fmod( ) function (which should be mapped to a Swiftier name, but that’s a separate proposal).<br></p><p>Alternative Considered:<br>Instead of binding “%” to fmod( ), it could be bound to remainder( ), which implements the IEEE 754 remainder operation; this is just like fmod( ), except instead of returning the remainder under truncating division, it returns the remainder of round-to-nearest division, meaning that if a and b are positive, remainder(a,b) is in the range [-b/2, b/2] rather than [0, b).  This still has a large discontinuity, but the discontinuity is moved away from zero, which makes it much less troublesome (that’s why IEEE 754 standardized this operation):<br></p><p>	(swift) remainder(1, 0.1)<br>    // r1 : Double = -0.000000000000000055511151231257827 // Looks like normal floating-point rounding<br></p><p>The downside to this alternative is that now % behaves totally differently for integer and floating-point data, and of course the division algorithm still doesn’t hold.<br></p><p>&gt; * I don&#39;t quite get how equatable is going to work. Do you mind explaining that in more detail?<br></p><p>I’m not totally sure what your question is.  Are you asking how FloatingPoint will conform to Equatable, or how the Equatable protocol will work?<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/fb099b3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:36 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Erica, thanks for the feedback.<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 6:29 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; * I do use % for floating point but not as much as I first thought before I started searching through my code after reading your e-mail. But when I do use it, it&#39;s nice to have a really familiar symbol rather than a big word. What were the ways that it was used incorrectly? Do you have some examples?<br>&gt; <br>&gt; As it happens, I have a rationale sitting around from an earlier (internal) discussion:<br>&gt; <br></p><p>Thanks. That makes plenty of sense although I do still think the name is long and hard to discover compared to fmod[1] and %.<br></p><p>&gt;&gt; * I don&#39;t quite get how equatable is going to work. Do you mind explaining that in more detail?<br>&gt; <br>&gt; I’m not totally sure what your question is.  Are you asking how FloatingPoint will conform to Equatable, or how the Equatable protocol will work?<br></p><p>Given the many words and passionate articles about how difficult it is to perform floating point comparisons, <br>for example, https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/, <br>I&#39;m just curious as to what approach you&#39;ve settled on. The topic has come up on-list quite a few times.<br></p><p>-- E<br></p><p>[1] Nearly all of what I *thought* I was doing with % did turn out to be fmod (CGFloat a = fmodf(stepAngle * i, 360.0))<br> so there&#39;s that<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/671f305e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:12 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 10:36 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Erica, thanks for the feedback.<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 14, 2016, at 6:29 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * I do use % for floating point but not as much as I first thought before I started searching through my code after reading your e-mail. But when I do use it, it&#39;s nice to have a really familiar symbol rather than a big word. What were the ways that it was used incorrectly? Do you have some examples?<br>&gt;&gt; <br>&gt;&gt; As it happens, I have a rationale sitting around from an earlier (internal) discussion:<br>&gt;&gt; <br>&gt; <br>&gt; Thanks. That makes plenty of sense although I do still think the name is long and hard to discover compared to fmod[1] and %.<br></p><p>I completely agree.  I don’t expect the fmod free function to go away anytime soon, FWIW (and I would oppose removing it unless we had a more discoverable name for this method).<br></p><p>&gt;&gt;&gt; * I don&#39;t quite get how equatable is going to work. Do you mind explaining that in more detail?<br>&gt;&gt; <br>&gt;&gt; I’m not totally sure what your question is.  Are you asking how FloatingPoint will conform to Equatable, or how the Equatable protocol will work?<br>&gt; <br>&gt; Given the many words and passionate articles about how difficult it is to perform floating point comparisons, <br>&gt; for example, https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/ &lt;https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition/&gt;, <br>&gt; I&#39;m just curious as to what approach you&#39;ve settled on. The topic has come up on-list quite a few times.<br></p><p>The actual == and != operators should continue to default to exact (IEEE 754) equality.  Doing anything else is asking for a lot of trouble when people try to convert algorithms from other languages.<br></p><p>Support for equality and comparison with a tolerance would be a great library feature, but the difficulty is that it’s impossible to provide a solution that’s appropriate for all (or even most) cases.  I have a few sketches of things I’d like to do in that direction, but it’s out of scope for Swift 3, considering the subtle numerics *and* library/language design issues involved.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/2bd843d2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 14, 2016 at 08:00:00pm</p></header><div class="content"><p>First of all: I do *not* do crazy things with floating-point numbers, so there&#39;s a good chance I&#39;m missing the point with some of this. Consider anything having to do with NaNs, subnormals, or other such strange denizens of the FPU to be prefixed with &quot;I may be totally missing the point, but…&quot;<br></p><p>&gt; public protocol Arithmetic<br></p><p><br>Is there a rationale for the name &quot;Arithmetic&quot;? There&#39;s probably nothing wrong with it, but I would have guessed you&#39;d use the name &quot;Number&quot;.<br></p><p>&gt; : Equatable, IntegerLiteralConvertible<br></p><p><br>Are there potential conforming types which aren&#39;t Comparable?<br></p><p>&gt; func adding(rhs: Self) -&gt; Self<br>&gt; mutating func add(rhs: Self)<br></p><p>Is there a reason we&#39;re introducing methods and calling them from the operators, rather than listing the operators themselves as requirements?<br></p><p>&gt;   func negate() -&gt; Self<br></p><p>Should this be `negated()`? Should there be a mutating `negate()` variant, even if we won&#39;t have an operator for it?<br></p><p>(If a mutating `negate` would be an attractive nuisance, we can use `negative()`/`formNegative()` instead.)<br></p><p>&gt;   /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;   /// payloads as zero, or mask them to create an admissible payload.<br>&gt;   static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br></p><p>This seems unusually tolerant of bad inputs. Should this instead be a precondition, and have an (elidable in unchecked mode) trap if it&#39;s violated?<br></p><p>&gt; static var greatestFiniteMagnitude: Self { get }<br>&gt; static var leastNormalMagnitude: Self { get }<br>&gt; static var leastMagnitude: Self { get }<br></p><p>Reading these, I find the use of &quot;least&quot; a little bit misleading—it seems like they should be negative. I wonder if instead, we can use ClosedIntervals/ClosedRanges to group together related values:<br></p><p>	static var positiveNormals: ClosedRange&lt;Self&gt; { get }<br>	static var positiveSubnormals: ClosedRange&lt;Self&gt; { get }<br></p><p>	Double.positiveNormals.upperBound		// DBL_MAX<br>	Double.positiveNormals.lowerBound		// DBL_MIN<br>	Double.positiveSubnormals.upperBound	// Self.positiveNormals.lowerBound.nextDown<br>	Double.positiveSubnormals.lowerBound	// 0.nextUp<br></p><p>	// Alternatively, you could have `positives`, running from 0.nextUp to infinity<br></p><p>Technically, you could probably implement calls like e.g. isNormal in terms of the positiveNormals property, but I&#39;m sure separate calls are much, much faster.<br></p><p>(It might also be helpful if you could negate signed ClosedIntervals, which would negate and swap the bounds.)<br></p><p>&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;   func isLess(than other: Self) -&gt; Bool<br>&gt;   func totalOrder(with other: Self) -&gt; Bool<br></p><p>Swift 2&#39;s Comparable demands a strict total order. However, the documentation here seems to imply that totalOrder is *not* what you get from the &lt; operator. Is something getting reshuffled here?<br></p><p>&gt;   init&lt;Source: Integer&gt;(_ value: Source)<br>&gt;   init?&lt;Source: Integer&gt;(exactly value: Source)<br></p><p>&gt;   init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source)<br>&gt;   init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source)<br></p><p>It&#39;s great to have both of these, but I wonder how they&#39;re going to be implemented—if Integer can be either signed or unsigned, I&#39;m not sure how you get the top bit of an unsigned integer out.<br></p><p>Also, since `init(_:)` is lossy and `init(exactly:)` is not, shouldn&#39;t their names technically be switched? Or perhaps `init(_:)` should be exact and trapping, `init(exactly:)` should be failable, and `init(closest:)` should always return something or other?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Brent, thanks for the feedback.<br></p><p>&gt; On Apr 14, 2016, at 8:34 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; First of all: I do *not* do crazy things with floating-point numbers, so there&#39;s a good chance I&#39;m missing the point with some of this. Consider anything having to do with NaNs, subnormals, or other such strange denizens of the FPU to be prefixed with &quot;I may be totally missing the point, but…”<br></p><p>Noted.<br></p><p>&gt;&gt; public protocol Arithmetic<br>&gt; <br>&gt; Is there a rationale for the name &quot;Arithmetic&quot;? There&#39;s probably nothing wrong with it, but I would have guessed you&#39;d use the name &quot;Number”.<br></p><p>Dave A. came up with the name, though I think it’s a good one.  Number isn’t bad either.<br></p><p>&gt;&gt; : Equatable, IntegerLiteralConvertible<br>&gt; <br>&gt; Are there potential conforming types which aren&#39;t Comparable?<br></p><p>Not at present, but I expect there to be in the future.  Modular integers and complex numbers come to mind as the most obvious examples.<br></p><p>&gt;&gt; func adding(rhs: Self) -&gt; Self<br>&gt;&gt; mutating func add(rhs: Self)<br>&gt; <br>&gt; Is there a reason we&#39;re introducing methods and calling them from the operators, rather than listing the operators themselves as requirements?<br>&gt; <br>&gt;&gt;  func negate() -&gt; Self<br>&gt; <br>&gt; Should this be `negated()`? Should there be a mutating `negate()` variant, even if we won&#39;t have an operator for it?<br>&gt; <br>&gt; (If a mutating `negate` would be an attractive nuisance, we can use `negative()`/`formNegative()` instead.)<br></p><p>Chris noted this too, and I think you’re both right.<br></p><p>&gt;&gt;  /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;&gt;  /// payloads as zero, or mask them to create an admissible payload.<br>&gt;&gt;  static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br>&gt; <br>&gt; This seems unusually tolerant of bad inputs. Should this instead be a precondition, and have an (elidable in unchecked mode) trap if it&#39;s violated?<br></p><p>I don’t think that it’s a particularly useful error to detect, and different floating point types may differ greatly in what payloads they support (if any), because they might choose to reserve those encodings for other purposes.<br></p><p>&gt;&gt; static var greatestFiniteMagnitude: Self { get }<br>&gt;&gt; static var leastNormalMagnitude: Self { get }<br>&gt;&gt; static var leastMagnitude: Self { get }<br>&gt; <br>&gt; Reading these, I find the use of &quot;least&quot; a little bit misleading—it seems like they should be negative.<br></p><p>Magnitudes are strictly positive.  In fairness, that may not be immediately obvious to all readers.<br></p><p>&gt; I wonder if instead, we can use ClosedIntervals/ClosedRanges to group together related values:<br>&gt; <br>&gt; 	static var positiveNormals: ClosedRange&lt;Self&gt; { get }<br>&gt; 	static var positiveSubnormals: ClosedRange&lt;Self&gt; { get }<br>&gt; <br>&gt; 	Double.positiveNormals.upperBound		// DBL_MAX<br>&gt; 	Double.positiveNormals.lowerBound		// DBL_MIN<br>&gt; 	Double.positiveSubnormals.upperBound	// Self.positiveNormals.lowerBound.nextDown<br>&gt; 	Double.positiveSubnormals.lowerBound	// 0.nextUp<br>&gt; <br>&gt; 	// Alternatively, you could have `positives`, running from 0.nextUp to infinity<br>&gt; <br>&gt; Technically, you could probably implement calls like e.g. isNormal in terms of the positiveNormals property, but I&#39;m sure separate calls are much, much faster.<br>&gt; <br>&gt; (It might also be helpful if you could negate signed ClosedIntervals, which would negate and swap the bounds.)<br></p><p>This seems wildly over-engineered to me personally.  Every language I surveyed provides (a subset of) these quantities as simple scalar values.<br></p><p>&gt;&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;&gt;  func isLess(than other: Self) -&gt; Bool<br>&gt;&gt;  func totalOrder(with other: Self) -&gt; Bool<br>&gt; <br>&gt; Swift 2&#39;s Comparable demands a strict total order. However, the documentation here seems to imply that totalOrder is *not* what you get from the &lt; operator. Is something getting reshuffled here?<br></p><p>The Swift 2 Comparable documentation is probably overly specific.  The requirement should really be something like a strict total order on non-exceptional values.<br></p><p>&gt;&gt;  init&lt;Source: Integer&gt;(_ value: Source)<br>&gt;&gt;  init?&lt;Source: Integer&gt;(exactly value: Source)<br>&gt; <br>&gt;&gt;  init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source)<br>&gt;&gt;  init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source)<br>&gt; <br>&gt; It&#39;s great to have both of these, but I wonder how they&#39;re going to be implemented—if Integer can be either signed or unsigned, I&#39;m not sure how you get the top bit of an unsigned integer out.<br></p><p>These are the bits that are dependent on the new Integer proposal, which should be forthcoming soonish.  As you note, they aren’t really implementable without it (at least, not easily).  However, I thought that it made the most sense to include them with this proposal.<br></p><p>&gt; Also, since `init(_:)` is lossy and `init(exactly:)` is not, shouldn&#39;t their names technically be switched? Or perhaps `init(_:)` should be exact and trapping, `init(exactly:)` should be failable, and `init(closest:)` should always return something or other?<br></p><p>That would be a large change in the existing behavior, since we only have the (potentially lossy) init(_:) today.  It would also be something of a surprise to users of C family languages.  That’s not to say that it’s necessarily wrong, but it would break a lot of people’s code an expectations, and I was trying to make this proposal fairly benign, with a focus on adding missing features.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;&gt; Are there potential conforming types which aren&#39;t Comparable?<br>&gt; <br>&gt; Not at present, but I expect there to be in the future.  Modular integers and complex numbers come to mind as the most obvious examples.<br></p><p>Ooh, those are great examples. That is definitely the right decision, then.<br></p><p>(One thing I&#39;ve been vaguely concerned with is dimensional analysis. A strong type system opens up the possibility of marking numbers with units, or at least dimensions, so that the type system can catch when you try to pass a Second&lt;Pound&lt;T&gt;&gt; to a call that&#39;s expecting a Second&lt;Newton&lt;T&gt;&gt;. Doing this properly requires more freedom in the multiplication and division operators&#39; parameters and return values—but of course, it also requires higher-kinded types to construct the right return values, so it&#39;s out of reach for Swift 3 anyway.)<br></p><p>&gt;&gt;&gt; /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;&gt;&gt; /// payloads as zero, or mask them to create an admissible payload.<br>&gt;&gt;&gt; static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; This seems unusually tolerant of bad inputs. Should this instead be a precondition, and have an (elidable in unchecked mode) trap if it&#39;s violated?<br>&gt; <br>&gt; I don’t think that it’s a particularly useful error to detect,<br></p><p>Maybe it&#39;s just my lack of knowledge, but I feel like, if you are calling this method, you probably care about getting that payload into the resulting NaN. Otherwise you would be using the `nan` property. (There is no `signalingNan` property, but there could be.)<br></p><p>What do people use NaN payloads for? Are there a lot of cases where the payload is a nice-to-have, but it&#39;s okay to destroy or even mangle it?<br></p><p>&gt; and different floating point types may differ greatly in what payloads they support (if any), because they might choose to reserve those encodings for other purposes.<br></p><p>If the data you can actually get into a NaN varies so much from one type to another, is this API a useful one to offer on the protocol? Is it something you can reliably use on &quot;any floating-point type&quot; without knowing which type it is?<br></p><p>(It also now occurs to me that this might be better off as an initializer: `init(nanWithPayload:signaling:)`.)<br></p><p>&gt;&gt; Reading these, I find the use of &quot;least&quot; a little bit misleading—it seems like they should be negative.<br>&gt; <br>&gt; Magnitudes are strictly positive.  In fairness, that may not be immediately obvious to all readers.<br></p><p>It does make sense now that you&#39;ve said so! It might be a good doc comment note, though.<br></p><p>&gt;&gt; 	static var positiveNormals: ClosedRange&lt;Self&gt; { get }<br>&gt;&gt; 	static var positiveSubnormals: ClosedRange&lt;Self&gt; { get }<br>&gt;&gt; <br>&gt;&gt; 	Double.positiveNormals.upperBound		// DBL_MAX<br>&gt;&gt; 	Double.positiveNormals.lowerBound		// DBL_MIN<br>&gt;&gt; 	Double.positiveSubnormals.upperBound	// Self.positiveNormals.lowerBound.nextDown<br>&gt;&gt; 	Double.positiveSubnormals.lowerBound	// 0.nextUp<br>&gt; <br>&gt; This seems wildly over-engineered to me personally.  Every language I surveyed provides (a subset of) these quantities as simple scalar values.<br></p><p>Well, I am rather prone to wild over-engineering. :^)<br></p><p>One place where a range like FloatingPoint.positives would be useful is in random number generation. Suppose you have:<br></p><p>	protocol Randomizer {<br>		…<br>		mutating func choice&lt;T: FloatingPoint&gt;(from choices: ClosedRange&lt;T&gt;) -&gt; T<br>		…<br>	}<br></p><p>Which lets you say:<br></p><p>	rng.choice(from: 0...1)<br></p><p>It would then be nice to say something like:<br></p><p>	rng.choice(from: Double.positives)<br>	rng.choice(from: Float.finites)<br>	// etc.<br></p><p>Of course, the set of ranges useful for that purpose is probably different from these more technical things, so that might not be the best design anyway.<br></p><p>&gt;&gt;&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;&gt;&gt; func isLess(than other: Self) -&gt; Bool<br>&gt;&gt;&gt; func totalOrder(with other: Self) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; Swift 2&#39;s Comparable demands a strict total order. However, the documentation here seems to imply that totalOrder is *not* what you get from the &lt; operator. Is something getting reshuffled here?<br>&gt; <br>&gt; The Swift 2 Comparable documentation is probably overly specific.  The requirement should really be something like a strict total order on non-exceptional values.<br></p><p>Okay.<br></p><p>(While I was waiting for your reply, I was thinking about a rework of `Comparable` which had a sort-oriented `totalOrder(_:)` as a requirement and `isLess(_:)`, `isGreater(_:)`, et. al. which defaulted to using `totalOrder(_:)`, but could be overridden for types like FloatingPoint with exceptional values. I should just wait for answers sometimes.)<br></p><p>&gt;&gt; Also, since `init(_:)` is lossy and `init(exactly:)` is not, shouldn&#39;t their names technically be switched? Or perhaps `init(_:)` should be exact and trapping, `init(exactly:)` should be failable, and `init(closest:)` should always return something or other?<br>&gt; <br>&gt; That would be a large change in the existing behavior, since we only have the (potentially lossy) init(_:) today.  It would also be something of a surprise to users of C family languages.  That’s not to say that it’s necessarily wrong, but it would break a lot of people’s code an expectations, and I was trying to make this proposal fairly benign, with a focus on adding missing features.<br></p><p>Sure, but it&#39;s also a surprise when integers don&#39;t roundtrip through floats. (See: every JSON-based API which had to add an &quot;id_str&quot; field when their ID numbers got too big.) I&#39;m not entirely certain it&#39;s the right move—you&#39;re right that people with a C background wouldn&#39;t expect it—but silently doing the wrong thing is a bit suspicious in Swift.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>April 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:07 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 8:34 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Stephen Canon wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol Arithmetic<br>&gt;&gt; <br>&gt;&gt; Is there a rationale for the name &quot;Arithmetic&quot;? There&#39;s probably nothing wrong with it, but I would have guessed you&#39;d use the name &quot;Number”.<br>&gt; <br>&gt; Dave A. came up with the name, though I think it’s a good one.  Number isn’t bad either.<br></p><p>Does Number hew too close to Foundation&#39;s NSNumber name?<br></p><p>`Arithmetic` provides a beautiful hook for grammar pedants: as a protocol name it ought to be pronounced as the adjective &quot;arithMEtic&quot; and not the noun &quot;aRITHmetic&quot;. Complaining about that sounds like fun to me, but naming the protocol `Arithmetical` would avoid that issue if others disagree.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>This proposal looks really really great, let me know when you want to start the review process (or just submit a PR for the -evolution repo) and I’ll happily review manage it for you.<br></p><p>On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>Nice, have you considered adding pi/e and other common constants?  I’d really really like to see use of M_PI go away… :-)<br></p><p>&gt; <br>&gt; /// SignedArithmetic protocol will only be conformed to by signed numbers,<br>&gt; /// otherwise it would be possible to negate an unsigned value.<br>&gt; ///<br>&gt; /// The only method of this protocol has the default implementation in an<br>&gt; /// extension, that uses a parameterless initializer and subtraction.<br>&gt; public protocol SignedArithmetic : Arithmetic {<br>&gt;   func negate() -&gt; Self<br>Should this be negated / negate?  negate() seems like an in-place mutating version.<br></p><p>&gt; /// A floating-point type that provides most of the IEEE 754 basic (clause 5)<br>Dumb Q, but is it “IEEE 754” or “IEEE-754”?<br></p><p><br>&gt; /// operations.  The base, precision, and exponent range are not fixed in<br>&gt; /// any way by this protocol, but it enforces the basic requirements of<br>&gt; /// any IEEE 754 floating-point type.<br>&gt; ///<br>&gt; /// The BinaryFloatingPoint protocol refines these requirements and provides<br>&gt; /// some additional useful operations as well.<br>&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt; <br>&gt;   static var ulp: Self { get }<br>&gt;   var ulp: Self { get }<br>Swift supports instance and type members with the same names, but this is controversial, leads to confusion, and may go away in the future.  It would be great to avoid this in your design.<br></p><p><br>&gt; <br>&gt; <br>&gt;   //  TODO: strictly speaking a bit and a bool are slightly different<br>&gt;   //  concepts.  Is another name more appropriate for this property?<br>&gt;   //  `isNegative` is incorrect because of -0 and NaN.  `isSignMinus` might<br>&gt;   //  be acceptable, but isn&#39;t great.  `signBit` is the IEEE 754 name.<br>&gt;   var signBit: Bool { get }<br>I think you have this right, by calling it a bit and typing it as a Bool -using a Bool to represent a specific bit from Self seems right. <br></p><p><br>&gt;   /// The significand satisfies:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// self = (signBit ? -1 : 1) * significand * radix**exponent<br>** isn’t a defined swift operator, it would be nice to change the comment to use something a swift programmer would recognize.<br></p><p><br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// If radix is 2 (the most common case), then for finite non-zero numbers<br>&gt;   /// `1 &lt;= significand` and `significand &lt; 2`.  For other values of `x`,<br>&gt;   /// `x.significand` is defined as follows:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.significand` is 0.0.<br>&gt;   /// - If `x` is infinity, then `x.significand` is 1.0.<br>&gt;   /// - If `x` is NaN, then `x.significand` is NaN.<br>...<br>&gt;   var significand: Self { get }<br>I’m certainly not a floating point guru, but I would have expected significant to be of type RawSignificand, and thought that the significant of a nan would return its payload.  Does this approach make sense?<br></p><p>… later: I see that you have this on the binary FP type, so I assume there is a good reason for this :-)<br></p><p>&gt;   /// Because of these properties, this initializer implements the IEEE 754<br>&gt;   /// `scaleB` operation.<br>&gt;   init(signBit: Bool, exponent: Int, significand: Self)<br>Stylistic question, but why list the initializers after members?<br></p><p><br>&gt; <br>&gt;   /// Mutating form of square root.<br>&gt;   mutating func formSquareRoot( )<br>extra space in the parens?<br></p><p><br>&gt; <br>&gt;   /// Fused multiply-add, accumulating the product of `lhs` and `rhs` to `self`.<br>&gt;   mutating func addProduct(lhs: Self, _ rhs: Self)<br>Stylistic, but it is easier to read with the mutating next to the non-mutating pairs.<br></p><p>&gt;   /// True if and only if `self` is subnormal.<br>&gt;   ///<br>&gt;   /// A subnormal number does not use the full precision available to normal<br>&gt;   /// numbers of the same format.  Zero is not a subnormal number.<br>&gt;   var isSubnormal: Bool { get }<br>I’m used to this being called a “Denormal”, but I suspect that “subnormal” is the actually right name?  Maybe it would be useful to mention the “frequently known as denormal” in the comment, like you did with mantissa earlier.<br></p><p>&gt; Impact on existing code<br>&gt; <br>&gt; The % operator is no longer available for FloatingPoint types. We don&#39;t believe that it was widely used correctly, and the operation is still available via the formTruncatingRemainder method for people who need it.<br>&gt; <br>Also worth mentioning that this operator is not supported in popular languages like C either.<br></p><p>-Chris<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/04c82aa1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>Thanks for the feedback, Chris.<br></p><p>&gt; On Apr 14, 2016, at 9:06 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; This proposal looks really really great, let me know when you want to start the review process (or just submit a PR for the -evolution repo) and I’ll happily review manage it for you.<br>&gt; <br>&gt; On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt; Nice, have you considered adding pi/e and other common constants?  I’d really really like to see use of M_PI go away… :-)<br></p><p>That’s a reasonable suggestion.  I’m not sure if FloatingPoint is the right protocol to attach them to, but I’m not sure that it’s wrong either.  I’d be interested to hear arguments from the community either way.<br></p><p>&gt;&gt; /// SignedArithmetic protocol will only be conformed to by signed numbers,<br>&gt;&gt; /// otherwise it would be possible to negate an unsigned value.<br>&gt;&gt; ///<br>&gt;&gt; /// The only method of this protocol has the default implementation in an<br>&gt;&gt; /// extension, that uses a parameterless initializer and subtraction.<br>&gt;&gt; public protocol SignedArithmetic : Arithmetic {<br>&gt;&gt;   func negate() -&gt; Self<br>&gt; Should this be negated / negate?  negate() seems like an in-place mutating version.<br></p><p>Yup, that seems right.<br></p><p>&gt;&gt; /// A floating-point type that provides most of the IEEE 754 basic (clause 5)<br>&gt; Dumb Q, but is it “IEEE 754” or “IEEE-754”?<br></p><p>It’s commonly styled both ways, but I believe IEEE 754 is the “official&quot; one.<br></p><p>&gt;&gt; /// operations.  The base, precision, and exponent range are not fixed in<br>&gt;&gt; /// any way by this protocol, but it enforces the basic requirements of<br>&gt;&gt; /// any IEEE 754 floating-point type.<br>&gt;&gt; ///<br>&gt;&gt; /// The BinaryFloatingPoint protocol refines these requirements and provides<br>&gt;&gt; /// some additional useful operations as well.<br>&gt;&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;&gt; <br>&gt;&gt;   static var ulp: Self { get }<br>&gt;&gt;   var ulp: Self { get }<br>&gt; Swift supports instance and type members with the same names, but this is controversial, leads to confusion, and may go away in the future.  It would be great to avoid this in your design.<br></p><p>Interesting.  Both are definitely useful, but Type(1).ulp is sufficiently simple that only having the instance member may be good enough.  Otherwise, ulpOfOne or similar could work.<br></p><p>&lt;snip&gt;<br></p><p>&gt; I’m certainly not a floating point guru, but I would have expected significant to be of type RawSignificand, and thought that the significant of a nan would return its payload.  Does this approach make sense?<br>&gt; <br>&gt; … later: I see that you have this on the binary FP type, so I assume there is a good reason for this :-)<br></p><p>Both are useful to have in practice.  I have been attempting to keep the assumptions about representation to a minimum in the top-level FloatingPoint protocol.<br></p><p>&lt;snip a few style notes that I’ll simply take as-is because they’re no-brainers&gt;<br></p><p>&gt;&gt;   /// True if and only if `self` is subnormal.<br>&gt;&gt;   ///<br>&gt;&gt;   /// A subnormal number does not use the full precision available to normal<br>&gt;&gt;   /// numbers of the same format.  Zero is not a subnormal number.<br>&gt;&gt;   var isSubnormal: Bool { get }<br>&gt; I’m used to this being called a “Denormal”, but I suspect that “subnormal” is the actually right name?  Maybe it would be useful to mention the “frequently known as denormal” in the comment, like you did with mantissa earlier.<br></p><p>Yes, “subnormal” is the preferred IEEE 754 terminology, but I’ll add a note referencing “denormal” as well.<br></p><p>Thanks,<br>– Steve<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/98c40c19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 11:00:00pm</p></header><div class="content"><p>On Apr 14, 2016, at 9:49 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt;&gt; Nice, have you considered adding pi/e and other common constants?  I’d really really like to see use of M_PI go away… :-)<br>&gt; <br>&gt; That’s a reasonable suggestion.  I’m not sure if FloatingPoint is the right protocol to attach them to, but I’m not sure that it’s wrong either.  I’d be interested to hear arguments from the community either way.<br></p><p>I’m not sure where the right place is either, I just want them :-)   Seriously though, the notion of pi seems to make sense for both decimal and binary fp types, it seems base independent.<br></p><p>&gt;&gt; Swift supports instance and type members with the same names, but this is controversial, leads to confusion, and may go away in the future.  It would be great to avoid this in your design.<br>&gt; <br>&gt; Interesting.  Both are definitely useful, but Type(1).ulp is sufficiently simple that only having the instance member may be good enough.  Otherwise, ulpOfOne or similar could work.<br></p><p>Either of those work for me.<br></p><p>&gt; <br>&gt;&gt; I’m certainly not a floating point guru, but I would have expected significant to be of type RawSignificand, and thought that the significant of a nan would return its payload.  Does this approach make sense?<br>&gt;&gt; <br>&gt;&gt; … later: I see that you have this on the binary FP type, so I assume there is a good reason for this :-)<br>&gt; <br>&gt; Both are useful to have in practice.  I have been attempting to keep the assumptions about representation to a minimum in the top-level FloatingPoint protocol.<br></p><p>Makes sense!<br></p><p>&gt;&gt; I’m used to this being called a “Denormal”, but I suspect that “subnormal” is the actually right name?  Maybe it would be useful to mention the “frequently known as denormal” in the comment, like you did with mantissa earlier.<br>&gt; <br>&gt; Yes, “subnormal” is the preferred IEEE 754 terminology, but I’ll add a note referencing “denormal” as well.<br></p><p>Thanks!<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/63f359b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 11:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 14, 2016, at 9:49 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt;&gt;&gt; Nice, have you considered adding pi/e and other common constants?  I’d really really like to see use of M_PI go away… :-)<br>&gt;&gt; <br>&gt;&gt; That’s a reasonable suggestion.  I’m not sure if FloatingPoint is the right protocol to attach them to, but I’m not sure that it’s wrong either.  I’d be interested to hear arguments from the community either way.<br>&gt; <br>&gt; I’m not sure where the right place is either, I just want them :-)   Seriously though, the notion of pi seems to make sense for both decimal and binary fp types, it seems base independent.<br></p><p>Incidentally, if you make pi and e be static members of the type, we should get a pretty fluent style, along the lines of:<br></p><p>	let x = someDouble * 2 * .pi<br></p><p>I agree that there is a concern about deciding “which” constants to include.  I’ll let you and the numeric elite figure that out :-)<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160414/c7a17a1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 11:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 11:01 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 14, 2016, at 9:49 PM, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt;&gt;&gt;&gt; Nice, have you considered adding pi/e and other common constants?  I’d really really like to see use of M_PI go away… :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s a reasonable suggestion.  I’m not sure if FloatingPoint is the right protocol to attach them to, but I’m not sure that it’s wrong either.  I’d be interested to hear arguments from the community either way.<br>&gt;&gt; <br>&gt;&gt; I’m not sure where the right place is either, I just want them :-)   Seriously though, the notion of pi seems to make sense for both decimal and binary fp types, it seems base independent.<br>&gt; <br>&gt; Incidentally, if you make pi and e be static members of the type, we should get a pretty fluent style, along the lines of:<br>&gt; <br>&gt; 	let x = someDouble * 2 * .pi<br>&gt; <br>&gt; I agree that there is a concern about deciding “which” constants to include.  I’ll let you and the numeric elite figure that out :-)<br></p><p>“e” is a great bike-shedding example.  While it would definitely allow a fluent style if you know what you’re looking at, I worry a little bit about readability of `Float.e` or `.e` in source.  Most programmers are at least passingly familiar with pi, but that familiarity doesn’t necessarily extend to e.  IDEs and docstrings make this palatable, of course.<br></p><p>I wonder if maybe we shouldn’t expose `.pi` directly, but tuck other constants behind something like `.math.e`.  It’s slightly inconsistent, but might be the pragmatic solution.  If we did this, we could be a bit more aggressive about what constants were included without worrying about being too confusing.  I would probably expose most of what’s in math.h initially:<br></p><p>	pi, 1/pi, e, log2(e), log10(e), log(2), log(10), sqrt(2), 1/sqrt(2)<br></p><p>The other question is how these play with arbitrary-precision types, if someone wants to write one that conforms to Floating Point.  Usually in arbitrary-precision libraries, these would be functions (desiredPrecision: Int) -&gt; Self, but they could also be implemented as a future that gets evaluated to the desired precision when used or something similar.  If we add these to the protocols, I wouldn’t want to constrain the design space arbitrarily.  The most conservative approach would be to just add them to the concrete types.  We could also put them in a FixedWidthFloatingPoint protocol for now if necessary.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/236101b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>On Apr 15, 2016, at 8:20 AM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Incidentally, if you make pi and e be static members of the type, we should get a pretty fluent style, along the lines of:<br>&gt;&gt; <br>&gt;&gt; 	let x = someDouble * 2 * .pi<br>&gt;&gt; <br>&gt;&gt; I agree that there is a concern about deciding “which” constants to include.  I’ll let you and the numeric elite figure that out :-)<br>&gt; <br>&gt; “e” is a great bike-shedding example.  While it would definitely allow a fluent style if you know what you’re looking at, I worry a little bit about readability of `Float.e` or `.e` in source.  Most programmers are at least passingly familiar with pi, but that familiarity doesn’t necessarily extend to e.  IDEs and docstrings make this palatable, of course.<br>&gt; <br>&gt; I wonder if maybe we shouldn’t expose `.pi` directly, but tuck other constants behind something like `.math.e`.<br></p><p>Yes, I think this is a great approach.  In my (totally limited and arbitrary) experience, Pi is used orders of magnitude more commonly than other non-trivial constants.<br></p><p>This is another situation where I wish we had real submodules and generic properties already.  At that point, we could these constants defined in the Math submodule, and even give them unicode aliases like π.  Then you’d get this sort of behavior:<br></p><p>let _ = 2*.pi*b    // works everywhere.<br>let _ = y + Math.e + .pi  // works everywhere, for all the weird constants you want to dump into the math module.<br>let _ = 2 * Math.π * b    // works everywhere.<br></p><p>func doMathStuff() {   // some local scode<br>  import Math<br>  let _ = y + e + .pi     // works because we imported Math.<br>  let _ = 2 * π * b        // works because we imported Math.<br>}<br></p><p>That said, we don’t have those features, so perhaps the discussion should be scoped to just adding the pi member for swift 3.<br></p><p>&gt; The other question is how these play with arbitrary-precision types, if someone wants to write one that conforms to Floating Point.  Usually in arbitrary-precision libraries, these would be functions (desiredPrecision: Int) -&gt; Self, but they could also be implemented as a future that gets evaluated to the desired precision when used or something similar.  If we add these to the protocols, I wouldn’t want to constrain the design space arbitrarily.  The most conservative approach would be to just add them to the concrete types.  We could also put them in a FixedWidthFloatingPoint protocol for now if necessary.<br></p><p>It would be unfortunate if these weren’t supported by (e.g.) the binary FP protocol at least, since that would defeat code trying to use type-generic FP algorithms.<br></p><p>Does the rest of your design scale to arbitrary precision types?  Is arbitrary precision FP used in any common or important domain?  If not, it seems worth throwing under the bus to get better utility for the types that non-specialists actually use in practice. <br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 8:20 AM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; “e” is a great bike-shedding example.  While it would definitely allow a fluent style if you know what you’re looking at, I worry a little bit about readability of `Float.e` or `.e` in source.  Most programmers are at least passingly familiar with pi, but that familiarity doesn’t necessarily extend to e.  IDEs and docstrings make this palatable, of course.<br></p><p>It&#39;s also questionable to me how often `e` itself is interesting independent of an exp() or log() operation.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 15, 2016 at 12:00:00pm</p></header><div class="content"><p>On Apr 15: 2016: at 11:56 AM: Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 15: 2016: at 8:20 AM: Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; “e” is a great bike-shedding example.  While it would definitely allow a fluent style if you know what you’re looking at: I worry a little bit about readability of `Float.e` or `.e` in source.  Most programmers are at least passingly familiar with pi: but that familiarity doesn’t necessarily extend to e.  IDEs and docstrings make this palatable: of course.<br>&gt; <br>&gt; It&#39;s also questionable to me how often `e` itself is interesting independent of an exp() or log() operation.<br></p><p>I&#39;m sure it gets used but I&#39;d imagine it would be at an order of magnitude or more less than PI. Quick gist count:<br></p><p>M_E: 109<br>M_LOG2E: 23<br>M_LOG10E: 19<br>M_LN2: 24<br>M_LN10: 10<br>M_PI: 2,231<br>M_PI_2: 255<br>M_PI_4: 54<br>M_1_PI: 27<br>M_2_PI: 25<br>M_2_SQRTPI: 23<br>M_SQRT2: 31<br>M_SQRT1_2: 26<br></p><p>That said, I use M_PI_4 a lot because it&#39;s really handy for sample code. I&#39;m one of the<br>outlier users whose use is not reflective of this quick check.<br></p><p>* With M_PI at 2,231 and M_E at 109, I think you can conclude that some constants really are used more<br>often than others.<br>* As my personal case reflects, less popular constants are sometimes heavily used in niche cases<br></p><p>Finally, it&#39;s Swift. Isn&#39;t it time for π and 𝜏 as well as Pi and Tau?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/fcfd1aeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 11:14 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; On Apr 15: 2016: at 11:56 AM: Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 15: 2016: at 8:20 AM: Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “e” is a great bike-shedding example.  While it would definitely allow a fluent style if you know what you’re looking at: I worry a little bit about readability of `Float.e` or `.e` in source.  Most programmers are at least passingly familiar with pi: but that familiarity doesn’t necessarily extend to e.  IDEs and docstrings make this palatable: of course.<br>&gt;&gt; <br>&gt;&gt; It&#39;s also questionable to me how often `e` itself is interesting independent of an exp() or log() operation.<br>&gt; <br>&gt; I&#39;m sure it gets used but I&#39;d imagine it would be at an order of magnitude or more less than PI. Quick gist count:<br>&gt; <br>&gt; M_E: 109<br>&gt; M_LOG2E: 23<br>&gt; M_LOG10E: 19<br>&gt; M_LN2: 24<br>&gt; M_LN10: 10<br>&gt; M_PI: 2,231<br>&gt; M_PI_2: 255<br>&gt; M_PI_4: 54<br>&gt; M_1_PI: 27<br>&gt; M_2_PI: 25<br>&gt; M_2_SQRTPI: 23<br>&gt; M_SQRT2: 31<br>&gt; M_SQRT1_2: 26<br>&gt; <br>&gt; That said, I use M_PI_4 a lot because it&#39;s really handy for sample code. I&#39;m one of the<br>&gt; outlier users whose use is not reflective of this quick check.<br></p><p>M_PI_2 and M_PI_4 are interesting cases; they date back to a time when compilers couldn’t be trusted to constant-fold computations like M_PI / 2.  Since Swift quite reliably does this transformation, I would prefer to simply use the more explicit .pi / 2.  How does that strike you as a user?<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/df59aae4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 15, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 12:22 PM, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 15, 2016, at 11:14 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; That said, I use M_PI_4 a lot because it&#39;s really handy for sample code. I&#39;m one of the<br>&gt;&gt; outlier users whose use is not reflective of this quick check.<br>&gt; <br>&gt; M_PI_2 and M_PI_4 are interesting cases; they date back to a time when compilers couldn’t be trusted to constant-fold computations like M_PI / 2.  Since Swift quite reliably does this transformation, I would prefer to simply use the more explicit .pi / 2.  How does that strike you as a user?<br>&gt; <br>&gt; – Steve<br></p><p>I cannot really defend my use other than to say they are comfortable constants, ones that I read easily. <br>Should Swift eliminate them I do not believe my code would suffer beyond muscle memory. Newer <br>users don&#39;t necessarily resonate to them the same way, either.<br></p><p>I do think that adding both .pi and .π and using .π/4.0 would be the most readable expression of intent.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/a0fbe4b4/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 15, 2016 at 12:00:00pm</p></header><div class="content"><p>On Apr 15: 2016: at 11:56 AM: Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 15: 2016: at 8:20 AM: Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; “e” is a great bike-shedding example.  While it would definitely allow a fluent style if you know what you’re looking at: I worry a little bit about readability of `Float.e` or `.e` in source.  Most programmers are at least passingly familiar with pi: but that familiarity doesn’t necessarily extend to e.  IDEs and docstrings make this palatable: of course.<br>&gt; <br>&gt; It&#39;s also questionable to me how often `e` itself is interesting independent of an exp() or log() operation.<br></p><p>I&#39;m sure it gets used but I&#39;d imagine it would be at an order of magnitude or more less than PI. Quick gist count:<br></p><p>M_E: 109<br>M_LOG2E: 23<br>M_LOG10E: 19<br>M_LN2: 24<br>M_LN10: 10<br>M_PI: 2,231<br>M_PI_2: 255<br>M_PI_4: 54<br>M_1_PI: 27<br>M_2_PI: 25<br>M_2_SQRTPI: 23<br>M_SQRT2: 31<br>M_SQRT1_2: 26<br></p><p>That said, I use M_PI_4 a lot because it&#39;s really handy for sample code. I&#39;m one of the<br>outlier users whose use is not reflective of this quick check.<br></p><p>* With M_PI at 2,231 and M_E at 109, I think you can conclude that some constants really are used more<br>often than others.<br>* As my personal case reflects, less popular constants are sometimes heavily used in niche cases<br></p><p>Finally, it&#39;s Swift. Isn&#39;t it time for π and 𝜏 as well as Pi and Tau?<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/dba59c23/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>April 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 11:15, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Finally, it&#39;s Swift. Isn&#39;t it time for π and 𝜏 as well as Pi and Tau?<br></p><p>Yes! I was waiting to bring up tau.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>In general, I think this is fantastic. In particular, I *really* like the notion that `BinaryFloatingPoint` conforms to `FloatingPoint`. I would do a few things differently, though:<br>&gt; On Apr 14, 2016, at 6:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;   ...<br>&gt;   /// The greatest finite number.<br>&gt;   ///<br>&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;   /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.<br>&gt;   /// The naming of those macros is slightly misleading, because infinity<br>&gt;   /// is greater than this value.<br>&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt;   ...<br>&gt; }<br></p><p>Why put this in FloatingPoint? The concept is valid for any real type (IMHO, it’s valid for rectangular Complex/Quaternion/etc types as well... I’m not sure if it is for the various polar formats, though). I think a better place for it is either in `Arithmetic`, or another protocol to which `Arithmetic` conforms:<br>protocol HasMinAndMaxFiniteValue {<br>    static var maxFinite: Self {get} // I think “max”/“min&quot; are clear enough (especially if the docs are explicit), but I understand the objection<br>    static var minFinite: Self {get} // 0 for unsigned types<br>}<br>This would unify the syntax for getting a numeric type’s min or max finite value across all the built-in numeric types (this means that `Int.max` would become `Int.maxFinite`). Similarly, IMHO infinity shouldn’t be tied to floating point types. While it’s true that the *native* integer types don’t support infinity, arbitrary precision integer types might.<br>protocol HasInfinity {<br>    static var infinity: Self {get}<br>}<br></p><p><br></p><p>&gt; /// Arithmetic protocol declares methods backing binary arithmetic operators,<br>&gt; /// such as  `+`, `-` and `*`; and their mutating counterparts.  These methods<br>&gt; /// operate on arguments of the same type.<br>&gt; ...<br>&gt; public protocol Arithmetic: Equatable, IntegerLiteralConvertible {<br>&gt;   init()<br>&gt;   func adding(rhs: Self) -&gt; Self<br>&gt;   mutating func add(rhs: Self)<br>&gt;   func subtracting(rhs: Self) -&gt; Self<br>&gt;   mutating func subtract(rhs: Self)<br>&gt;   func multiplied(by rhs: Self) -&gt; Self<br>&gt;   mutating func multiply(by rhs: Self)<br>&gt;   func divided(by rhs: Self) -&gt; Self<br>&gt;   mutating func divide(by rhs: Self)<br>&gt; }<br></p><p>I’d restructure this a bit:<br>protocol Arithmetic { //AFAIK *all* numeric types should be able to do these<br>    init()<br>    func adding(rhs: Self) -&gt; Self<br>    mutating func add(rhs: Self)<br>    func subtracting(rhs: Self) -&gt; Self<br>    mutating func subtract(rhs: Self)<br>}<br>protocol ScalarArithmetic : Arithmetic { //These can be iffy for non-scalar types<br>    func multiplied(by rhs: Self) -&gt; Self<br>    mutating func multiply(by rhs: Self)<br>    func divided(by rhs: Self) -&gt; Self<br>    mutating func divide(by rhs: Self)<br>}<br></p><p>Multiplication isn&#39;t always defined for any two arbitrarily-dimensioned matrices (plus, there are so many reasonable matrix “subtypes” that there&#39;s no guarantee that the return type should always be the same), and I don’t think there’s a generally agreed-upon meaning for matrix division at all.<br></p><p>[Slight_Rabbit_Trail] For a while, I was trying to get work around the issue in my own code by doing something like (this was before the change to “associatedtype”):<br>public protocol MathLibNumberType {<br>    typealias AddType<br>    typealias AddReturnType<br>    ...    <br>    func +(_: Self, _: Self.AddType) -&gt; Self.AddReturnType<br>    ...<br>}<br>But there was some problem when I got to this part:<br>public protocol ScalarType : MathLibNumberType {<br>    typealias AddType = Self<br>    typealias AddReturnType = Self<br>    ...<br>}<br>extension Int : ScalarType {}<br>I can’t remember what the exact problem was anymore. It’s been a while… I think maybe even pre-Swift 2.  Hmm… maybe I should try it again...<br>[/Slight_Rabbit_Trail] <br></p><p>Anyway, those are my thoughts on the matter.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/f09f9055/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:47 PM, davesweeris at mac.com wrote:<br>&gt; <br>&gt; In general, I think this is fantastic. In particular, I *really* like the notion that `BinaryFloatingPoint` conforms to `FloatingPoint`. I would do a few things differently, though:<br>&gt;&gt; On Apr 14, 2016, at 6:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;&gt;   ...<br>&gt;&gt;   /// The greatest finite number.<br>&gt;&gt;   ///<br>&gt;&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;&gt;   /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.<br>&gt;&gt;   /// The naming of those macros is slightly misleading, because infinity<br>&gt;&gt;   /// is greater than this value.<br>&gt;&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt;&gt;   ...<br>&gt;&gt; }<br>&gt; <br>&gt; Why put this in FloatingPoint? The concept is valid for any real type (IMHO, it’s valid for rectangular Complex/Quaternion/etc types as well... I’m not sure if it is for the various polar formats, though). I think a better place for it is either in `Arithmetic`, or another protocol to which `Arithmetic` conforms:<br>&gt; <br>&gt; protocol HasMinAndMaxFiniteValue {<br>&gt;     static var maxFinite: Self {get} // I think “max”/“min&quot; are clear enough (especially if the docs are explicit), but I understand the objection<br>&gt;     static var minFinite: Self {get} // 0 for unsigned types<br>&gt; }<br></p><p>As mentioned in reply to Brent, there may very well be Arithmetic types without a real notion of magnitude (modular integers).  There’s also a complication that the magnitude of a Complex&lt;T&gt; shouldn’t be complex, but rather real, and also isn’t usually representable as a T (the one exception is polar forms, where it *is* representable =).<br></p><p>&gt; This would unify the syntax for getting a numeric type’s min or max finite value across all the built-in numeric types (this means that `Int.max` would become `Int.maxFinite`). Similarly, IMHO infinity shouldn’t be tied to floating point types. While it’s true that the *native* integer types don’t support infinity, arbitrary precision integer types might.<br>&gt; <br>&gt; protocol HasInfinity {<br>&gt;     static var infinity: Self {get}<br>&gt; }<br></p><p>I think that integer max and min behave sufficiently differently from the FloatingPoint quantities that it’s not particularly useful to unify their names.  Most obviously, all integers between min and max are representable for integers, and this is very much not the case for floating point types.<br></p><p>&gt; I’d restructure this a bit:<br>&gt; protocol Arithmetic { //AFAIK *all* numeric types should be able to do these<br>&gt;     init()<br>&gt;     func adding(rhs: Self) -&gt; Self<br>&gt;     mutating func add(rhs: Self)<br>&gt;     func subtracting(rhs: Self) -&gt; Self<br>&gt;     mutating func subtract(rhs: Self)<br>&gt; }<br>&gt; protocol ScalarArithmetic : Arithmetic { //These can be iffy for non-scalar types<br>&gt;     func multiplied(by rhs: Self) -&gt; Self<br>&gt;     mutating func multiply(by rhs: Self)<br>&gt;     func divided(by rhs: Self) -&gt; Self<br>&gt;     mutating func divide(by rhs: Self)<br>&gt; }<br>&gt; <br>&gt; Multiplication isn&#39;t always defined for any two arbitrarily-dimensioned matrices (plus, there are so many reasonable matrix “subtypes” that there&#39;s no guarantee that the return type should always be the same), and I don’t think there’s a generally agreed-upon meaning for matrix division at all.<br></p><p>There’s a natural tension of exactly what structure in the hierarchy of semigroups, groups, rings, etc is the baseline to be “numbery”.  While it’s not totally obvious that division should be required, neither is it obvious that it should be excluded.<br></p><p>I should note that for non-scalar types, multiplication and division are frequently more reasonable than addition and subtraction.  E.g. the orthogonal matrix groups and unitary quaternions are closed under multiplication but not addition.<br></p><p>Ultimately, we may want to have a finer-grained classification of numeric protocols, but “schoolbook arithmetic” is a pretty reasonable set of operations while we’re picking just one.<br></p><p>– Steve<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/b5287cf5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; <br>&gt; Ultimately, we may want to have a finer-grained classification of numeric protocols, but “schoolbook arithmetic” is a pretty reasonable set of operations while we’re picking just one.<br>&gt; <br>&gt; – Steve<br>&gt; <br></p><p>The only thing I want to add to this fantastic discussion is that, while &quot;schoolbook arithmetic&quot; should have priority above all else, I&#39;m dreaming about using well-designed language features for quaternions, complex math, matrices, and galiois fields. :)<br></p><p>- Will<br></p><p>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>+1; this is great!<br></p><p>I have nothing but good things to say about the proposal itself.<br></p><p>I have two smaller questions, however; I apologize if they are off-topic.<br></p><p>One is if there’s any ETA or similar for a glimpse at the “complete picture” of Swift’s revised numeric protocols; these floating-point protocols look really, really good, but this is also (I think) the first glimpse at the new `Arithmetic` protocol, and there’s also a new “Integer” protocol coming…and it’d be nice to get a sense of the complete vision here.<br></p><p>My other question is potentially subsumed by the above, but I want to raise it now: it’d be great if there was some standardized protocol/vocabulary to use when converting between various numeric representations that was:<br></p><p>- easy for custom numeric types to *adopt* correctly (e.g. if one were to write a fixed-point type, or a rational type, etc.)<br>- easy for non-experts to *use* correctly for non-expert purposes<br></p><p>…since such conversions from one representation to another are at least IMHO a dangerous area; if you know what you’re doing it’s not dangerous, but e.g. even if someone is only trying to go from Double -&gt; Int:<br></p><p>- they probably aren’t an expert, doing expert numerical things<br>- they may not have a solid understanding of floating point (NaN, infinities, etc.)<br>- they thus may not know they may *need* to be careful here<br>- they may not know *how* to be careful, even if they know they *should* be<br>- they may not be able to be careful *correctly*, even if they attempt it<br></p><p>…and so it’d again be great if the revised numeric protocols allow as broad a range of such conversions as possible to be handled by generic code in the standard library. <br></p><p>It certainly looks like `FloatingPoint` protocol itself provides enough information to allow an expert to write generic version of most floating point -&gt; integer conversion variants I can think of, but I’m not an expert…but it’d be great if e.g. there was some simpler protocol other custom numeric types could adopt to take advantage of expert-written generic conversions to other numeric types. <br></p><p>I can provide examples if this is unclear, and if it’s off-topic it can wait for another time. <br></p><p>This `FloatingPoint` revision itself looks really really good! <br></p><p>&gt; On Apr 14, 2016, at 6:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Enhanced floating-point protocols<br>&gt; <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/cf60dece/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 7:23 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One is if there’s any ETA or similar for a glimpse at the “complete picture” of Swift’s revised numeric protocols; these floating-point protocols look really, really good, but this is also (I think) the first glimpse at the new `Arithmetic` protocol, and there’s also a new “Integer” protocol coming…and it’d be nice to get a sense of the complete vision here.<br></p><p>I don’t want to speak for the Apple standard library team, who are doing the Integer protocol work, but I’ve seen a reasonably complete draft, so I believe the answer is “soon”.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/1bd8a33f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 15, 2016 at 11:00:00am</p></header><div class="content"><p>+1 great addition.<br></p><p>Would suggest the naming could be more consistent, in particular:<br></p><p>   1. Anything returning Self could be named xxxed. In the current proposal<br>   this naming convention is sometimes used, e.g. divided, and sometimes not,<br>   e.g. subtracting. Suggest all unified with the xxxed convention.<br>   2. Anything returning Bool could be named isXxx. In some cases this is<br>   used, e.g. isUnordered, but not others, e.g. totalOrder.<br></p><p><br>  -- Howard.<br></p><p>On 15 April 2016 at 09:55, Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Enhanced floating-point protocols<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;    - Author(s): Stephen Canon &lt;https://github.com/stephentyrone&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; The current FloatingPoint protocol is quite limited, and provides only a<br>&gt; small subset of the features expected of an IEEE 754 conforming type. This<br>&gt; proposal expands the protocol to cover most of the expected basic<br>&gt; operations, and adds a second protocol, BinaryFloatingPoint, that provides<br>&gt; a number of useful tools for generic programming with the most commonly<br>&gt; used types.<br>&gt;<br>&gt; &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Beside the high-level motivation provided by the introduction, the<br>&gt; proposed prototype schema addresses a number of issues and requests that<br>&gt; we&#39;ve received from programmers:<br>&gt;<br>&gt;    - FloatingPoint should conform to Equatable, and Comparable<br>&gt;    - FloatingPoint should conform to FloatLiteralConvertible<br>&gt;    - Deprecate the % operator for floating-point types<br>&gt;    - Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt;    - Make Float80 conform to FloatingPoint<br>&gt;<br>&gt; It also puts FloatingPoint much more tightly in sync with the work that is<br>&gt; being done on protocols for Integers, which will make it easier to provide<br>&gt; a uniform interface for arithmetic scalar types.<br>&gt;<br>&gt; &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; A new protocol, Arithmetic, is introduced that provides the most basic<br>&gt; operations (add, subtract, multiply and divide) as well as Equatable and<br>&gt; IntegerLiteralConvertible, and is conformed to by both integer and<br>&gt; floating- point types.<br>&gt;<br>&gt; There has been some resistance to adding such a protocol, owing to<br>&gt; differences in behavior between floating point and integer arithmetic.<br>&gt; While these differences make it difficult to write correct generic code<br>&gt; that operates on all &quot;arithmetic&quot; types, it is nonetheless convenient to<br>&gt; provide a single protocol that guarantees the availability of these basic<br>&gt; operations. It is intended that &quot;number-like&quot; types should provide these<br>&gt; APIs.<br>&gt;<br>&gt; /// Arithmetic protocol declares methods backing binary arithmetic operators,/// such as  `+`, `-` and `*`; and their mutating counterparts.  These methods/// operate on arguments of the same type.////// Both mutating and non-mutating operations are declared in the protocol, but/// only the mutating ones are required.  Should conforming type omit/// non-mutating implementations, they will be provided by a protocol extension./// Implementation in that case will copy `self`, perform a mutating operation/// on it and return the resulting value.public protocol Arithmetic: Equatable, IntegerLiteralConvertible {<br>&gt;   /// Initialize to zero<br>&gt;   init()<br>&gt;<br>&gt;   /// The sum of `self` and `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `add` operation.<br>&gt;   @warn_unused_result<br>&gt;   func adding(rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Adds `rhs` to `self`.<br>&gt;   mutating func add(rhs: Self)<br>&gt;<br>&gt;   /// The result of subtracting `rhs` from `self`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `subtract` operation.<br>&gt;   @warn_unused_result<br>&gt;   func subtracting(rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Subtracts `rhs` from `self`.<br>&gt;   mutating func subtract(rhs: Self)<br>&gt;<br>&gt;   /// The product of `self` and `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `multiply` operation.<br>&gt;   @warn_unused_result<br>&gt;   func multiplied(by rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Multiplies `self` by `rhs`.<br>&gt;   mutating func multiply(by rhs: Self)<br>&gt;<br>&gt;   /// The quotient of `self` dividing by `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `divide` operation.<br>&gt;   @warn_unused_result<br>&gt;   func divided(by rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// Divides `self` by `rhs`.<br>&gt;   mutating func divide(by rhs: Self)<br>&gt; }<br>&gt; /// SignedArithmetic protocol will only be conformed to by signed numbers,/// otherwise it would be possible to negate an unsigned value.////// The only method of this protocol has the default implementation in an/// extension, that uses a parameterless initializer and subtraction.public protocol SignedArithmetic : Arithmetic {<br>&gt;   func negate() -&gt; Self<br>&gt; }<br>&gt;<br>&gt; The usual arithmetic operators are then defined in terms of the<br>&gt; implementation hooks provided by Arithmetic and SignedArithmetic, so<br>&gt; providing those operations are all that is necessary for a type to present<br>&gt; a &quot;number-like&quot; interface.<br>&gt;<br>&gt; The FloatingPoint protocol is split into two parts; FloatingPoint and<br>&gt; BinaryFloatingPoint, which conforms to FloatingPoint. If decimal types<br>&gt; were added at some future point, they would conform to<br>&gt; DecimalFloatingPoint.<br>&gt;<br>&gt; FloatingPoint is expanded to contain most of the IEEE 754 basic<br>&gt; operations, as well as conformance to SignedArithmetic and Comparable.<br>&gt;<br>&gt; /// A floating-point type that provides most of the IEEE 754 basic (clause 5)/// operations.  The base, precision, and exponent range are not fixed in/// any way by this protocol, but it enforces the basic requirements of/// any IEEE 754 floating-point type.////// The BinaryFloatingPoint protocol refines these requirements and provides/// some additional useful operations as well.public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt;<br>&gt;   /// An unsigned integer type that can represent the significand of any value.<br>&gt;   ///<br>&gt;   /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently<br>&gt;   /// also called the &quot;mantissa&quot;, but this terminology is slightly incorrect<br>&gt;   /// (see the &quot;Use of &#39;mantissa&#39;&quot; section on the linked Wikipedia page for<br>&gt;   /// more details).  &quot;Significand&quot; is the preferred terminology in IEEE 754.<br>&gt;   associatedtype RawSignificand: UnsignedInteger<br>&gt;<br>&gt;   /// 2 for binary floating-point types, 10 for decimal.<br>&gt;   ///<br>&gt;   /// A conforming type may use any integer radix, but values other than<br>&gt;   /// 2 or 10 are extraordinarily rare in practice.<br>&gt;   static var radix: Int { get }<br>&gt;<br>&gt;   /// Positive infinity.  Compares greater than all finite numbers.<br>&gt;   static var infinity: Self { get }<br>&gt;<br>&gt;   /// A quiet NaN (not-a-number).  Compares not equal to every value,<br>&gt;   /// including itself.<br>&gt;   static var nan: Self { get }<br>&gt;<br>&gt;   /// NaN with specified `payload`.<br>&gt;   ///<br>&gt;   /// Compares not equal to every value, including itself.  Most operations<br>&gt;   /// with a NaN operand will produce a NaN result.  Note that it is generally<br>&gt;   /// not the case that all possible significand values are valid<br>&gt;   /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;   /// payloads as zero, or mask them to create an admissible payload.<br>&gt;   @warn_unused_result<br>&gt;   static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br>&gt;<br>&gt;   /// The greatest finite number.<br>&gt;   ///<br>&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;   /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.<br>&gt;   /// The naming of those macros is slightly misleading, because infinity<br>&gt;   /// is greater than this value.<br>&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt;<br>&gt;   // NOTE: Rationale for &quot;ulp&quot; instead of &quot;epsilon&quot;:<br>&gt;   // We do not use that name because it is ambiguous at best and misleading<br>&gt;   // at worst:<br>&gt;   //<br>&gt;   // - Historically several definitions of &quot;machine epsilon&quot; have commonly<br>&gt;   //   been used, which differ by up to a factor of two or so.  By contrast<br>&gt;   //   &quot;ulp&quot; is a term with a specific unambiguous definition.<br>&gt;   //<br>&gt;   // - Some languages have used &quot;epsilon&quot; to refer to wildly different values,<br>&gt;   //   such as `leastMagnitude`.<br>&gt;   //<br>&gt;   // - Inexperienced users often believe that &quot;epsilon&quot; should be used as a<br>&gt;   //   tolerance for floating-point comparisons, because of the name.  It is<br>&gt;   //   nearly always the wrong value to use for this purpose.<br>&gt;<br>&gt;   /// The unit in the last place of 1.0.<br>&gt;   ///<br>&gt;   /// This is the weight of the least significant bit of the significand of 1.0,<br>&gt;   /// or the positive difference between 1.0 and the next greater representable<br>&gt;   /// number.  Corresponds to the C macros `FLT_EPSILON`, `DBL_EPSILON`, etc.<br>&gt;   static var ulp: Self { get }<br>&gt;<br>&gt;   /// The unit in the last place of `self`.<br>&gt;   ///<br>&gt;   /// This is the unit of the least significant digit in the significand of<br>&gt;   /// `self`.  For most numbers `x`, this is the difference between `x` and<br>&gt;   /// the next greater (in magnitude) representable number.  There are some<br>&gt;   /// edge cases to be aware of:<br>&gt;   ///<br>&gt;   /// - `greatestFiniteMagnitude.ulp` is a finite number, even though<br>&gt;   ///   the next greater representable value is `infinity`.<br>&gt;   /// - `x.ulp` is `NaN` if `x` is not a finite number.<br>&gt;   /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal<br>&gt;   ///   number.  On targets that do not support subnormals, `x.ulp` may be<br>&gt;   ///   flushed to zero.<br>&gt;   ///<br>&gt;   /// This quantity, or a related quantity is sometimes called &quot;epsilon&quot; or<br>&gt;   /// &quot;machine epsilon&quot;.  We avoid that name because it has different meanings<br>&gt;   /// in different languages, which can lead to confusion, and because it<br>&gt;   /// suggests that it is an good tolerance to use for comparisons,<br>&gt;   /// which is almost never is.<br>&gt;   ///<br>&gt;   /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)<br>&gt;   var ulp: Self { get }<br>&gt;<br>&gt;   /// The least positive normal number.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive normal numbers.  There may<br>&gt;   /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>&gt;   /// they are represented with less precision than normal numbers.<br>&gt;   /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of<br>&gt;   /// those macros is slightly misleading, because subnormals, zeros, and<br>&gt;   /// negative numbers are smaller than this value.<br>&gt;   static var leastNormalMagnitude: Self { get }<br>&gt;<br>&gt;   /// The least positive number.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive numbers, but greater than<br>&gt;   /// zero.  If the target supports subnormal values, this is smaller than<br>&gt;   /// `leastNormalMagnitude`; otherwise they are equal.<br>&gt;   static var leastMagnitude: Self { get }<br>&gt;<br>&gt;   /// `true` iff the signbit of `self` is set.  Implements the IEEE 754<br>&gt;   /// `signbit` operation.<br>&gt;   ///<br>&gt;   /// Note that this is not the same as `self &lt; 0`.  In particular, this<br>&gt;   /// property is true for `-0` and some NaNs, both of which compare not<br>&gt;   /// less than zero.<br>&gt;   //  TODO: strictly speaking a bit and a bool are slightly different<br>&gt;   //  concepts.  Is another name more appropriate for this property?<br>&gt;   //  `isNegative` is incorrect because of -0 and NaN.  `isSignMinus` might<br>&gt;   //  be acceptable, but isn&#39;t great.  `signBit` is the IEEE 754 name.<br>&gt;   var signBit: Bool { get }<br>&gt;<br>&gt;   /// The integer part of the base-r logarithm of the magnitude of `self`,<br>&gt;   /// where r is the radix (2 for binary, 10 for decimal).  Implements the<br>&gt;   /// IEEE 754 `logB` operation.<br>&gt;   ///<br>&gt;   /// Edge cases:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.exponent` is `Int.min`.<br>&gt;   /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`<br>&gt;   var exponent: Int { get }<br>&gt;<br>&gt;   /// The significand satisfies:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// self = (signBit ? -1 : 1) * significand * radix**exponent<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// If radix is 2 (the most common case), then for finite non-zero numbers<br>&gt;   /// `1 &lt;= significand` and `significand &lt; 2`.  For other values of `x`,<br>&gt;   /// `x.significand` is defined as follows:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.significand` is 0.0.<br>&gt;   /// - If `x` is infinity, then `x.significand` is 1.0.<br>&gt;   /// - If `x` is NaN, then `x.significand` is NaN.<br>&gt;   ///<br>&gt;   /// For all floating-point `x`, if we define y by:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// let y = Self(signBit: x.signBit, exponent: x.exponent,<br>&gt;   ///              significand: x.significand)<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.<br>&gt;   var significand: Self { get }<br>&gt;<br>&gt;   /// Initialize from signBit, exponent, and significand.<br>&gt;   ///<br>&gt;   /// The result is:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// (signBit ? -1 : 1) * significand * radix**exponent<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// (where `**` is exponentiation) computed as if by a single correctly-<br>&gt;   /// rounded floating-point operation.  If this value is outside the<br>&gt;   /// representable range of the type, overflow or underflow occurs, and zero,<br>&gt;   /// a subnormal value, or infinity may result, as with any basic operation.<br>&gt;   /// Other edge cases:<br>&gt;   ///<br>&gt;   /// - If `significand` is zero or infinite, the result is zero or infinite,<br>&gt;   ///   regardless of the value of `exponent`.<br>&gt;   ///<br>&gt;   /// - If `significand` is NaN, the result is NaN.<br>&gt;   ///<br>&gt;   /// Note that for any floating-point `x` the result of<br>&gt;   ///<br>&gt;   ///   `Self(signBit: x.signBit,<br>&gt;   ///         exponent: x.exponent,<br>&gt;   ///         significand: x.significand)`<br>&gt;   ///<br>&gt;   /// is &quot;the same&quot; as `x`; it is `x` canonicalized.<br>&gt;   ///<br>&gt;   /// Because of these properties, this initializer implements the IEEE 754<br>&gt;   /// `scaleB` operation.<br>&gt;   init(signBit: Bool, exponent: Int, significand: Self)<br>&gt;<br>&gt;   /// A floating point value whose exponent and signficand are taken from<br>&gt;   /// `magnitude` and whose signBit is taken from `signOf`.  Implements the<br>&gt;   /// IEEE 754 `copysign` operation.<br>&gt;   //  TODO: better argument names would be great.<br>&gt;   init(magnitudeOf magnitude: Self, signOf: Self)<br>&gt;<br>&gt;   /// The least representable value that compares greater than `self`.<br>&gt;   ///<br>&gt;   /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.<br>&gt;   /// - If `x` is `-leastMagnitude`, then `x.nextUp` is `-0.0`.<br>&gt;   /// - If `x` is zero, then `x.nextUp` is `leastMagnitude`.<br>&gt;   /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.<br>&gt;   /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.<br>&gt;   var nextUp: Self { get }<br>&gt;<br>&gt;   /// The greatest representable value that compares less than `self`.<br>&gt;   ///<br>&gt;   /// `x.nextDown` is equivalent to `-(-x).nextUp`<br>&gt;   var nextDown: Self { get }<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other`.<br>&gt;   ///<br>&gt;   /// For finite `self` and `other`, the remainder `r` is defined by<br>&gt;   /// `r = self - other*n`, where `n` is the integer nearest to `self/other`.<br>&gt;   /// (Note that `n` is *not* `self/other` computed in floating-point<br>&gt;   /// arithmetic, and that `n` may not even be representable in any available<br>&gt;   /// integer type).  If `self/other` is exactly halfway between two integers,<br>&gt;   /// `n` is chosen to be even.<br>&gt;   ///<br>&gt;   /// It follows that if `self` and `other` are finite numbers, the remainder<br>&gt;   /// `r` satisfies `-|other|/2 &lt;= r` and `r &lt;= |other|/2`.<br>&gt;   ///<br>&gt;   /// `formRemainder` is always exact, and therefore is not affected by<br>&gt;   /// rounding modes.<br>&gt;   mutating func formRemainder(dividingBy other: Self)<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other` using truncating division.<br>&gt;   ///<br>&gt;   /// If `self` and `other` are finite numbers, the truncating remainder<br>&gt;   /// `r` has the same sign as `other` and is strictly smaller in magnitude.<br>&gt;   /// It satisfies `r = self - other*n`, where `n` is the integral part<br>&gt;   /// of `self/other`.<br>&gt;   ///<br>&gt;   /// `formTruncatingRemainder` is always exact, and therefore is not<br>&gt;   /// affected by rounding modes.<br>&gt;   mutating func formTruncatingRemainder(dividingBy other: Self)<br>&gt;<br>&gt;   /// Mutating form of square root.<br>&gt;   mutating func formSquareRoot( )<br>&gt;<br>&gt;   /// Fused multiply-add, accumulating the product of `lhs` and `rhs` to `self`.<br>&gt;   mutating func addProduct(lhs: Self, _ rhs: Self)<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other`.<br>&gt;   @warn_unused_result<br>&gt;   func remainder(dividingBy other: Self) -&gt; Self<br>&gt;<br>&gt;   /// Remainder of `self` divided by `other` using truncating division.<br>&gt;   @warn_unused_result<br>&gt;   func truncatingRemainder(dividingBy other: Self) -&gt; Self<br>&gt;<br>&gt;   /// Square root of `self`.<br>&gt;   @warn_unused_result<br>&gt;   func squareRoot( ) -&gt; Self<br>&gt;<br>&gt;   /// `self + lhs*rhs` computed without intermediate rounding.<br>&gt;   @warn_unused_result<br>&gt;   func addingProduct(lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;<br>&gt;   /// The minimum of `x` and `y`.  Implements the IEEE 754 `minNum` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if `x &lt;= y`, `y` if `y &lt; x`, and whichever of `x` or `y`<br>&gt;   /// is a number if the other is NaN.  The result is NaN only if both<br>&gt;   /// arguments are NaN.<br>&gt;   ///<br>&gt;   /// This function is an implementation hook to be used by the free function<br>&gt;   /// min(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>&gt;   /// to NaNs.<br>&gt;   @warn_unused_result<br>&gt;   static func minimum(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// The maximum of `x` and `y`.  Implements the IEEE 754 `maxNum` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if `x &gt;= y`, `y` if `y &gt; x`, and whichever of `x` or `y`<br>&gt;   /// is a number if the other is NaN.  The result is NaN only if both<br>&gt;   /// arguments are NaN.<br>&gt;   ///<br>&gt;   /// This function is an implementation hook to be used by the free function<br>&gt;   /// max(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>&gt;   /// to NaNs.<br>&gt;   @warn_unused_result<br>&gt;   static func maximum(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// Whichever of `x` or `y` has lesser magnitude.  Implements the IEEE 754<br>&gt;   /// `minNumMag` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if abs(x) &lt;= abs(y), `y` if abs(y) &lt; abs(x), and whichever of<br>&gt;   /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>&gt;   /// only if both arguments are NaN.<br>&gt;   @warn_unused_result<br>&gt;   static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// Whichever of `x` or `y` has greater magnitude.  Implements the IEEE 754<br>&gt;   /// `maxNumMag` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if abs(x) &gt;= abs(y), `y` if abs(y) &gt; abs(x), and whichever of<br>&gt;   /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>&gt;   /// only if both arguments are NaN.<br>&gt;   @warn_unused_result<br>&gt;   static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt;<br>&gt;   /// IEEE 754 equality predicate.<br>&gt;   ///<br>&gt;   /// -0 compares equal to +0, and NaN compares not equal to anything,<br>&gt;   /// including itself.<br>&gt;   @warn_unused_result<br>&gt;   func isEqual(to other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// IEEE 754 less-than predicate.<br>&gt;   ///<br>&gt;   /// NaN compares not less than anything.  -infinity compares less than<br>&gt;   /// all values except for itself and NaN.  Everything except for NaN and<br>&gt;   /// +infinity compares less than +infinity.<br>&gt;   @warn_unused_result<br>&gt;   func isLess(than other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// IEEE 754 less-than-or-equal predicate.<br>&gt;   ///<br>&gt;   /// NaN compares not less than or equal to anything, including itself.<br>&gt;   /// -infinity compares less than or equal to everything except NaN.<br>&gt;   /// Everything except NaN compares less than or equal to +infinity.<br>&gt;   ///<br>&gt;   /// Because of the existence of NaN in FloatingPoint types, trichotomy does<br>&gt;   /// not hold, which means that `x &lt; y` and `!(y &lt;= x)` are not equivalent.<br>&gt;   /// This is why `isLessThanOrEqual(to:)` is a separate implementation hook<br>&gt;   /// in the protocol.<br>&gt;   ///<br>&gt;   /// Note that this predicate does not impose a total order.  The `totalOrder`<br>&gt;   /// predicate provides a refinement satisfying that criteria.<br>&gt;   @warn_unused_result<br>&gt;   func isLessThanOrEqual(to other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// IEEE 754 unordered predicate.  True if either `self` or `other` is NaN,<br>&gt;   /// and false otherwise.<br>&gt;   @warn_unused_result<br>&gt;   func isUnordered(with other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// True if and only if `self` is normal.<br>&gt;   ///<br>&gt;   /// A normal number uses the full precision available in the format.  Zero<br>&gt;   /// is not a normal number.<br>&gt;   var isNormal: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is finite.<br>&gt;   ///<br>&gt;   /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or<br>&gt;   /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNan` are<br>&gt;   /// `false`.<br>&gt;   var isFinite: Bool { get }<br>&gt;<br>&gt;   /// True iff `self` is zero.  Equivalent to `self == 0`.<br>&gt;   var isZero: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is subnormal.<br>&gt;   ///<br>&gt;   /// A subnormal number does not use the full precision available to normal<br>&gt;   /// numbers of the same format.  Zero is not a subnormal number.<br>&gt;   var isSubnormal: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is infinite.<br>&gt;   ///<br>&gt;   /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because<br>&gt;   /// they are not total.  If `x` is `NaN`, then both properties are `false`.<br>&gt;   var isInfinite: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is NaN (&quot;not a number&quot;).<br>&gt;   var isNan: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` is a signaling NaN.<br>&gt;   var isSignalingNan: Bool { get }<br>&gt;<br>&gt;   /// The IEEE 754 &quot;class&quot; of this type.<br>&gt;   var floatingPointClass: FloatingPointClassification { get }<br>&gt;<br>&gt;   /// True if and only if `self` is canonical.<br>&gt;   ///<br>&gt;   /// Every floating-point value of type Float or Double is canonical, but<br>&gt;   /// non-canonical values of type Float80 exist, and non-canonical values<br>&gt;   /// may exist for other types that conform to FloatingPoint.<br>&gt;   ///<br>&gt;   /// The non-canonical Float80 values are known as &quot;pseudo-denormal&quot;,<br>&gt;   /// &quot;unnormal&quot;, &quot;pseudo-infinity&quot;, and &quot;pseudo-NaN&quot;.<br>&gt;   /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)<br>&gt;   var isCanonical: Bool { get }<br>&gt;<br>&gt;   /// True if and only if `self` preceeds `other` in the IEEE 754 total order<br>&gt;   /// relation.<br>&gt;   ///<br>&gt;   /// This relation is a refinement of `&lt;=` that provides a total order on all<br>&gt;   /// values of type `Self`, including non-canonical encodings, signed zeros,<br>&gt;   /// and NaNs.  Because it is used much less frequently than the usual<br>&gt;   /// comparisons, there is no operator form of this relation.<br>&gt;   @warn_unused_result<br>&gt;   func totalOrder(with other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// True if and only if `abs(self)` preceeds `abs(other)` in the IEEE 754<br>&gt;   /// total order relation.<br>&gt;   @warn_unused_result<br>&gt;   func totalOrderMagnitude(with other: Self) -&gt; Bool<br>&gt;<br>&gt;   /// The closest representable value to the argument.<br>&gt;   init&lt;Source: Integer&gt;(_ value: Source)<br>&gt;<br>&gt;   /// Fails if the argument cannot be exactly represented.<br>&gt;   init?&lt;Source: Integer&gt;(exactly value: Source)<br>&gt; }<br>&gt;<br>&gt; The BinaryFloatingPoint protocol provides a number of additional APIs<br>&gt; that only make sense for types with fixed radix 2:<br>&gt;<br>&gt; /// A radix-2 (binary) floating-point type that follows the IEEE 754 encoding/// conventions.public protocol BinaryFloatingPoint: FloatingPoint {<br>&gt;<br>&gt;   /// The number of bits used to represent the exponent.<br>&gt;   ///<br>&gt;   /// Following IEEE 754 encoding convention, the exponent bias is:<br>&gt;   ///<br>&gt;   ///   bias = 2**(exponentBitCount-1) - 1<br>&gt;   ///<br>&gt;   /// The least normal exponent is `1-bias` and the largest finite exponent<br>&gt;   /// is `bias`.  The all-zeros exponent is reserved for subnormals and zeros,<br>&gt;   /// and the all-ones exponent is reserved for infinities and NaNs.<br>&gt;   static var exponentBitCount: Int { get }<br>&gt;<br>&gt;   /// For fixed-width floating-point types, this is the number of fractional<br>&gt;   /// significand bits.<br>&gt;   ///<br>&gt;   /// For extensible floating-point types, `significandBitCount` should be<br>&gt;   /// the maximum allowed significand width (without counting any leading<br>&gt;   /// integral bit of the significand).  If there is no upper limit, then<br>&gt;   /// `significandBitCount` should be `Int.max`.<br>&gt;   ///<br>&gt;   /// Note that `Float80.significandBitCount` is 63, even though 64 bits<br>&gt;   /// are used to store the significand in the memory representation of a<br>&gt;   /// `Float80` (unlike other floating-point types, `Float80` explicitly<br>&gt;   /// stores the leading integral significand bit, but the<br>&gt;   /// `BinaryFloatingPoint` APIs provide an abstraction so that users don&#39;t<br>&gt;   /// need to be aware of this detail).<br>&gt;   static var significandBitCount: Int { get }<br>&gt;<br>&gt;   /// The raw encoding of the exponent field of the floating-point value.<br>&gt;   var exponentBitPattern: UInt { get }<br>&gt;<br>&gt;   /// The raw encoding of the significand field of the floating-point value.<br>&gt;   ///<br>&gt;   /// `significandBitPattern` does *not* include the leading integral bit of<br>&gt;   /// the significand, even for types like `Float80` that store it explicitly.<br>&gt;   var significandBitPattern: RawSignificand { get }<br>&gt;<br>&gt;   /// Combines `signBit`, `exponent` and `significand` bit patterns to produce<br>&gt;   /// a floating-point value.<br>&gt;   init(signBit: Bool,<br>&gt;        exponentBitPattern: UInt,<br>&gt;        significandBitPattern: RawSignificand)<br>&gt;<br>&gt;   /// The least-magnitude member of the binade of `self`.<br>&gt;   ///<br>&gt;   /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is<br>&gt;   /// `+/- 2**exponent`; i.e. the floating point number with the same sign<br>&gt;   /// and exponent, but with a significand of 1.0.<br>&gt;   var binade: Self { get }<br>&gt;<br>&gt;   /// The number of bits required to represent significand.<br>&gt;   ///<br>&gt;   /// If `self` is not a finite non-zero number, `significandWidth` is<br>&gt;   /// `-1`.  Otherwise, it is the number of bits required to represent the<br>&gt;   /// significand exactly (less `1` because common formats represent one bit<br>&gt;   /// implicitly).<br>&gt;   var significandWidth: Int { get }<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func isUnordered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt;<br>&gt;   @warn_unused_result<br>&gt;   func totalOrder&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt;<br>&gt;   /// `value` rounded to the closest representable value.<br>&gt;   init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source)<br>&gt;<br>&gt;   /// Fails if `value` cannot be represented exactly as `Self`.<br>&gt;   init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source)<br>&gt; }<br>&gt;<br>&gt; Float, Double, Float80 and CGFloat will conform to all of these protocols.<br>&gt;<br>&gt; A small portion of the implementation of these APIs is dependent on new<br>&gt; Integer protocols that will be proposed separately. Everything else is<br>&gt; implemented in draft form on the branch floating-point-revision of my fork<br>&gt; &lt;https://github.com/stephentyrone/swift&gt;.<br>&gt;<br>&gt; &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    The % operator is no longer available for FloatingPoint types. We<br>&gt;    don&#39;t believe that it was widely used correctly, and the operation is still<br>&gt;    available via the formTruncatingRemainder method for people who need<br>&gt;    it.<br>&gt;    2.<br>&gt;<br>&gt;    To follow the naming guidelines, NaN and isNaN are replaced with nan<br>&gt;     and isNan.<br>&gt;    3.<br>&gt;<br>&gt;    The redundant property quietNaN is removed.<br>&gt;    4.<br>&gt;<br>&gt;    isSignaling is renamed isSignalingNan.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/stephentyrone/swift-evolution/blob/master/NNNN-floating-point-protocols.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; N/A.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/6e360a20/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>April 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Stephen,<br></p><p>You write<br></p><p>&gt;   * FloatingPoint should conform to Equatable, and Comparable<br></p><p>but the documentation for Equatable and Comparable states that == and &lt; <br>must implement an equivalence relation and a strict total order, which <br>is incompatible with the default IEEE-754 implementation of these <br>operators when NaN values are involved. How do you resolve this conflict?<br></p><p>- Stephan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 9:52 AM, Stephan Tolksdorf via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; but the documentation for Equatable and Comparable states that == and &lt; must implement an equivalence relation and a strict total order, which is incompatible with the default IEEE-754 implementation of these operators when NaN values are involved. How do you resolve this conflict?<br></p><p>That’s a documentation bug; it should be relaxed by appending something like “… on non-exceptional values.”<br></p><p>I’ll quote Dave A. to put it a bit more formally:<br></p><p>&gt; To be clear, the semantic conformance of floating point types to Comparable depends on treating NaN as a &quot;singular value”, i.e. outside the domain of valid arguments to &lt; for the purposes of Comparable.  That doesn’t mean we can’t nail down what &lt; does for floating point types when it does get a NaN.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/86bff9fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/909469b64d49eaf2c4e82fbba166d55c?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Stephan Tolksdorf</string> &lt;st at quanttec.com&gt;<p>April 15, 2016 at 08:00:00pm</p></header><div class="content"><p>On 2016-04-15, 18:58, Stephen Canon wrote:<br></p><p>&gt;&gt; but the documentation for Equatable and Comparable states that == and<br>&gt;&gt; &lt; must implement an equivalence relation and a strict total order,<br>&gt;&gt; which is incompatible with the default IEEE-754 implementation of<br>&gt;&gt; these operators when NaN values are involved. How do you resolve this<br>&gt;&gt; conflict?<br>&gt;<br>&gt; That’s a documentation bug; it should be relaxed by appending something<br>&gt; like “… on non-exceptional values.”<br>&gt;<br>&gt; I’ll quote Dave A. to put it a bit more formally:<br>&gt;<br>&gt;&gt; To be clear, the semantic conformance of floating point types to<br>&gt;&gt; Comparable depends on treating NaN as a &quot;singular value”, i.e. outside<br>&gt;&gt; the domain of valid arguments to &lt; /for the purposes of Comparable/.<br>&gt;&gt;  That doesn’t mean we can’t nail down what &lt; does for floating point<br>&gt;&gt; types when it does get a NaN.<br></p><p>Thanks for the clarification!<br></p><p>- Stephan<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>The floating-point API design looks great. However, I&#39;m concerned about providing a generic Arithmetic protocol:<br></p><p>&gt; On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A new protocol, Arithmetic, is introduced that provides the most basic operations (add, subtract, multiply and divide) as well as Equatable and  IntegerLiteralConvertible, and is conformed to by both integer and floating- point types.<br>&gt; <br>&gt; There has been some resistance to adding such a protocol, owing to differences in behavior between floating point and integer arithmetic. While these differences make it difficult to write correct generic code that operates on all &quot;arithmetic&quot; types, it is nonetheless convenient to provide a single protocol that guarantees the availability of these basic operations. It is intended that &quot;number-like&quot; types should provide these APIs.<br></p><p>There are many other things we could do because they&#39;re &quot;convenient&quot;, but we don&#39;t because they&#39;re wrong or mislead users into design cul-de-sacs. For example, we could provide integer indexing into strings, which would certainly be convenient, but we don&#39;t do that because it would lead to misguided accidentally-quadratic algorithms all over the place. This feels like a similar accommodation—while convenient, it makes it too easy for users to write naive real-number-arithmetic code and apply it blindly to numeric representations with very different error and overflow behavior. By including &quot;divides&quot; in the protocol, you&#39;re also implying a common abstraction over two *completely different* operations—integer quotient and floating-point division don&#39;t share many properties other than unfortunately sharing an operator in C.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 04:00:00pm</p></header><div class="content"><p>Oh, a couple more things I just thought of:<br></p><p>&gt; public protocol Arithmetic: Equatable, IntegerLiteralConvertible {<br></p><p>If your goals include supporting complex numbers, how is IntegerLiteralConvertible going to fit in there?<br></p><p>&gt;   /// Initialize to zero<br>&gt;   init()<br></p><p>0 is valuable as the additive identity. Should there also be a way to get 1, the multiplicative identity? If you need both, should these be static properties instead of initializers?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>April 18, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 4:55 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;   /// `true` iff the signbit of `self` is set.  Implements the IEEE 754<br>&gt;   /// `signbit` operation.<br>&gt;   ///<br>&gt;   /// Note that this is not the same as `self &lt; 0`.  In particular, this<br>&gt;   /// property is true for `-0` and some NaNs, both of which compare not<br>&gt;   /// less than zero.<br>&gt;   //  TODO: strictly speaking a bit and a bool are slightly different<br>&gt;   //  concepts.  Is another name more appropriate for this property?<br>&gt;   //  `isNegative` is incorrect because of -0 and NaN.  `isSignMinus` might<br>&gt;   //  be acceptable, but isn&#39;t great.  `signBit` is the IEEE 754 name.<br>&gt;   var signBit: Bool { get }<br>&gt; <br>&gt;   init(signBit: Bool, exponent: Int, significand: Self)<br>These do feel a bit awkward. Perhaps something over-engineered to handle the typical cases more readably?<br></p><p>  public protocol FloatingPoint: SignedArithmetic, Comparable {<br>    enum Sign { <br>      case Plus<br>      case Minus<br>      init(bit: Bool) { return bit ? .Minus : .Plus }<br>      var bit: Bool { get { return self == Minus } }<br>    }<br>  <br>    var sign: Sign { get }<br>    var signBit: Bool { get }<br>  <br>    init(sign: Sign, exponent: Int, significand: Self)<br>    init(signBit: Bool, exponent: Int, significand: Self)<br>  <br>    …<br>  }<br></p><p>…and perhaps each sign/signBit pair would provides one as a default implementation that calls the other.<br></p><p>Then we can often write something more readable than signBit: <br></p><p>  let x = Float(sign: .Plus, exponent: 2, signficand: 2)<br>  if x.sign == .Plus { … }<br></p><p>Alternatively or additionally, perhaps signBit ought to be an Int because the people writing code using signBit would probably prefer to use literal 1 and 0 instead of true and false. (Hasn&#39;t the distinction between Bit and Bool come up before?)<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/88a325d8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal draft] Enhanced floating-point protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;d like to have something like Summable with &#39;add&#39;, &#39;adding&#39; and &#39;zero&#39; being a separate protocol as well as somthing like Multiplicative with &#39;multiply&#39;, &#39;multiplied&#39; and &#39;one&#39; being a separate protocol, because these are universally interesting for other cases, e.g. Summable would be useful for defining path lengths in a graph library.<br></p><p>Would you mind adding that to the proposal?<br></p><p>-Thorsten <br></p><p>&gt; Am 15.04.2016 um 01:55 schrieb Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Enhanced floating-point protocols<br>&gt; Proposal: SE-NNNN<br>&gt; Author(s): Stephen Canon<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; The current FloatingPoint protocol is quite limited, and provides only a small subset of the features expected of an IEEE 754 conforming type. This proposal expands the protocol to cover most of the expected basic operations, and adds a second protocol, BinaryFloatingPoint, that provides a number of useful tools for generic programming with the most commonly used types.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Beside the high-level motivation provided by the introduction, the proposed prototype schema addresses a number of issues and requests that we&#39;ve received from programmers:<br>&gt; <br>&gt; FloatingPoint should conform to Equatable, and Comparable<br>&gt; FloatingPoint should conform to FloatLiteralConvertible<br>&gt; Deprecate the % operator for floating-point types<br>&gt; Provide basic constants (analogues of C&#39;s DBL_MAX, etc.)<br>&gt; Make Float80 conform to FloatingPoint<br>&gt; It also puts FloatingPoint much more tightly in sync with the work that is being done on protocols for Integers, which will make it easier to provide a uniform interface for arithmetic scalar types.<br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; A new protocol, Arithmetic, is introduced that provides the most basic operations (add, subtract, multiply and divide) as well as Equatable and IntegerLiteralConvertible, and is conformed to by both integer and floating- point types.<br>&gt; <br>&gt; There has been some resistance to adding such a protocol, owing to differences in behavior between floating point and integer arithmetic. While these differences make it difficult to write correct generic code that operates on all &quot;arithmetic&quot; types, it is nonetheless convenient to provide a single protocol that guarantees the availability of these basic operations. It is intended that &quot;number-like&quot; types should provide these APIs.<br>&gt; <br>&gt; /// Arithmetic protocol declares methods backing binary arithmetic operators,<br>&gt; /// such as  `+`, `-` and `*`; and their mutating counterparts.  These methods<br>&gt; /// operate on arguments of the same type.<br>&gt; ///<br>&gt; /// Both mutating and non-mutating operations are declared in the protocol, but<br>&gt; /// only the mutating ones are required.  Should conforming type omit<br>&gt; /// non-mutating implementations, they will be provided by a protocol extension.<br>&gt; /// Implementation in that case will copy `self`, perform a mutating operation<br>&gt; /// on it and return the resulting value.<br>&gt; public protocol Arithmetic: Equatable, IntegerLiteralConvertible {<br>&gt;   /// Initialize to zero<br>&gt;   init()<br>&gt; <br>&gt;   /// The sum of `self` and `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `add` operation.<br>&gt;   @warn_unused_result<br>&gt;   func adding(rhs: Self) -&gt; Self<br>&gt; <br>&gt;   /// Adds `rhs` to `self`.<br>&gt;   mutating func add(rhs: Self)<br>&gt; <br>&gt;   /// The result of subtracting `rhs` from `self`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `subtract` operation.<br>&gt;   @warn_unused_result<br>&gt;   func subtracting(rhs: Self) -&gt; Self<br>&gt; <br>&gt;   /// Subtracts `rhs` from `self`.<br>&gt;   mutating func subtract(rhs: Self)<br>&gt; <br>&gt;   /// The product of `self` and `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `multiply` operation.<br>&gt;   @warn_unused_result<br>&gt;   func multiplied(by rhs: Self) -&gt; Self<br>&gt; <br>&gt;   /// Multiplies `self` by `rhs`.<br>&gt;   mutating func multiply(by rhs: Self)<br>&gt; <br>&gt;   /// The quotient of `self` dividing by `rhs`.<br>&gt;   //  Arithmetic provides a default implementation of this method in terms<br>&gt;   //  of the mutating `divide` operation.<br>&gt;   @warn_unused_result<br>&gt;   func divided(by rhs: Self) -&gt; Self<br>&gt; <br>&gt;   /// Divides `self` by `rhs`.<br>&gt;   mutating func divide(by rhs: Self)<br>&gt; }<br>&gt; <br>&gt; /// SignedArithmetic protocol will only be conformed to by signed numbers,<br>&gt; /// otherwise it would be possible to negate an unsigned value.<br>&gt; ///<br>&gt; /// The only method of this protocol has the default implementation in an<br>&gt; /// extension, that uses a parameterless initializer and subtraction.<br>&gt; public protocol SignedArithmetic : Arithmetic {<br>&gt;   func negate() -&gt; Self<br>&gt; }<br>&gt; The usual arithmetic operators are then defined in terms of the implementation hooks provided by Arithmetic and SignedArithmetic, so providing those operations are all that is necessary for a type to present a &quot;number-like&quot; interface.<br>&gt; <br>&gt; The FloatingPoint protocol is split into two parts; FloatingPoint and BinaryFloatingPoint, which conforms to FloatingPoint. If decimal types were added at some future point, they would conform to DecimalFloatingPoint.<br>&gt; <br>&gt; FloatingPoint is expanded to contain most of the IEEE 754 basic operations, as well as conformance to SignedArithmetic and Comparable.<br>&gt; <br>&gt; /// A floating-point type that provides most of the IEEE 754 basic (clause 5)<br>&gt; /// operations.  The base, precision, and exponent range are not fixed in<br>&gt; /// any way by this protocol, but it enforces the basic requirements of<br>&gt; /// any IEEE 754 floating-point type.<br>&gt; ///<br>&gt; /// The BinaryFloatingPoint protocol refines these requirements and provides<br>&gt; /// some additional useful operations as well.<br>&gt; public protocol FloatingPoint: SignedArithmetic, Comparable {<br>&gt; <br>&gt;   /// An unsigned integer type that can represent the significand of any value.<br>&gt;   ///<br>&gt;   /// The significand (http://en.wikipedia.org/wiki/Significand) is frequently<br>&gt;   /// also called the &quot;mantissa&quot;, but this terminology is slightly incorrect<br>&gt;   /// (see the &quot;Use of &#39;mantissa&#39;&quot; section on the linked Wikipedia page for<br>&gt;   /// more details).  &quot;Significand&quot; is the preferred terminology in IEEE 754.<br>&gt;   associatedtype RawSignificand: UnsignedInteger<br>&gt; <br>&gt;   /// 2 for binary floating-point types, 10 for decimal.<br>&gt;   ///<br>&gt;   /// A conforming type may use any integer radix, but values other than<br>&gt;   /// 2 or 10 are extraordinarily rare in practice.<br>&gt;   static var radix: Int { get }<br>&gt; <br>&gt;   /// Positive infinity.  Compares greater than all finite numbers.<br>&gt;   static var infinity: Self { get }<br>&gt; <br>&gt;   /// A quiet NaN (not-a-number).  Compares not equal to every value,<br>&gt;   /// including itself.<br>&gt;   static var nan: Self { get }<br>&gt; <br>&gt;   /// NaN with specified `payload`.<br>&gt;   ///<br>&gt;   /// Compares not equal to every value, including itself.  Most operations<br>&gt;   /// with a NaN operand will produce a NaN result.  Note that it is generally<br>&gt;   /// not the case that all possible significand values are valid<br>&gt;   /// NaN `payloads`.  `FloatingPoint` types should either treat inadmissible<br>&gt;   /// payloads as zero, or mask them to create an admissible payload.<br>&gt;   @warn_unused_result<br>&gt;   static func nan(payload payload: RawSignificand, signaling: Bool) -&gt; Self<br>&gt; <br>&gt;   /// The greatest finite number.<br>&gt;   ///<br>&gt;   /// Compares greater than or equal to all finite numbers, but less than<br>&gt;   /// infinity.  Corresponds to the C macros `FLT_MAX`, `DBL_MAX`, etc.<br>&gt;   /// The naming of those macros is slightly misleading, because infinity<br>&gt;   /// is greater than this value.<br>&gt;   static var greatestFiniteMagnitude: Self { get }<br>&gt; <br>&gt;   // NOTE: Rationale for &quot;ulp&quot; instead of &quot;epsilon&quot;:<br>&gt;   // We do not use that name because it is ambiguous at best and misleading<br>&gt;   // at worst:<br>&gt;   //<br>&gt;   // - Historically several definitions of &quot;machine epsilon&quot; have commonly<br>&gt;   //   been used, which differ by up to a factor of two or so.  By contrast<br>&gt;   //   &quot;ulp&quot; is a term with a specific unambiguous definition.<br>&gt;   //<br>&gt;   // - Some languages have used &quot;epsilon&quot; to refer to wildly different values,<br>&gt;   //   such as `leastMagnitude`.<br>&gt;   //<br>&gt;   // - Inexperienced users often believe that &quot;epsilon&quot; should be used as a<br>&gt;   //   tolerance for floating-point comparisons, because of the name.  It is<br>&gt;   //   nearly always the wrong value to use for this purpose.<br>&gt; <br>&gt;   /// The unit in the last place of 1.0.<br>&gt;   ///<br>&gt;   /// This is the weight of the least significant bit of the significand of 1.0,<br>&gt;   /// or the positive difference between 1.0 and the next greater representable<br>&gt;   /// number.  Corresponds to the C macros `FLT_EPSILON`, `DBL_EPSILON`, etc.<br>&gt;   static var ulp: Self { get }<br>&gt; <br>&gt;   /// The unit in the last place of `self`.<br>&gt;   ///<br>&gt;   /// This is the unit of the least significant digit in the significand of<br>&gt;   /// `self`.  For most numbers `x`, this is the difference between `x` and<br>&gt;   /// the next greater (in magnitude) representable number.  There are some<br>&gt;   /// edge cases to be aware of:<br>&gt;   ///<br>&gt;   /// - `greatestFiniteMagnitude.ulp` is a finite number, even though<br>&gt;   ///   the next greater representable value is `infinity`.<br>&gt;   /// - `x.ulp` is `NaN` if `x` is not a finite number.<br>&gt;   /// - If `x` is very small in magnitude, then `x.ulp` may be a subnormal<br>&gt;   ///   number.  On targets that do not support subnormals, `x.ulp` may be<br>&gt;   ///   flushed to zero.<br>&gt;   ///<br>&gt;   /// This quantity, or a related quantity is sometimes called &quot;epsilon&quot; or<br>&gt;   /// &quot;machine epsilon&quot;.  We avoid that name because it has different meanings<br>&gt;   /// in different languages, which can lead to confusion, and because it<br>&gt;   /// suggests that it is an good tolerance to use for comparisons,<br>&gt;   /// which is almost never is.<br>&gt;   ///<br>&gt;   /// (See https://en.wikipedia.org/wiki/Machine_epsilon for more detail)<br>&gt;   var ulp: Self { get }<br>&gt; <br>&gt;   /// The least positive normal number.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive normal numbers.  There may<br>&gt;   /// be smaller positive numbers, but they are &quot;subnormal&quot;, meaning that<br>&gt;   /// they are represented with less precision than normal numbers.<br>&gt;   /// Corresponds to the C macros `FLT_MIN`, `DBL_MIN`, etc.  The naming of<br>&gt;   /// those macros is slightly misleading, because subnormals, zeros, and<br>&gt;   /// negative numbers are smaller than this value.<br>&gt;   static var leastNormalMagnitude: Self { get }<br>&gt; <br>&gt;   /// The least positive number.<br>&gt;   ///<br>&gt;   /// Compares less than or equal to all positive numbers, but greater than<br>&gt;   /// zero.  If the target supports subnormal values, this is smaller than<br>&gt;   /// `leastNormalMagnitude`; otherwise they are equal.<br>&gt;   static var leastMagnitude: Self { get }<br>&gt; <br>&gt;   /// `true` iff the signbit of `self` is set.  Implements the IEEE 754<br>&gt;   /// `signbit` operation.<br>&gt;   ///<br>&gt;   /// Note that this is not the same as `self &lt; 0`.  In particular, this<br>&gt;   /// property is true for `-0` and some NaNs, both of which compare not<br>&gt;   /// less than zero.<br>&gt;   //  TODO: strictly speaking a bit and a bool are slightly different<br>&gt;   //  concepts.  Is another name more appropriate for this property?<br>&gt;   //  `isNegative` is incorrect because of -0 and NaN.  `isSignMinus` might<br>&gt;   //  be acceptable, but isn&#39;t great.  `signBit` is the IEEE 754 name.<br>&gt;   var signBit: Bool { get }<br>&gt; <br>&gt;   /// The integer part of the base-r logarithm of the magnitude of `self`,<br>&gt;   /// where r is the radix (2 for binary, 10 for decimal).  Implements the<br>&gt;   /// IEEE 754 `logB` operation.<br>&gt;   ///<br>&gt;   /// Edge cases:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.exponent` is `Int.min`.<br>&gt;   /// - If `x` is +/-infinity or NaN, then `x.exponent` is `Int.max`<br>&gt;   var exponent: Int { get }<br>&gt; <br>&gt;   /// The significand satisfies:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// self = (signBit ? -1 : 1) * significand * radix**exponent<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// If radix is 2 (the most common case), then for finite non-zero numbers<br>&gt;   /// `1 &lt;= significand` and `significand &lt; 2`.  For other values of `x`,<br>&gt;   /// `x.significand` is defined as follows:<br>&gt;   ///<br>&gt;   /// - If `x` is zero, then `x.significand` is 0.0.<br>&gt;   /// - If `x` is infinity, then `x.significand` is 1.0.<br>&gt;   /// - If `x` is NaN, then `x.significand` is NaN.<br>&gt;   ///<br>&gt;   /// For all floating-point `x`, if we define y by:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// let y = Self(signBit: x.signBit, exponent: x.exponent,<br>&gt;   ///              significand: x.significand)<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// then `y` is equivalent to `x`, meaning that `y` is `x` canonicalized.<br>&gt;   var significand: Self { get }<br>&gt; <br>&gt;   /// Initialize from signBit, exponent, and significand.<br>&gt;   ///<br>&gt;   /// The result is:<br>&gt;   ///<br>&gt;   /// ~~~<br>&gt;   /// (signBit ? -1 : 1) * significand * radix**exponent<br>&gt;   /// ~~~<br>&gt;   ///<br>&gt;   /// (where `**` is exponentiation) computed as if by a single correctly-<br>&gt;   /// rounded floating-point operation.  If this value is outside the<br>&gt;   /// representable range of the type, overflow or underflow occurs, and zero,<br>&gt;   /// a subnormal value, or infinity may result, as with any basic operation.<br>&gt;   /// Other edge cases:<br>&gt;   ///<br>&gt;   /// - If `significand` is zero or infinite, the result is zero or infinite,<br>&gt;   ///   regardless of the value of `exponent`.<br>&gt;   ///<br>&gt;   /// - If `significand` is NaN, the result is NaN.<br>&gt;   ///<br>&gt;   /// Note that for any floating-point `x` the result of<br>&gt;   ///<br>&gt;   ///   `Self(signBit: x.signBit,<br>&gt;   ///         exponent: x.exponent,<br>&gt;   ///         significand: x.significand)`<br>&gt;   ///<br>&gt;   /// is &quot;the same&quot; as `x`; it is `x` canonicalized.<br>&gt;   ///<br>&gt;   /// Because of these properties, this initializer implements the IEEE 754<br>&gt;   /// `scaleB` operation.<br>&gt;   init(signBit: Bool, exponent: Int, significand: Self)<br>&gt; <br>&gt;   /// A floating point value whose exponent and signficand are taken from<br>&gt;   /// `magnitude` and whose signBit is taken from `signOf`.  Implements the<br>&gt;   /// IEEE 754 `copysign` operation.<br>&gt;   //  TODO: better argument names would be great.<br>&gt;   init(magnitudeOf magnitude: Self, signOf: Self)<br>&gt; <br>&gt;   /// The least representable value that compares greater than `self`.<br>&gt;   ///<br>&gt;   /// - If `x` is `-infinity`, then `x.nextUp` is `-greatestMagnitude`.<br>&gt;   /// - If `x` is `-leastMagnitude`, then `x.nextUp` is `-0.0`.<br>&gt;   /// - If `x` is zero, then `x.nextUp` is `leastMagnitude`.<br>&gt;   /// - If `x` is `greatestMagnitude`, then `x.nextUp` is `infinity`.<br>&gt;   /// - If `x` is `infinity` or `NaN`, then `x.nextUp` is `x`.<br>&gt;   var nextUp: Self { get }<br>&gt; <br>&gt;   /// The greatest representable value that compares less than `self`.<br>&gt;   ///<br>&gt;   /// `x.nextDown` is equivalent to `-(-x).nextUp`<br>&gt;   var nextDown: Self { get }<br>&gt; <br>&gt;   /// Remainder of `self` divided by `other`.<br>&gt;   ///<br>&gt;   /// For finite `self` and `other`, the remainder `r` is defined by<br>&gt;   /// `r = self - other*n`, where `n` is the integer nearest to `self/other`.<br>&gt;   /// (Note that `n` is *not* `self/other` computed in floating-point<br>&gt;   /// arithmetic, and that `n` may not even be representable in any available<br>&gt;   /// integer type).  If `self/other` is exactly halfway between two integers,<br>&gt;   /// `n` is chosen to be even.<br>&gt;   ///<br>&gt;   /// It follows that if `self` and `other` are finite numbers, the remainder<br>&gt;   /// `r` satisfies `-|other|/2 &lt;= r` and `r &lt;= |other|/2`.<br>&gt;   ///<br>&gt;   /// `formRemainder` is always exact, and therefore is not affected by<br>&gt;   /// rounding modes.<br>&gt;   mutating func formRemainder(dividingBy other: Self)<br>&gt; <br>&gt;   /// Remainder of `self` divided by `other` using truncating division.<br>&gt;   ///<br>&gt;   /// If `self` and `other` are finite numbers, the truncating remainder<br>&gt;   /// `r` has the same sign as `other` and is strictly smaller in magnitude.<br>&gt;   /// It satisfies `r = self - other*n`, where `n` is the integral part<br>&gt;   /// of `self/other`.<br>&gt;   ///<br>&gt;   /// `formTruncatingRemainder` is always exact, and therefore is not<br>&gt;   /// affected by rounding modes.<br>&gt;   mutating func formTruncatingRemainder(dividingBy other: Self)<br>&gt; <br>&gt;   /// Mutating form of square root.<br>&gt;   mutating func formSquareRoot( )<br>&gt; <br>&gt;   /// Fused multiply-add, accumulating the product of `lhs` and `rhs` to `self`.<br>&gt;   mutating func addProduct(lhs: Self, _ rhs: Self)<br>&gt; <br>&gt;   /// Remainder of `self` divided by `other`.<br>&gt;   @warn_unused_result<br>&gt;   func remainder(dividingBy other: Self) -&gt; Self<br>&gt; <br>&gt;   /// Remainder of `self` divided by `other` using truncating division.<br>&gt;   @warn_unused_result<br>&gt;   func truncatingRemainder(dividingBy other: Self) -&gt; Self<br>&gt; <br>&gt;   /// Square root of `self`.<br>&gt;   @warn_unused_result<br>&gt;   func squareRoot( ) -&gt; Self<br>&gt; <br>&gt;   /// `self + lhs*rhs` computed without intermediate rounding.<br>&gt;   @warn_unused_result<br>&gt;   func addingProduct(lhs: Self, _ rhs: Self) -&gt; Self<br>&gt; <br>&gt;   /// The minimum of `x` and `y`.  Implements the IEEE 754 `minNum` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if `x &lt;= y`, `y` if `y &lt; x`, and whichever of `x` or `y`<br>&gt;   /// is a number if the other is NaN.  The result is NaN only if both <br>&gt;   /// arguments are NaN.<br>&gt;   ///<br>&gt;   /// This function is an implementation hook to be used by the free function<br>&gt;   /// min(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>&gt;   /// to NaNs.<br>&gt;   @warn_unused_result<br>&gt;   static func minimum(x: Self, _ y: Self) -&gt; Self<br>&gt; <br>&gt;   /// The maximum of `x` and `y`.  Implements the IEEE 754 `maxNum` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if `x &gt;= y`, `y` if `y &gt; x`, and whichever of `x` or `y`<br>&gt;   /// is a number if the other is NaN.  The result is NaN only if both<br>&gt;   /// arguments are NaN.<br>&gt;   ///<br>&gt;   /// This function is an implementation hook to be used by the free function<br>&gt;   /// max(Self, Self) -&gt; Self so that we get the IEEE 754 behavior with regard<br>&gt;   /// to NaNs.<br>&gt;   @warn_unused_result<br>&gt;   static func maximum(x: Self, _ y: Self) -&gt; Self<br>&gt; <br>&gt;   /// Whichever of `x` or `y` has lesser magnitude.  Implements the IEEE 754<br>&gt;   /// `minNumMag` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if abs(x) &lt;= abs(y), `y` if abs(y) &lt; abs(x), and whichever of<br>&gt;   /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>&gt;   /// only if both arguments are NaN.<br>&gt;   @warn_unused_result<br>&gt;   static func minimumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt; <br>&gt;   /// Whichever of `x` or `y` has greater magnitude.  Implements the IEEE 754<br>&gt;   /// `maxNumMag` operation.<br>&gt;   ///<br>&gt;   /// Returns `x` if abs(x) &gt;= abs(y), `y` if abs(y) &gt; abs(x), and whichever of<br>&gt;   /// `x` or `y` is a number if the other is NaN.  The result is NaN<br>&gt;   /// only if both arguments are NaN.<br>&gt;   @warn_unused_result<br>&gt;   static func maximumMagnitude(x: Self, _ y: Self) -&gt; Self<br>&gt; <br>&gt;   /// IEEE 754 equality predicate.<br>&gt;   ///<br>&gt;   /// -0 compares equal to +0, and NaN compares not equal to anything,<br>&gt;   /// including itself.<br>&gt;   @warn_unused_result<br>&gt;   func isEqual(to other: Self) -&gt; Bool<br>&gt; <br>&gt;   /// IEEE 754 less-than predicate.<br>&gt;   ///<br>&gt;   /// NaN compares not less than anything.  -infinity compares less than<br>&gt;   /// all values except for itself and NaN.  Everything except for NaN and<br>&gt;   /// +infinity compares less than +infinity.<br>&gt;   @warn_unused_result<br>&gt;   func isLess(than other: Self) -&gt; Bool<br>&gt; <br>&gt;   /// IEEE 754 less-than-or-equal predicate.<br>&gt;   ///<br>&gt;   /// NaN compares not less than or equal to anything, including itself.<br>&gt;   /// -infinity compares less than or equal to everything except NaN.<br>&gt;   /// Everything except NaN compares less than or equal to +infinity.<br>&gt;   ///<br>&gt;   /// Because of the existence of NaN in FloatingPoint types, trichotomy does<br>&gt;   /// not hold, which means that `x &lt; y` and `!(y &lt;= x)` are not equivalent.<br>&gt;   /// This is why `isLessThanOrEqual(to:)` is a separate implementation hook<br>&gt;   /// in the protocol.<br>&gt;   ///<br>&gt;   /// Note that this predicate does not impose a total order.  The `totalOrder`<br>&gt;   /// predicate provides a refinement satisfying that criteria.<br>&gt;   @warn_unused_result<br>&gt;   func isLessThanOrEqual(to other: Self) -&gt; Bool<br>&gt; <br>&gt;   /// IEEE 754 unordered predicate.  True if either `self` or `other` is NaN,<br>&gt;   /// and false otherwise.<br>&gt;   @warn_unused_result<br>&gt;   func isUnordered(with other: Self) -&gt; Bool<br>&gt; <br>&gt;   /// True if and only if `self` is normal.<br>&gt;   ///<br>&gt;   /// A normal number uses the full precision available in the format.  Zero<br>&gt;   /// is not a normal number.<br>&gt;   var isNormal: Bool { get }<br>&gt; <br>&gt;   /// True if and only if `self` is finite.<br>&gt;   ///<br>&gt;   /// If `x.isFinite` is `true`, then one of `x.isZero`, `x.isSubnormal`, or<br>&gt;   /// `x.isNormal` is also `true`, and `x.isInfinite` and `x.isNan` are<br>&gt;   /// `false`.<br>&gt;   var isFinite: Bool { get }<br>&gt; <br>&gt;   /// True iff `self` is zero.  Equivalent to `self == 0`.<br>&gt;   var isZero: Bool { get }<br>&gt; <br>&gt;   /// True if and only if `self` is subnormal.<br>&gt;   ///<br>&gt;   /// A subnormal number does not use the full precision available to normal<br>&gt;   /// numbers of the same format.  Zero is not a subnormal number.<br>&gt;   var isSubnormal: Bool { get }<br>&gt; <br>&gt;   /// True if and only if `self` is infinite.<br>&gt;   ///<br>&gt;   /// Note that `isFinite` and `isInfinite` do not form a dichotomy, because<br>&gt;   /// they are not total.  If `x` is `NaN`, then both properties are `false`.<br>&gt;   var isInfinite: Bool { get }<br>&gt; <br>&gt;   /// True if and only if `self` is NaN (&quot;not a number&quot;).<br>&gt;   var isNan: Bool { get }<br>&gt; <br>&gt;   /// True if and only if `self` is a signaling NaN.<br>&gt;   var isSignalingNan: Bool { get }<br>&gt; <br>&gt;   /// The IEEE 754 &quot;class&quot; of this type.<br>&gt;   var floatingPointClass: FloatingPointClassification { get }<br>&gt; <br>&gt;   /// True if and only if `self` is canonical.<br>&gt;   ///<br>&gt;   /// Every floating-point value of type Float or Double is canonical, but<br>&gt;   /// non-canonical values of type Float80 exist, and non-canonical values<br>&gt;   /// may exist for other types that conform to FloatingPoint.<br>&gt;   ///<br>&gt;   /// The non-canonical Float80 values are known as &quot;pseudo-denormal&quot;,<br>&gt;   /// &quot;unnormal&quot;, &quot;pseudo-infinity&quot;, and &quot;pseudo-NaN&quot;.<br>&gt;   /// (https://en.wikipedia.org/wiki/Extended_precision#x86_Extended_Precision_Format)<br>&gt;   var isCanonical: Bool { get }<br>&gt; <br>&gt;   /// True if and only if `self` preceeds `other` in the IEEE 754 total order<br>&gt;   /// relation.<br>&gt;   ///<br>&gt;   /// This relation is a refinement of `&lt;=` that provides a total order on all<br>&gt;   /// values of type `Self`, including non-canonical encodings, signed zeros,<br>&gt;   /// and NaNs.  Because it is used much less frequently than the usual<br>&gt;   /// comparisons, there is no operator form of this relation.<br>&gt;   @warn_unused_result<br>&gt;   func totalOrder(with other: Self) -&gt; Bool<br>&gt; <br>&gt;   /// True if and only if `abs(self)` preceeds `abs(other)` in the IEEE 754<br>&gt;   /// total order relation.<br>&gt;   @warn_unused_result<br>&gt;   func totalOrderMagnitude(with other: Self) -&gt; Bool<br>&gt; <br>&gt;   /// The closest representable value to the argument.<br>&gt;   init&lt;Source: Integer&gt;(_ value: Source)<br>&gt; <br>&gt;   /// Fails if the argument cannot be exactly represented.<br>&gt;   init?&lt;Source: Integer&gt;(exactly value: Source)<br>&gt; }<br>&gt; The BinaryFloatingPoint protocol provides a number of additional APIs that only make sense for types with fixed radix 2:<br>&gt; <br>&gt; /// A radix-2 (binary) floating-point type that follows the IEEE 754 encoding<br>&gt; /// conventions.<br>&gt; public protocol BinaryFloatingPoint: FloatingPoint {<br>&gt; <br>&gt;   /// The number of bits used to represent the exponent.<br>&gt;   ///<br>&gt;   /// Following IEEE 754 encoding convention, the exponent bias is:<br>&gt;   ///<br>&gt;   ///   bias = 2**(exponentBitCount-1) - 1<br>&gt;   ///<br>&gt;   /// The least normal exponent is `1-bias` and the largest finite exponent<br>&gt;   /// is `bias`.  The all-zeros exponent is reserved for subnormals and zeros,<br>&gt;   /// and the all-ones exponent is reserved for infinities and NaNs.<br>&gt;   static var exponentBitCount: Int { get }<br>&gt; <br>&gt;   /// For fixed-width floating-point types, this is the number of fractional<br>&gt;   /// significand bits.<br>&gt;   ///<br>&gt;   /// For extensible floating-point types, `significandBitCount` should be<br>&gt;   /// the maximum allowed significand width (without counting any leading<br>&gt;   /// integral bit of the significand).  If there is no upper limit, then<br>&gt;   /// `significandBitCount` should be `Int.max`.<br>&gt;   ///<br>&gt;   /// Note that `Float80.significandBitCount` is 63, even though 64 bits<br>&gt;   /// are used to store the significand in the memory representation of a<br>&gt;   /// `Float80` (unlike other floating-point types, `Float80` explicitly<br>&gt;   /// stores the leading integral significand bit, but the<br>&gt;   /// `BinaryFloatingPoint` APIs provide an abstraction so that users don&#39;t<br>&gt;   /// need to be aware of this detail).<br>&gt;   static var significandBitCount: Int { get }<br>&gt; <br>&gt;   /// The raw encoding of the exponent field of the floating-point value.<br>&gt;   var exponentBitPattern: UInt { get }<br>&gt; <br>&gt;   /// The raw encoding of the significand field of the floating-point value.<br>&gt;   ///<br>&gt;   /// `significandBitPattern` does *not* include the leading integral bit of<br>&gt;   /// the significand, even for types like `Float80` that store it explicitly.<br>&gt;   var significandBitPattern: RawSignificand { get }<br>&gt; <br>&gt;   /// Combines `signBit`, `exponent` and `significand` bit patterns to produce<br>&gt;   /// a floating-point value.<br>&gt;   init(signBit: Bool,<br>&gt;        exponentBitPattern: UInt,<br>&gt;        significandBitPattern: RawSignificand)<br>&gt; <br>&gt;   /// The least-magnitude member of the binade of `self`.<br>&gt;   ///<br>&gt;   /// If `x` is `+/-significand * 2**exponent`, then `x.binade` is<br>&gt;   /// `+/- 2**exponent`; i.e. the floating point number with the same sign<br>&gt;   /// and exponent, but with a significand of 1.0.<br>&gt;   var binade: Self { get }<br>&gt; <br>&gt;   /// The number of bits required to represent significand.<br>&gt;   ///<br>&gt;   /// If `self` is not a finite non-zero number, `significandWidth` is<br>&gt;   /// `-1`.  Otherwise, it is the number of bits required to represent the<br>&gt;   /// significand exactly (less `1` because common formats represent one bit<br>&gt;   /// implicitly).<br>&gt;   var significandWidth: Int { get }<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   func isEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   func isLess&lt;Other: BinaryFloatingPoint&gt;(than other: Other) -&gt; Bool<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   func isLessThanOrEqual&lt;Other: BinaryFloatingPoint&gt;(to other: Other) -&gt; Bool<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   func isUnordered&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt; <br>&gt;   @warn_unused_result<br>&gt;   func totalOrder&lt;Other: BinaryFloatingPoint&gt;(with other: Other) -&gt; Bool<br>&gt; <br>&gt;   /// `value` rounded to the closest representable value.<br>&gt;   init&lt;Source: BinaryFloatingPoint&gt;(_ value: Source)<br>&gt; <br>&gt;   /// Fails if `value` cannot be represented exactly as `Self`.<br>&gt;   init?&lt;Source: BinaryFloatingPoint&gt;(exactly value: Source)<br>&gt; }<br>&gt; Float, Double, Float80 and CGFloat will conform to all of these protocols.<br>&gt; <br>&gt; A small portion of the implementation of these APIs is dependent on new Integer protocols that will be proposed separately. Everything else is implemented in draft form on the branch floating-point-revision of my fork.<br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; The % operator is no longer available for FloatingPoint types. We don&#39;t believe that it was widely used correctly, and the operation is still available via the formTruncatingRemainder method for people who need it.<br>&gt; <br>&gt; To follow the naming guidelines, NaN and isNaN are replaced with nan and isNan.<br>&gt; <br>&gt; The redundant property quietNaN is removed.<br>&gt; <br>&gt; isSignaling is renamed isSignalingNan.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; N/A.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/48c4942e/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
