<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/154b79f484b74617fe0bea7b5cc5c35a?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Grzegorz Adam Hankiewicz</string> &lt;swift at gradha.imap.cc&gt;<p>January  5, 2016 at 05:00:00pm</p></header><div class="content"><p>Hello, newcomer here.<br></p><p>The other day I was reading about https://www.reddit.com/r/swift/comments/3zbk64/type_math/ and given the verbose solutions decided to pitch a possible language improvement. But after reading through the archives it seems that this idea has already been pitched before:<br></p><p>* Proposal: newtype feature for creating brand new types from existing types<br></p><p>- https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html<br></p><p>- https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001826.html<br></p><p>Some time later:<br></p><p>* Epic: Typesafe calculations<br></p><p>- https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004735.html<br></p><p>Since this is already known I would like to talk about this potential feature in order to address the perceived lack of community interest.<br></p><p>Recently I’ve been bitten by a lack of this feature for code dealing with database serialisation. If a database table is modelled as an object it will most likely use integers or longs to represent primary and foreign keys. An example would be:<br></p><p>struct SomeTable {<br>    var primaryKey: Int64<br>    var otherTableForeignKey: Int64<br>    var yeatAnotherForeginKey: Int64<br>}<br></p><p>Unfortunately the types can be mixed, one can assign the value from otherTableForeignKey to primaryKey without impunity. Using the reddit proposed struct as separate type would help here:<br></p><p>    public struct RefTablePk {<br>        private let value: Int64<br>    }<br></p><p>    public struct SomeTablePk {<br>        private let value: Int64<br>    }<br></p><p>    struct RefTable {<br>        var primaryKey: RefTablePk<br>    }<br></p><p>    struct SomeTable {<br>        var primaryKey = SomeTablePk(value: 0)<br>        var otherTableForeignKey = RefTablePk(value: 0)<br>    }<br></p><p>    var a = SomeTable()<br>    a.primaryKey = SomeTablePk(value: 3)<br>    a.otherTableForeignKey = a.primaryKey // Fails, good!<br>    print(a.primaryKey.value)<br></p><p>So far so good. The solution gets more hairy when one attempts to use such fake types for mathematical operations because the new type doesn’t inherit possible operations done on the parent type it is based of:<br></p><p>    public struct Euros {<br>        private let value: Double<br>    }<br></p><p>    public struct Dollars {<br>        private let value: Double<br>    }<br></p><p>    var account = Euros(value: 100)<br>    var bill = Euros(value: 42)<br>    account = account - bill<br></p><p>The last line won’t compile: Binary operator ‘-‘ cannot be applied to two ‘Euros’ operands. The immediate solution would be to add variants of all the usual operators for every type, which quickly gets tedious and verbose. On top of this, each *new* type is generating code, which is actually not desirable. The ideal would be for the compiler to pretend Euros or RefTablePk are different types, yet use their parent type at the binary level. This needs a specific syntax to teach the compiler which existing methods/operations are allowed on the new fake types and which aren’t. These new distinct types would *borrow* previous implementations.<br></p><p>Other examples of possible use for such fake types (note again: these exist only at compilation time and generate no extra code) would be user input validation. Strings coming from *the exterior* (whatever that might be) could use a distinct type of TaintedString instead of the usual String, and would require a validation or converter function to produce a correct String, or maybe a ValidatedString for better distinction. Similarly for a security library it would be useful to mark Strings as encrypted. The EncryptedString would be tracked by the compiler to prevent mistakes or uses where plaintext strings are expected. One bug I recently had the pleasure to solve was mixing time units, some APIs use seconds, other use milliseconds, both store the values as longs. The *fix* was to wrap all primitive type access inside objects with explicit methods having the unit in their signature. Effective, but tedious and verbose.<br></p><p>The typealias jumped out of the swift language documentation while I was reading it, but it is actually the opposite of the desired behaviour. The current type alias doesn’t prevent one from mixing these new fake types so it has effectively the same value as a user comment. Also, having seen https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md it seems that the keyword won’t be used any more, plus it would be convenient to invent a new one to avoid migration mistakes.<br></p><p>Examples I know of this feature in other languages and/or implementations which can be used for reference/inspiration:<br></p><p>- C++. I asked http://stackoverflow.com/questions/23726038/how-can-i-create-a-new-primitive-type-using-c11-style-strong-typedefs while following a talk by Bjarne Stroustrup and some of the answers include using boost units (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units/Units.html) to alleviate writing the required boilerplate code. The library was already mentioned here as reference in previous threads.<br></p><p>- Nim (http://nim-lang.org). Defined as distinct types (http://nim-lang.org/docs/manual.html#types-distinct-type) they can be used with the borrow pragma and templates to avoid boilerplate code yet customise which existing procs can be applied to the new distinct type.<br></p><p>- Java. The language doesn’t allow this kind of fake types, but it has been patched to various degrees through annotation support. Recently Android Studio added resource type annotations (http://tools.android.com/tech-docs/support-annotations#TOC-Resource-Type-Annotations) for mobile developers which allow marking integers with @StringRes, @IntegerRes and similar. The linter will look for these annotations and issue warnings when the assigned literals don’t satisfy the requirements. A more generic approach can be found in the Checker Framework in the Subtyping checker (http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#subtyping-checker). The provided example shows how this hypothetical encrypted/plaintext string distinction would work. They also support the typical units annotations (http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#units-checker).<br></p><p>Precisely this last reference is an argument against implementing this feature directly at the language level. I’ve seen that there is an attributes proposal (https://github.com/rsmogura/swift/wiki/Attributes-Proposal) which would provide the equivalent of java’s annotations. Given that Java has a checker framework it would surely make sense to implement this similarly in swift? I don’t think so. Essentially nobody I’ve worked with knows about such annotations or external tools (sad). While anecdotal, it’s easy for me to think that annotations are easy to brush off and forget.<br></p><p>And that’s why I’ve written this email, hopefully I can spur interest in others for this feature so that it becomes a first class citizen of the language at some point. I still haven’t got enough experience with swift to make a more concrete proposal. If nobody picks this up you may hear from me in the future.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 10:00:00am</p></header><div class="content"><p>Thanks for doing the work to collect links related to this topic!  I am planning to give them a read.<br></p><p>You may be interested in the proposal I am working on for automatic protocol forwarding.  <br></p><p>The first draft was posted to the list last week: https://github.com/anandabits/swift-evolution/blob/automatic-protocol-forwarding/proposals/NNNN-automatic-protocol-forwarding.md &lt;https://github.com/anandabits/swift-evolution/blob/automatic-protocol-forwarding/proposals/NNNN-automatic-protocol-forwarding.md&gt;.  It will give you an idea of where the proposal is going, although it is somewhat out of date at this point.  The motivation section is also not fully fleshed out.  Several good suggestions came up during the discussion leading to some important design changes.<br></p><p>I am working on a significantly enhanced second draft right now.  It will include examples showing how it can be used to achieve a similar effect to `newtype` (as well as several other examples).  It won’t be quite as concise syntactically as it is designed to support many use cases, not just the `newtype` use case.  A future enhancement to that proposal might allow more concise syntax to better support the `newtype` use case.<br></p><p>I am hoping to have the second draft ready to share soon.  <br></p><p>Matthew<br></p><p>&gt; On Jan 5, 2016, at 10:11 AM, Grzegorz Adam Hankiewicz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, newcomer here.<br>&gt; <br>&gt; The other day I was reading about https://www.reddit.com/r/swift/comments/3zbk64/type_math/ and given the verbose solutions decided to pitch a possible language improvement. But after reading through the archives it seems that this idea has already been pitched before:<br>&gt; <br>&gt; * Proposal: newtype feature for creating brand new types from existing types<br>&gt; <br>&gt; - https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html<br>&gt; <br>&gt; - https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001826.html<br>&gt; <br>&gt; Some time later:<br>&gt; <br>&gt; * Epic: Typesafe calculations<br>&gt; <br>&gt; - https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151228/004735.html<br>&gt; <br>&gt; Since this is already known I would like to talk about this potential feature in order to address the perceived lack of community interest.<br>&gt; <br>&gt; Recently I’ve been bitten by a lack of this feature for code dealing with database serialisation. If a database table is modelled as an object it will most likely use integers or longs to represent primary and foreign keys. An example would be:<br>&gt; <br>&gt; struct SomeTable {<br>&gt;    var primaryKey: Int64<br>&gt;    var otherTableForeignKey: Int64<br>&gt;    var yeatAnotherForeginKey: Int64<br>&gt; }<br>&gt; <br>&gt; Unfortunately the types can be mixed, one can assign the value from otherTableForeignKey to primaryKey without impunity. Using the reddit proposed struct as separate type would help here:<br>&gt; <br>&gt;    public struct RefTablePk {<br>&gt;        private let value: Int64<br>&gt;    }<br>&gt; <br>&gt;    public struct SomeTablePk {<br>&gt;        private let value: Int64<br>&gt;    }<br>&gt; <br>&gt;    struct RefTable {<br>&gt;        var primaryKey: RefTablePk<br>&gt;    }<br>&gt; <br>&gt;    struct SomeTable {<br>&gt;        var primaryKey = SomeTablePk(value: 0)<br>&gt;        var otherTableForeignKey = RefTablePk(value: 0)<br>&gt;    }<br>&gt; <br>&gt;    var a = SomeTable()<br>&gt;    a.primaryKey = SomeTablePk(value: 3)<br>&gt;    a.otherTableForeignKey = a.primaryKey // Fails, good!<br>&gt;    print(a.primaryKey.value)<br>&gt; <br>&gt; So far so good. The solution gets more hairy when one attempts to use such fake types for mathematical operations because the new type doesn’t inherit possible operations done on the parent type it is based of:<br>&gt; <br>&gt;    public struct Euros {<br>&gt;        private let value: Double<br>&gt;    }<br>&gt; <br>&gt;    public struct Dollars {<br>&gt;        private let value: Double<br>&gt;    }<br>&gt; <br>&gt;    var account = Euros(value: 100)<br>&gt;    var bill = Euros(value: 42)<br>&gt;    account = account - bill<br>&gt; <br>&gt; The last line won’t compile: Binary operator ‘-‘ cannot be applied to two ‘Euros’ operands. The immediate solution would be to add variants of all the usual operators for every type, which quickly gets tedious and verbose. On top of this, each *new* type is generating code, which is actually not desirable. The ideal would be for the compiler to pretend Euros or RefTablePk are different types, yet use their parent type at the binary level. This needs a specific syntax to teach the compiler which existing methods/operations are allowed on the new fake types and which aren’t. These new distinct types would *borrow* previous implementations.<br>&gt; <br>&gt; Other examples of possible use for such fake types (note again: these exist only at compilation time and generate no extra code) would be user input validation. Strings coming from *the exterior* (whatever that might be) could use a distinct type of TaintedString instead of the usual String, and would require a validation or converter function to produce a correct String, or maybe a ValidatedString for better distinction. Similarly for a security library it would be useful to mark Strings as encrypted. The EncryptedString would be tracked by the compiler to prevent mistakes or uses where plaintext strings are expected. One bug I recently had the pleasure to solve was mixing time units, some APIs use seconds, other use milliseconds, both store the values as longs. The *fix* was to wrap all primitive type access inside objects with explicit methods having the unit in their signature. Effective, but tedious and verbose.<br>&gt; <br>&gt; The typealias jumped out of the swift language documentation while I was reading it, but it is actually the opposite of the desired behaviour. The current type alias doesn’t prevent one from mixing these new fake types so it has effectively the same value as a user comment. Also, having seen https://github.com/apple/swift-evolution/blob/master/proposals/0011-replace-typealias-associated.md it seems that the keyword won’t be used any more, plus it would be convenient to invent a new one to avoid migration mistakes.<br>&gt; <br>&gt; Examples I know of this feature in other languages and/or implementations which can be used for reference/inspiration:<br>&gt; <br>&gt; - C++. I asked http://stackoverflow.com/questions/23726038/how-can-i-create-a-new-primitive-type-using-c11-style-strong-typedefs while following a talk by Bjarne Stroustrup and some of the answers include using boost units (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units/Units.html) to alleviate writing the required boilerplate code. The library was already mentioned here as reference in previous threads.<br>&gt; <br>&gt; - Nim (http://nim-lang.org). Defined as distinct types (http://nim-lang.org/docs/manual.html#types-distinct-type) they can be used with the borrow pragma and templates to avoid boilerplate code yet customise which existing procs can be applied to the new distinct type.<br>&gt; <br>&gt; - Java. The language doesn’t allow this kind of fake types, but it has been patched to various degrees through annotation support. Recently Android Studio added resource type annotations (http://tools.android.com/tech-docs/support-annotations#TOC-Resource-Type-Annotations) for mobile developers which allow marking integers with @StringRes, @IntegerRes and similar. The linter will look for these annotations and issue warnings when the assigned literals don’t satisfy the requirements. A more generic approach can be found in the Checker Framework in the Subtyping checker (http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#subtyping-checker). The provided example shows how this hypothetical encrypted/plaintext string distinction would work. They also support the typical units annotations (http://types.cs.washington.edu/checker-framework/current/checker-framework-manual.html#units-checker).<br>&gt; <br>&gt; Precisely this last reference is an argument against implementing this feature directly at the language level. I’ve seen that there is an attributes proposal (https://github.com/rsmogura/swift/wiki/Attributes-Proposal) which would provide the equivalent of java’s annotations. Given that Java has a checker framework it would surely make sense to implement this similarly in swift? I don’t think so. Essentially nobody I’ve worked with knows about such annotations or external tools (sad). While anecdotal, it’s easy for me to think that annotations are easy to brush off and forget.<br>&gt; <br>&gt; And that’s why I’ve written this email, hopefully I can spur interest in others for this feature so that it becomes a first class citizen of the language at some point. I still haven’t got enough experience with swift to make a more concrete proposal. If nobody picks this up you may hear from me in the future.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/b653793c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; The ideal would be for the compiler to pretend Euros or RefTablePk are different types, yet use their parent type at the binary level. This needs a specific syntax to teach the compiler which existing methods/operations are allowed on the new fake types and which aren’t. These new distinct types would *borrow* previous implementations.<br></p><p>What about citing the relevant protocols in the newtype definition? This should include the ability to use my own protocols to which I have made the underlying type conform to by an extension.<br></p><p>Throwing some syntax into the discussion:<br></p><p>newtype Euro = Double : Addable, Subtractable<br></p><p>where I have defined the protocols Addable and Subtractable somewhere and made Double conform to them if all this is not provided by the standard library.<br>The implementation of Euro then borrows the implementation of Double for these protocols.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk are different types, yet use their parent type at the binary level. This needs a specific syntax to teach the compiler which existing methods/operations are allowed on the new fake types and which aren’t. These new distinct types would *borrow* previous implementations.<br>&gt; <br>&gt; What about citing the relevant protocols in the newtype definition? This should include the ability to use my own protocols to which I have made the underlying type conform to by an extension.<br></p><p>This is how my forwarding proposal works.  The newtype syntax I suggested as a possible extension looks like this:<br></p><p>newtype Euro = Double forwarding Addable, Subtractable<br></p><p>The keyword could be different, but I think `forwarding` is not bad.  When I complete the second draft I think it will make even more sense.  The forwarding facility has features to handle non-trivial cases (Self and associated type requirements, etc).<br></p><p>&gt; <br>&gt; Throwing some syntax into the discussion:<br>&gt; <br>&gt; newtype Euro = Double : Addable, Subtractable<br>&gt; <br>&gt; where I have defined the protocols Addable and Subtractable somewhere and made Double conform to them if all this is not provided by the standard library.<br>&gt; The implementation of Euro then borrows the implementation of Double for these protocols.<br>&gt; <br>&gt; -Thorsten <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  6, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;ve managed to implement this already in the language with a few ugly<br>corners due to the lack of generic protocols.<br></p><p>I created a protocol based on Box (https://github.com/robrix/Box/) which<br>works really well. I have extended this to handle certain special protocols<br>like Equatable so you can do SpecialType == SpecialType, and even<br>literalConversion.<br></p><p>There is however a lot of boilerplate:<br></p><p>- You have to declare all of your Convertible protocols for converting from<br>one type to another<br>- You have to define an empty init so the protocol extensions have<br>something to chain to.<br>- You need to write the value property with type.<br></p><p>Due to the lack of protocol generics, you also need to have a protocol for<br>every type you wish to box which sets the associated type. Of course I<br>could have done this with classes but I wanted to keep this as a value type<br>:).<br></p><p>With member-wise initializations and generic protocols this could be<br>achievable just by adding a Box protocol to the standard library.<br></p><p>Here is my implementation of Box as a protocol:<br></p><p>*protocol Box: CustomStringConvertible, CustomDebugStringConvertible {*<br></p><p><br></p><p>*    typealias FloatLiteralType = Double*<br></p><p>*    typealias IntegerLiteralType = Int*<br></p><p>*    typealias BoxType = Any*<br></p><p><br></p><p>*    var value: BoxType { get set }*<br></p><p><br></p><p>*    init()*<br></p><p>*    init(_ value: BoxType)*<br></p><p>*}*<br></p><p><br>*extension Box where BoxType: CustomStringConvertible {*<br></p><p><br></p><p>*    var description: String {*<br></p><p>*        return self.value.description*<br></p><p>*    }*<br></p><p><br></p><p>*    var debugDescription: String {*<br></p><p>*        return &quot;\(self.value.description)㎭&quot;*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*//MARK: FloatingPointBox*<br></p><p><br>*protocol FloatingPointBox: Box, FloatLiteralConvertible,<br>IntegerLiteralConvertible {*<br></p><p><br></p><p>*    typealias BoxType = Double*<br></p><p>*    typealias FloatLiteralConvertible = Double*<br></p><p>*    typealias IntegerLiteralConvertible = Int*<br></p><p>*}*<br></p><p><br>*extension Box where Self.BoxType == Double {*<br></p><p><br></p><p>*    init(_ value: Double) {*<br></p><p><br></p><p>*        self.init()*<br></p><p>*        self.value = value*<br></p><p>*    }*<br></p><p><br></p><p>*    init(_ value: Int) {*<br></p><p><br></p><p>*        self.init()*<br></p><p>*        self.value = Double(value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension FloatLiteralType {*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br></p><p>*        self.init(box.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br></p><p>*        self.init(box.value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*extension CGFloat {*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Double &gt;(_ box: T) {*<br></p><p>*        self.init(box.value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: Box where T.BoxType == Int &gt;(_ box: T) {*<br></p><p>*        self.init(box.value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*//Adding FloatLiteralConvertible, IntegerLiteralConvertible*<br></p><p><br>*extension FloatingPointBox where Self.BoxType == Double,<br>Self.FloatLiteralConvertible == Double {*<br></p><p><br></p><p>*    init(floatLiteral value: Double) {*<br></p><p>*        self.init(value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init(integerLiteral value: Int) {*<br></p><p>*        self.init(value)*<br></p><p>*    }*<br></p><p><br></p><p>*    init&lt;T: IntegerType&gt;(_ value: T) {*<br></p><p>*        self.init(value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p>Here is my example of using the Box protocol:<br></p><p>*struct Degree: FloatingPointBox {*<br></p><p><br></p><p>*    var value: Double = 0*<br></p><p><br></p><p>*    init()*<br></p><p>*    {*<br></p><p>*    }*<br></p><p>*}*<br></p><p><br>*protocol DegreeConvertiable {*<br></p><p><br></p><p>*    init(degreeLiteral value: Degree)*<br></p><p>*}*<br></p><p><br>*extension Degree: RadianConvertiable {*<br></p><p><br></p><p>*    init(radianLiteral value: Radian) {*<br></p><p>*        self.value = Double(value) * 180.0 / M_PI*<br></p><p>*    }*<br></p><p><br></p><p>*    init(_ value: Radian) {*<br></p><p>*        self.init(radianLiteral: value)*<br></p><p>*    }*<br></p><p>*}*<br></p><p>On Tue, Jan 5, 2016 at 5:24 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 5, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 05.01.2016 um 17:11 schrieb Grzegorz Adam Hankiewicz via<br>&gt; swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The ideal would be for the compiler to pretend Euros or RefTablePk are<br>&gt; different types, yet use their parent type at the binary level. This needs<br>&gt; a specific syntax to teach the compiler which existing methods/operations<br>&gt; are allowed on the new fake types and which aren’t. These new distinct<br>&gt; types would *borrow* previous implementations.<br>&gt; &gt;<br>&gt; &gt; What about citing the relevant protocols in the newtype definition? This<br>&gt; should include the ability to use my own protocols to which I have made the<br>&gt; underlying type conform to by an extension.<br>&gt;<br>&gt; This is how my forwarding proposal works.  The newtype syntax I suggested<br>&gt; as a possible extension looks like this:<br>&gt;<br>&gt; newtype Euro = Double forwarding Addable, Subtractable<br>&gt;<br>&gt; The keyword could be different, but I think `forwarding` is not bad.  When<br>&gt; I complete the second draft I think it will make even more sense.  The<br>&gt; forwarding facility has features to handle non-trivial cases (Self and<br>&gt; associated type requirements, etc).<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Throwing some syntax into the discussion:<br>&gt; &gt;<br>&gt; &gt; newtype Euro = Double : Addable, Subtractable<br>&gt; &gt;<br>&gt; &gt; where I have defined the protocols Addable and Subtractable somewhere<br>&gt; and made Double conform to them if all this is not provided by the standard<br>&gt; library.<br>&gt; &gt; The implementation of Euro then borrows the implementation of Double for<br>&gt; these protocols.<br>&gt; &gt;<br>&gt; &gt; -Thorsten<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/ef1371cf/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Support for newtype feature/typesafe calculations</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>January  5, 2016 at 05:00:00pm</p></header><div class="content"><p>I’m not saying your proposal would not be useful, but in the case of all of your examples, there are solutions that can be implemented now that might be better than just creating a new-type-but-exactly-the-same.<br></p><p>&gt; On 5 Jan 2016, at 16:11, Grzegorz Adam Hankiewicz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The other day I was reading about https://www.reddit.com/r/swift/comments/3zbk64/type_math/<br></p><p>The idea of having a different type for each unit of distance is just wrong. You have one type for Distance with a value in a canonical unit and properties that extract the value in different units e.g<br></p><p>struct Distance<br>{<br>    let m: Double // SI unit of distance<br>    var km: Double { return m / 1000 }<br>    var cm: Double { return m * 100 }<br>    var miles: Double { return km * 0.62 }<br>}<br></p><p>Then you only need one set of addition and subtraction operators. You would also have multiplication by a dimensionless constant yielding a Distance and multiplication of two Distances yielding an Area.<br></p><p><br>&gt; struct SomeTable {<br>&gt;    var primaryKey: Int64<br>&gt;    var otherTableForeignKey: Int64<br>&gt;    var yeatAnotherForeginKey: Int64<br>&gt; }<br>&gt; <br>&gt; Unfortunately the types can be mixed, one can assign the value from otherTableForeignKey to primaryKey without impunity.<br>&gt; Using the reddit proposed struct as separate type would help here:<br>&gt; <br>&gt;    public struct RefTablePk {<br>&gt;        private let value: Int64<br>&gt;    }<br>&gt; <br>&gt;    public struct SomeTablePk {<br>&gt;        private let value: Int64<br>&gt;    }<br>&gt; <br>&gt;    struct RefTable {<br>&gt;        var primaryKey: RefTablePk<br>&gt;    }<br>&gt; <br>&gt;    struct SomeTable {<br>&gt;        var primaryKey = SomeTablePk(value: 0)<br>&gt;        var otherTableForeignKey = RefTablePk(value: 0)<br>&gt;    }<br>&gt; <br>&gt;    var a = SomeTable()<br>&gt;    a.primaryKey = SomeTablePk(value: 3)<br>&gt;    a.otherTableForeignKey = a.primaryKey // Fails, good!<br>&gt;    print(a.primaryKey.value)<br></p><p>That all looks fine except, why not take advantage of nested types:<br></p><p>struct SomeTable<br>{<br>    struct PrimaryKey { let value: Int }<br></p><p>    var primaryKey: PrimaryKey<br>    var refTableId: RefTable.PrimaryKey<br>}<br></p><p>&gt; <br>&gt; So far so good. The solution gets more hairy when one attempts to use such fake types for mathematical operations<br></p><p>Why would you want to do mathematical operations on the primary key of a table? Primary keys obviously need to be Equatable and possibly Comparable (except what if the database uses a GUID as its key) but that is about it.<br></p><p>&gt;    public struct Euros {<br>&gt;        private let value: Double<br>&gt;    }<br>&gt; <br>&gt;    public struct Dollars {<br>&gt;        private let value: Double<br>&gt;    }<br>&gt; <br>&gt;    var account = Euros(value: 100)<br>&gt;    var bill = Euros(value: 42)<br>&gt;    account = account - bill<br>&gt; <br>&gt; The last line won’t compile: Binary operator ‘-‘ cannot be applied to two ‘Euros’ operands.<br></p><p>How about a Currency protocol?<br></p><p>protocol Currency<br>{<br>    // value in smallest unit of currency e.g. EUR = cents, GBP = pence<br>    var rawValue: Int64 { get }<br>    init(rawValue: Int64)<br>}<br></p><p>func -&lt;T: Currency&gt;(a: T, b: T) -&gt; T<br>{<br>    return T(rawValue: a.rawValue - b.rawValue)<br>}<br></p><p>struct EUR: Currency<br>{<br>    var rawValue: Int64<br>}<br></p><p>struct USD: Currency<br>{<br>    var rawValue: Int64<br>}<br></p><p>let foo = EUR(rawValue: 2000)<br>let bar = EUR(rawValue: 1000)<br></p><p>let baz = foo - bar // compiles<br></p><p>let whizz = USD(rawValue: 4000)<br></p><p>let biz = baz - whizz // error: binary operator &#39;-&#39; cannot be applied to operands of type &#39;EUR&#39; and &#39;USD&#39;<br></p><p>Only one - operator needs to be defined for all currencies and the fact that EUR and USD are intended to model currencies is self documenting.<br></p><p>So I don’t think any of your examples are compelling evidence for your proposal. That’s not to say there are not good reasons for it, I just haven’t seen them yet.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
