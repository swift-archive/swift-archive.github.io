<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  6, 2016 at 01:00:00pm</p></header><div class="content"><p>on Thu May 05 2016, Nate Cook &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thanks for the feedback, Dmitri &amp;co, this all looks excellent! I&#39;ll work on updating the proposal.<br>&gt;<br>&gt;&gt; On May 5, 2016, at 6:13 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, May 3, 2016 at 8:57 PM, Chris Lattner via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9.<br>&gt;&gt; <br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; I&#39;m posting this feedback on behalf of Dave Abrahams, Max Moiseev and<br>&gt;&gt; myself.  We met and discussed the proposal in great detail.<br>&gt;&gt; <br>&gt;&gt; First of all, we want to thank Nate and Sergey for proposing this API,<br>&gt;&gt; which is an important and useful algorithm.  We are generally in favor<br>&gt;&gt; of the proposal, but we would like to request a few changes.<br>&gt;&gt; <br>&gt;&gt; Could you make &#39;func rotate&#39; a requirement in the MutableCollection<br>&gt;&gt; protocol?  This allows selecting the best implementation for a given<br>&gt;&gt; concrete type, even when calling from generic code.<br>&gt;&gt; <br>&gt;&gt; Could you explain why do we need a special implementation of<br>&gt;&gt; &#39;reverse()&#39; for RandomAccessCollection?  We couldn&#39;t think of a<br>&gt;&gt; performance reason for this.<br>&gt;<br>&gt; With a bidirectional collection, you have to compare the high and low<br>&gt; index at each iteration, stopping when low &gt;= high (before indices<br>&gt; were Comparable, this required two equality comparisons per<br>&gt; iteration). With a random-access collection, you can optimize the loop<br>&gt; to use a fixed number of iterations, which should be more efficient.<br></p><p>How can you reverse a variable-length collection with a fixed number of<br>iterations?  Are you talking about loop unrolling in the library?<br></p><p>&gt;<br>&gt;<br>&gt;&gt; Could you add complexity clauses to all new documentation comments?<br>&gt;&gt; <br>&gt;&gt; We have discussed the names for these functions at length.  We felt<br>&gt;&gt; like the argument in &#39;rotate(firstFrom:)&#39; does not convey the<br>&gt;&gt; argument&#39;s role well.  Our suggestion is to use<br>&gt;&gt; &#39;rotate(shiftingToStart:)&#39; and &#39;rotated(shiftingToStart:)&#39;.  These<br>&gt;&gt; names emphasize that methods operate on the whole collection, shifting<br>&gt;&gt; all elements.  The argument is the index of the element that is moved<br>&gt;&gt; to the start index, and we tried to convey that by using the word<br>&gt;&gt; &#39;start&#39; instead of &#39;first&#39;.  In the standard library, &#39;first&#39; refers<br>&gt;&gt; to the element itself, not the index.  Indices use &#39;startIndex&#39; and<br>&gt;&gt; &#39;endIndex&#39;.<br>&gt;&gt; <br>&gt;&gt; We have considered a lot of alternative names, including<br>&gt;&gt; &#39;swapSubranges(boundedBy:)&#39;, &#39;rewind&#39;, &#39;splitAndSwap&#39;, &#39;swapHalves&#39;<br>&gt;&gt; and others, but they were not as good.  The problems are:<br>&gt;&gt; <br>&gt;&gt; - &#39;swapSubranges&#39; is mostly good, but &#39;subranges&#39; does not imply that<br>&gt;&gt; the two subranges cover the whole collection.  The user might<br>&gt;&gt; reasonably expect to pass two subranges that will be swapped.<br>&gt;&gt; <br>&gt;&gt; - &#39;Half&#39; implies that two parts make a whole, but it also implies that<br>&gt;&gt; two parts are of equal size, which is not the case for this API.<br>&gt;&gt; <br>&gt;&gt; - &#39;splitAndSwap&#39; implies that we are operating on the whole, but feels<br>&gt;&gt; a very roundabout way to describe the operation.<br>&gt;<br>&gt; Agreed on all of this. The rotate name is hard to beat!<br>&gt;<br>&gt;&gt; For a non-mutating rotation we suggest defining separate types,<br>&gt;&gt; RotatedCollection, RotatedBidirectionalCollection, and<br>&gt;&gt; RotatedRandomAccessCollection, instead of returning a<br>&gt;&gt; FlattenCollection.  This has a few advantages.<br>&gt;&gt; <br>&gt;&gt; - We can change the non-mutating &#39;rotated()&#39; to just return the<br>&gt;&gt; collection instead of returning tuples of the collection and the<br>&gt;&gt; index.  The index of the former first element can be stored inside the<br>&gt;&gt; RotatedCollection in a property.  This change allows easier chaining<br>&gt;&gt; on &#39;.rotated()&#39;, and goes in line with the return value of the<br>&gt;&gt; mutating &#39;rotate()&#39; being discardable.<br>&gt;&gt; <br>&gt;&gt; - Using an array in the return type of &#39;rotated()&#39;<br>&gt;&gt; (FlattenCollection&lt;[Self.SubSequence]&gt;) would be less efficient than<br>&gt;&gt; it could be (extra allocation), and also feels like exposing too many<br>&gt;&gt; implementation details that we might want to change in future (for<br>&gt;&gt; example, if we get a CollectionOfTwo type).<br>&gt;&gt; <br>&gt;&gt; - In future, when we have conditional protocol conformances in the<br>&gt;&gt; language, we would fold the three RotatedCollection types into one<br>&gt;&gt; type that conditionally conforms to collection protocols based on the<br>&gt;&gt; capabilities of the underlying collection.  We won&#39;t be able to do<br>&gt;&gt; that if some overloads return a FlattenCollection.<br>&gt;&gt; <br>&gt;&gt; For lazy &#39;rotated()&#39;, just like for non-mutating &#39;rotated()&#39;, we<br>&gt;&gt; recommend returning only one value, a LazyCollection that wraps an<br>&gt;&gt; appropriate RotatedCollection.  The RotatedCollection will store the<br>&gt;&gt; index of the former first element in a property.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>May  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 3:18 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; on Thu May 05 2016, Nate Cook &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Thanks for the feedback, Dmitri &amp;co, this all looks excellent! I&#39;ll work on updating the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 5, 2016, at 6:13 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, May 3, 2016 at 8:57 PM, Chris Lattner via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++&quot; begins now and runs through May 9.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m posting this feedback on behalf of Dave Abrahams, Max Moiseev and<br>&gt;&gt;&gt; myself.  We met and discussed the proposal in great detail.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, we want to thank Nate and Sergey for proposing this API,<br>&gt;&gt;&gt; which is an important and useful algorithm.  We are generally in favor<br>&gt;&gt;&gt; of the proposal, but we would like to request a few changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you make &#39;func rotate&#39; a requirement in the MutableCollection<br>&gt;&gt;&gt; protocol?  This allows selecting the best implementation for a given<br>&gt;&gt;&gt; concrete type, even when calling from generic code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you explain why do we need a special implementation of<br>&gt;&gt;&gt; &#39;reverse()&#39; for RandomAccessCollection?  We couldn&#39;t think of a<br>&gt;&gt;&gt; performance reason for this.<br>&gt;&gt; <br>&gt;&gt; With a bidirectional collection, you have to compare the high and low<br>&gt;&gt; index at each iteration, stopping when low &gt;= high (before indices<br>&gt;&gt; were Comparable, this required two equality comparisons per<br>&gt;&gt; iteration). With a random-access collection, you can optimize the loop<br>&gt;&gt; to use a fixed number of iterations, which should be more efficient.<br>&gt; <br>&gt; How can you reverse a variable-length collection with a fixed number of<br>&gt; iterations?  Are you talking about loop unrolling in the library?<br></p><p>I mean looping count / 2 times instead of looping while lowIndex &lt; highIndex, not a fixed number of iterations for every array.<br></p><p>&gt;&gt;&gt; Could you add complexity clauses to all new documentation comments?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have discussed the names for these functions at length.  We felt<br>&gt;&gt;&gt; like the argument in &#39;rotate(firstFrom:)&#39; does not convey the<br>&gt;&gt;&gt; argument&#39;s role well.  Our suggestion is to use<br>&gt;&gt;&gt; &#39;rotate(shiftingToStart:)&#39; and &#39;rotated(shiftingToStart:)&#39;.  These<br>&gt;&gt;&gt; names emphasize that methods operate on the whole collection, shifting<br>&gt;&gt;&gt; all elements.  The argument is the index of the element that is moved<br>&gt;&gt;&gt; to the start index, and we tried to convey that by using the word<br>&gt;&gt;&gt; &#39;start&#39; instead of &#39;first&#39;.  In the standard library, &#39;first&#39; refers<br>&gt;&gt;&gt; to the element itself, not the index.  Indices use &#39;startIndex&#39; and<br>&gt;&gt;&gt; &#39;endIndex&#39;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We have considered a lot of alternative names, including<br>&gt;&gt;&gt; &#39;swapSubranges(boundedBy:)&#39;, &#39;rewind&#39;, &#39;splitAndSwap&#39;, &#39;swapHalves&#39;<br>&gt;&gt;&gt; and others, but they were not as good.  The problems are:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - &#39;swapSubranges&#39; is mostly good, but &#39;subranges&#39; does not imply that<br>&gt;&gt;&gt; the two subranges cover the whole collection.  The user might<br>&gt;&gt;&gt; reasonably expect to pass two subranges that will be swapped.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - &#39;Half&#39; implies that two parts make a whole, but it also implies that<br>&gt;&gt;&gt; two parts are of equal size, which is not the case for this API.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - &#39;splitAndSwap&#39; implies that we are operating on the whole, but feels<br>&gt;&gt;&gt; a very roundabout way to describe the operation.<br>&gt;&gt; <br>&gt;&gt; Agreed on all of this. The rotate name is hard to beat!<br>&gt;&gt; <br>&gt;&gt;&gt; For a non-mutating rotation we suggest defining separate types,<br>&gt;&gt;&gt; RotatedCollection, RotatedBidirectionalCollection, and<br>&gt;&gt;&gt; RotatedRandomAccessCollection, instead of returning a<br>&gt;&gt;&gt; FlattenCollection.  This has a few advantages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - We can change the non-mutating &#39;rotated()&#39; to just return the<br>&gt;&gt;&gt; collection instead of returning tuples of the collection and the<br>&gt;&gt;&gt; index.  The index of the former first element can be stored inside the<br>&gt;&gt;&gt; RotatedCollection in a property.  This change allows easier chaining<br>&gt;&gt;&gt; on &#39;.rotated()&#39;, and goes in line with the return value of the<br>&gt;&gt;&gt; mutating &#39;rotate()&#39; being discardable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Using an array in the return type of &#39;rotated()&#39;<br>&gt;&gt;&gt; (FlattenCollection&lt;[Self.SubSequence]&gt;) would be less efficient than<br>&gt;&gt;&gt; it could be (extra allocation), and also feels like exposing too many<br>&gt;&gt;&gt; implementation details that we might want to change in future (for<br>&gt;&gt;&gt; example, if we get a CollectionOfTwo type).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - In future, when we have conditional protocol conformances in the<br>&gt;&gt;&gt; language, we would fold the three RotatedCollection types into one<br>&gt;&gt;&gt; type that conditionally conforms to collection protocols based on the<br>&gt;&gt;&gt; capabilities of the underlying collection.  We won&#39;t be able to do<br>&gt;&gt;&gt; that if some overloads return a FlattenCollection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For lazy &#39;rotated()&#39;, just like for non-mutating &#39;rotated()&#39;, we<br>&gt;&gt;&gt; recommend returning only one value, a LazyCollection that wraps an<br>&gt;&gt;&gt; appropriate RotatedCollection.  The RotatedCollection will store the<br>&gt;&gt;&gt; index of the former first element in a property.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160506/f7fb5661/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  6, 2016 at 02:00:00pm</p></header><div class="content"><p>on Fri May 06 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br></p><p>&gt;     How can you reverse a variable-length collection with a fixed number of<br>&gt;     iterations? Are you talking about loop unrolling in the library?<br>&gt;<br>&gt; I mean looping count / 2 times instead of looping while lowIndex &lt;<br>&gt; highIndex,<br></p><p>Why do you think that will be faster?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/67a361b77f5c6cba256d06ba641f2af8?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Nate Cook</string> &lt;nate at natecook.com&gt;<p>May  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 6, 2016, at 4:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; on Fri May 06 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;    How can you reverse a variable-length collection with a fixed number of<br>&gt;&gt;    iterations? Are you talking about loop unrolling in the library?<br>&gt;&gt; <br>&gt;&gt; I mean looping count / 2 times instead of looping while lowIndex &lt;<br>&gt;&gt; highIndex,<br>&gt; <br>&gt; Why do you think that will be faster?<br></p><p>I don&#39;t know what kinds of optimization the compiler performs, but it certainly seems more open to optimization. Barring that, it removes the custom index comparison, which certainly couldn&#39;t be faster than checking for the end of a loop. <br></p><p>If it&#39;s not an improvement over the bidirectional algorithm, let&#39;s leave it out. Then we could skip the customization method and only have reverse() as an extension to BidirectionalCollection.<br></p><p>Nate<br></p><p><br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0078: Implement a rotate algorithm, equivalent to std::rotate() in C++</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May  6, 2016 at 03:00:00pm</p></header><div class="content"><p>on Fri May 06 2016, Nate Cook &lt;nate-AT-natecook.com&gt; wrote:<br></p><p>&gt;&gt; On May 6, 2016, at 4:20 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; on Fri May 06 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    How can you reverse a variable-length collection with a fixed number of<br>&gt;&gt;&gt;    iterations? Are you talking about loop unrolling in the library?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mean looping count / 2 times instead of looping while lowIndex &lt;<br>&gt;&gt;&gt; highIndex,<br>&gt;&gt; <br>&gt;&gt; Why do you think that will be faster?<br>&gt;<br>&gt; I don&#39;t know what kinds of optimization the compiler performs, but it<br>&gt; certainly seems more open to optimization. Barring that, it removes<br>&gt; the custom index comparison, which certainly couldn&#39;t be faster than<br>&gt; checking for the end of a loop.<br></p><p>When the collection has a trivial index with random access, the compiler<br>should be able to optimize the loop in all kinds of ways.  IMO putting<br>this kind of optimization in the library is at the very least premature<br>without both testing to prove it&#39;s slower and talking with the optimizer<br>people to make sure they can&#39;t handle it at that level.<br></p><p>&gt; If it&#39;s not an improvement over the bidirectional algorithm, let&#39;s<br>&gt; leave it out. Then we could skip the customization method and only<br>&gt; have reverse() as an extension to BidirectionalCollection.<br></p><p>IMO the cost of reverse() is going to be dominated by data copying, and<br>the chance of index comparison showing up as significant is very low.<br>But it&#39;s all speculation.  When there&#39;s no Big-O difference involved,<br>it&#39;s hard to justify introducing any complexity for an as-yet unobserved<br>performance increase.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
