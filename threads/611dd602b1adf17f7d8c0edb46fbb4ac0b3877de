<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 30, 2015 at 12:00:00pm</p></header><div class="content"><p>After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>1. Its default implementation in `SequenceType` just returns nil.<br>2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>3. In all other place it just delegates to another `SequenceType`.<br></p><p>So no one is doing real work.<br></p><p>If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 12:00:00am</p></header><div class="content"><p>On Wed, Dec 30, 2015 at 8:34 PM, Ling Wang via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>&gt; 1. Its default implementation in `SequenceType` just returns nil.<br>&gt; 2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>&gt; 3. In all other place it just delegates to another `SequenceType`.<br>&gt;<br>&gt; So no one is doing real work.<br>&gt;<br>&gt; If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br></p><p>It is not a relic.  It allows the contains() method to perform dynamic<br>dispatch in case the container knows something extra about the<br>elements.<br></p><p>Consider the case when you have a Set typed as a plain Sequence or a<br>Collection.  In that case, you won&#39;t be able to call the custom<br>Set.contains() method, the overload resolution will only see the<br>protocol extension.  This extra entry point,<br>_customContainsEquatableElement, allows us to perform dynamic dispatch<br>and use the fast Set implementation if it is available.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 30, 2015 at 06:00:00pm</p></header><div class="content"><p>Got it. `contains` is only declared in extension. Interesting workaround. Thanks.<br></p><p>&gt; On Dec 30, 2015, at 4:45 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 30, 2015 at 8:34 PM, Ling Wang via swift-dev<br>&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>&gt;&gt; 1. Its default implementation in `SequenceType` just returns nil.<br>&gt;&gt; 2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>&gt;&gt; 3. In all other place it just delegates to another `SequenceType`.<br>&gt;&gt; <br>&gt;&gt; So no one is doing real work.<br>&gt;&gt; <br>&gt;&gt; If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br>&gt; <br>&gt; It is not a relic.  It allows the contains() method to perform dynamic<br>&gt; dispatch in case the container knows something extra about the<br>&gt; elements.<br>&gt; <br>&gt; Consider the case when you have a Set typed as a plain Sequence or a<br>&gt; Collection.  In that case, you won&#39;t be able to call the custom<br>&gt; Set.contains() method, the overload resolution will only see the<br>&gt; protocol extension.  This extra entry point,<br>&gt; _customContainsEquatableElement, allows us to perform dynamic dispatch<br>&gt; and use the fast Set implementation if it is available.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 31, 2015 at 11:00:00am</p></header><div class="content"><p>Following the previous discussion do you think this is a good patch:<br></p><p>// O(1) implementation of `contains()` for ranges of comparable elements.<br>extension Range where Element: Comparable {<br>  @_transparent<br>  @warn_unused_result<br>  func _customContainsEquatableElement(<br>    element: Generator.Element<br>  ) -&gt; Bool? {<br>    return element &gt;= self.startIndex &amp;&amp; element &lt; self.endIndex<br>  }<br>}<br></p><p>&gt; On Dec 30, 2015, at 6:42 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; <br>&gt; Got it. `contains` is only declared in extension. Interesting workaround. Thanks.<br>&gt; <br>&gt;&gt; On Dec 30, 2015, at 4:45 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 30, 2015 at 8:34 PM, Ling Wang via swift-dev<br>&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>&gt;&gt;&gt; 1. Its default implementation in `SequenceType` just returns nil.<br>&gt;&gt;&gt; 2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>&gt;&gt;&gt; 3. In all other place it just delegates to another `SequenceType`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So no one is doing real work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br>&gt;&gt; <br>&gt;&gt; It is not a relic.  It allows the contains() method to perform dynamic<br>&gt;&gt; dispatch in case the container knows something extra about the<br>&gt;&gt; elements.<br>&gt;&gt; <br>&gt;&gt; Consider the case when you have a Set typed as a plain Sequence or a<br>&gt;&gt; Collection.  In that case, you won&#39;t be able to call the custom<br>&gt;&gt; Set.contains() method, the overload resolution will only see the<br>&gt;&gt; protocol extension.  This extra entry point,<br>&gt;&gt; _customContainsEquatableElement, allows us to perform dynamic dispatch<br>&gt;&gt; and use the fast Set implementation if it is available.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 07:00:00pm</p></header><div class="content"><p>Yes, I think it is good -- this is exactly the use case for this<br>method, except that @_transparent should be dropped, and the comment<br>is duplicating the code, so it should be dropped, too.  The change<br>also needs a simple test that checks that calling .contains() on a<br>suitable Range should dispatch to this method (you can detect that by<br>using MinimalComparableValue and supplying it a custom lessImpl that<br>counts the number of invocations).<br></p><p>Dmitri<br></p><p>On Thu, Dec 31, 2015 at 7:05 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; Following the previous discussion do you think this is a good patch:<br>&gt;<br>&gt; // O(1) implementation of `contains()` for ranges of comparable elements.<br>&gt; extension Range where Element: Comparable {<br>&gt;   @_transparent<br>&gt;   @warn_unused_result<br>&gt;   func _customContainsEquatableElement(<br>&gt;     element: Generator.Element<br>&gt;   ) -&gt; Bool? {<br>&gt;     return element &gt;= self.startIndex &amp;&amp; element &lt; self.endIndex<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;&gt; On Dec 30, 2015, at 6:42 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Got it. `contains` is only declared in extension. Interesting workaround. Thanks.<br>&gt;&gt;<br>&gt;&gt;&gt; On Dec 30, 2015, at 4:45 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 30, 2015 at 8:34 PM, Ling Wang via swift-dev<br>&gt;&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>&gt;&gt;&gt;&gt; 1. Its default implementation in `SequenceType` just returns nil.<br>&gt;&gt;&gt;&gt; 2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>&gt;&gt;&gt;&gt; 3. In all other place it just delegates to another `SequenceType`.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So no one is doing real work.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It is not a relic.  It allows the contains() method to perform dynamic<br>&gt;&gt;&gt; dispatch in case the container knows something extra about the<br>&gt;&gt;&gt; elements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Consider the case when you have a Set typed as a plain Sequence or a<br>&gt;&gt;&gt; Collection.  In that case, you won&#39;t be able to call the custom<br>&gt;&gt;&gt; Set.contains() method, the overload resolution will only see the<br>&gt;&gt;&gt; protocol extension.  This extra entry point,<br>&gt;&gt;&gt; _customContainsEquatableElement, allows us to perform dynamic dispatch<br>&gt;&gt;&gt; and use the fast Set implementation if it is available.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>Do you mean something like this in validation-test/stdlib/SequenceType.swift.gyb:<br></p><p>SequenceTypeTests.test(&quot;Range&lt;Element&gt;.contains/WhereElementIsComparable/dispatch&quot;) {<br>  MinimalComparableValue.timesLessWasCalled = 0<br>  let start = 0<br>  let end = 10<br>  let range = Range(start: MinimalComparableValue(start), end: MinimalComparableValue(end))<br>  let count = 20<br>  for test in 0...count {<br>    expectEqual(<br>      test &gt;= start &amp;&amp; test &lt; end,<br>      range.contains(MinimalComparableValue(test)))<br>  }<br>  expectEqual(<br>    count * 2, MinimalComparableValue.timesLessWasCalled)<br>}<br></p><p>There is one issue. MinimalComparableValue doesn’t conform to ForwardIndexType. I’m not sure it is proper for me to add this conformance in an extension because the definition of MinimalComparableValue is “A type that conforms only to `Equatable` and `Comparable`”.<br></p><p>What’s your suggestion?<br></p><p>&gt; On Dec 31, 2015, at 11:21 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; Yes, I think it is good -- this is exactly the use case for this<br>&gt; method, except that @_transparent should be dropped, and the comment<br>&gt; is duplicating the code, so it should be dropped, too.  The change<br>&gt; also needs a simple test that checks that calling .contains() on a<br>&gt; suitable Range should dispatch to this method (you can detect that by<br>&gt; using MinimalComparableValue and supplying it a custom lessImpl that<br>&gt; counts the number of invocations).<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; On Thu, Dec 31, 2015 at 7:05 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt;&gt; Following the previous discussion do you think this is a good patch:<br>&gt;&gt; <br>&gt;&gt; // O(1) implementation of `contains()` for ranges of comparable elements.<br>&gt;&gt; extension Range where Element: Comparable {<br>&gt;&gt;  @_transparent<br>&gt;&gt;  @warn_unused_result<br>&gt;&gt;  func _customContainsEquatableElement(<br>&gt;&gt;    element: Generator.Element<br>&gt;&gt;  ) -&gt; Bool? {<br>&gt;&gt;    return element &gt;= self.startIndex &amp;&amp; element &lt; self.endIndex<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 30, 2015, at 6:42 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Got it. `contains` is only declared in extension. Interesting workaround. Thanks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 30, 2015, at 4:45 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 30, 2015 at 8:34 PM, Ling Wang via swift-dev<br>&gt;&gt;&gt;&gt; &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>&gt;&gt;&gt;&gt;&gt; 1. Its default implementation in `SequenceType` just returns nil.<br>&gt;&gt;&gt;&gt;&gt; 2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>&gt;&gt;&gt;&gt;&gt; 3. In all other place it just delegates to another `SequenceType`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So no one is doing real work.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is not a relic.  It allows the contains() method to perform dynamic<br>&gt;&gt;&gt;&gt; dispatch in case the container knows something extra about the<br>&gt;&gt;&gt;&gt; elements.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Consider the case when you have a Set typed as a plain Sequence or a<br>&gt;&gt;&gt;&gt; Collection.  In that case, you won&#39;t be able to call the custom<br>&gt;&gt;&gt;&gt; Set.contains() method, the overload resolution will only see the<br>&gt;&gt;&gt;&gt; protocol extension.  This extra entry point,<br>&gt;&gt;&gt;&gt; _customContainsEquatableElement, allows us to perform dynamic dispatch<br>&gt;&gt;&gt;&gt; and use the fast Set implementation if it is available.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Dmitri<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt;&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>December 31, 2015 at 11:00:00pm</p></header><div class="content"><p>On Thu, Dec 31, 2015 at 10:06 PM, Ling Wang &lt;an00na at gmail.com&gt; wrote:<br>&gt; Do you mean something like this in validation-test/stdlib/SequenceType.swift.gyb:<br>&gt;<br>&gt; SequenceTypeTests.test(&quot;Range&lt;Element&gt;.contains/WhereElementIsComparable/dispatch&quot;) {<br>&gt;   MinimalComparableValue.timesLessWasCalled = 0<br>&gt;   let start = 0<br>&gt;   let end = 10<br>&gt;   let range = Range(start: MinimalComparableValue(start), end: MinimalComparableValue(end))<br>&gt;   let count = 20<br>&gt;   for test in 0...count {<br>&gt;     expectEqual(<br>&gt;       test &gt;= start &amp;&amp; test &lt; end,<br>&gt;       range.contains(MinimalComparableValue(test)))<br>&gt;   }<br>&gt;   expectEqual(<br>&gt;     count * 2, MinimalComparableValue.timesLessWasCalled)<br>&gt; }<br></p><p>Yes, this would be good.<br></p><p>&gt; There is one issue. MinimalComparableValue doesn’t conform to ForwardIndexType. I’m not sure it is proper for me to add this conformance in an extension because the definition of MinimalComparableValue is “A type that conforms only to `Equatable` and `Comparable`”.<br>&gt;<br>&gt; What’s your suggestion?<br></p><p>I think it would be appropriate to define a special type like<br>MinimalComparableValue just for this test since the requirements are<br>quite specific (Comparable + ForwardIndexType).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a726de03bed3104ddaecca3fdcf59e19?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Ling Wang</string> &lt;an00na at gmail.com&gt;<p>January  1, 2016 at 08:00:00pm</p></header><div class="content"><p>After fumbling for several days and firing a related bug(https://bugs.swift.org/browse/SR-435) I finally submitted the pull request: https://github.com/apple/swift/pull/854.<br></p><p>Thanks for your help!<br></p><p>&gt; On Dec 31, 2015, at 3:49 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Dec 31, 2015 at 10:06 PM, Ling Wang &lt;an00na at gmail.com &lt;mailto:an00na at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Do you mean something like this in validation-test/stdlib/SequenceType.swift.gyb:<br>&gt;&gt; <br>&gt;&gt; SequenceTypeTests.test(&quot;Range&lt;Element&gt;.contains/WhereElementIsComparable/dispatch&quot;) {<br>&gt;&gt;  MinimalComparableValue.timesLessWasCalled = 0<br>&gt;&gt;  let start = 0<br>&gt;&gt;  let end = 10<br>&gt;&gt;  let range = Range(start: MinimalComparableValue(start), end: MinimalComparableValue(end))<br>&gt;&gt;  let count = 20<br>&gt;&gt;  for test in 0...count {<br>&gt;&gt;    expectEqual(<br>&gt;&gt;      test &gt;= start &amp;&amp; test &lt; end,<br>&gt;&gt;      range.contains(MinimalComparableValue(test)))<br>&gt;&gt;  }<br>&gt;&gt;  expectEqual(<br>&gt;&gt;    count * 2, MinimalComparableValue.timesLessWasCalled)<br>&gt;&gt; }<br>&gt; <br>&gt; Yes, this would be good.<br>&gt; <br>&gt;&gt; There is one issue. MinimalComparableValue doesn’t conform to ForwardIndexType. I’m not sure it is proper for me to add this conformance in an extension because the definition of MinimalComparableValue is “A type that conforms only to `Equatable` and `Comparable`”.<br>&gt;&gt; <br>&gt;&gt; What’s your suggestion?<br>&gt; <br>&gt; I think it would be appropriate to define a special type like<br>&gt; MinimalComparableValue just for this test since the requirements are<br>&gt; quite specific (Comparable + ForwardIndexType).<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160101/132a9183/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 30, 2015 at 04:00:00pm</p></header><div class="content"><p>FWIW, once we have conditional protocol conformance (`extension ... : Proto where ...`), and if we get rid of the circular protocol inheritance limitation (two protocols that inherit from each other, which should in theory be fine), then we can say something like<br></p><p>protocol EquatableSequenceType : SequenceType {<br>    func contains(element: Self.Generator.Element) -&gt; Bool<br>}<br></p><p>extension SequenceType : EquatableSequenceType where Self.Generator.Element : Equatable {<br>    func contains(element: Self.Generator.Element) -&gt; Bool {<br>        // ...<br>    }<br>}<br></p><p>This way the method can actually be overridden directly without requiring any hacks like _customContainsEquatableElement.<br></p><p>We could work around the circular protocol inheritance thing by declaring a `typealias _Element : Equatable` in EquatableSequenceType instead of having the inheritance, and then just set `typealias _Element = Self.Generator.Element` in the protocol extension on SequenceType, but that does in theory let implementing types actually change the type of the contains() method parameter by overriding the typealias, which is a bit weird. Alternatively, we could work around it by allowing you to say `extension Any : EquatableSequenceType where Self : SequenceType { ... }` and having that essentially extend every concrete type that conforms to SequenceType, which means SequenceType itself doesn&#39;t conform to EquatableSequenceType and therefore there&#39;s no circular protocol inheritance, but I&#39;m not sure if this is actually an approach we want to take (although this is precisely what Rust does and it works for them).<br></p><p>-Kevin Ballard<br></p><p>On Wed, Dec 30, 2015, at 10:34 AM, Ling Wang via swift-dev wrote:<br>&gt; After reviewing the code of stdlib I found no one actually implements _customContainsEquatableElement:<br>&gt; 1. Its default implementation in `SequenceType` just returns nil.<br>&gt; 2. The implementation in `Set` delegates to `contains` which is bad because it reverses their relationship: the default implementation of `contains` in `SequenceType` delegates to `_customContainsEquatableElement`.<br>&gt; 3. In all other place it just delegates to another `SequenceType`.<br>&gt; <br>&gt; So no one is doing real work.<br>&gt; <br>&gt; If the current _customContainsEquatableElement is only a relic I suggest we remove it and clean up related code.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00am</p></header><div class="content"><p>&gt; On Dec 30, 2015, at 4:50 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; FWIW, once we have conditional protocol conformance (`extension ... : Proto where ...`), and if we get rid of the circular protocol inheritance limitation (two protocols that inherit from each other, which should in theory be fine), then we can say something like<br>&gt; <br>&gt; protocol EquatableSequenceType : SequenceType {<br>&gt;    func contains(element: Self.Generator.Element) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension SequenceType : EquatableSequenceType where Self.Generator.Element : Equatable {<br>&gt;    func contains(element: Self.Generator.Element) -&gt; Bool {<br>&gt;        // ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; This way the method can actually be overridden directly without requiring any hacks like _customContainsEquatableElement.<br>&gt; <br>&gt; We could work around the circular protocol inheritance thing by declaring a `typealias _Element : Equatable` in EquatableSequenceType instead of having the inheritance, and then just set `typealias _Element = Self.Generator.Element` in the protocol extension on SequenceType, but that does in theory let implementing types actually change the type of the contains() method parameter by overriding the typealias, which is a bit weird.<br></p><p>Tricks like this also usually break generic code because it can no longer count on the usual relationships between types.<br></p><p>&gt; Alternatively, we could work around it by allowing you to say `extension Any : EquatableSequenceType where Self : SequenceType { ... }` and having that essentially extend every concrete type that conforms to SequenceType, which means SequenceType itself doesn&#39;t conform to EquatableSequenceType and therefore there&#39;s no circular protocol inheritance, but I&#39;m not sure if this is actually an approach we want to take (although this is precisely what Rust does and it works for them).<br></p><p>I don’t want to create stdlib churn working around the lack of generics features that we expect to have for the next release.  We should just wait for the generics system to be ready.<br></p><p><br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 31, 2015 at 01:00:00am</p></header><div class="content"><p>On Dec 31, 2015, at 1:07 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br></p><p>&gt;&gt; Alternatively, we could work around it by allowing you to say `extension Any : EquatableSequenceType where Self : SequenceType { ... }` and having that essentially extend every concrete type that conforms to SequenceType, which means SequenceType itself doesn&#39;t conform to EquatableSequenceType and therefore there&#39;s no circular protocol inheritance, but I&#39;m not sure if this is actually an approach we want to take (although this is precisely what Rust does and it works for them).<br>&gt; <br>&gt; I don’t want to create stdlib churn working around the lack of generics features that we expect to have for the next release.  We should just wait for the generics system to be ready.<br></p><p>This suggestion was not meant as a workaround for the genetics limitation but for the following problem:<br></p><p>protocol Foo : Bar {}<br>protocol Bar : Foo {}<br></p><p>This throws an error about circular protocol inheritance.<br></p><p>-Kevin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Should we remove _customContainsEquatableElement from stdlib?</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 01:00:00am</p></header><div class="content"><p>-Dave<br></p><p>&gt; On Dec 31, 2015, at 1:11 AM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Dec 31, 2015, at 1:07 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Alternatively, we could work around it by allowing you to say `extension Any : EquatableSequenceType where Self : SequenceType { ... }` and having that essentially extend every concrete type that conforms to SequenceType, which means SequenceType itself doesn&#39;t conform to EquatableSequenceType and therefore there&#39;s no circular protocol inheritance, but I&#39;m not sure if this is actually an approach we want to take (although this is precisely what Rust does and it works for them).<br>&gt;&gt; <br>&gt;&gt; I don’t want to create stdlib churn working around the lack of generics features that we expect to have for the next release.  We should just wait for the generics system to be ready.<br>&gt; <br>&gt; This suggestion was not meant as a workaround for the genetics limitation but for the following problem:<br>&gt; <br>&gt; protocol Foo : Bar {}<br>&gt; protocol Bar : Foo {}<br>&gt; <br>&gt; This throws an error about circular protocol inheritance.<br></p><p>That is one of the generics limitations I’m referring to.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
