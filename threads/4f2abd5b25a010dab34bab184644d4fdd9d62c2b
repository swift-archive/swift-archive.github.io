<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30531676aaa28c283443b2bbe04e1a7b?s=50"></div><header><strong>Guard Implicit Fallback</strong> from <string>Alexey Demedetskiy</string> &lt;dalog at me.com&gt;<p>February 12, 2016 at 09:00:00am</p></header><div class="content"><p>Hey all<br></p><p>Can we align `guard` statement with `as` and `try` statements?<br></p><p>I mean enabling `guard?` and `guard!` versions. <br></p><p>guard! behavior is a pretty straightforward - raise an exception if condition is false. <br>In this case it will look like precondition(), but with conditional bindings.<br></p><p>guard? is a tricky one. What actually want to say - return default value.<br>in Void returning functions it is simple. It can be obvious in an Optional returning functions.<br>But this use cases are not general enough.<br></p><p>In other words, to give guard? statements enough semantics, we need to provide default return value <br>to function signature.<br></p><p>So, given small setup:<br></p><p>typealias UserID = Int<br>struct User { let id: UserID }<br></p><p>let users = [User(id: 1), User(id: 2)]<br></p><p>We can write findUser(byID:) function this way:<br></p><p>func findUser(byId id: UserID?) -&gt; User? {<br>    guard let id = id else { return nil }<br> <br>    for user in users {<br>        if user.id == id { return user }<br>    }<br>    <br>    return nil<br>}<br></p><p>And with guard? and function default return values this way:<br></p><p>func findUser(byId id: UserID?) -&gt; User? = nil {<br>    guard? let id = id<br>    <br>    for user in users {<br>        if user.id == id { return user }<br>    }<br>}<br></p><p>Function default return values is an off topic here and can be moved to separate thread if anyone is interested.<br></p><p>Best regards,<br>Alexey Demedetskiy<br></p><p>&gt; Hey everyone,<br>&gt; <br>&gt; I feel that `guard` could be a little more Swifty and would like to start a conversation concerning it.<br>&gt; <br>&gt; For example, I often have a function whose job depends on an optional having a value, and so I guard-let at the start and return if the guard fails. Or if the function returns an optional type, I&#39;ll simply return nil if guard fails.<br>&gt; <br>&gt; Can we improve on the general fallback case? Could we simply say:<br>&gt; <br>&gt; func noReturn() {<br>&gt; guard let aValue = someOptional<br>&gt; ....<br>&gt; }<br>&gt; <br>&gt; and have that imply &quot;else { returnvoid or nil}&quot;<br>&gt; <br>&gt; What are your thoughts?<br>&gt; <br>&gt; Tighe<br>&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Guard Implicit Fallback</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 12, 2016 at 11:00:00am</p></header><div class="content"><p>I like the general elegance of aligning this with existing constructs, but<br>ultimately it would be of little use to me.  Usually if a guard fails, I<br>want to log a message, or increment a counter, or at the very least have a<br>statement that I can stick a breakpoint on.  This proposal is appealing to<br>me from a brevity POV, but I suspect that if it were adopted, a lot of<br>organizations would adopt code conventions that ban it so that you can more<br>easily follow the control flow when debugging.<br></p><p>On Thu, Feb 11, 2016 at 11:19 PM, Alexey Demedetskiy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hey all<br>&gt;<br>&gt; Can we align `guard` statement with `as` and `try` statements?<br>&gt;<br>&gt; I mean enabling `guard?` and `guard!` versions.<br>&gt;<br>&gt; guard! behavior is a pretty straightforward - raise an exception if<br>&gt; condition is false.<br>&gt; In this case it will look like precondition(), but with conditional<br>&gt; bindings.<br>&gt;<br>&gt; guard? is a tricky one. What actually want to say - return default value.<br>&gt; in Void returning functions it is simple. It can be obvious in an Optional<br>&gt; returning functions.<br>&gt; But this use cases are not general enough.<br>&gt;<br>&gt; In other words, to give guard? statements enough semantics, we need to<br>&gt; provide default return value<br>&gt; to function signature.<br>&gt;<br>&gt; So, given small setup:<br>&gt;<br>&gt; typealias UserID = Int<br>&gt; struct User { let id: UserID }<br>&gt;<br>&gt; let users = [User(id: 1), User(id: 2)]<br>&gt;<br>&gt; We can write findUser(byID:) function this way:<br>&gt;<br>&gt; func findUser(byId id: UserID?) -&gt; User? {<br>&gt;     guard let id = id else { return nil }<br>&gt;<br>&gt;     for user in users {<br>&gt;         if user.id == id { return user }<br>&gt;     }<br>&gt;<br>&gt;     return nil<br>&gt; }<br>&gt;<br>&gt; And with guard? and function default return values this way:<br>&gt;<br>&gt; func findUser(byId id: UserID?) -&gt; User? = nil {<br>&gt;     guard? let id = id<br>&gt;<br>&gt;     for user in users {<br>&gt;         if user.id == id { return user }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Function default return values is an off topic here and can be moved to<br>&gt; separate thread if anyone is interested.<br>&gt;<br>&gt; Best regards,<br>&gt; Alexey Demedetskiy<br>&gt;<br>&gt; &gt; Hey everyone,<br>&gt; &gt;<br>&gt; &gt; I feel that `guard` could be a little more Swifty and would like to<br>&gt; start a conversation concerning it.<br>&gt; &gt;<br>&gt; &gt; For example, I often have a function whose job depends on an optional<br>&gt; having a value, and so I guard-let at the start and return if the guard<br>&gt; fails. Or if the function returns an optional type, I&#39;ll simply return nil<br>&gt; if guard fails.<br>&gt; &gt;<br>&gt; &gt; Can we improve on the general fallback case? Could we simply say:<br>&gt; &gt;<br>&gt; &gt; func noReturn() {<br>&gt; &gt; guard let aValue = someOptional<br>&gt; &gt; ....<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; and have that imply &quot;else { returnvoid or nil}&quot;<br>&gt; &gt;<br>&gt; &gt; What are your thoughts?<br>&gt; &gt;<br>&gt; &gt; Tighe<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/e5bd9ba0/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
