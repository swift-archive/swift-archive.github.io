<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri May 20 2016, Fabian Ehrentraud &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; there&#39;s been a little discussion about static vs. dynamic dispatch on<br>&gt; this mailing list, and there is a good post about the pitfalls when<br>&gt; using attributes defined in extensions [1].<br>&gt;<br>&gt; Having run into this myself during development, is there a plan on how<br>&gt; to reduce the pitfalls in future versions of Swift?<br>&gt;<br>&gt; - Fabian<br>&gt;<br>&gt; [1] https://developer.ibm.com/swift/2016/01/27/seven-swift-snares-how-to-avoid-them/<br>&gt;<br>&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels<br>&gt; very much like a fight to the ideological death between POP and OOP<br>&gt; and it may get really bad results this way.<br></p><p>Being in the run-up to WWDC, I don&#39;t really have the time to participate<br>in this discussion right now, although I think it is important and<br>interesting.  However, this last sentence caught my eye and I thought I<br>should clarify something: protocols unify static and dynamic dispatch,<br>and one is not inherently better than the other.  They have different<br>strengths.  Protocol-oriented programming is about leveraging those<br>strengths appropriately, not about a mandate to choose one or the other<br>form of dispatch.<br></p><p><br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On 4 Mar 2016, at 08:58, Brent Royal-Gordon &lt;brent at<br>&gt; architechies.com&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;&gt; Brent, why is dynamic dispatching for protocol extension default<br>&gt;&gt;&gt; implementations wrong in your mind? Wouldn&#39;t you agree that when<br>&gt;&gt;&gt; static dispatching introduces such a side effect that it should not<br>&gt;&gt;&gt; be automatically applied and perhaps a keyword should be added if<br>&gt;&gt;&gt; you really wanted static dispatching nonetheless?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think that code execution should not be affected by type casting,<br>&gt;&gt;&gt; it feels like a very confusing part of the language.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think dynamic dispatch is wrong; I think it&#39;s a large and<br>&gt;&gt; technically challenging change. So in the spirit of incrementalism,<br>&gt;&gt; I was trying to make cautious proposals which kept existing<br>&gt;&gt; semantics intact but made them clearer, in preparation for perhaps<br>&gt;&gt; eventually introducing dynamic dispatch. (Basically, I suggested<br>&gt;&gt; that non-overridable protocol extension members should be marked<br>&gt;&gt; `final` and it should be illegal to shadow them.)<br>&gt;&gt;<br>&gt;&gt; But the feedback I got indicated that most people wanted a more<br>&gt;&gt; aggressive proposal which introduced dynamic dispatch<br>&gt;&gt; immediately. That&#39;s much harder to propose because it touches on all<br>&gt;&gt; sorts of runtime implementation details I know nothing about, so I<br>&gt;&gt; didn&#39;t try to draft a proposal.<br>&gt;&gt;<br>&gt;&gt; (You are, perhaps inadvertently, currently demonstrating exactly what happened in those previous threads!)<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;<br>&gt;&gt; On Dec 11, 2015, at 8:56 PM, Kevin Ballard via swift-evolution<br>&gt;&gt; &lt;swift-evolution at<br>&gt;&gt; swift.org&lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; You think that Swift prefers virtual dispatch. I think it prefers static.<br>&gt;&gt;<br>&gt;&gt; I think what&#39;s really going on here is that _in most cases_ there&#39;s<br>&gt;&gt; no observable difference between static dispatch and virtual<br>&gt;&gt; dispatch. If you think of Swift as an OOP language with a powerful<br>&gt;&gt; value-typed system added on, then you&#39;ll probably think Swift<br>&gt;&gt; prefers virtual dispatch. If you think of Swift as a value-typed<br>&gt;&gt; language with an OOP layer added, then you&#39;ll probably think Swift<br>&gt;&gt; prefers static dispatch. In reality, Swift is a hybrid language and<br>&gt;&gt; it uses different types of dispatch in different situations as<br>&gt;&gt; appropriate.<br>&gt;<br>&gt; (emphasis mine)<br>&gt;<br>&gt; I know that this is a bit philosophical, but let me suggest a “next<br>&gt; level down” way to look at this.  Static and dynamic are *both* great<br>&gt; after all, and if you’re looking to type-cast languages, you need to<br>&gt; consider them both in light of their semantics, but also factor in<br>&gt; their compilation strategy and the programmer model that they all<br>&gt; provide.  Let me give you some examples, but keep in mind that this is<br>&gt; a narrow view and just MHO:<br>&gt;<br>&gt; 1. C: Static compilation model, static semantics.  While it does<br>&gt; provide indirect function pointers, C does everything possible to<br>&gt; punish their use (ever see the non-typedef&#39;d prototype for<br>&gt; signal(3/7)?), and is almost always statically compiled.  It provides<br>&gt; a very “static centric” programming model.  This is great in terms of<br>&gt; predictability - it makes it trivial to “predict” what your code will<br>&gt; look like at a machine level.<br>&gt;<br>&gt; 2. Javascript: Completely dynamic compilation model, completely<br>&gt; dynamic semantics.  No one talks about statically compiling<br>&gt; javascript, because the result of doing so would be a really really<br>&gt; slow executable.  Javascript performance hinges on dynamic profile<br>&gt; information to be able to efficiently execute a program.  This<br>&gt; provides a very “dynamic centric” programming model, with no ability<br>&gt; to understand how your code executes at a machine level.<br>&gt;<br>&gt; 3. C++: C++ is a step up from C in terms of introducing dynamism into<br>&gt; the model with virtual functions.  Sadly, C++ also provides a hostile<br>&gt; model for static optimizability - the existence of placement new<br>&gt; prevents a lot of interesting devirtualization opportunities, and<br>&gt; generally makes the compiler’s life difficult.  OTOH, like C, C++<br>&gt; provides a very predictable model: C++ programmers assume that C<br>&gt; constructs are static, but virtual methods will be dynamically<br>&gt; dispatched.  This is correct because (except for narrow cases) the<br>&gt; compiler has to use dynamic dispatch for C++ virtual methods.  The<br>&gt; good news here is that its dynamism is completely opt in, so C++<br>&gt; preserves all of the predictability, performance, and<br>&gt; static-compilability of C while providing a higher level programming<br>&gt; model.  If virtual methods are ever actually a performance problem, a<br>&gt; C++ programmer has ways to deal with that, directly in their code.<br>&gt;<br>&gt; 4. Java: Java makes nearly &quot;everything&quot; an object (no structs or other<br>&gt; non-primitive value types), and all methods default to being “virtual”<br>&gt; (in the C++ sense).  Java also introduces interfaces, which offer an<br>&gt; added dimension on dynamic dispatch.  To cope with this, Java assumes<br>&gt; a JIT compilation model, which can use dynamic behavior to<br>&gt; de-virtualize the (almost always) monomorphic calls into checked<br>&gt; direct calls.  This works out really well in practice, because JIT<br>&gt; compilers are great at telling when a program with apparently very<br>&gt; dynamic semantics actually have static semantics in practice (e.g. a<br>&gt; dynamic call has a single receiver).  OTOH, since the compilation<br>&gt; model assumes a JIT, this means that purely “AOT” static compilers<br>&gt; (which have no profile information, no knowledge of class loaders,<br>&gt; etc) necessarily produce inferior code.  It also means that Java<br>&gt; doesn’t “scale down” well to small embedded systems that can’t support<br>&gt; a JIT, like a bootloader.<br>&gt;<br>&gt; 5) Objective-C: Objective-C provides a hybrid model which favors<br>&gt; predictability due to its static compilation model (similar in some<br>&gt; ways to C++).  The C-like constructs provide C-like performance, and<br>&gt; the “messaging” constructs are never “devirtualized”, so they provide<br>&gt; very predictable performance characteristics.  Because it is<br>&gt; predictable, if the cost of a message send ever becomes an issue in<br>&gt; practice, the programmer has many patterns to deal with it (including<br>&gt; &quot;imp caching&quot;, and also including the ability to define the problem<br>&gt; away by rewriting code in terms of C constructs).  The end result of<br>&gt; this is that programmers write code which use C-level features where<br>&gt; performance matters and dynamicism doesn’t, but use ObjC features<br>&gt; where dynamicism is important or where performance doesn’t matter.<br>&gt;<br>&gt; While it would be possible to implement a JIT compiler for ObjC, I’d<br>&gt; expect the wins to be low, because the “hot” code which may be hinging<br>&gt; on these dynamic features is likely to already be optimized by hand.<br>&gt;<br>&gt; 6) GoLang: From this narrow discussion and perspective, Go has a<br>&gt; hybrid model that has similar characteristics to Objective-C 2013<br>&gt; (which introduced modules, but didn’t yet have generics).  It assumes<br>&gt; static compilation and provides a very predictable hybrid programming<br>&gt; model.  Its func’s are statically dispatched, but its interfaces are<br>&gt; dynamically dispatched.  It doesn’t provide guaranteed dynamic<br>&gt; dispatch (or “classes&quot;) like ObjC, but it provides even more dynamic<br>&gt; feautres in other areas (e.g. it requires a cycle-collecting garbage<br>&gt; collector).  Its &quot;interface{}” type is pretty equivalent to “id”<br>&gt; (e.g. all uses of it are dynamically dispatched or must be<br>&gt; downcasted), and it encourages use of it in the same places that<br>&gt; Objective-C does.  Go introduces checked downcasts, which introduce<br>&gt; some run-time overhead, but also provide safety compared to<br>&gt; Objective-C. Go thankfully introduces a replacement for the imperative<br>&gt; constructs in C, which defines away a bunch of C problems that<br>&gt; Objective-C inherited, and it certainly is prettier!<br>&gt;<br>&gt; … I can go on about other languages, but I have probably already gotten myself into enough trouble. :-)<br>&gt;<br>&gt; With this as context, lets talk about Swift:<br>&gt;<br>&gt; Swift is another case of a hybrid model: its semantics provide<br>&gt; predictability between obviously static (structs, enums, and global<br>&gt; funcs) and obviously dynamic (classes, protocols, and closures)<br>&gt; constructs.  A focus of Swift (like Java and Javascript) is to provide<br>&gt; an apparently simple programming model.  However, Swift also<br>&gt; intentionally &quot;cheats&quot; in its global design by mixing in a few tricks<br>&gt; to make the dynamic parts of the language optimizable by a static<br>&gt; compiler in many common cases, without requiring profiling or other<br>&gt; dynamic information..  For example, the Swift compiler can tell if<br>&gt; methods in non-public classes are never overridden (and non-public is<br>&gt; the default, for a lot of good reasons) - thus treating them as final.<br>&gt; This allows eliminating much of the overhead of dynamic dispatch<br>&gt; without requiring a JIT.  Consider an “app”: because it never needs to<br>&gt; have non-public classes, this is incredibly powerful - the design of<br>&gt; the swift package manager extends this even further (in principle, not<br>&gt; done yet) to external libraries. Further, Swift’s generics provide an<br>&gt; a static performance model similar to C++ templates in release builds<br>&gt; (though I agree we need to do more to really follow through on this)<br>&gt; -- while Swift existentials (values of protocol type) provide a<br>&gt; balance by giving a highly dynamic model.<br>&gt;<br>&gt; The upshot of this is that Swift isn’t squarely in either of the<br>&gt; static or dynamic camps: it aims to provide a very predictable<br>&gt; performance model (someone writing a bootloader or firmware can stick<br>&gt; to using Swift structs and have a simple guarantee of no dynamic<br>&gt; overhead or runtime dependence) while also providing an expressive and<br>&gt; clean high level programming model - simplifying learning and the<br>&gt; common case where programmers don’t care to count cycles.  If<br>&gt; anything, I’d say that Swift is an “opportunistic” language, in that<br>&gt; it provides a very dynamic “default&quot; programming model, where you<br>&gt; don’t have to think about the fact that a static compiler is able to<br>&gt; transparently provide great performance - without needing the overhead<br>&gt; of a JIT.<br>&gt;<br>&gt; Finally, while it is possible that a JIT compiler might be interesting<br>&gt; someday in the Swift space, if we do things right, it will never be<br>&gt; “worth it” because programmers will have enough ability to reason<br>&gt; about performance at their fingertips.  This means that there should<br>&gt; be no Java or Javascript-magnitude &quot;performance delta&quot; sitting on the<br>&gt; table waiting for a JIT to scoop up.  We’ll see how it works out long<br>&gt; term, but I think we’re doing pretty well so far.<br>&gt;<br>&gt; TL;DR: What I’m really getting at is that the old static vs dynamic<br>&gt; trope is at the very least only half of the story.  You really need to<br>&gt; include the compilation model and thus the resultant programmer model<br>&gt; into the story, and the programmer model is what really matters, IMHO.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fc174169a3054f2e9bcb366884b02b?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Fabian Ehrentraud</string> &lt;Fabian.Ehrentraud at willhaben.at&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>Sorry, I understand and appreciate your pragmatism. Right now it feels<br>very much like a fight to the ideological death between POP and OOP<br>and it may get really bad results this way.<br></p><p>Being in the run-up to WWDC, I don&#39;t really have the time to participate<br>in this discussion right now, although I think it is important and<br>interesting.  However, this last sentence caught my eye and I thought I<br>should clarify something: protocols unify static and dynamic dispatch,<br>and one is not inherently better than the other.  They have different<br>strengths.  Protocol-oriented programming is about leveraging those<br>strengths appropriately, not about a mandate to choose one or the other<br>form of dispatch.<br></p><p>Well said.<br>Maybe the issue is not about being unclear at the point of definition in the extension, but at the call site - similar to value vs. reference semantics.<br>Just as a thought experiment, putting aside that it would be ugly, would having a different syntax for invoking methods with static and dynamic dispatch help to understand the working of the code better?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4fc99273/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Static Dispatch Pitfalls</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>May 21, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Am 20.05.2016 um 21:51 schrieb Fabian Ehrentraud via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt;&gt; Sorry, I understand and appreciate your pragmatism. Right now it feels<br>&gt;&gt;&gt; very much like a fight to the ideological death between POP and OOP<br>&gt;&gt;&gt; and it may get really bad results this way.<br>&gt;&gt; <br>&gt;&gt; Being in the run-up to WWDC, I don&#39;t really have the time to participate<br>&gt;&gt; in this discussion right now, although I think it is important and<br>&gt;&gt; interesting.  However, this last sentence caught my eye and I thought I<br>&gt;&gt; should clarify something: protocols unify static and dynamic dispatch,<br>&gt;&gt; and one is not inherently better than the other.  They have different<br>&gt;&gt; strengths.  Protocol-oriented programming is about leveraging those<br>&gt;&gt; strengths appropriately, not about a mandate to choose one or the other<br>&gt;&gt; form of dispatch.<br>&gt; <br>&gt; Well said.<br>&gt; Maybe the issue is not about being unclear at the point of definition in the extension, but at the call site - similar to value vs. reference semantics.<br>&gt; Just as a thought experiment, putting aside that it would be ugly, would having a different syntax for invoking methods with static and dynamic dispatch help to understand the working of the code better?<br></p><p>Hi all,<br></p><p>I unsuccessfully tried to start a thread about this topic as well, 14 hours earlier ( https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160516/018214.html ).<br></p><p>I think what is needed is that every method that wants to override something has to be annotated with an `override` keyword. And it is not enough to have just one `override`: you need `override` for overriding from a class, `override(Pr)` for overriding from protocol `Pr`, and overriding a method which is not defined in any protocol or superclass (but just in a protocol extension), is just impossible (yet). Everything else is impractical.<br></p><p>The idea is that each method has a contract. When sending a message, the most specialized method that implements the contract of that message should get called. But conceptually, messages and contracts are not the same, and they will never be. The same message can define different contracts for different classes. Two methods can be called by the same message but have a different contract (on two different objects, of course). A proposal has to deal with this somehow.<br></p><p>`override` is a &quot;contract-annotation&quot;: it says &quot;this method has the same contract as the method defined in the superclass (subtext: I will not violate LSP)&quot;<br></p><p>1) Dispatching everything dynamically is bad,<br>2) dispatching everything statically is bad,<br>3) having the caller decide is bad too. (just see my code example on 1) and replace the statically dispatched call to `makeBlue` with `@dynamicDispatch(makeBlue)`. We see: the program misbehaves, but why was the dynamicDispatch-decision of the caller bad here?)<br>4) The person who writes a method should know it&#39;s contract. This developer can also decide if it matches another contract from a protocol and if it therefore should be an override.<br></p><p>I think the sticking point here is to think through realistic examples, not short use-cases with a few lines of code; but 2 or 3 modules with multiple protocols, extensions, classes and overrides. Maybe my original mail was incomprehensible. But it at least tries not to oversimplify the problem when designing a solution.<br></p><p>-Michael<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
