<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Completing Generics] Arbitrary requirements in protocols</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 11, 2016 at 01:00:00am</p></header><div class="content"><p>Doug wrote this in the Completing Generics manifesto, under &quot;Minor<br>extensions&quot;:<br></p><p><br>&gt; **Arbitrary requirements in protocols*<br></p><p><br></p><p>Currently, a new protocol can inherit from other protocols, introduce new<br>&gt; associated types, and add new conformance constraints to associated types<br>&gt; (by redeclaring an associated type from an inherited protocol). However,<br>&gt; one cannot express more general constraints. Building on the example from<br>&gt; “Recursive protocol constraints”, we really want the element type of a<br>&gt; Sequence’s SubSequence to be the same as the element type of the Sequence,<br>&gt; e.g.,<br>&gt;<br></p><p><br>    protocol Sequence {<br>&gt;         associatedtype Iterator : IteratorProtocol<br>&gt;         …<br>&gt;         associatedtype SubSequence : Sequence where<br>&gt; SubSequence.Iterator.Element == Iterator.Element<br>&gt;     }<br>&gt;<br></p><p><br>+1.<br></p><p>To make it into Swift 3, would this feature require a proposal of its own?<br>How feasible would it be to implement on top of the current system?<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160411/d7000391/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>[Completing Generics] Arbitrary requirements in protocols</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>April 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Jacob,<br></p><p>I really like the idea of constraining associated types. However I think there could be a much more general solution to this problem by introducing &quot;Partially constrained protocols&quot;.<br></p><p>I&#39;ve already created a (almost finished) proposal for another thread which hasn&#39;t continued. It attacks the same issue as &quot;Arbitrary requirements in protocols&quot;: https://github.com/Qbyte248/swift-evolution/blob/master/proposals/0000-Partially%20constrained%20protocols%20and%20generic%20types.md<br></p><p>Unfortunately I have (almost) no time to discuss this in depth or completely finish the proposal. So feel free to copy my proposal add yourself as coauthor and start a new thread. Or just take it as an inspiration :)<br></p><p>Kind regards<br>- Maximilian<br></p><p>PS: Looking forward to a new generics model :)<br></p><p>&gt; Am 11.04.2016 um 10:01 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Doug wrote this in the Completing Generics manifesto, under &quot;Minor extensions&quot;:<br>&gt; <br>&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt;  <br>&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt;  <br>&gt;&gt;     protocol Sequence {<br>&gt;&gt;         associatedtype Iterator : IteratorProtocol<br>&gt;&gt;         …<br>&gt;&gt;         associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;     }<br>&gt; <br>&gt; <br>&gt; +1.<br>&gt; <br>&gt; To make it into Swift 3, would this feature require a proposal of its own? How feasible would it be to implement on top of the current system?<br>&gt; <br>&gt; Jacob<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/4b54f2bc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Completing Generics] Arbitrary requirements in protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 11, 2016, at 1:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Doug wrote this in the Completing Generics manifesto, under &quot;Minor extensions&quot;:<br>&gt; <br>&gt; *Arbitrary requirements in protocols<br>&gt;  <br>&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;  <br>&gt;     protocol Sequence {<br>&gt;         associatedtype Iterator : IteratorProtocol<br>&gt;         …<br>&gt;         associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     }<br>&gt; <br>&gt; <br>&gt; +1.<br>&gt; <br>&gt; To make it into Swift 3, would this feature require a proposal of its own?<br></p><p>Yes. Also, be wary that the syntax above potentially conflicts with the syntax discussed as &quot;moving the where clauses”:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058<br></p><p><br>&gt; How feasible would it be to implement on top of the current system?<br></p><p>Definitely! The archetype builder would need to learn to check these extra where clauses, and one would need to be sure that the constraint solver is picking them up as well.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/4eed4d82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Completing Generics] Arbitrary requirements in protocols</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 13, 2016 at 08:00:00am</p></header><div class="content"><p>Hi Doug,<br></p><p>I&#39;ve read the discussion about moving the where clause to the right of declarations (which I full-heartedly approve) but I don&#39;t see how it would have any impact on the syntax of associated types requirements.<br></p><p>David<br></p><p>&gt; On 12 Apr 2016, at 19:07, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Apr 11, 2016, at 1:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug wrote this in the Completing Generics manifesto, under &quot;Minor extensions&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     protocol Sequence {<br>&gt;&gt;&gt;         associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;         …<br>&gt;&gt;&gt;         associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; +1.<br>&gt;&gt; <br>&gt;&gt; To make it into Swift 3, would this feature require a proposal of its own?<br>&gt; <br>&gt; Yes. Also, be wary that the syntax above potentially conflicts with the syntax discussed as &quot;moving the where clauses”:<br>&gt; <br>&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058<br>&gt; <br>&gt; <br>&gt;&gt; How feasible would it be to implement on top of the current system?<br>&gt; <br>&gt; Definitely! The archetype builder would need to learn to check these extra where clauses, and one would need to be sure that the constraint solver is picking them up as well.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160413/28574a0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Completing Generics] Arbitrary requirements in protocols</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 12, 2016, at 11:19 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt; I&#39;ve read the discussion about moving the where clause to the right of declarations (which I full-heartedly approve) but I don&#39;t see how it would have any impact on the syntax of associated types requirements.<br></p><p>I think “arbitrary requirements in protocols” doesn’t necessarily require them to be attached to an associated type. For example, Collection might require that the SubSequence type itself be a Collection:<br></p><p>	protocol Collection : Sequence {<br>	  associatedtype SubSequence : Collection<br>	} <br></p><p>Why did we have to declare the SubSequence associated type again (since it’s already down in SubSequence) just to make it conform to Collection. In fact, why are we even allowed to declare a redundant associated type, which we know is defined in Sequence and will have to be the same? Seems to me that we just want a where clause to add the constraint, e.g.,<br></p><p>	protocol Collection : Sequence {<br>	  where SubSequence : Collection<br>	} <br></p><p>which of course would conflict with moving where clauses later, e.g.,<br></p><p>	protocol Collection : Sequence {<br>          func foo() // is the following where clause part of foo() or part of Collection?<br>	  where SubSequence : Collection<br>	} <br></p><p><br>	- Doug<br></p><p><br>&gt; <br>&gt; David<br>&gt; <br>&gt; On 12 Apr 2016, at 19:07, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 11, 2016, at 1:01 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Doug wrote this in the Completing Generics manifesto, under &quot;Minor extensions&quot;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; *Arbitrary requirements in protocols<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Currently, a new protocol can inherit from other protocols, introduce new associated types, and add new conformance constraints to associated types (by redeclaring an associated type from an inherited protocol). However, one cannot express more general constraints. Building on the example from “Recursive protocol constraints”, we really want the element type of a Sequence’s SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;     protocol Sequence {<br>&gt;&gt;&gt;         associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;         …<br>&gt;&gt;&gt;         associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To make it into Swift 3, would this feature require a proposal of its own?<br>&gt;&gt; <br>&gt;&gt; Yes. Also, be wary that the syntax above potentially conflicts with the syntax discussed as &quot;moving the where clauses”:<br>&gt;&gt; <br>&gt;&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; How feasible would it be to implement on top of the current system?<br>&gt;&gt; <br>&gt;&gt; Definitely! The archetype builder would need to learn to check these extra where clauses, and one would need to be sure that the constraint solver is picking them up as well.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160412/bbbc11b0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
