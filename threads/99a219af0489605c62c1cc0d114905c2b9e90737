<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 11, 2016 at 02:00:00am</p></header><div class="content"><p>TL;DR<br></p><p>Thinking about some problems presented here this mailing list. I believe<br>that by following the same concepts behind the default protocol<br>implementations, allowing the same mechanism to provide default properties<br>can be a remarkable gain for language.<br></p><p>Rationale:<br></p><p>It has been proposed here also on this list, a need to produce abstract<br>classes, one of the reasons that need, is because is not possible to<br>declare properties in the same way as we declare default implementation on<br>protocols.<br>I also believe that this can help in the concept of multiple inheritance,<br>and serve as an aid to the default implementation on protocols, and<br>&quot;complete&quot; the Protocol-Oriented Programming concept.<br></p><p>For example:<br></p><p>protocol Named {<br>    var name: String { get }<br>}<br>protocol Aged {<br>    var age: Int { get }<br>}<br>struct Person: Named, Aged {<br>    var name: String<br>    var age: Int<br>}<br></p><p>extension Aged where Self: Named {<br>    func wishHappyBirthday() { // regular default implementation<br>        print(&quot;Happy birthday \(self.name) - you&#39;re \(self.age)!&quot;)<br>    }<br>    var birthdayVideo: AVPlayerItem? // nil is a default value<br>}<br>...<br>func playBirthdayMediaFrom(person: Person){<br>    var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>    // etc...<br>}<br></p><p>One of thousands of using this feature is to prevent us to create variables<br>that are not actually part of the data model we are shaping.<br></p><p>birthdayVideo in this case would be any variable that is not part of our<br>model, but need to be associated with the object (or structure) in some<br>context of our application. (And not be used anywhere else in the APP or<br>another API).<br></p><p>Other examples maybe a counter helper, weak reference to something, etc.<br>There is a infinite examples when we need to declare some variable just to<br>make the &quot;api&quot; happy like add a observer, holding some value, and use this<br>again to removeobserver in dealloc.<br></p><p>I believe that the same rules and the same mechanisms involving default<br>implementation functions, should govern this default property<br>implementation, and any discussion about it on the problems on protocols<br>rules should be made separate this thread.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/99a20737/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 10, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 6:43 PM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; TL;DR<br>&gt; <br>&gt; Thinking about some problems presented here this mailing list. I believe that by following the same concepts behind the default protocol implementations, allowing the same mechanism to provide default properties can be a remarkable gain for language.<br>&gt; <br>&gt; Rationale:<br>&gt; <br>&gt; It has been proposed here also on this list, a need to produce abstract classes, one of the reasons that need, is because is not possible to declare properties in the same way as we declare default implementation on protocols.<br>&gt; I also believe that this can help in the concept of multiple inheritance, and serve as an aid to the default implementation on protocols, and &quot;complete&quot; the Protocol-Oriented Programming concept.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; protocol Named {<br>&gt;     var name: String { get }<br>&gt; }<br>&gt; protocol Aged {<br>&gt;     var age: Int { get }<br>&gt; }<br>&gt; struct Person: Named, Aged {<br>&gt;     var name: String<br>&gt;     var age: Int<br>&gt; }<br>&gt; <br>&gt; extension Aged where Self: Named {    <br>&gt;     func wishHappyBirthday() { // regular default implementation<br>&gt;         print(&quot;Happy birthday \(self.name &lt;http://self.name/&gt;) - you&#39;re \(self.age)!&quot;)<br>&gt;     }<br>&gt;     var birthdayVideo: AVPlayerItem? // nil is a default value<br>&gt; }<br>&gt; ...<br>&gt; func playBirthdayMediaFrom(person: Person){<br>&gt;     var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>&gt;     // etc...<br>&gt; }<br>&gt; <br>&gt; One of thousands of using this feature is to prevent us to create variables that are not actually part of the data model we are shaping.<br>&gt; <br>&gt; birthdayVideo in this case would be any variable that is not part of our model, but need to be associated with the object (or structure) in some context of our application. (And not be used anywhere else in the APP or another API).<br>&gt; <br>&gt; Other examples maybe a counter helper, weak reference to something, etc. There is a infinite examples when we need to declare some variable just to make the &quot;api&quot; happy like add a observer, holding some value, and use this again to removeobserver in dealloc.<br>&gt; <br>&gt; I believe that the same rules and the same mechanisms involving default implementation functions, should govern this default property implementation, and any discussion about it on the problems on protocols rules should be made separate this thread.<br></p><p>Default implementations of functions don’t require per-instance state, while adding a stored property via a protocol extension does. Let’s step back to a simpler problem: stored properties in (non-protocol) extensions.<br></p><p>In the existing language, one can only introduce stored properties in the primary definition of the type. That’s because, when we create an instance of that type, we need to know how much storage to allocate for that instance. So, right now, we don’t even allow, e.g.,<br></p><p>	struct MyStruct { }<br>	extension MyStruct { var storage: Int = 0 } // error: extensions may not contain stored properties<br></p><p>	class MyClass { }<br>	extension MyClass { var storage: Int = 0 } // error: extensions may not contain stored properties<br></p><p>because, in the worst case, we don’t know about the storage required for the “storage” property until after we’ve allocated some instances of MyStruct or MyClass, and we can’t simply go back and resize those instances when we learn about the “storage” property. The “worst case” here could come about with shared libraries: put the MyStruct/MyClass primary definitions into an app, then put the extensions into a separate shared library. The app creates some MyStruct and MyClass instances, then loads the shared library, and now we have a problem: those instances have no storage for “storage.”<br></p><p>We could relax the requirement to allow extensions in the same module as the primary definition of that type to introduce stored properties, because they’re compiled along with the primary type definition anyway. This doesn’t solve out-of-module extensions, of course.<br></p><p>We could embed a pointer into each instance that points off to the stored properties for that instance. The pointer would refer to some lazily-allocated memory on the heap with that extra storage. However, this would either bloat every data structure by a pointer (including “Int”!) or have to be opt-in, neither of which are great. I don’t think there is any reasonable implementation for out-of-module stored properties in extensions of value types (struct/enum).<br></p><p>For classes, where we have object identity, we could have a side table containing the stored properties (keyed on the object’s address). This is how Objective-C’s associated objects work, and it’s a reasonable module for out-of-module stored properties in extensions of classes.<br></p><p>Getting back to stored properties in protocol extensions, the general feature isn’t implementable without having some mechanism for out-of-module stored properties in extensions of structs and enums, so you can limit it in a few ways:<br></p><p>	* Only allow them on class-bound protocols, where there is a reasonable implementation model<br></p><p>	* Allow them as default implementations within a protocol (not an extension of a protocol!); a type can conform to that protocol either by providing its own implementation of that property or somewhere where it is reasonable for the default implementation to inject a stored property into that context (e.g., on the primary type, within the same module as the primary type, or on a class).<br></p><p>Either handles the example brought up in the discussion of abstract base classes.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/598db778/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 11, 2016 at 04:00:00pm</p></header><div class="content"><p>I suspect it is easier both for the compiler and the programmer to allow<br>abstract classes and abstract functions within abstract classes than<br>allowing extensions and by extension (pun intended) protocols to have<br>stored properties. There is precedence for this approach, in Scala and<br>Java you can have their equivalents of calculated properties in protocols<br>but not stored properties. Both Scala and Java have abstract classes and<br>this seems to work well.<br></p><p>On Monday, 11 January 2016, Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 10, 2016, at 6:43 PM, Wallacy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; TL;DR<br>&gt;<br>&gt; Thinking about some problems presented here this mailing list. I believe<br>&gt; that by following the same concepts behind the default protocol<br>&gt; implementations, allowing the same mechanism to provide default properties<br>&gt; can be a remarkable gain for language.<br>&gt;<br>&gt; Rationale:<br>&gt;<br>&gt; It has been proposed here also on this list, a need to produce abstract<br>&gt; classes, one of the reasons that need, is because is not possible to<br>&gt; declare properties in the same way as we declare default implementation on<br>&gt; protocols.<br>&gt; I also believe that this can help in the concept of multiple inheritance,<br>&gt; and serve as an aid to the default implementation on protocols, and<br>&gt; &quot;complete&quot; the Protocol-Oriented Programming concept.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; protocol Named {<br>&gt;     var name: String { get }<br>&gt; }<br>&gt; protocol Aged {<br>&gt;     var age: Int { get }<br>&gt; }<br>&gt; struct Person: Named, Aged {<br>&gt;     var name: String<br>&gt;     var age: Int<br>&gt; }<br>&gt;<br>&gt; extension Aged where Self: Named {<br>&gt;     func wishHappyBirthday() { // regular default implementation<br>&gt;         print(&quot;Happy birthday \(self.name) - you&#39;re \(self.age)!&quot;)<br>&gt;     }<br>&gt;     var birthdayVideo: AVPlayerItem? // nil is a default value<br>&gt; }<br>&gt; ...<br>&gt; func playBirthdayMediaFrom(person: Person){<br>&gt;     var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>&gt;     // etc...<br>&gt; }<br>&gt;<br>&gt; One of thousands of using this feature is to prevent us to create<br>&gt; variables that are not actually part of the data model we are shaping.<br>&gt;<br>&gt; birthdayVideo in this case would be any variable that is not part of our<br>&gt; model, but need to be associated with the object (or structure) in some<br>&gt; context of our application. (And not be used anywhere else in the APP or<br>&gt; another API).<br>&gt;<br>&gt; Other examples maybe a counter helper, weak reference to something, etc.<br>&gt; There is a infinite examples when we need to declare some variable just to<br>&gt; make the &quot;api&quot; happy like add a observer, holding some value, and use this<br>&gt; again to removeobserver in dealloc.<br>&gt;<br>&gt; I believe that the same rules and the same mechanisms involving default<br>&gt; implementation functions, should govern this default property<br>&gt; implementation, and any discussion about it on the problems on protocols<br>&gt; rules should be made separate this thread.<br>&gt;<br>&gt;<br>&gt; Default implementations of functions don’t require per-instance state,<br>&gt; while adding a stored property via a protocol extension does. Let’s step<br>&gt; back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt;<br>&gt; In the existing language, one can only introduce stored properties in the<br>&gt; primary definition of the type. That’s because, when we create an instance<br>&gt; of that type, we need to know how much storage to allocate for that<br>&gt; instance. So, right now, we don’t even allow, e.g.,<br>&gt;<br>&gt; struct MyStruct { }<br>&gt; extension MyStruct { var storage: Int = 0 } // error: extensions may not<br>&gt; contain stored properties<br>&gt;<br>&gt; class MyClass { }<br>&gt; extension MyClass { var storage: Int = 0 } // error: extensions may not<br>&gt; contain stored properties<br>&gt;<br>&gt; because, in the worst case, we don’t know about the storage required for<br>&gt; the “storage” property until after we’ve allocated some instances of<br>&gt; MyStruct or MyClass, and we can’t simply go back and resize those instances<br>&gt; when we learn about the “storage” property. The “worst case” here could<br>&gt; come about with shared libraries: put the MyStruct/MyClass primary<br>&gt; definitions into an app, then put the extensions into a separate shared<br>&gt; library. The app creates some MyStruct and MyClass instances, then loads<br>&gt; the shared library, and now we have a problem: those instances have no<br>&gt; storage for “storage.”<br>&gt;<br>&gt; We could relax the requirement to allow extensions in the same module as<br>&gt; the primary definition of that type to introduce stored properties, because<br>&gt; they’re compiled along with the primary type definition anyway. This<br>&gt; doesn’t solve out-of-module extensions, of course.<br>&gt;<br>&gt; We could embed a pointer into each instance that points off to the stored<br>&gt; properties for that instance. The pointer would refer to some<br>&gt; lazily-allocated memory on the heap with that extra storage. However, this<br>&gt; would either bloat every data structure by a pointer (including “Int”!) or<br>&gt; have to be opt-in, neither of which are great. I don’t think there is any<br>&gt; reasonable implementation for out-of-module stored properties in extensions<br>&gt; of value types (struct/enum).<br>&gt;<br>&gt; For classes, where we have object identity, we could have a side table<br>&gt; containing the stored properties (keyed on the object’s address). This is<br>&gt; how Objective-C’s associated objects work, and it’s a reasonable module for<br>&gt; out-of-module stored properties in extensions of classes.<br>&gt;<br>&gt; Getting back to stored properties in protocol extensions, the general<br>&gt; feature isn’t implementable without having some mechanism for out-of-module<br>&gt; stored properties in extensions of structs and enums, so you can limit it<br>&gt; in a few ways:<br>&gt;<br>&gt; * Only allow them on class-bound protocols, where there is a reasonable<br>&gt; implementation model<br>&gt;<br>&gt; * Allow them as default implementations within a protocol (not an<br>&gt; extension of a protocol!); a type can conform to that protocol either by<br>&gt; providing its own implementation of that property or somewhere where it is<br>&gt; reasonable for the default implementation to inject a stored property into<br>&gt; that context (e.g., on the primary type, within the same module as the<br>&gt; primary type, or on a class).<br>&gt;<br>&gt; Either handles the example brought up in the discussion of abstract base<br>&gt; classes.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/58e93443/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 10, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 10, 2016, at 9:03 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; I suspect it is easier both for the compiler and the programmer to allow abstract classes and abstract functions within abstract classes than allowing extensions and by extension (pun intended) protocols to have stored properties.<br></p><p>Developers independently want the ability to add stored properties in extensions (at least for classes). The delta from that to stored properties as default implementations in protocols isn’t that large, and if it’s a better modeling of the problems abstract classes are meant to solve, that’s the right thing to do. Other than stored properties, what important problems do abstract classes solve that protocols don’t?<br></p><p>&gt; There is precedence for this approach, in Scala and Java you can have their equivalents of calculated properties in protocols but not stored properties. Both Scala and Java have abstract classes and this seems to work well.<br></p><p>Numerous languages have abstract classes; the question is whether they are the right answer in Swift.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; On Monday, 11 January 2016, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 6:43 PM, Wallacy via swift-evolution &lt;swift-evolution at swift.org &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; TL;DR<br>&gt;&gt; <br>&gt;&gt; Thinking about some problems presented here this mailing list. I believe that by following the same concepts behind the default protocol implementations, allowing the same mechanism to provide default properties can be a remarkable gain for language.<br>&gt;&gt; <br>&gt;&gt; Rationale:<br>&gt;&gt; <br>&gt;&gt; It has been proposed here also on this list, a need to produce abstract classes, one of the reasons that need, is because is not possible to declare properties in the same way as we declare default implementation on protocols.<br>&gt;&gt; I also believe that this can help in the concept of multiple inheritance, and serve as an aid to the default implementation on protocols, and &quot;complete&quot; the Protocol-Oriented Programming concept.<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; protocol Named {<br>&gt;&gt;     var name: String { get }<br>&gt;&gt; }<br>&gt;&gt; protocol Aged {<br>&gt;&gt;     var age: Int { get }<br>&gt;&gt; }<br>&gt;&gt; struct Person: Named, Aged {<br>&gt;&gt;     var name: String<br>&gt;&gt;     var age: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Aged where Self: Named {    <br>&gt;&gt;     func wishHappyBirthday() { // regular default implementation<br>&gt;&gt;         print(&quot;Happy birthday \(self.name &lt;http://self.name/&gt;) - you&#39;re \(self.age)!&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     var birthdayVideo: AVPlayerItem? // nil is a default value<br>&gt;&gt; }<br>&gt;&gt; ...<br>&gt;&gt; func playBirthdayMediaFrom(person: Person){<br>&gt;&gt;     var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>&gt;&gt;     // etc...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One of thousands of using this feature is to prevent us to create variables that are not actually part of the data model we are shaping.<br>&gt;&gt; <br>&gt;&gt; birthdayVideo in this case would be any variable that is not part of our model, but need to be associated with the object (or structure) in some context of our application. (And not be used anywhere else in the APP or another API).<br>&gt;&gt; <br>&gt;&gt; Other examples maybe a counter helper, weak reference to something, etc. There is a infinite examples when we need to declare some variable just to make the &quot;api&quot; happy like add a observer, holding some value, and use this again to removeobserver in dealloc.<br>&gt;&gt; <br>&gt;&gt; I believe that the same rules and the same mechanisms involving default implementation functions, should govern this default property implementation, and any discussion about it on the problems on protocols rules should be made separate this thread.<br>&gt; <br>&gt; Default implementations of functions don’t require per-instance state, while adding a stored property via a protocol extension does. Let’s step back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt; <br>&gt; In the existing language, one can only introduce stored properties in the primary definition of the type. That’s because, when we create an instance of that type, we need to know how much storage to allocate for that instance. So, right now, we don’t even allow, e.g.,<br>&gt; <br>&gt; 	struct MyStruct { }<br>&gt; 	extension MyStruct { var storage: Int = 0 } // error: extensions may not contain stored properties<br>&gt; <br>&gt; 	class MyClass { }<br>&gt; 	extension MyClass { var storage: Int = 0 } // error: extensions may not contain stored properties<br>&gt; <br>&gt; because, in the worst case, we don’t know about the storage required for the “storage” property until after we’ve allocated some instances of MyStruct or MyClass, and we can’t simply go back and resize those instances when we learn about the “storage” property. The “worst case” here could come about with shared libraries: put the MyStruct/MyClass primary definitions into an app, then put the extensions into a separate shared library. The app creates some MyStruct and MyClass instances, then loads the shared library, and now we have a problem: those instances have no storage for “storage.”<br>&gt; <br>&gt; We could relax the requirement to allow extensions in the same module as the primary definition of that type to introduce stored properties, because they’re compiled along with the primary type definition anyway. This doesn’t solve out-of-module extensions, of course.<br>&gt; <br>&gt; We could embed a pointer into each instance that points off to the stored properties for that instance. The pointer would refer to some lazily-allocated memory on the heap with that extra storage. However, this would either bloat every data structure by a pointer (including “Int”!) or have to be opt-in, neither of which are great. I don’t think there is any reasonable implementation for out-of-module stored properties in extensions of value types (struct/enum).<br>&gt; <br>&gt; For classes, where we have object identity, we could have a side table containing the stored properties (keyed on the object’s address). This is how Objective-C’s associated objects work, and it’s a reasonable module for out-of-module stored properties in extensions of classes.<br>&gt; <br>&gt; Getting back to stored properties in protocol extensions, the general feature isn’t implementable without having some mechanism for out-of-module stored properties in extensions of structs and enums, so you can limit it in a few ways:<br>&gt; <br>&gt; 	* Only allow them on class-bound protocols, where there is a reasonable implementation model<br>&gt; <br>&gt; 	* Allow them as default implementations within a protocol (not an extension of a protocol!); a type can conform to that protocol either by providing its own implementation of that property or somewhere where it is reasonable for the default implementation to inject a stored property into that context (e.g., on the primary type, within the same module as the primary type, or on a class).<br>&gt; <br>&gt; Either handles the example brought up in the discussion of abstract base classes.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/e0da4d76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0b728da29cd3d569863451ebf5d1d361?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>品雪</string> &lt;pinxue at gmail.com&gt;<p>January 11, 2016 at 03:00:00pm</p></header><div class="content"><p>I prefer Ruby&#39;s module mixing over Java&#39;s long inheritance path<br>(AbstractBase &lt;|= Abstract &lt;|= DefaultBase &lt;|= ...).<br></p><p>In objc, non-fragile instance variables already allow changing base<br>class without re-compiling sub class, it should not be that hard to<br>support this feature. And I agree it is better not allowed for struct<br>in Swift because of semantic of value type.<br></p><p>On Mon, Jan 11, 2016 at 1:37 PM, Douglas Gregor via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jan 10, 2016, at 9:03 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt;<br>&gt; I suspect it is easier both for the compiler and the programmer to allow<br>&gt; abstract classes and abstract functions within abstract classes than<br>&gt; allowing extensions and by extension (pun intended) protocols to have stored<br>&gt; properties.<br>&gt;<br>&gt;<br>&gt; Developers independently want the ability to add stored properties in<br>&gt; extensions (at least for classes). The delta from that to stored properties<br>&gt; as default implementations in protocols isn’t that large, and if it’s a<br>&gt; better modeling of the problems abstract classes are meant to solve, that’s<br>&gt; the right thing to do. Other than stored properties, what important problems<br>&gt; do abstract classes solve that protocols don’t?<br>&gt;<br>&gt; There is precedence for this approach, in Scala and Java you can have their<br>&gt; equivalents of calculated properties in protocols but not stored properties.<br>&gt; Both Scala and Java have abstract classes and this seems to work well.<br>&gt;<br>&gt;<br>&gt; Numerous languages have abstract classes; the question is whether they are<br>&gt; the right answer in Swift.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; On Monday, 11 January 2016, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 10, 2016, at 6:43 PM, Wallacy via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; TL;DR<br>&gt;&gt;<br>&gt;&gt; Thinking about some problems presented here this mailing list. I believe<br>&gt;&gt; that by following the same concepts behind the default protocol<br>&gt;&gt; implementations, allowing the same mechanism to provide default properties<br>&gt;&gt; can be a remarkable gain for language.<br>&gt;&gt;<br>&gt;&gt; Rationale:<br>&gt;&gt;<br>&gt;&gt; It has been proposed here also on this list, a need to produce abstract<br>&gt;&gt; classes, one of the reasons that need, is because is not possible to declare<br>&gt;&gt; properties in the same way as we declare default implementation on<br>&gt;&gt; protocols.<br>&gt;&gt; I also believe that this can help in the concept of multiple inheritance,<br>&gt;&gt; and serve as an aid to the default implementation on protocols, and<br>&gt;&gt; &quot;complete&quot; the Protocol-Oriented Programming concept.<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; protocol Named {<br>&gt;&gt;     var name: String { get }<br>&gt;&gt; }<br>&gt;&gt; protocol Aged {<br>&gt;&gt;     var age: Int { get }<br>&gt;&gt; }<br>&gt;&gt; struct Person: Named, Aged {<br>&gt;&gt;     var name: String<br>&gt;&gt;     var age: Int<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Aged where Self: Named {<br>&gt;&gt;     func wishHappyBirthday() { // regular default implementation<br>&gt;&gt;         print(&quot;Happy birthday \(self.name) - you&#39;re \(self.age)!&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     var birthdayVideo: AVPlayerItem? // nil is a default value<br>&gt;&gt; }<br>&gt;&gt; ...<br>&gt;&gt; func playBirthdayMediaFrom(person: Person){<br>&gt;&gt;     var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>&gt;&gt;     // etc...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; One of thousands of using this feature is to prevent us to create<br>&gt;&gt; variables that are not actually part of the data model we are shaping.<br>&gt;&gt;<br>&gt;&gt; birthdayVideo in this case would be any variable that is not part of our<br>&gt;&gt; model, but need to be associated with the object (or structure) in some<br>&gt;&gt; context of our application. (And not be used anywhere else in the APP or<br>&gt;&gt; another API).<br>&gt;&gt;<br>&gt;&gt; Other examples maybe a counter helper, weak reference to something, etc.<br>&gt;&gt; There is a infinite examples when we need to declare some variable just to<br>&gt;&gt; make the &quot;api&quot; happy like add a observer, holding some value, and use this<br>&gt;&gt; again to removeobserver in dealloc.<br>&gt;&gt;<br>&gt;&gt; I believe that the same rules and the same mechanisms involving default<br>&gt;&gt; implementation functions, should govern this default property<br>&gt;&gt; implementation, and any discussion about it on the problems on protocols<br>&gt;&gt; rules should be made separate this thread.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Default implementations of functions don’t require per-instance state,<br>&gt;&gt; while adding a stored property via a protocol extension does. Let’s step<br>&gt;&gt; back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt;&gt;<br>&gt;&gt; In the existing language, one can only introduce stored properties in the<br>&gt;&gt; primary definition of the type. That’s because, when we create an instance<br>&gt;&gt; of that type, we need to know how much storage to allocate for that<br>&gt;&gt; instance. So, right now, we don’t even allow, e.g.,<br>&gt;&gt;<br>&gt;&gt; struct MyStruct { }<br>&gt;&gt; extension MyStruct { var storage: Int = 0 } // error: extensions may not<br>&gt;&gt; contain stored properties<br>&gt;&gt;<br>&gt;&gt; class MyClass { }<br>&gt;&gt; extension MyClass { var storage: Int = 0 } // error: extensions may not<br>&gt;&gt; contain stored properties<br>&gt;&gt;<br>&gt;&gt; because, in the worst case, we don’t know about the storage required for<br>&gt;&gt; the “storage” property until after we’ve allocated some instances of<br>&gt;&gt; MyStruct or MyClass, and we can’t simply go back and resize those instances<br>&gt;&gt; when we learn about the “storage” property. The “worst case” here could come<br>&gt;&gt; about with shared libraries: put the MyStruct/MyClass primary definitions<br>&gt;&gt; into an app, then put the extensions into a separate shared library. The app<br>&gt;&gt; creates some MyStruct and MyClass instances, then loads the shared library,<br>&gt;&gt; and now we have a problem: those instances have no storage for “storage.”<br>&gt;&gt;<br>&gt;&gt; We could relax the requirement to allow extensions in the same module as<br>&gt;&gt; the primary definition of that type to introduce stored properties, because<br>&gt;&gt; they’re compiled along with the primary type definition anyway. This doesn’t<br>&gt;&gt; solve out-of-module extensions, of course.<br>&gt;&gt;<br>&gt;&gt; We could embed a pointer into each instance that points off to the stored<br>&gt;&gt; properties for that instance. The pointer would refer to some<br>&gt;&gt; lazily-allocated memory on the heap with that extra storage. However, this<br>&gt;&gt; would either bloat every data structure by a pointer (including “Int”!) or<br>&gt;&gt; have to be opt-in, neither of which are great. I don’t think there is any<br>&gt;&gt; reasonable implementation for out-of-module stored properties in extensions<br>&gt;&gt; of value types (struct/enum).<br>&gt;&gt;<br>&gt;&gt; For classes, where we have object identity, we could have a side table<br>&gt;&gt; containing the stored properties (keyed on the object’s address). This is<br>&gt;&gt; how Objective-C’s associated objects work, and it’s a reasonable module for<br>&gt;&gt; out-of-module stored properties in extensions of classes.<br>&gt;&gt;<br>&gt;&gt; Getting back to stored properties in protocol extensions, the general<br>&gt;&gt; feature isn’t implementable without having some mechanism for out-of-module<br>&gt;&gt; stored properties in extensions of structs and enums, so you can limit it in<br>&gt;&gt; a few ways:<br>&gt;&gt;<br>&gt;&gt; * Only allow them on class-bound protocols, where there is a reasonable<br>&gt;&gt; implementation model<br>&gt;&gt;<br>&gt;&gt; * Allow them as default implementations within a protocol (not an<br>&gt;&gt; extension of a protocol!); a type can conform to that protocol either by<br>&gt;&gt; providing its own implementation of that property or somewhere where it is<br>&gt;&gt; reasonable for the default implementation to inject a stored property into<br>&gt;&gt; that context (e.g., on the primary type, within the same module as the<br>&gt;&gt; primary type, or on a class).<br>&gt;&gt;<br>&gt;&gt; Either handles the example brought up in the discussion of abstract base<br>&gt;&gt; classes.<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Best Regards!<br></p><p>Yang Wu<br>--------------------------------------------------------<br>Location: Pudong, Shanghai, China.<br>EMail    : pinxue at gmail.com<br>Website: http://www.time2change.mobi http://rockplayer.com<br>Twitter/Weibo : @pinxue<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>To be honest, I did not expect was to find some kind of consensus with<br>respect to structs. The technical challenge appears to be greater than the<br>benefit.<br></p><p>And about class, I imagine that today would only be possible to implement<br>using objc protocols, right? Using the associated objects mechanism.<br></p><p>Keeping limited to objc protocols is a feature that might be worth?<br></p><p>&quot;<br> Allow them as default implementations within a protocol (not an extension<br>of a protocol!); a type can conform to that protocol either by providing<br>its own implementation of that property or somewhere where it is reasonable<br>for the default implementation to inject a stored property into that<br>context (e.g., on the primary type, within the same module as the primary<br>type, or on a class)<br>&quot;<br></p><p>The problem with that is will make the protocol to much limited or not?<br>Maybe not worth the trouble.<br></p><p><br>Em seg, 11 de jan de 2016 às 02:34, Douglas Gregor &lt;dgregor at apple.com&gt;<br>escreveu:<br></p><p>&gt;<br>&gt; On Jan 10, 2016, at 6:43 PM, Wallacy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; TL;DR<br>&gt;<br>&gt; Thinking about some problems presented here this mailing list. I believe<br>&gt; that by following the same concepts behind the default protocol<br>&gt; implementations, allowing the same mechanism to provide default properties<br>&gt; can be a remarkable gain for language.<br>&gt;<br>&gt; Rationale:<br>&gt;<br>&gt; It has been proposed here also on this list, a need to produce abstract<br>&gt; classes, one of the reasons that need, is because is not possible to<br>&gt; declare properties in the same way as we declare default implementation on<br>&gt; protocols.<br>&gt; I also believe that this can help in the concept of multiple inheritance,<br>&gt; and serve as an aid to the default implementation on protocols, and<br>&gt; &quot;complete&quot; the Protocol-Oriented Programming concept.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; protocol Named {<br>&gt;     var name: String { get }<br>&gt; }<br>&gt; protocol Aged {<br>&gt;     var age: Int { get }<br>&gt; }<br>&gt; struct Person: Named, Aged {<br>&gt;     var name: String<br>&gt;     var age: Int<br>&gt; }<br>&gt;<br>&gt; extension Aged where Self: Named {<br>&gt;     func wishHappyBirthday() { // regular default implementation<br>&gt;         print(&quot;Happy birthday \(self.name) - you&#39;re \(self.age)!&quot;)<br>&gt;     }<br>&gt;     var birthdayVideo: AVPlayerItem? // nil is a default value<br>&gt; }<br>&gt; ...<br>&gt; func playBirthdayMediaFrom(person: Person){<br>&gt;     var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>&gt;     // etc...<br>&gt; }<br>&gt;<br>&gt; One of thousands of using this feature is to prevent us to create<br>&gt; variables that are not actually part of the data model we are shaping.<br>&gt;<br>&gt; birthdayVideo in this case would be any variable that is not part of our<br>&gt; model, but need to be associated with the object (or structure) in some<br>&gt; context of our application. (And not be used anywhere else in the APP or<br>&gt; another API).<br>&gt;<br>&gt; Other examples maybe a counter helper, weak reference to something, etc.<br>&gt; There is a infinite examples when we need to declare some variable just to<br>&gt; make the &quot;api&quot; happy like add a observer, holding some value, and use this<br>&gt; again to removeobserver in dealloc.<br>&gt;<br>&gt; I believe that the same rules and the same mechanisms involving default<br>&gt; implementation functions, should govern this default property<br>&gt; implementation, and any discussion about it on the problems on protocols<br>&gt; rules should be made separate this thread.<br>&gt;<br>&gt;<br>&gt; Default implementations of functions don’t require per-instance state,<br>&gt; while adding a stored property via a protocol extension does. Let’s step<br>&gt; back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt;<br>&gt; In the existing language, one can only introduce stored properties in the<br>&gt; primary definition of the type. That’s because, when we create an instance<br>&gt; of that type, we need to know how much storage to allocate for that<br>&gt; instance. So, right now, we don’t even allow, e.g.,<br>&gt;<br>&gt; struct MyStruct { }<br>&gt; extension MyStruct { var storage: Int = 0 } // error: extensions may not<br>&gt; contain stored properties<br>&gt;<br>&gt; class MyClass { }<br>&gt; extension MyClass { var storage: Int = 0 } // error: extensions may not<br>&gt; contain stored properties<br>&gt;<br>&gt; because, in the worst case, we don’t know about the storage required for<br>&gt; the “storage” property until after we’ve allocated some instances of<br>&gt; MyStruct or MyClass, and we can’t simply go back and resize those instances<br>&gt; when we learn about the “storage” property. The “worst case” here could<br>&gt; come about with shared libraries: put the MyStruct/MyClass primary<br>&gt; definitions into an app, then put the extensions into a separate shared<br>&gt; library. The app creates some MyStruct and MyClass instances, then loads<br>&gt; the shared library, and now we have a problem: those instances have no<br>&gt; storage for “storage.”<br>&gt;<br>&gt; We could relax the requirement to allow extensions in the same module as<br>&gt; the primary definition of that type to introduce stored properties, because<br>&gt; they’re compiled along with the primary type definition anyway. This<br>&gt; doesn’t solve out-of-module extensions, of course.<br>&gt;<br>&gt; We could embed a pointer into each instance that points off to the stored<br>&gt; properties for that instance. The pointer would refer to some<br>&gt; lazily-allocated memory on the heap with that extra storage. However, this<br>&gt; would either bloat every data structure by a pointer (including “Int”!) or<br>&gt; have to be opt-in, neither of which are great. I don’t think there is any<br>&gt; reasonable implementation for out-of-module stored properties in extensions<br>&gt; of value types (struct/enum).<br>&gt;<br>&gt; For classes, where we have object identity, we could have a side table<br>&gt; containing the stored properties (keyed on the object’s address). This is<br>&gt; how Objective-C’s associated objects work, and it’s a reasonable module for<br>&gt; out-of-module stored properties in extensions of classes.<br>&gt;<br>&gt; Getting back to stored properties in protocol extensions, the general<br>&gt; feature isn’t implementable without having some mechanism for out-of-module<br>&gt; stored properties in extensions of structs and enums, so you can limit it<br>&gt; in a few ways:<br>&gt;<br>&gt; * Only allow them on class-bound protocols, where there is a reasonable<br>&gt; implementation model<br>&gt;<br>&gt; * Allow them as default implementations within a protocol (not an<br>&gt; extension of a protocol!); a type can conform to that protocol either by<br>&gt; providing its own implementation of that property or somewhere where it is<br>&gt; reasonable for the default implementation to inject a stored property into<br>&gt; that context (e.g., on the primary type, within the same module as the<br>&gt; primary type, or on a class).<br>&gt;<br>&gt; Either handles the example brought up in the discussion of abstract base<br>&gt; classes.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/a55a3a6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 6:08 AM, Wallacy &lt;wallacyf at gmail.com&gt; wrote:<br>&gt; <br>&gt; To be honest, I did not expect was to find some kind of consensus with respect to structs. The technical challenge appears to be greater than the benefit.<br>&gt; <br>&gt; And about class, I imagine that today would only be possible to implement using objc protocols, right? Using the associated objects mechanism.<br>&gt; <br>&gt; Keeping limited to objc protocols is a feature that might be worth?<br></p><p>IMO, If we don’t do it portably for all classes and class-bound protocols, it’s not worth it. We don’t really want to introduce new @objc-only features.<br></p><p>&gt; <br>&gt; &quot;<br>&gt;  Allow them as default implementations within a protocol (not an extension of a protocol!); a type can conform to that protocol either by providing its own implementation of that property or somewhere where it is reasonable for the default implementation to inject a stored property into that context (e.g., on the primary type, within the same module as the primary type, or on a class)<br>&gt; &quot;<br>&gt; <br>&gt; The problem with that is will make the protocol to much limited or not? Maybe not worth the trouble.<br></p><p>Possibly not worth the trouble. If nothing else, it’s very hard to explain the limitations without deep-diving into the implementation details, which is an indicator that it’s “too complicated.&quot;<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt; Em seg, 11 de jan de 2016 às 02:34, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; escreveu:<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 6:43 PM, Wallacy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; TL;DR<br>&gt;&gt; <br>&gt;&gt; Thinking about some problems presented here this mailing list. I believe that by following the same concepts behind the default protocol implementations, allowing the same mechanism to provide default properties can be a remarkable gain for language.<br>&gt;&gt; <br>&gt;&gt; Rationale:<br>&gt;&gt; <br>&gt;&gt; It has been proposed here also on this list, a need to produce abstract classes, one of the reasons that need, is because is not possible to declare properties in the same way as we declare default implementation on protocols.<br>&gt;&gt; I also believe that this can help in the concept of multiple inheritance, and serve as an aid to the default implementation on protocols, and &quot;complete&quot; the Protocol-Oriented Programming concept.<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; protocol Named {<br>&gt;&gt;     var name: String { get }<br>&gt;&gt; }<br>&gt;&gt; protocol Aged {<br>&gt;&gt;     var age: Int { get }<br>&gt;&gt; }<br>&gt;&gt; struct Person: Named, Aged {<br>&gt;&gt;     var name: String<br>&gt;&gt;     var age: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Aged where Self: Named {    <br>&gt;&gt;     func wishHappyBirthday() { // regular default implementation<br>&gt;&gt;         print(&quot;Happy birthday \(self.name &lt;http://self.name/&gt;) - you&#39;re \(self.age)!&quot;)<br>&gt;&gt;     }<br>&gt;&gt;     var birthdayVideo: AVPlayerItem? // nil is a default value<br>&gt;&gt; }<br>&gt;&gt; ...<br>&gt;&gt; func playBirthdayMediaFrom(person: Person){<br>&gt;&gt;     var avPlayer = AVPlayer(playerItem: person.birthdayVideo)<br>&gt;&gt;     // etc...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; One of thousands of using this feature is to prevent us to create variables that are not actually part of the data model we are shaping.<br>&gt;&gt; <br>&gt;&gt; birthdayVideo in this case would be any variable that is not part of our model, but need to be associated with the object (or structure) in some context of our application. (And not be used anywhere else in the APP or another API).<br>&gt;&gt; <br>&gt;&gt; Other examples maybe a counter helper, weak reference to something, etc. There is a infinite examples when we need to declare some variable just to make the &quot;api&quot; happy like add a observer, holding some value, and use this again to removeobserver in dealloc.<br>&gt;&gt; <br>&gt;&gt; I believe that the same rules and the same mechanisms involving default implementation functions, should govern this default property implementation, and any discussion about it on the problems on protocols rules should be made separate this thread.<br>&gt; <br>&gt; Default implementations of functions don’t require per-instance state, while adding a stored property via a protocol extension does. Let’s step back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt; <br>&gt; In the existing language, one can only introduce stored properties in the primary definition of the type. That’s because, when we create an instance of that type, we need to know how much storage to allocate for that instance. So, right now, we don’t even allow, e.g.,<br>&gt; <br>&gt; 	struct MyStruct { }<br>&gt; 	extension MyStruct { var storage: Int = 0 } // error: extensions may not contain stored properties<br>&gt; <br>&gt; 	class MyClass { }<br>&gt; 	extension MyClass { var storage: Int = 0 } // error: extensions may not contain stored properties<br>&gt; <br>&gt; because, in the worst case, we don’t know about the storage required for the “storage” property until after we’ve allocated some instances of MyStruct or MyClass, and we can’t simply go back and resize those instances when we learn about the “storage” property. The “worst case” here could come about with shared libraries: put the MyStruct/MyClass primary definitions into an app, then put the extensions into a separate shared library. The app creates some MyStruct and MyClass instances, then loads the shared library, and now we have a problem: those instances have no storage for “storage.”<br>&gt; <br>&gt; We could relax the requirement to allow extensions in the same module as the primary definition of that type to introduce stored properties, because they’re compiled along with the primary type definition anyway. This doesn’t solve out-of-module extensions, of course.<br>&gt; <br>&gt; We could embed a pointer into each instance that points off to the stored properties for that instance. The pointer would refer to some lazily-allocated memory on the heap with that extra storage. However, this would either bloat every data structure by a pointer (including “Int”!) or have to be opt-in, neither of which are great. I don’t think there is any reasonable implementation for out-of-module stored properties in extensions of value types (struct/enum).<br>&gt; <br>&gt; For classes, where we have object identity, we could have a side table containing the stored properties (keyed on the object’s address). This is how Objective-C’s associated objects work, and it’s a reasonable module for out-of-module stored properties in extensions of classes.<br>&gt; <br>&gt; Getting back to stored properties in protocol extensions, the general feature isn’t implementable without having some mechanism for out-of-module stored properties in extensions of structs and enums, so you can limit it in a few ways:<br>&gt; <br>&gt; 	* Only allow them on class-bound protocols, where there is a reasonable implementation model<br>&gt; <br>&gt; 	* Allow them as default implementations within a protocol (not an extension of a protocol!); a type can conform to that protocol either by providing its own implementation of that property or somewhere where it is reasonable for the default implementation to inject a stored property into that context (e.g., on the primary type, within the same module as the primary type, or on a class).<br>&gt; <br>&gt; Either handles the example brought up in the discussion of abstract base classes.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/f4fbdd45/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>On Jan 10, 2016, at 8:34 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Default implementations of functions don’t require per-instance state, while adding a stored property via a protocol extension does. Let’s step back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt; <br>&gt; For classes, where we have object identity, we could have a side table containing the stored properties (keyed on the object’s address). This is how Objective-C’s associated objects work, and it’s a reasonable module for out-of-module stored properties in extensions of classes.<br>&gt; <br>&gt; Getting back to stored properties in protocol extensions, the general feature isn’t implementable without having some mechanism for out-of-module stored properties in extensions of structs and enums, so you can limit it in a few ways:<br>&gt; <br>&gt; 	* Only allow them on class-bound protocols, where there is a reasonable implementation model<br>&gt; <br>&gt; 	* Allow them as default implementations within a protocol (not an extension of a protocol!); a type can conform to that protocol either by providing its own implementation of that property or somewhere where it is reasonable for the default implementation to inject a stored property into that context (e.g., on the primary type, within the same module as the primary type, or on a class).<br>&gt; <br>&gt; Either handles the example brought up in the discussion of abstract base classes.<br></p><p>Hi Doug,<br></p><p>Have you considered this similar-but-different approach?<br></p><p>- Allow extensions on classes (only) within the same module/resilience domain as the class to add stored properties. This would keep them inline in the instance.<br>- Allow protocols to have stored property declarations, introducing a new “protocol with storage” (PwS) concept.<br>- Classes can directly conform to a PwS in its definition, or within an extension inside the same module/resilience domain.<br></p><p>Just this would give many of the benefits of a full mix-in programming model.  People could define these protocols, and their local implementation of the type can benefit from them.  It doesn’t support retroactive mixin’ing, but that is probably a good thing.  I’m assuming that we don’t want to allow adding state to structs within a resilience domain, just because I don’t think that is actually a good thing to add to the programming model (other reasonable people will surely disagree).<br></p><p>This base model could then be extended:<br>- Structs could conform to a PwS in their definition, but not an extension.  We could optionally require the struct to redeclare the properties to improve readability of the struct, but it wouldn’t be required from an implementation perspective.<br>- Classes could conform to a PwS across resilience boundaries, but wouldn’t get the state: they’d have to implement the storage requirement with a computed property.<br>- We could introduce an “associated objects” property behavior that makes providing the computed property very straight-forward, using the out of band implementation approach of ObjC.<br></p><p>The advantages of this approach I see are:<br></p><p>1) implementable, always a bonus.<br>2) keeps predictable performance.  You don’t get out “associated objects” overhead unexpectedly.  All state is always stored inline.<br>3) retroactive mixins are possible, but explicit.<br></p><p>The primary downside of this approach is that it introduces yet another weird protocol variant with limitations and behaviors, making the model more complicated.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 10:27 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jan 10, 2016, at 8:34 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Default implementations of functions don’t require per-instance state, while adding a stored property via a protocol extension does. Let’s step back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt;&gt; <br>&gt;&gt; For classes, where we have object identity, we could have a side table containing the stored properties (keyed on the object’s address). This is how Objective-C’s associated objects work, and it’s a reasonable module for out-of-module stored properties in extensions of classes.<br>&gt;&gt; <br>&gt;&gt; Getting back to stored properties in protocol extensions, the general feature isn’t implementable without having some mechanism for out-of-module stored properties in extensions of structs and enums, so you can limit it in a few ways:<br>&gt;&gt; <br>&gt;&gt; 	* Only allow them on class-bound protocols, where there is a reasonable implementation model<br>&gt;&gt; <br>&gt;&gt; 	* Allow them as default implementations within a protocol (not an extension of a protocol!); a type can conform to that protocol either by providing its own implementation of that property or somewhere where it is reasonable for the default implementation to inject a stored property into that context (e.g., on the primary type, within the same module as the primary type, or on a class).<br>&gt;&gt; <br>&gt;&gt; Either handles the example brought up in the discussion of abstract base classes.<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt; Have you considered this similar-but-different approach?<br></p><p>Not this particular shade, but I understand your motivation.<br></p><p>&gt; <br>&gt; - Allow extensions on classes (only) within the same module/resilience domain as the class to add stored properties. This would keep them inline in the instance.<br>&gt; - Allow protocols to have stored property declarations, introducing a new “protocol with storage” (PwS) concept.<br>&gt; - Classes can directly conform to a PwS in its definition, or within an extension inside the same module/resilience domain.<br>&gt; <br>&gt; Just this would give many of the benefits of a full mix-in programming model.  People could define these protocols, and their local implementation of the type can benefit from them.  It doesn’t support retroactive mixin’ing, but that is probably a good thing.  I’m assuming that we don’t want to allow adding state to structs within a resilience domain, just because I don’t think that is actually a good thing to add to the programming model (other reasonable people will surely disagree).<br>&gt; <br>&gt; This base model could then be extended:<br>&gt; - Structs could conform to a PwS in their definition, but not an extension.  We could optionally require the struct to redeclare the properties to improve readability of the struct, but it wouldn’t be required from an implementation perspective.<br>&gt; - Classes could conform to a PwS across resilience boundaries, but wouldn’t get the state: they’d have to implement the storage requirement with a computed property.<br>&gt; - We could introduce an “associated objects” property behavior that makes providing the computed property very straight-forward, using the out of band implementation approach of ObjC.<br>&gt; <br>&gt; The advantages of this approach I see are:<br>&gt; <br>&gt; 1) implementable, always a bonus.<br></p><p>This isn’t a different from my proposal in that regard ;)<br></p><p>&gt; 2) keeps predictable performance.  You don’t get out “associated objects” overhead unexpectedly.  All state is always stored inline.<br>&gt; 3) retroactive mixins are possible, but explicit.<br></p><p>… this is the real benefit, and I agree. The overhead of associated objects should require one to explicitly opt-in.<br></p><p>&gt; The primary downside of this approach is that it introduces yet another weird protocol variant with limitations and behaviors, making the model more complicated.<br></p><p><br>I think these semantics are reasonable, and the limitation is the same as what I proposed: it’s hard to describe why the limitations are what they are without a deep-dive into the implementation model.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>FWIW:<br></p><p>I quick look of my code base (in ObjC), i found 39 code points with I use<br>ObjC associated objects, one of them is a crazy database manager (for<br>postgres) with automatic look for the database, search the tables, search<br>for the program to find classes with the same name, and automatic add a<br>observer for all rows properties that match (surprisingly works).<br></p><p>Others codes are more simpler, but my point with this proposal, despite all<br>technical issues, is avoid some &quot;to much creative&quot; solutions to model the<br>code, one in particular I am looking now (in swift), has 8 core data<br>properties, and 8 transient and irrelevante properties just to maintain the<br>everything sane (like avplayer Periodic Time Observer), and all 8 has<br>default implementation using extensions, will be good declare some of the<br>storage properties in a protocol and make each &quot;behavior&quot; (like monitoring<br>the avplayer) a protocol to be reused.<br></p><p>And think about the PwS noted by Chris, yes, maybe can be confusing add<br>another &quot;kind&quot; of protocols, but like the Self requirement, generally, if<br>well implemented, its just a matter of time (not so much) to people<br>understand and drive a good protocol-oriented-programing code.<br></p><p>Em seg, 11 de jan de 2016 às 16:35, Douglas Gregor &lt;dgregor at apple.com&gt;<br>escreveu:<br></p><p>&gt;<br>&gt; &gt; On Jan 11, 2016, at 10:27 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Jan 10, 2016, at 8:34 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Default implementations of functions don’t require per-instance state,<br>&gt; while adding a stored property via a protocol extension does. Let’s step<br>&gt; back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; For classes, where we have object identity, we could have a side table<br>&gt; containing the stored properties (keyed on the object’s address). This is<br>&gt; how Objective-C’s associated objects work, and it’s a reasonable module for<br>&gt; out-of-module stored properties in extensions of classes.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Getting back to stored properties in protocol extensions, the general<br>&gt; feature isn’t implementable without having some mechanism for out-of-module<br>&gt; stored properties in extensions of structs and enums, so you can limit it<br>&gt; in a few ways:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      * Only allow them on class-bound protocols, where there is a<br>&gt; reasonable implementation model<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;      * Allow them as default implementations within a protocol (not an<br>&gt; extension of a protocol!); a type can conform to that protocol either by<br>&gt; providing its own implementation of that property or somewhere where it is<br>&gt; reasonable for the default implementation to inject a stored property into<br>&gt; that context (e.g., on the primary type, within the same module as the<br>&gt; primary type, or on a class).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Either handles the example brought up in the discussion of abstract<br>&gt; base classes.<br>&gt; &gt;<br>&gt; &gt; Hi Doug,<br>&gt; &gt;<br>&gt; &gt; Have you considered this similar-but-different approach?<br>&gt;<br>&gt; Not this particular shade, but I understand your motivation.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; - Allow extensions on classes (only) within the same module/resilience<br>&gt; domain as the class to add stored properties. This would keep them inline<br>&gt; in the instance.<br>&gt; &gt; - Allow protocols to have stored property declarations, introducing a<br>&gt; new “protocol with storage” (PwS) concept.<br>&gt; &gt; - Classes can directly conform to a PwS in its definition, or within an<br>&gt; extension inside the same module/resilience domain.<br>&gt; &gt;<br>&gt; &gt; Just this would give many of the benefits of a full mix-in programming<br>&gt; model.  People could define these protocols, and their local implementation<br>&gt; of the type can benefit from them.  It doesn’t support retroactive<br>&gt; mixin’ing, but that is probably a good thing.  I’m assuming that we don’t<br>&gt; want to allow adding state to structs within a resilience domain, just<br>&gt; because I don’t think that is actually a good thing to add to the<br>&gt; programming model (other reasonable people will surely disagree).<br>&gt; &gt;<br>&gt; &gt; This base model could then be extended:<br>&gt; &gt; - Structs could conform to a PwS in their definition, but not an<br>&gt; extension.  We could optionally require the struct to redeclare the<br>&gt; properties to improve readability of the struct, but it wouldn’t be<br>&gt; required from an implementation perspective.<br>&gt; &gt; - Classes could conform to a PwS across resilience boundaries, but<br>&gt; wouldn’t get the state: they’d have to implement the storage requirement<br>&gt; with a computed property.<br>&gt; &gt; - We could introduce an “associated objects” property behavior that<br>&gt; makes providing the computed property very straight-forward, using the out<br>&gt; of band implementation approach of ObjC.<br>&gt; &gt;<br>&gt; &gt; The advantages of this approach I see are:<br>&gt; &gt;<br>&gt; &gt; 1) implementable, always a bonus.<br>&gt;<br>&gt; This isn’t a different from my proposal in that regard ;)<br>&gt;<br>&gt; &gt; 2) keeps predictable performance.  You don’t get out “associated<br>&gt; objects” overhead unexpectedly.  All state is always stored inline.<br>&gt; &gt; 3) retroactive mixins are possible, but explicit.<br>&gt;<br>&gt; … this is the real benefit, and I agree. The overhead of associated<br>&gt; objects should require one to explicitly opt-in.<br>&gt;<br>&gt; &gt; The primary downside of this approach is that it introduces yet another<br>&gt; weird protocol variant with limitations and behaviors, making the model<br>&gt; more complicated.<br>&gt;<br>&gt;<br>&gt; I think these semantics are reasonable, and the limitation is the same as<br>&gt; what I proposed: it’s hard to describe why the limitations are what they<br>&gt; are without a deep-dive into the implementation model.<br>&gt;<br>&gt;         - Doug<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/23a3413a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Syntactically, would PwS be special like class-only protocols are now or<br>would it be automatic by having stored property declarations within the<br>protocol?<br></p><p>On Mon, Jan 11, 2016 at 6:36 PM, Wallacy via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; FWIW:<br>&gt;<br>&gt; I quick look of my code base (in ObjC), i found 39 code points with I use<br>&gt; ObjC associated objects, one of them is a crazy database manager (for<br>&gt; postgres) with automatic look for the database, search the tables, search<br>&gt; for the program to find classes with the same name, and automatic add a<br>&gt; observer for all rows properties that match (surprisingly works).<br>&gt;<br>&gt; Others codes are more simpler, but my point with this proposal, despite<br>&gt; all technical issues, is avoid some &quot;to much creative&quot; solutions to model<br>&gt; the code, one in particular I am looking now (in swift), has 8 core data<br>&gt; properties, and 8 transient and irrelevante properties just to maintain the<br>&gt; everything sane (like avplayer Periodic Time Observer), and all 8 has<br>&gt; default implementation using extensions, will be good declare some of the<br>&gt; storage properties in a protocol and make each &quot;behavior&quot; (like monitoring<br>&gt; the avplayer) a protocol to be reused.<br>&gt;<br>&gt; And think about the PwS noted by Chris, yes, maybe can be confusing add<br>&gt; another &quot;kind&quot; of protocols, but like the Self requirement, generally, if<br>&gt; well implemented, its just a matter of time (not so much) to people<br>&gt; understand and drive a good protocol-oriented-programing code.<br>&gt;<br>&gt; Em seg, 11 de jan de 2016 às 16:35, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt; escreveu:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Jan 11, 2016, at 10:27 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Jan 10, 2016, at 8:34 PM, Douglas Gregor via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; Default implementations of functions don’t require per-instance state,<br>&gt;&gt; while adding a stored property via a protocol extension does. Let’s step<br>&gt;&gt; back to a simpler problem: stored properties in (non-protocol) extensions.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; For classes, where we have object identity, we could have a side table<br>&gt;&gt; containing the stored properties (keyed on the object’s address). This is<br>&gt;&gt; how Objective-C’s associated objects work, and it’s a reasonable module for<br>&gt;&gt; out-of-module stored properties in extensions of classes.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Getting back to stored properties in protocol extensions, the general<br>&gt;&gt; feature isn’t implementable without having some mechanism for out-of-module<br>&gt;&gt; stored properties in extensions of structs and enums, so you can limit it<br>&gt;&gt; in a few ways:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;      * Only allow them on class-bound protocols, where there is a<br>&gt;&gt; reasonable implementation model<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;      * Allow them as default implementations within a protocol (not an<br>&gt;&gt; extension of a protocol!); a type can conform to that protocol either by<br>&gt;&gt; providing its own implementation of that property or somewhere where it is<br>&gt;&gt; reasonable for the default implementation to inject a stored property into<br>&gt;&gt; that context (e.g., on the primary type, within the same module as the<br>&gt;&gt; primary type, or on a class).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Either handles the example brought up in the discussion of abstract<br>&gt;&gt; base classes.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Hi Doug,<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Have you considered this similar-but-different approach?<br>&gt;&gt;<br>&gt;&gt; Not this particular shade, but I understand your motivation.<br>&gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; - Allow extensions on classes (only) within the same module/resilience<br>&gt;&gt; domain as the class to add stored properties. This would keep them inline<br>&gt;&gt; in the instance.<br>&gt;&gt; &gt; - Allow protocols to have stored property declarations, introducing a<br>&gt;&gt; new “protocol with storage” (PwS) concept.<br>&gt;&gt; &gt; - Classes can directly conform to a PwS in its definition, or within an<br>&gt;&gt; extension inside the same module/resilience domain.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Just this would give many of the benefits of a full mix-in programming<br>&gt;&gt; model.  People could define these protocols, and their local implementation<br>&gt;&gt; of the type can benefit from them.  It doesn’t support retroactive<br>&gt;&gt; mixin’ing, but that is probably a good thing.  I’m assuming that we don’t<br>&gt;&gt; want to allow adding state to structs within a resilience domain, just<br>&gt;&gt; because I don’t think that is actually a good thing to add to the<br>&gt;&gt; programming model (other reasonable people will surely disagree).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This base model could then be extended:<br>&gt;&gt; &gt; - Structs could conform to a PwS in their definition, but not an<br>&gt;&gt; extension.  We could optionally require the struct to redeclare the<br>&gt;&gt; properties to improve readability of the struct, but it wouldn’t be<br>&gt;&gt; required from an implementation perspective.<br>&gt;&gt; &gt; - Classes could conform to a PwS across resilience boundaries, but<br>&gt;&gt; wouldn’t get the state: they’d have to implement the storage requirement<br>&gt;&gt; with a computed property.<br>&gt;&gt; &gt; - We could introduce an “associated objects” property behavior that<br>&gt;&gt; makes providing the computed property very straight-forward, using the out<br>&gt;&gt; of band implementation approach of ObjC.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The advantages of this approach I see are:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1) implementable, always a bonus.<br>&gt;&gt;<br>&gt;&gt; This isn’t a different from my proposal in that regard ;)<br>&gt;&gt;<br>&gt;&gt; &gt; 2) keeps predictable performance.  You don’t get out “associated<br>&gt;&gt; objects” overhead unexpectedly.  All state is always stored inline.<br>&gt;&gt; &gt; 3) retroactive mixins are possible, but explicit.<br>&gt;&gt;<br>&gt;&gt; … this is the real benefit, and I agree. The overhead of associated<br>&gt;&gt; objects should require one to explicitly opt-in.<br>&gt;&gt;<br>&gt;&gt; &gt; The primary downside of this approach is that it introduces yet another<br>&gt;&gt; weird protocol variant with limitations and behaviors, making the model<br>&gt;&gt; more complicated.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think these semantics are reasonable, and the limitation is the same as<br>&gt;&gt; what I proposed: it’s hard to describe why the limitations are what they<br>&gt;&gt; are without a deep-dive into the implementation model.<br>&gt;&gt;<br>&gt;&gt;         - Doug<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/aaef586d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 3:46 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; <br>&gt; Syntactically, would PwS be special like class-only protocols are now or would it be automatic by having stored property declarations within the protocol?<br></p><p>Up for debate.  An automatic approach brings hesitation to me, because I don’t want it to be the difference between:<br></p><p>protocol P {<br>  var x : Int { get }<br>}<br></p><p>and:<br></p><p>protocol P {<br>  var x : Int <br>}<br></p><p>Did I want a PwS there, or did I just forget {get/set}?<br></p><p>Marking the protocol with an attribute or declmodifier would solve that.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 11, 2016, at 7:25 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 11, 2016, at 3:46 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Syntactically, would PwS be special like class-only protocols are now or would it be automatic by having stored property declarations within the protocol?<br>&gt; <br>&gt; Up for debate.  An automatic approach brings hesitation to me, because I don’t want it to be the difference between:<br>&gt; <br>&gt; protocol P {<br>&gt;  var x : Int { get }<br>&gt; }<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; protocol P {<br>&gt;  var x : Int <br>&gt; }<br>&gt; <br>&gt; Did I want a PwS there, or did I just forget {get/set}?<br>&gt; <br>&gt; Marking the protocol with an attribute or declmodifier would solve that.<br></p><p>+1.  This is something that deserves to be pretty explicit.<br></p><p>Another point that I think needs to be discussed is whether the protocol storage is just a default that can be overridden or whether it should be protocol-specific.  Or should the protocol author be able to choose.  For example, can a protocol have private storage that is not visible outside the implementation of default or extension methods?  All things that need to be considered IMO.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c40db4457ab2c91a0d8006da31b177c6?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Trent Nadeau</string> &lt;tanadeau at gmail.com&gt;<p>January 11, 2016 at 08:00:00pm</p></header><div class="content"><p>+1 for being explicit given there are, at a minimum, costs to size of<br>conforming types.<br></p><p>When it comes to visibility to only extensions, that could be more general<br>that just for protocols. That could also be useful for structs and classes.<br></p><p>For example,<br></p><p>class Foo {<br>    /// Extensions should log all commands<br>    // Treated like private everywhere but extensions.<br>    // It would be an exported symbol but with qualifiers restricting usage<br>    private public(extension) func logCommand(message: String) { ... }<br>}<br></p><p>// Can be in another file in same or different module<br>extension Foo {<br>    func doStuff() {<br>        logCommand(&quot;Doing stuff now&quot;)<br>        // ...<br>    }<br>}<br></p><p>let f = Foo()<br>f.logCommand(&quot;blah&quot;) // error anywhere but same file<br></p><p>On Mon, Jan 11, 2016 at 8:27 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt; &gt; On Jan 11, 2016, at 7:25 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jan 11, 2016, at 3:46 PM, Trent Nadeau &lt;tanadeau at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Syntactically, would PwS be special like class-only protocols are now<br>&gt; or would it be automatic by having stored property declarations within the<br>&gt; protocol?<br>&gt; &gt;<br>&gt; &gt; Up for debate.  An automatic approach brings hesitation to me, because I<br>&gt; don’t want it to be the difference between:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt;  var x : Int { get }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; and:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt;  var x : Int<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Did I want a PwS there, or did I just forget {get/set}?<br>&gt; &gt;<br>&gt; &gt; Marking the protocol with an attribute or declmodifier would solve that.<br>&gt;<br>&gt; +1.  This is something that deserves to be pretty explicit.<br>&gt;<br>&gt; Another point that I think needs to be discussed is whether the protocol<br>&gt; storage is just a default that can be overridden or whether it should be<br>&gt; protocol-specific.  Or should the protocol author be able to choose.  For<br>&gt; example, can a protocol have private storage that is not visible outside<br>&gt; the implementation of default or extension methods?  All things that need<br>&gt; to be considered IMO.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; &gt;<br>&gt; &gt; -Chris<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Trent Nadeau<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/3b163bf9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 11, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; An automatic approach brings hesitation to me, because I don’t want it to be the difference between:<br>&gt; <br>&gt; protocol P {<br>&gt;  var x : Int { get }<br>&gt; }<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; protocol P {<br>&gt;  var x : Int <br>&gt; }<br>&gt; <br>&gt; Did I want a PwS there, or did I just forget {get/set}?<br></p><p>If we&#39;re going to start adding concrete things to protocols—not just stored properties, but (drawing on other proposals) perhaps also default implementations, final members, factory initializers, etc.—perhaps we should start marking the things that *aren&#39;t* concrete with `required`.<br></p><p>Currently:<br></p><p>	public protocol Strideable : Comparable, _Strideable {<br>	    associatedtype Stride : SignedNumberType<br>	    @warn_unused_result<br>	    public func distanceTo(other: Self) -&gt; Self.Stride<br>	    @warn_unused_result<br>	    public func advancedBy(n: Self.Stride) -&gt; Self<br>	}<br>	<br>	extension Strideable {<br>	    @warn_unused_result<br>	    public func stride(to end: Self, by stride: Self.Stride) -&gt; StrideTo&lt;Self&gt; {<br>	        /* implementation here */<br>	    }<br>	}<br>	<br>	extension Strideable {<br>	    @warn_unused_result<br>	    public func stride(through end: Self, by stride: Self.Stride) -&gt; StrideThrough&lt;Self&gt; {<br>	        /* implementation here */<br>	    }<br>	}<br></p><p>Future:<br></p><p>	public protocol Strideable : Comparable, _Strideable {<br>	    associatedtype Stride : SignedNumberType<br>	    @warn_unused_result<br>	    required public func distanceTo(other: Self) -&gt; Self.Stride<br>	    @warn_unused_result<br>	    required public func advancedBy(n: Self.Stride) -&gt; Self<br>	    <br>	    @warn_unused_result<br>	    final public func stride(to end: Self, by stride: Self.Stride) -&gt; StrideTo&lt;Self&gt; {<br>	        /* implementation here */<br>	    }<br>            <br>	    @warn_unused_result<br>	    final public func stride(through end: Self, by stride: Self.Stride) -&gt; StrideThrough&lt;Self&gt; {<br>	        /* implementation here */<br>	    }<br>	}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January 12, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>On Jan 12, 2016, at 1:11 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; An automatic approach brings hesitation to me, because I don’t want it to be the difference between:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; var x : Int { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; var x : Int <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Did I want a PwS there, or did I just forget {get/set}?<br>&gt; <br>&gt; If we&#39;re going to start adding concrete things to protocols—not just stored properties, but (drawing on other proposals) perhaps also default implementations, final members, factory initializers, etc.—perhaps we should start marking the things that *aren&#39;t* concrete with `required`.<br>&gt; <br>&gt; Currently:<br>&gt; <br>&gt;    public protocol Strideable : Comparable, _Strideable {<br>&gt;        associatedtype Stride : SignedNumberType<br>&gt;        @warn_unused_result<br>&gt;        public func distanceTo(other: Self) -&gt; Self.Stride<br>&gt;        @warn_unused_result<br>&gt;        public func advancedBy(n: Self.Stride) -&gt; Self<br>&gt;    }<br>&gt;    <br>&gt;    extension Strideable {<br>&gt;        @warn_unused_result<br>&gt;        public func stride(to end: Self, by stride: Self.Stride) -&gt; StrideTo&lt;Self&gt; {<br>&gt;            /* implementation here */<br>&gt;        }<br>&gt;    }<br>&gt;    <br>&gt;    extension Strideable {<br>&gt;        @warn_unused_result<br>&gt;        public func stride(through end: Self, by stride: Self.Stride) -&gt; StrideThrough&lt;Self&gt; {<br>&gt;            /* implementation here */<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt; Future:<br>&gt; <br>&gt;    public protocol Strideable : Comparable, _Strideable {<br>&gt;        associatedtype Stride : SignedNumberType<br>&gt;        @warn_unused_result<br>&gt;        required public func distanceTo(other: Self) -&gt; Self.Stride<br>&gt;        @warn_unused_result<br>&gt;        required public func advancedBy(n: Self.Stride) -&gt; Self<br>&gt;        <br>&gt;        @warn_unused_result<br>&gt;        final public func stride(to end: Self, by stride: Self.Stride) -&gt; StrideTo&lt;Self&gt; {<br>&gt;            /* implementation here */<br>&gt;        }<br>&gt; <br>&gt;        @warn_unused_result<br>&gt;        final public func stride(through end: Self, by stride: Self.Stride) -&gt; StrideThrough&lt;Self&gt; {<br>&gt;            /* implementation here */<br>&gt;        }<br>&gt;    }<br></p><p>Not sure which should be the default (required or not required), but I agree that the minimum required members for conformance should be much more clear than it is in protocol declarations today.<br></p><p>Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Yes, currently is hard to &quot;know for sure&quot; if you need for implement all<br>requirements of the protocol. Usually I wait for compile to tell me.<br></p><p>Anyway, i think the protocols is more useful to model behaviour, and<br>default implementation help with that. Its like multiple inheritance<br>without the hard part.<br></p><p>So I&#39;m very concerned about putting &quot;a lot of stuffs&quot; on protocols, and<br>bring the bad parts of multiple heritage.<br></p><p>Although my proposal, I believe protocols need to be extremely simple, and<br>easy to use. And i&#39;m really think the storage properties can help with<br>that. I&#39;m worried about the idea of people using/modeling protocols just as<br>concrete types.<br></p><p>If this idea go ahead, it may be an opportunity to bring some clarity to<br>the current scenario, but also prevent future abuses.<br></p><p>The main problem is (to me): What is really a Protocol Oriented Programing?<br>I Saw Dave Abrahams presentations a few times, but the whole idea is not<br>100% clear. So it&#39;s hard to think of a design to help this concept.<br></p><p><br>Em ter, 12 de jan de 2016 às 05:11, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; &gt; An automatic approach brings hesitation to me, because I don’t want it<br>&gt; to be the difference between:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt;  var x : Int { get }<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; and:<br>&gt; &gt;<br>&gt; &gt; protocol P {<br>&gt; &gt;  var x : Int<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; Did I want a PwS there, or did I just forget {get/set}?<br>&gt;<br>&gt; If we&#39;re going to start adding concrete things to protocols—not just<br>&gt; stored properties, but (drawing on other proposals) perhaps also default<br>&gt; implementations, final members, factory initializers, etc.—perhaps we<br>&gt; should start marking the things that *aren&#39;t* concrete with `required`.<br>&gt;<br>&gt; Currently:<br>&gt;<br>&gt;         public protocol Strideable : Comparable, _Strideable {<br>&gt;             associatedtype Stride : SignedNumberType<br>&gt;             @warn_unused_result<br>&gt;             public func distanceTo(other: Self) -&gt; Self.Stride<br>&gt;             @warn_unused_result<br>&gt;             public func advancedBy(n: Self.Stride) -&gt; Self<br>&gt;         }<br>&gt;<br>&gt;         extension Strideable {<br>&gt;             @warn_unused_result<br>&gt;             public func stride(to end: Self, by stride: Self.Stride) -&gt;<br>&gt; StrideTo&lt;Self&gt; {<br>&gt;                 /* implementation here */<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;         extension Strideable {<br>&gt;             @warn_unused_result<br>&gt;             public func stride(through end: Self, by stride: Self.Stride)<br>&gt; -&gt; StrideThrough&lt;Self&gt; {<br>&gt;                 /* implementation here */<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; Future:<br>&gt;<br>&gt;         public protocol Strideable : Comparable, _Strideable {<br>&gt;             associatedtype Stride : SignedNumberType<br>&gt;             @warn_unused_result<br>&gt;             required public func distanceTo(other: Self) -&gt; Self.Stride<br>&gt;             @warn_unused_result<br>&gt;             required public func advancedBy(n: Self.Stride) -&gt; Self<br>&gt;<br>&gt;             @warn_unused_result<br>&gt;             final public func stride(to end: Self, by stride: Self.Stride)<br>&gt; -&gt; StrideTo&lt;Self&gt; {<br>&gt;                 /* implementation here */<br>&gt;             }<br>&gt;<br>&gt;             @warn_unused_result<br>&gt;             final public func stride(through end: Self, by stride:<br>&gt; Self.Stride) -&gt; StrideThrough&lt;Self&gt; {<br>&gt;                 /* implementation here */<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/4bffb736/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Properties on Default Protocol Implementations</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>January 12, 2016 at 04:00:00pm</p></header><div class="content"><p>Also, FWIW:<br></p><p>Another example using Dave&#39;s presentation:<br></p><p>extension Renderer where Self:CGContext { // same as extension CGContext :<br>Renderer in this case<br>   * var defaultDashPhase:CGFloat = 0.0*<br>*    var defaultDashLengths:[CGFloat] = [10.0, 4.0]*<br></p><p>    func moveTo(position: CGPoint) {<br>        CGContextMoveToPoint(self, position.x, position.y)<br>    }<br>    func lineTo(position: CGPoint) {<br>        CGContextAddLineToPoint(self, position.x, position.y)<br>    }<br>    *func dashedLineTo(position: CGPoint) {*<br>*<br>CGContextSetLineDash(self,defaultDashPhase,defaultDashLengths,defaultDashLengths.count);*<br>*        CGContextAddLineToPoint(self, position.x, position.y)*<br>*    }*<br>    func arcAt(center: CGPoint, radius: CGFloat, startAngle: CGFloat,<br>endAngle: CGFloat) {<br>        let arc = CGPathCreateMutable()<br>        CGPathAddArc(arc, nil, center.x, center.y, radius, startAngle,<br>endAngle, true)<br>        CGContextAddPath(self, arc)<br>    }<br>}<br></p><p>We can make more &quot;customizable&quot; extensions, good... And for other &quot;kind&quot; of<br>Renderer we can use other variables (for that kind), fine.<br></p><p>It&#39;s too much magic i know, but i can see some problems be solved using<br>this construct. But i don&#39;t know how to make this more explicit on protocol<br>declaration, or just leave in that way, like the other functions.<br></p><p><br></p><p><br>Em ter, 12 de jan de 2016 às 13:32, Wallacy &lt;wallacyf at gmail.com&gt; escreveu:<br></p><p>&gt; Yes, currently is hard to &quot;know for sure&quot; if you need for implement all<br>&gt; requirements of the protocol. Usually I wait for compile to tell me.<br>&gt;<br>&gt; Anyway, i think the protocols is more useful to model behaviour, and<br>&gt; default implementation help with that. Its like multiple inheritance<br>&gt; without the hard part.<br>&gt;<br>&gt; So I&#39;m very concerned about putting &quot;a lot of stuffs&quot; on protocols, and<br>&gt; bring the bad parts of multiple heritage.<br>&gt;<br>&gt; Although my proposal, I believe protocols need to be extremely simple, and<br>&gt; easy to use. And i&#39;m really think the storage properties can help with<br>&gt; that. I&#39;m worried about the idea of people using/modeling protocols just as<br>&gt; concrete types.<br>&gt;<br>&gt; If this idea go ahead, it may be an opportunity to bring some clarity to<br>&gt; the current scenario, but also prevent future abuses.<br>&gt;<br>&gt; The main problem is (to me): What is really a Protocol Oriented<br>&gt; Programing? I Saw Dave Abrahams presentations a few times, but the whole<br>&gt; idea is not 100% clear. So it&#39;s hard to think of a design to help this<br>&gt; concept.<br>&gt;<br>&gt;<br>&gt; Em ter, 12 de jan de 2016 às 05:11, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; escreveu:<br>&gt;<br>&gt;&gt; &gt; An automatic approach brings hesitation to me, because I don’t want it<br>&gt;&gt; to be the difference between:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt;  var x : Int { get }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; and:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol P {<br>&gt;&gt; &gt;  var x : Int<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Did I want a PwS there, or did I just forget {get/set}?<br>&gt;&gt;<br>&gt;&gt; If we&#39;re going to start adding concrete things to protocols—not just<br>&gt;&gt; stored properties, but (drawing on other proposals) perhaps also default<br>&gt;&gt; implementations, final members, factory initializers, etc.—perhaps we<br>&gt;&gt; should start marking the things that *aren&#39;t* concrete with `required`.<br>&gt;&gt;<br>&gt;&gt; Currently:<br>&gt;&gt;<br>&gt;&gt;         public protocol Strideable : Comparable, _Strideable {<br>&gt;&gt;             associatedtype Stride : SignedNumberType<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             public func distanceTo(other: Self) -&gt; Self.Stride<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             public func advancedBy(n: Self.Stride) -&gt; Self<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension Strideable {<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             public func stride(to end: Self, by stride: Self.Stride) -&gt;<br>&gt;&gt; StrideTo&lt;Self&gt; {<br>&gt;&gt;                 /* implementation here */<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         extension Strideable {<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             public func stride(through end: Self, by stride: Self.Stride)<br>&gt;&gt; -&gt; StrideThrough&lt;Self&gt; {<br>&gt;&gt;                 /* implementation here */<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; Future:<br>&gt;&gt;<br>&gt;&gt;         public protocol Strideable : Comparable, _Strideable {<br>&gt;&gt;             associatedtype Stride : SignedNumberType<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             required public func distanceTo(other: Self) -&gt; Self.Stride<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             required public func advancedBy(n: Self.Stride) -&gt; Self<br>&gt;&gt;<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             final public func stride(to end: Self, by stride:<br>&gt;&gt; Self.Stride) -&gt; StrideTo&lt;Self&gt; {<br>&gt;&gt;                 /* implementation here */<br>&gt;&gt;             }<br>&gt;&gt;<br>&gt;&gt;             @warn_unused_result<br>&gt;&gt;             final public func stride(through end: Self, by stride:<br>&gt;&gt; Self.Stride) -&gt; StrideThrough&lt;Self&gt; {<br>&gt;&gt;                 /* implementation here */<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/a6acca08/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
