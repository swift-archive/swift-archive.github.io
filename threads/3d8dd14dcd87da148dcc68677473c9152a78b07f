<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>Lexical matters: identifiers and operators</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October  1, 2016 at 09:00:00am</p></header><div class="content"><p>New to the list, but old hand at PL design. Was looking over the lexical<br>structure of Swift 2.2 and 3.0, and I have some questions. A number of<br>considerations identified in UAX31 (Unicode Identifier and Pattern Syntax)<br>and UAX36 (Unicode Security Considerations) aren&#39;t obviously addressed.<br></p><p>Here are some items that jumped out from a casual glance at the spec:<br></p><p>1. The specification does not appear to state any particular rules for<br>compatibility or normalization in identifiers. Other Unicode-aware<br>programming languages have adopted NFKC almost universally, and for good<br>reason. The current identifier-head and identifier-character grammar admit<br>sequences that Unicode considers malformed.<br></p><p>2. The specification does not appear to address any notion of Unicode<br>equivalent sequences.<br></p><p>3. The relationship between the identifiers admitted by Swift 3 and<br>identifiers admitted by UAX31 isn&#39;t clear. As a matter of cross-platform<br>compatibility it would be really good if identifiers permitted by the<br>default rules of UAX31 were all legal in Swift. This seems important for<br>cross-language interop.<br></p><p>Has this relationship been discussed somewhere I can catch up on?<br></p><p>4. Valid operators include code points that are undefined in any current or<br>historical Unicode standard. That seems problematic. Future revisions to<br>Unicode will eventually place *some* of those code points in the XIDS/XIDC<br>categories, at which point we will have to choose between backwards<br>compatibility and interop. Others will be assigned to new combining marks,<br>which will want to be used in identifiers. As new languages are added to<br>Unicode, compatibility concerns will exclude some groups from using<br>identifiers that are natural to them.<br></p><p><br>In order of least-to-most difficulty, I&#39;d like to suggest some changes to<br>the specification. I&#39;m willing to implement them if agreement can be<br>reached:<br></p><p>1. Pick a Unicode version and exclude any code point that is undefined as<br>of that standard from both operators and identifiers. It&#39;s relatively easy<br>and backwards compatible to move the Unicode version number forward as the<br>language specification evolves.<br></p><p>2. Ensure that no code point in the Unicode Pattern_Syntax and<br>Pattern_WhiteSpace categories are not included in identifier-head or<br>identifier-character.<br></p><p>3. Explicitly state that no code point in (XIDS u XIDC) or<br>Pattern_WhiteSpace is legal in an operator. Consider ensuring that<br>everything in Pattern_Syntax *is* permitted in an operator.<br></p><p>4. I&#39;d personally like to see an explicit statement of the extensions to<br>XIDS/XIDC that are admitted by identifier-head and identifier-character.<br>UAX31 refers to such extensions as a &quot;profile&quot;, and explicitly allows them.<br>I&#39;m not interested in changing the identifier space unless there is<br>something grossly and obviously problematic. What I&#39;m after is enabling<br>developers to be cognizant of potential interop challenges.<br></p><p>5. Adopt NFKC for identifiers. Specify and implement a combining algorithm<br>version so that forward/backward compatibility is ensured.<br></p><p><br>The first three are pretty trivial. The fourth would take some sleuthing,<br>but it is straightforward. The fifth is real work. I&#39;d be willing to sign<br>up to any or all of these, but for a starting point I want to learn where<br>things stand, what decisions have already been made, and where any current<br>discussion may be happening.<br></p><p>I very much doubt that NFKC would break existing code, if only because the<br>use of malformed Unicode sequences is likely to be rare. To the extent that<br>they exist in the field, they are almost certainly (a) unintentional, or<br>(b) security concerns. It seems like a good thing to catch both of those<br>early to the extent that we can, and to do so while the language definition<br>remains somewhat fluid.<br></p><p><br>Thanks!<br></p><p><br>Jonathan Shapiro<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161001/3d8db07f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Lexical matters: identifiers and operators</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October  1, 2016 at 04:00:00pm</p></header><div class="content"><p>There is a PR on swift-evolution to implement UAX#31 recommendations:<br></p><p>https://github.com/apple/swift-evolution/pull/531<br></p><p>It was discussed on this list fairly recently, so a quick scroll through<br>the archives should surface those threads.<br></p><p>Briefly, UAX#31 recommends NFC for languages with case-sensitive<br>identifiers and NFKC for languages with case-insensitive identifiers, so<br>the proposed normalization in this PR is NFC and not NFKC.<br></p><p>On Sat, Oct 1, 2016 at 11:02 Jonathan S. Shapiro via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; New to the list, but old hand at PL design. Was looking over the lexical<br>&gt; structure of Swift 2.2 and 3.0, and I have some questions. A number of<br>&gt; considerations identified in UAX31 (Unicode Identifier and Pattern Syntax)<br>&gt; and UAX36 (Unicode Security Considerations) aren&#39;t obviously addressed.<br>&gt;<br>&gt; Here are some items that jumped out from a casual glance at the spec:<br>&gt;<br>&gt; 1. The specification does not appear to state any particular rules for<br>&gt; compatibility or normalization in identifiers. Other Unicode-aware<br>&gt; programming languages have adopted NFKC almost universally, and for good<br>&gt; reason. The current identifier-head and identifier-character grammar admit<br>&gt; sequences that Unicode considers malformed.<br>&gt;<br>&gt; 2. The specification does not appear to address any notion of Unicode<br>&gt; equivalent sequences.<br>&gt;<br>&gt; 3. The relationship between the identifiers admitted by Swift 3 and<br>&gt; identifiers admitted by UAX31 isn&#39;t clear. As a matter of cross-platform<br>&gt; compatibility it would be really good if identifiers permitted by the<br>&gt; default rules of UAX31 were all legal in Swift. This seems important for<br>&gt; cross-language interop.<br>&gt;<br>&gt; Has this relationship been discussed somewhere I can catch up on?<br>&gt;<br>&gt; 4. Valid operators include code points that are undefined in any current<br>&gt; or historical Unicode standard. That seems problematic. Future revisions to<br>&gt; Unicode will eventually place *some* of those code points in the XIDS/XIDC<br>&gt; categories, at which point we will have to choose between backwards<br>&gt; compatibility and interop. Others will be assigned to new combining marks,<br>&gt; which will want to be used in identifiers. As new languages are added to<br>&gt; Unicode, compatibility concerns will exclude some groups from using<br>&gt; identifiers that are natural to them.<br>&gt;<br>&gt;<br>&gt; In order of least-to-most difficulty, I&#39;d like to suggest some changes to<br>&gt; the specification. I&#39;m willing to implement them if agreement can be<br>&gt; reached:<br>&gt;<br>&gt; 1. Pick a Unicode version and exclude any code point that is undefined as<br>&gt; of that standard from both operators and identifiers. It&#39;s relatively easy<br>&gt; and backwards compatible to move the Unicode version number forward as the<br>&gt; language specification evolves.<br>&gt;<br>&gt; 2. Ensure that no code point in the Unicode Pattern_Syntax and<br>&gt; Pattern_WhiteSpace categories are not included in identifier-head or<br>&gt; identifier-character.<br>&gt;<br>&gt; 3. Explicitly state that no code point in (XIDS u XIDC) or<br>&gt; Pattern_WhiteSpace is legal in an operator. Consider ensuring that<br>&gt; everything in Pattern_Syntax *is* permitted in an operator.<br>&gt;<br>&gt; 4. I&#39;d personally like to see an explicit statement of the extensions to<br>&gt; XIDS/XIDC that are admitted by identifier-head and identifier-character.<br>&gt; UAX31 refers to such extensions as a &quot;profile&quot;, and explicitly allows them.<br>&gt; I&#39;m not interested in changing the identifier space unless there is<br>&gt; something grossly and obviously problematic. What I&#39;m after is enabling<br>&gt; developers to be cognizant of potential interop challenges.<br>&gt;<br>&gt; 5. Adopt NFKC for identifiers. Specify and implement a combining algorithm<br>&gt; version so that forward/backward compatibility is ensured.<br>&gt;<br>&gt;<br>&gt; The first three are pretty trivial. The fourth would take some sleuthing,<br>&gt; but it is straightforward. The fifth is real work. I&#39;d be willing to sign<br>&gt; up to any or all of these, but for a starting point I want to learn where<br>&gt; things stand, what decisions have already been made, and where any current<br>&gt; discussion may be happening.<br>&gt;<br>&gt; I very much doubt that NFKC would break existing code, if only because the<br>&gt; use of malformed Unicode sequences is likely to be rare. To the extent that<br>&gt; they exist in the field, they are almost certainly (a) unintentional, or<br>&gt; (b) security concerns. It seems like a good thing to catch both of those<br>&gt; early to the extent that we can, and to do so while the language definition<br>&gt; remains somewhat fluid.<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt;<br>&gt; Jonathan Shapiro<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161001/d0ababe7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5931766360e7b16042376524df12d61c?s=50"></div><header><strong>Lexical matters: identifiers and operators</strong> from <string>Jonathan S. Shapiro</string> &lt;jonathan.s.shapiro at gmail.com&gt;<p>October  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Xiaodi:<br></p><p>Thanks for the pointer. I&#39;ll catch up on the state of the PR before doing<br>anything else.<br></p><p>And yes, I should have written NFC rather than NFKC. Thanks for pointing<br>out the error.<br></p><p><br>Jonathan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161001/9157c126/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Lexical matters: identifiers and operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>October  1, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Jonathan,<br></p><p>I started another discussion on this a couple weeks ago. I haven&#39;t had time<br>to make any progress on the topic lately, but I&#39;m hoping to do so this<br>weekend. Glad to hear you&#39;re interested!<br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160912/027108.html<br></p><p>Jacob<br></p><p>On Sat, Oct 1, 2016 at 9:02 AM, Jonathan S. Shapiro via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; New to the list, but old hand at PL design. Was looking over the lexical<br>&gt; structure of Swift 2.2 and 3.0, and I have some questions. A number of<br>&gt; considerations identified in UAX31 (Unicode Identifier and Pattern Syntax)<br>&gt; and UAX36 (Unicode Security Considerations) aren&#39;t obviously addressed.<br>&gt;<br>&gt; Here are some items that jumped out from a casual glance at the spec:<br>&gt;<br>&gt; 1. The specification does not appear to state any particular rules for<br>&gt; compatibility or normalization in identifiers. Other Unicode-aware<br>&gt; programming languages have adopted NFKC almost universally, and for good<br>&gt; reason. The current identifier-head and identifier-character grammar admit<br>&gt; sequences that Unicode considers malformed.<br>&gt;<br>&gt; 2. The specification does not appear to address any notion of Unicode<br>&gt; equivalent sequences.<br>&gt;<br>&gt; 3. The relationship between the identifiers admitted by Swift 3 and<br>&gt; identifiers admitted by UAX31 isn&#39;t clear. As a matter of cross-platform<br>&gt; compatibility it would be really good if identifiers permitted by the<br>&gt; default rules of UAX31 were all legal in Swift. This seems important for<br>&gt; cross-language interop.<br>&gt;<br>&gt; Has this relationship been discussed somewhere I can catch up on?<br>&gt;<br>&gt; 4. Valid operators include code points that are undefined in any current<br>&gt; or historical Unicode standard. That seems problematic. Future revisions to<br>&gt; Unicode will eventually place *some* of those code points in the XIDS/XIDC<br>&gt; categories, at which point we will have to choose between backwards<br>&gt; compatibility and interop. Others will be assigned to new combining marks,<br>&gt; which will want to be used in identifiers. As new languages are added to<br>&gt; Unicode, compatibility concerns will exclude some groups from using<br>&gt; identifiers that are natural to them.<br>&gt;<br>&gt;<br>&gt; In order of least-to-most difficulty, I&#39;d like to suggest some changes to<br>&gt; the specification. I&#39;m willing to implement them if agreement can be<br>&gt; reached:<br>&gt;<br>&gt; 1. Pick a Unicode version and exclude any code point that is undefined as<br>&gt; of that standard from both operators and identifiers. It&#39;s relatively easy<br>&gt; and backwards compatible to move the Unicode version number forward as the<br>&gt; language specification evolves.<br>&gt;<br>&gt; 2. Ensure that no code point in the Unicode Pattern_Syntax and<br>&gt; Pattern_WhiteSpace categories are not included in identifier-head or<br>&gt; identifier-character.<br>&gt;<br>&gt; 3. Explicitly state that no code point in (XIDS u XIDC) or<br>&gt; Pattern_WhiteSpace is legal in an operator. Consider ensuring that<br>&gt; everything in Pattern_Syntax *is* permitted in an operator.<br>&gt;<br>&gt; 4. I&#39;d personally like to see an explicit statement of the extensions to<br>&gt; XIDS/XIDC that are admitted by identifier-head and identifier-character.<br>&gt; UAX31 refers to such extensions as a &quot;profile&quot;, and explicitly allows them.<br>&gt; I&#39;m not interested in changing the identifier space unless there is<br>&gt; something grossly and obviously problematic. What I&#39;m after is enabling<br>&gt; developers to be cognizant of potential interop challenges.<br>&gt;<br>&gt; 5. Adopt NFKC for identifiers. Specify and implement a combining algorithm<br>&gt; version so that forward/backward compatibility is ensured.<br>&gt;<br>&gt;<br>&gt; The first three are pretty trivial. The fourth would take some sleuthing,<br>&gt; but it is straightforward. The fifth is real work. I&#39;d be willing to sign<br>&gt; up to any or all of these, but for a starting point I want to learn where<br>&gt; things stand, what decisions have already been made, and where any current<br>&gt; discussion may be happening.<br>&gt;<br>&gt; I very much doubt that NFKC would break existing code, if only because the<br>&gt; use of malformed Unicode sequences is likely to be rare. To the extent that<br>&gt; they exist in the field, they are almost certainly (a) unintentional, or<br>&gt; (b) security concerns. It seems like a good thing to catch both of those<br>&gt; early to the extent that we can, and to do so while the language definition<br>&gt; remains somewhat fluid.<br>&gt;<br>&gt;<br>&gt; Thanks!<br>&gt;<br>&gt;<br>&gt; Jonathan Shapiro<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161001/51695a5a/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
