<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>SILVerifier: Should SuperMethodInst&#39;s result type be the same type as the referenced member?</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>December  9, 2015 at 06:00:00pm</p></header><div class="content"><p>[Joe, Roman, sorry for resend, I got the e-mail group wrong]<br></p><p>In SuperMethodInst&#39;s verifier, we have:<br></p><p>require(CMI-&gt;getType() == TC.getConstantType(CMI-&gt;getMember()),<br>       &quot;result type of super_method must match type of method&quot;);<br></p><p>I think this assumption was valid when we only allowed super_method on foreign classes, without needing to worry about reabstractions. Now that we&#39;re allowing super_method with operands of native class type which can be generic, does this check make sense anymore?<br></p><p>Consider the following:<br></p><p>class Parent&lt;A&gt; {<br> let x: A<br> required init(x: A) { self.x = x }<br>}<br></p><p>class Child : Parent&lt;String&gt; {<br> required init(x: String) {<br>   super.init(x: x)<br> }<br>}<br></p><p>class Grandchild : Child {}<br></p><p><br>Here, the vtable thunks for their initializers have respective types:<br></p><p>$@convention(method) &lt;T&gt; (@in T, @owned Base&lt;T&gt;) -&gt; @owned Base&lt;T&gt;<br>$@convention(method) (@in String, @owned Child) -&gt; @owned Child<br>$@convention(method) (@in String, @owned Grandchild) -&gt; @owned Grandchild<br></p><p><br>However, the real backing implementations have these respective types:<br></p><p>$@convention(method) &lt;T&gt; (@in T, @owned Base&lt;T&gt;) -&gt; @owned Base&lt;T&gt;<br>$@convention(method) (@owned String, @owned Child) -&gt; @owned Child<br>$@convention(method) (@owned String, @owned Grandchild) -&gt; @owned Grandchild<br></p><p><br>So, Child and Grandchild have abstraction differences because their initializers aren&#39;t generic. When I make a super_method instruction, the constant appears to always point to the backing implementation, not the thunk, so I needed to get the overridden vtable entry from the constant and I think that&#39;s reasonable. That gives me:<br></p><p>super_method %10 : $Child, #Base.init!initializer.1 : &lt;T&gt; Base&lt;T&gt;.Type -&gt; (x: T) -&gt; Base&lt;T&gt; , $@convention(method) &lt;τ_0_0&gt; (@in τ_0_0, @owned Base&lt;τ_0_0&gt;) -&gt; @owned Base&lt;τ_0_0&gt;<br></p><p>and<br></p><p>super_method %6 : $Grandchild, #Child.init!initializer.1 : Child.Type -&gt; (x: String) -&gt; Child , $@convention(method) (@in String, @owned Child) -&gt; @owned Child<br></p><p><br>which look good to me.<br></p><p>With my changes today to fix generic substitutions of partial super methods and getting the right type from the vtable, if I disable that verifier check, devirtualization works correctly with super_method instructions.<br></p><p>Is this a problem with SILDeclRef or is this check simply no longer valid in the verifier? If so, I wonder what the suitable replacement check should be. Maybe something like:<br></p><p>if the constant is foreign:<br> do the original check<br>else:<br> require super_method&#39;s result type == vtable entry&#39;s function type (as opposed to the backing implementation)<br></p><p>David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151209/4715c3c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>SILVerifier: Should SuperMethodInst&#39;s result type be the same type as the referenced member?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 6:09 PM, David Farler via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; [Joe, Roman, sorry for resend, I got the e-mail group wrong]<br>&gt; <br>&gt; In SuperMethodInst&#39;s verifier, we have:<br>&gt; <br>&gt; require(CMI-&gt;getType() == TC.getConstantType(CMI-&gt;getMember()),<br>&gt;        &quot;result type of super_method must match type of method&quot;);<br>&gt; <br>&gt; I think this assumption was valid when we only allowed super_method on foreign classes, without needing to worry about reabstractions. Now that we&#39;re allowing super_method with operands of native class type which can be generic, does this check make sense anymore?<br>&gt; <br>&gt; Consider the following:<br>&gt; <br>&gt; class Parent&lt;A&gt; {<br>&gt;  let x: A<br>&gt;  required init(x: A) { self.x = x }<br>&gt; }<br>&gt; <br>&gt; class Child : Parent&lt;String&gt; {<br>&gt;  required init(x: String) {<br>&gt;    super.init(x: x)<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; class Grandchild : Child {}<br>&gt; <br>&gt; <br>&gt; Here, the vtable thunks for their initializers have respective types:<br>&gt; <br>&gt; $@convention(method) &lt;T&gt; (@in T, @owned Base&lt;T&gt;) -&gt; @owned Base&lt;T&gt;<br>&gt; $@convention(method) (@in String, @owned Child) -&gt; @owned Child<br>&gt; $@convention(method) (@in String, @owned Grandchild) -&gt; @owned Grandchild<br>&gt; <br>&gt; <br>&gt; However, the real backing implementations have these respective types:<br>&gt; <br>&gt; $@convention(method) &lt;T&gt; (@in T, @owned Base&lt;T&gt;) -&gt; @owned Base&lt;T&gt;<br>&gt; $@convention(method) (@owned String, @owned Child) -&gt; @owned Child<br>&gt; $@convention(method) (@owned String, @owned Grandchild) -&gt; @owned Grandchild<br>&gt; <br>&gt; <br>&gt; So, Child and Grandchild have abstraction differences because their initializers aren&#39;t generic. When I make a super_method instruction, the constant appears to always point to the backing implementation, not the thunk, so I needed to get the overridden vtable entry from the constant and I think that&#39;s reasonable. That gives me:<br>&gt; <br>&gt; super_method %10 : $Child, #Base.init!initializer.1 : &lt;T&gt; Base&lt;T&gt;.Type -&gt; (x: T) -&gt; Base&lt;T&gt; , $@convention(method) &lt;τ_0_0&gt; (@in τ_0_0, @owned Base&lt;τ_0_0&gt;) -&gt; @owned Base&lt;τ_0_0&gt;<br>&gt; <br>&gt; and<br>&gt; <br>&gt; super_method %6 : $Grandchild, #Child.init!initializer.1 : Child.Type -&gt; (x: String) -&gt; Child , $@convention(method) (@in String, @owned Child) -&gt; @owned Child<br>&gt; <br>&gt; <br>&gt; which look good to me.<br>&gt; <br>&gt; With my changes today to fix generic substitutions of partial super methods and getting the right type from the vtable, if I disable that verifier check, devirtualization works correctly with super_method instructions.<br>&gt; <br>&gt; Is this a problem with SILDeclRef or is this check simply no longer valid in the verifier? If so, I wonder what the suitable replacement check should be. Maybe something like:<br></p><p>I’d look at the verifier for ClassMethodInst.  It turns out that TypeConverter has a getConstantOverrideType that lowers according to the overridden abstraction pattern.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151210/7a2d4776/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f7d3036e2eaf1283f20f43d62472a29f?s=50"></div><header><strong>SILVerifier: Should SuperMethodInst&#39;s result type be the same type as the referenced member?</strong> from <string>David Farler</string> &lt;dfarler at apple.com&gt;<p>December 10, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 08:16, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 6:09 PM, David Farler via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; [Joe, Roman, sorry for resend, I got the e-mail group wrong]<br>&gt;&gt; <br>&gt;&gt; In SuperMethodInst&#39;s verifier, we have:<br>&gt;&gt; <br>&gt;&gt; require(CMI-&gt;getType() == TC.getConstantType(CMI-&gt;getMember()),<br>&gt;&gt;        &quot;result type of super_method must match type of method&quot;);<br>&gt;&gt; <br>&gt;&gt; I think this assumption was valid when we only allowed super_method on foreign classes, without needing to worry about reabstractions. Now that we&#39;re allowing super_method with operands of native class type which can be generic, does this check make sense anymore?<br>&gt;&gt; <br>&gt;&gt; Consider the following:<br>&gt;&gt; <br>&gt;&gt; class Parent&lt;A&gt; {<br>&gt;&gt;  let x: A<br>&gt;&gt;  required init(x: A) { self.x = x }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Child : Parent&lt;String&gt; {<br>&gt;&gt;  required init(x: String) {<br>&gt;&gt;    super.init(x: x)<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Grandchild : Child {}<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Here, the vtable thunks for their initializers have respective types:<br>&gt;&gt; <br>&gt;&gt; $@convention(method) &lt;T&gt; (@in T, @owned Base&lt;T&gt;) -&gt; @owned Base&lt;T&gt;<br>&gt;&gt; $@convention(method) (@in String, @owned Child) -&gt; @owned Child<br>&gt;&gt; $@convention(method) (@in String, @owned Grandchild) -&gt; @owned Grandchild<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; However, the real backing implementations have these respective types:<br>&gt;&gt; <br>&gt;&gt; $@convention(method) &lt;T&gt; (@in T, @owned Base&lt;T&gt;) -&gt; @owned Base&lt;T&gt;<br>&gt;&gt; $@convention(method) (@owned String, @owned Child) -&gt; @owned Child<br>&gt;&gt; $@convention(method) (@owned String, @owned Grandchild) -&gt; @owned Grandchild<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So, Child and Grandchild have abstraction differences because their initializers aren&#39;t generic. When I make a super_method instruction, the constant appears to always point to the backing implementation, not the thunk, so I needed to get the overridden vtable entry from the constant and I think that&#39;s reasonable. That gives me:<br>&gt;&gt; <br>&gt;&gt; super_method %10 : $Child, #Base.init!initializer.1 : &lt;T&gt; Base&lt;T&gt;.Type -&gt; (x: T) -&gt; Base&lt;T&gt; , $@convention(method) &lt;τ_0_0&gt; (@in τ_0_0, @owned Base&lt;τ_0_0&gt;) -&gt; @owned Base&lt;τ_0_0&gt;<br>&gt;&gt; <br>&gt;&gt; and<br>&gt;&gt; <br>&gt;&gt; super_method %6 : $Grandchild, #Child.init!initializer.1 : Child.Type -&gt; (x: String) -&gt; Child , $@convention(method) (@in String, @owned Child) -&gt; @owned Child<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; which look good to me.<br>&gt;&gt; <br>&gt;&gt; With my changes today to fix generic substitutions of partial super methods and getting the right type from the vtable, if I disable that verifier check, devirtualization works correctly with super_method instructions.<br>&gt;&gt; <br>&gt;&gt; Is this a problem with SILDeclRef or is this check simply no longer valid in the verifier? If so, I wonder what the suitable replacement check should be. Maybe something like:<br>&gt; <br>&gt; I’d look at the verifier for ClassMethodInst.  It turns out that TypeConverter has a getConstantOverrideType that lowers according to the overridden abstraction pattern.<br>&gt; <br>&gt; John.<br></p><p>Yep, that&#39;s what I moved over to using yesterday to fix the abstraction mismatch in the devirtualizer and that&#39;s when I started getting the verifier error.  I&#39;ll take a look at the class method&#39;s verifier and see what it says. <br></p><p>David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151210/25f1440f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
