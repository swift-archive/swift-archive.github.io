<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello swift-evolutioneers,<br></p><p>Here&#39;s an idea. It&#39;s technically additive, but it&#39;s small and I think it<br>fits in well with Swift 3&#39;s goals, one of which is to establish API<br>conventions.<br></p><p>Right now, you can declare a function, type member, etc and mark it using<br>&quot;@available(*, unavailable, renamed:&quot;someNewName()&quot;)&quot;. Doing so causes a<br>compile-time error if the user tries to use that member, and if you provide<br>the new name a fix-it is even generated telling you to use the new name.<br></p><p>However, you can (and still need to) provide an implementation (e.g.<br>function body). You can just stick a fatalError() inside and be done with<br>it, but my question is, is an impl even necessary?<br></p><p>My pitch is very simple: the declaration of any member marked with<br>@available(*, unavailable), or in other words marked as unavailable<br>regardless of platform or version, should be allowed to omit the<br>implementation.<br></p><p>So, instead of:<br></p><p>@available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>public func someOldAPI() -&gt; Int { fatalError() }<br></p><p>You can just have:<br></p><p>@available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>public func someOldAPI() -&gt; Int<br></p><p>The intent is, in my opinion, clearer for the latter and it feels less<br>kludgy.<br></p><p>What do people think? Are there any potential barriers (implementation or<br>semantics) that would preclude this?<br></p><p>Best,<br>Austin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/9a7d7bcb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 10, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; So, instead of:<br>&gt; <br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt; <br>&gt; You can just have:<br>&gt; <br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int<br>&gt; <br>&gt; The intent is, in my opinion, clearer for the latter and it feels less kludgy.<br></p><p>You ask, we answer. I&#39;d much prefer spelling out { fatalError(&quot;unavailable API&quot;) }. <br>It makes the code clearer to read, to maintain, it produces debug and runtime errors. etc. I think <br>this is an example where concision is overrated.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/aac0759d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>Sorry, but I&#39;m going to have to disagree with you on this one.<br></p><p>On Fri, Jun 10, 2016 at 2:26 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; So, instead of:<br>&gt;<br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;<br>&gt; You can just have:<br>&gt;<br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int<br>&gt;<br>&gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt; kludgy.<br>&gt;<br>&gt;<br>&gt; You ask, we answer. I&#39;d much prefer spelling out {<br>&gt; fatalError(&quot;unavailable API&quot;) }.<br>&gt; It makes the code clearer to read, to maintain,<br>&gt;<br></p><p>The member is marked as &quot;unavailable&quot; in the @available annotation. I don&#39;t<br>see how adding a fatalError() in the body makes it any clearer or easier to<br>read.<br></p><p><br>&gt; it produces debug and runtime errors. etc.<br>&gt;<br></p><p>I&#39;m not sure how you can even compile code that uses an API marked as<br>&quot;unavailable&quot;, given that using such an API causes the compiler to error.<br></p><p><br>&gt; I think<br>&gt; this is an example where concision is overrated.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/c543755e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June 10, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;ve seen around the Swift source code some uses of a function named<br>something like NSUnimplemented(). I&#39;m not sure this is available only<br>inside the Swift source or if we could call it as well (I&#39;m not in<br>front of a Swift compiler right now so I cannot test).<br></p><p>The idea of being able to drop the body of the function is interesting<br>but I keep thinking of the overhead of the compiler to check for every<br>function if it can drop the requirement for a body. Perhaps keeping<br>the body is well suited here.<br></p><p>On 10 June 2016 at 18:26, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; So, instead of:<br>&gt;<br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;<br>&gt; You can just have:<br>&gt;<br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int<br>&gt;<br>&gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt; kludgy.<br>&gt;<br>&gt;<br>&gt; You ask, we answer. I&#39;d much prefer spelling out { fatalError(&quot;unavailable<br>&gt; API&quot;) }.<br>&gt; It makes the code clearer to read, to maintain, it produces debug and<br>&gt; runtime errors. etc. I think<br>&gt; this is an example where concision is overrated.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>NSUnimplemented() has nothing to do with the Swift compiler proper, and you<br>won&#39;t find it in the Swift repo. It&#39;s a marker used for the Swift<br>Foundation project to denote methods and APIs that haven&#39;t yet been<br>implemented. It has nothing to do with availability/renamed.<br></p><p>As for the overhead, I don&#39;t understand this argument either. Today, the<br>compiler already has to cross-check the use of an API against a list of<br>whether or not it&#39;s been blacklisted using &quot;unavailable&quot;. If it&#39;s<br>&quot;unavailable&quot; the compiler stops with an error and does not need to further<br>check whether a function body has been defined. As for the grammar, there<br>are already productions defined for member declarations without<br>implementations, used for constructing protocols.<br></p><p>Austin<br></p><p>On Fri, Jun 10, 2016 at 2:32 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>&gt; I&#39;ve seen around the Swift source code some uses of a function named<br>&gt; something like NSUnimplemented(). I&#39;m not sure this is available only<br>&gt; inside the Swift source or if we could call it as well (I&#39;m not in<br>&gt; front of a Swift compiler right now so I cannot test).<br>&gt;<br>&gt; The idea of being able to drop the body of the function is interesting<br>&gt; but I keep thinking of the overhead of the compiler to check for every<br>&gt; function if it can drop the requirement for a body. Perhaps keeping<br>&gt; the body is well suited here.<br>&gt;<br>&gt; On 10 June 2016 at 18:26, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; So, instead of:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt; &gt;<br>&gt; &gt; You can just have:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int<br>&gt; &gt;<br>&gt; &gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt; &gt; kludgy.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; You ask, we answer. I&#39;d much prefer spelling out {<br>&gt; fatalError(&quot;unavailable<br>&gt; &gt; API&quot;) }.<br>&gt; &gt; It makes the code clearer to read, to maintain, it produces debug and<br>&gt; &gt; runtime errors. etc. I think<br>&gt; &gt; this is an example where concision is overrated.<br>&gt; &gt;<br>&gt; &gt; -- E<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/9acfea0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need animpl</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>June 10, 2016 at 07:00:00pm</p></header><div class="content"><p>The thing with NSUnimplemented was really just a mention and nothing to do with the issue.<br></p><p>As for the real issue, the blacklist you mention is formed after parsing the source. That&#39;s how compilers usually work. The function impl is expected due to the syntax definition that is checked during the parsing phase and before that blacklist is formed. Thus one would have to flex the syntax and allow every func to not have a body and only after parsing the source check if the func had or not to have a body based on the unavailable attribute. That is unless the compiler analyses the source code while it&#39;s being parsed and I don&#39;t believe the Swift compiler does that (I haven&#39;t been that down the rabbit hole so I&#39;m not affirming). Please note that in not saying it cannot be done, only that there may be consequences.<br></p><p>L<br></p><p>-----Original Message-----<br>From: &quot;Austin Zheng&quot; &lt;austinzheng at gmail.com&gt;<br>Sent: ‎10/‎06/‎2016 06:42 PM<br>To: &quot;Leonardo Pessoa&quot; &lt;me at lmpessoa.com&gt;<br>Cc: &quot;Erica Sadun&quot; &lt;erica at ericasadun.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Pitch] &quot;unavailable&quot; members shouldn&#39;t need animpl<br></p><p>NSUnimplemented() has nothing to do with the Swift compiler proper, and you won&#39;t find it in the Swift repo. It&#39;s a marker used for the Swift Foundation project to denote methods and APIs that haven&#39;t yet been implemented. It has nothing to do with availability/renamed.<br></p><p><br>As for the overhead, I don&#39;t understand this argument either. Today, the compiler already has to cross-check the use of an API against a list of whether or not it&#39;s been blacklisted using &quot;unavailable&quot;. If it&#39;s &quot;unavailable&quot; the compiler stops with an error and does not need to further check whether a function body has been defined. As for the grammar, there are already productions defined for member declarations without implementations, used for constructing protocols.<br></p><p><br>Austin<br></p><p><br>On Fri, Jun 10, 2016 at 2:32 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>I&#39;ve seen around the Swift source code some uses of a function named<br>something like NSUnimplemented(). I&#39;m not sure this is available only<br>inside the Swift source or if we could call it as well (I&#39;m not in<br>front of a Swift compiler right now so I cannot test).<br></p><p>The idea of being able to drop the body of the function is interesting<br>but I keep thinking of the overhead of the compiler to check for every<br>function if it can drop the requirement for a body. Perhaps keeping<br>the body is well suited here.<br></p><p>On 10 June 2016 at 18:26, Erica Sadun via swift-evolution<br></p><p>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; So, instead of:<br>&gt;<br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;<br>&gt; You can just have:<br>&gt;<br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int<br>&gt;<br>&gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt; kludgy.<br>&gt;<br>&gt;<br>&gt; You ask, we answer. I&#39;d much prefer spelling out { fatalError(&quot;unavailable<br>&gt; API&quot;) }.<br>&gt; It makes the code clearer to read, to maintain, it produces debug and<br>&gt; runtime errors. etc. I think<br>&gt; this is an example where concision is overrated.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt;<br></p><p>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/72c8b870/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need animpl</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 10, 2016 at 03:00:00pm</p></header><div class="content"><p>I won&#39;t speculate more about the internals of the compiler, since (like<br>you) I haven&#39;t gone far enough into the code to know how it works in this<br>regard.<br></p><p>However, if it really is something that the current architecture can&#39;t<br>easily support, I&#39;d be happy for one of the compiler engineers to jump in<br>and nix the proposal, or for the proposal to be dismissed after five<br>minutes of deliberation when it goes up for review. Worrying about<br>implementation cost without understanding whether it would actually be a<br>problem is premature.<br></p><p>On Fri, Jun 10, 2016 at 3:03 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>&gt; The thing with NSUnimplemented was really just a mention and nothing to do<br>&gt; with the issue.<br>&gt;<br>&gt; As for the real issue, the blacklist you mention is formed after parsing<br>&gt; the source. That&#39;s how compilers usually work. The function impl is<br>&gt; expected due to the syntax definition that is checked during the parsing<br>&gt; phase and before that blacklist is formed. Thus one would have to flex the<br>&gt; syntax and allow every func to not have a body and only after parsing the<br>&gt; source check if the func had or not to have a body based on the unavailable<br>&gt; attribute. That is unless the compiler analyses the source code while it&#39;s<br>&gt; being parsed and I don&#39;t believe the Swift compiler does that (I haven&#39;t<br>&gt; been that down the rabbit hole so I&#39;m not affirming). Please note that in<br>&gt; not saying it cannot be done, only that there may be consequences.<br>&gt;<br>&gt; L<br>&gt; ------------------------------<br>&gt; From: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; Sent: ‎10/‎06/‎2016 06:42 PM<br>&gt; To: Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>&gt; Cc: Erica Sadun &lt;erica at ericasadun.com&gt;; swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] &quot;unavailable&quot; members shouldn&#39;t<br>&gt; need animpl<br>&gt;<br>&gt; NSUnimplemented() has nothing to do with the Swift compiler proper, and<br>&gt; you won&#39;t find it in the Swift repo. It&#39;s a marker used for the Swift<br>&gt; Foundation project to denote methods and APIs that haven&#39;t yet been<br>&gt; implemented. It has nothing to do with availability/renamed.<br>&gt;<br>&gt; As for the overhead, I don&#39;t understand this argument either. Today, the<br>&gt; compiler already has to cross-check the use of an API against a list of<br>&gt; whether or not it&#39;s been blacklisted using &quot;unavailable&quot;. If it&#39;s<br>&gt; &quot;unavailable&quot; the compiler stops with an error and does not need to further<br>&gt; check whether a function body has been defined. As for the grammar, there<br>&gt; are already productions defined for member declarations without<br>&gt; implementations, used for constructing protocols.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Fri, Jun 10, 2016 at 2:32 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ve seen around the Swift source code some uses of a function named<br>&gt;&gt; something like NSUnimplemented(). I&#39;m not sure this is available only<br>&gt;&gt; inside the Swift source or if we could call it as well (I&#39;m not in<br>&gt;&gt; front of a Swift compiler right now so I cannot test).<br>&gt;&gt;<br>&gt;&gt; The idea of being able to drop the body of the function is interesting<br>&gt;&gt; but I keep thinking of the overhead of the compiler to check for every<br>&gt;&gt; function if it can drop the requirement for a body. Perhaps keeping<br>&gt;&gt; the body is well suited here.<br>&gt;&gt;<br>&gt;&gt; On 10 June 2016 at 18:26, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So, instead of:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; &gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You can just have:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; &gt; public func someOldAPI() -&gt; Int<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt;&gt; &gt; kludgy.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You ask, we answer. I&#39;d much prefer spelling out {<br>&gt;&gt; fatalError(&quot;unavailable<br>&gt;&gt; &gt; API&quot;) }.<br>&gt;&gt; &gt; It makes the code clearer to read, to maintain, it produces debug and<br>&gt;&gt; &gt; runtime errors. etc. I think<br>&gt;&gt; &gt; this is an example where concision is overrated.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/10bdf5a5/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need animpl</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June 10, 2016 at 10:00:00pm</p></header><div class="content"><p>On Fri, Jun 10, 2016 at 3:03 PM Leonardo Pessoa via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The thing with NSUnimplemented was really just a mention and nothing to do<br>&gt; with the issue.<br>&gt;<br>&gt; As for the real issue, the blacklist you mention is formed after parsing<br>&gt; the source. That&#39;s how compilers usually work. The function impl is<br>&gt; expected due to the syntax definition that is checked during the parsing<br>&gt; phase and before that blacklist is formed. Thus one would have to flex the<br>&gt; syntax and allow every func to not have a body and only after parsing the<br>&gt; source check if the func had or not to have a body based on the unavailable<br>&gt; attribute. That is unless the compiler analyses the source code while it&#39;s<br>&gt; being parsed and I don&#39;t believe the Swift compiler does that (I haven&#39;t<br>&gt; been that down the rabbit hole so I&#39;m not affirming). Please note that in<br>&gt; not saying it cannot be done, only that there may be consequences.<br>&gt;<br></p><p>It seems like the whole &quot;has a body&quot; thing only really matters in the case<br>of non-Void functions, because a Void function can simply do this:<br></p><p>    @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>    public func someOldAPI() {}<br></p><p>The extra two characters (three, if you count the space), don&#39;t seem like<br>the end of the world there.<br></p><p>So, what if unavailable functions were implicitly @noreturn, since that&#39;s<br>effectively what you&#39;re doing by calling fatalError anyway? Then you could<br>write {} even for value-returning functions, and it happens at the semantic<br>analysis phase where that contextual information is available, rather than<br>at the syntactic analysis phase.<br></p><p><br></p><p>&gt;<br>&gt; L<br>&gt; ------------------------------<br>&gt; From: Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; Sent: ‎10/‎06/‎2016 06:42 PM<br>&gt; To: Leonardo Pessoa &lt;me at lmpessoa.com&gt;<br>&gt; Cc: Erica Sadun &lt;erica at ericasadun.com&gt;; swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Pitch] &quot;unavailable&quot; members shouldn&#39;t<br>&gt; need animpl<br>&gt;<br>&gt; NSUnimplemented() has nothing to do with the Swift compiler proper, and<br>&gt; you won&#39;t find it in the Swift repo. It&#39;s a marker used for the Swift<br>&gt; Foundation project to denote methods and APIs that haven&#39;t yet been<br>&gt; implemented. It has nothing to do with availability/renamed.<br>&gt;<br>&gt; As for the overhead, I don&#39;t understand this argument either. Today, the<br>&gt; compiler already has to cross-check the use of an API against a list of<br>&gt; whether or not it&#39;s been blacklisted using &quot;unavailable&quot;. If it&#39;s<br>&gt; &quot;unavailable&quot; the compiler stops with an error and does not need to further<br>&gt; check whether a function body has been defined. As for the grammar, there<br>&gt; are already productions defined for member declarations without<br>&gt; implementations, used for constructing protocols.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Fri, Jun 10, 2016 at 2:32 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt;&gt; I&#39;ve seen around the Swift source code some uses of a function named<br>&gt;&gt; something like NSUnimplemented(). I&#39;m not sure this is available only<br>&gt;&gt; inside the Swift source or if we could call it as well (I&#39;m not in<br>&gt;&gt; front of a Swift compiler right now so I cannot test).<br>&gt;&gt;<br>&gt;&gt; The idea of being able to drop the body of the function is interesting<br>&gt;&gt; but I keep thinking of the overhead of the compiler to check for every<br>&gt;&gt; function if it can drop the requirement for a body. Perhaps keeping<br>&gt;&gt; the body is well suited here.<br>&gt;&gt;<br>&gt;&gt; On 10 June 2016 at 18:26, Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; So, instead of:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; &gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You can just have:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; &gt; public func someOldAPI() -&gt; Int<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt;&gt; &gt; kludgy.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; You ask, we answer. I&#39;d much prefer spelling out {<br>&gt;&gt; fatalError(&quot;unavailable<br>&gt;&gt; &gt; API&quot;) }.<br>&gt;&gt; &gt; It makes the code clearer to read, to maintain, it produces debug and<br>&gt;&gt; &gt; runtime errors. etc. I think<br>&gt;&gt; &gt; this is an example where concision is overrated.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -- E<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/571f8763/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8e77369a540cf4d35924683e176c7a9c?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Mark Lacey</string> &lt;mark.lacey at apple.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 10, 2016, at 2:32 PM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve seen around the Swift source code some uses of a function named<br>&gt; something like NSUnimplemented(). I&#39;m not sure this is available only<br>&gt; inside the Swift source or if we could call it as well (I&#39;m not in<br>&gt; front of a Swift compiler right now so I cannot test).<br></p><p>You might be thinking of Builtin.unreachable(). I recently replaced the bodies of all the stdlib functions that are completely unavailable with calls to Builtin.unreachable(), which generates a trap instruction (as opposed to having bodies with calls to fatalError that take static strings, which generate more code/data).<br></p><p>&gt; The idea of being able to drop the body of the function is interesting<br>&gt; but I keep thinking of the overhead of the compiler to check for every<br>&gt; function if it can drop the requirement for a body. Perhaps keeping<br>&gt; the body is well suited here.<br></p><p>Personally I think it would be nice if you could omit the body of any function (through some special syntax) with the intent that you’d get a warning for these when compiling and that they would trap if ever called. It can be handy to be able to do that while prototyping, e.g. as you’re trying to figure out the design of the types you want to implement, etc. I don’t consider this critical though, as it’s usually not too hard to write a placeholder body that constructs and returns some kind of dummy return value.<br></p><p>Mark<br></p><p>&gt; <br>&gt; On 10 June 2016 at 18:26, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On Jun 10, 2016, at 3:22 PM, Austin Zheng via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; So, instead of:<br>&gt;&gt; <br>&gt;&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;&gt; <br>&gt;&gt; You can just have:<br>&gt;&gt; <br>&gt;&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; public func someOldAPI() -&gt; Int<br>&gt;&gt; <br>&gt;&gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt;&gt; kludgy.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You ask, we answer. I&#39;d much prefer spelling out { fatalError(&quot;unavailable<br>&gt;&gt; API&quot;) }.<br>&gt;&gt; It makes the code clearer to read, to maintain, it produces debug and<br>&gt;&gt; runtime errors. etc. I think<br>&gt;&gt; this is an example where concision is overrated.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 10, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; However, you can (and still need to) provide an implementation (e.g. function body). You can just stick a fatalError() inside and be done with it, but my question is, is an impl even necessary?<br></p><p>Personally, I always figured the best thing to do was to call through to the new API. We don&#39;t have library resilience yet, but I&#39;m assuming that&#39;s what you&#39;ll have to do in resilient code when you want to retire an API, just in case you get loaded by something compiled against an old version.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 10, 2016, at 2:22 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello swift-evolutioneers,<br>&gt; <br>&gt; Here&#39;s an idea. It&#39;s technically additive, but it&#39;s small and I think it fits in well with Swift 3&#39;s goals, one of which is to establish API conventions.<br>&gt; <br>&gt; Right now, you can declare a function, type member, etc and mark it using &quot;@available(*, unavailable, renamed:&quot;someNewName()&quot;)&quot;. Doing so causes a compile-time error if the user tries to use that member, and if you provide the new name a fix-it is even generated telling you to use the new name.<br>&gt; <br>&gt; However, you can (and still need to) provide an implementation (e.g. function body). You can just stick a fatalError() inside and be done with it, but my question is, is an impl even necessary?<br>&gt; <br>&gt; My pitch is very simple: the declaration of any member marked with @available(*, unavailable), or in other words marked as unavailable regardless of platform or version, should be allowed to omit the implementation.<br>&gt; <br>&gt; So, instead of:<br>&gt; <br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt; <br>&gt; You can just have:<br>&gt; <br>&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; public func someOldAPI() -&gt; Int<br>&gt; <br>&gt; The intent is, in my opinion, clearer for the latter and it feels less kludgy.<br>&gt; <br>&gt; What do people think? Are there any potential barriers (implementation or semantics) that would preclude this?<br></p><p>I actually just consider it a bug that you&#39;re require to implement an always-unavailable function.  We can take it through evolution anyway, though.<br></p><p>John.<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June 11, 2016 at 11:00:00am</p></header><div class="content"><p>Unavailable doesn&#39;t mean un-callable.<br></p><p>   - If you&#39;re marking an override or required initialiser as unavailable,<br>   it&#39;s still possible it&#39;s called dynamically, or by super.<br>   - If you&#39;re marking it unavailable for some OS versions, it could still<br>   be called by the other OS versions.<br>   - If it&#39;s neither of those two categories, you probably don&#39;t even need<br>   the function declaration.<br></p><p>It&#39;s not clear what default behaviour you would want in an unavailable<br>method, calling super, calling a new method, a runtime error, ...<br></p><p>An undefined implementation lacks clarity, as Erica says, &quot;this is an<br>example where concision is overrated&quot;.<br></p><p>Likewise, as Brent says, you may want the old unavailable API to call<br>through to the new API.  A new version of a library may be dynamically<br>linked by something compiled against an older version.<br></p><p><br>On Sat, Jun 11, 2016 at 10:47 AM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Jun 10, 2016, at 2:22 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello swift-evolutioneers,<br>&gt; &gt;<br>&gt; &gt; Here&#39;s an idea. It&#39;s technically additive, but it&#39;s small and I think it<br>&gt; fits in well with Swift 3&#39;s goals, one of which is to establish API<br>&gt; conventions.<br>&gt; &gt;<br>&gt; &gt; Right now, you can declare a function, type member, etc and mark it<br>&gt; using &quot;@available(*, unavailable, renamed:&quot;someNewName()&quot;)&quot;. Doing so<br>&gt; causes a compile-time error if the user tries to use that member, and if<br>&gt; you provide the new name a fix-it is even generated telling you to use the<br>&gt; new name.<br>&gt; &gt;<br>&gt; &gt; However, you can (and still need to) provide an implementation (e.g.<br>&gt; function body). You can just stick a fatalError() inside and be done with<br>&gt; it, but my question is, is an impl even necessary?<br>&gt; &gt;<br>&gt; &gt; My pitch is very simple: the declaration of any member marked with<br>&gt; @available(*, unavailable), or in other words marked as unavailable<br>&gt; regardless of platform or version, should be allowed to omit the<br>&gt; implementation.<br>&gt; &gt;<br>&gt; &gt; So, instead of:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt; &gt;<br>&gt; &gt; You can just have:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int<br>&gt; &gt;<br>&gt; &gt; The intent is, in my opinion, clearer for the latter and it feels less<br>&gt; kludgy.<br>&gt; &gt;<br>&gt; &gt; What do people think? Are there any potential barriers (implementation<br>&gt; or semantics) that would preclude this?<br>&gt;<br>&gt; I actually just consider it a bug that you&#39;re require to implement an<br>&gt; always-unavailable function.  We can take it through evolution anyway,<br>&gt; though.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160611/5c3a3161/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 10, 2016 at 07:00:00pm</p></header><div class="content"><p>All I want, and all @available(*, unavailable, renamed:) gives me, is the ability to give my users a more pleasant upgrade experience than simply working through whatever errors Xcode spits out and trying to figure out what old APIs correspond with what new APIs.<br></p><p>If resilience is an issue...a library author can always simply choose to remove the old APIs altogether and break compatibility with older consumers. There is nothing Swift currently does to prevent this from happening, nor should it. If the library author wishes to forward use of unavailable APIs to their not-unavailable counterparts, that&#39;s their prerogative. There are a couple of other folks who are working on a resilience story for Swift (including things like versioning checks); until they have something to show us I don&#39;t see the point of worrying about maintaining resilience that Swift doesn&#39;t promise consumers of libraries to begin with.<br></p><p>Austin<br></p><p>&gt; On Jun 10, 2016, at 6:51 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Unavailable doesn&#39;t mean un-callable.<br>&gt; If you&#39;re marking an override or required initialiser as unavailable, it&#39;s still possible it&#39;s called dynamically, or by super.<br>&gt; If you&#39;re marking it unavailable for some OS versions, it could still be called by the other OS versions.<br>&gt; If it&#39;s neither of those two categories, you probably don&#39;t even need the function declaration.<br>&gt; It&#39;s not clear what default behaviour you would want in an unavailable method, calling super, calling a new method, a runtime error, ...<br>&gt; <br>&gt; An undefined implementation lacks clarity, as Erica says, &quot;this is an example where concision is overrated&quot;.<br>&gt; <br>&gt; Likewise, as Brent says, you may want the old unavailable API to call through to the new API.  A new version of a library may be dynamically linked by something compiled against an older version.<br>&gt; <br>&gt; <br>&gt; On Sat, Jun 11, 2016 at 10:47 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; On Jun 10, 2016, at 2:22 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello swift-evolutioneers,<br>&gt; &gt;<br>&gt; &gt; Here&#39;s an idea. It&#39;s technically additive, but it&#39;s small and I think it fits in well with Swift 3&#39;s goals, one of which is to establish API conventions.<br>&gt; &gt;<br>&gt; &gt; Right now, you can declare a function, type member, etc and mark it using &quot;@available(*, unavailable, renamed:&quot;someNewName()&quot;)&quot;. Doing so causes a compile-time error if the user tries to use that member, and if you provide the new name a fix-it is even generated telling you to use the new name.<br>&gt; &gt;<br>&gt; &gt; However, you can (and still need to) provide an implementation (e.g. function body). You can just stick a fatalError() inside and be done with it, but my question is, is an impl even necessary?<br>&gt; &gt;<br>&gt; &gt; My pitch is very simple: the declaration of any member marked with @available(*, unavailable), or in other words marked as unavailable regardless of platform or version, should be allowed to omit the implementation.<br>&gt; &gt;<br>&gt; &gt; So, instead of:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt; &gt;<br>&gt; &gt; You can just have:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int<br>&gt; &gt;<br>&gt; &gt; The intent is, in my opinion, clearer for the latter and it feels less kludgy.<br>&gt; &gt;<br>&gt; &gt; What do people think? Are there any potential barriers (implementation or semantics) that would preclude this?<br>&gt; <br>&gt; I actually just consider it a bug that you&#39;re require to implement an always-unavailable function.  We can take it through evolution anyway, though.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160610/3293b718/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 13, 2016 at 06:00:00am</p></header><div class="content"><p>As Andrew says - I have several cases where I mark a method on a subclass as unavailable to ensure subclasses do not call it directly, but it is required by the root class to be implemented (which it is and gets called).<br></p><p>Example:<br></p><p>class Root {<br>	func doSomething() {<br>		print(&quot;Root&quot;)<br>	}<br>}<br></p><p>class Subclass {<br>	@available(*, unavailable)<br>	override func doSomething() {<br>		super.doSomething()<br>		print(&quot;Subclass&quot;)<br>	}	<br>}<br></p><p>And you can still do:<br></p><p>let instance: Root = Subclass()<br>instance.doSomething()<br></p><p>and it will call Root Subclass.<br></p><p>If it&#39;s renamed, you should really first deprecate it and just call the new API and after a while make it unavailable with no change in the code.<br></p><p>If it&#39;s meant for abstract classes, then it&#39;s kind of a different issue.<br></p><p><br></p><p>&gt; On Jun 11, 2016, at 3:51 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Unavailable doesn&#39;t mean un-callable.<br>&gt; If you&#39;re marking an override or required initialiser as unavailable, it&#39;s still possible it&#39;s called dynamically, or by super.<br>&gt; If you&#39;re marking it unavailable for some OS versions, it could still be called by the other OS versions.<br>&gt; If it&#39;s neither of those two categories, you probably don&#39;t even need the function declaration.<br>&gt; It&#39;s not clear what default behaviour you would want in an unavailable method, calling super, calling a new method, a runtime error, ...<br>&gt; <br>&gt; An undefined implementation lacks clarity, as Erica says, &quot;this is an example where concision is overrated&quot;.<br>&gt; <br>&gt; Likewise, as Brent says, you may want the old unavailable API to call through to the new API.  A new version of a library may be dynamically linked by something compiled against an older version.<br>&gt; <br>&gt; <br>&gt; On Sat, Jun 11, 2016 at 10:47 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; On Jun 10, 2016, at 2:22 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello swift-evolutioneers,<br>&gt; &gt;<br>&gt; &gt; Here&#39;s an idea. It&#39;s technically additive, but it&#39;s small and I think it fits in well with Swift 3&#39;s goals, one of which is to establish API conventions.<br>&gt; &gt;<br>&gt; &gt; Right now, you can declare a function, type member, etc and mark it using &quot;@available(*, unavailable, renamed:&quot;someNewName()&quot;)&quot;. Doing so causes a compile-time error if the user tries to use that member, and if you provide the new name a fix-it is even generated telling you to use the new name.<br>&gt; &gt;<br>&gt; &gt; However, you can (and still need to) provide an implementation (e.g. function body). You can just stick a fatalError() inside and be done with it, but my question is, is an impl even necessary?<br>&gt; &gt;<br>&gt; &gt; My pitch is very simple: the declaration of any member marked with @available(*, unavailable), or in other words marked as unavailable regardless of platform or version, should be allowed to omit the implementation.<br>&gt; &gt;<br>&gt; &gt; So, instead of:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt; &gt;<br>&gt; &gt; You can just have:<br>&gt; &gt;<br>&gt; &gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt; &gt; public func someOldAPI() -&gt; Int<br>&gt; &gt;<br>&gt; &gt; The intent is, in my opinion, clearer for the latter and it feels less kludgy.<br>&gt; &gt;<br>&gt; &gt; What do people think? Are there any potential barriers (implementation or semantics) that would preclude this?<br>&gt; <br>&gt; I actually just consider it a bug that you&#39;re require to implement an always-unavailable function.  We can take it through evolution anyway, though.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/0058db87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>June 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 12, 2016, at 9:08 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; On Jun 11, 2016, at 3:51 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unavailable doesn&#39;t mean un-callable.<br>&gt;&gt; If you&#39;re marking an override or required initialiser as unavailable, it&#39;s still possible it&#39;s called dynamically, or by super.<br>&gt;&gt; If you&#39;re marking it unavailable for some OS versions, it could still be called by the other OS versions.<br>&gt;&gt; If it&#39;s neither of those two categories, you probably don&#39;t even need the function declaration.<br>&gt;&gt; It&#39;s not clear what default behaviour you would want in an unavailable method, calling super, calling a new method, a runtime error, ...<br>&gt;&gt; <br>&gt;&gt; An undefined implementation lacks clarity, as Erica says, &quot;this is an example where concision is overrated&quot;.<br>&gt;&gt; <br>&gt;&gt; Likewise, as Brent says, you may want the old unavailable API to call through to the new API.  A new version of a library may be dynamically linked by something compiled against an older version.<br></p><p>&gt; As Andrew says - I have several cases where I mark a method on a subclass as unavailable to ensure subclasses do not call it directly, but it is required by the root class to be implemented (which it is and gets called).<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; class Root {<br>&gt; 	func doSomething() {<br>&gt; 		print(&quot;Root&quot;)<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; class Subclass {<br>&gt; 	@available(*, unavailable)<br>&gt; 	override func doSomething() {<br>&gt; 		super.doSomething()<br>&gt; 		print(&quot;Subclass&quot;)<br>&gt; 	}	<br>&gt; }<br>&gt; <br>&gt; And you can still do:<br>&gt; <br>&gt; let instance: Root = Subclass()<br>&gt; instance.doSomething()<br>&gt; <br>&gt; and it will call Root Subclass.<br>&gt; <br>&gt; If it&#39;s renamed, you should really first deprecate it and just call the new API and after a while make it unavailable with no change in the code.<br>&gt; <br>&gt; If it&#39;s meant for abstract classes, then it&#39;s kind of a different issue.<br></p><p>In many of the cases you guys are describing, we ought to have enough information to do the right thing.  For example, library evolution shouldn&#39;t be done with an ordinary unavailable attribute; it should use something that indicates that the API was added in v2.6c, deprecated in v2.7, and made illegal in v2.8.  With that information, we clearly would still require a function body if the build configuration says that we need to support pre-v2.8 clients.<br></p><p>My point was just that there is a clear use case for an attribute that says &quot;don&#39;t allow this declaration to be used at all&quot;, including indirectly such as via a protocol requirement or overridden method, and those use cases should not require an actual function body.  I recognize that there are also use cases for a more relaxed attribute that just prohibits direct uses but still requires a function body.  Perhaps that should just be a completely different attribute, or perhaps we can differentiate based on the attribute arguments, or perhaps we can address all of those use cases with targeted language features.  However, we should still get to a point where we don&#39;t require function bodies for the true-unavailable cases.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160614/e3e4286a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Pitch] &quot;unavailable&quot; members shouldn&#39;t need an impl</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 10, 2016, at 5:47 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 10, 2016, at 2:22 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello swift-evolutioneers,<br>&gt;&gt; <br>&gt;&gt; Here&#39;s an idea. It&#39;s technically additive, but it&#39;s small and I think it fits in well with Swift 3&#39;s goals, one of which is to establish API conventions.<br>&gt;&gt; <br>&gt;&gt; Right now, you can declare a function, type member, etc and mark it using &quot;@available(*, unavailable, renamed:&quot;someNewName()&quot;)&quot;. Doing so causes a compile-time error if the user tries to use that member, and if you provide the new name a fix-it is even generated telling you to use the new name.<br>&gt;&gt; <br>&gt;&gt; However, you can (and still need to) provide an implementation (e.g. function body). You can just stick a fatalError() inside and be done with it, but my question is, is an impl even necessary?<br>&gt;&gt; <br>&gt;&gt; My pitch is very simple: the declaration of any member marked with @available(*, unavailable), or in other words marked as unavailable regardless of platform or version, should be allowed to omit the implementation.<br>&gt;&gt; <br>&gt;&gt; So, instead of:<br>&gt;&gt; <br>&gt;&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; public func someOldAPI() -&gt; Int { fatalError() }<br>&gt;&gt; <br>&gt;&gt; You can just have:<br>&gt;&gt; <br>&gt;&gt; @available(*, unavailable, renamed:&quot;someNewAPI()&quot;)<br>&gt;&gt; public func someOldAPI() -&gt; Int<br>&gt;&gt; <br>&gt;&gt; The intent is, in my opinion, clearer for the latter and it feels less kludgy.<br>&gt;&gt; <br>&gt;&gt; What do people think? Are there any potential barriers (implementation or semantics) that would preclude this?<br>&gt; <br>&gt; I actually just consider it a bug that you&#39;re require to implement an always-unavailable function.  We can take it through evolution anyway, though.<br></p><p>I agree with John on both parts: it’s a bug, but considering it in evolution makes sense.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
