<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ddfdaf0f44f9f985f1de1b27edc06ae9?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Vester Gottfried</string> &lt;vester.gottfried at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>Some class based libraries/frameworks expect the consumer to subclass<br>certain classes and override specific method and require that the super<br>implementation of an overridden method is being called.<br></p><p>Not calling the super implementation is a common source of bugs that may be<br>prevented if the compiler checks if super is called, like it does in some<br>cases of init().<br></p><p>Example:<br></p><p>class Box {<br>   @requires_super<br>    func addStuff() { ... }<br>}<br></p><p>Overriding class Box&#39;s addStuff without calling super.addStuff() should<br>result in an error<br></p><p>class Chest : Box {<br>    override addStuff() {<br>         // ERROR: addStuff() requires call to super.addStuff()<br>        ...<br>    }<br>}<br></p><p>Objective-C developers know this as NS_REQUIRES_SUPER and I think its worth<br>thinking about adapting it.<br></p><p>I hope my proposal was clear and thanks for reading,<br></p><p>Gottfried<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/7d9e7b3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>+1 to this.  Anything that helps ensure inheritance is thought through carefully and used correctly is a win.<br></p><p>&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some class based libraries/frameworks expect the consumer to subclass certain classes and override specific method and require that the super implementation of an overridden method is being called.<br>&gt; <br>&gt; Not calling the super implementation is a common source of bugs that may be prevented if the compiler checks if super is called, like it does in some cases of init().<br>&gt; <br>&gt; Example:<br>&gt; <br>&gt; class Box {<br>&gt;    @requires_super<br>&gt;     func addStuff() { ... }<br>&gt; }<br>&gt; <br>&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should result in an error<br>&gt; <br>&gt; class Chest : Box {<br>&gt;     override addStuff() {<br>&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its worth thinking about adapting it.<br>&gt; <br>&gt; I hope my proposal was clear and thanks for reading,<br>&gt; <br>&gt; Gottfried<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/3c10b76d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>+1 always had such issues with UIViewController&#39;s lifecycle methods.<br></p><p>But edge cases need to be considered like &quot;throws&quot; for example.<br>Do I need to call super before I throw something?<br></p><p>On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 to this.  Anything that helps ensure inheritance is thought through<br>&gt; carefully and used correctly is a win.<br>&gt;<br>&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Some class based libraries/frameworks expect the consumer to subclass<br>&gt; certain classes and override specific method and require that the super<br>&gt; implementation of an overridden method is being called.<br>&gt;<br>&gt; Not calling the super implementation is a common source of bugs that may<br>&gt; be prevented if the compiler checks if super is called, like it does in<br>&gt; some cases of init().<br>&gt;<br>&gt; Example:<br>&gt;<br>&gt; class Box {<br>&gt;    @requires_super<br>&gt;     func addStuff() { ... }<br>&gt; }<br>&gt;<br>&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should<br>&gt; result in an error<br>&gt;<br>&gt; class Chest : Box {<br>&gt;     override addStuff() {<br>&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;         ...<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its<br>&gt; worth thinking about adapting it.<br>&gt;<br>&gt; I hope my proposal was clear and thanks for reading,<br>&gt;<br>&gt; Gottfried<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/affeb3f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ddfdaf0f44f9f985f1de1b27edc06ae9?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Vester Gottfried</string> &lt;vester.gottfried at gmail.com&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>I would suggest that @requires_super only checks if a call to super is<br>present at all. More detailed behaviour should be part of the functions<br>documentation, because I think all possibilities cannot be checked easily<br>by the compiler. For example a call to super my be required to happen early<br>or late inside the function. But when too early or too late is can probably<br>not been forseen by the compiler.<br></p><p>On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;<br>&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt; Do I need to call super before I throw something?<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought through<br>&gt;&gt; carefully and used correctly is a win.<br>&gt;&gt;<br>&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass<br>&gt;&gt; certain classes and override specific method and require that the super<br>&gt;&gt; implementation of an overridden method is being called.<br>&gt;&gt;<br>&gt;&gt; Not calling the super implementation is a common source of bugs that may<br>&gt;&gt; be prevented if the compiler checks if super is called, like it does in<br>&gt;&gt; some cases of init().<br>&gt;&gt;<br>&gt;&gt; Example:<br>&gt;&gt;<br>&gt;&gt; class Box {<br>&gt;&gt;    @requires_super<br>&gt;&gt;     func addStuff() { ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should<br>&gt;&gt; result in an error<br>&gt;&gt;<br>&gt;&gt; class Chest : Box {<br>&gt;&gt;     override addStuff() {<br>&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its<br>&gt;&gt; worth thinking about adapting it.<br>&gt;&gt;<br>&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;<br>&gt;&gt; Gottfried<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/b51e2e24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>Sounds reasonable since even the best flow analysis cannot ensure that all<br>codepaths call the super implementation.<br></p><p>Some more edge cases:<br></p><p>   - Calling super asynchronously by using it in a closure<br>   - Referring to the super implementation by assign it to a variable and<br>   call it later (is that really possible? never did that)<br></p><p><br>On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>vester.gottfried at gmail.com&gt; wrote:<br></p><p>&gt; I would suggest that @requires_super only checks if a call to super is<br>&gt; present at all. More detailed behaviour should be part of the functions<br>&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt; by the compiler. For example a call to super my be required to happen early<br>&gt; or late inside the function. But when too early or too late is can probably<br>&gt; not been forseen by the compiler.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;<br>&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought through<br>&gt;&gt;&gt; carefully and used correctly is a win.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass<br>&gt;&gt;&gt; certain classes and override specific method and require that the super<br>&gt;&gt;&gt; implementation of an overridden method is being called.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that may<br>&gt;&gt;&gt; be prevented if the compiler checks if super is called, like it does in<br>&gt;&gt;&gt; some cases of init().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should<br>&gt;&gt;&gt; result in an error<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its<br>&gt;&gt;&gt; worth thinking about adapting it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/3831e621/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>Calling super asynchronously would not meet an @requires_super specification IMO.  I would interpret it to mean you must call super before returning.<br></p><p>The compiler already guarantees all code paths return and guarantees subclass initializers call super.  I don&#39;t think a sensible definition of @requires_super would be any more complex than that. <br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 16, 2015, at 11:49 AM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt; <br>&gt; Sounds reasonable since even the best flow analysis cannot ensure that all codepaths call the super implementation.<br>&gt; <br>&gt; Some more edge cases:<br>&gt; Calling super asynchronously by using it in a closure<br>&gt; Referring to the super implementation by assign it to a variable and call it later (is that really possible? never did that)<br>&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt; I would suggest that @requires_super only checks if a call to super is present at all. More detailed behaviour should be part of the functions documentation, because I think all possibilities cannot be checked easily by the compiler. For example a call to super my be required to happen early or late inside the function. But when too early or too late is can probably not been forseen by the compiler.<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass certain classes and override specific method and require that the super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that may be prevented if the compiler checks if super is called, like it does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should result in an error<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/570ceed9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>+1 from me. FWIW, the Objective-C one is syntactic.<br></p><p>Information from Radar: the request for this is rdar://problem/17408107 (plus a few duplicates). One of the dups suggests a variation where a subclass method can be declared as &quot;refine&quot; instead of &quot;override&quot; so that you can document that your own method is expected to call super. In this model, &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough, especially since we wouldn&#39;t be publishing refine-vs-override in a library&#39;s public interface.<br></p><p>Jordan<br></p><p>&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sounds reasonable since even the best flow analysis cannot ensure that all codepaths call the super implementation.<br>&gt; <br>&gt; Some more edge cases:<br>&gt; Calling super asynchronously by using it in a closure<br>&gt; Referring to the super implementation by assign it to a variable and call it later (is that really possible? never did that)<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;vester.gottfried at gmail.com &lt;mailto:vester.gottfried at gmail.com&gt;&gt; wrote:<br>&gt; I would suggest that @requires_super only checks if a call to super is present at all. More detailed behaviour should be part of the functions documentation, because I think all possibilities cannot be checked easily by the compiler. For example a call to super my be required to happen early or late inside the function. But when too early or too late is can probably not been forseen by the compiler.<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt; <br>&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt; Do I need to call super before I throw something?<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1 to this.  Anything that helps ensure inheritance is thought through carefully and used correctly is a win.<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass certain classes and override specific method and require that the super implementation of an overridden method is being called.<br>&gt;&gt; <br>&gt;&gt; Not calling the super implementation is a common source of bugs that may be prevented if the compiler checks if super is called, like it does in some cases of init().<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; class Box {<br>&gt;&gt;    @requires_super<br>&gt;&gt;     func addStuff() { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should result in an error<br>&gt;&gt; <br>&gt;&gt; class Chest : Box {<br>&gt;&gt;     override addStuff() {<br>&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its worth thinking about adapting it.<br>&gt;&gt; <br>&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt; <br>&gt;&gt; Gottfried<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/769aed4b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>What about re-using the &quot;required&quot; keyword in the superclass which already<br>means something similar for initializers?<br>Subclass implementations are required to call super&#39;s implementation.<br>If a subclass doesn&#39;t implemented the required method it could mean that it<br>inherits the behavior from the superclass - just like initializers can be<br>inherited too.<br></p><p>On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;<br>&gt; Information from Radar: the request for this is rdar://problem/17408107<br>&gt; (plus a few duplicates). One of the dups suggests a variation where a<br>&gt; subclass method can be declared as &quot;refine&quot; instead of &quot;override&quot; so that<br>&gt; you can document that your *own* method is expected to call super. In<br>&gt; this model, &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I<br>&gt; personally think this doesn&#39;t add enough, especially since we wouldn&#39;t be<br>&gt; publishing refine-vs-override in a library&#39;s public interface.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Sounds reasonable since even the best flow analysis cannot ensure that all<br>&gt; codepaths call the super implementation.<br>&gt;<br>&gt; Some more edge cases:<br>&gt;<br>&gt;    - Calling super asynchronously by using it in a closure<br>&gt;    - Referring to the super implementation by assign it to a variable and<br>&gt;    call it later (is that really possible? never did that)<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I would suggest that @requires_super only checks if a call to super is<br>&gt;&gt; present at all. More detailed behaviour should be part of the functions<br>&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought through<br>&gt;&gt;&gt;&gt; carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass<br>&gt;&gt;&gt;&gt; certain classes and override specific method and require that the super<br>&gt;&gt;&gt;&gt; implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that<br>&gt;&gt;&gt;&gt; may be prevented if the compiler checks if super is called, like it does in<br>&gt;&gt;&gt;&gt; some cases of init().<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should<br>&gt;&gt;&gt;&gt; result in an error<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its<br>&gt;&gt;&gt;&gt; worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e03d3db3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ddfdaf0f44f9f985f1de1b27edc06ae9?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Vester Gottfried</string> &lt;vester.gottfried at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>I think reusing required would send the wrong message. Required would mean<br>for me something like NSOperation subclasses maybe require to have a main()<br>function, but that doesn&#39;t mean you have to call super. On the contrary,<br>the documentation of NSOperation main() explicitly states not to call<br>super.<br></p><p>On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; What about re-using the &quot;required&quot; keyword in the superclass which already<br>&gt; means something similar for initializers?<br>&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt; If a subclass doesn&#39;t implemented the required method it could mean that<br>&gt; it inherits the behavior from the superclass - just like initializers can<br>&gt; be inherited too.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;<br>&gt;&gt; Information from Radar: the request for this is rdar://problem/17408107<br>&gt;&gt; (plus a few duplicates). One of the dups suggests a variation where a<br>&gt;&gt; subclass method can be declared as &quot;refine&quot; instead of &quot;override&quot; so that<br>&gt;&gt; you can document that your *own* method is expected to call super. In<br>&gt;&gt; this model, &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I<br>&gt;&gt; personally think this doesn&#39;t add enough, especially since we wouldn&#39;t be<br>&gt;&gt; publishing refine-vs-override in a library&#39;s public interface.<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure that<br>&gt;&gt; all codepaths call the super implementation.<br>&gt;&gt;<br>&gt;&gt; Some more edge cases:<br>&gt;&gt;<br>&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;    - Referring to the super implementation by assign it to a variable<br>&gt;&gt;    and call it later (is that really possible? never did that)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to super is<br>&gt;&gt;&gt; present at all. More detailed behaviour should be part of the functions<br>&gt;&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought through<br>&gt;&gt;&gt;&gt;&gt; carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass<br>&gt;&gt;&gt;&gt;&gt; certain classes and override specific method and require that the super<br>&gt;&gt;&gt;&gt;&gt; implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that<br>&gt;&gt;&gt;&gt;&gt; may be prevented if the compiler checks if super is called, like it does in<br>&gt;&gt;&gt;&gt;&gt; some cases of init().<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its<br>&gt;&gt;&gt;&gt;&gt; worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/af05c37d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>&quot;required&quot; also doesn&#39;t mean that a subclass has to implement the required<br>initializer since it can be inherited.<br>Your example is an abstract function which should have it&#39;s own keyword (if<br>we ever get abstract functions).<br></p><p>On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>vester.gottfried at gmail.com&gt; wrote:<br></p><p>&gt; I think reusing required would send the wrong message. Required would mean<br>&gt; for me something like NSOperation subclasses maybe require to have a main()<br>&gt; function, but that doesn&#39;t mean you have to call super. On the contrary,<br>&gt; the documentation of NSOperation main() explicitly states not to call<br>&gt; super.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt; already means something similar for initializers?<br>&gt;&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean that<br>&gt;&gt; it inherits the behavior from the superclass - just like initializers can<br>&gt;&gt; be inherited too.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Information from Radar: the request for this is rdar://problem/17408107<br>&gt;&gt;&gt; (plus a few duplicates). One of the dups suggests a variation where a<br>&gt;&gt;&gt; subclass method can be declared as &quot;refine&quot; instead of &quot;override&quot; so that<br>&gt;&gt;&gt; you can document that your *own* method is expected to call super. In<br>&gt;&gt;&gt; this model, &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I<br>&gt;&gt;&gt; personally think this doesn&#39;t add enough, especially since we wouldn&#39;t be<br>&gt;&gt;&gt; publishing refine-vs-override in a library&#39;s public interface.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure that<br>&gt;&gt;&gt; all codepaths call the super implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;    - Referring to the super implementation by assign it to a variable<br>&gt;&gt;&gt;    and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to super is<br>&gt;&gt;&gt;&gt; present at all. More detailed behaviour should be part of the functions<br>&gt;&gt;&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt;&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt;&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt;&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass<br>&gt;&gt;&gt;&gt;&gt;&gt; certain classes and override specific method and require that the super<br>&gt;&gt;&gt;&gt;&gt;&gt; implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that<br>&gt;&gt;&gt;&gt;&gt;&gt; may be prevented if the compiler checks if super is called, like it does in<br>&gt;&gt;&gt;&gt;&gt;&gt; some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its<br>&gt;&gt;&gt;&gt;&gt;&gt; worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/4b00b8b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>December 16, 2015 at 06:00:00pm</p></header><div class="content"><p>+1 for this if for nothing else but UIKit classes yelling at me to call<br>super.viewDidLoad().<br></p><p>I think using the required keyword makes sense. The one possible caveat is<br>overloading, as my knee jerk reaction is that methods of the same name<br>would behave like initializers. So a method overriding a required method<br>would have to call a required method of the same name on the superclass if<br>one exists. I&#39;m not convinced that&#39;s correct, though.<br></p><p>On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the required<br>&gt; initializer since it can be inherited.<br>&gt; Your example is an abstract function which should have it&#39;s own keyword<br>&gt; (if we ever get abstract functions).<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; I think reusing required would send the wrong message. Required would<br>&gt;&gt; mean for me something like NSOperation subclasses maybe require to have a<br>&gt;&gt; main() function, but that doesn&#39;t mean you have to call super. On the<br>&gt;&gt; contrary, the documentation of NSOperation main() explicitly states not to<br>&gt;&gt; call super.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean that<br>&gt;&gt;&gt; it inherits the behavior from the superclass - just like initializers can<br>&gt;&gt;&gt; be inherited too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Information from Radar: the request for this is rdar://problem/17408107<br>&gt;&gt;&gt;&gt; (plus a few duplicates). One of the dups suggests a variation where a<br>&gt;&gt;&gt;&gt; subclass method can be declared as &quot;refine&quot; instead of &quot;override&quot; so that<br>&gt;&gt;&gt;&gt; you can document that your *own* method is expected to call super. In<br>&gt;&gt;&gt;&gt; this model, &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I<br>&gt;&gt;&gt;&gt; personally think this doesn&#39;t add enough, especially since we wouldn&#39;t be<br>&gt;&gt;&gt;&gt; publishing refine-vs-override in a library&#39;s public interface.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure that<br>&gt;&gt;&gt;&gt; all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a variable<br>&gt;&gt;&gt;&gt;    and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to super is<br>&gt;&gt;&gt;&gt;&gt; present at all. More detailed behaviour should be part of the functions<br>&gt;&gt;&gt;&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt;&gt;&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt;&gt;&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt;&gt;&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; may be prevented if the compiler checks if super is called, like it does in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c0d0e8fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>My hesitation about &quot;required&quot; is that required initializers don&#39;t have to call the same initializer, which is something that NS_REQUIRES_SUPER does enforce. (In fact, this new attribute could very well apply to required initializers as well: if you implement this initializer, you must chain to the same initializer. I&#39;m not quite sure when that would come up, but it&#39;s potentially useful.)<br></p><p>Jordan<br></p><p>&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for this if for nothing else but UIKit classes yelling at me to call super.viewDidLoad().<br>&gt; <br>&gt; I think using the required keyword makes sense. The one possible caveat is overloading, as my knee jerk reaction is that methods of the same name would behave like initializers. So a method overriding a required method would have to call a required method of the same name on the superclass if one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the required initializer since it can be inherited.<br>&gt; Your example is an abstract function which should have it&#39;s own keyword (if we ever get abstract functions).<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;vester.gottfried at gmail.com &lt;mailto:vester.gottfried at gmail.com&gt;&gt; wrote:<br>&gt; I think reusing required would send the wrong message. Required would mean for me something like NSOperation subclasses maybe require to have a main() function, but that doesn&#39;t mean you have to call super. On the contrary, the documentation of NSOperation main() explicitly states not to call super. <br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt; What about re-using the &quot;required&quot; keyword in the superclass which already means something similar for initializers?<br>&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt; If a subclass doesn&#39;t implemented the required method it could mean that it inherits the behavior from the superclass - just like initializers can be inherited too.<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt; <br>&gt; Information from Radar: the request for this is rdar://problem/17408107 &lt;&gt; (plus a few duplicates). One of the dups suggests a variation where a subclass method can be declared as &quot;refine&quot; instead of &quot;override&quot; so that you can document that your own method is expected to call super. In this model, &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough, especially since we wouldn&#39;t be publishing refine-vs-override in a library&#39;s public interface.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure that all codepaths call the super implementation.<br>&gt;&gt; <br>&gt;&gt; Some more edge cases:<br>&gt;&gt; Calling super asynchronously by using it in a closure<br>&gt;&gt; Referring to the super implementation by assign it to a variable and call it later (is that really possible? never did that)<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;vester.gottfried at gmail.com &lt;mailto:vester.gottfried at gmail.com&gt;&gt; wrote:<br>&gt;&gt; I would suggest that @requires_super only checks if a call to super is present at all. More detailed behaviour should be part of the functions documentation, because I think all possibilities cannot be checked easily by the compiler. For example a call to super my be required to happen early or late inside the function. But when too early or too late is can probably not been forseen by the compiler.<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln &lt;mailto:marc at knaup.koeln&gt;&gt; wrote:<br>&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt; <br>&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt; <br>&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought through carefully and used correctly is a win.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass certain classes and override specific method and require that the super implementation of an overridden method is being called.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not calling the super implementation is a common source of bugs that may be prevented if the compiler checks if super is called, like it does in some cases of init().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should result in an error<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its worth thinking about adapting it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c1e567b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 16, 2015 at 02:00:00pm</p></header><div class="content"><p>+1<br></p><p>I thought that there must have been some reason not to include it that I<br>hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br></p><p>On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t have to<br>&gt; call the *same* initializer, which is something that NS_REQUIRES_SUPER<br>&gt; *does* enforce. (In fact, this new attribute could very well apply to<br>&gt; required initializers as well: if you implement this initializer, you must<br>&gt; chain to the same initializer. I&#39;m not quite sure when that would come up,<br>&gt; but it&#39;s potentially useful.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; +1 for this if for nothing else but UIKit classes yelling at me to call<br>&gt; super.viewDidLoad().<br>&gt;<br>&gt; I think using the required keyword makes sense. The one possible caveat is<br>&gt; overloading, as my knee jerk reaction is that methods of the same name<br>&gt; would behave like initializers. So a method overriding a required method<br>&gt; would have to call a required method of the same name on the superclass if<br>&gt; one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt; Your example is an abstract function which should have it&#39;s own keyword<br>&gt;&gt; (if we ever get abstract functions).<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I think reusing required would send the wrong message. Required would<br>&gt;&gt;&gt; mean for me something like NSOperation subclasses maybe require to have a<br>&gt;&gt;&gt; main() function, but that doesn&#39;t mean you have to call super. On the<br>&gt;&gt;&gt; contrary, the documentation of NSOperation main() explicitly states not to<br>&gt;&gt;&gt; call super.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean<br>&gt;&gt;&gt;&gt; that it inherits the behavior from the superclass - just like initializers<br>&gt;&gt;&gt;&gt; can be inherited too.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the dups<br>&gt;&gt;&gt;&gt;&gt; suggests a variation where a subclass method can be declared as &quot;refine&quot;<br>&gt;&gt;&gt;&gt;&gt; instead of &quot;override&quot; so that you can document that your *own* method<br>&gt;&gt;&gt;&gt;&gt; is expected to call super. In this model, &quot;@requires_super&quot; could become<br>&gt;&gt;&gt;&gt;&gt; something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough,<br>&gt;&gt;&gt;&gt;&gt; especially since we wouldn&#39;t be publishing refine-vs-override in a<br>&gt;&gt;&gt;&gt;&gt; library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure that<br>&gt;&gt;&gt;&gt;&gt; all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a variable<br>&gt;&gt;&gt;&gt;&gt;    and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to super<br>&gt;&gt;&gt;&gt;&gt;&gt; is present at all. More detailed behaviour should be part of the functions<br>&gt;&gt;&gt;&gt;&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt;&gt;&gt;&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt;&gt;&gt;&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt;&gt;&gt;&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that may be prevented if the compiler checks if super is called, like it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/3cb93572/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>@Jordan I might slowly be convincing myself that initialization behavior is<br>correct, though. For example, this feels right:<br></p><p>    class Foo {<br>        required func foo() {<br></p><p>        }<br>    }<br></p><p>    class Bar: Foo {<br>        required func foo(bar: Bar) {<br>            super.foo()<br>        }<br>    }<br></p><p>This, however, feels less right:<br></p><p>    class Foo {<br>        required func foo(string: String) {<br></p><p>        }<br></p><p>        required func foo(url: NSURL) {<br></p><p>        }<br>    }<br></p><p>    class Bar: Foo {<br>        override required func foo(string: String) {<br>            super.foo(url: NSURL(string: string)!)<br>        }<br>    }<br></p><p>But regardless, I&#39;m having trouble coming up with a better keyword.<br></p><p>fo<br>On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; I thought that there must have been some reason not to include it that I<br>&gt; hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t have<br>&gt;&gt; to call the *same* initializer, which is something that<br>&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute could<br>&gt;&gt; very well apply to required initializers as well: if you implement this<br>&gt;&gt; initializer, you must chain to the same initializer. I&#39;m not quite sure<br>&gt;&gt; when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;<br>&gt;&gt; Jordan<br>&gt;&gt;<br>&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to call<br>&gt;&gt; super.viewDidLoad().<br>&gt;&gt;<br>&gt;&gt; I think using the required keyword makes sense. The one possible caveat<br>&gt;&gt; is overloading, as my knee jerk reaction is that methods of the same name<br>&gt;&gt; would behave like initializers. So a method overriding a required method<br>&gt;&gt; would have to call a required method of the same name on the superclass if<br>&gt;&gt; one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own keyword<br>&gt;&gt;&gt; (if we ever get abstract functions).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required would<br>&gt;&gt;&gt;&gt; mean for me something like NSOperation subclasses maybe require to have a<br>&gt;&gt;&gt;&gt; main() function, but that doesn&#39;t mean you have to call super. On the<br>&gt;&gt;&gt;&gt; contrary, the documentation of NSOperation main() explicitly states not to<br>&gt;&gt;&gt;&gt; call super.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean<br>&gt;&gt;&gt;&gt;&gt; that it inherits the behavior from the superclass - just like initializers<br>&gt;&gt;&gt;&gt;&gt; can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the dups<br>&gt;&gt;&gt;&gt;&gt;&gt; suggests a variation where a subclass method can be declared as &quot;refine&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of &quot;override&quot; so that you can document that your *own* method<br>&gt;&gt;&gt;&gt;&gt;&gt; is expected to call super. In this model, &quot;@requires_super&quot; could become<br>&gt;&gt;&gt;&gt;&gt;&gt; something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough,<br>&gt;&gt;&gt;&gt;&gt;&gt; especially since we wouldn&#39;t be publishing refine-vs-override in a<br>&gt;&gt;&gt;&gt;&gt;&gt; library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure<br>&gt;&gt;&gt;&gt;&gt;&gt; that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is present at all. More detailed behaviour should be part of the functions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that may be prevented if the compiler checks if super is called, like it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/265d25bb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>When requiring super&#39;s implementation to always be called Swift should not<br>make the assumption that two methods with the same name but different<br>signatures are interchangeable.<br>Only the super method with exactly the same signature - i.e. the overridden<br>one - should be allowed to called. Anything else will likely be complex and<br>confusing.<br></p><p>@Ian &quot;override&quot; keyword is neither necessary nor allowed when &quot;required&quot; is<br>used since it implies exactly that already.<br></p><p>On Wed, Dec 16, 2015 at 8:17 PM, Ian Ynda-Hummel via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; @Jordan I might slowly be convincing myself that initialization behavior<br>&gt; is correct, though. For example, this feels right:<br>&gt;<br>&gt;     class Foo {<br>&gt;         required func foo() {<br>&gt;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     class Bar: Foo {<br>&gt;         required func foo(bar: Bar) {<br>&gt;             super.foo()<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; This, however, feels less right:<br>&gt;<br>&gt;     class Foo {<br>&gt;         required func foo(string: String) {<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         required func foo(url: NSURL) {<br>&gt;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     class Bar: Foo {<br>&gt;         override required func foo(string: String) {<br>&gt;             super.foo(url: NSURL(string: string)!)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; But regardless, I&#39;m having trouble coming up with a better keyword.<br>&gt;<br>&gt; fo<br>&gt; On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; +1<br>&gt;&gt;<br>&gt;&gt; I thought that there must have been some reason not to include it that I<br>&gt;&gt; hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t have<br>&gt;&gt;&gt; to call the *same* initializer, which is something that<br>&gt;&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute could<br>&gt;&gt;&gt; very well apply to required initializers as well: if you implement this<br>&gt;&gt;&gt; initializer, you must chain to the same initializer. I&#39;m not quite sure<br>&gt;&gt;&gt; when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to call<br>&gt;&gt;&gt; super.viewDidLoad().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think using the required keyword makes sense. The one possible caveat<br>&gt;&gt;&gt; is overloading, as my knee jerk reaction is that methods of the same name<br>&gt;&gt;&gt; would behave like initializers. So a method overriding a required method<br>&gt;&gt;&gt; would have to call a required method of the same name on the superclass if<br>&gt;&gt;&gt; one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own keyword<br>&gt;&gt;&gt;&gt; (if we ever get abstract functions).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required would<br>&gt;&gt;&gt;&gt;&gt; mean for me something like NSOperation subclasses maybe require to have a<br>&gt;&gt;&gt;&gt;&gt; main() function, but that doesn&#39;t mean you have to call super. On the<br>&gt;&gt;&gt;&gt;&gt; contrary, the documentation of NSOperation main() explicitly states not to<br>&gt;&gt;&gt;&gt;&gt; call super.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt;&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean<br>&gt;&gt;&gt;&gt;&gt;&gt; that it inherits the behavior from the superclass - just like initializers<br>&gt;&gt;&gt;&gt;&gt;&gt; can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the dups<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; suggests a variation where a subclass method can be declared as &quot;refine&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of &quot;override&quot; so that you can document that your *own* method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is expected to call super. In this model, &quot;@requires_super&quot; could become<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially since we wouldn&#39;t be publishing refine-vs-override in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is present at all. More detailed behaviour should be part of the functions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; documentation, because I think all possibilities cannot be checked easily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; by the compiler. For example a call to super my be required to happen early<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or late inside the function. But when too early or too late is can probably<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that may be prevented if the compiler checks if super is called, like it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/d5d8d06f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>Well, consider the following:<br></p><p>    class Foo {<br>        func foo() {<br></p><p>        }<br>    }<br></p><p>    class Bar: Foo {<br>        override required foo() {<br></p><p>        }<br>    }<br></p><p>    class Baz: Bar {<br>        override(?) required foo() {<br></p><p>        }<br>    }<br></p><p>The override would be required for Bar. If not it&#39;s either making<br>assumptions about the superclass that may not be correct or no subclass can<br>make an overridden method required by its subsequent subclasses.<br>Initializers have the convenience of always being required for the root<br>class.<br></p><p>Now I think I&#39;m talking myself out of the initializer behavior being<br>correct. I&#39;ll just call myself undecided about that for now.<br></p><p><br>On Wed, Dec 16, 2015 at 2:22 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; When requiring super&#39;s implementation to always be called Swift should not<br>&gt; make the assumption that two methods with the same name but different<br>&gt; signatures are interchangeable.<br>&gt; Only the super method with exactly the same signature - i.e. the<br>&gt; overridden one - should be allowed to called. Anything else will likely be<br>&gt; complex and confusing.<br>&gt;<br>&gt; @Ian &quot;override&quot; keyword is neither necessary nor allowed when &quot;required&quot;<br>&gt; is used since it implies exactly that already.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 8:17 PM, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; @Jordan I might slowly be convincing myself that initialization behavior<br>&gt;&gt; is correct, though. For example, this feels right:<br>&gt;&gt;<br>&gt;&gt;     class Foo {<br>&gt;&gt;         required func foo() {<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     class Bar: Foo {<br>&gt;&gt;         required func foo(bar: Bar) {<br>&gt;&gt;             super.foo()<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; This, however, feels less right:<br>&gt;&gt;<br>&gt;&gt;     class Foo {<br>&gt;&gt;         required func foo(string: String) {<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;<br>&gt;&gt;         required func foo(url: NSURL) {<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     class Bar: Foo {<br>&gt;&gt;         override required func foo(string: String) {<br>&gt;&gt;             super.foo(url: NSURL(string: string)!)<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; But regardless, I&#39;m having trouble coming up with a better keyword.<br>&gt;&gt;<br>&gt;&gt; fo<br>&gt;&gt; On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; +1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I thought that there must have been some reason not to include it that I<br>&gt;&gt;&gt; hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t have<br>&gt;&gt;&gt;&gt; to call the *same* initializer, which is something that<br>&gt;&gt;&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute could<br>&gt;&gt;&gt;&gt; very well apply to required initializers as well: if you implement this<br>&gt;&gt;&gt;&gt; initializer, you must chain to the same initializer. I&#39;m not quite sure<br>&gt;&gt;&gt;&gt; when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to call<br>&gt;&gt;&gt;&gt; super.viewDidLoad().<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think using the required keyword makes sense. The one possible caveat<br>&gt;&gt;&gt;&gt; is overloading, as my knee jerk reaction is that methods of the same name<br>&gt;&gt;&gt;&gt; would behave like initializers. So a method overriding a required method<br>&gt;&gt;&gt;&gt; would have to call a required method of the same name on the superclass if<br>&gt;&gt;&gt;&gt; one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own<br>&gt;&gt;&gt;&gt;&gt; keyword (if we ever get abstract functions).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required would<br>&gt;&gt;&gt;&gt;&gt;&gt; mean for me something like NSOperation subclasses maybe require to have a<br>&gt;&gt;&gt;&gt;&gt;&gt; main() function, but that doesn&#39;t mean you have to call super. On the<br>&gt;&gt;&gt;&gt;&gt;&gt; contrary, the documentation of NSOperation main() explicitly states not to<br>&gt;&gt;&gt;&gt;&gt;&gt; call super.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it inherits the behavior from the superclass - just like initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the dups<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; suggests a variation where a subclass method can be declared as &quot;refine&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of &quot;override&quot; so that you can document that your *own* method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is expected to call super. In this model, &quot;@requires_super&quot; could become<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially since we wouldn&#39;t be publishing refine-vs-override in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super is present at all. More detailed behaviour should be part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions documentation, because I think all possibilities cannot be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; checked easily by the compiler. For example a call to super my be required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to happen early or late inside the function. But when too early or too late<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is can probably not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that may be prevented if the compiler checks if super is called, like it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/1e59b5ea/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>I assume you just forgot &quot;func&quot;.<br></p><p>Okay, in the case where the super implementation is not &quot;required&quot; but the<br>subclass starts using &quot;required&quot; you must specify both.<br></p><p>This is the same as the current behavior for initializers:<br></p><p>class A {<br>init() {}<br>}<br></p><p>class B: A {<br>required override init() {}<br>}<br></p><p>class C: B {<br>required init() {}<br>}<br></p><p><br>Btw I just noticed that my previous assumption was wrong. Subclasses can<br>always use &quot;override&quot; and &quot;required&quot;. For class &quot;C&quot; it would just yield a<br>warning because it&#39;s redundant.<br></p><p>On Wed, Dec 16, 2015 at 8:29 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br></p><p>&gt; Well, consider the following:<br>&gt;<br>&gt;     class Foo {<br>&gt;         func foo() {<br>&gt;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     class Bar: Foo {<br>&gt;         override required foo() {<br>&gt;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     class Baz: Bar {<br>&gt;         override(?) required foo() {<br>&gt;<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; The override would be required for Bar. If not it&#39;s either making<br>&gt; assumptions about the superclass that may not be correct or no subclass can<br>&gt; make an overridden method required by its subsequent subclasses.<br>&gt; Initializers have the convenience of always being required for the root<br>&gt; class.<br>&gt;<br>&gt; Now I think I&#39;m talking myself out of the initializer behavior being<br>&gt; correct. I&#39;ll just call myself undecided about that for now.<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 2:22 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; When requiring super&#39;s implementation to always be called Swift should<br>&gt;&gt; not make the assumption that two methods with the same name but different<br>&gt;&gt; signatures are interchangeable.<br>&gt;&gt; Only the super method with exactly the same signature - i.e. the<br>&gt;&gt; overridden one - should be allowed to called. Anything else will likely be<br>&gt;&gt; complex and confusing.<br>&gt;&gt;<br>&gt;&gt; @Ian &quot;override&quot; keyword is neither necessary nor allowed when &quot;required&quot;<br>&gt;&gt; is used since it implies exactly that already.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 8:17 PM, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; @Jordan I might slowly be convincing myself that initialization behavior<br>&gt;&gt;&gt; is correct, though. For example, this feels right:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;         required func foo() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;         required func foo(bar: Bar) {<br>&gt;&gt;&gt;             super.foo()<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This, however, feels less right:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;         required func foo(string: String) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         required func foo(url: NSURL) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;         override required func foo(string: String) {<br>&gt;&gt;&gt;             super.foo(url: NSURL(string: string)!)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But regardless, I&#39;m having trouble coming up with a better keyword.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; fo<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I thought that there must have been some reason not to include it that<br>&gt;&gt;&gt;&gt; I hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t<br>&gt;&gt;&gt;&gt;&gt; have to call the *same* initializer, which is something that<br>&gt;&gt;&gt;&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute could<br>&gt;&gt;&gt;&gt;&gt; very well apply to required initializers as well: if you implement this<br>&gt;&gt;&gt;&gt;&gt; initializer, you must chain to the same initializer. I&#39;m not quite sure<br>&gt;&gt;&gt;&gt;&gt; when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to<br>&gt;&gt;&gt;&gt;&gt; call super.viewDidLoad().<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think using the required keyword makes sense. The one possible<br>&gt;&gt;&gt;&gt;&gt; caveat is overloading, as my knee jerk reaction is that methods of the same<br>&gt;&gt;&gt;&gt;&gt; name would behave like initializers. So a method overriding a required<br>&gt;&gt;&gt;&gt;&gt; method would have to call a required method of the same name on the<br>&gt;&gt;&gt;&gt;&gt; superclass if one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt;&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt;&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own<br>&gt;&gt;&gt;&gt;&gt;&gt; keyword (if we ever get abstract functions).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would mean for me something like NSOperation subclasses maybe require to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a main() function, but that doesn&#39;t mean you have to call super. On<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the contrary, the documentation of NSOperation main() explicitly states not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to call super.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could mean<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that it inherits the behavior from the superclass - just like initializers<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;jordan_rose at apple.com<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the dups<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; suggests a variation where a subclass method can be declared as &quot;refine&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of &quot;override&quot; so that you can document that your *own* method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is expected to call super. In this model, &quot;@requires_super&quot; could become<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially since we wouldn&#39;t be publishing refine-vs-override in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super is present at all. More detailed behaviour should be part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions documentation, because I think all possibilities cannot be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; checked easily by the compiler. For example a call to super my be required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to happen early or late inside the function. But when too early or too late<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is can probably not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of bugs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that may be prevented if the compiler checks if super is called, like it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super.addStuff() should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/05568de9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 08:00:00pm</p></header><div class="content"><p>PS: Just swap &quot;init()&quot; for &quot;func foo()&quot; and you have the syntax for<br>functions which require super calls in subclasses :)<br></p><p><br>On Wed, Dec 16, 2015 at 8:34 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; I assume you just forgot &quot;func&quot;.<br>&gt;<br>&gt; Okay, in the case where the super implementation is not &quot;required&quot; but the<br>&gt; subclass starts using &quot;required&quot; you must specify both.<br>&gt;<br>&gt; This is the same as the current behavior for initializers:<br>&gt;<br>&gt; class A {<br>&gt; init() {}<br>&gt; }<br>&gt;<br>&gt; class B: A {<br>&gt; required override init() {}<br>&gt; }<br>&gt;<br>&gt; class C: B {<br>&gt; required init() {}<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Btw I just noticed that my previous assumption was wrong. Subclasses can<br>&gt; always use &quot;override&quot; and &quot;required&quot;. For class &quot;C&quot; it would just yield a<br>&gt; warning because it&#39;s redundant.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 8:29 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Well, consider the following:<br>&gt;&gt;<br>&gt;&gt;     class Foo {<br>&gt;&gt;         func foo() {<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     class Bar: Foo {<br>&gt;&gt;         override required foo() {<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     class Baz: Bar {<br>&gt;&gt;         override(?) required foo() {<br>&gt;&gt;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt; The override would be required for Bar. If not it&#39;s either making<br>&gt;&gt; assumptions about the superclass that may not be correct or no subclass can<br>&gt;&gt; make an overridden method required by its subsequent subclasses.<br>&gt;&gt; Initializers have the convenience of always being required for the root<br>&gt;&gt; class.<br>&gt;&gt;<br>&gt;&gt; Now I think I&#39;m talking myself out of the initializer behavior being<br>&gt;&gt; correct. I&#39;ll just call myself undecided about that for now.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 2:22 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; When requiring super&#39;s implementation to always be called Swift should<br>&gt;&gt;&gt; not make the assumption that two methods with the same name but different<br>&gt;&gt;&gt; signatures are interchangeable.<br>&gt;&gt;&gt; Only the super method with exactly the same signature - i.e. the<br>&gt;&gt;&gt; overridden one - should be allowed to called. Anything else will likely be<br>&gt;&gt;&gt; complex and confusing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; @Ian &quot;override&quot; keyword is neither necessary nor allowed when &quot;required&quot;<br>&gt;&gt;&gt; is used since it implies exactly that already.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 8:17 PM, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @Jordan I might slowly be convincing myself that initialization<br>&gt;&gt;&gt;&gt; behavior is correct, though. For example, this feels right:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;         required func foo() {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;         required func foo(bar: Bar) {<br>&gt;&gt;&gt;&gt;             super.foo()<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This, however, feels less right:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;         required func foo(string: String) {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         required func foo(url: NSURL) {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;         override required func foo(string: String) {<br>&gt;&gt;&gt;&gt;             super.foo(url: NSURL(string: string)!)<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; But regardless, I&#39;m having trouble coming up with a better keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; fo<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I thought that there must have been some reason not to include it that<br>&gt;&gt;&gt;&gt;&gt; I hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt; have to call the *same* initializer, which is something that<br>&gt;&gt;&gt;&gt;&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute could<br>&gt;&gt;&gt;&gt;&gt;&gt; very well apply to required initializers as well: if you implement this<br>&gt;&gt;&gt;&gt;&gt;&gt; initializer, you must chain to the same initializer. I&#39;m not quite sure<br>&gt;&gt;&gt;&gt;&gt;&gt; when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to<br>&gt;&gt;&gt;&gt;&gt;&gt; call super.viewDidLoad().<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I think using the required keyword makes sense. The one possible<br>&gt;&gt;&gt;&gt;&gt;&gt; caveat is overloading, as my knee jerk reaction is that methods of the same<br>&gt;&gt;&gt;&gt;&gt;&gt; name would behave like initializers. So a method overriding a required<br>&gt;&gt;&gt;&gt;&gt;&gt; method would have to call a required method of the same name on the<br>&gt;&gt;&gt;&gt;&gt;&gt; superclass if one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; keyword (if we ever get abstract functions).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would mean for me something like NSOperation subclasses maybe require to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a main() function, but that doesn&#39;t mean you have to call super. On<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the contrary, the documentation of NSOperation main() explicitly states not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to call super.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass which<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mean that it inherits the behavior from the superclass - just like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; initializers can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the dups<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; suggests a variation where a subclass method can be declared as &quot;refine&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of &quot;override&quot; so that you can document that your *own* method<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is expected to call super. In this model, &quot;@requires_super&quot; could become<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; something like &quot;imposed&quot;. I personally think this doesn&#39;t add enough,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; especially since we wouldn&#39;t be publishing refine-vs-override in a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot ensure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super is present at all. More detailed behaviour should be part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions documentation, because I think all possibilities cannot be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; checked easily by the compiler. For example a call to super my be required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to happen early or late inside the function. But when too early or too late<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is can probably not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is thought<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bugs that may be prevented if the compiler checks if super is called, like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super.addStuff() should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/6a5a3327/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85ade213ef182c4a30916753b3c82b1e?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Ian Ynda-Hummel</string> &lt;ianynda at gmail.com&gt;<p>December 16, 2015 at 07:00:00pm</p></header><div class="content"><p>Yes, I forgot the func. I can type, I swear. :)<br></p><p>As for the throws thing, which it doesn&#39;t look like has been addressed:<br>method overrides cannot throw unless the overridden method throws, and it<br>seems like in the case that an error is thrown it doesn&#39;t matter if it the<br>was the superclass or the subclass as execution of the method is halted<br>anyway. I might be missing something, but I don&#39;t currently see a reason<br>that required (or whatever keyword) would exclude throws.<br></p><p>On Wed, Dec 16, 2015 at 2:36 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br></p><p>&gt; PS: Just swap &quot;init()&quot; for &quot;func foo()&quot; and you have the syntax for<br>&gt; functions which require super calls in subclasses :)<br>&gt;<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 8:34 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; I assume you just forgot &quot;func&quot;.<br>&gt;&gt;<br>&gt;&gt; Okay, in the case where the super implementation is not &quot;required&quot; but<br>&gt;&gt; the subclass starts using &quot;required&quot; you must specify both.<br>&gt;&gt;<br>&gt;&gt; This is the same as the current behavior for initializers:<br>&gt;&gt;<br>&gt;&gt; class A {<br>&gt;&gt; init() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class B: A {<br>&gt;&gt; required override init() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class C: B {<br>&gt;&gt; required init() {}<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Btw I just noticed that my previous assumption was wrong. Subclasses can<br>&gt;&gt; always use &quot;override&quot; and &quot;required&quot;. For class &quot;C&quot; it would just yield a<br>&gt;&gt; warning because it&#39;s redundant.<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 8:29 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Well, consider the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;         func foo() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;         override required foo() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     class Baz: Bar {<br>&gt;&gt;&gt;         override(?) required foo() {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The override would be required for Bar. If not it&#39;s either making<br>&gt;&gt;&gt; assumptions about the superclass that may not be correct or no subclass can<br>&gt;&gt;&gt; make an overridden method required by its subsequent subclasses.<br>&gt;&gt;&gt; Initializers have the convenience of always being required for the root<br>&gt;&gt;&gt; class.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now I think I&#39;m talking myself out of the initializer behavior being<br>&gt;&gt;&gt; correct. I&#39;ll just call myself undecided about that for now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 2:22 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; When requiring super&#39;s implementation to always be called Swift should<br>&gt;&gt;&gt;&gt; not make the assumption that two methods with the same name but different<br>&gt;&gt;&gt;&gt; signatures are interchangeable.<br>&gt;&gt;&gt;&gt; Only the super method with exactly the same signature - i.e. the<br>&gt;&gt;&gt;&gt; overridden one - should be allowed to called. Anything else will likely be<br>&gt;&gt;&gt;&gt; complex and confusing.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; @Ian &quot;override&quot; keyword is neither necessary nor allowed when<br>&gt;&gt;&gt;&gt; &quot;required&quot; is used since it implies exactly that already.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 8:17 PM, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; @Jordan I might slowly be convincing myself that initialization<br>&gt;&gt;&gt;&gt;&gt; behavior is correct, though. For example, this feels right:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;&gt;         required func foo() {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;&gt;         required func foo(bar: Bar) {<br>&gt;&gt;&gt;&gt;&gt;             super.foo()<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This, however, feels less right:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;&gt;         required func foo(string: String) {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         required func foo(url: NSURL) {<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;&gt;         override required func foo(string: String) {<br>&gt;&gt;&gt;&gt;&gt;             super.foo(url: NSURL(string: string)!)<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; But regardless, I&#39;m having trouble coming up with a better keyword.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; fo<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I thought that there must have been some reason not to include it<br>&gt;&gt;&gt;&gt;&gt;&gt; that I hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have to call the *same* initializer, which is something that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; could very well apply to required initializers as well: if you implement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this initializer, you must chain to the same initializer. I&#39;m not quite<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sure when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; call super.viewDidLoad().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think using the required keyword makes sense. The one possible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; caveat is overloading, as my knee jerk reaction is that methods of the same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; name would behave like initializers. So a method overriding a required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; method would have to call a required method of the same name on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; superclass if one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; keyword (if we ever get abstract functions).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would mean for me something like NSOperation subclasses maybe require to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a main() function, but that doesn&#39;t mean you have to call super. On<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the contrary, the documentation of NSOperation main() explicitly states not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to call super.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mean that it inherits the behavior from the superclass - just like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; initializers can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dups suggests a variation where a subclass method can be declared as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;refine&quot; instead of &quot;override&quot; so that you can document that your<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *own* method is expected to call super. In this model,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I personally think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this doesn&#39;t add enough, especially since we wouldn&#39;t be publishing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refine-vs-override in a library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ensure that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super is present at all. More detailed behaviour should be part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions documentation, because I think all possibilities cannot be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; checked easily by the compiler. For example a call to super my be required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to happen early or late inside the function. But when too early or too late<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is can probably not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thought through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bugs that may be prevented if the compiler checks if super is called, like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super.addStuff() should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/f3494893/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>This fits with the approach that &quot;required&quot; will only check that the call<br>to the superclass&#39; implementation is present but not that it is actually<br>called.<br></p><p>OTOH should it be required to call the super implementation exactly once no<br>matter what codepath is taken then throwing should be allowed before<br>super&#39;s implementation is called.<br>It may be helpful though to check a few examples to better evaluate that<br>case.<br></p><p>On Wed, Dec 16, 2015 at 8:55 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt; wrote:<br></p><p>&gt; Yes, I forgot the func. I can type, I swear. :)<br>&gt;<br>&gt; As for the throws thing, which it doesn&#39;t look like has been addressed:<br>&gt; method overrides cannot throw unless the overridden method throws, and it<br>&gt; seems like in the case that an error is thrown it doesn&#39;t matter if it the<br>&gt; was the superclass or the subclass as execution of the method is halted<br>&gt; anyway. I might be missing something, but I don&#39;t currently see a reason<br>&gt; that required (or whatever keyword) would exclude throws.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 2:36 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;<br>&gt;&gt; PS: Just swap &quot;init()&quot; for &quot;func foo()&quot; and you have the syntax for<br>&gt;&gt; functions which require super calls in subclasses :)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Dec 16, 2015 at 8:34 PM, Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I assume you just forgot &quot;func&quot;.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Okay, in the case where the super implementation is not &quot;required&quot; but<br>&gt;&gt;&gt; the subclass starts using &quot;required&quot; you must specify both.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is the same as the current behavior for initializers:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class A {<br>&gt;&gt;&gt; init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class B: A {<br>&gt;&gt;&gt; required override init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class C: B {<br>&gt;&gt;&gt; required init() {}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Btw I just noticed that my previous assumption was wrong. Subclasses can<br>&gt;&gt;&gt; always use &quot;override&quot; and &quot;required&quot;. For class &quot;C&quot; it would just yield a<br>&gt;&gt;&gt; warning because it&#39;s redundant.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Dec 16, 2015 at 8:29 PM, Ian Ynda-Hummel &lt;ianynda at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Well, consider the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;         func foo() {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;         override required foo() {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     class Baz: Bar {<br>&gt;&gt;&gt;&gt;         override(?) required foo() {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The override would be required for Bar. If not it&#39;s either making<br>&gt;&gt;&gt;&gt; assumptions about the superclass that may not be correct or no subclass can<br>&gt;&gt;&gt;&gt; make an overridden method required by its subsequent subclasses.<br>&gt;&gt;&gt;&gt; Initializers have the convenience of always being required for the root<br>&gt;&gt;&gt;&gt; class.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Now I think I&#39;m talking myself out of the initializer behavior being<br>&gt;&gt;&gt;&gt; correct. I&#39;ll just call myself undecided about that for now.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 2:22 PM Marc Knaup &lt;marc at knaup.koeln&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; When requiring super&#39;s implementation to always be called Swift should<br>&gt;&gt;&gt;&gt;&gt; not make the assumption that two methods with the same name but different<br>&gt;&gt;&gt;&gt;&gt; signatures are interchangeable.<br>&gt;&gt;&gt;&gt;&gt; Only the super method with exactly the same signature - i.e. the<br>&gt;&gt;&gt;&gt;&gt; overridden one - should be allowed to called. Anything else will likely be<br>&gt;&gt;&gt;&gt;&gt; complex and confusing.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; @Ian &quot;override&quot; keyword is neither necessary nor allowed when<br>&gt;&gt;&gt;&gt;&gt; &quot;required&quot; is used since it implies exactly that already.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 8:17 PM, Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; @Jordan I might slowly be convincing myself that initialization<br>&gt;&gt;&gt;&gt;&gt;&gt; behavior is correct, though. For example, this feels right:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;         required func foo() {<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;         required func foo(bar: Bar) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             super.foo()<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This, however, feels less right:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     class Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;         required func foo(string: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         required func foo(url: NSURL) {<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;     class Bar: Foo {<br>&gt;&gt;&gt;&gt;&gt;&gt;         override required func foo(string: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;             super.foo(url: NSURL(string: string)!)<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; But regardless, I&#39;m having trouble coming up with a better keyword.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; fo<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 2:03 PM T.J. Usiyan &lt;griotspeak at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I thought that there must have been some reason not to include it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that I hadn&#39;t considered when it wasn&#39;t in Swift 1.0.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:59 PM, Jordan Rose via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; My hesitation about &quot;required&quot; is that required initializers don&#39;t<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have to call the *same* initializer, which is something that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; NS_REQUIRES_SUPER *does* enforce. (In fact, this new attribute<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could very well apply to required initializers as well: if you implement<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this initializer, you must chain to the same initializer. I&#39;m not quite<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sure when that would come up, but it&#39;s potentially useful.)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:56 , Ian Ynda-Hummel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for this if for nothing else but UIKit classes yelling at me to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; call super.viewDidLoad().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think using the required keyword makes sense. The one possible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; caveat is overloading, as my knee jerk reaction is that methods of the same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; name would behave like initializers. So a method overriding a required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; method would have to call a required method of the same name on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; superclass if one exists. I&#39;m not convinced that&#39;s correct, though.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 1:40 PM Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;required&quot; also doesn&#39;t mean that a subclass has to implement the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; required initializer since it can be inherited.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Your example is an abstract function which should have it&#39;s own<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; keyword (if we ever get abstract functions).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:37 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think reusing required would send the wrong message. Required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would mean for me something like NSOperation subclasses maybe require to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have a main() function, but that doesn&#39;t mean you have to call super. On<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the contrary, the documentation of NSOperation main() explicitly states not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to call super.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:08 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What about re-using the &quot;required&quot; keyword in the superclass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; which already means something similar for initializers?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Subclass implementations are required to call super&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If a subclass doesn&#39;t implemented the required method it could<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; mean that it inherits the behavior from the superclass - just like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; initializers can be inherited too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 7:02 PM, Jordan Rose &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; jordan_rose at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 from me. FWIW, the Objective-C one is syntactic.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Information from Radar: the request for this is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; rdar://problem/17408107 (plus a few duplicates). One of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dups suggests a variation where a subclass method can be declared as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;refine&quot; instead of &quot;override&quot; so that you can document that your<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; *own* method is expected to call super. In this model,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;@requires_super&quot; could become something like &quot;imposed&quot;. I personally think<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; this doesn&#39;t add enough, especially since we wouldn&#39;t be publishing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; refine-vs-override in a library&#39;s public interface.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 9:49 , Marc Knaup via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sounds reasonable since even the best flow analysis cannot<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ensure that all codepaths call the super implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some more edge cases:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Calling super asynchronously by using it in a closure<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    - Referring to the super implementation by assign it to a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    variable and call it later (is that really possible? never did that)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 6:25 PM, Vester Gottfried &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; vester.gottfried at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I would suggest that @requires_super only checks if a call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super is present at all. More detailed behaviour should be part of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; functions documentation, because I think all possibilities cannot be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; checked easily by the compiler. For example a call to super my be required<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to happen early or late inside the function. But when too early or too late<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is can probably not been forseen by the compiler.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:46 PM, Marc Knaup &lt;marc at knaup.koeln&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 always had such issues with UIViewController&#39;s lifecycle<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; methods.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; But edge cases need to be considered like &quot;throws&quot; for<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; example.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do I need to call super before I throw something?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 to this.  Anything that helps ensure inheritance is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; thought through carefully and used correctly is a win.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Some class based libraries/frameworks expect the consumer to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; subclass certain classes and override specific method and require that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super implementation of an overridden method is being called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not calling the super implementation is a common source of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bugs that may be prevented if the compiler checks if super is called, like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it does in some cases of init().<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;    @requires_super<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     func addStuff() { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Overriding class Box&#39;s addStuff without calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super.addStuff() should result in an error<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; class Chest : Box {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     override addStuff() {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;          // ERROR: addStuff() requires call to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; super.addStuff()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; think its worth thinking about adapting it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gottfried<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/e1b7ba0c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0eaab3d5d1d4428f74a711f724f2eb47?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Etan Kissling</string> &lt;kissling at oberon.ch&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>Or simply make `throws` and `requires_super` mutually exclusive?<br></p><p>The case where the base class does not `throw` but the subclass `throws` isn&#39;t possible<br>as it would break all clients who cast everything to the base class and assume that it doesn&#39;t throw.<br></p><p>Etan<br></p><p><br>&gt; On 16 Dec 2015, at 17:46, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 always had such issues with UIViewController&#39;s lifecycle methods.<br>&gt; <br>&gt; But edge cases need to be considered like &quot;throws&quot; for example.<br>&gt; Do I need to call super before I throw something?<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 5:41 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; +1 to this.  Anything that helps ensure inheritance is thought through carefully and used correctly is a win.<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 10:32 AM, Vester Gottfried via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some class based libraries/frameworks expect the consumer to subclass certain classes and override specific method and require that the super implementation of an overridden method is being called.<br>&gt;&gt; <br>&gt;&gt; Not calling the super implementation is a common source of bugs that may be prevented if the compiler checks if super is called, like it does in some cases of init().<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; class Box {<br>&gt;&gt;    @requires_super<br>&gt;&gt;     func addStuff() { ... }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Overriding class Box&#39;s addStuff without calling super.addStuff() should result in an error<br>&gt;&gt; <br>&gt;&gt; class Chest : Box {<br>&gt;&gt;     override addStuff() {<br>&gt;&gt;          // ERROR: addStuff() requires call to super.addStuff()<br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Objective-C developers know this as NS_REQUIRES_SUPER and I think its worth thinking about adapting it.<br>&gt;&gt; <br>&gt;&gt; I hope my proposal was clear and thanks for reading,<br>&gt;&gt; <br>&gt;&gt; Gottfried<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/982fb149/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 801 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/982fb149/attachment.sig&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>A huge +1 on this  I&#39;d actually go one step further and propose to make it the default behavior:<br>Calling super rarely hurts, and it would be easier to find a better name for the attribute ;-) (maybe &quot;replaceable&quot;)<br>Additionally, it is one step in the right direction for those who think &quot;final&quot; should be default (if there is any good reason to prefer final over requires_super, I haven&#39;t seen it yet).<br></p><p>Instead of enforcing the call to super, it would be possible to automatically run the super implementation after (or before) the overriding method (unless it is explicitly called).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>I think that the problem with making it a default behavior is that you<br>can&#39;t be sure *when* to call super in a child implementation. you should<br>call in the middle for init but in the beginning for viewDidLoad and<br>(sometimes) at the end for dealloc.<br></p><p>On Wed, Dec 16, 2015 at 5:04 PM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A huge +1 on this  I&#39;d actually go one step further and propose to make<br>&gt; it the default behavior:<br>&gt; Calling super rarely hurts, and it would be easier to find a better name<br>&gt; for the attribute ;-) (maybe &quot;replaceable&quot;)<br>&gt; Additionally, it is one step in the right direction for those who think<br>&gt; &quot;final&quot; should be default (if there is any good reason to prefer final over<br>&gt; requires_super, I haven&#39;t seen it yet).<br>&gt;<br>&gt; Instead of enforcing the call to super, it would be possible to<br>&gt; automatically run the super implementation after (or before) the overriding<br>&gt; method (unless it is explicitly called).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/2d285923/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 16, 2015 at 11:00:00pm</p></header><div class="content"><p>Default behavior would require something like &quot;unrequire&quot; which seems odd.<br>Also this would break a lot of existing code and migration can&#39;t be done<br>automatically.<br></p><p>On Wed, Dec 16, 2015 at 11:04 PM, Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A huge +1 on this  I&#39;d actually go one step further and propose to make<br>&gt; it the default behavior:<br>&gt; Calling super rarely hurts, and it would be easier to find a better name<br>&gt; for the attribute ;-) (maybe &quot;replaceable&quot;)<br>&gt; Additionally, it is one step in the right direction for those who think<br>&gt; &quot;final&quot; should be default (if there is any good reason to prefer final over<br>&gt; requires_super, I haven&#39;t seen it yet).<br>&gt;<br>&gt; Instead of enforcing the call to super, it would be possible to<br>&gt; automatically run the super implementation after (or before) the overriding<br>&gt; method (unless it is explicitly called).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/edd7af25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3a5eef1234103a85d2004c44ca18fd5b?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Cullen MacDonald</string> &lt;cullenbmacdonald at gmail.com&gt;<p>December 16, 2015 at 05:00:00pm</p></header><div class="content"><p>huge +1 from me.<br></p><p>On Wed, Dec 16, 2015 at 5:16 PM, Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Default behavior would require something like &quot;unrequire&quot; which seems odd.<br>&gt; Also this would break a lot of existing code and migration can&#39;t be done<br>&gt; automatically.<br>&gt;<br>&gt; On Wed, Dec 16, 2015 at 11:04 PM, Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; A huge +1 on this  I&#39;d actually go one step further and propose to make<br>&gt;&gt; it the default behavior:<br>&gt;&gt; Calling super rarely hurts, and it would be easier to find a better name<br>&gt;&gt; for the attribute ;-) (maybe &quot;replaceable&quot;)<br>&gt;&gt; Additionally, it is one step in the right direction for those who think<br>&gt;&gt; &quot;final&quot; should be default (if there is any good reason to prefer final over<br>&gt;&gt; requires_super, I haven&#39;t seen it yet).<br>&gt;&gt;<br>&gt;&gt; Instead of enforcing the call to super, it would be possible to<br>&gt;&gt; automatically run the super implementation after (or before) the overriding<br>&gt;&gt; method (unless it is explicitly called).<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/d5f006dc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 17, 2015 at 12:00:00am</p></header><div class="content"><p>&gt; Default behavior would require something like &quot;unrequire&quot; which seems odd.<br>the keyword for requires_super is so odd, it doesn&#39;t even fit in a single word! ;-)<br>I think it is much easer to find a word for something that can be replaced completely than for &quot;you have to call the implementation of the parent class&quot;<br></p><p>&gt; Also this would break a lot of existing code and migration can&#39;t be done automatically.<br>Two parts:<br>What is a lot? I really don&#39;t think calling super hurts in many places.<br>Why shouldn&#39;t it be possible to migrate automatically? It might get complicated for compiled libs, but definitely possible.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/5eb01b1c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c0eafab7106ab63b8db4025e57c1a8d2?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Javier Soto</string> &lt;javier.api at gmail.com&gt;<p>December 17, 2015 at 02:00:00am</p></header><div class="content"><p>I&#39;m not a fan of this feature because it encourages a type of API design<br>that&#39;s really hard to ensure that it&#39;s used correctly. The biggest problem<br>is the fact that often when a class expects or allows a method to be<br>overriden, and super needs to be called, it expects the call to happen in a<br>particular order: either before of after the implementation from the<br>subclass.<br></p><p>So yes, this is missing from Obj-C, yes, this is important because UIKit,<br>but going forward my feeling is that a language without this feature is a<br>language that will force you to think about an alternative way to implement<br>an API without this, and that&#39;ll probably be less error-prone.<br>On Wed, Dec 16, 2015 at 3:03 PM Tino Heth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Default behavior would require something like &quot;unrequire&quot; which seems odd.<br>&gt;<br>&gt; the keyword for requires_super is so odd, it doesn&#39;t even fit in a single<br>&gt; word! ;-)<br>&gt; I think it is much easer to find a word for something that can be replaced<br>&gt; completely than for &quot;you have to call the implementation of the parent<br>&gt; class&quot;<br>&gt;<br>&gt; Also this would break a lot of existing code and migration can&#39;t be done<br>&gt; automatically.<br>&gt;<br>&gt; Two parts:<br>&gt; What is a lot? I really don&#39;t think calling super hurts in many places.<br>&gt; Why shouldn&#39;t it be possible to migrate automatically? It might get<br>&gt; complicated for compiled libs, but definitely possible.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>Javier Soto<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/6ae3d3b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>one solution is @requires_super(first|last). This cuts out &quot;call me in the<br>middle&quot; but that is a worthwhile trade, in my opinion.<br></p><p>On Wed, Dec 16, 2015 at 9:22 PM, Javier Soto via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m not a fan of this feature because it encourages a type of API design<br>&gt; that&#39;s really hard to ensure that it&#39;s used correctly. The biggest problem<br>&gt; is the fact that often when a class expects or allows a method to be<br>&gt; overriden, and super needs to be called, it expects the call to happen in a<br>&gt; particular order: either before of after the implementation from the<br>&gt; subclass.<br>&gt;<br>&gt; So yes, this is missing from Obj-C, yes, this is important because UIKit,<br>&gt; but going forward my feeling is that a language without this feature is a<br>&gt; language that will force you to think about an alternative way to implement<br>&gt; an API without this, and that&#39;ll probably be less error-prone.<br>&gt; On Wed, Dec 16, 2015 at 3:03 PM Tino Heth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Default behavior would require something like &quot;unrequire&quot; which seems odd.<br>&gt;&gt;<br>&gt;&gt; the keyword for requires_super is so odd, it doesn&#39;t even fit in a single<br>&gt;&gt; word! ;-)<br>&gt;&gt; I think it is much easer to find a word for something that can be<br>&gt;&gt; replaced completely than for &quot;you have to call the implementation of the<br>&gt;&gt; parent class&quot;<br>&gt;&gt;<br>&gt;&gt; Also this would break a lot of existing code and migration can&#39;t be done<br>&gt;&gt; automatically.<br>&gt;&gt;<br>&gt;&gt; Two parts:<br>&gt;&gt; What is a lot? I really don&#39;t think calling super hurts in many places.<br>&gt;&gt; Why shouldn&#39;t it be possible to migrate automatically? It might get<br>&gt;&gt; complicated for compiled libs, but definitely possible.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; --<br>&gt; Javier Soto<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/ad1db401/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>When a superclass method must be called either before or after the override it would be ideal to have the compiler synthesize the call rather than just verify the developer writes it.  The developer should only need to write it when they need control over when that call happens.<br></p><p>willSet and didSet are pretty similar to this synthesis, but rather than synthesizing a call to super the compiler synthesizes the entire setter with the willSet and / or didSet code in the appropriate location(s).<br></p><p><br>&gt; On Dec 16, 2015, at 8:28 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; one solution is @requires_super(first|last). This cuts out &quot;call me in the middle&quot; but that is a worthwhile trade, in my opinion.<br>&gt; <br>&gt; On Wed, Dec 16, 2015 at 9:22 PM, Javier Soto via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I&#39;m not a fan of this feature because it encourages a type of API design that&#39;s really hard to ensure that it&#39;s used correctly. The biggest problem is the fact that often when a class expects or allows a method to be overriden, and super needs to be called, it expects the call to happen in a particular order: either before of after the implementation from the subclass. <br>&gt; <br>&gt; So yes, this is missing from Obj-C, yes, this is important because UIKit, but going forward my feeling is that a language without this feature is a language that will force you to think about an alternative way to implement an API without this, and that&#39;ll probably be less error-prone. <br>&gt; On Wed, Dec 16, 2015 at 3:03 PM Tino Heth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Default behavior would require something like &quot;unrequire&quot; which seems odd.<br>&gt; <br>&gt; the keyword for requires_super is so odd, it doesn&#39;t even fit in a single word! ;-)<br>&gt; I think it is much easer to find a word for something that can be replaced completely than for &quot;you have to call the implementation of the parent class&quot;<br>&gt; <br>&gt;&gt; Also this would break a lot of existing code and migration can&#39;t be done automatically.<br>&gt; <br>&gt; Two parts:<br>&gt; What is a lot? I really don&#39;t think calling super hurts in many places.<br>&gt; Why shouldn&#39;t it be possible to migrate automatically? It might get complicated for compiled libs, but definitely possible.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -- <br>&gt; Javier Soto  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/680ee6d4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 17, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; The biggest problem is the fact that often when a class expects or allows a method to be overriden, and super needs to be called, it expects the call to happen in a particular order: either before of after the implementation from the subclass. <br>Do you have concrete examples for this claim?<br>Even if my impression that it doesn&#39;t matter in most cases is wrong, imho the argument is like advising not to wear a helmet on the construction site because it doesn&#39;t protect your feet.<br>Additionally, it can be easily addressed (&quot;@prepend, @append&quot;...)<br></p><p>&gt; So yes, this is missing from Obj-C, yes, this is important because UIKit, but going forward my feeling is that a language without this feature is a language that will force you to think about an alternative way to implement an API without this, and that&#39;ll probably be less error-prone. <br>Why?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151217/161e559a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Proposal: Add @requires_super attribute</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>December 17, 2015 at 05:00:00pm</p></header><div class="content"><p>YES! +10.<br></p><p>&#39;nough said.<br></p><p>One caveat: it should be syntactic, like other people mentioned; if nothing else, this will allow you to suppress the error when you know what you&#39;re doing.<br></p><p>A.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
