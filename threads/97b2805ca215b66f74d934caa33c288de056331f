<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 27, 2016 at 11:00:00am</p></header><div class="content"><p>Hi all,<br></p><p>Proposal link: https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md<br></p><p>Here is a detailed proposal draft for bridging NSError to ErrorProtocol. Getting this right is surprisingly involved, so the detailed design on this proposal is fairly large. Comments welcome!<br></p><p>	- Doug<br></p><p>NSError Bridging<br></p><p>Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/NNNN-nserror-bridging.md&gt;<br>Author: Doug Gregor &lt;https://github.com/DougGregor&gt;, Charles Srstka &lt;https://github.com/CharlesJS&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#introduction&gt;Introduction<br></p><p>Swift&#39;s error handling model interoperates directly with Cocoa&#39;s NSError conventions. For example, an Objective-C method with an NSError** parameter, e.g.,<br></p><p>- (nullable NSURL *)replaceItemAtURL:(NSURL *)url options:(NSFileVersionReplacingOptions)options error:(NSError **)error;<br>will be imported as a throwing method:<br></p><p>func replaceItem(at url: URL, options: ReplacingOptions = []) throws -&gt; URL<br>Swift bridges between ErrorProtocol-conforming types and NSError so, for example, a Swift enum that conforms toErrorProtocol can be thrown and will be reflected as an NSError with a suitable domain and code. Moreover, an NSErrorproduced with that domain and code can be caught as the Swift enum type, providing round-tripping so that Swift can deal in ErrorProtocol values while Objective-C deals in NSError objects.<br></p><p>However, the interoperability is incomplete in a number of ways, which results in Swift programs having to walk a careful line between the ErrorProtocol-based Swift way and the NSError-based way. This proposal attempts to bridge those gaps.<br></p><p>Swift-evolution thread: Charles Srstka&#39;s pitch for Consistent bridging for NSErrors at the language boundary &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016618.html&gt;, which discussed Charles&#39; original proposal &lt;https://github.com/apple/swift-evolution/pull/331&gt; that addressed these issues by providing NSError to ErrorProtocol bridging and exposing the domain, code, and user-info dictionary for all errors. This proposal expands upon that work, but without directly exposing the domain, code, and user-info.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#motivation&gt;Motivation<br></p><p>There are a number of weaknesses in Swift&#39;s interoperability with Cocoa&#39;s error model, including:<br></p><p>There is no good way to provide important error information when throwing an error from Swift. For example, let&#39;s consider a simple application-defined error in Swift:<br></p><p>enum HomeworkError : Int, ErrorProtocol {<br>  case forgotten<br>  case lost<br>  case dogAteIt<br>}<br>One can throw HomeworkError.dogAteIt and it can be interpreted as an NSError by Objective-C with an appropriate error domain (effectively, the mangled name of the HomeworkError type) and code (effectively, the case discriminator). However, one cannot provide a localized description, help anchor, recovery attempter, or any other information commonly placed into the userInfo dictionary of an NSError. To provide these values, one must specifically construct an NSError in Swift, e.g.,<br></p><p>throw NSError(code: HomeworkError.dogAteIt.rawValue,<br>              domain: HomeworkError._domain,<br>              userInfo: [ NSLocalizedDescriptionKey : &quot;the dog ate it&quot; ])<br>There is no good way to get information typically associated with NSError&#39;s userInfo in Swift. For example, the Swift-natural way to catch a specific error in the AVError error domain doesn&#39;t give one access to the userInfo dictionary, e.g.,:<br></p><p>catch let error as AVError where error == .diskFull {<br>  // AVError is an enum, so one only gets the equivalent of the code.<br>  // There is no way to access the localized description (for example) or<br>  // any other information typically stored in the ``userInfo`` dictionary.<br>}<br>The workaround is to catch as an NSError, which is quite a bit more ugly:<br></p><p>catch let error as NSError where error._domain == AVFoundationErrorDomain &amp;&amp; error._code == AVFoundationErrorDomain.diskFull.rawValue {<br>  // okay: userInfo is finally accessible, but still weakly typed<br>}<br>This makes it extremely hard to access common information, such as the localized description. Moreover, the userInfo dictionary is effectively untyped so, for example, one has to know a priori that the value associated with the known AVErrorDeviceKey will be typed as CMTime:<br></p><p>catch let error as NSError where error._domain = AVFoundationErrorDomain {<br>  if let time = error.userInfo[AVErrorDeviceKey] as? CMTime {<br>    // ...<br>  }<br>}<br>It would be far better if one could catch an AVError directly and query the time in a type-safe manner:<br></p><p>catch let error as AVError {<br>  if let time = error.time {<br>    // ...<br>  }<br>}<br>NSError is inconsistently bridged with ErrorProtocol. Swift interoperates by translating between NSError and ErrorProtocol when mapping between a throwing Swift method/initializer and an Objective-C method with an NSError** parameter. However, an Objective-C method that takes an NSError* parameter (e.g., to render it) does not bridge to ErrorProtocol, meaning that NSError is part of the API in Swift in some places (but not others). For example, NSError leaks through when the following UIDocument API in Objective-C:<br></p><p>- (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>is imported into Swift as follows:<br></p><p>func handleError(_ error: NSError, userInteractionPermitted: Bool)<br>One would expect the first parameter to be imported as ErrorProtocol. <br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#proposed-solution&gt;Proposed solution<br></p><p>This proposal involves directly addressing (1)-(3) with new protocols and a different way of bridging Objective-C error code types into Swift, along with some conveniences for working with Cocoa errors:<br></p><p>Introduce three new protocols for describing more information about errors: LocalizedError, RecoverableError, andCustomNSError. For example, an error type can provide a localized description by conforming to LocalizedError:<br></p><p>extension HomeworkError : LocalizedError {<br>  var errorDescription: String? {<br>    switch self {<br>    case .forgotten: return NSLocalizedString(&quot;I forgot it&quot;)<br>    case .lost: return NSLocalizedString(&quot;I lost it&quot;)<br>    case .dogAteIt: return NSLocalizedString(&quot;The dog ate it&quot;)<br>    }<br>  }<br>}<br>Imported Objective-C error types should be mapped to struct types that store an NSError so that no information is lost when bridging from an NSError to the Swift error types. We propose to introduce a new macro, NS_ERROR_ENUM, that one can use to both declare an enumeration type used to describe the error codes as well as tying that type to a specific domain constant, e.g.,<br></p><p>typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>  AVErrorUnknown                                      = -11800,<br>  AVErrorOutOfMemory                                  = -11801,<br>  AVErrorSessionNotRunning                            = -11803,<br>  AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>  // ...<br>}<br>The imported AVError will have a struct that allows one to access the userInfo dictionary directly. This retains the ability to catch via a specific code, e.g.,<br></p><p>catch AVError.outOfMemory {<br> // ...<br>}<br>However, catching a specific error as a value doesn&#39;t lose information:<br></p><p>catch let error as AVError where error.code == .sessionNotRunning {<br> // able to access userInfo here!<br>}<br>This also gives the ability for one to add typed accessors for known keys within the userInfo dictionary:<br></p><p>extension AVError {<br> var time: CMTime? {<br>   get {<br>     return userInfo[AVErrorTimeKey] as? CMTime?<br>   }<br></p><p>   set {<br>     userInfo[AVErrorTimeKey] = newValue.map { $0 as CMTime }<br>   }<br> }<br>}<br>Bridge NSError to ErrorProtocol, so that all NSError uses are bridged consistently. For example, this means that the Objective-C API:<br></p><p>- (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>is imported into Swift as:<br></p><p>func handleError(_ error: ErrorProtocol, userInteractionPermitted: Bool)<br>This will use the same bridging logic in the Clang importer that we use for other value types (Array, String, URL, etc.), but with the runtime translation we&#39;ve already been doing for catching/throwing errors.<br></p><p>When we introduce this bridging, we will need to remove NSError&#39;s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, we still need an easy way to create an ErrorProtocol instance from an arbitrary NSError, e.g.,<br></p><p>extension NSError {<br>  var asError: ErrorProtocol { ... }<br>}<br>In Foundation, add an extension to ErrorProtocol that provides typed access to the common user-info keys. Note that we focus only on those user-info keys that are read by user code (vs. only accessed by frameworks):<br></p><p>extension ErrorProtocol {<br>  // Note: for exposition only. Not actual API.<br>  private var userInfo: [NSObject : AnyObject] {<br>    return (self as! NSError).userInfo<br>  }<br></p><p>  var localizedDescription: String {<br>    return (self as! NSError).localizedDescription<br>  }<br></p><p>  var filePath: String? {<br>    return userInfo[NSFilePathErrorKey] as? String<br>  }<br></p><p>  var stringEncoding: String.Encoding? {<br>    return (userInfo[NSStringEncodingErrorKey] as? NSNumber)<br>             .map { String.Encoding(rawValue: $0.uintValue) }<br>  }<br></p><p>  var underlying: ErrorProtocol? {<br>    return (userInfo[NSUnderlyingErrorKey] as? NSError)?.asError<br>  }<br></p><p>  var url: URL? {<br>    return userInfo[NSURLErrorKey] as? URL<br>  }<br>}<br>Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br></p><p>func handleError(_ error: Error, userInteractionPermitted: Bool)<br> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#detailed-design&gt;Detailed design<br></p><p>This section details both the design (including the various new protocols, mapping from Objective-C error code enumeration types into Swift types, etc.) and the efficient implementation of this design to interoperate with NSError. Throughout the detailed design, we already assume the name change from ErrorProtocol to Error.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#new-protocols&gt;New protocols<br></p><p>This proposal introduces several new protocols that allow error types to expose more information about error types.<br></p><p>The LocalizedError protocol describes an error that provides localized messages for display to the end user, all of which provide default implementations. The conforming type can provide implementations for any subset of these requirements:<br></p><p>protocol LocalizedError : Error {<br>  /// A localized message describing what error occurred.<br>  var errorDescription: String? { get }<br></p><p>  /// A localized message describing the reason for the failure.<br>  var failureReason: String? { get }<br></p><p>  /// A localized message describing how one might recover from the failure.<br>  var recoverySuggestion: String? { get }<br></p><p>  /// A localized message providing &quot;help&quot; text if the user requests help.<br>  var helpAnchor: String? { get }<br>}<br></p><p>extension LocalizedError {<br>  var errorDescription: String? { return nil }<br>  var failureReason: String? { return nil }<br>  var recoverySuggestion: String? { return nil }<br>  var helpAnchor: String? { return nil }<br>}<br>The RecoverableError protocol describes an error that might be recoverable: <br></p><p>protocol RecoverableError : Error {<br>  /// Provides a set of possible recovery options to present to the user.<br>  var recoveryOptions: [String] { get }<br></p><p>  /// Attempt to recover from this error when the user selected the<br>  /// option at the given index. This routine must call resultHandler and<br>  /// indicate whether recovery was successful (or not).<br>  ///<br>  /// This entry point is used for recovery of errors handled at a<br>  /// &quot;document&quot; granularity, that do not affect the entire<br>  /// application.<br>  func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>                       andThen resultHandler: (recovered: Bool) -&gt; Void)<br></p><p>  /// Attempt to recover from this error when the user selected the<br>  /// option at the given index. Returns true to indicate<br>  /// successful recovery, and false otherwise.<br>  ///<br>  /// This entry point is used for recovery of errors handled at<br>  /// the &quot;application&quot; granularity, where nothing else in the<br>  /// application can proceed until the attmpted error recovery<br>  /// completes.<br>  func attemptRecovery(optionIndex recoveryOptionIndex: Int) -&gt; Bool<br>}<br></p><p>extension RecoverableError {<br>  /// By default, implements document-modal recovery via application-model<br>  /// recovery.<br>  func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>                       andThen resultHandler: (Bool) -&gt; Void) {<br>    resultHandler(recovered: attemptRecovery(optionIndex: recoveryOptionIndex))<br>  }<br>}<br>Error types that conform to RecoverableError may be given an opportunity to recover from the error. The user can be presented with some number of (localized) recovery options, described by recoveryOptions, and the selected option will be passed to the appropriate attemptRecovery method.<br></p><p>The CustomNSError protocol describes an error that wants to provide custom NSError information. This can be used, e.g., to provide a specific domain/code or to populate NSError&#39;s userInfo dictionary with values for custom keys that can be accessed from Objective-C code but are not covered by the other protocols.<br></p><p>/// Describes an error type that fills in the userInfo directly.<br>protocol CustomNSError : Error {<br>  var errorDomain: String { get }<br>  var errorCode: Int { get }<br>  var errorUserInfo: [String : AnyObject] { get }<br>}<br>Note that, unlike with NSError, the provided errorUserInfo requires String keys. This is in line with common practice for NSError and is important for the implementation (see below). All of these properties are defaulted, so one can provide any subset:<br></p><p>extension CustomNSError {<br>  var errorDomain: String { ... }<br>  var errorCode: Int { ... }<br>  var errorUserInfo: [String : AnyObject] { ... }<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-error-types-to-nserror&gt;Mapping error types to NSError<br></p><p>Every type that conforms to the Error protocol is implicitly bridged to NSError. This has been the case since Swift 2, where the compiler provides a domain (i.e., the mangled name of the type) and code (based on the discriminator of the enumeration type). This proposal also allows for the userInfo dictionary to be populated by the runtime, which will check for conformance to the various protocols (LocalizedError, RecoverableError, or CustomNSError) to retrieve information.<br></p><p>Conceptually, this could be implemented by eagerly creating a userInfo dictionary for a given instance of Error:<br></p><p>func createUserInfo(error: Error) -&gt; [NSObject : AnyObject] {<br>  var userInfo: [NSObject : AnyObject] = [:]<br></p><p>  // Retrieve custom userInfo information.<br>  if let customUserInfoError = error as? CustomNSError {<br>    userInfo = customUserInfoError.userInfo<br>  }<br></p><p>  if let localizedError = error as? LocalizedError {<br>    if let description = localizedError.errorDescription {<br>      userInfo[NSLocalizedDescriptionKey] = description<br>    }<br></p><p>    if let reason = localizedError.failureReason {<br>      userInfo[NSLocalizedFailureReasonErrorKey] = reason<br>    }<br></p><p>    if let suggestion = localizedError.recoverySuggestion {   <br>      userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>    }<br></p><p>    if let helpAnchor = localizedError.helpAnchor {   <br>      userInfo[NSHelpAnchorErrorKey] = helpAnchor<br>    }<br>  }<br></p><p>  if let recoverableError = error as? RecoverableError {<br>    userInfo[NSLocalizedRecoveryOptionsErrorKey] = recoverableError.recoveryOptions<br>    userInfo[NSRecoveryAttempterErrorKey] = RecoveryAttempter()<br>  }<br>}<br>The RecoveryAttempter class is an implementation detail. It will implement the informal protocol NSErrorRecoveryAttempting &lt;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSErrorRecoveryAttempting_Protocol/&gt; for the given error:<br></p><p>class RecoveryAttempter : NSObject {<br>  @objc(attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:)<br>  func attemptRecovery(fromError nsError: NSError,<br>                       optionIndex recoveryOptionIndex: Int,<br>                       delegate: AnyObject?,<br>                       didRecoverSelector: Selector,<br>                       contextInfo: UnsafeMutablePointer&lt;Void&gt;) {<br>    let error = nsError as! RecoverableError<br>    error.attemptRecovery(optionIndex: recoveryOptionIndex) { success in<br>      // Exposition only: this part will actually have to be<br>      // implemented in Objective-C to pass the BOOL and void* through.<br>      delegate?.perform(didRecoverSelector, with: success, with: contextInfo)<br>    }<br>  }<br></p><p>  @objc(attemptRecoveryFromError:optionIndex:)<br>  func attemptRecovery(fromError nsError: NSError,<br>                       optionIndex recoveryOptionIndex: Int) -&gt; Bool {<br>    let error = nsError as! RecoverableError<br>    return error.attemptRecovery(optionIndex: recoveryOptionIndex)<br>  }<br>}<br>The actual the population of the userInfo dictionary should not be eager. NSError provides the notion of global &quot;user info value providers&quot; that it uses to lazily request the values for certain keys, via setUserInfoValueProvider(forDomain:provider:), which is declared as:<br></p><p>extension NSError {<br>  @available(OSX 10.11, iOS 9.0, tvOS 9.0, watchOS 2.0, *)<br>  class func setUserInfoValueProvider(forDomain errorDomain: String,<br>                                      provider: ((NSError, String) -&gt; AnyObject?)? = nil)<br>}<br>The runtime would need to register a user info value provider for each error type the first time it is bridged into NSError, supplying the domain and the following user info value provider function:<br></p><p>func userInfoValueProvider(nsError: NSError, key: String) -&gt; AnyObject? {<br>  let error = nsError as! Error<br>  switch key {<br>  case NSLocalizedDescriptionKey:<br>    return (error as? LocalizedError)?.errorDescription<br></p><p>  case NSLocalizedFailureReasonErrorKey:<br>    return (error as? LocalizedError)?.failureReason<br></p><p>  case NSLocalizedRecoverySuggestionErrorKey:<br>    return (error as? LocalizedError)?.recoverySuggestion<br></p><p>  case NSHelpAnchorErrorKey:<br>    return (error as? LocalizedError)?.helpAnchor<br></p><p>  case NSLocalizedRecoveryOptionsErrorKey:<br>    return (error as? RecoverableError)?.recoveryOptions<br></p><p>  case NSRecoveryAttempterErrorKey:<br>    return error is RecoverableError ? RecoveryAttempter() : nil<br></p><p>  default:<br>    guard let customUserInfoError = error as? CustomNSError else { return nil }<br>    return customUserInfoError.userInfo[key]<br>  }<br>}<br>On platforms that predate the introduction of user info value providers, there are alternate implementation strategies, including introducing a custom NSDictionary subclass to use as the userInfo in the NSError that lazily populates the dictionary by, effectively, calling the userInfoValueProvider function above for each requested key. Or, one could eagerly populate userInfo on older platforms.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#importing-error-types-from-objective-c&gt;Importing error types from Objective-C<br></p><p>In Objective-C, error domains are typically constructed using an enumeration describing the error codes and a constant describing the error domain, e.g,<br></p><p>extern NSString *const AVFoundationErrorDomain;<br></p><p>typedef NS_ENUM(NSInteger, AVError) {<br>  AVErrorUnknown                                      = -11800,<br>  AVErrorOutOfMemory                                  = -11801,<br>  AVErrorSessionNotRunning                            = -11803,<br>  AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>  // ...<br>}<br>This is currently imported as an enum that conforms to Error:<br></p><p>enum AVError : Int {<br>  case unknown                                      = -11800<br>  case outOfMemory                                  = -11801<br>  case sessionNotRunning                            = -11803<br>  case deviceAlreadyUsedByAnotherSession            = -11804<br></p><p>  static var _domain: String { return AVFoundationErrorDomain }<br>}<br>and Swift code introduces an extension that makes it an Error, along with some implementation magic to allow bridging from an NSError (losing userInfo in the process):<br></p><p>extension AVError : Error {<br>  static var _domain: String { return AVFoundationErrorDomain }<br>}<br>Instead, error enums should be expressed with a new macro, NS_ERROR_ENUM, that ties together the code and domain in the Objective-C header:<br></p><p>extern NSString *const AVFoundationErrorDomain;<br></p><p>typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>  AVErrorUnknown                                      = -11800,<br>  AVErrorOutOfMemory                                  = -11801,<br>  AVErrorSessionNotRunning                            = -11803,<br>  AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>  // ...<br>}<br>This will import as a new struct AVError that contains an NSError, so there is no information loss. The actual enum will become a nested type Code, so that it is still accessible. The resulting struct will be as follows:<br></p><p>struct AVError {<br>  /// Stored NSError. Note that error.domain == AVFoundationErrorDomain is an invariant.<br>  private var error: NSError<br></p><p>  /// Describes the error codes; directly imported from AVError<br>  enum Code : Int, ErrorCodeProtocol {<br>    typealias ErrorType = AVError<br></p><p>    case unknown                                      = -11800<br>    case outOfMemory                                  = -11801<br>    case sessionNotRunning                            = -11803<br>    case deviceAlreadyUsedByAnotherSession            = -11804<br></p><p>    func errorMatchesCode(_ error: AVError) -&gt; Bool {<br>      return error.code == self<br>    }<br>  }<br></p><p>  /// Allow one to create an error (optionally) with a userInfo dictionary.<br>  init(_ code: Code, userInfo: [NSObject: AnyObject] = [:]) {<br>    error = NSError(code: code.rawValue, domain: _domain, userInfo: userInfo)<br>  }<br></p><p>  /// Retrieve the code.<br>  var code: Code { return Code(rawValue: error.code)! }<br></p><p>  /// Allow direct access to the userInfo dictionary.<br>  var userInfo: [NSObject: AnyObject] { return error.userInfo }<br></p><p>  /// Make it easy to refer to constants without context.<br>  static let unknown: Code = .unknown<br>  static let outOfMemory: Code = .outOfMemory<br>  static let sessionNotRunning: Code = .sessionNotRunning<br>  static let deviceAlreadyUsedByAnotherSession: Code = .deviceAlreadyUsedByAnotherSession<br>}<br></p><p>// Implementation detail: makes AVError conform to Error<br>extension AVError : Error {<br>  static var _domain: String { return AVFoundationErrorDomain }<br></p><p>  var _code: Int { return error.code }<br>}<br>This syntax allows one to throw specific errors fairly easily, with or without userInfo dictionaries:<br></p><p>throw AVError(.sessionNotRunning)<br>throw AVError(.sessionNotRunning, userInfo: [ ... ])<br>The ImportedErrorCode protocol is a helper so that we can define a general ~= operator, which is used by both switchcase matching and catch blocks:<br></p><p>protocol ErrorCodeProtocol {<br>  typealias ErrorType : Error<br></p><p>  func errorMatchesCode(_ error: ErrorType) -&gt; Bool<br>}<br></p><p>func ~= &lt;EC: ErrorCodeProtocol&gt; (error: Error, code: EC) -&gt; Bool {<br>  guard let myError = error as? EC.ErrorType else { return false }<br>  return code.errorMatchesCode(myError)<br>}<br> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-nserror-types-back-into-swift&gt;Mapping NSError types back into Swift<br></p><p>When an NSError object bridged to an Error instance, it may be immediately mapped back to a Swift error type (e.g., if the error was created as a HomeworkError instance in Swift and then passed through NSError unmodified) or it might be leave as an instance of NSError. The error might then be catch as a particular Swift error type, e.g.,<br></p><p>catch let error as AVError where error.code == .sessionNotRunning {<br>  // able to access userInfo here!<br>}<br>In this case, the mapping from an NSError instance to AVError goes through an implementation-detail protocol_ObjectiveCBridgeableError:<br></p><p>protocol _ObjectiveCBridgeableError : Error {<br>  /// Produce a value of the error type corresponding to the given NSError,<br>  /// or return nil if it cannot be bridged.<br>  init?(_bridgedNSError error: NSError)<br>}<br>The initializer is responsible for checking the domain and (optionally) the code of the incoming NSError to map it to an instance of the Swift error type. For example, AVError would adopt this protocol as follows:<br></p><p>// Implementation detail: makes AVError conform to _ObjectiveCBridgeableError<br>extension AVError : _ObjectiveCBridgeableError {<br>  init?(_bridgedNSError error: NSError) {<br>    // Check whether the error comes from the AVFoundation error domain<br>    if error.domain != AVFoundationErrorDomain { return nil }<br></p><p>    // Save the error<br>    self.error = error<br>  }<br>}<br>We do not propose that _ObjectiveCBridgeableError become a public protocol, because the core team has already deferred a similar proposal (SE-0058 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md&gt;) to make the related protocol _ObjectiveCBridgeable public. <br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#other-issues&gt;Other Issues<br></p><p>NSError codes and domains are important for localization of error messages. This is barely supported today by genstrings, but becomes considerably harder when the domain and code are hidden (as they are in Swift). We would need to consider tooling to make it easier to localize error descriptions, recovery options, etc. in a sensible way. Although this is out of the scope of the Swift language per se, it&#39;s an important part of the developer story.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This is a major source-breaking change for Objective-C APIs that operate on NSError values, because those parameter/return/property types will change from NSError to Error. There are ~400 such APIs in the macOS SDK, and closer to 500 in the iOS SDK, which is a sizable number. Fortunately, this is similar in scope to the Foundation value types proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;, and can use the same code migration mechanism. That said, the scale of this change means that it should either happen in Swift 3 or not at all.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#future-directions&gt;Future directions<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#better-tooling-for-describing-errors&gt;Better tooling for describing errors<br></p><p>When adopting one of the new protocols (e.g., LocalizedError) in an enum, one will inevitably end up with a number of switch statements that have to enumerate all of the cases, leading to a lot of boilerplate. Better tooling could improve the situation considerably: for example, one could use something like Cocoa&#39;s stringsdict files &lt;https://developer.apple.com/library/prerelease/content/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html&gt; to provide localized strings identified by the enum name, case name, and property. That would eliminate the need for the switch-on-all-cases implementations of each property.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#round-tripping-errors-through-userinfo&gt;Round-tripping errors through userInfo<br></p><p>The CustomNSError protocol allows one to place arbitrary key/value pairs into NSError&#39;s userInfo dictionary. The implementation-detail _ObjectiveCBridgeableError protocol allows one to control how a raw NSError is mapped to a particular error type. One could effectively serialize the entire state of a particular error type into the userInfo dictionary viaCustomNSError, then restore it via _ObjectiveCBridgeableError, allowing one to form a complete NSError in Objective-C that can reconstitute itself as a particular Swift error type, which can be useful both for mixed-source projects and (possibly) as a weak form of serialization for NSErrors.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#alternatives-considered&gt;Alternatives considered<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#exposing-the-domain-code-and-user-info-dictionary-directly&gt;Exposing the domain, code, and user-info dictionary directly<br></p><p>This proposal does not directly expose the domain, code, or user-info dictionary on ErrorProtocol, because these notions are superseded by Swift&#39;s strong typing of errors. The domain is effectively subsumed by the type of the error (e.g., a Swift-defined error type uses its mangled name as the domain); the code is some type-specific value (e.g., the discriminator of the enum); and the user-info dictionary is an untyped set of key-value pairs that are better expressed in Swift as data on the specific error type.<br></p><p> &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#bridging-nserror-to-a-new-value-type-error&gt;Bridging NSError to a new value type Error<br></p><p>One could introduce a new value type, Error, that stores a domain, code, and user-info dictionary but provides them with value semantics. Doing so would make it easier to create &quot;generic&quot; errors that carry some information. However, we feel that introducing new error types in Swift is already easier than establishing a new domain and a set of codes, because a new enum type provides this information naturally in Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/97b2331f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Obviously, I’m in favor of this one. +1!<br></p><p>I think I did prefer the older name of CustomUserInfoError for the domain/code/userInfo protocol, rather than CustomNSError. This is just because I’d like to be able to do a global search through my project for “NSError” and have it turn up empty. Maybe a silly reason, I know. ;-)<br></p><p>I sent a few more comments off-list before I realized you’d posted the proposal already, so you can peruse, consider, and/or discard those at your leisure. It’s nothing terribly important, though; this proposal is pretty great as is.<br></p><p>Thanks so much for doing this! I’m really excited for better error handling in Swift 3.<br></p><p>Charles<br></p><p>&gt; On Jun 27, 2016, at 1:17 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Proposal link: https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md&gt;<br>&gt; <br>&gt; Here is a detailed proposal draft for bridging NSError to ErrorProtocol. Getting this right is surprisingly involved, so the detailed design on this proposal is fairly large. Comments welcome!<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; NSError Bridging<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/NNNN-nserror-bridging.md&gt;<br>&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;, Charles Srstka &lt;https://github.com/CharlesJS&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift&#39;s error handling model interoperates directly with Cocoa&#39;s NSError conventions. For example, an Objective-C method with an NSError** parameter, e.g.,<br>&gt; <br>&gt; - (nullable NSURL *)replaceItemAtURL:(NSURL *)url options:(NSFileVersionReplacingOptions)options error:(NSError **)error;<br>&gt; will be imported as a throwing method:<br>&gt; <br>&gt; func replaceItem(at url: URL, options: ReplacingOptions = []) throws -&gt; URL<br>&gt; Swift bridges between ErrorProtocol-conforming types and NSError so, for example, a Swift enum that conforms toErrorProtocol can be thrown and will be reflected as an NSError with a suitable domain and code. Moreover, an NSErrorproduced with that domain and code can be caught as the Swift enum type, providing round-tripping so that Swift can deal in ErrorProtocol values while Objective-C deals in NSError objects.<br>&gt; <br>&gt; However, the interoperability is incomplete in a number of ways, which results in Swift programs having to walk a careful line between the ErrorProtocol-based Swift way and the NSError-based way. This proposal attempts to bridge those gaps.<br>&gt; <br>&gt; Swift-evolution thread: Charles Srstka&#39;s pitch for Consistent bridging for NSErrors at the language boundary &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016618.html&gt;, which discussed Charles&#39; original proposal &lt;https://github.com/apple/swift-evolution/pull/331&gt; that addressed these issues by providing NSError to ErrorProtocol bridging and exposing the domain, code, and user-info dictionary for all errors. This proposal expands upon that work, but without directly exposing the domain, code, and user-info.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#motivation&gt;Motivation<br>&gt; <br>&gt; There are a number of weaknesses in Swift&#39;s interoperability with Cocoa&#39;s error model, including:<br>&gt; <br>&gt; There is no good way to provide important error information when throwing an error from Swift. For example, let&#39;s consider a simple application-defined error in Swift:<br>&gt; <br>&gt; enum HomeworkError : Int, ErrorProtocol {<br>&gt;   case forgotten<br>&gt;   case lost<br>&gt;   case dogAteIt<br>&gt; }<br>&gt; One can throw HomeworkError.dogAteIt and it can be interpreted as an NSError by Objective-C with an appropriate error domain (effectively, the mangled name of the HomeworkError type) and code (effectively, the case discriminator). However, one cannot provide a localized description, help anchor, recovery attempter, or any other information commonly placed into the userInfo dictionary of an NSError. To provide these values, one must specifically construct an NSError in Swift, e.g.,<br>&gt; <br>&gt; throw NSError(code: HomeworkError.dogAteIt.rawValue,<br>&gt;               domain: HomeworkError._domain,<br>&gt;               userInfo: [ NSLocalizedDescriptionKey : &quot;the dog ate it&quot; ])<br>&gt; There is no good way to get information typically associated with NSError&#39;s userInfo in Swift. For example, the Swift-natural way to catch a specific error in the AVError error domain doesn&#39;t give one access to the userInfo dictionary, e.g.,:<br>&gt; <br>&gt; catch let error as AVError where error == .diskFull {<br>&gt;   // AVError is an enum, so one only gets the equivalent of the code.<br>&gt;   // There is no way to access the localized description (for example) or<br>&gt;   // any other information typically stored in the ``userInfo`` dictionary.<br>&gt; }<br>&gt; The workaround is to catch as an NSError, which is quite a bit more ugly:<br>&gt; <br>&gt; catch let error as NSError where error._domain == AVFoundationErrorDomain &amp;&amp; error._code == AVFoundationErrorDomain.diskFull.rawValue {<br>&gt;   // okay: userInfo is finally accessible, but still weakly typed<br>&gt; }<br>&gt; This makes it extremely hard to access common information, such as the localized description. Moreover, the userInfo dictionary is effectively untyped so, for example, one has to know a priori that the value associated with the known AVErrorDeviceKey will be typed as CMTime:<br>&gt; <br>&gt; catch let error as NSError where error._domain = AVFoundationErrorDomain {<br>&gt;   if let time = error.userInfo[AVErrorDeviceKey] as? CMTime {<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; It would be far better if one could catch an AVError directly and query the time in a type-safe manner:<br>&gt; <br>&gt; catch let error as AVError {<br>&gt;   if let time = error.time {<br>&gt;     // ...<br>&gt;   }<br>&gt; }<br>&gt; NSError is inconsistently bridged with ErrorProtocol. Swift interoperates by translating between NSError and ErrorProtocol when mapping between a throwing Swift method/initializer and an Objective-C method with an NSError** parameter. However, an Objective-C method that takes an NSError* parameter (e.g., to render it) does not bridge to ErrorProtocol, meaning that NSError is part of the API in Swift in some places (but not others). For example, NSError leaks through when the following UIDocument API in Objective-C:<br>&gt; <br>&gt; - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>&gt; is imported into Swift as follows:<br>&gt; <br>&gt; func handleError(_ error: NSError, userInteractionPermitted: Bool)<br>&gt; One would expect the first parameter to be imported as ErrorProtocol. <br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; This proposal involves directly addressing (1)-(3) with new protocols and a different way of bridging Objective-C error code types into Swift, along with some conveniences for working with Cocoa errors:<br>&gt; <br>&gt; Introduce three new protocols for describing more information about errors: LocalizedError, RecoverableError, andCustomNSError. For example, an error type can provide a localized description by conforming to LocalizedError:<br>&gt; <br>&gt; extension HomeworkError : LocalizedError {<br>&gt;   var errorDescription: String? {<br>&gt;     switch self {<br>&gt;     case .forgotten: return NSLocalizedString(&quot;I forgot it&quot;)<br>&gt;     case .lost: return NSLocalizedString(&quot;I lost it&quot;)<br>&gt;     case .dogAteIt: return NSLocalizedString(&quot;The dog ate it&quot;)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; Imported Objective-C error types should be mapped to struct types that store an NSError so that no information is lost when bridging from an NSError to the Swift error types. We propose to introduce a new macro, NS_ERROR_ENUM, that one can use to both declare an enumeration type used to describe the error codes as well as tying that type to a specific domain constant, e.g.,<br>&gt; <br>&gt; typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>&gt;   AVErrorUnknown                                      = -11800,<br>&gt;   AVErrorOutOfMemory                                  = -11801,<br>&gt;   AVErrorSessionNotRunning                            = -11803,<br>&gt;   AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;   // ...<br>&gt; }<br>&gt; The imported AVError will have a struct that allows one to access the userInfo dictionary directly. This retains the ability to catch via a specific code, e.g.,<br>&gt; <br>&gt; catch AVError.outOfMemory {<br>&gt;  // ...<br>&gt; }<br>&gt; However, catching a specific error as a value doesn&#39;t lose information:<br>&gt; <br>&gt; catch let error as AVError where error.code == .sessionNotRunning {<br>&gt;  // able to access userInfo here!<br>&gt; }<br>&gt; This also gives the ability for one to add typed accessors for known keys within the userInfo dictionary:<br>&gt; <br>&gt; extension AVError {<br>&gt;  var time: CMTime? {<br>&gt;    get {<br>&gt;      return userInfo[AVErrorTimeKey] as? CMTime?<br>&gt;    }<br>&gt; <br>&gt;    set {<br>&gt;      userInfo[AVErrorTimeKey] = newValue.map { $0 as CMTime }<br>&gt;    }<br>&gt;  }<br>&gt; }<br>&gt; Bridge NSError to ErrorProtocol, so that all NSError uses are bridged consistently. For example, this means that the Objective-C API:<br>&gt; <br>&gt; - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>&gt; is imported into Swift as:<br>&gt; <br>&gt; func handleError(_ error: ErrorProtocol, userInteractionPermitted: Bool)<br>&gt; This will use the same bridging logic in the Clang importer that we use for other value types (Array, String, URL, etc.), but with the runtime translation we&#39;ve already been doing for catching/throwing errors.<br>&gt; <br>&gt; When we introduce this bridging, we will need to remove NSError&#39;s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, we still need an easy way to create an ErrorProtocol instance from an arbitrary NSError, e.g.,<br>&gt; <br>&gt; extension NSError {<br>&gt;   var asError: ErrorProtocol { ... }<br>&gt; }<br>&gt; In Foundation, add an extension to ErrorProtocol that provides typed access to the common user-info keys. Note that we focus only on those user-info keys that are read by user code (vs. only accessed by frameworks):<br>&gt; <br>&gt; extension ErrorProtocol {<br>&gt;   // Note: for exposition only. Not actual API.<br>&gt;   private var userInfo: [NSObject : AnyObject] {<br>&gt;     return (self as! NSError).userInfo<br>&gt;   }<br>&gt; <br>&gt;   var localizedDescription: String {<br>&gt;     return (self as! NSError).localizedDescription<br>&gt;   }<br>&gt; <br>&gt;   var filePath: String? {<br>&gt;     return userInfo[NSFilePathErrorKey] as? String<br>&gt;   }<br>&gt; <br>&gt;   var stringEncoding: String.Encoding? {<br>&gt;     return (userInfo[NSStringEncodingErrorKey] as? NSNumber)<br>&gt;              .map { String.Encoding(rawValue: $0.uintValue) }<br>&gt;   }<br>&gt; <br>&gt;   var underlying: ErrorProtocol? {<br>&gt;     return (userInfo[NSUnderlyingErrorKey] as? NSError)?.asError<br>&gt;   }<br>&gt; <br>&gt;   var url: URL? {<br>&gt;     return userInfo[NSURLErrorKey] as? URL<br>&gt;   }<br>&gt; }<br>&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt; <br>&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; This section details both the design (including the various new protocols, mapping from Objective-C error code enumeration types into Swift types, etc.) and the efficient implementation of this design to interoperate with NSError. Throughout the detailed design, we already assume the name change from ErrorProtocol to Error.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#new-protocols&gt;New protocols<br>&gt; <br>&gt; This proposal introduces several new protocols that allow error types to expose more information about error types.<br>&gt; <br>&gt; The LocalizedError protocol describes an error that provides localized messages for display to the end user, all of which provide default implementations. The conforming type can provide implementations for any subset of these requirements:<br>&gt; <br>&gt; protocol LocalizedError : Error {<br>&gt;   /// A localized message describing what error occurred.<br>&gt;   var errorDescription: String? { get }<br>&gt; <br>&gt;   /// A localized message describing the reason for the failure.<br>&gt;   var failureReason: String? { get }<br>&gt; <br>&gt;   /// A localized message describing how one might recover from the failure.<br>&gt;   var recoverySuggestion: String? { get }<br>&gt; <br>&gt;   /// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt;   var helpAnchor: String? { get }<br>&gt; }<br>&gt; <br>&gt; extension LocalizedError {<br>&gt;   var errorDescription: String? { return nil }<br>&gt;   var failureReason: String? { return nil }<br>&gt;   var recoverySuggestion: String? { return nil }<br>&gt;   var helpAnchor: String? { return nil }<br>&gt; }<br>&gt; The RecoverableError protocol describes an error that might be recoverable: <br>&gt; <br>&gt; protocol RecoverableError : Error {<br>&gt;   /// Provides a set of possible recovery options to present to the user.<br>&gt;   var recoveryOptions: [String] { get }<br>&gt; <br>&gt;   /// Attempt to recover from this error when the user selected the<br>&gt;   /// option at the given index. This routine must call resultHandler and<br>&gt;   /// indicate whether recovery was successful (or not).<br>&gt;   ///<br>&gt;   /// This entry point is used for recovery of errors handled at a<br>&gt;   /// &quot;document&quot; granularity, that do not affect the entire<br>&gt;   /// application.<br>&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>&gt;                        andThen resultHandler: (recovered: Bool) -&gt; Void)<br>&gt; <br>&gt;   /// Attempt to recover from this error when the user selected the<br>&gt;   /// option at the given index. Returns true to indicate<br>&gt;   /// successful recovery, and false otherwise.<br>&gt;   ///<br>&gt;   /// This entry point is used for recovery of errors handled at<br>&gt;   /// the &quot;application&quot; granularity, where nothing else in the<br>&gt;   /// application can proceed until the attmpted error recovery<br>&gt;   /// completes.<br>&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension RecoverableError {<br>&gt;   /// By default, implements document-modal recovery via application-model<br>&gt;   /// recovery.<br>&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>&gt;                        andThen resultHandler: (Bool) -&gt; Void) {<br>&gt;     resultHandler(recovered: attemptRecovery(optionIndex: recoveryOptionIndex))<br>&gt;   }<br>&gt; }<br>&gt; Error types that conform to RecoverableError may be given an opportunity to recover from the error. The user can be presented with some number of (localized) recovery options, described by recoveryOptions, and the selected option will be passed to the appropriate attemptRecovery method.<br>&gt; <br>&gt; The CustomNSError protocol describes an error that wants to provide custom NSError information. This can be used, e.g., to provide a specific domain/code or to populate NSError&#39;s userInfo dictionary with values for custom keys that can be accessed from Objective-C code but are not covered by the other protocols.<br>&gt; <br>&gt; /// Describes an error type that fills in the userInfo directly.<br>&gt; protocol CustomNSError : Error {<br>&gt;   var errorDomain: String { get }<br>&gt;   var errorCode: Int { get }<br>&gt;   var errorUserInfo: [String : AnyObject] { get }<br>&gt; }<br>&gt; Note that, unlike with NSError, the provided errorUserInfo requires String keys. This is in line with common practice for NSError and is important for the implementation (see below). All of these properties are defaulted, so one can provide any subset:<br>&gt; <br>&gt; extension CustomNSError {<br>&gt;   var errorDomain: String { ... }<br>&gt;   var errorCode: Int { ... }<br>&gt;   var errorUserInfo: [String : AnyObject] { ... }<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-error-types-to-nserror&gt;Mapping error types to NSError<br>&gt; <br>&gt; Every type that conforms to the Error protocol is implicitly bridged to NSError. This has been the case since Swift 2, where the compiler provides a domain (i.e., the mangled name of the type) and code (based on the discriminator of the enumeration type). This proposal also allows for the userInfo dictionary to be populated by the runtime, which will check for conformance to the various protocols (LocalizedError, RecoverableError, or CustomNSError) to retrieve information.<br>&gt; <br>&gt; Conceptually, this could be implemented by eagerly creating a userInfo dictionary for a given instance of Error:<br>&gt; <br>&gt; func createUserInfo(error: Error) -&gt; [NSObject : AnyObject] {<br>&gt;   var userInfo: [NSObject : AnyObject] = [:]<br>&gt; <br>&gt;   // Retrieve custom userInfo information.<br>&gt;   if let customUserInfoError = error as? CustomNSError {<br>&gt;     userInfo = customUserInfoError.userInfo<br>&gt;   }<br>&gt; <br>&gt;   if let localizedError = error as? LocalizedError {<br>&gt;     if let description = localizedError.errorDescription {<br>&gt;       userInfo[NSLocalizedDescriptionKey] = description<br>&gt;     }<br>&gt; <br>&gt;     if let reason = localizedError.failureReason {<br>&gt;       userInfo[NSLocalizedFailureReasonErrorKey] = reason<br>&gt;     }<br>&gt; <br>&gt;     if let suggestion = localizedError.recoverySuggestion {   <br>&gt;       userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>&gt;     }<br>&gt; <br>&gt;     if let helpAnchor = localizedError.helpAnchor {   <br>&gt;       userInfo[NSHelpAnchorErrorKey] = helpAnchor<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   if let recoverableError = error as? RecoverableError {<br>&gt;     userInfo[NSLocalizedRecoveryOptionsErrorKey] = recoverableError.recoveryOptions<br>&gt;     userInfo[NSRecoveryAttempterErrorKey] = RecoveryAttempter()<br>&gt;   }<br>&gt; }<br>&gt; The RecoveryAttempter class is an implementation detail. It will implement the informal protocol NSErrorRecoveryAttempting &lt;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSErrorRecoveryAttempting_Protocol/&gt; for the given error:<br>&gt; <br>&gt; class RecoveryAttempter : NSObject {<br>&gt;   @objc(attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:)<br>&gt;   func attemptRecovery(fromError nsError: NSError,<br>&gt;                        optionIndex recoveryOptionIndex: Int,<br>&gt;                        delegate: AnyObject?,<br>&gt;                        didRecoverSelector: Selector,<br>&gt;                        contextInfo: UnsafeMutablePointer&lt;Void&gt;) {<br>&gt;     let error = nsError as! RecoverableError<br>&gt;     error.attemptRecovery(optionIndex: recoveryOptionIndex) { success in<br>&gt;       // Exposition only: this part will actually have to be<br>&gt;       // implemented in Objective-C to pass the BOOL and void* through.<br>&gt;       delegate?.perform(didRecoverSelector, with: success, with: contextInfo)<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   @objc(attemptRecoveryFromError:optionIndex:)<br>&gt;   func attemptRecovery(fromError nsError: NSError,<br>&gt;                        optionIndex recoveryOptionIndex: Int) -&gt; Bool {<br>&gt;     let error = nsError as! RecoverableError<br>&gt;     return error.attemptRecovery(optionIndex: recoveryOptionIndex)<br>&gt;   }<br>&gt; }<br>&gt; The actual the population of the userInfo dictionary should not be eager. NSError provides the notion of global &quot;user info value providers&quot; that it uses to lazily request the values for certain keys, via setUserInfoValueProvider(forDomain:provider:), which is declared as:<br>&gt; <br>&gt; extension NSError {<br>&gt;   @available(OSX 10.11, iOS 9.0, tvOS 9.0, watchOS 2.0, *)<br>&gt;   class func setUserInfoValueProvider(forDomain errorDomain: String,<br>&gt;                                       provider: ((NSError, String) -&gt; AnyObject?)? = nil)<br>&gt; }<br>&gt; The runtime would need to register a user info value provider for each error type the first time it is bridged into NSError, supplying the domain and the following user info value provider function:<br>&gt; <br>&gt; func userInfoValueProvider(nsError: NSError, key: String) -&gt; AnyObject? {<br>&gt;   let error = nsError as! Error<br>&gt;   switch key {<br>&gt;   case NSLocalizedDescriptionKey:<br>&gt;     return (error as? LocalizedError)?.errorDescription<br>&gt; <br>&gt;   case NSLocalizedFailureReasonErrorKey:<br>&gt;     return (error as? LocalizedError)?.failureReason<br>&gt; <br>&gt;   case NSLocalizedRecoverySuggestionErrorKey:<br>&gt;     return (error as? LocalizedError)?.recoverySuggestion<br>&gt; <br>&gt;   case NSHelpAnchorErrorKey:<br>&gt;     return (error as? LocalizedError)?.helpAnchor<br>&gt; <br>&gt;   case NSLocalizedRecoveryOptionsErrorKey:<br>&gt;     return (error as? RecoverableError)?.recoveryOptions<br>&gt; <br>&gt;   case NSRecoveryAttempterErrorKey:<br>&gt;     return error is RecoverableError ? RecoveryAttempter() : nil<br>&gt; <br>&gt;   default:<br>&gt;     guard let customUserInfoError = error as? CustomNSError else { return nil }<br>&gt;     return customUserInfoError.userInfo[key]<br>&gt;   }<br>&gt; }<br>&gt; On platforms that predate the introduction of user info value providers, there are alternate implementation strategies, including introducing a custom NSDictionary subclass to use as the userInfo in the NSError that lazily populates the dictionary by, effectively, calling the userInfoValueProvider function above for each requested key. Or, one could eagerly populate userInfo on older platforms.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#importing-error-types-from-objective-c&gt;Importing error types from Objective-C<br>&gt; <br>&gt; In Objective-C, error domains are typically constructed using an enumeration describing the error codes and a constant describing the error domain, e.g,<br>&gt; <br>&gt; extern NSString *const AVFoundationErrorDomain;<br>&gt; <br>&gt; typedef NS_ENUM(NSInteger, AVError) {<br>&gt;   AVErrorUnknown                                      = -11800,<br>&gt;   AVErrorOutOfMemory                                  = -11801,<br>&gt;   AVErrorSessionNotRunning                            = -11803,<br>&gt;   AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;   // ...<br>&gt; }<br>&gt; This is currently imported as an enum that conforms to Error:<br>&gt; <br>&gt; enum AVError : Int {<br>&gt;   case unknown                                      = -11800<br>&gt;   case outOfMemory                                  = -11801<br>&gt;   case sessionNotRunning                            = -11803<br>&gt;   case deviceAlreadyUsedByAnotherSession            = -11804<br>&gt; <br>&gt;   static var _domain: String { return AVFoundationErrorDomain }<br>&gt; }<br>&gt; and Swift code introduces an extension that makes it an Error, along with some implementation magic to allow bridging from an NSError (losing userInfo in the process):<br>&gt; <br>&gt; extension AVError : Error {<br>&gt;   static var _domain: String { return AVFoundationErrorDomain }<br>&gt; }<br>&gt; Instead, error enums should be expressed with a new macro, NS_ERROR_ENUM, that ties together the code and domain in the Objective-C header:<br>&gt; <br>&gt; extern NSString *const AVFoundationErrorDomain;<br>&gt; <br>&gt; typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>&gt;   AVErrorUnknown                                      = -11800,<br>&gt;   AVErrorOutOfMemory                                  = -11801,<br>&gt;   AVErrorSessionNotRunning                            = -11803,<br>&gt;   AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;   // ...<br>&gt; }<br>&gt; This will import as a new struct AVError that contains an NSError, so there is no information loss. The actual enum will become a nested type Code, so that it is still accessible. The resulting struct will be as follows:<br>&gt; <br>&gt; struct AVError {<br>&gt;   /// Stored NSError. Note that error.domain == AVFoundationErrorDomain is an invariant.<br>&gt;   private var error: NSError<br>&gt; <br>&gt;   /// Describes the error codes; directly imported from AVError<br>&gt;   enum Code : Int, ErrorCodeProtocol {<br>&gt;     typealias ErrorType = AVError<br>&gt; <br>&gt;     case unknown                                      = -11800<br>&gt;     case outOfMemory                                  = -11801<br>&gt;     case sessionNotRunning                            = -11803<br>&gt;     case deviceAlreadyUsedByAnotherSession            = -11804<br>&gt; <br>&gt;     func errorMatchesCode(_ error: AVError) -&gt; Bool {<br>&gt;       return error.code == self<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt;   /// Allow one to create an error (optionally) with a userInfo dictionary.<br>&gt;   init(_ code: Code, userInfo: [NSObject: AnyObject] = [:]) {<br>&gt;     error = NSError(code: code.rawValue, domain: _domain, userInfo: userInfo)<br>&gt;   }<br>&gt; <br>&gt;   /// Retrieve the code.<br>&gt;   var code: Code { return Code(rawValue: error.code)! }<br>&gt; <br>&gt;   /// Allow direct access to the userInfo dictionary.<br>&gt;   var userInfo: [NSObject: AnyObject] { return error.userInfo }<br>&gt; <br>&gt;   /// Make it easy to refer to constants without context.<br>&gt;   static let unknown: Code = .unknown<br>&gt;   static let outOfMemory: Code = .outOfMemory<br>&gt;   static let sessionNotRunning: Code = .sessionNotRunning<br>&gt;   static let deviceAlreadyUsedByAnotherSession: Code = .deviceAlreadyUsedByAnotherSession<br>&gt; }<br>&gt; <br>&gt; // Implementation detail: makes AVError conform to Error<br>&gt; extension AVError : Error {<br>&gt;   static var _domain: String { return AVFoundationErrorDomain }<br>&gt; <br>&gt;   var _code: Int { return error.code }<br>&gt; }<br>&gt; This syntax allows one to throw specific errors fairly easily, with or without userInfo dictionaries:<br>&gt; <br>&gt; throw AVError(.sessionNotRunning)<br>&gt; throw AVError(.sessionNotRunning, userInfo: [ ... ])<br>&gt; The ImportedErrorCode protocol is a helper so that we can define a general ~= operator, which is used by both switchcase matching and catch blocks:<br>&gt; <br>&gt; protocol ErrorCodeProtocol {<br>&gt;   typealias ErrorType : Error<br>&gt; <br>&gt;   func errorMatchesCode(_ error: ErrorType) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; func ~= &lt;EC: ErrorCodeProtocol&gt; (error: Error, code: EC) -&gt; Bool {<br>&gt;   guard let myError = error as? EC.ErrorType else { return false }<br>&gt;   return code.errorMatchesCode(myError)<br>&gt; }<br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-nserror-types-back-into-swift&gt;Mapping NSError types back into Swift<br>&gt; <br>&gt; When an NSError object bridged to an Error instance, it may be immediately mapped back to a Swift error type (e.g., if the error was created as a HomeworkError instance in Swift and then passed through NSError unmodified) or it might be leave as an instance of NSError. The error might then be catch as a particular Swift error type, e.g.,<br>&gt; <br>&gt; catch let error as AVError where error.code == .sessionNotRunning {<br>&gt;   // able to access userInfo here!<br>&gt; }<br>&gt; In this case, the mapping from an NSError instance to AVError goes through an implementation-detail protocol_ObjectiveCBridgeableError:<br>&gt; <br>&gt; protocol _ObjectiveCBridgeableError : Error {<br>&gt;   /// Produce a value of the error type corresponding to the given NSError,<br>&gt;   /// or return nil if it cannot be bridged.<br>&gt;   init?(_bridgedNSError error: NSError)<br>&gt; }<br>&gt; The initializer is responsible for checking the domain and (optionally) the code of the incoming NSError to map it to an instance of the Swift error type. For example, AVError would adopt this protocol as follows:<br>&gt; <br>&gt; // Implementation detail: makes AVError conform to _ObjectiveCBridgeableError<br>&gt; extension AVError : _ObjectiveCBridgeableError {<br>&gt;   init?(_bridgedNSError error: NSError) {<br>&gt;     // Check whether the error comes from the AVFoundation error domain<br>&gt;     if error.domain != AVFoundationErrorDomain { return nil }<br>&gt; <br>&gt;     // Save the error<br>&gt;     self.error = error<br>&gt;   }<br>&gt; }<br>&gt; We do not propose that _ObjectiveCBridgeableError become a public protocol, because the core team has already deferred a similar proposal (SE-0058 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md&gt;) to make the related protocol _ObjectiveCBridgeable public. <br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#other-issues&gt;Other Issues<br>&gt; <br>&gt; NSError codes and domains are important for localization of error messages. This is barely supported today by genstrings, but becomes considerably harder when the domain and code are hidden (as they are in Swift). We would need to consider tooling to make it easier to localize error descriptions, recovery options, etc. in a sensible way. Although this is out of the scope of the Swift language per se, it&#39;s an important part of the developer story.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This is a major source-breaking change for Objective-C APIs that operate on NSError values, because those parameter/return/property types will change from NSError to Error. There are ~400 such APIs in the macOS SDK, and closer to 500 in the iOS SDK, which is a sizable number. Fortunately, this is similar in scope to the Foundation value types proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;, and can use the same code migration mechanism. That said, the scale of this change means that it should either happen in Swift 3 or not at all.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#future-directions&gt;Future directions<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#better-tooling-for-describing-errors&gt;Better tooling for describing errors<br>&gt; <br>&gt; When adopting one of the new protocols (e.g., LocalizedError) in an enum, one will inevitably end up with a number of switch statements that have to enumerate all of the cases, leading to a lot of boilerplate. Better tooling could improve the situation considerably: for example, one could use something like Cocoa&#39;s stringsdict files &lt;https://developer.apple.com/library/prerelease/content/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html&gt; to provide localized strings identified by the enum name, case name, and property. That would eliminate the need for the switch-on-all-cases implementations of each property.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#round-tripping-errors-through-userinfo&gt;Round-tripping errors through userInfo<br>&gt; <br>&gt; The CustomNSError protocol allows one to place arbitrary key/value pairs into NSError&#39;s userInfo dictionary. The implementation-detail _ObjectiveCBridgeableError protocol allows one to control how a raw NSError is mapped to a particular error type. One could effectively serialize the entire state of a particular error type into the userInfo dictionary viaCustomNSError, then restore it via _ObjectiveCBridgeableError, allowing one to form a complete NSError in Objective-C that can reconstitute itself as a particular Swift error type, which can be useful both for mixed-source projects and (possibly) as a weak form of serialization for NSErrors.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#exposing-the-domain-code-and-user-info-dictionary-directly&gt;Exposing the domain, code, and user-info dictionary directly<br>&gt; <br>&gt; This proposal does not directly expose the domain, code, or user-info dictionary on ErrorProtocol, because these notions are superseded by Swift&#39;s strong typing of errors. The domain is effectively subsumed by the type of the error (e.g., a Swift-defined error type uses its mangled name as the domain); the code is some type-specific value (e.g., the discriminator of the enum); and the user-info dictionary is an untyped set of key-value pairs that are better expressed in Swift as data on the specific error type.<br>&gt; <br>&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#bridging-nserror-to-a-new-value-type-error&gt;Bridging NSError to a new value type Error<br>&gt; <br>&gt; One could introduce a new value type, Error, that stores a domain, code, and user-info dictionary but provides them with value semantics. Doing so would make it easier to create &quot;generic&quot; errors that carry some information. However, we feel that introducing new error types in Swift is already easier than establishing a new domain and a set of codes, because a new enum type provides this information naturally in Swift.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/108ab897/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>I agree with Charles about removing the “NSError” bit from the name, but otherwise this looks fantastic. By my “would I be excited to use this in Swift” metric, this is definitely a welcome addition.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Jun 27, 2016, at 4:54 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Obviously, I’m in favor of this one. +1!<br>&gt; <br>&gt; I think I did prefer the older name of CustomUserInfoError for the domain/code/userInfo protocol, rather than CustomNSError. This is just because I’d like to be able to do a global search through my project for “NSError” and have it turn up empty. Maybe a silly reason, I know. ;-)<br>&gt; <br>&gt; I sent a few more comments off-list before I realized you’d posted the proposal already, so you can peruse, consider, and/or discard those at your leisure. It’s nothing terribly important, though; this proposal is pretty great as is.<br>&gt; <br>&gt; Thanks so much for doing this! I’m really excited for better error handling in Swift 3.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 1:17 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Proposal link: https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md&gt;<br>&gt;&gt; <br>&gt;&gt; Here is a detailed proposal draft for bridging NSError to ErrorProtocol. Getting this right is surprisingly involved, so the detailed design on this proposal is fairly large. Comments welcome!<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; NSError Bridging<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/NNNN-nserror-bridging.md&gt;<br>&gt;&gt; Author: Doug Gregor &lt;https://github.com/DougGregor&gt;, Charles Srstka &lt;https://github.com/CharlesJS&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift&#39;s error handling model interoperates directly with Cocoa&#39;s NSError conventions. For example, an Objective-C method with an NSError** parameter, e.g.,<br>&gt;&gt; <br>&gt;&gt; - (nullable NSURL *)replaceItemAtURL:(NSURL *)url options:(NSFileVersionReplacingOptions)options error:(NSError **)error;<br>&gt;&gt; will be imported as a throwing method:<br>&gt;&gt; <br>&gt;&gt; func replaceItem(at url: URL, options: ReplacingOptions = []) throws -&gt; URL<br>&gt;&gt; Swift bridges between ErrorProtocol-conforming types and NSError so, for example, a Swift enum that conforms toErrorProtocol can be thrown and will be reflected as an NSError with a suitable domain and code. Moreover, an NSErrorproduced with that domain and code can be caught as the Swift enum type, providing round-tripping so that Swift can deal in ErrorProtocol values while Objective-C deals in NSError objects.<br>&gt;&gt; <br>&gt;&gt; However, the interoperability is incomplete in a number of ways, which results in Swift programs having to walk a careful line between the ErrorProtocol-based Swift way and the NSError-based way. This proposal attempts to bridge those gaps.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Charles Srstka&#39;s pitch for Consistent bridging for NSErrors at the language boundary &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016618.html&gt;, which discussed Charles&#39; original proposal &lt;https://github.com/apple/swift-evolution/pull/331&gt; that addressed these issues by providing NSError to ErrorProtocol bridging and exposing the domain, code, and user-info dictionary for all errors. This proposal expands upon that work, but without directly exposing the domain, code, and user-info.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; There are a number of weaknesses in Swift&#39;s interoperability with Cocoa&#39;s error model, including:<br>&gt;&gt; <br>&gt;&gt; There is no good way to provide important error information when throwing an error from Swift. For example, let&#39;s consider a simple application-defined error in Swift:<br>&gt;&gt; <br>&gt;&gt; enum HomeworkError : Int, ErrorProtocol {<br>&gt;&gt;   case forgotten<br>&gt;&gt;   case lost<br>&gt;&gt;   case dogAteIt<br>&gt;&gt; }<br>&gt;&gt; One can throw HomeworkError.dogAteIt and it can be interpreted as an NSError by Objective-C with an appropriate error domain (effectively, the mangled name of the HomeworkError type) and code (effectively, the case discriminator). However, one cannot provide a localized description, help anchor, recovery attempter, or any other information commonly placed into the userInfo dictionary of an NSError. To provide these values, one must specifically construct an NSError in Swift, e.g.,<br>&gt;&gt; <br>&gt;&gt; throw NSError(code: HomeworkError.dogAteIt.rawValue,<br>&gt;&gt;               domain: HomeworkError._domain,<br>&gt;&gt;               userInfo: [ NSLocalizedDescriptionKey : &quot;the dog ate it&quot; ])<br>&gt;&gt; There is no good way to get information typically associated with NSError&#39;s userInfo in Swift. For example, the Swift-natural way to catch a specific error in the AVError error domain doesn&#39;t give one access to the userInfo dictionary, e.g.,:<br>&gt;&gt; <br>&gt;&gt; catch let error as AVError where error == .diskFull {<br>&gt;&gt;   // AVError is an enum, so one only gets the equivalent of the code.<br>&gt;&gt;   // There is no way to access the localized description (for example) or<br>&gt;&gt;   // any other information typically stored in the ``userInfo`` dictionary.<br>&gt;&gt; }<br>&gt;&gt; The workaround is to catch as an NSError, which is quite a bit more ugly:<br>&gt;&gt; <br>&gt;&gt; catch let error as NSError where error._domain == AVFoundationErrorDomain &amp;&amp; error._code == AVFoundationErrorDomain.diskFull.rawValue {<br>&gt;&gt;   // okay: userInfo is finally accessible, but still weakly typed<br>&gt;&gt; }<br>&gt;&gt; This makes it extremely hard to access common information, such as the localized description. Moreover, the userInfo dictionary is effectively untyped so, for example, one has to know a priori that the value associated with the known AVErrorDeviceKey will be typed as CMTime:<br>&gt;&gt; <br>&gt;&gt; catch let error as NSError where error._domain = AVFoundationErrorDomain {<br>&gt;&gt;   if let time = error.userInfo[AVErrorDeviceKey] as? CMTime {<br>&gt;&gt;     // ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; It would be far better if one could catch an AVError directly and query the time in a type-safe manner:<br>&gt;&gt; <br>&gt;&gt; catch let error as AVError {<br>&gt;&gt;   if let time = error.time {<br>&gt;&gt;     // ...<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; NSError is inconsistently bridged with ErrorProtocol. Swift interoperates by translating between NSError and ErrorProtocol when mapping between a throwing Swift method/initializer and an Objective-C method with an NSError** parameter. However, an Objective-C method that takes an NSError* parameter (e.g., to render it) does not bridge to ErrorProtocol, meaning that NSError is part of the API in Swift in some places (but not others). For example, NSError leaks through when the following UIDocument API in Objective-C:<br>&gt;&gt; <br>&gt;&gt; - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>&gt;&gt; is imported into Swift as follows:<br>&gt;&gt; <br>&gt;&gt; func handleError(_ error: NSError, userInteractionPermitted: Bool)<br>&gt;&gt; One would expect the first parameter to be imported as ErrorProtocol. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal involves directly addressing (1)-(3) with new protocols and a different way of bridging Objective-C error code types into Swift, along with some conveniences for working with Cocoa errors:<br>&gt;&gt; <br>&gt;&gt; Introduce three new protocols for describing more information about errors: LocalizedError, RecoverableError, andCustomNSError. For example, an error type can provide a localized description by conforming to LocalizedError:<br>&gt;&gt; <br>&gt;&gt; extension HomeworkError : LocalizedError {<br>&gt;&gt;   var errorDescription: String? {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case .forgotten: return NSLocalizedString(&quot;I forgot it&quot;)<br>&gt;&gt;     case .lost: return NSLocalizedString(&quot;I lost it&quot;)<br>&gt;&gt;     case .dogAteIt: return NSLocalizedString(&quot;The dog ate it&quot;)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Imported Objective-C error types should be mapped to struct types that store an NSError so that no information is lost when bridging from an NSError to the Swift error types. We propose to introduce a new macro, NS_ERROR_ENUM, that one can use to both declare an enumeration type used to describe the error codes as well as tying that type to a specific domain constant, e.g.,<br>&gt;&gt; <br>&gt;&gt; typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>&gt;&gt;   AVErrorUnknown                                      = -11800,<br>&gt;&gt;   AVErrorOutOfMemory                                  = -11801,<br>&gt;&gt;   AVErrorSessionNotRunning                            = -11803,<br>&gt;&gt;   AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; The imported AVError will have a struct that allows one to access the userInfo dictionary directly. This retains the ability to catch via a specific code, e.g.,<br>&gt;&gt; <br>&gt;&gt; catch AVError.outOfMemory {<br>&gt;&gt;  // ...<br>&gt;&gt; }<br>&gt;&gt; However, catching a specific error as a value doesn&#39;t lose information:<br>&gt;&gt; <br>&gt;&gt; catch let error as AVError where error.code == .sessionNotRunning {<br>&gt;&gt;  // able to access userInfo here!<br>&gt;&gt; }<br>&gt;&gt; This also gives the ability for one to add typed accessors for known keys within the userInfo dictionary:<br>&gt;&gt; <br>&gt;&gt; extension AVError {<br>&gt;&gt;  var time: CMTime? {<br>&gt;&gt;    get {<br>&gt;&gt;      return userInfo[AVErrorTimeKey] as? CMTime?<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    set {<br>&gt;&gt;      userInfo[AVErrorTimeKey] = newValue.map { $0 as CMTime }<br>&gt;&gt;    }<br>&gt;&gt;  }<br>&gt;&gt; }<br>&gt;&gt; Bridge NSError to ErrorProtocol, so that all NSError uses are bridged consistently. For example, this means that the Objective-C API:<br>&gt;&gt; <br>&gt;&gt; - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>&gt;&gt; is imported into Swift as:<br>&gt;&gt; <br>&gt;&gt; func handleError(_ error: ErrorProtocol, userInteractionPermitted: Bool)<br>&gt;&gt; This will use the same bridging logic in the Clang importer that we use for other value types (Array, String, URL, etc.), but with the runtime translation we&#39;ve already been doing for catching/throwing errors.<br>&gt;&gt; <br>&gt;&gt; When we introduce this bridging, we will need to remove NSError&#39;s conformance to ErrorProtocol to avoid creating cyclic implicit conversions. However, we still need an easy way to create an ErrorProtocol instance from an arbitrary NSError, e.g.,<br>&gt;&gt; <br>&gt;&gt; extension NSError {<br>&gt;&gt;   var asError: ErrorProtocol { ... }<br>&gt;&gt; }<br>&gt;&gt; In Foundation, add an extension to ErrorProtocol that provides typed access to the common user-info keys. Note that we focus only on those user-info keys that are read by user code (vs. only accessed by frameworks):<br>&gt;&gt; <br>&gt;&gt; extension ErrorProtocol {<br>&gt;&gt;   // Note: for exposition only. Not actual API.<br>&gt;&gt;   private var userInfo: [NSObject : AnyObject] {<br>&gt;&gt;     return (self as! NSError).userInfo<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var localizedDescription: String {<br>&gt;&gt;     return (self as! NSError).localizedDescription<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var filePath: String? {<br>&gt;&gt;     return userInfo[NSFilePathErrorKey] as? String<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var stringEncoding: String.Encoding? {<br>&gt;&gt;     return (userInfo[NSStringEncodingErrorKey] as? NSNumber)<br>&gt;&gt;              .map { String.Encoding(rawValue: $0.uintValue) }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var underlying: ErrorProtocol? {<br>&gt;&gt;     return (userInfo[NSUnderlyingErrorKey] as? NSError)?.asError<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   var url: URL? {<br>&gt;&gt;     return userInfo[NSURLErrorKey] as? URL<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Rename ErrorProtocol to Error: once we&#39;ve completed the bridging story, Error becomes the primary way to work with error types in Swift, and the value type to which NSError is bridged:<br>&gt;&gt; <br>&gt;&gt; func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; This section details both the design (including the various new protocols, mapping from Objective-C error code enumeration types into Swift types, etc.) and the efficient implementation of this design to interoperate with NSError. Throughout the detailed design, we already assume the name change from ErrorProtocol to Error.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#new-protocols&gt;New protocols<br>&gt;&gt; <br>&gt;&gt; This proposal introduces several new protocols that allow error types to expose more information about error types.<br>&gt;&gt; <br>&gt;&gt; The LocalizedError protocol describes an error that provides localized messages for display to the end user, all of which provide default implementations. The conforming type can provide implementations for any subset of these requirements:<br>&gt;&gt; <br>&gt;&gt; protocol LocalizedError : Error {<br>&gt;&gt;   /// A localized message describing what error occurred.<br>&gt;&gt;   var errorDescription: String? { get }<br>&gt;&gt; <br>&gt;&gt;   /// A localized message describing the reason for the failure.<br>&gt;&gt;   var failureReason: String? { get }<br>&gt;&gt; <br>&gt;&gt;   /// A localized message describing how one might recover from the failure.<br>&gt;&gt;   var recoverySuggestion: String? { get }<br>&gt;&gt; <br>&gt;&gt;   /// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt;&gt;   var helpAnchor: String? { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension LocalizedError {<br>&gt;&gt;   var errorDescription: String? { return nil }<br>&gt;&gt;   var failureReason: String? { return nil }<br>&gt;&gt;   var recoverySuggestion: String? { return nil }<br>&gt;&gt;   var helpAnchor: String? { return nil }<br>&gt;&gt; }<br>&gt;&gt; The RecoverableError protocol describes an error that might be recoverable: <br>&gt;&gt; <br>&gt;&gt; protocol RecoverableError : Error {<br>&gt;&gt;   /// Provides a set of possible recovery options to present to the user.<br>&gt;&gt;   var recoveryOptions: [String] { get }<br>&gt;&gt; <br>&gt;&gt;   /// Attempt to recover from this error when the user selected the<br>&gt;&gt;   /// option at the given index. This routine must call resultHandler and<br>&gt;&gt;   /// indicate whether recovery was successful (or not).<br>&gt;&gt;   ///<br>&gt;&gt;   /// This entry point is used for recovery of errors handled at a<br>&gt;&gt;   /// &quot;document&quot; granularity, that do not affect the entire<br>&gt;&gt;   /// application.<br>&gt;&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>&gt;&gt;                        andThen resultHandler: (recovered: Bool) -&gt; Void)<br>&gt;&gt; <br>&gt;&gt;   /// Attempt to recover from this error when the user selected the<br>&gt;&gt;   /// option at the given index. Returns true to indicate<br>&gt;&gt;   /// successful recovery, and false otherwise.<br>&gt;&gt;   ///<br>&gt;&gt;   /// This entry point is used for recovery of errors handled at<br>&gt;&gt;   /// the &quot;application&quot; granularity, where nothing else in the<br>&gt;&gt;   /// application can proceed until the attmpted error recovery<br>&gt;&gt;   /// completes.<br>&gt;&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension RecoverableError {<br>&gt;&gt;   /// By default, implements document-modal recovery via application-model<br>&gt;&gt;   /// recovery.<br>&gt;&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>&gt;&gt;                        andThen resultHandler: (Bool) -&gt; Void) {<br>&gt;&gt;     resultHandler(recovered: attemptRecovery(optionIndex: recoveryOptionIndex))<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; Error types that conform to RecoverableError may be given an opportunity to recover from the error. The user can be presented with some number of (localized) recovery options, described by recoveryOptions, and the selected option will be passed to the appropriate attemptRecovery method.<br>&gt;&gt; <br>&gt;&gt; The CustomNSError protocol describes an error that wants to provide custom NSError information. This can be used, e.g., to provide a specific domain/code or to populate NSError&#39;s userInfo dictionary with values for custom keys that can be accessed from Objective-C code but are not covered by the other protocols.<br>&gt;&gt; <br>&gt;&gt; /// Describes an error type that fills in the userInfo directly.<br>&gt;&gt; protocol CustomNSError : Error {<br>&gt;&gt;   var errorDomain: String { get }<br>&gt;&gt;   var errorCode: Int { get }<br>&gt;&gt;   var errorUserInfo: [String : AnyObject] { get }<br>&gt;&gt; }<br>&gt;&gt; Note that, unlike with NSError, the provided errorUserInfo requires String keys. This is in line with common practice for NSError and is important for the implementation (see below). All of these properties are defaulted, so one can provide any subset:<br>&gt;&gt; <br>&gt;&gt; extension CustomNSError {<br>&gt;&gt;   var errorDomain: String { ... }<br>&gt;&gt;   var errorCode: Int { ... }<br>&gt;&gt;   var errorUserInfo: [String : AnyObject] { ... }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-error-types-to-nserror&gt;Mapping error types to NSError<br>&gt;&gt; <br>&gt;&gt; Every type that conforms to the Error protocol is implicitly bridged to NSError. This has been the case since Swift 2, where the compiler provides a domain (i.e., the mangled name of the type) and code (based on the discriminator of the enumeration type). This proposal also allows for the userInfo dictionary to be populated by the runtime, which will check for conformance to the various protocols (LocalizedError, RecoverableError, or CustomNSError) to retrieve information.<br>&gt;&gt; <br>&gt;&gt; Conceptually, this could be implemented by eagerly creating a userInfo dictionary for a given instance of Error:<br>&gt;&gt; <br>&gt;&gt; func createUserInfo(error: Error) -&gt; [NSObject : AnyObject] {<br>&gt;&gt;   var userInfo: [NSObject : AnyObject] = [:]<br>&gt;&gt; <br>&gt;&gt;   // Retrieve custom userInfo information.<br>&gt;&gt;   if let customUserInfoError = error as? CustomNSError {<br>&gt;&gt;     userInfo = customUserInfoError.userInfo<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   if let localizedError = error as? LocalizedError {<br>&gt;&gt;     if let description = localizedError.errorDescription {<br>&gt;&gt;       userInfo[NSLocalizedDescriptionKey] = description<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     if let reason = localizedError.failureReason {<br>&gt;&gt;       userInfo[NSLocalizedFailureReasonErrorKey] = reason<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     if let suggestion = localizedError.recoverySuggestion {   <br>&gt;&gt;       userInfo[NSLocalizedRecoverySuggestionErrorKey] = suggestion<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     if let helpAnchor = localizedError.helpAnchor {   <br>&gt;&gt;       userInfo[NSHelpAnchorErrorKey] = helpAnchor<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   if let recoverableError = error as? RecoverableError {<br>&gt;&gt;     userInfo[NSLocalizedRecoveryOptionsErrorKey] = recoverableError.recoveryOptions<br>&gt;&gt;     userInfo[NSRecoveryAttempterErrorKey] = RecoveryAttempter()<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; The RecoveryAttempter class is an implementation detail. It will implement the informal protocol NSErrorRecoveryAttempting &lt;https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Protocols/NSErrorRecoveryAttempting_Protocol/&gt; for the given error:<br>&gt;&gt; <br>&gt;&gt; class RecoveryAttempter : NSObject {<br>&gt;&gt;   @objc(attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:)<br>&gt;&gt;   func attemptRecovery(fromError nsError: NSError,<br>&gt;&gt;                        optionIndex recoveryOptionIndex: Int,<br>&gt;&gt;                        delegate: AnyObject?,<br>&gt;&gt;                        didRecoverSelector: Selector,<br>&gt;&gt;                        contextInfo: UnsafeMutablePointer&lt;Void&gt;) {<br>&gt;&gt;     let error = nsError as! RecoverableError<br>&gt;&gt;     error.attemptRecovery(optionIndex: recoveryOptionIndex) { success in<br>&gt;&gt;       // Exposition only: this part will actually have to be<br>&gt;&gt;       // implemented in Objective-C to pass the BOOL and void* through.<br>&gt;&gt;       delegate?.perform(didRecoverSelector, with: success, with: contextInfo)<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   @objc(attemptRecoveryFromError:optionIndex:)<br>&gt;&gt;   func attemptRecovery(fromError nsError: NSError,<br>&gt;&gt;                        optionIndex recoveryOptionIndex: Int) -&gt; Bool {<br>&gt;&gt;     let error = nsError as! RecoverableError<br>&gt;&gt;     return error.attemptRecovery(optionIndex: recoveryOptionIndex)<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; The actual the population of the userInfo dictionary should not be eager. NSError provides the notion of global &quot;user info value providers&quot; that it uses to lazily request the values for certain keys, via setUserInfoValueProvider(forDomain:provider:), which is declared as:<br>&gt;&gt; <br>&gt;&gt; extension NSError {<br>&gt;&gt;   @available(OSX 10.11, iOS 9.0, tvOS 9.0, watchOS 2.0, *)<br>&gt;&gt;   class func setUserInfoValueProvider(forDomain errorDomain: String,<br>&gt;&gt;                                       provider: ((NSError, String) -&gt; AnyObject?)? = nil)<br>&gt;&gt; }<br>&gt;&gt; The runtime would need to register a user info value provider for each error type the first time it is bridged into NSError, supplying the domain and the following user info value provider function:<br>&gt;&gt; <br>&gt;&gt; func userInfoValueProvider(nsError: NSError, key: String) -&gt; AnyObject? {<br>&gt;&gt;   let error = nsError as! Error<br>&gt;&gt;   switch key {<br>&gt;&gt;   case NSLocalizedDescriptionKey:<br>&gt;&gt;     return (error as? LocalizedError)?.errorDescription<br>&gt;&gt; <br>&gt;&gt;   case NSLocalizedFailureReasonErrorKey:<br>&gt;&gt;     return (error as? LocalizedError)?.failureReason<br>&gt;&gt; <br>&gt;&gt;   case NSLocalizedRecoverySuggestionErrorKey:<br>&gt;&gt;     return (error as? LocalizedError)?.recoverySuggestion<br>&gt;&gt; <br>&gt;&gt;   case NSHelpAnchorErrorKey:<br>&gt;&gt;     return (error as? LocalizedError)?.helpAnchor<br>&gt;&gt; <br>&gt;&gt;   case NSLocalizedRecoveryOptionsErrorKey:<br>&gt;&gt;     return (error as? RecoverableError)?.recoveryOptions<br>&gt;&gt; <br>&gt;&gt;   case NSRecoveryAttempterErrorKey:<br>&gt;&gt;     return error is RecoverableError ? RecoveryAttempter() : nil<br>&gt;&gt; <br>&gt;&gt;   default:<br>&gt;&gt;     guard let customUserInfoError = error as? CustomNSError else { return nil }<br>&gt;&gt;     return customUserInfoError.userInfo[key]<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; On platforms that predate the introduction of user info value providers, there are alternate implementation strategies, including introducing a custom NSDictionary subclass to use as the userInfo in the NSError that lazily populates the dictionary by, effectively, calling the userInfoValueProvider function above for each requested key. Or, one could eagerly populate userInfo on older platforms.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#importing-error-types-from-objective-c&gt;Importing error types from Objective-C<br>&gt;&gt; <br>&gt;&gt; In Objective-C, error domains are typically constructed using an enumeration describing the error codes and a constant describing the error domain, e.g,<br>&gt;&gt; <br>&gt;&gt; extern NSString *const AVFoundationErrorDomain;<br>&gt;&gt; <br>&gt;&gt; typedef NS_ENUM(NSInteger, AVError) {<br>&gt;&gt;   AVErrorUnknown                                      = -11800,<br>&gt;&gt;   AVErrorOutOfMemory                                  = -11801,<br>&gt;&gt;   AVErrorSessionNotRunning                            = -11803,<br>&gt;&gt;   AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; This is currently imported as an enum that conforms to Error:<br>&gt;&gt; <br>&gt;&gt; enum AVError : Int {<br>&gt;&gt;   case unknown                                      = -11800<br>&gt;&gt;   case outOfMemory                                  = -11801<br>&gt;&gt;   case sessionNotRunning                            = -11803<br>&gt;&gt;   case deviceAlreadyUsedByAnotherSession            = -11804<br>&gt;&gt; <br>&gt;&gt;   static var _domain: String { return AVFoundationErrorDomain }<br>&gt;&gt; }<br>&gt;&gt; and Swift code introduces an extension that makes it an Error, along with some implementation magic to allow bridging from an NSError (losing userInfo in the process):<br>&gt;&gt; <br>&gt;&gt; extension AVError : Error {<br>&gt;&gt;   static var _domain: String { return AVFoundationErrorDomain }<br>&gt;&gt; }<br>&gt;&gt; Instead, error enums should be expressed with a new macro, NS_ERROR_ENUM, that ties together the code and domain in the Objective-C header:<br>&gt;&gt; <br>&gt;&gt; extern NSString *const AVFoundationErrorDomain;<br>&gt;&gt; <br>&gt;&gt; typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>&gt;&gt;   AVErrorUnknown                                      = -11800,<br>&gt;&gt;   AVErrorOutOfMemory                                  = -11801,<br>&gt;&gt;   AVErrorSessionNotRunning                            = -11803,<br>&gt;&gt;   AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;&gt;   // ...<br>&gt;&gt; }<br>&gt;&gt; This will import as a new struct AVError that contains an NSError, so there is no information loss. The actual enum will become a nested type Code, so that it is still accessible. The resulting struct will be as follows:<br>&gt;&gt; <br>&gt;&gt; struct AVError {<br>&gt;&gt;   /// Stored NSError. Note that error.domain == AVFoundationErrorDomain is an invariant.<br>&gt;&gt;   private var error: NSError<br>&gt;&gt; <br>&gt;&gt;   /// Describes the error codes; directly imported from AVError<br>&gt;&gt;   enum Code : Int, ErrorCodeProtocol {<br>&gt;&gt;     typealias ErrorType = AVError<br>&gt;&gt; <br>&gt;&gt;     case unknown                                      = -11800<br>&gt;&gt;     case outOfMemory                                  = -11801<br>&gt;&gt;     case sessionNotRunning                            = -11803<br>&gt;&gt;     case deviceAlreadyUsedByAnotherSession            = -11804<br>&gt;&gt; <br>&gt;&gt;     func errorMatchesCode(_ error: AVError) -&gt; Bool {<br>&gt;&gt;       return error.code == self<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Allow one to create an error (optionally) with a userInfo dictionary.<br>&gt;&gt;   init(_ code: Code, userInfo: [NSObject: AnyObject] = [:]) {<br>&gt;&gt;     error = NSError(code: code.rawValue, domain: _domain, userInfo: userInfo)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   /// Retrieve the code.<br>&gt;&gt;   var code: Code { return Code(rawValue: error.code)! }<br>&gt;&gt; <br>&gt;&gt;   /// Allow direct access to the userInfo dictionary.<br>&gt;&gt;   var userInfo: [NSObject: AnyObject] { return error.userInfo }<br>&gt;&gt; <br>&gt;&gt;   /// Make it easy to refer to constants without context.<br>&gt;&gt;   static let unknown: Code = .unknown<br>&gt;&gt;   static let outOfMemory: Code = .outOfMemory<br>&gt;&gt;   static let sessionNotRunning: Code = .sessionNotRunning<br>&gt;&gt;   static let deviceAlreadyUsedByAnotherSession: Code = .deviceAlreadyUsedByAnotherSession<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Implementation detail: makes AVError conform to Error<br>&gt;&gt; extension AVError : Error {<br>&gt;&gt;   static var _domain: String { return AVFoundationErrorDomain }<br>&gt;&gt; <br>&gt;&gt;   var _code: Int { return error.code }<br>&gt;&gt; }<br>&gt;&gt; This syntax allows one to throw specific errors fairly easily, with or without userInfo dictionaries:<br>&gt;&gt; <br>&gt;&gt; throw AVError(.sessionNotRunning)<br>&gt;&gt; throw AVError(.sessionNotRunning, userInfo: [ ... ])<br>&gt;&gt; The ImportedErrorCode protocol is a helper so that we can define a general ~= operator, which is used by both switchcase matching and catch blocks:<br>&gt;&gt; <br>&gt;&gt; protocol ErrorCodeProtocol {<br>&gt;&gt;   typealias ErrorType : Error<br>&gt;&gt; <br>&gt;&gt;   func errorMatchesCode(_ error: ErrorType) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ~= &lt;EC: ErrorCodeProtocol&gt; (error: Error, code: EC) -&gt; Bool {<br>&gt;&gt;   guard let myError = error as? EC.ErrorType else { return false }<br>&gt;&gt;   return code.errorMatchesCode(myError)<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-nserror-types-back-into-swift&gt;Mapping NSError types back into Swift<br>&gt;&gt; <br>&gt;&gt; When an NSError object bridged to an Error instance, it may be immediately mapped back to a Swift error type (e.g., if the error was created as a HomeworkError instance in Swift and then passed through NSError unmodified) or it might be leave as an instance of NSError. The error might then be catch as a particular Swift error type, e.g.,<br>&gt;&gt; <br>&gt;&gt; catch let error as AVError where error.code == .sessionNotRunning {<br>&gt;&gt;   // able to access userInfo here!<br>&gt;&gt; }<br>&gt;&gt; In this case, the mapping from an NSError instance to AVError goes through an implementation-detail protocol_ObjectiveCBridgeableError:<br>&gt;&gt; <br>&gt;&gt; protocol _ObjectiveCBridgeableError : Error {<br>&gt;&gt;   /// Produce a value of the error type corresponding to the given NSError,<br>&gt;&gt;   /// or return nil if it cannot be bridged.<br>&gt;&gt;   init?(_bridgedNSError error: NSError)<br>&gt;&gt; }<br>&gt;&gt; The initializer is responsible for checking the domain and (optionally) the code of the incoming NSError to map it to an instance of the Swift error type. For example, AVError would adopt this protocol as follows:<br>&gt;&gt; <br>&gt;&gt; // Implementation detail: makes AVError conform to _ObjectiveCBridgeableError<br>&gt;&gt; extension AVError : _ObjectiveCBridgeableError {<br>&gt;&gt;   init?(_bridgedNSError error: NSError) {<br>&gt;&gt;     // Check whether the error comes from the AVFoundation error domain<br>&gt;&gt;     if error.domain != AVFoundationErrorDomain { return nil }<br>&gt;&gt; <br>&gt;&gt;     // Save the error<br>&gt;&gt;     self.error = error<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; We do not propose that _ObjectiveCBridgeableError become a public protocol, because the core team has already deferred a similar proposal (SE-0058 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0058-objectivecbridgeable.md&gt;) to make the related protocol _ObjectiveCBridgeable public. <br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#other-issues&gt;Other Issues<br>&gt;&gt; <br>&gt;&gt; NSError codes and domains are important for localization of error messages. This is barely supported today by genstrings, but becomes considerably harder when the domain and code are hidden (as they are in Swift). We would need to consider tooling to make it easier to localize error descriptions, recovery options, etc. in a sensible way. Although this is out of the scope of the Swift language per se, it&#39;s an important part of the developer story.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is a major source-breaking change for Objective-C APIs that operate on NSError values, because those parameter/return/property types will change from NSError to Error. There are ~400 such APIs in the macOS SDK, and closer to 500 in the iOS SDK, which is a sizable number. Fortunately, this is similar in scope to the Foundation value types proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0069-swift-mutability-for-foundation.md&gt;, and can use the same code migration mechanism. That said, the scale of this change means that it should either happen in Swift 3 or not at all.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#future-directions&gt;Future directions<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#better-tooling-for-describing-errors&gt;Better tooling for describing errors<br>&gt;&gt; <br>&gt;&gt; When adopting one of the new protocols (e.g., LocalizedError) in an enum, one will inevitably end up with a number of switch statements that have to enumerate all of the cases, leading to a lot of boilerplate. Better tooling could improve the situation considerably: for example, one could use something like Cocoa&#39;s stringsdict files &lt;https://developer.apple.com/library/prerelease/content/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html&gt; to provide localized strings identified by the enum name, case name, and property. That would eliminate the need for the switch-on-all-cases implementations of each property.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#round-tripping-errors-through-userinfo&gt;Round-tripping errors through userInfo<br>&gt;&gt; <br>&gt;&gt; The CustomNSError protocol allows one to place arbitrary key/value pairs into NSError&#39;s userInfo dictionary. The implementation-detail _ObjectiveCBridgeableError protocol allows one to control how a raw NSError is mapped to a particular error type. One could effectively serialize the entire state of a particular error type into the userInfo dictionary viaCustomNSError, then restore it via _ObjectiveCBridgeableError, allowing one to form a complete NSError in Objective-C that can reconstitute itself as a particular Swift error type, which can be useful both for mixed-source projects and (possibly) as a weak form of serialization for NSErrors.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#exposing-the-domain-code-and-user-info-dictionary-directly&gt;Exposing the domain, code, and user-info dictionary directly<br>&gt;&gt; <br>&gt;&gt; This proposal does not directly expose the domain, code, or user-info dictionary on ErrorProtocol, because these notions are superseded by Swift&#39;s strong typing of errors. The domain is effectively subsumed by the type of the error (e.g., a Swift-defined error type uses its mangled name as the domain); the code is some type-specific value (e.g., the discriminator of the enum); and the user-info dictionary is an untyped set of key-value pairs that are better expressed in Swift as data on the specific error type.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#bridging-nserror-to-a-new-value-type-error&gt;Bridging NSError to a new value type Error<br>&gt;&gt; <br>&gt;&gt; One could introduce a new value type, Error, that stores a domain, code, and user-info dictionary but provides them with value semantics. Doing so would make it easier to create &quot;generic&quot; errors that carry some information. However, we feel that introducing new error types in Swift is already easier than establishing a new domain and a set of codes, because a new enum type provides this information naturally in Swift.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/8cd3543e/attachment-0001.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>June 28, 2016 at 03:00:00pm</p></header><div class="content"><p>I did a quick read and this looks great! Thanks to you two for pulling this<br>together.<br></p><p>I will attempt a deeper read and comment as needed later today. I am<br>interested in helping with this as possible.<br></p><p>-Shawn<br></p><p>On Mon, Jun 27, 2016 at 2:41 PM Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi all,<br>&gt;<br>&gt; Proposal link:<br>&gt; https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md<br>&gt;<br>&gt; Here is a detailed proposal draft for bridging NSError to ErrorProtocol.<br>&gt; Getting this right is surprisingly involved, so the detailed design on this<br>&gt; proposal is fairly large. Comments welcome!<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt; NSError Bridging<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/NNNN-nserror-bridging.md&gt;<br>&gt;    - Author: Doug Gregor &lt;https://github.com/DougGregor&gt;, Charles Srstka<br>&gt;    &lt;https://github.com/CharlesJS&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift&#39;s error handling model interoperates directly with Cocoa&#39;s NSError<br>&gt; conventions. For example, an Objective-C method with an NSError** parameter,<br>&gt; e.g.,<br>&gt;<br>&gt; - (nullable NSURL *)replaceItemAtURL:(NSURL *)url options:(NSFileVersionReplacingOptions)options error:(NSError **)error;<br>&gt;<br>&gt; will be imported as a throwing method:<br>&gt;<br>&gt; func replaceItem(at url: URL, options: ReplacingOptions = []) throws -&gt; URL<br>&gt;<br>&gt; Swift bridges between ErrorProtocol-conforming types and NSError so, for<br>&gt; example, a Swift enum that conforms toErrorProtocol can be thrown and<br>&gt; will be reflected as an NSError with a suitable domain and code.<br>&gt; Moreover, an NSErrorproduced with that domain and code can be caught as<br>&gt; the Swift enum type, providing round-tripping so that Swift can deal in<br>&gt; ErrorProtocol values while Objective-C deals in NSError objects.<br>&gt;<br>&gt; However, the interoperability is incomplete in a number of ways, which<br>&gt; results in Swift programs having to walk a careful line between the<br>&gt; ErrorProtocol-based Swift way and the NSError-based way. This proposal<br>&gt; attempts to bridge those gaps.<br>&gt;<br>&gt; Swift-evolution thread: Charles Srstka&#39;s pitch for Consistent bridging<br>&gt; for NSErrors at the language boundary<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160502/016618.html&gt;,<br>&gt; which discussed Charles&#39; original proposal<br>&gt; &lt;https://github.com/apple/swift-evolution/pull/331&gt; that addressed these<br>&gt; issues by providing NSError to ErrorProtocol bridging and exposing the<br>&gt; domain, code, and user-info dictionary for all errors. This proposal<br>&gt; expands upon that work, but without directly exposing the domain, code, and<br>&gt; user-info.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; There are a number of weaknesses in Swift&#39;s interoperability with Cocoa&#39;s<br>&gt; error model, including:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    There is no good way to provide important error information when<br>&gt;    throwing an error from Swift. For example, let&#39;s consider a simple<br>&gt;    application-defined error in Swift:<br>&gt;<br>&gt;    enum HomeworkError : Int, ErrorProtocol {<br>&gt;      case forgotten<br>&gt;      case lost<br>&gt;      case dogAteIt<br>&gt;    }<br>&gt;<br>&gt;    One can throw HomeworkError.dogAteIt and it can be interpreted as an<br>&gt;    NSError by Objective-C with an appropriate error domain (effectively,<br>&gt;    the mangled name of the HomeworkError type) and code (effectively, the<br>&gt;    case discriminator). However, one cannot provide a localized description,<br>&gt;    help anchor, recovery attempter, or any other information commonly placed<br>&gt;    into the userInfo dictionary of an NSError. To provide these values,<br>&gt;    one must specifically construct an NSError in Swift, e.g.,<br>&gt;<br>&gt;    throw NSError(code: HomeworkError.dogAteIt.rawValue,<br>&gt;                  domain: HomeworkError._domain,<br>&gt;                  userInfo: [ NSLocalizedDescriptionKey : &quot;the dog ate it&quot; ])<br>&gt;<br>&gt;    2.<br>&gt;<br>&gt;    There is no good way to get information typically associated with<br>&gt;    NSError&#39;s userInfo in Swift. For example, the Swift-natural way to<br>&gt;    catch a specific error in the AVError error domain doesn&#39;t give one<br>&gt;    access to the userInfo dictionary, e.g.,:<br>&gt;<br>&gt;    catch let error as AVError where error == .diskFull {<br>&gt;      // AVError is an enum, so one only gets the equivalent of the code.<br>&gt;      // There is no way to access the localized description (for example) or<br>&gt;      // any other information typically stored in the ``userInfo`` dictionary.<br>&gt;    }<br>&gt;<br>&gt;    The workaround is to catch as an NSError, which is quite a bit more<br>&gt;    ugly:<br>&gt;<br>&gt;    catch let error as NSError where error._domain == AVFoundationErrorDomain &amp;&amp; error._code == AVFoundationErrorDomain.diskFull.rawValue {<br>&gt;      // okay: userInfo is finally accessible, but still weakly typed<br>&gt;    }<br>&gt;<br>&gt;    This makes it extremely hard to access common information, such as the<br>&gt;    localized description. Moreover, the userInfo dictionary is<br>&gt;    effectively untyped so, for example, one has to know a priori that the<br>&gt;    value associated with the known AVErrorDeviceKey will be typed as<br>&gt;    CMTime:<br>&gt;<br>&gt;    catch let error as NSError where error._domain = AVFoundationErrorDomain {<br>&gt;      if let time = error.userInfo[AVErrorDeviceKey] as? CMTime {<br>&gt;        // ...<br>&gt;      }<br>&gt;    }<br>&gt;<br>&gt;    It would be far better if one could catch an AVError directly and<br>&gt;    query the time in a type-safe manner:<br>&gt;<br>&gt;    catch let error as AVError {<br>&gt;      if let time = error.time {<br>&gt;        // ...<br>&gt;      }<br>&gt;    }<br>&gt;<br>&gt;    3.<br>&gt;<br>&gt;    NSError is inconsistently bridged with ErrorProtocol. Swift<br>&gt;    interoperates by translating between NSError and ErrorProtocol when<br>&gt;    mapping between a throwing Swift method/initializer and an Objective-C<br>&gt;    method with an NSError** parameter. However, an Objective-C method<br>&gt;    that takes an NSError* parameter (e.g., to render it) does not bridge<br>&gt;    to ErrorProtocol, meaning that NSError is part of the API in Swift in<br>&gt;    some places (but not others). For example, NSError leaks through when<br>&gt;    the following UIDocument API in Objective-C:<br>&gt;<br>&gt;    - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>&gt;<br>&gt;    is imported into Swift as follows:<br>&gt;<br>&gt;    func handleError(_ error: NSError, userInteractionPermitted: Bool)<br>&gt;<br>&gt;    One would expect the first parameter to be imported as ErrorProtocol.<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; This proposal involves directly addressing (1)-(3) with new protocols and<br>&gt; a different way of bridging Objective-C error code types into Swift, along<br>&gt; with some conveniences for working with Cocoa errors:<br>&gt;<br>&gt;    1.<br>&gt;<br>&gt;    Introduce three new protocols for describing more information about<br>&gt;    errors: LocalizedError, RecoverableError, andCustomNSError. For<br>&gt;    example, an error type can provide a localized description by conforming to<br>&gt;    LocalizedError:<br>&gt;<br>&gt;    extension HomeworkError : LocalizedError {<br>&gt;      var errorDescription: String? {<br>&gt;        switch self {<br>&gt;        case .forgotten: return NSLocalizedString(&quot;I forgot it&quot;)<br>&gt;        case .lost: return NSLocalizedString(&quot;I lost it&quot;)<br>&gt;        case .dogAteIt: return NSLocalizedString(&quot;The dog ate it&quot;)<br>&gt;        }<br>&gt;      }<br>&gt;    }<br>&gt;<br>&gt;    2.<br>&gt;<br>&gt;    Imported Objective-C error types should be mapped to struct types that<br>&gt;    store an NSError so that no information is lost when bridging from an<br>&gt;    NSError to the Swift error types. We propose to introduce a new macro,<br>&gt;    NS_ERROR_ENUM, that one can use to both declare an enumeration type<br>&gt;    used to describe the error codes as well as tying that type to a specific<br>&gt;    domain constant, e.g.,<br>&gt;<br>&gt;    typedef NS_ERROR_ENUM(NSInteger, AVError, AVFoundationErrorDomain) {<br>&gt;      AVErrorUnknown                                      = -11800,<br>&gt;      AVErrorOutOfMemory                                  = -11801,<br>&gt;      AVErrorSessionNotRunning                            = -11803,<br>&gt;      AVErrorDeviceAlreadyUsedByAnotherSession            = -11804,<br>&gt;      // ...<br>&gt;    }<br>&gt;<br>&gt;    The imported AVError will have a struct that allows one to access the<br>&gt;    userInfo dictionary directly. This retains the ability to catch via a<br>&gt;    specific code, e.g.,<br>&gt;<br>&gt;    catch AVError.outOfMemory {<br>&gt;     // ...<br>&gt;    }<br>&gt;<br>&gt;    However, catching a specific error as a value doesn&#39;t lose information:<br>&gt;<br>&gt;    catch let error as AVError where error.code == .sessionNotRunning {<br>&gt;     // able to access userInfo here!<br>&gt;    }<br>&gt;<br>&gt;    This also gives the ability for one to add typed accessors for known<br>&gt;    keys within the userInfo dictionary:<br>&gt;<br>&gt;    extension AVError {<br>&gt;     var time: CMTime? {<br>&gt;       get {<br>&gt;         return userInfo[AVErrorTimeKey] as? CMTime?<br>&gt;       }<br>&gt;<br>&gt;       set {<br>&gt;         userInfo[AVErrorTimeKey] = newValue.map { $0 as CMTime }<br>&gt;       }<br>&gt;     }<br>&gt;    }<br>&gt;<br>&gt;    3.<br>&gt;<br>&gt;    Bridge NSError to ErrorProtocol, so that all NSError uses are bridged<br>&gt;    consistently. For example, this means that the Objective-C API:<br>&gt;<br>&gt;    - (void)handleError:(NSError *)error userInteractionPermitted:(BOOL)userInteractionPermitted;<br>&gt;<br>&gt;    is imported into Swift as:<br>&gt;<br>&gt;    func handleError(_ error: ErrorProtocol, userInteractionPermitted: Bool)<br>&gt;<br>&gt;    This will use the same bridging logic in the Clang importer that we<br>&gt;    use for other value types (Array, String, URL, etc.), but with the<br>&gt;    runtime translation we&#39;ve already been doing for catching/throwing errors.<br>&gt;<br>&gt;    When we introduce this bridging, we will need to remove NSError&#39;s<br>&gt;    conformance to ErrorProtocol to avoid creating cyclic implicit<br>&gt;    conversions. However, we still need an easy way to create an<br>&gt;    ErrorProtocol instance from an arbitrary NSError, e.g.,<br>&gt;<br>&gt;    extension NSError {<br>&gt;      var asError: ErrorProtocol { ... }<br>&gt;    }<br>&gt;<br>&gt;    4.<br>&gt;<br>&gt;    In Foundation, add an extension to ErrorProtocol that provides typed<br>&gt;    access to the common user-info keys. Note that we focus only on those<br>&gt;    user-info keys that are read by user code (vs. only accessed by frameworks):<br>&gt;<br>&gt;    extension ErrorProtocol {<br>&gt;      // Note: for exposition only. Not actual API.<br>&gt;      private var userInfo: [NSObject : AnyObject] {<br>&gt;        return (self as! NSError).userInfo<br>&gt;      }<br>&gt;<br>&gt;      var localizedDescription: String {<br>&gt;        return (self as! NSError).localizedDescription<br>&gt;      }<br>&gt;<br>&gt;      var filePath: String? {<br>&gt;        return userInfo[NSFilePathErrorKey] as? String<br>&gt;      }<br>&gt;<br>&gt;      var stringEncoding: String.Encoding? {<br>&gt;        return (userInfo[NSStringEncodingErrorKey] as? NSNumber)<br>&gt;                 .map { String.Encoding(rawValue: $0.uintValue) }<br>&gt;      }<br>&gt;<br>&gt;      var underlying: ErrorProtocol? {<br>&gt;        return (userInfo[NSUnderlyingErrorKey] as? NSError)?.asError<br>&gt;      }<br>&gt;<br>&gt;      var url: URL? {<br>&gt;        return userInfo[NSURLErrorKey] as? URL<br>&gt;      }<br>&gt;    }<br>&gt;<br>&gt;    5.<br>&gt;<br>&gt;    Rename ErrorProtocol to Error: once we&#39;ve completed the bridging<br>&gt;    story, Error becomes the primary way to work with error types in<br>&gt;    Swift, and the value type to which NSError is bridged:<br>&gt;<br>&gt;    func handleError(_ error: Error, userInteractionPermitted: Bool)<br>&gt;<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; This section details both the design (including the various new protocols,<br>&gt; mapping from Objective-C error code enumeration types into Swift types,<br>&gt; etc.) and the efficient implementation of this design to interoperate with<br>&gt; NSError. Throughout the detailed design, we already assume the name<br>&gt; change from ErrorProtocol to Error.<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#new-protocols&gt;New<br>&gt; protocols<br>&gt;<br>&gt; This proposal introduces several new protocols that allow error types to<br>&gt; expose more information about error types.<br>&gt;<br>&gt; The LocalizedError protocol describes an error that provides localized<br>&gt; messages for display to the end user, all of which provide default<br>&gt; implementations. The conforming type can provide implementations for any<br>&gt; subset of these requirements:<br>&gt;<br>&gt; protocol LocalizedError : Error {<br>&gt;   /// A localized message describing what error occurred.<br>&gt;   var errorDescription: String? { get }<br>&gt;<br>&gt;   /// A localized message describing the reason for the failure.<br>&gt;   var failureReason: String? { get }<br>&gt;<br>&gt;   /// A localized message describing how one might recover from the failure.<br>&gt;   var recoverySuggestion: String? { get }<br>&gt;<br>&gt;   /// A localized message providing &quot;help&quot; text if the user requests help.<br>&gt;   var helpAnchor: String? { get }<br>&gt; }<br>&gt; extension LocalizedError {<br>&gt;   var errorDescription: String? { return nil }<br>&gt;   var failureReason: String? { return nil }<br>&gt;   var recoverySuggestion: String? { return nil }<br>&gt;   var helpAnchor: String? { return nil }<br>&gt; }<br>&gt;<br>&gt; The RecoverableError protocol describes an error that might be<br>&gt; recoverable:<br>&gt;<br>&gt; protocol RecoverableError : Error {<br>&gt;   /// Provides a set of possible recovery options to present to the user.<br>&gt;   var recoveryOptions: [String] { get }<br>&gt;<br>&gt;   /// Attempt to recover from this error when the user selected the<br>&gt;   /// option at the given index. This routine must call resultHandler and<br>&gt;   /// indicate whether recovery was successful (or not).<br>&gt;   ///<br>&gt;   /// This entry point is used for recovery of errors handled at a<br>&gt;   /// &quot;document&quot; granularity, that do not affect the entire<br>&gt;   /// application.<br>&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>&gt;                        andThen resultHandler: (recovered: Bool) -&gt; Void)<br>&gt;<br>&gt;   /// Attempt to recover from this error when the user selected the<br>&gt;   /// option at the given index. Returns true to indicate<br>&gt;   /// successful recovery, and false otherwise.<br>&gt;   ///<br>&gt;   /// This entry point is used for recovery of errors handled at<br>&gt;   /// the &quot;application&quot; granularity, where nothing else in the<br>&gt;   /// application can proceed until the attmpted error recovery<br>&gt;   /// completes.<br>&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int) -&gt; Bool<br>&gt; }<br>&gt; extension RecoverableError {<br>&gt;   /// By default, implements document-modal recovery via application-model<br>&gt;   /// recovery.<br>&gt;   func attemptRecovery(optionIndex recoveryOptionIndex: Int,<br>&gt;                        andThen resultHandler: (Bool) -&gt; Void) {<br>&gt;     resultHandler(recovered: attemptRecovery(optionIndex: recoveryOptionIndex))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Error types that conform to RecoverableError may be given an opportunity<br>&gt; to recover from the error. The user can be presented with some number of<br>&gt; (localized) recovery options, described by recoveryOptions, and the<br>&gt; selected option will be passed to the appropriate attemptRecovery method.<br>&gt;<br>&gt; The CustomNSError protocol describes an error that wants to provide<br>&gt; custom NSError information. This can be used, e.g., to provide a specific<br>&gt; domain/code or to populate NSError&#39;s userInfo dictionary with values for<br>&gt; custom keys that can be accessed from Objective-C code but are not covered<br>&gt; by the other protocols.<br>&gt;<br>&gt; /// Describes an error type that fills in the userInfo directly.protocol CustomNSError : Error {<br>&gt;   var errorDomain: String { get }<br>&gt;   var errorCode: Int { get }<br>&gt;   var errorUserInfo: [String : AnyObject] { get }<br>&gt; }<br>&gt;<br>&gt; Note that, unlike with NSError, the provided errorUserInfo requires String keys.<br>&gt; This is in line with common practice for NSError and is important for the<br>&gt; implementation (see below). All of these properties are defaulted, so one<br>&gt; can provide any subset:<br>&gt;<br>&gt; extension CustomNSError {<br>&gt;   var errorDomain: String { ... }<br>&gt;   var errorCode: Int { ... }<br>&gt;   var errorUserInfo: [String : AnyObject] { ... }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/DougGregor/swift-evolution/blob/nserror-bridging/proposals/0000-nserror-bridging.md#mapping-error-types-to-nserror&gt;Mapping<br>&gt; error types to NSError<br>&gt;<br>&gt; Every type that conforms to the Error protocol is implicitly bridged to<br>&gt; NSError. This has been the case since Swift 2, where the compiler<br>&gt; provides a domain (i.e., the mangled name of the type) and code (based on<br>&gt; the discriminator of the enumeration type). This proposal also allows for<br>&gt; the userInfo dictionary to be populated by the runtime, which will check<br>&gt; for conformance to the various protocols (LocalizedError, RecoverableError,<br>&gt; or CustomNSError) to retrieve information.<br>&gt;<br>&gt; Conceptually, this could be implemented by eagerly creating a userInfo dictionary<br>&gt; for a given instance of Error:<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/a157592a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 29, 2016 at 12:00:00am</p></header><div class="content"><p>On Mon, Jun 27, 2016 at 11:17 AM, Douglas Gregor via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; extension ErrorProtocol {<br>&gt;   // Note: for exposition only. Not actual API.<br>&gt;   private var userInfo: [NSObject : AnyObject] {<br>&gt;     return (self as! NSError).userInfo<br>&gt;   }<br>&gt;<br>&gt;   var localizedDescription: String {<br>&gt;     return (self as! NSError).localizedDescription<br>&gt;   }<br>&gt;<br>&gt;   var filePath: String? {<br>&gt;     return userInfo[NSFilePathErrorKey] as? String<br>&gt;   }<br>&gt;<br>&gt;   var stringEncoding: String.Encoding? {<br>&gt;     return (userInfo[NSStringEncodingErrorKey] as? NSNumber)<br>&gt;              .map { String.Encoding(rawValue: $0.uintValue) }<br>&gt;   }<br>&gt;<br>&gt;   var underlying: ErrorProtocol? {<br>&gt;     return (userInfo[NSUnderlyingErrorKey] as? NSError)?.asError<br>&gt;   }<br>&gt;<br>&gt;   var url: URL? {<br>&gt;     return userInfo[NSURLErrorKey] as? URL<br>&gt;   }<br>&gt; }<br></p><p>I&#39;m not sure I really want &#39;.url&#39; and &#39;.stringEncoding&#39; on every<br>Error.  &#39;var underlying&#39; is universally useful, but providing it<br>requires a implementing conformance to CustomNSError, which has to<br>vend a weakly-typed dictionary.  Is this really the API we want to<br>expose?<br></p><p>Also, the underlying error has to be stored somewhere, which<br>effectively prevents implementers of CustomNSError from being enums.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 29, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 2:50 AM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure I really want &#39;.url&#39; and &#39;.stringEncoding&#39; on every<br>&gt; Error.  &#39;var underlying&#39; is universally useful, but providing it<br>&gt; requires a implementing conformance to CustomNSError, which has to<br>&gt; vend a weakly-typed dictionary.  Is this really the API we want to<br>&gt; expose?<br></p><p>We need to expose the dictionary in order to provide full compatibility with NSError.<br></p><p>&gt; Also, the underlying error has to be stored somewhere, which<br>&gt; effectively prevents implementers of CustomNSError from being enums.<br></p><p><br>Not at all. Your enum can implement a dynamic errorUserInfo property that will populate the dictionary with the appropriate values. If you need to actually store something, that can be done with enum cases as well.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/59835a27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 29, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, Jun 29, 2016 at 4:13 AM, Charles Srstka<br>&lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; On Jun 29, 2016, at 2:50 AM, Dmitri Gribenko via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure I really want &#39;.url&#39; and &#39;.stringEncoding&#39; on every<br>&gt; Error.  &#39;var underlying&#39; is universally useful, but providing it<br>&gt; requires a implementing conformance to CustomNSError, which has to<br>&gt; vend a weakly-typed dictionary.  Is this really the API we want to<br>&gt; expose?<br>&gt;<br>&gt;<br>&gt; We need to expose the dictionary in order to provide full compatibility with<br>&gt; NSError.<br></p><p>The full compatibility argument is universal, and it can be applied to<br>anything.  Not always the answer is &quot;dump the compatibility APIs onto<br>the Swift type&quot;.<br></p><p>&gt; Also, the underlying error has to be stored somewhere, which<br>&gt; effectively prevents implementers of CustomNSError from being enums.<br>&gt;<br>&gt;<br>&gt; Not at all. Your enum can implement a dynamic errorUserInfo property that<br>&gt; will populate the dictionary with the appropriate values. If you need to<br>&gt; actually store something, that can be done with enum cases as well.<br></p><p>You would need to store the underlying error in every enum case, which<br>creates boilerplate, and you&#39;d lose the raw representable conformance.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 12:05 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Jun 29, 2016 at 4:13 AM, Charles Srstka<br>&gt; &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt; On Jun 29, 2016, at 2:50 AM, Dmitri Gribenko via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure I really want &#39;.url&#39; and &#39;.stringEncoding&#39; on every<br>&gt;&gt; Error.  &#39;var underlying&#39; is universally useful, but providing it<br>&gt;&gt; requires a implementing conformance to CustomNSError, which has to<br>&gt;&gt; vend a weakly-typed dictionary.  Is this really the API we want to<br>&gt;&gt; expose?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; We need to expose the dictionary in order to provide full compatibility with<br>&gt;&gt; NSError.<br>&gt; <br>&gt; The full compatibility argument is universal, and it can be applied to<br>&gt; anything.  Not always the answer is &quot;dump the compatibility APIs onto<br>&gt; the Swift type”.<br></p><p>In this case, the type in question is the error type returned by all of the error-returning APIs in the frameworks, as well as the vast library of Objective-C code out there in the community. I think that being able to access all the information provided by said error type is a fairly important goal.<br></p><p>Also, the APIs are not “dumped onto the Swift type.” They are added in an extension in Foundation, and if you don’t import Foundation, you won’t see them. This is consistent with the way other bridged types are treated; for example, Foundation has an extension on String that provides most of the goodies provided by NSString. This allows us to write code using Strings exclusively, with NSString rarely, if ever, actually needing to appear in Swift code, which is what we want to achieve with NSError-&gt;Error.<br></p><p>&gt;&gt; Also, the underlying error has to be stored somewhere, which<br>&gt;&gt; effectively prevents implementers of CustomNSError from being enums.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Not at all. Your enum can implement a dynamic errorUserInfo property that<br>&gt;&gt; will populate the dictionary with the appropriate values. If you need to<br>&gt;&gt; actually store something, that can be done with enum cases as well.<br>&gt; <br>&gt; You would need to store the underlying error in every enum case, which<br>&gt; creates boilerplate, and you&#39;d lose the raw representable conformance.<br></p><p>Only on the cases for which an underlying error is relevant, which may only be a few cases. Alternatively, you could use a struct if that fits your design better, or you could go with a hybrid approach such as an enum inside a struct, or if RawRepresentable conformance is important, you could forego providing an underlying error. Simply use the type of error that most appropriately fits your project and the conceptual type of error you wish to report.<br></p><p>If you do decide to provide an underlying error, you will need to create a little boilerplate, yes, whether it’s in an enum case, a struct’s initializer, or somewhere else. I don’t think that is avoidable in any case. I will still contend that it is much less boilerplate than having to fill your code with this:<br></p><p>let userInfo = [NSLocalizedFailureReasonErrorKey: NSLocalizedString(“A horse, a horse, my kingdom for a horse!”, comment: “Tudors are in, Yorks are out&quot;), NSRecoverySuggestionErrorKey: NSLocalizedString(“Time for a new king.”, comment: “The Henry that doesn’t have a Shakespeare play”), NSFilePathErrorKey: “/Europe/England/Leicestershire/Bosworth”, NSURLErrorKey: NSURL(string: &quot;https://en.wikipedia.org/wiki/Battle_of_Bosworth_Field”), NSUnderlyingErrorKey: wantedAHorseshoeNail]<br>throw NSError(domain: “OhMyGodWhyDoINeedToTypeAllThis”, code: WarOfRosesError.HorseDied.rawValue, userInfo: userInfo)<br></p><p>and then, when you need to check for the thing later on, you have to:<br></p><p>do {<br>    try something()<br>} catch let error as NSError {<br>    if error.domain == “OhMyGodWhyDoINeedToTypeAllThis” &amp;&amp; error.code == WarOfRosesError.HorseDied.rawValue {<br>        self.setUpHenryVII()<br>    }<br>} catch {<br>    // handle normal errors<br>}<br></p><p>Yeah, I think we win overall in the boilerplate department by just turning that into a enum case or a struct with an “underlying” argument on it. :-P<br></p><p>Charles<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 29, 2016 at 10:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/52f5533e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 30, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 30, 2016, at 12:56 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 29, 2016, at 10:05 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Wed, Jun 29, 2016 at 4:13 AM, Charles Srstka<br>&gt;&gt; &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt;&gt; On Jun 29, 2016, at 2:50 AM, Dmitri Gribenko via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure I really want &#39;.url&#39; and &#39;.stringEncoding&#39; on every<br>&gt;&gt;&gt; Error.  &#39;var underlying&#39; is universally useful, but providing it<br>&gt;&gt;&gt; requires a implementing conformance to CustomNSError, which has to<br>&gt;&gt;&gt; vend a weakly-typed dictionary.  Is this really the API we want to<br>&gt;&gt;&gt; expose?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We need to expose the dictionary in order to provide full compatibility with<br>&gt;&gt;&gt; NSError.<br>&gt;&gt; <br>&gt;&gt; The full compatibility argument is universal, and it can be applied to<br>&gt;&gt; anything.  Not always the answer is &quot;dump the compatibility APIs onto<br>&gt;&gt; the Swift type”.<br>&gt; <br>&gt; Yes, that’s a reasonable point. These APIs are available by bouncing through NSError and (at worst) looking up a known key in its userInfo dictionary. I only truly care about localizedDescription being available on Error(Protocol), because that’s universal and useful. The others… I think I’ll go put them on (NS)CocoaError, which covers the Cocoa error domain and is where one might reasonably expect these keys to show up. It’s fairly easy for other, specific error types to do the same if they need them. If we truly need some of these on all error types, we can add that at a later time.<br>&gt; <br>&gt; I’ll revise the proposal shortly.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Also, the underlying error has to be stored somewhere, which<br>&gt;&gt;&gt; effectively prevents implementers of CustomNSError from being enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not at all. Your enum can implement a dynamic errorUserInfo property that<br>&gt;&gt;&gt; will populate the dictionary with the appropriate values. If you need to<br>&gt;&gt;&gt; actually store something, that can be done with enum cases as well.<br>&gt;&gt; <br>&gt;&gt; You would need to store the underlying error in every enum case, which<br>&gt;&gt; creates boilerplate, and you&#39;d lose the raw representable conformance.<br>&gt; <br>&gt; <br>&gt; If it’s important for the error type to store the underlying error, you can use a struct or add the payload to every enum case. Maybe some future feature will make the latter option easier (I feel like we saw a pitch about that before).<br></p><p>There was a pitch along these lines.  IIRC it was something like stored properties for enums where you could declare the property once and it would be added to the payload of all cases as well as available directly as a property.  I thought it sounded useful - underlying error is an example of a good use case.<br></p><p>I&#39;m pretty sure there was pretty strong negative feedback along the lines that is blurs the distinction between struct and enum too much and I think that feedback came from someone on the core team.  I don&#39;t recall the exact details though.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 1:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; The LocalizedError protocol describes an error that provides localized messages for display to the end user, all of which provide default implementations. The conforming type can provide implementations for any subset of these requirements:<br>&gt; <br>&gt; protocol LocalizedError : Error {<br>&gt;   /// A localized message describing what error occurred.<br>&gt;   var errorDescription: String? { get }<br>&gt;   …<br>&gt; }<br></p><p><br>Given that LocalizedError would now be its own protocol that not all errors would conform to, could errorDescription be non-optional?<br></p><p>&gt;   var errorDescription: String { get }<br></p><p>It would be nice if conformance to LocalizedError guaranteed the presence of a user-readable message. Such a guarantee is useful when building a UI.<br></p><p>I realize the bridging to NSError may make this impossible, but in principle it seems like the right design.<br></p><p>Cheers,<br></p><p>Paul<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/34b2b199/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 29, 2016, at 5:30 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 1:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The LocalizedError protocol describes an error that provides localized messages for display to the end user, all of which provide default implementations. The conforming type can provide implementations for any subset of these requirements:<br>&gt;&gt; <br>&gt;&gt; protocol LocalizedError : Error {<br>&gt;&gt;   /// A localized message describing what error occurred.<br>&gt;&gt;   var errorDescription: String? { get }<br>&gt;&gt;   …<br>&gt;&gt; }<br>&gt; <br>&gt; <br>&gt; Given that LocalizedError would now be its own protocol that not all errors would conform to, could errorDescription be non-optional?<br>&gt; <br>&gt;&gt;   var errorDescription: String { get }<br>&gt; <br>&gt; It would be nice if conformance to LocalizedError guaranteed the presence of a user-readable message. Such a guarantee is useful when building a UI.<br>&gt; <br>&gt; I realize the bridging to NSError may make this impossible, but in principle it seems like the right design.<br></p><p>The trouble is that NSError allows NSLocalizedDescriptionKey to be nil, and leaving it nil is how you get Cocoa&#39;s default behavior in a lot of situations. In fact, this is usually what you want—leaving NSLocalizedDescriptionKey nil and populating NSLocalizedFailureReasonErrorKey instead is often the better way to go. For example, in NSDocument’s error reporting, if you throw an error that sets a failure reason, like this:<br></p><p>override func read(from data: Data, ofType typeName: String) throws {<br>    let userInfo = [NSLocalizedFailureReasonErrorKey: &quot;Something went wrong.&quot;]<br>    throw NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo)<br>}<br></p><p>The error is presented to the user as “The operation could not be completed. Something went wrong.”<br></p><p>However, if you provide the description instead:<br></p><p>override func read(from data: Data, ofType typeName: String) throws {<br>    let userInfo = [NSLocalizedDescriptionKey: &quot;Something went wrong.&quot;]<br>    throw NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo)<br>}<br></p><p>You just get “The operation could not be completed.” with no further information.<br></p><p>Providing the failure reason while leaving the description nil also changes the presentation when you’re reporting errors directly, as below:<br></p><p>let userInfo = [NSLocalizedFailureReasonErrorKey: &quot;Something went wrong.&quot;]<br>NSApp.presentError(NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo))<br></p><p>This gives you “The operation could not be completed. Something went wrong.” By comparison:<br></p><p>let userInfo = [NSLocalizedDescriptionKey: &quot;Something went wrong.&quot;]<br>NSApp.presentError(NSError(domain: &quot;Foo&quot;, code: 1, userInfo: userInfo))<br></p><p>This just gives you “Something went wrong.” without the polite “The operation could not be completed.” prefix, which causes the error description to come across as rather blunt. A default implementation for the property could be provided, of course, but since the primary purpose of the methods in this protocol are for the implementer of the error type to provide information to the frameworks to assist in creating the NSError, I can’t think of any way to have it simultaneously return a meaningful value to a client and still communicate to the frameworks that this value should be nil.<br></p><p>Perhaps we should add an additional property for a user-facing string generated from the rest of the strings?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/3f82089a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 30, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; Note that, unlike with NSError, the provided errorUserInfo requires String keys.<br></p><p>Is there any way this could be tightened further to require Error.UserInfoKey keys (where Error.UserInfoKey is a Notification.Name-style wrapper)?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] NSError bridging</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 2:19 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Note that, unlike with NSError, the provided errorUserInfo requires String keys.<br>&gt; <br>&gt; Is there any way this could be tightened further to require Error.UserInfoKey keys (where Error.UserInfoKey is a Notification.Name-style wrapper)?<br></p><p><br>Maybe. We had originally tried doing this, but it caused a lot of frustration because NSError’s userInfo historically allowed non-string keys, so technically it should be typed as [NSObject : AnyObject]. However, that type signature means that one is “.rawValue”’ing all of the keys over and over:<br></p><p>	  userInfo[NSErrorUserInfoKey.myKeyName.rawValue] = foo<br></p><p>That said, this proposal eliminates the need for using those keys (and, indeed, NSError) most of the time, and maybe we can write off non-string keys entirely in Swift.<br></p><p>	- Doug<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
