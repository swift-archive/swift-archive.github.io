<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 11:00:00am</p></header><div class="content"><p>on Sat Jan 23 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think Joe&#39;s reply is a pretty good summary.<br></p><p>Hi David,<br></p><p>Let me start by expressing my appreciation for the way you&#39;re struggling<br>with the hard issues here.  The questions you&#39;re asking reflect many of<br>the same ones we asked ourselves during the development of these<br>guidelines.<br></p><p>&gt; At a high-level, I really get no sense on how APIs are really supposed<br>&gt; to be developed in Swift. Joe talks about second arguments generally<br>&gt; becoming prepositional phrases, but is that the true intent? Because<br>&gt; that&#39;s not what the guideline says, nor what the language semantics<br>&gt; really promote or suggest to do.<br></p><p>No, that&#39;s not the intent of the guideline.<br></p><p>&gt; For example, the guidelines say to do one thing but the example does<br>&gt; something different:<br>&gt;<br>&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt; <br>&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt;&gt; fundamental type such Int or String, type information and context at<br>&gt;&gt; the point of use may not fully convey intent. In this example, the<br>&gt;&gt; declaration may be clear, but the use site is vague:<br>&gt;&gt; <br>&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt; grid.add(self, for: graphics)<br>&gt;&gt; <br>&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt; <br>&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;<br>&gt; This example already had a &quot;for&quot; in the label, but if it were not<br>&gt; already there, the API, according to the guidelines, should become<br>&gt; this:<br>&gt;<br>&gt; func addObserver(_ observer: NSObject, keyPath path: String)<br>&gt; grid.addObserver(self, keyPath: graphics) // clear<br></p><p>The reason &quot;for&quot; is there is that otherwise you can&#39;t tell what the<br>relationship between the observer and the keyPath is.  For example, if<br>it had been &quot;at&quot; instead of &quot;for,&quot; it would completely change the<br>meaning. &quot;Of&quot; would probably be more descriptive, frankly.  But the<br>example isn&#39;t trying to illustrate anything about that preposition or<br>that relationship.  <br></p><p>&gt; Especially when compared with the ObjC import items. Seemingly, the<br>&gt; ObjC APIs would be using prepositional clauses for parameter labels<br>&gt; while the Swift labels would simply be more descriptive nouns.<br></p><p>I don&#39;t know what you mean here, sorry.<br></p><p>&gt; The rules I described are keeping in strict guidance to the API design<br>&gt; guidelines of adding nouns. So the above would actually be:<br>&gt;<br>&gt; func add(observer o: NSObject, keyPath path: String)<br>&gt; grid.add(observer: self, keyPath: graphics)<br></p><p>I&#39;ll have to go back and look at the rules you described, but regarding<br>the above example, my reason to keep &quot;observer&quot; in the base name is that<br>adding observers is really a totally distinct thing from adding, say,<br>gesture recognizers, or animation steps, or anything else.  There isn&#39;t<br>one big pot to which you&#39;re adding everything.  If there were, the<br>receiver would be like a collection, and we wouldn&#39;t need a noun there<br>at all.<br></p><p>&gt; However, if the API guidelines are really about creating APIs that are<br>&gt; to be read in a more English-like manner, like ObjC APIs are designed,<br>&gt; then the guidelines should really be amended to make that clear.<br></p><p>The point of the guidelines is not to make code look like English; it&#39;s<br>to make code clear and understandable.  It happens that in many cases,<br>leveraging English grammar serves that purpose well.  In other cases<br>it&#39;s necessary to take a different approach, which is why we have sin(x)<br>and zip(x, y).  But as I think we make clear, one shouldn&#39;t add words<br>just to make an API more “English-like.”<br></p><p>&gt; If the intention is truly that Swift APIs are supposed to read as<br>&gt; naturally as ObjC APIs, <br></p><p>Ah... “naturally” is in the eye of the beholder, though.<br></p><p>&gt; then I completely agree with Joe that there should be a language<br>&gt; change to actually require the label for parameters.<br>&gt;<br>&gt; func addObserver(o: NSObject, path: String) // error: Argument label required for `path`.<br></p><p>I&#39;m confused; &quot;path&quot; has an argument label; it&#39;s &quot;path.&quot;<br></p><p>&gt; However, this pattern of using prepositional phrases is still going to<br>&gt; be in contradiction when using init().<br>&gt;<br>&gt; let items = Array&lt;Int&gt;(capacityOf: 12, filledWith: 10)<br>&gt;<br>&gt; // vs<br>&gt;<br>&gt; let items = Array&lt;Int&gt;(count: 12, repeatedValue: 10)<br>&gt;<br>&gt; The difference is that init has a much tighter coupling with direct<br>&gt; sets to properties on the type. <br></p><p>I don&#39;t think that&#39;s the key distinction.<br></p><p>&gt; So yeah... basic story is, even after using Swift since its been<br>&gt; released, I still have no clear sense of what a Swift API should look<br>&gt; like, <br></p><p>Well, part of that may be that we haven&#39;t had any clarity on that up to<br>this point, so a couple of years of experience don&#39;t help you much.<br></p><p>&gt; and the guidelines don&#39;t bring any of that clarity that I&#39;m missing to<br>&gt; the table. <br></p><p>That part, I&#39;m more worried about.<br></p><p>&gt; At the end of the day, Swift chose a C-style pattern which actively<br>&gt; dissuades API authors from building the more fluid types of APIs we<br>&gt; have in ObjC; there&#39;s simply more sigils in the way to break up a<br>&gt; natural reading of the API.<br>&gt;<br>&gt; grid.addObserver(self, forKeyPath: graphics)<br>&gt;<br>&gt; // vs<br>&gt;<br>&gt; [grid addObserver:self forKeyPath:graphics]<br></p><p>Personally I don&#39;t see those two as significantly different, and the<br>Swift pattern has the benefit of un-nesting method chains, allowing<br>&quot;fluent&quot; interfaces.  But we&#39;re not reviewing the basic syntax choices<br>of Swift here.<br></p><p>&gt; All of my inclinations for C-style syntactical languages say the API<br>&gt; should be (in order of my conceptual preference model):<br>&gt;<br>&gt; grid.add(observer: self, keyPath: graphics)<br>&gt;<br>&gt; // or<br>&gt;<br>&gt; grid.addObserver(self, keyPath: graphics)<br>&gt;<br>&gt; // or<br>&gt;<br>&gt; grid.addObserver(self, graphics)<br></p><p>I think we&#39;re asking you to let go of your inclinations and think more<br>carefully about what will serve the reader of code using your API :-).<br>This is less about having a pattern to follow than about how to make<br>choices that lead to readable, maintainable code.<br></p><p>&gt; And then take this proposed change to a Swift based on guideline updates:<br>&gt;<br>&gt;  extension Strideable {<br>&gt;<br>&gt; -  public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt; +  public func strideThrough(end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt;<br>&gt;  }<br>&gt;<br>&gt; In what part of the guidelines does it say that we should &quot;by&quot; as the<br>&gt; argument label? <br></p><p>It doesn&#39;t say that explcitly anywhere.  Good APIs aren&#39;t the result of<br>applying a set of mechanical rules.  You have to consider what the usage<br>will look like.<br></p><p>&gt; The stride parameter does not have a lack of type<br>&gt; information; in fact, it&#39;s quite strong. <br></p><p>And there&#39;s no noun preceding it.  Where&#39;s the problem?<br></p><p>&gt; The call site *is* arguably better with &quot;by&quot; vs. &quot;stride&quot;. <br></p><p>By Jove, I think he&#39;s got it! :-)<br></p><p>&gt; However, &quot;stride&quot; is not missing context on type information or role<br>&gt; specificity.<br>&gt;<br>&gt; I guess I&#39;m starting to ramble on here, so I&#39;ll stop now...<br></p><p>I actually think you&#39;re on the right track.  Let&#39;s keep working on this;<br>maybe it will lead to something we can clarify in the guidelines.<br></p><p>Thanks,<br></p><p>&gt; -David<br>&gt;<br>&gt;&gt; On Jan 23, 2016, at 10:45 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This all looks good to me (aside from the linguistic problems with<br>&gt;&gt; verb conjugation I&#39;ve raised in another subthread). However, I think<br>&gt;&gt; these naming guidelines lead us to reconsider our default argument<br>&gt;&gt; labeling rules for &#39;func&#39; declarations again, as David Owens and<br>&gt;&gt; others have suggested. The stated goal of the current language rule<br>&gt;&gt; is to guide people into good API design following our conventions,<br>&gt;&gt; but I don&#39;t think it succeeds in serving that purpose. If you follow<br>&gt;&gt; the guidelines, the argument labels for your secondary arguments<br>&gt;&gt; generally end up becoming prepositional phrases, which make for poor<br>&gt;&gt; variable names, and you&#39;re naturally guided to giving the argument<br>&gt;&gt; an explicit descriptive binding name:<br>&gt;&gt; <br>&gt;&gt; func perform(stuff: Stuff, with: Thing) {<br>&gt;&gt;   with.apply(stuff) // &#39;with&#39; is a weird variable name<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func perform(stuff: Stuff, with thing: Thing) {<br>&gt;&gt;   thing.apply(stuff) // &#39;thing&#39; is better<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The shorthand thus doesn&#39;t save the good API citizen from much<br>&gt;&gt; work. On the other hand, a developer who&#39;s unaware or uninterested<br>&gt;&gt; in the guidelines and is just trying to C or Java in Swift gets<br>&gt;&gt; argument labels by default that neither follow the guidelines nor<br>&gt;&gt; meet their expectation:<br>&gt;&gt; <br>&gt;&gt; func atan2(y: Double, x: Double) -&gt; Double { ... }<br>&gt;&gt; <br>&gt;&gt; atan2(10, 10) // Why doesn&#39;t this work?<br>&gt;&gt; atan2(10, x: 10) // Nobody wants this<br>&gt;&gt; <br>&gt;&gt; And when staring down potentially dozens or hundreds of compile<br>&gt;&gt; errors at various mismatched use sites, they&#39;re unlikely to<br>&gt;&gt; reconsider their API naming choice, and will instead do the minimal<br>&gt;&gt; amount of work to get their code to compile by suppressing the<br>&gt;&gt; argument label. The language hasn&#39;t led this developer to better<br>&gt;&gt; conventional API design either.<br>&gt;&gt; <br>&gt;&gt; I can think of a couple possible modifications to the language rule<br>&gt;&gt; that could help reduce the surprise factor, and still lead people to<br>&gt;&gt; good API design:<br>&gt;&gt; <br>&gt;&gt; - Require all &#39;func&#39; arguments after the first to explicitly specify<br>&gt;&gt; both a label and a binding name. Users following the guidelines will<br>&gt;&gt; usually end up doing this anyway, and users who aren&#39;t will get a<br>&gt;&gt; helpful message instead of unexpected behavior. This also avoids a<br>&gt;&gt; problem with our current rule, where otherwise identical-looking<br>&gt;&gt; parameter declarations in a &#39;func&#39; end up behaving differently based<br>&gt;&gt; on position. A diagnostic immediately at the declaration site also<br>&gt;&gt; seems more likely to me to lead the developer to think more about<br>&gt;&gt; their API naming; diagnosing call sites that don&#39;t look the way they<br>&gt;&gt; want is just going to lead them to reactively suppress the labels to<br>&gt;&gt; get their code to compile.<br>&gt;&gt; - Change the default rule so that all arguments *after an explicitly<br>&gt;&gt; labeled argument* default to being labeled (instead of all arguments<br>&gt;&gt; after the first). It&#39;s unlikely anyone wants an unlabeled argument<br>&gt;&gt; positionally after a labeled one, and the rare methods in Cocoa that<br>&gt;&gt; take more than two arguments do tend to use noun rather than<br>&gt;&gt; preposition phrases for arguments after the second. Users following<br>&gt;&gt; the guidelines get nice labeled APIs, and users who aren&#39;t get the<br>&gt;&gt; bare, uncaring anonymous arguments they deserve:<br>&gt;&gt; <br>&gt;&gt; func perform(stuff: Stuff, with thing: Thing, options: StuffOptions) // perform(_:with:options:)<br>&gt;&gt; func atan2(y: Double, x: Double) // atan2(_:_:)<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 22, 2016, at 1:02 PM, Douglas Gregor via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of SE-0023&quot;API Design Guidelines&quot; begins now and runs<br>&gt;&gt;&gt; through January 31, 2016. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to<br>&gt;&gt;&gt; the review manager. When replying, please try to keep the proposal<br>&gt;&gt;&gt; link at the top of the message:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal link:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0023-api-guidelines.md&gt;<br>&gt;&gt;&gt; Reply text<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Other replies<br>&gt;&gt;&gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under<br>&gt;&gt;&gt; review through constructive criticism and, eventually, determine<br>&gt;&gt;&gt; the direction of Swift. When writing your review, here are some<br>&gt;&gt;&gt; questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Doug Gregor<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 24, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 11:17 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; on Sat Jan 23 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I think Joe&#39;s reply is a pretty good summary.<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; Let me start by expressing my appreciation for the way you&#39;re struggling<br>&gt; with the hard issues here.  The questions you&#39;re asking reflect many of<br>&gt; the same ones we asked ourselves during the development of these<br>&gt; guidelines.<br>&gt; <br>&gt;&gt; At a high-level, I really get no sense on how APIs are really supposed<br>&gt;&gt; to be developed in Swift. Joe talks about second arguments generally<br>&gt;&gt; becoming prepositional phrases, but is that the true intent? Because<br>&gt;&gt; that&#39;s not what the guideline says, nor what the language semantics<br>&gt;&gt; really promote or suggest to do.<br>&gt; <br>&gt; No, that&#39;s not the intent of the guideline.<br></p><p>&quot;The use of external parameter names can allow a function to be called in an expressive, sentence-like manner, while still providing a function body that is readable and clear in intent.&quot;<br></p><p>Source: https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html<br></p><p>That&#39;s the 2.1 guide, so your mileage may vary in 3.0, but that&#39;s some of the baggage coming in to this review.<br></p><p>The problem I see is that there is a mixed bag of what &quot;good&quot; APIs look like. And when push comes to shove, code wins. The libraries exposed in code, even through the ObjC bridging, will be used as the basis of what determines what good Swift APIs look like more than a published doc.<br></p><p>However, what I see is the struggle between creating good API call sites, what the defaults of the language provide today, and what the guidelines are saying and comparing those to what we get from the new Swift APIs and the updated ObjC imported APIs.<br></p><p>By default we get this:<br></p><p>func max(a: Int, b: Int) -&gt; Int<br>max(a, b: 12)<br></p><p>func addObserver(observer: Observable, path: String)<br>thing.addObserver(observing, path: &quot;/path/to/observe&quot;)<br></p><p>public func strideTo(end: Self, stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>thing.strideTo(10, stride: 1)<br></p><p>Of the three, only the addObserver are APIs I deem to be acceptable. Of course, there are many examples to prove any given point, but I think these represent the common cases.<br></p><p>1. Labels are obviously bad (max)<br>2. Labels are fine though the external label could be better (addObserver)<br>3. Exposes an implementation name that really confuses the API (strideTo)<br></p><p>(more on this example a bit later)<br></p><p><br>&gt;&gt; For example, the guidelines say to do one thing but the example does<br>&gt;&gt; something different:<br>&gt;&gt; <br>&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt;&gt;&gt; fundamental type such Int or String, type information and context at<br>&gt;&gt;&gt; the point of use may not fully convey intent. In this example, the<br>&gt;&gt;&gt; declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt; grid.add(self, for: graphics)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a noun describing its role:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt; <br>&gt;&gt; This example already had a &quot;for&quot; in the label, but if it were not<br>&gt;&gt; already there, the API, according to the guidelines, should become<br>&gt;&gt; this:<br>&gt;&gt; <br>&gt;&gt; func addObserver(_ observer: NSObject, keyPath path: String)<br>&gt;&gt; grid.addObserver(self, keyPath: graphics) // clear<br>&gt; <br>&gt; The reason &quot;for&quot; is there is that otherwise you can&#39;t tell what the<br>&gt; relationship between the observer and the keyPath is.  For example, if<br>&gt; it had been &quot;at&quot; instead of &quot;for,&quot; it would completely change the<br>&gt; meaning. &quot;Of&quot; would probably be more descriptive, frankly.  But the<br>&gt; example isn&#39;t trying to illustrate anything about that preposition or<br>&gt; that relationship.  <br></p><p>Right, but the argument is that the API is indeed better with the &quot;for&quot; preposition. I believe it is, I think you are also saying that it is.<br></p><p>This is the closest guideline that I think attempts to address it:<br></p><p>&gt; Clarity at the point of use is your most important goal. Code is read far more than it is written.<br></p><p>But the clarity here is, ironically, inherently ambiguous. Clarity could mean to make the weak type information known. Clarity could be about intention of how the parameter could be used. Clarity could simply be a more verbose name that provides additional context. I think it would be clear to have guidelines that actually describe what you think make up a good call site.<br></p><p>thing.strideTo(10, stride: 1) // clear<br>thing.strideTo(10, by: 1)     // clear and linguistically better<br>thing.strideTo(10, 1)         // not clear<br></p><p>Both provide some amount clarity at the call site as the value of 1 is quite clear what it means. So in one sense, I agree that the defaults of the language today push you towards clarity.<br></p><p>To me, the guidelines, as I understand them, lead us to the first option when I believe the intent is to actually get to the second usage.<br></p><p>&gt;&gt; Especially when compared with the ObjC import items. Seemingly, the<br>&gt;&gt; ObjC APIs would be using prepositional clauses for parameter labels<br>&gt;&gt; while the Swift labels would simply be more descriptive nouns.<br>&gt; <br>&gt; I don&#39;t know what you mean here, sorry.<br></p><p>Many of the ObjC APIs will come across with prepositions in the external labels, such as:<br></p><p>func insert(_ anObject: AnyObject, atIndex index: Int)<br></p><p>Whereas my interpretation of the Swift 3.0 guidelines would say to design that API like this:<br></p><p>func insert(_ anObject: AnyObject, index: Int)<br></p><p>So when we look at the various API options in front of us when designing new APIs, do we use &quot;atIndex&quot;, &quot;at&quot;, or simply stick with the default &quot;index&quot;? This is where I think the guidelines don&#39;t help steer us in any direction.<br></p><p>However, indeed someone thinks that we should use &quot;at&quot;, but based on the guidelines, it&#39;s really hard to understand why:<br></p><p>-  mutating func insert(newElement: Iterator.Element, atIndex i: Int)<br>+  mutating func insert(newElement: Iterator.Element, at i: Int)<br></p><p>Again, I agree that &quot;at&quot; reads better at the call site. However, it doesn&#39;t provide any real clarity over the default &quot;index&quot; (sidenote: i is still a bad choice ;)), and in some ways, it could be argued that it&#39;s slightly ambiguous. Does the below mean insert &quot;12&quot; at the index of &quot;2&quot; or at the value matching &quot;2&quot;?<br></p><p>items.insert(12, at: 2)<br></p><p>While this version does not even have that ambiguity. This also relates to the &quot;weak type information&quot; guidelines.<br></p><p>items.insert(12, atIndex: 2)<br></p><p><br>&gt;&gt; The rules I described are keeping in strict guidance to the API design<br>&gt;&gt; guidelines of adding nouns. So the above would actually be:<br>&gt;&gt; <br>&gt;&gt; func add(observer o: NSObject, keyPath path: String)<br>&gt;&gt; grid.add(observer: self, keyPath: graphics)<br>&gt; <br>&gt; I&#39;ll have to go back and look at the rules you described, but regarding<br>&gt; the above example, my reason to keep &quot;observer&quot; in the base name is that<br>&gt; adding observers is really a totally distinct thing from adding, say,<br>&gt; gesture recognizers, or animation steps, or anything else.  There isn&#39;t<br>&gt; one big pot to which you&#39;re adding everything.  If there were, the<br>&gt; receiver would be like a collection, and we wouldn&#39;t need a noun there<br>&gt; at all.<br></p><p>Granted, this is the case some of the times. However, if the protocol is this:<br></p><p>protocol Observable {<br>    func add(observable o: NSObject, forKeyPath path: String)<br>    func remove(observable o: NSObject)<br>}<br></p><p><br>I actually really hard pressed to come up with a definitive example as to why that should be allowed. The best I can argue is that &quot;add&quot; itself is too generic and could be confused on the implementing type that may also have an &quot;add&quot; function. However, the additional label information helps with that.<br></p><p>Also, the argument against this one:<br></p><p>protocol Observable {<br>    func addObservable(o: NSObject, forKeyPath path: String)<br>    func removeObservable(o: NSObject)<br>}<br></p><p>Would seem to be me that we are simply duplicating type information. Maybe it&#39;s more clear?<br></p><p>In any respect, I at least submit that &quot;addObservable&quot; in this case is definitely in the grey area.<br></p><p>However, I absolutely believe that the &quot;strideTo/strideThrough&quot; example is clearly on the side of really being part of the argument label. In both cases we are striding, the difference is on where we stop.<br></p><p>extension Strideable {<br></p><p>-  public func stride(to end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>+  public func strideTo(end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br></p><p> }<br></p><p> extension Strideable {<br></p><p>-  public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>+  public func strideThrough(end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br></p><p> }<br></p><p>This change seems to be simply because the usage of labelled first parameters are frowned up, not because it&#39;s actually a better place to describe what is going on.<br></p><p>&gt;&gt; However, if the API guidelines are really about creating APIs that are<br>&gt;&gt; to be read in a more English-like manner, like ObjC APIs are designed,<br>&gt;&gt; then the guidelines should really be amended to make that clear.<br>&gt; <br>&gt; The point of the guidelines is not to make code look like English; it&#39;s<br>&gt; to make code clear and understandable.  It happens that in many cases,<br>&gt; leveraging English grammar serves that purpose well.  In other cases<br>&gt; it&#39;s necessary to take a different approach, which is why we have sin(x)<br>&gt; and zip(x, y).  But as I think we make clear, one shouldn&#39;t add words<br>&gt; just to make an API more “English-like.”<br>&gt; <br>&gt;&gt; If the intention is truly that Swift APIs are supposed to read as<br>&gt;&gt; naturally as ObjC APIs, <br>&gt; <br>&gt; Ah... “naturally” is in the eye of the beholder, though.<br></p><p>Not quite, I think we can objectively say that this:<br></p><p>items.insert(12, atIndex: 2)<br></p><p>Reads far more naturally than this:<br></p><p>items.insert(12, index: 2)<br></p><p>In the later, you have to add words to make the API read fluidly. The former simply does by the nature of the words.<br></p><p>&gt;&gt; then I completely agree with Joe that there should be a language<br>&gt;&gt; change to actually require the label for parameters.<br>&gt;&gt; <br>&gt;&gt; func addObserver(o: NSObject, path: String) // error: Argument label required for `path`.<br>&gt; <br>&gt; I&#39;m confused; &quot;path&quot; has an argument label; it&#39;s &quot;path.&quot;<br></p><p>What I&#39;m saying is that this is a compiler error:<br></p><p>func addObserver(o: NSObject, path: String) // error: Argument label required for `path`.<br></p><p>While this version is not:<br></p><p>func addObserver(o: NSObject, forKeyPath path: String) // error: Argument label required for `path`.<br></p><p>So the external API label is not simply defaulted to the name of the variable within the function scope.<br></p><p>&gt;&gt; All of my inclinations for C-style syntactical languages say the API<br>&gt;&gt; should be (in order of my conceptual preference model):<br>&gt;&gt; <br>&gt;&gt; grid.add(observer: self, keyPath: graphics)<br>&gt;&gt; <br>&gt;&gt; // or<br>&gt;&gt; <br>&gt;&gt; grid.addObserver(self, keyPath: graphics)<br>&gt;&gt; <br>&gt;&gt; // or<br>&gt;&gt; <br>&gt;&gt; grid.addObserver(self, graphics)<br>&gt; <br>&gt; I think we&#39;re asking you to let go of your inclinations and think more<br>&gt; carefully about what will serve the reader of code using your API :-).<br>&gt; This is less about having a pattern to follow than about how to make<br>&gt; choices that lead to readable, maintainable code.<br></p><p>I&#39;m trying to, but we&#39;re not really following the ObjC guidelines either. At least on paper. I think you keep talking about readable APIs, but I feel the guidelines keep talking more about descriptive. The difference is subtle, I agree. But I think it&#39;s the difference between these two APIs:<br></p><p>items.insert(12, atIndex: 2)  // or items.insert(12, at: 2)<br></p><p>items.insert(12, index: 2)<br></p><p>Again, it&#39;s about which is supposed to be &quot;canonical&quot; Swift.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/3b47954e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 24, 2016 at 07:00:00pm</p></header><div class="content"><p>on Sun Jan 24 2016, David Owens II &lt;david-AT-owensd.io&gt; wrote:<br></p><p>&gt;&gt; On Jan 24, 2016, at 11:17 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Sat Jan 23 2016, David Owens II &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; I think Joe&#39;s reply is a pretty good summary.<br>&gt;&gt; <br>&gt;&gt; Hi David,<br>&gt;&gt; <br>&gt;&gt; Let me start by expressing my appreciation for the way you&#39;re struggling<br>&gt;&gt; with the hard issues here.  The questions you&#39;re asking reflect many of<br>&gt;&gt; the same ones we asked ourselves during the development of these<br>&gt;&gt; guidelines.<br>&gt;&gt; <br>&gt;&gt;&gt; At a high-level, I really get no sense on how APIs are really supposed<br>&gt;&gt;&gt; to be developed in Swift. Joe talks about second arguments generally<br>&gt;&gt;&gt; becoming prepositional phrases, but is that the true intent? Because<br>&gt;&gt;&gt; that&#39;s not what the guideline says, nor what the language semantics<br>&gt;&gt;&gt; really promote or suggest to do.<br>&gt;&gt; <br>&gt;&gt; No, that&#39;s not the intent of the guideline.<br>&gt;<br>&gt; &quot;The use of external parameter names can allow a function to be called<br>&gt; in an expressive, sentence-like manner, while still providing a<br>&gt; function body that is readable and clear in intent.&quot;<br>&gt;<br>&gt; Source:<br>&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html<br>&gt;<br>&gt; That&#39;s the 2.1 guide, so your mileage may vary in 3.0, but that&#39;s some<br>&gt; of the baggage coming in to this review.<br></p><p>Understood; the &quot;sentence-like&quot; idea keeps getting repeated.  The<br>keepers of Cocoa APIs tell me that, since several years ago, they moved<br>away from adding prepositions to secondary selector pieces to make<br>things more sentence-like.<br></p><p>&gt; The problem I see is that there is a mixed bag of what &quot;good&quot; APIs<br>&gt; look like. And when push comes to shove, code wins. The libraries<br>&gt; exposed in code, even through the ObjC bridging, will be used as the<br>&gt; basis of what determines what good Swift APIs look like more than a<br>&gt; published doc.<br></p><p>Yep.  But a big part of the reason to publish the doc is so we can<br>decide what direction to push the library APIs.<br></p><p>&gt; However, what I see is the struggle between creating good API call<br>&gt; sites, what the defaults of the language provide today, and what the<br>&gt; guidelines are saying and comparing those to what we get from the new<br>&gt; Swift APIs and the updated ObjC imported APIs.<br>&gt;<br>&gt; By default we get this:<br>&gt;<br>&gt; func max(a: Int, b: Int) -&gt; Int<br>&gt; max(a, b: 12)<br>&gt;<br>&gt; func addObserver(observer: Observable, path: String)<br>&gt; thing.addObserver(observing, path: &quot;/path/to/observe&quot;)<br>&gt;<br>&gt; public func strideTo(end: Self, stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt; thing.strideTo(10, stride: 1)<br>&gt;<br>&gt; Of the three, only the addObserver are APIs I deem to be<br>&gt; acceptable. <br></p><p>IIUC you&#39;d prefer to see an initial argument label on the stride<br>function?  I get that, but can you explain why you consider the<br>alternative to be *unacceptable*?  Even below, where you talk about why<br>it might be better to use a label, you don&#39;t really make the case for<br>why we shouldn&#39;t tolerate not using one.<br></p><p>&gt; Of course, there are many examples to prove any given point, but I<br>&gt; think these represent the common cases.<br>&gt;<br>&gt; 1. Labels are obviously bad (max)<br></p><p>Covered by the guidelines.<br></p><p>&gt; 2. Labels are fine though the external label could be better (addObserver)<br>&gt; 3. Exposes an implementation name that really confuses the API (strideTo)<br>&gt;<br>&gt; (more on this example a bit later)<br>&gt;<br>&gt;&gt;&gt; For example, the guidelines say to do one thing but the example does<br>&gt;&gt;&gt; something different:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Compensate For Weak Type Information as needed to clarify a parameter’s role.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Especially when a parameter type is NSObject, Any, AnyObject, or a<br>&gt;&gt;&gt;&gt; fundamental type such Int or String, type information and context at<br>&gt;&gt;&gt;&gt; the point of use may not fully convey intent. In this example, the<br>&gt;&gt;&gt;&gt; declaration may be clear, but the use site is vague:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func add(observer: NSObject, for keyPath: String)<br>&gt;&gt;&gt;&gt; grid.add(self, for: graphics)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To restore clarity, precede each weakly-typed parameter with a<br>&gt;&gt;&gt;&gt; noun describing its role:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func addObserver(_ observer: NSObject, forKeyPath path: String)<br>&gt;&gt;&gt;&gt; grid.addObserver(self, forKeyPath: graphics) // clear<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example already had a &quot;for&quot; in the label, but if it were not<br>&gt;&gt;&gt; already there, the API, according to the guidelines, should become<br>&gt;&gt;&gt; this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func addObserver(_ observer: NSObject, keyPath path: String)<br>&gt;&gt;&gt; grid.addObserver(self, keyPath: graphics) // clear<br>&gt;&gt; <br>&gt;&gt; The reason &quot;for&quot; is there is that otherwise you can&#39;t tell what the<br>&gt;&gt; relationship between the observer and the keyPath is.  For example, if<br>&gt;&gt; it had been &quot;at&quot; instead of &quot;for,&quot; it would completely change the<br>&gt;&gt; meaning. &quot;Of&quot; would probably be more descriptive, frankly.  But the<br>&gt;&gt; example isn&#39;t trying to illustrate anything about that preposition or<br>&gt;&gt; that relationship.  <br>&gt;<br>&gt; Right, but the argument is that the API is indeed better with the<br>&gt; &quot;for&quot; preposition. I believe it is, I think you are also saying that<br>&gt; it is.<br></p><p>Yes.  So... what are we arguing about?<br></p><p>&gt; This is the closest guideline that I think attempts to address it:<br>&gt;<br>&gt;&gt; Clarity at the point of use is your most important goal. Code is<br>&gt;&gt; read far more than it is written.<br>&gt;<br>&gt; But the clarity here is, ironically, inherently ambiguous. Clarity<br>&gt; could mean to make the weak type information known. Clarity could be<br>&gt; about intention of how the parameter could be used. Clarity could<br>&gt; simply be a more verbose name that provides additional context. I<br>&gt; think it would be clear to have guidelines that actually describe what<br>&gt; you think make up a good call site.<br></p><p>We intend that to mean &quot;clarity of semantics.&quot;  Would that change, um,<br>clear this up for you?<br></p><p>&gt; thing.strideTo(10, stride: 1) // clear<br>&gt; thing.strideTo(10, by: 1)     // clear and linguistically better<br>&gt; thing.strideTo(10, 1)         // not clear<br></p><p>Actually I think the first is unclear simply because the word &quot;stride&quot;<br>takes two different roles, one as a noun and one as a verb.  It&#39;s<br>possible to misinterpret the 1 as being an expression of the word in the<br>base name, or at least it&#39;s possible to be confused by that until you<br>work out all the reasons that it doesn&#39;t make sense.<br></p><p>&gt; Both provide some amount clarity at the call site as the value of 1 is<br>&gt; quite clear what it means. So in one sense, I agree that the defaults<br>&gt; of the language today push you towards clarity.<br>&gt;<br>&gt; To me, the guidelines, as I understand them, lead us to the first<br>&gt; option when I believe the intent is to actually get to the second<br>&gt; usage.<br></p><p>Yes, IMO that is the intent!  But why do you think they lead us to the<br>first option?  Because they explicitly mention using nouns to clarify<br>roles?<br></p><p>&gt;&gt;&gt; Especially when compared with the ObjC import items. Seemingly, the<br>&gt;&gt;&gt; ObjC APIs would be using prepositional clauses for parameter labels<br>&gt;&gt;&gt; while the Swift labels would simply be more descriptive nouns.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what you mean here, sorry.<br>&gt;<br>&gt; Many of the ObjC APIs will come across with prepositions in the<br>&gt; external labels, such as:<br>&gt;<br>&gt; func insert(_ anObject: AnyObject, atIndex index: Int)<br></p><p>That&#39;ll come in as<br></p><p>  func insert(_ anObject: AnyObject, at index: Int)<br></p><p>&gt; Whereas my interpretation of the Swift 3.0 guidelines would say to<br>&gt; design that API like this:<br>&gt;<br>&gt; func insert(_ anObject: AnyObject, index: Int)<br></p><p>That&#39;s not the intent; the intent would be to move you toward what I<br>wrote above.<br></p><p>&gt; So when we look at the various API options in front of us when<br>&gt; designing new APIs, do we use &quot;atIndex&quot;, &quot;at&quot;, or simply stick with<br>&gt; the default &quot;index&quot;? This is where I think the guidelines don&#39;t help<br>&gt; steer us in any direction.<br></p><p>Fair point; we could be more explicit about that.  I think the<br>admonition to avoid merely repeating type information is the applicable<br>one here, but it really only works to push you away from &quot;index&quot; in the<br>context of an associated Index type, and NSArray doesn&#39;t have one.  You<br>can see the idea expressed in the importer rules at<br>https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br></p><p>,----<br>| Index in the selector piece matches Int in the type name:<br>| <br>| func characterAtIndex(_: Int) -&gt; unichar<br>|                 ~~~~~    ~~~<br>`----<br></p><p>&gt; However, indeed someone thinks that we should use &quot;at&quot;, but based on<br>&gt; the guidelines, it&#39;s really hard to understand why:<br>&gt;<br>&gt; -  mutating func insert(newElement: Iterator.Element, atIndex i: Int)<br>&gt; +  mutating func insert(newElement: Iterator.Element, at i: Int)<br>&gt;<br>&gt; Again, I agree that &quot;at&quot; reads better at the call site. However, it<br>&gt; doesn&#39;t provide any real clarity over the default &quot;index&quot; (sidenote: i<br>&gt; is still a bad choice ;)), <br></p><p>It all depends on what it does for the doc comment.  IMO there&#39;s nothing<br>wrong with “Inserts `newElement` before the `i`th element, or at the end<br>if `i == count`”.<br></p><p>&gt; and in some ways, it could be argued that it&#39;s slightly<br>&gt; ambiguous. Does the below mean insert &quot;12&quot; at the index of &quot;2&quot; or at<br>&gt; the value matching &quot;2&quot;?<br>&gt;<br>&gt; items.insert(12, at: 2)<br>&gt;<br>&gt; While this version does not even have that ambiguity. This also<br>&gt; relates to the &quot;weak type information&quot; guidelines.<br>&gt;<br>&gt; items.insert(12, atIndex: 2)<br></p><p>Yes.  This all becomes a little bit more complicated when you consider<br>fitting it into code with generics, because you can&#39;t know when an<br>associated type might have a broader role.<br></p><p>&gt;&gt;&gt; The rules I described are keeping in strict guidance to the API design<br>&gt;&gt;&gt; guidelines of adding nouns. So the above would actually be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func add(observer o: NSObject, keyPath path: String)<br>&gt;&gt;&gt; grid.add(observer: self, keyPath: graphics)<br>&gt;&gt; <br>&gt;&gt; I&#39;ll have to go back and look at the rules you described, but regarding<br>&gt;&gt; the above example, my reason to keep &quot;observer&quot; in the base name is that<br>&gt;&gt; adding observers is really a totally distinct thing from adding, say,<br>&gt;&gt; gesture recognizers, or animation steps, or anything else.  There isn&#39;t<br>&gt;&gt; one big pot to which you&#39;re adding everything.  If there were, the<br>&gt;&gt; receiver would be like a collection, and we wouldn&#39;t need a noun there<br>&gt;&gt; at all.<br>&gt;<br>&gt; Granted, this is the case some of the times. However, if the protocol is this:<br>&gt;<br>&gt; protocol Observable {<br>&gt;     func add(observable o: NSObject, forKeyPath path: String)<br>&gt;     func remove(observable o: NSObject)<br></p><p>[don&#39;t you mean &quot;observer o:&quot; above?]<br></p><p>&gt; }<br>&gt;<br>&gt; I actually really hard pressed to come up with a definitive example as<br>&gt; to why that should be allowed. The best I can argue is that &quot;add&quot;<br>&gt; itself is too generic and could be confused on the implementing type<br>&gt; that may also have an &quot;add&quot; function. However, the additional label<br>&gt; information helps with that.<br></p><p>You have to consider how this protocol is going to be used; it&#39;s a<br>mix-in that will be broadly applied to many things that could add an<br>NSObject for many purposes.  Unfortunately, as hard as we tried, we were<br>unable to come up with guidelines that actually make API design easy!<br></p><p>&gt; Also, the argument against this one:<br>&gt;<br>&gt; protocol Observable {<br>&gt;     func addObservable(o: NSObject, forKeyPath path: String)<br>&gt;     func removeObservable(o: NSObject)<br>&gt; }<br>&gt;<br>&gt; Would seem to be me that we are simply duplicating type<br>&gt; information. <br></p><p>Where?  There&#39;s nothing about NSObject that implies it&#39;s an observer.  I<br>could see that argument with<br></p><p>  protocol Observable {<br>      func addObserver(o: Observer, forKeyPath path: String)<br>      func removeObserver(o: Observer)<br>  }<br></p><p>&gt; Maybe it&#39;s more clear?<br>&gt;<br>&gt; In any respect, I at least submit that &quot;addObservable&quot; in this case is<br>&gt; definitely in the grey area.<br>&gt;<br>&gt; However, I absolutely believe that the &quot;strideTo/strideThrough&quot;<br>&gt; example is clearly on the side of really being part of the argument<br>&gt; label. In both cases we are striding, the difference is on where we<br>&gt; stop.<br>&gt;<br>&gt; extension Strideable {<br>&gt;<br>&gt; -  public func stride(to end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>&gt; +  public func strideTo(end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>&gt;<br>&gt;  }<br>&gt;<br>&gt;  extension Strideable {<br>&gt;<br>&gt; -  public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt; +  public func strideThrough(end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt;<br>&gt;  }<br>&gt;<br>&gt; This change seems to be simply because the usage of labelled first<br>&gt; parameters are frowned up, not because it&#39;s actually a better place to<br>&gt; describe what is going on.<br></p><p>I can&#39;t argue with you here.<br></p><p>&gt;&gt;&gt; However, if the API guidelines are really about creating APIs that are<br>&gt;&gt;&gt; to be read in a more English-like manner, like ObjC APIs are designed,<br>&gt;&gt;&gt; then the guidelines should really be amended to make that clear.<br>&gt;&gt; <br>&gt;&gt; The point of the guidelines is not to make code look like English; it&#39;s<br>&gt;&gt; to make code clear and understandable.  It happens that in many cases,<br>&gt;&gt; leveraging English grammar serves that purpose well.  In other cases<br>&gt;&gt; it&#39;s necessary to take a different approach, which is why we have sin(x)<br>&gt;&gt; and zip(x, y).  But as I think we make clear, one shouldn&#39;t add words<br>&gt;&gt; just to make an API more “English-like.”<br>&gt;&gt; <br>&gt;&gt;&gt; If the intention is truly that Swift APIs are supposed to read as<br>&gt;&gt;&gt; naturally as ObjC APIs, <br>&gt;&gt; <br>&gt;&gt; Ah... “naturally” is in the eye of the beholder, though.<br>&gt;<br>&gt; Not quite, I think we can objectively say that this:<br>&gt;<br>&gt; items.insert(12, atIndex: 2)<br>&gt;<br>&gt; Reads far more naturally than this:<br>&gt;<br>&gt; items.insert(12, index: 2)<br>&gt;<br>&gt; In the later, you have to add words to make the API read fluidly. The<br>&gt; former simply does by the nature of the words.<br></p><p>Agreed.<br></p><p>&gt;&gt;&gt; then I completely agree with Joe that there should be a language<br>&gt;&gt;&gt; change to actually require the label for parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func addObserver(o: NSObject, path: String) // error: Argument<br>&gt;&gt;&gt; label required for `path`.<br>&gt;&gt; <br>&gt;&gt; I&#39;m confused; &quot;path&quot; has an argument label; it&#39;s &quot;path.&quot;<br>&gt;<br>&gt; What I&#39;m saying is that this is a compiler error:<br>&gt;<br>&gt; func addObserver(o: NSObject, path: String) // error: Argument label<br>&gt; required for `path`.<br>&gt;<br>&gt; While this version is not:<br>&gt;<br>&gt; func addObserver(o: NSObject, forKeyPath path: String) // error:<br>&gt; Argument label required for `path`.<br>&gt;<br>&gt; So the external API label is not simply defaulted to the name of the<br>&gt; variable within the function scope.<br></p><p>OK.<br></p><p>&gt;&gt;&gt; All of my inclinations for C-style syntactical languages say the API<br>&gt;&gt;&gt; should be (in order of my conceptual preference model):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; grid.add(observer: self, keyPath: graphics)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; grid.addObserver(self, keyPath: graphics)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // or<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; grid.addObserver(self, graphics)<br>&gt;&gt; <br>&gt;&gt; I think we&#39;re asking you to let go of your inclinations and think more<br>&gt;&gt; carefully about what will serve the reader of code using your API :-).<br>&gt;&gt; This is less about having a pattern to follow than about how to make<br>&gt;&gt; choices that lead to readable, maintainable code.<br>&gt;<br>&gt; I&#39;m trying to, but we&#39;re not really following the ObjC guidelines<br>&gt; either. At least on paper. I think you keep talking about readable<br>&gt; APIs, but I feel the guidelines keep talking more about<br>&gt; descriptive. <br>&gt;<br>&gt; The difference is subtle, I agree. But I think it&#39;s the difference<br>&gt; between these two APIs:<br>&gt;<br>&gt; items.insert(12, atIndex: 2)  // or items.insert(12, at: 2)<br>&gt;<br>&gt; items.insert(12, index: 2)<br>&gt;<br>&gt; Again, it&#39;s about which is supposed to be &quot;canonical&quot; Swift.<br></p><p><br>OK, I&#39;ll try to come up with some wording adjustments that sort this out.<br></p><p>Thanks for your patience,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>January 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 24, 2016, at 7:07 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; Understood; the &quot;sentence-like&quot; idea keeps getting repeated.  The<br>&gt; keepers of Cocoa APIs tell me that, since several years ago, they moved<br>&gt; away from adding prepositions to secondary selector pieces to make<br>&gt; things more sentence-like.<br></p><p>Yes, I’ve noticed that as well. <br></p><p><br>&gt;&gt; The problem I see is that there is a mixed bag of what &quot;good&quot; APIs<br>&gt;&gt; look like. And when push comes to shove, code wins. The libraries<br>&gt;&gt; exposed in code, even through the ObjC bridging, will be used as the<br>&gt;&gt; basis of what determines what good Swift APIs look like more than a<br>&gt;&gt; published doc.<br>&gt; <br>&gt; Yep.  But a big part of the reason to publish the doc is so we can<br>&gt; decide what direction to push the library APIs.<br></p><p>I agree. And really, I find most of the doc fairly good.<br></p><p>&gt;&gt;&gt; The reason &quot;for&quot; is there is that otherwise you can&#39;t tell what the<br>&gt;&gt;&gt; relationship between the observer and the keyPath is.  For example, if<br>&gt;&gt;&gt; it had been &quot;at&quot; instead of &quot;for,&quot; it would completely change the<br>&gt;&gt;&gt; meaning. &quot;Of&quot; would probably be more descriptive, frankly.  But the<br>&gt;&gt;&gt; example isn&#39;t trying to illustrate anything about that preposition or<br>&gt;&gt;&gt; that relationship.  <br>&gt;&gt; <br>&gt;&gt; Right, but the argument is that the API is indeed better with the<br>&gt;&gt; &quot;for&quot; preposition. I believe it is, I think you are also saying that<br>&gt;&gt; it is.<br>&gt; <br>&gt; Yes.  So... what are we arguing about?<br></p><p>At the heart of it, that the guidelines don’t seem to help one down a path to use prepositions, but rather only descriptive nouns. <br></p><p>So in one sense you are arguing to make things more English-like because they read better at the call site, but on the other, you’ve stated APIs reading more English-like is a non-goal. Basically, I think the guideline tries to give some rules on how to get get APIs, but doesn’t talk much about what a good API is.<br></p><p>&gt;&gt; This is the closest guideline that I think attempts to address it:<br>&gt;&gt; <br>&gt;&gt;&gt; Clarity at the point of use is your most important goal. Code is<br>&gt;&gt;&gt; read far more than it is written.<br>&gt;&gt; <br>&gt;&gt; But the clarity here is, ironically, inherently ambiguous. Clarity<br>&gt;&gt; could mean to make the weak type information known. Clarity could be<br>&gt;&gt; about intention of how the parameter could be used. Clarity could<br>&gt;&gt; simply be a more verbose name that provides additional context. I<br>&gt;&gt; think it would be clear to have guidelines that actually describe what<br>&gt;&gt; you think make up a good call site.<br>&gt; <br>&gt; We intend that to mean &quot;clarity of semantics.&quot;  Would that change, um,<br>&gt; clear this up for you?<br></p><p>Maybe so.<br></p><p>&gt; <br>&gt;&gt; thing.strideTo(10, stride: 1) // clear<br>&gt;&gt; thing.strideTo(10, by: 1)     // clear and linguistically better<br>&gt;&gt; thing.strideTo(10, 1)         // not clear<br>&gt; <br>&gt; Actually I think the first is unclear simply because the word &quot;stride&quot;<br>&gt; takes two different roles, one as a noun and one as a verb.  It&#39;s<br>&gt; possible to misinterpret the 1 as being an expression of the word in the<br>&gt; base name, or at least it&#39;s possible to be confused by that until you<br>&gt; work out all the reasons that it doesn&#39;t make sense.<br>&gt; <br>&gt;&gt; Both provide some amount clarity at the call site as the value of 1 is<br>&gt;&gt; quite clear what it means. So in one sense, I agree that the defaults<br>&gt;&gt; of the language today push you towards clarity.<br>&gt;&gt; <br>&gt;&gt; To me, the guidelines, as I understand them, lead us to the first<br>&gt;&gt; option when I believe the intent is to actually get to the second<br>&gt;&gt; usage.<br>&gt; <br>&gt; Yes, IMO that is the intent!  But why do you think they lead us to the<br>&gt; first option?  Because they explicitly mention using nouns to clarify<br>&gt; roles?<br></p><p>Yeah. I don’t think you actually mean descriptive nouns.<br></p><p>&gt;&gt; However, indeed someone thinks that we should use &quot;at&quot;, but based on<br>&gt;&gt; the guidelines, it&#39;s really hard to understand why:<br>&gt;&gt; <br>&gt;&gt; -  mutating func insert(newElement: Iterator.Element, atIndex i: Int)<br>&gt;&gt; +  mutating func insert(newElement: Iterator.Element, at i: Int)<br>&gt;&gt; <br>&gt;&gt; Again, I agree that &quot;at&quot; reads better at the call site. However, it<br>&gt;&gt; doesn&#39;t provide any real clarity over the default &quot;index&quot; (sidenote: i<br>&gt;&gt; is still a bad choice ;)), <br>&gt; <br>&gt; It all depends on what it does for the doc comment.  IMO there&#39;s nothing<br>&gt; wrong with “Inserts `newElement` before the `i`th element, or at the end<br>&gt; if `i == count`”.<br></p><p>Hmm… we disagree on that point. If I need to go the documentation to get basic clarification of the parameter, I’m not really sure what the point of the label is then.<br></p><p>&gt;&gt; I actually really hard pressed to come up with a definitive example as<br>&gt;&gt; to why that should be allowed. The best I can argue is that &quot;add&quot;<br>&gt;&gt; itself is too generic and could be confused on the implementing type<br>&gt;&gt; that may also have an &quot;add&quot; function. However, the additional label<br>&gt;&gt; information helps with that.<br>&gt; <br>&gt; You have to consider how this protocol is going to be used; it&#39;s a<br>&gt; mix-in that will be broadly applied to many things that could add an<br>&gt; NSObject for many purposes.  Unfortunately, as hard as we tried, we were<br>&gt; unable to come up with guidelines that actually make API design easy!<br></p><p>Agreed. API design isn’t easy. =)<br></p><p>&gt;&gt; However, I absolutely believe that the &quot;strideTo/strideThrough&quot;<br>&gt;&gt; example is clearly on the side of really being part of the argument<br>&gt;&gt; label. In both cases we are striding, the difference is on where we<br>&gt;&gt; stop.<br>&gt;&gt; <br>&gt;&gt; extension Strideable {<br>&gt;&gt; <br>&gt;&gt; -  public func stride(to end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>&gt;&gt; +  public func strideTo(end: Self, by stride: Stride) -&gt; StrideTo&lt;Self&gt;<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Strideable {<br>&gt;&gt; <br>&gt;&gt; -  public func stride(through end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt;&gt; +  public func strideThrough(end: Self, by stride: Stride) -&gt; StrideThrough&lt;Self&gt;<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This change seems to be simply because the usage of labelled first<br>&gt;&gt; parameters are frowned up, not because it&#39;s actually a better place to<br>&gt;&gt; describe what is going on.<br>&gt; <br>&gt; I can&#39;t argue with you here.<br></p><p>So the question is this though: what is the better Swift API? I think examples like these and reasons as to why one is chosen over the other at least help with the guidelines being more inclusive. I agree that it’s very hard to generalize something as subjective as a “good API”. So in light of that, I think more examples of some of the boundaries edges at least give people some reference to compare ask, “is my API more like this or more like that?”<br></p><p>&gt;&gt; I&#39;m trying to, but we&#39;re not really following the ObjC guidelines<br>&gt;&gt; either. At least on paper. I think you keep talking about readable<br>&gt;&gt; APIs, but I feel the guidelines keep talking more about<br>&gt;&gt; descriptive. <br>&gt;&gt; <br>&gt;&gt; The difference is subtle, I agree. But I think it&#39;s the difference<br>&gt;&gt; between these two APIs:<br>&gt;&gt; <br>&gt;&gt; items.insert(12, atIndex: 2)  // or items.insert(12, at: 2)<br>&gt;&gt; <br>&gt;&gt; items.insert(12, index: 2)<br>&gt;&gt; <br>&gt;&gt; Again, it&#39;s about which is supposed to be &quot;canonical&quot; Swift.<br>&gt; <br>&gt; <br>&gt; OK, I&#39;ll try to come up with some wording adjustments that sort this out.<br>&gt; <br>&gt; Thanks for your patience,<br></p><p>Thanks for being willing to listen and discuss!<br></p><p>-David<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 26, 2016 at 06:00:00am</p></header><div class="content"><p>Am 25.01.2016 um 04:07 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; &quot;The use of external parameter names can allow a function to be called<br>&gt;&gt; in an expressive, sentence-like manner, while still providing a<br>&gt;&gt; function body that is readable and clear in intent.&quot;<br>&gt;&gt; <br>&gt;&gt; Source:<br>&gt;&gt; https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Functions.html<br>&gt;&gt; <br>&gt;&gt; That&#39;s the 2.1 guide, so your mileage may vary in 3.0, but that&#39;s some<br>&gt;&gt; of the baggage coming in to this review.<br>&gt; <br>&gt; Understood; the &quot;sentence-like&quot; idea keeps getting repeated.  The<br>&gt; keepers of Cocoa APIs tell me that, since several years ago, they moved<br>&gt; away from adding prepositions to secondary selector pieces to make<br>&gt; things more sentence-like.<br></p><p>IMO being able to make signatures read more sentence-like is a real advantage of Smalltalk, Objective-C and now Swift with its external labels over other languages, so it&#39;s a bit sad to hear that.<br></p><p>-Thorsten<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>January 25, 2016 at 06:00:00pm</p></header><div class="content"><p>_Can we_ say that objectively, though?<br></p><p>I would agree that <br></p><p>&gt; items.insert(12, atIndex: 2)<br></p><p>reads more _like an English_ sentence than without the “at”. But I would hold back from saying “reads more naturally” / “more fluidly”, because it suggests to me that it’s inherently better. And I’m not sure I agree.<br></p><p>I think there’s an agreement that making Swift sound like English is a non-goal. In fact, trying to do so is often harmful as we end up putting unnecessary words, like “with”, “and”, “by”, etc. (I’m not saying they’re always unnecessary; they often help convey the semantics or intent, or are needed for the method name to make sense. But too often they’re just glue words used to make code sound like English without any actual readability benefits, and merely adding noise.)<br></p><p>Personally, out of:<br></p><p>1. insert(12, at: 2)<br>2. insert(12, atIndex: 2)<br>3. insert(12, index: 3)<br></p><p>I like 1 and 2 best. 1) is neat, short, and still understandable in the context of collections. 3) describes the parameter more explicitly, still clear. 2) tries to do both, but it’s really unnecessary. It adds no readability value in my mind over either.<br></p><p>— Radek<br></p><p>&gt; On 25 Jan 2016, at 01:33, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Not quite, I think we can objectively say that this:<br>&gt; <br>&gt; items.insert(12, atIndex: 2)<br>&gt; <br>&gt; Reads far more naturally than this:<br>&gt; <br>&gt; items.insert(12, index: 2)<br>&gt; <br>&gt; In the later, you have to add words to make the API read fluidly. The former simply does by the nature of the words.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/e6a3c675/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
