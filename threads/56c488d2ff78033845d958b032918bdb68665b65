<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Generic Alaises</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>This was inspired from the topic about moving where clauses out of<br>parameter lists.<br></p><p>Certain generics get very long winded, I was wondering if we could create<br>some sort of alias for generics.<br></p><p>func anyCommonElements &lt;T: SequenceType, U: SequenceType where<br>T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;<br>(lhs: T, _ rhs: U) -&gt; Bool<br></p><p>could be shared across functions like so:<br></p><p>genericalias SequencesWithSameElements&lt;T, U&gt; =  &lt;T: SequenceType, U:<br>SequenceType where T.Generator.Element: Equatable, T.Generator.Element ==<br>U.Generator.Element&gt;<br></p><p>func anyCommonElements &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt;<br>Bool<br>func == &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br></p><p>*___________________________________*<br></p><p>*James⎥*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/56c45b65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Generic Alaises</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>Chris Lattner has a proposal under review &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md&gt; on this topic. <br></p><p>milos<br></p><p>&gt; On 6 Apr 2016, at 20:41, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This was inspired from the topic about moving where clauses out of parameter lists.<br>&gt; <br>&gt; Certain generics get very long winded, I was wondering if we could create some sort of alias for generics.<br>&gt; <br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; <br>&gt; could be shared across functions like so:<br>&gt; <br>&gt; genericalias SequencesWithSameElements&lt;T, U&gt; =  &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;<br>&gt; <br>&gt; func anyCommonElements &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; func == &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/6eac54c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>Generic Alaises</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>April  6, 2016 at 09:00:00pm</p></header><div class="content"><p>It&#39;s not the same topic. Let&#39;s take an example: suppose we have a data<br>structure for a graph of nodes and edges, where the nodes and edges are<br>indexed and both have values. So we have a Graph&lt;NodeIndex : Hashable,<br>EdgeIndex : Hashable, NodeValue, EdgeValue&gt;.<br>Now suppose we want a shortest path from one node to another, and we have a<br>data structure to represent that. Now we have a Path&lt;NodeIndex : Hashable,<br>EdgeIndex : Hashable, NodeValue, EdgeValue&gt;. They both have the same<br>&#39;generic signature&#39;. If you&#39;re navigating a Graph&lt;String, Int, City,<br>Motorway&gt;, you&#39;re going to want a Path&lt;String, Int, City, Motorway&gt; as<br>output.<br></p><p>Right now you might write that as:<br>func shortestPath&lt;NodeIndex, EdgeIndex, NodeValue,<br>EdgeValue&gt;(graph:Graph&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;,<br>startNode: NodeIndex, endNode: NodeIndex&gt; -&gt; Path&lt;NodeIndex, EdgeIndex,<br>NodeValue, EdgeValue&gt;<br></p><p>It might save a fair amount of typing if we had a generic equivalent to<br>both typealias and associatedtype.<br></p><p>associatedgenerics GraphElements = &lt;NodeIndex : Hashable, EdgeIndex :<br>Hashable, NodeValue, EdgeValue&gt;<br>func shortestPath&lt;GraphElements&gt;(graph: Graph&lt;GraphElements&gt;,<br>startNode&lt;GraphElements.NodeIndex&gt;, endNode&lt;GraphElements.NodeIndex&gt;) -&gt;<br>Path&lt;GraphElements&gt;<br></p><p>genericalias NavigationGraphElements = GraphElements&lt;String, Int, City,<br>Motorway&gt;<br></p><p>typealias NavigationGraph = Graph&lt;NavigationGraphElements&gt;<br>// navigationGraph.shortestPath() now returns a<br>Path&lt;NavigationGraphElements&gt;<br>// this last part is closest to the proposal under review.<br></p><p><br>On Wed, Apr 6, 2016 at 9:05 PM, Milos Rankovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Chris Lattner has a proposal under review<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md&gt; on<br>&gt; this topic.<br>&gt;<br>&gt; milos<br>&gt;<br>&gt; On 6 Apr 2016, at 20:41, James Campbell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This was inspired from the topic about moving where clauses out of<br>&gt; parameter lists.<br>&gt;<br>&gt; Certain generics get very long winded, I was wondering if we could create<br>&gt; some sort of alias for generics.<br>&gt;<br>&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where<br>&gt; T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;<br>&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;<br>&gt; could be shared across functions like so:<br>&gt;<br>&gt; genericalias SequencesWithSameElements&lt;T, U&gt; =  &lt;T: SequenceType, U:<br>&gt; SequenceType where T.Generator.Element: Equatable, T.Generator.Element ==<br>&gt; U.Generator.Element&gt;<br>&gt;<br>&gt; func anyCommonElements &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt;<br>&gt; Bool<br>&gt; func == &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;<br>&gt; *___________________________________*<br>&gt;<br>&gt; *James⎥*<br>&gt;<br>&gt; *james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com<br>&gt; &lt;http://supmenow.com/&gt;*<br>&gt;<br>&gt; *Sup*<br>&gt;<br>&gt; *Runway East *<br>&gt;<br>&gt; *10 Finsbury Square*<br>&gt;<br>&gt; *London*<br>&gt;<br>&gt; * EC2A 1AF *<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/cac264bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Generic Alaises</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>April  6, 2016 at 08:00:00pm</p></header><div class="content"><p>Ross put it better than I ever could :) yes this is what I meant <br></p><p>Sent from Supmenow.com<br></p><p><br></p><p><br>On Wed, Apr 6, 2016 at 1:45 PM -0700, &quot;Ross O&#39;Brien&quot; &lt;narrativium+swift at gmail.com&gt; wrote:<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>It&#39;s not the same topic. Let&#39;s take an example: suppose we have a data structure for a graph of nodes and edges, where the nodes and edges are indexed and both have values. So we have a Graph&lt;NodeIndex : Hashable, EdgeIndex : Hashable, NodeValue, EdgeValue&gt;.Now suppose we want a shortest path from one node to another, and we have a data structure to represent that. Now we have a Path&lt;NodeIndex : Hashable, EdgeIndex : Hashable, NodeValue, EdgeValue&gt;. They both have the same &#39;generic signature&#39;. If you&#39;re navigating a Graph&lt;String, Int, City, Motorway&gt;, you&#39;re going to want a Path&lt;String, Int, City, Motorway&gt; as output.<br>Right now you might write that as:func shortestPath&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;(graph:Graph&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;, startNode: NodeIndex, endNode: NodeIndex&gt; -&gt; Path&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;<br>It might save a fair amount of typing if we had a generic equivalent to both typealias and associatedtype.<br>associatedgenerics GraphElements = &lt;NodeIndex : Hashable, EdgeIndex : Hashable, NodeValue, EdgeValue&gt;func shortestPath&lt;GraphElements&gt;(graph: Graph&lt;GraphElements&gt;, startNode&lt;GraphElements.NodeIndex&gt;, endNode&lt;GraphElements.NodeIndex&gt;) -&gt; Path&lt;GraphElements&gt;<br>genericalias NavigationGraphElements = GraphElements&lt;String, Int, City, Motorway&gt;<br>typealias NavigationGraph = Graph&lt;NavigationGraphElements&gt;// navigationGraph.shortestPath() now returns a Path&lt;NavigationGraphElements&gt;// this last part is closest to the proposal under review.<br></p><p>On Wed, Apr 6, 2016 at 9:05 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Chris Lattner has a proposal under review on this topic. <br>milos<br></p><p>On 6 Apr 2016, at 20:41, James Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>This was inspired from the topic about moving where clauses out of parameter lists.<br>Certain generics get very long winded, I was wondering if we could create some sort of alias for generics.<br>func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br></p><p>could be shared across functions like so:<br>genericalias SequencesWithSameElements&lt;T, U&gt; =  &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;<br>func anyCommonElements &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>func == &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br></p><p><br>___________________________________<br></p><p>James⎥<br></p><p>james at supmenow.com⎥supmenow.com<br></p><p>Sup<br></p><p>Runway East <br></p><p>10 Finsbury Square<br></p><p>London<br></p><p> EC2A 1AF <br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>_______________________________________________<br></p><p>swift-evolution mailing list<br></p><p>swift-evolution at swift.org<br></p><p>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/9ab01a6a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6d3081a5b9c408dfecc2681ab82af734?s=50"></div><header><strong>Generic Alaises</strong> from <string>Milos Rankovic</string> &lt;milos at milos-and-slavica.net&gt;<p>April  6, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi Ross,<br></p><p>That was a hell of an example! However, even with the types as they are now, the code needn’t look so dreadful. With following protocols in place:<br></p><p>protocol Indexed {<br>	associatedtype Index : Hashable<br>	var index: Index { get }<br>}<br></p><p>protocol NodeType : Indexed { }<br>protocol EdgeType: Indexed { }<br></p><p>protocol GraphType {<br>	associatedtype Node : NodeType<br>	associatedtype Edge : EdgeType<br>	<br>	var nodes: [Node] { get }<br>	var edges: [Edge] { get }<br>}<br></p><p>We can define `Graph` and `Path` as:<br></p><p>struct Graph&lt;Node:NodeType, Edge:EdgeType&gt; : GraphType {<br>	let nodes: [Node] = [] // todo<br>	let edges: [Edge] = [] // todo<br>}<br></p><p>struct Path&lt;Node:NodeType, Edge:EdgeType&gt; {}<br></p><p>So the function with the endless signature you’ve got would become:<br></p><p>extension Graph {<br>	func shortestPath(from from: Node, to: Node) -&gt; Path&lt;Node, Edge&gt; {<br>		fatalError(&quot;todo&quot;)<br>	}<br>}<br></p><p>As for my link to Chris’s proposal, all I meant is to point out that there is a proposal under review with an identical name as this thread. I certainly did not mean to discourage discussion James started!<br></p><p>milos<br></p><p>&gt; On 6 Apr 2016, at 21:45, Ross O&#39;Brien &lt;narrativium+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; It&#39;s not the same topic. Let&#39;s take an example: suppose we have a data structure for a graph of nodes and edges, where the nodes and edges are indexed and both have values. So we have a Graph&lt;NodeIndex : Hashable, EdgeIndex : Hashable, NodeValue, EdgeValue&gt;.<br>&gt; Now suppose we want a shortest path from one node to another, and we have a data structure to represent that. Now we have a Path&lt;NodeIndex : Hashable, EdgeIndex : Hashable, NodeValue, EdgeValue&gt;. They both have the same &#39;generic signature&#39;. If you&#39;re navigating a Graph&lt;String, Int, City, Motorway&gt;, you&#39;re going to want a Path&lt;String, Int, City, Motorway&gt; as output.<br>&gt; <br>&gt; Right now you might write that as:<br>&gt; func shortestPath&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;(graph:Graph&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;, startNode: NodeIndex, endNode: NodeIndex&gt; -&gt; Path&lt;NodeIndex, EdgeIndex, NodeValue, EdgeValue&gt;<br>&gt; <br>&gt; It might save a fair amount of typing if we had a generic equivalent to both typealias and associatedtype.<br>&gt; <br>&gt; associatedgenerics GraphElements = &lt;NodeIndex : Hashable, EdgeIndex : Hashable, NodeValue, EdgeValue&gt;<br>&gt; func shortestPath&lt;GraphElements&gt;(graph: Graph&lt;GraphElements&gt;, startNode&lt;GraphElements.NodeIndex&gt;, endNode&lt;GraphElements.NodeIndex&gt;) -&gt; Path&lt;GraphElements&gt;<br>&gt; <br>&gt; genericalias NavigationGraphElements = GraphElements&lt;String, Int, City, Motorway&gt;<br>&gt; <br>&gt; typealias NavigationGraph = Graph&lt;NavigationGraphElements&gt;<br>&gt; // navigationGraph.shortestPath() now returns a Path&lt;NavigationGraphElements&gt;<br>&gt; // this last part is closest to the proposal under review.<br>&gt; <br>&gt; <br>&gt; On Wed, Apr 6, 2016 at 9:05 PM, Milos Rankovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Chris Lattner has a proposal under review &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0048-generic-typealias.md&gt; on this topic. <br>&gt; <br>&gt; milos<br>&gt; <br>&gt;&gt; On 6 Apr 2016, at 20:41, James Campbell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This was inspired from the topic about moving where clauses out of parameter lists.<br>&gt;&gt; <br>&gt;&gt; Certain generics get very long winded, I was wondering if we could create some sort of alias for generics.<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; <br>&gt;&gt; could be shared across functions like so:<br>&gt;&gt; <br>&gt;&gt; genericalias SequencesWithSameElements&lt;T, U&gt; =  &lt;T: SequenceType, U: SequenceType where T.Generator.Element: Equatable, T.Generator.Element == U.Generator.Element&gt;<br>&gt;&gt; <br>&gt;&gt; func anyCommonElements &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; func == &lt;SequencesWithSameElements&gt; (lhs: T, _ rhs: U) -&gt; Bool<br>&gt;&gt; ___________________________________<br>&gt;&gt; <br>&gt;&gt; James⎥<br>&gt;&gt; <br>&gt;&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt;&gt; Sup<br>&gt;&gt; <br>&gt;&gt; Runway East &gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 10 Finsbury Square<br>&gt;&gt; <br>&gt;&gt; London<br>&gt;&gt; <br>&gt;&gt;  &gt;&gt; EC2A 1AF <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/6aae4d58/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
