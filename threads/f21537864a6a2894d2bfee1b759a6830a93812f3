<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/671aaf492518a334ad3b9243cf2b1328?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Florian Liefers</string> &lt;florian at liefers.com&gt;<p>February 15, 2016 at 09:00:00pm</p></header><div class="content"><p>Hi!<br></p><p>I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br></p><p>class View {<br>   func viewDidLoad() {<br>      // does something<br>   }<br>}<br></p><p>class Button: View {<br>  override func viewDidLoad() {<br>      super.viewDidLoad()   // &lt;— this might be forgotten<br>      // do something other<br>   }<br>}<br></p><p>The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br></p><p>// Example for extending a function<br>class Button: View {<br>  extend func viewDidLoad() {<br>      super.viewDidLoad()<br>      // do something<br>   }<br></p><p>  extend func viewDidAppear() {<br>      // do something<br>   } // &lt;— the compiler should throw an error here.<br>}<br></p><p>// Example for replacing a function<br>class Geometry {<br>   func volume() -&gt; Double {<br>      return 0;<br>   }<br>}<br></p><p>class Cube: Geometry {<br>   var length: Double = 0.0<br>   replace func volume() -&gt; Double {<br>      let v = length * length * length<br>      return v<br>   }<br>}<br></p><p>Cheers,<br>Florian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 15, 2016 at 10:00:00pm</p></header><div class="content"><p>This is an interesting idea, and fits well with the theme of preventing mistakes in Swift, but I think that the proposed solution isn’t flexible enough, as there are cases for inheritance patterns where extending doesn’t actually make sense, so having to specify an exception every time could quickly become annoying.<br></p><p>I think the better solution is to instead allow super-classes to specify whether or not their method must be called when overridden/extended. For example:<br></p><p>	class View {<br>		@super(required) func viewDidLoad() { … }<br>	}<br></p><p>	class Button : View {<br>		override func viewDidLoad() { … }<br>	}<br></p><p>	class Widget : View {<br>		override func viewDidLoad() {<br>			super.viewDidLoad()<br>			…<br>		}<br>	}<br></p><p>In this extension of your example Button will cause an error because it overrides viewDidLoad() but fails to call the parent’s method as required by the @super attribute. However, Widget compiles successfully because it follows the requirement.<br></p><p>So the options for @super would be:<br></p><p>required: child-class must call parent implementation of this method.<br>optional: default behaviour, child can choose whether to call the parent’s method.<br>denied: child may not call parent’s method (useful if it makes assumptions that a child-class may not follow), but can still extend/override.<br></p><p>I think this would be a more flexible solution to the problem, and put the decision in the hands of those writing classes designed for inheritance. I’m not 100% sure of whether to rename override to extend, I like extend better personally, but it probably doesn’t matter overall.<br></p><p>&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi!<br>&gt; <br>&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; <br>&gt; class View {<br>&gt;   func viewDidLoad() {<br>&gt;      // does something<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Button: View {<br>&gt;  override func viewDidLoad() {<br>&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;      // do something other<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; <br>&gt; // Example for extending a function<br>&gt; class Button: View {<br>&gt;  extend func viewDidLoad() {<br>&gt;      super.viewDidLoad()<br>&gt;      // do something<br>&gt;   }<br>&gt; <br>&gt;  extend func viewDidAppear() {<br>&gt;      // do something<br>&gt;   } // &lt;— the compiler should throw an error here.<br>&gt; }<br>&gt; <br>&gt; // Example for replacing a function<br>&gt; class Geometry {<br>&gt;   func volume() -&gt; Double {<br>&gt;      return 0;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Cube: Geometry {<br>&gt;   var length: Double = 0.0<br>&gt;   replace func volume() -&gt; Double {<br>&gt;      let v = length * length * length<br>&gt;      return v<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Cheers,<br>&gt; Florian<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/1eba4b87/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 15, 2016 at 10:00:00pm</p></header><div class="content"><p>Oh, it looks like Alexey beat me to a similar solution, but split the thread (at least in Mail.app):<br></p><p>&gt; On Mon, Feb 15, 2016 at 2:07 PM Alexey Demedetskiy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi<br>&gt; <br>&gt; I would like to suggest you to extend your proposal.<br>&gt; <br>&gt; In my practice, overriding super functions can have several semantics.<br>&gt; 1) Replace - simple case for abstract classes which implementation do nothing, or throw an exceptions.<br>&gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc. All cases where super expect to be called before child code.<br>&gt; 3) Before super - opposite to 2.<br>&gt; 4) Override - no rules about order, but super call must be done. <br>&gt; <br>&gt; So code can look like: <br>&gt; <br>&gt; override(after) func viewDidLoad() {<br>&gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;    // child code<br>&gt; }<br>&gt; <br>&gt; override(before) func tearDown() {<br>&gt;    // clean code<br>&gt;    // super… inserted by compiler<br>&gt; }<br>&gt; <br>&gt; override(instead) func loadView() {<br>&gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to remove instead modifier<br>&gt; }<br>&gt; <br>&gt; override func refillHealthBar() {<br>&gt;   // absent call to super will cause an error with fix-up to add (instead) modifier<br>&gt; }<br>&gt; <br>&gt; I am not sure about exposing this in a public interface and limit child override options.<br>&gt; <br>&gt; But in general - what is your thoughts about this approach to problem that you mention?<br></p><p>&gt; On 15 Feb 2016, at 22:52, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is an interesting idea, and fits well with the theme of preventing mistakes in Swift, but I think that the proposed solution isn’t flexible enough, as there are cases for inheritance patterns where extending doesn’t actually make sense, so having to specify an exception every time could quickly become annoying.<br>&gt; <br>&gt; I think the better solution is to instead allow super-classes to specify whether or not their method must be called when overridden/extended. For example:<br>&gt; <br>&gt; 	class View {<br>&gt; 		@super(required) func viewDidLoad() { … }<br>&gt; 	}<br>&gt; <br>&gt; 	class Button : View {<br>&gt; 		override func viewDidLoad() { … }<br>&gt; 	}<br>&gt; <br>&gt; 	class Widget : View {<br>&gt; 		override func viewDidLoad() {<br>&gt; 			super.viewDidLoad()<br>&gt; 			…<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; In this extension of your example Button will cause an error because it overrides viewDidLoad() but fails to call the parent’s method as required by the @super attribute. However, Widget compiles successfully because it follows the requirement.<br>&gt; <br>&gt; So the options for @super would be:<br>&gt; <br>&gt; required: child-class must call parent implementation of this method.<br>&gt; optional: default behaviour, child can choose whether to call the parent’s method.<br>&gt; denied: child may not call parent’s method (useful if it makes assumptions that a child-class may not follow), but can still extend/override.<br>&gt; <br>&gt; I think this would be a more flexible solution to the problem, and put the decision in the hands of those writing classes designed for inheritance. I’m not 100% sure of whether to rename override to extend, I like extend better personally, but it probably doesn’t matter overall.<br>&gt; <br>&gt;&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt; <br>&gt;&gt; class View {<br>&gt;&gt;   func viewDidLoad() {<br>&gt;&gt;      // does something<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Button: View {<br>&gt;&gt;  override func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;&gt;      // do something other<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt; <br>&gt;&gt; // Example for extending a function<br>&gt;&gt; class Button: View {<br>&gt;&gt;  extend func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()<br>&gt;&gt;      // do something<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;  extend func viewDidAppear() {<br>&gt;&gt;      // do something<br>&gt;&gt;   } // &lt;— the compiler should throw an error here.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Example for replacing a function<br>&gt;&gt; class Geometry {<br>&gt;&gt;   func volume() -&gt; Double {<br>&gt;&gt;      return 0;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cube: Geometry {<br>&gt;&gt;   var length: Double = 0.0<br>&gt;&gt;   replace func volume() -&gt; Double {<br>&gt;&gt;      let v = length * length * length<br>&gt;&gt;      return v<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Florian<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/0e6631d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>Building on Haravikk&#39;s suggestion:<br></p><p>    1. Make methods and classes final by default and mark an overridable<br>class with `class(option)` or `class(replace)` (see below for<br>`class(replace)`).<br>    2. A function declaration requires one of `func`, `func(final)`,<br>`func(replace)`, `func(option)`, `func(before)`, `func(after)`, or<br>`func(instead)` keywords and a function override requires one of<br>`override`, `override(final)`, `override(replace)`,<br>`override(option)`, `override(before)`, `override(after)`, or<br>`override(instead) - note no func keyword.<br>    3. A change from Haravikk&#39;s suggestion, retain the current meaning of<br>override (with different notation) so that `override(option)` means that<br>you can call super anywhere or not at all. (Equivalent to current<br>`override`.)<br>    4. Establish a hierarchy, since the override becomes part of the<br>method&#39;s public signature, in particular:<br>        4.a. `func/override(replace)` can be overridden/implemented by any<br>form, i.e. one of `override(replace)`, `override(replace,<br>option)`, `override(replace, before)`, `override(replace, after)`,<br>and `override(replace, instead)`. (Note the two qualifiers: what you are<br>going from to what you are going to.)<br>        4.b. `func/override(option)` can be overridden/implemented<br>by `override(option)`, `override(option, before)`, `override(option,<br>after)`, or `override(option, instead)`.<br>        4.c. `func/override(before)`, `func/override(after)`, and<br>`func/override(instead)` can only be overridden/implemented by the same<br>modifier.<br>    5. Methods in protocols and classes that do not have a body are<br>automatically `func/override(replace)`. (Currently protocols cannot have<br>bodies, but that is likely to change.) Final methods must have a body, i.e.<br>`func(final) method()` is an error because it is final and has no body.<br>    6. A class with a method without a body, which must be marked<br>`func/override` or `func/override(replace)`, has to be marked<br>`class(replace)`; it is abstract. (Note the notation `class(option)` and<br>`class(replace)` is consistent, a `class(option)` has at least one<br>optionally overridable method and no `func/override(replace)` methods,<br>whereas a class with at least one `func/override(replace)` method is marked<br>`class(replace)`.)<br>   7. Any of the annotations can be extended with final, e.g.<br>`func(optional, final)` means it is overriding a `func(optional)` but from<br>this point down it is final. Final methods must have a body.<br>   8. In a class/protocol `func` is shorthand for `func(final)` unless the<br>method has no body in which case it is shorthand for `func(replace)`.<br>   9. `override` is a shorthand for `override(A, final)` where A is the<br>annotation specified in the matching `func` declaration.<br>   10. Overriding methods in a final class do not require the extra final<br>annotation, e.g. in a final class `func(option)` and `func(option, final)`<br>are equivalent.<br></p><p>EG:<br></p><p>    class(replace) Abstract { // Point 1: class marked as replace, it is<br>therefore abstract and you can&#39;t call init. Point 6: it has an abstract<br>method therefore must be abstract itself.<br>        func abstract() // Point 5: declare an abstract method (it has no<br>body), equivalent to `func(replace)`.<br></p><p>        func(option) overridable() { // Point 2: declare an optionally<br>overridable method. Point 3: same override semantics as Swift 2.<br>            print(&quot;Optionally overridable with any super call OK&quot;)<br>        }<br></p><p>        func finalFunc() { // Point 1: methods are final by default. Point<br>8: `func` is shorthand for `func(final)` when the method has a body.<br>            print(&quot;Method is final&quot;)<br>        }<br>    }<br></p><p>    class Final: Overridable { // Point 1: class is final since it isn&#39;t<br>annotated.<br>        override abstract() { // Point 2: override keyword not func. Point<br>7: method is final because class is final. Point 9: `override` is<br>equivalent to `override(replace, final)`.<br>            print(&quot;Implementation of abstract method&quot;)<br>        }<br></p><p>        override overridable() { // Point 2: override keyword not func.<br>Point 7: method is final because class is final. Point 9: `override` is<br>equivalent to `override(option, final)`.<br>            print(&quot;Method is final because class is final&quot;)<br>        }<br>    }<br></p><p>    class(option) Derived: Overridable { // Point 1: class is overridable<br>because it is annotated option.<br>        override(replace, after) abstract() { // Point 4.a: implementation<br>of an abstract class<br>            print(&quot;In a derived class this will be printed after the<br>derived class&#39;s body has finished&quot;)<br>        }<br></p><p>        override(option, final) overridable() { // Point 7: method is final<br>because it is annotated final.<br>            print(&quot;Method is final because class is final&quot;)<br>        }<br>    }<br></p><p><br>  -- Howard.<br></p><p>On 16 February 2016 at 09:56, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Oh, it looks like Alexey beat me to a similar solution, but split the<br>&gt; thread (at least in Mail.app):<br>&gt;<br>&gt; On Mon, Feb 15, 2016 at 2:07 PM Alexey Demedetskiy via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi<br>&gt;<br>&gt; I would like to suggest you to extend your proposal.<br>&gt;<br>&gt; In my practice, overriding super functions can have several semantics.<br>&gt; 1) Replace - simple case for abstract classes which implementation do<br>&gt; nothing, or throw an exceptions.<br>&gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc.<br>&gt; All cases where super expect to be called before child code.<br>&gt; 3) Before super - opposite to 2.<br>&gt; 4) Override - no rules about order, but super call must be done.<br>&gt;<br>&gt; So code can look like:<br>&gt;<br>&gt; override(after) func viewDidLoad() {<br>&gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;    // child code<br>&gt; }<br>&gt;<br>&gt; override(before) func tearDown() {<br>&gt;    // clean code<br>&gt;    // super… inserted by compiler<br>&gt; }<br>&gt;<br>&gt; override(instead) func loadView() {<br>&gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to<br>&gt; remove instead modifier<br>&gt; }<br>&gt;<br>&gt; override func refillHealthBar() {<br>&gt;   // absent call to super will cause an error with fix-up to add (instead)<br>&gt; modifier<br>&gt; }<br>&gt;<br>&gt; I am not sure about exposing this in a public interface and limit child<br>&gt; override options.<br>&gt;<br>&gt; But in general - what is your thoughts about this approach to problem that<br>&gt; you mention?<br>&gt;<br>&gt;<br>&gt; On 15 Feb 2016, at 22:52, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is an interesting idea, and fits well with the theme of preventing<br>&gt; mistakes in Swift, but I think that the proposed solution isn’t flexible<br>&gt; enough, as there are cases for inheritance patterns where extending doesn’t<br>&gt; actually make sense, so having to specify an exception every time could<br>&gt; quickly become annoying.<br>&gt;<br>&gt; I think the better solution is to instead allow super-classes to specify<br>&gt; whether or not their method must be called when overridden/extended. For<br>&gt; example:<br>&gt;<br>&gt; class View {<br>&gt; @super(required) func viewDidLoad() { … }<br>&gt; }<br>&gt;<br>&gt; class Button : View {<br>&gt; override func viewDidLoad() { … }<br>&gt; }<br>&gt;<br>&gt; class Widget : View {<br>&gt; override func viewDidLoad() {<br>&gt; super.viewDidLoad()<br>&gt; …<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; In this extension of your example Button will cause an error because it<br>&gt; overrides viewDidLoad() but fails to call the parent’s method as required<br>&gt; by the @super attribute. However, Widget compiles successfully because it<br>&gt; follows the requirement.<br>&gt;<br>&gt; So the options for @super would be:<br>&gt;<br>&gt;<br>&gt;    - *required: *child-class must call parent implementation of this<br>&gt;    method.<br>&gt;    - *optional:* default behaviour, child can choose whether to call the<br>&gt;    parent’s method.<br>&gt;    - *denied:* child may not call parent’s method (useful if it makes<br>&gt;    assumptions that a child-class may not follow), but can still<br>&gt;    extend/override.<br>&gt;<br>&gt;<br>&gt; I think this would be a more flexible solution to the problem, and put the<br>&gt; decision in the hands of those writing classes designed for inheritance.<br>&gt; I’m not 100% sure of whether to rename override to extend, I like extend<br>&gt; better personally, but it probably doesn’t matter overall.<br>&gt;<br>&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi!<br>&gt;<br>&gt; I would like to suggest to replace the override keyword for functions by<br>&gt; something like extend and replace or to add an annotation like<br>&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt; The reason for this is, that it might happen, that one forgets to call the<br>&gt; super’s implementation in an overridden function or if one reads the code<br>&gt; it might not be obvious why the super’s implementation is not called:<br>&gt;<br>&gt; class View {<br>&gt;   func viewDidLoad() {<br>&gt;      // does something<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; class Button: View {<br>&gt;  override func viewDidLoad() {<br>&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;      // do something other<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; The compiler will accept if one overrides a superclass’s function but does<br>&gt; not call the superclass’s implementation which is often ok. The developer<br>&gt; should clearly state that he doesn’t want to call the superclass’s<br>&gt; implementation, otherwise the compiler should throw an error.<br>&gt;<br>&gt; // Example for extending a function<br>&gt; class Button: View {<br>&gt;  extend func viewDidLoad() {<br>&gt;      super.viewDidLoad()<br>&gt;      // do something<br>&gt;   }<br>&gt;<br>&gt;  extend func viewDidAppear() {<br>&gt;      // do something<br>&gt;   } // &lt;— the compiler should throw an error here.<br>&gt; }<br>&gt;<br>&gt; // Example for replacing a function<br>&gt; class Geometry {<br>&gt;   func volume() -&gt; Double {<br>&gt;      return 0;<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; class Cube: Geometry {<br>&gt;   var length: Double = 0.0<br>&gt;   replace func volume() -&gt; Double {<br>&gt;      let v = length * length * length<br>&gt;      return v<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Cheers,<br>&gt; Florian<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/e3bd25ac/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>February 16, 2016 at 02:00:00pm</p></header><div class="content"><p>+1. great original idea. I really like the improvements proposed by Howard.<br></p><p>On Mon, Feb 15, 2016 at 10:36 PM Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Building on Haravikk&#39;s suggestion:<br>&gt;<br>&gt;     1. Make methods and classes final by default and mark an overridable<br>&gt; class with `class(option)` or `class(replace)` (see below for<br>&gt; `class(replace)`).<br>&gt;     2. A function declaration requires one of `func`, `func(final)`,<br>&gt; `func(replace)`, `func(option)`, `func(before)`, `func(after)`, or<br>&gt; `func(instead)` keywords and a function override requires one of<br>&gt; `override`, `override(final)`, `override(replace)`,<br>&gt; `override(option)`, `override(before)`, `override(after)`, or<br>&gt; `override(instead) - note no func keyword.<br>&gt;     3. A change from Haravikk&#39;s suggestion, retain the current meaning of<br>&gt; override (with different notation) so that `override(option)` means that<br>&gt; you can call super anywhere or not at all. (Equivalent to current<br>&gt; `override`.)<br>&gt;     4. Establish a hierarchy, since the override becomes part of the<br>&gt; method&#39;s public signature, in particular:<br>&gt;         4.a. `func/override(replace)` can be overridden/implemented by any<br>&gt; form, i.e. one of `override(replace)`, `override(replace,<br>&gt; option)`, `override(replace, before)`, `override(replace, after)`,<br>&gt; and `override(replace, instead)`. (Note the two qualifiers: what you are<br>&gt; going from to what you are going to.)<br>&gt;         4.b. `func/override(option)` can be overridden/implemented<br>&gt; by `override(option)`, `override(option, before)`, `override(option,<br>&gt; after)`, or `override(option, instead)`.<br>&gt;         4.c. `func/override(before)`, `func/override(after)`, and<br>&gt; `func/override(instead)` can only be overridden/implemented by the same<br>&gt; modifier.<br>&gt;     5. Methods in protocols and classes that do not have a body are<br>&gt; automatically `func/override(replace)`. (Currently protocols cannot have<br>&gt; bodies, but that is likely to change.) Final methods must have a body, i.e.<br>&gt; `func(final) method()` is an error because it is final and has no body.<br>&gt;     6. A class with a method without a body, which must be marked<br>&gt; `func/override` or `func/override(replace)`, has to be marked<br>&gt; `class(replace)`; it is abstract. (Note the notation `class(option)` and<br>&gt; `class(replace)` is consistent, a `class(option)` has at least one<br>&gt; optionally overridable method and no `func/override(replace)` methods,<br>&gt; whereas a class with at least one `func/override(replace)` method is marked<br>&gt; `class(replace)`.)<br>&gt;    7. Any of the annotations can be extended with final, e.g.<br>&gt; `func(optional, final)` means it is overriding a `func(optional)` but from<br>&gt; this point down it is final. Final methods must have a body.<br>&gt;    8. In a class/protocol `func` is shorthand for `func(final)` unless the<br>&gt; method has no body in which case it is shorthand for `func(replace)`.<br>&gt;    9. `override` is a shorthand for `override(A, final)` where A is the<br>&gt; annotation specified in the matching `func` declaration.<br>&gt;    10. Overriding methods in a final class do not require the extra final<br>&gt; annotation, e.g. in a final class `func(option)` and `func(option, final)`<br>&gt; are equivalent.<br>&gt;<br>&gt; EG:<br>&gt;<br>&gt;     class(replace) Abstract { // Point 1: class marked as replace, it is<br>&gt; therefore abstract and you can&#39;t call init. Point 6: it has an abstract<br>&gt; method therefore must be abstract itself.<br>&gt;         func abstract() // Point 5: declare an abstract method (it has no<br>&gt; body), equivalent to `func(replace)`.<br>&gt;<br>&gt;         func(option) overridable() { // Point 2: declare an optionally<br>&gt; overridable method. Point 3: same override semantics as Swift 2.<br>&gt;             print(&quot;Optionally overridable with any super call OK&quot;)<br>&gt;         }<br>&gt;<br>&gt;         func finalFunc() { // Point 1: methods are final by default. Point<br>&gt; 8: `func` is shorthand for `func(final)` when the method has a body.<br>&gt;             print(&quot;Method is final&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     class Final: Overridable { // Point 1: class is final since it isn&#39;t<br>&gt; annotated.<br>&gt;         override abstract() { // Point 2: override keyword not func. Point<br>&gt; 7: method is final because class is final. Point 9: `override` is<br>&gt; equivalent to `override(replace, final)`.<br>&gt;             print(&quot;Implementation of abstract method&quot;)<br>&gt;         }<br>&gt;<br>&gt;         override overridable() { // Point 2: override keyword not func.<br>&gt; Point 7: method is final because class is final. Point 9: `override` is<br>&gt; equivalent to `override(option, final)`.<br>&gt;             print(&quot;Method is final because class is final&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     class(option) Derived: Overridable { // Point 1: class is overridable<br>&gt; because it is annotated option.<br>&gt;         override(replace, after) abstract() { // Point 4.a: implementation<br>&gt; of an abstract class<br>&gt;             print(&quot;In a derived class this will be printed after the<br>&gt; derived class&#39;s body has finished&quot;)<br>&gt;         }<br>&gt;<br>&gt;         override(option, final) overridable() { // Point 7: method is<br>&gt; final because it is annotated final.<br>&gt;             print(&quot;Method is final because class is final&quot;)<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 16 February 2016 at 09:56, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Oh, it looks like Alexey beat me to a similar solution, but split the<br>&gt;&gt; thread (at least in Mail.app):<br>&gt;&gt;<br>&gt;&gt; On Mon, Feb 15, 2016 at 2:07 PM Alexey Demedetskiy via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi<br>&gt;&gt;<br>&gt;&gt; I would like to suggest you to extend your proposal.<br>&gt;&gt;<br>&gt;&gt; In my practice, overriding super functions can have several semantics.<br>&gt;&gt; 1) Replace - simple case for abstract classes which implementation do<br>&gt;&gt; nothing, or throw an exceptions.<br>&gt;&gt; 2) After super - things like viewDidLoad and viewWillAppear, setUp etc.<br>&gt;&gt; All cases where super expect to be called before child code.<br>&gt;&gt; 3) Before super - opposite to 2.<br>&gt;&gt; 4) Override - no rules about order, but super call must be done.<br>&gt;&gt;<br>&gt;&gt; So code can look like:<br>&gt;&gt;<br>&gt;&gt; override(after) func viewDidLoad() {<br>&gt;&gt;    // super.viewDidLoad() &lt;— no need to call super at first line.<br>&gt;&gt;    // child code<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; override(before) func tearDown() {<br>&gt;&gt;    // clean code<br>&gt;&gt;    // super… inserted by compiler<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; override(instead) func loadView() {<br>&gt;&gt;    // super.loadView() &lt;— marked as an error with appropriate fix-up to<br>&gt;&gt; remove instead modifier<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; override func refillHealthBar() {<br>&gt;&gt;   // absent call to super will cause an error with fix-up to add<br>&gt;&gt; (instead) modifier<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I am not sure about exposing this in a public interface and limit child<br>&gt;&gt; override options.<br>&gt;&gt;<br>&gt;&gt; But in general - what is your thoughts about this approach to problem<br>&gt;&gt; that you mention?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 15 Feb 2016, at 22:52, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is an interesting idea, and fits well with the theme of preventing<br>&gt;&gt; mistakes in Swift, but I think that the proposed solution isn’t flexible<br>&gt;&gt; enough, as there are cases for inheritance patterns where extending doesn’t<br>&gt;&gt; actually make sense, so having to specify an exception every time could<br>&gt;&gt; quickly become annoying.<br>&gt;&gt;<br>&gt;&gt; I think the better solution is to instead allow super-classes to specify<br>&gt;&gt; whether or not their method must be called when overridden/extended. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; class View {<br>&gt;&gt; @super(required) func viewDidLoad() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Button : View {<br>&gt;&gt; override func viewDidLoad() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Widget : View {<br>&gt;&gt; override func viewDidLoad() {<br>&gt;&gt; super.viewDidLoad()<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In this extension of your example Button will cause an error because it<br>&gt;&gt; overrides viewDidLoad() but fails to call the parent’s method as required<br>&gt;&gt; by the @super attribute. However, Widget compiles successfully because it<br>&gt;&gt; follows the requirement.<br>&gt;&gt;<br>&gt;&gt; So the options for @super would be:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - *required: *child-class must call parent implementation of this<br>&gt;&gt;    method.<br>&gt;&gt;    - *optional:* default behaviour, child can choose whether to call the<br>&gt;&gt;    parent’s method.<br>&gt;&gt;    - *denied:* child may not call parent’s method (useful if it makes<br>&gt;&gt;    assumptions that a child-class may not follow), but can still<br>&gt;&gt;    extend/override.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this would be a more flexible solution to the problem, and put<br>&gt;&gt; the decision in the hands of those writing classes designed for<br>&gt;&gt; inheritance. I’m not 100% sure of whether to rename override to extend, I<br>&gt;&gt; like extend better personally, but it probably doesn’t matter overall.<br>&gt;&gt;<br>&gt;&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi!<br>&gt;&gt;<br>&gt;&gt; I would like to suggest to replace the override keyword for functions by<br>&gt;&gt; something like extend and replace or to add an annotation like<br>&gt;&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; The reason for this is, that it might happen, that one forgets to call<br>&gt;&gt; the super’s implementation in an overridden function or if one reads the<br>&gt;&gt; code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt;<br>&gt;&gt; class View {<br>&gt;&gt;   func viewDidLoad() {<br>&gt;&gt;      // does something<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Button: View {<br>&gt;&gt;  override func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;&gt;      // do something other<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The compiler will accept if one overrides a superclass’s function but<br>&gt;&gt; does not call the superclass’s implementation which is often ok. The<br>&gt;&gt; developer should clearly state that he doesn’t want to call the<br>&gt;&gt; superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt;<br>&gt;&gt; // Example for extending a function<br>&gt;&gt; class Button: View {<br>&gt;&gt;  extend func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()<br>&gt;&gt;      // do something<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;  extend func viewDidAppear() {<br>&gt;&gt;      // do something<br>&gt;&gt;   } // &lt;— the compiler should throw an error here.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Example for replacing a function<br>&gt;&gt; class Geometry {<br>&gt;&gt;   func volume() -&gt; Double {<br>&gt;&gt;      return 0;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Cube: Geometry {<br>&gt;&gt;   var length: Double = 0.0<br>&gt;&gt;   replace func volume() -&gt; Double {<br>&gt;&gt;      let v = length * length * length<br>&gt;&gt;      return v<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; Florian<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/53a02080/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 16, 2016 at 10:00:00pm</p></header><div class="content"><p>Woah, pretty expansive and well thought out set of rules here!<br></p><p>&gt; On 16 Feb 2016, at 03:36, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt;     1. Make methods and classes final by default and mark an overridable class with `class(option)` or `class(replace)` (see below for `class(replace)`).<br></p><p>This is a great idea, it’s definitely better to force the developer to think about extension and explicitly declare it, and having the whole thing self-documenting will make it so much easier.<br></p><p>&gt;     2. A function declaration requires one of `func`, `func(final)`, `func(replace)`, `func(option)`, `func(before)`, `func(after)`, or `func(instead)` keywords and a function override requires one of `override`, `override(final)`, `override(replace)`, `override(option)`, `override(before)`, `override(after)`, or `override(instead) - note no func keyword.<br></p><p>I’m not so sure about putting this into the keywords. Personally I think an attribute is a bit neater (it can go nicely above the function declaration). Meanwhile with override I think it’s probably enough to just override a method, as this implicitly agrees to whatever rules were set out by the super-method. If want to put your own requirements on sub-classes even further down the chain then you just add the attribute to your own method.<br></p><p>&gt;     6. A class with a method without a body, which must be marked `func/override` or `func/override(replace)`, has to be marked `class(replace)`; it is abstract. (Note the notation `class(option)` and `class(replace)` is consistent, a `class(option)` has at least one optionally overridable method and no `func/override(replace)` methods, whereas a class with at least one `func/override(replace)` method is marked `class(replace)`.)<br></p><p>I like this, but would an abstract keyword not be simpler and clearer to most? Setting it on a class would allow that class to contain abstract methods (and properties?) also declared with the abstract keyword. An abstract method could contain no body (child class must give full implementation) or could include a body in which case it must be extended and called.<br></p><p>&gt;    7. Any of the annotations can be extended with final, e.g. `func(optional, final)` means it is overriding a `func(optional)` but from this point down it is final. Final methods must have a body.<br>&gt;    8. In a class/protocol `func` is shorthand for `func(final)` unless the method has no body in which case it is shorthand for `func(replace)`.<br>&gt;    9. `override` is a shorthand for `override(A, final)` where A is the annotation specified in the matching `func` declaration.<br>&gt;    10. Overriding methods in a final class do not require the extra final annotation, e.g. in a final class `func(option)` and `func(option, final)` are equivalent.<br></p><p>I think my preference is still towards an attribute to specify the requirements for sub-classes overriding a method, with the override keyword implicitly agreeing to those conditions rather than having to repeat them. If you want to change those requirements for further levels of sub-class then you can just add the same attribute your own methods, like so:<br></p><p>	class MyClass {<br>		@super(required)<br>		func mustCallMe() { … } // Immediate sub-classes must call this method<br></p><p>		@super(optional)<br>		func someOtherMethod() { … } // Call super, or not, this method doesn’t care<br>	}<br></p><p>	class MySubClass : MyClass {<br>		@super(before)<br>		override func mustCallMe() { … } // Further sub-classes must now call this first<br></p><p>		override func someOtherMethod() { … } 	// This implicitly agrees to optionally include the parent call and <br>							// is final due to the lack of a @super attribute of its own (or one on its class).<br>	}<br></p><p>If an overriding method has no @super attribute of its own then it is implicitly final, unless the attribute is instead placed on the class (allowing us to make a class’ methods all overridable if we like). <br></p><p>I dunno, it may just be personal preference; I can completely get wanting to clarify what rules are being followed at each step, but I’m just unsure whether the extra complexity is worth it? I can definitely see the need to introduce more options over the three I gave though, giving us:<br></p><p>required: parent method must be called somewhere in all code paths of overriding method.<br>optional: parent method may or may not be called anywhere in the overriding method.<br>replace: parent method may not be called at all by overriding method (sub-class must provide total replacement).<br>before and after: these imply required but can also be set as optional (to be read as “if included, parent call must come first/last”). Not sure if after should require the parent method’s return value to be used in methods with a return type?<br></p><p>I think that abstract methods and classes should probably be a separate proposal building upon these extension requirements. In essence though an abstract method with no body would imply @super(replace). An abstract method with a body implies @super(required), but could anything other than @super(replace) would be valid, allowing an abstract class to provide a sample implementation that need not be used in sub-classes, optionally setting a before/after requirement in the event that it is used.<br></p><p>Thoughts? I’m not too fussy about the exact syntax, but I think that while repeating the requirements in the override is explicit (which is usually a good thing) I personally think that the override keyword alone should suffice, as anyone creating a sub-class should know what the requirements of the parent are and agreed to them. What’s important is really whether the overriding method itself has any requirements for classes further down the hierarchy I think.<br></p><p>I also think it could be interesting to allow @super on the class itself, allowing the developer to decide if they want to keep the implicitly final default, or make their methods implicitly overridable, in which case they can then use the final keyword to put it back again.<br></p><p>Lastly, I’m not sure about the use of an attribute actually as I’m not clear on what the rules for them really are (if there are any?). I quite like how they look and they’re already setup to support multiple options etc., but adding options to a keyword may make sense. If we do that though then personally I think we could just re-use super, e.g-:<br></p><p>	class MyClass {<br>		super(required) func mustCallMe() { … }<br>	}<br></p><p>I suppose there’s no reason this couldn’t go on func() like you suggest, but I like the consistency with the fact that it’s the super keyword in the method body that this feature is controlling.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/0d0a3c78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 17, 2016 at 09:00:00am</p></header><div class="content"><p>@Haravikk,<br></p><p>I am not perticularly fussed about the exact syntax so long as it is clear<br>and consistent, it is the semantics I am most interested in. I would say<br>just go with what is the most popular syntax. The syntax I suggested is<br>clear, consistent, and concise, that is why I suggested it, EG instead of:<br></p><p>    @super(option) override func name() { ... }<br></p><p>I am suggesting<br></p><p>    override(option) name() { ... }<br></p><p>Its only syntax :). Either is fine because they are both clear and<br>consistent.<br></p><p>Changing tack to abstract methods and classes. Maybe it is necessary to<br>propose abstract methods and classes for Swift with a future expansion<br>section noting that it is the intention to add control over when super is<br>called at a later date and giving some examples. That way abstract classes<br>can be added with systax that can be extended to accommodate more control<br>at a later date. The problem with doing two seperate proposals is that the<br>syntax could become inconsistent.<br></p><p>Thanks for starting this thread, I think it would be a valuable addition to<br>Swift.<br></p><p> -- Howard.<br></p><p>On Wednesday, 17 February 2016, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt; Woah, pretty expansive and well thought out set of rules here!<br>&gt;<br>&gt; On 16 Feb 2016, at 03:36, Howard Lovatt &lt;howard.lovatt at gmail.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;howard.lovatt at gmail.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;     1. Make methods and classes final by default and mark an overridable<br>&gt; class with `class(option)` or `class(replace)` (see below for<br>&gt; `class(replace)`).<br>&gt;<br>&gt;<br>&gt; This is a great idea, it’s definitely better to force the developer to<br>&gt; think about extension and explicitly declare it, and having the whole thing<br>&gt; self-documenting will make it so much easier.<br>&gt;<br>&gt;     2. A function declaration requires one of `func`, `func(final)`,<br>&gt; `func(replace)`, `func(option)`, `func(before)`, `func(after)`, or<br>&gt; `func(instead)` keywords and a function override requires one of<br>&gt; `override`, `override(final)`, `override(replace)`,<br>&gt; `override(option)`, `override(before)`, `override(after)`, or<br>&gt; `override(instead) - note no func keyword.<br>&gt;<br>&gt;<br>&gt; I’m not so sure about putting this into the keywords. Personally I think<br>&gt; an attribute is a bit neater (it can go nicely above the function<br>&gt; declaration). Meanwhile with override I think it’s probably enough to just<br>&gt; override a method, as this implicitly agrees to whatever rules were set out<br>&gt; by the super-method. If want to put your own requirements on sub-classes<br>&gt; even further down the chain then you just add the attribute to your own<br>&gt; method.<br>&gt;<br>&gt;     6. A class with a method without a body, which must be marked<br>&gt; `func/override` or `func/override(replace)`, has to be marked<br>&gt; `class(replace)`; it is abstract. (Note the notation `class(option)` and<br>&gt; `class(replace)` is consistent, a `class(option)` has at least one<br>&gt; optionally overridable method and no `func/override(replace)` methods,<br>&gt; whereas a class with at least one `func/override(replace)` method is marked<br>&gt; `class(replace)`.)<br>&gt;<br>&gt;<br>&gt; I like this, but would an abstract keyword not be simpler and clearer to<br>&gt; most? Setting it on a class would allow that class to contain abstract<br>&gt; methods (and properties?) also declared with the abstract keyword. An<br>&gt; abstract method could contain no body (child class must give full<br>&gt; implementation) or could include a body in which case it must be extended<br>&gt; and called.<br>&gt;<br>&gt;    7. Any of the annotations can be extended with final, e.g.<br>&gt; `func(optional, final)` means it is overriding a `func(optional)` but from<br>&gt; this point down it is final. Final methods must have a body.<br>&gt;<br>&gt;    8. In a class/protocol `func` is shorthand for `func(final)` unless the<br>&gt; method has no body in which case it is shorthand for `func(replace)`.<br>&gt;    9. `override` is a shorthand for `override(A, final)` where A is the<br>&gt; annotation specified in the matching `func` declaration.<br>&gt;    10. Overriding methods in a final class do not require the extra final<br>&gt; annotation, e.g. in a final class `func(option)` and `func(option, final)`<br>&gt; are equivalent.<br>&gt;<br>&gt;<br>&gt; I think my preference is still towards an attribute to specify the<br>&gt; requirements for sub-classes overriding a method, with the override keyword<br>&gt; implicitly agreeing to those conditions rather than having to repeat them.<br>&gt; If you want to change those requirements for further levels of sub-class<br>&gt; then you can just add the same attribute your own methods, like so:<br>&gt;<br>&gt; class MyClass {<br>&gt; @super(required)<br>&gt; func mustCallMe() { … } // Immediate sub-classes must call this method<br>&gt;<br>&gt; @super(optional)<br>&gt; func someOtherMethod() { … } // Call super, or not, this method doesn’t<br>&gt; care<br>&gt; }<br>&gt;<br>&gt; class MySubClass : MyClass {<br>&gt; @super(before)<br>&gt; override func mustCallMe() { … } // Further sub-classes must now call this<br>&gt; first<br>&gt;<br>&gt; override func someOtherMethod() { … } // This implicitly agrees to<br>&gt; optionally include the parent call and<br>&gt; // is final due to the lack of a @super attribute of its own (or one on<br>&gt; its class).<br>&gt; }<br>&gt;<br>&gt; If an overriding method has no @super attribute of its own then it is<br>&gt; implicitly final, unless the attribute is instead placed on the class<br>&gt; (allowing us to make a class’ methods all overridable if we like).<br>&gt;<br>&gt; I dunno, it may just be personal preference; I can completely get wanting<br>&gt; to clarify what rules are being followed at each step, but I’m just unsure<br>&gt; whether the extra complexity is worth it? I can definitely see the need to<br>&gt; introduce more options over the three I gave though, giving us:<br>&gt;<br>&gt;<br>&gt;    - *required*: parent method must be called somewhere in all code paths<br>&gt;    of overriding method.<br>&gt;    - *optional*: parent method may or may not be called anywhere in the<br>&gt;    overriding method.<br>&gt;    - *replace*: parent method may not be called at all by overriding<br>&gt;    method (sub-class must provide total replacement).<br>&gt;    - *before* and *after*: these imply required but can also be set as<br>&gt;    optional (to be read as “if included, parent call must come first/last”).<br>&gt;    Not sure if after should require the parent method’s return value to be<br>&gt;    used in methods with a return type?<br>&gt;<br>&gt;<br>&gt; I think that abstract methods and classes should probably be a separate<br>&gt; proposal building upon these extension requirements. In essence though an<br>&gt; abstract method with no body would imply @super(replace). An abstract<br>&gt; method with a body implies @super(required), but could anything other than<br>&gt; @super(replace) would be valid, allowing an abstract class to provide a<br>&gt; sample implementation that need not be used in sub-classes, optionally<br>&gt; setting a before/after requirement in the event that it is used.<br>&gt;<br>&gt; Thoughts? I’m not too fussy about the exact syntax, but I think that while<br>&gt; repeating the requirements in the override is explicit (which is usually a<br>&gt; good thing) I personally think that the override keyword alone should<br>&gt; suffice, as anyone creating a sub-class should know what the requirements<br>&gt; of the parent are and agreed to them. What’s important is really whether<br>&gt; the overriding method itself has any requirements for classes further down<br>&gt; the hierarchy I think.<br>&gt;<br>&gt; I also think it could be interesting to allow @super on the class itself,<br>&gt; allowing the developer to decide if they want to keep the implicitly final<br>&gt; default, or make their methods implicitly overridable, in which case they<br>&gt; can then use the final keyword to put it back again.<br>&gt;<br>&gt; Lastly, I’m not sure about the use of an attribute actually as I’m not<br>&gt; clear on what the rules for them really are (if there are any?). I quite<br>&gt; like how they look and they’re already setup to support multiple options<br>&gt; etc., but adding options to a keyword may make sense. If we do that though<br>&gt; then personally I think we could just re-use super, e.g-:<br>&gt;<br>&gt; class MyClass {<br>&gt; super(required) func mustCallMe() { … }<br>&gt; }<br>&gt;<br>&gt; I suppose there’s no reason this couldn’t go on func() like you suggest,<br>&gt; but I like the consistency with the fact that it’s the super keyword in the<br>&gt; method body that this feature is controlling.<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/8c6d095e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 16, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Building on Haravikk&#39;s suggestion:<br>&gt; <br>&gt;     1. Make methods and classes final by default<br></p><p>That&#39;s a serious problem for Swift resilience—it&#39;s not safe to change a public class from final to non-final because that would break devirtualized calls in other modules. Whatever the default is, it needs to not break things.<br></p><p>Overall, I don&#39;t like this proposal for several reasons:<br></p><p>- It conflates several different features—final, abstract, super call requirement, super call location—into a single set of annotations.<br>- It violates the usual grammar of Swift declarations by attaching particular modifiers directly to the keyword, disrupting the usual flow of modifiers-keyword-name-type.<br>- It not only supports, but actively encourages, placing extremely heavy constraints on subclass implementations. (Want to put a logging statement before a &quot;before&quot; method&#39;s super call or after an &quot;after&quot; method&#39;s? Too bad, the guy who wrote the superclass said &quot;no&quot;.)<br></p><p>In general, this proposal seems like it&#39;s tremendously overengineered, insufficiently motivated, and fits poorly into Swift&#39;s syntax.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 17, 2016 at 02:00:00pm</p></header><div class="content"><p>Comments in-line below.<br></p><p>  -- Howard.<br></p><p>On 17 February 2016 at 12:22, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Building on Haravikk&#39;s suggestion:<br>&gt; &gt;<br>&gt; &gt;     1. Make methods and classes final by default<br>&gt;<br>&gt; That&#39;s a serious problem for Swift resilience—it&#39;s not safe to change a<br>&gt; public class from final to non-final because that would break devirtualized<br>&gt; calls in other modules. Whatever the default is, it needs to not break<br>&gt; things.<br>&gt;<br></p><p>If a class/method is final it can be made virtual, but not vice versa.<br>Therefore the default is best as final since you can change your mind<br>later. Whereas a virtual declaration you are stuck with.<br></p><p><br>&gt; Overall, I don&#39;t like this proposal for several reasons:<br>&gt;<br>&gt; - It conflates several different features—final, abstract, super call<br>&gt; requirement, super call location—into a single set of annotations.<br>&gt;<br></p><p>Yes. There is some discussion of splitting out abstract. Could also split<br>out final. However you wouldn&#39;t want a solution for final or abstract that<br>stopped you from later adding super constraints if people decided they were<br>still useful.<br></p><p><br>&gt; - It violates the usual grammar of Swift declarations by attaching<br>&gt; particular modifiers directly to the keyword, disrupting the usual flow of<br>&gt; modifiers-keyword-name-type.<br>&gt;<br></p><p>Different syntaxes have been discussed, mainly `@super(option) override<br>func name()` and `override(option) name()`, both have precedence in Swift,<br>e.g. annotations like `@noexcape` and options on annotations and<br>constraints on visibility like `private(set)` respectively.<br></p><p><br>&gt; - It not only supports, but actively encourages, placing extremely heavy<br>&gt; constraints on subclass implementations. (Want to put a logging statement<br>&gt; before a &quot;before&quot; method&#39;s super call or after an &quot;after&quot; method&#39;s? Too<br>&gt; bad, the guy who wrote the superclass said &quot;no&quot;.)<br>&gt;<br></p><p>A similar discussion has occurred re. pure functions. It might be possible<br>to say no mutating stored properties before/after the super call in a<br>&quot;before&quot;/&quot;after&quot; method respectively. This would require some careful<br>consideration though.<br></p><p><br>&gt;<br>&gt; In general, this proposal seems like it&#39;s tremendously overengineered,<br>&gt; insufficiently motivated, and fits poorly into Swift&#39;s syntax.<br>&gt;<br></p><p>Not the first time this sort of discussion has come up on Swift Evolution -<br>therefore there is some interest.<br></p><p><br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/f12f95f4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 17 Feb 2016, at 01:22, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; That&#39;s a serious problem for Swift resilience—it&#39;s not safe to change a public class from final to non-final because that would break devirtualized calls in other modules. Whatever the default is, it needs to not break things.<br></p><p>Swift hasn’t really shied away from breaking things thus far, but this is partly why I mentioned supporting a class level override. So for example, if @super(optional) is the current behaviour (can override, compiler doesn’t care what you do) then that could be added to all existing classes in a project, but without it a new class will default to its methods being final.<br></p><p>&gt; - It conflates several different features—final, abstract, super call requirement, super call location—into a single set of annotations.<br></p><p>Not quite; I’d say that abstract is kind of its own thing, but would definitely build in the addition of extension requirements. Regarding the rest, is them being in a single set of annotations actually a bad thing? IMO that’s an advantage, as plus it’s not like it should be complicated. In the sample set of annotations I gave you might do:<br></p><p>	@super(optional, before)<br></p><p>Which essentially reads as “extending classes don’t need to include super call, but must place it first if they do”. The most major change is really that the final keyword wouldn’t be necessary except for classes that set @super(optional) as their default (as everything would be overridable otherwise). That said it probably does make sense to just make final another type of requirement for consistency in that case.<br></p><p>&gt; - It violates the usual grammar of Swift declarations by attaching particular modifiers directly to the keyword, disrupting the usual flow of modifiers-keyword-name-type.<br></p><p>private(set) already does this, so super(optional, before) or whatever wouldn’t be any different. We’re considering other options like @attributes as well, but they’re functionally the same so it really comes down to code style.<br></p><p>&gt; - It not only supports, but actively encourages, placing extremely heavy constraints on subclass implementations. (Want to put a logging statement before a &quot;before&quot; method&#39;s super call or after an &quot;after&quot; method&#39;s? Too bad, the guy who wrote the superclass said &quot;no”.)<br></p><p>I wouldn’t say it encourages heavy constraints, in fact I’d expect most developers to mostly use required or optional. The before and after conditions make more sense in the case of abstract classes that are partial implementations specifically intended to be built upon in a certain way.<br></p><p>It’s possible the restriction could be relaxed to allow non-mutating operations before/after the required statement, but I think in general developers shouldn’t be adding the before/after requirements unless they’re absolutely certain it has to be done that way. Technical you can still work around it like so:<br></p><p>	class Foo {<br>		super(before) func doSomething() { … }<br>	}<br>	class Bar : Foo {<br>		super(required) override func doSomething() {<br>			super.doSomething(); // Foo decreed that this shall be so<br>			…<br>		}<br>	}<br>	class AddLogging : Bar {<br>		override func doSomething() {<br>			/* Do some logging here and there’s nothing Foo can do about it */<br>			super.doSomething()<br>		}<br>	}<br></p><p>Not pretty I know, but the point is that you aren’t actually completely prevented, but you should have a good reason to want to do this if it circumvents what a developer set as an explicit requirement. In the case of Foo being abstract however this actually makes a lot of sense, as Bar would be the first proper implementation, so has to follow all the rules, but relaxing them afterwards is fine.<br></p><p>&gt; In general, this proposal seems like it&#39;s tremendously overengineered, insufficiently motivated, and fits poorly into Swift&#39;s syntax.<br></p><p>I don’t think the guts are actually that complex, the syntax just needs to be paired down to basics, and abstract classes possibly added later once the groundwork is done.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/43f3db1f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February 15, 2016 at 11:00:00pm</p></header><div class="content"><p>I like your idea of @super() a lot :)!<br></p><p>Sent from my iPhone<br></p><p>&gt; On 15 Feb 2016, at 22:52, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is an interesting idea, and fits well with the theme of preventing mistakes in Swift, but I think that the proposed solution isn’t flexible enough, as there are cases for inheritance patterns where extending doesn’t actually make sense, so having to specify an exception every time could quickly become annoying.<br>&gt; <br>&gt; I think the better solution is to instead allow super-classes to specify whether or not their method must be called when overridden/extended. For example:<br>&gt; <br>&gt; 	class View {<br>&gt; 		@super(required) func viewDidLoad() { … }<br>&gt; 	}<br>&gt; <br>&gt; 	class Button : View {<br>&gt; 		override func viewDidLoad() { … }<br>&gt; 	}<br>&gt; <br>&gt; 	class Widget : View {<br>&gt; 		override func viewDidLoad() {<br>&gt; 			super.viewDidLoad()<br>&gt; 			…<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; In this extension of your example Button will cause an error because it overrides viewDidLoad() but fails to call the parent’s method as required by the @super attribute. However, Widget compiles successfully because it follows the requirement.<br>&gt; <br>&gt; So the options for @super would be:<br>&gt; <br>&gt; required: child-class must call parent implementation of this method.<br>&gt; optional: default behaviour, child can choose whether to call the parent’s method.<br>&gt; denied: child may not call parent’s method (useful if it makes assumptions that a child-class may not follow), but can still extend/override.<br>&gt; <br>&gt; I think this would be a more flexible solution to the problem, and put the decision in the hands of those writing classes designed for inheritance. I’m not 100% sure of whether to rename override to extend, I like extend better personally, but it probably doesn’t matter overall.<br>&gt; <br>&gt;&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt; <br>&gt;&gt; class View {<br>&gt;&gt;   func viewDidLoad() {<br>&gt;&gt;      // does something<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Button: View {<br>&gt;&gt;  override func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;&gt;      // do something other<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt; <br>&gt;&gt; // Example for extending a function<br>&gt;&gt; class Button: View {<br>&gt;&gt;  extend func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()<br>&gt;&gt;      // do something<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;  extend func viewDidAppear() {<br>&gt;&gt;      // do something<br>&gt;&gt;   } // &lt;— the compiler should throw an error here.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Example for replacing a function<br>&gt;&gt; class Geometry {<br>&gt;&gt;   func volume() -&gt; Double {<br>&gt;&gt;      return 0;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cube: Geometry {<br>&gt;&gt;   var length: Double = 0.0<br>&gt;&gt;   replace func volume() -&gt; Double {<br>&gt;&gt;      let v = length * length * length<br>&gt;&gt;      return v<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Florian<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/7f8082b1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February 15, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 to @super :-)<br></p><p>On Mon, Feb 15, 2016 at 8:52 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is an interesting idea, and fits well with the theme of preventing<br>&gt; mistakes in Swift, but I think that the proposed solution isn’t flexible<br>&gt; enough, as there are cases for inheritance patterns where extending doesn’t<br>&gt; actually make sense, so having to specify an exception every time could<br>&gt; quickly become annoying.<br>&gt;<br>&gt; I think the better solution is to instead allow super-classes to specify<br>&gt; whether or not their method must be called when overridden/extended. For<br>&gt; example:<br>&gt;<br>&gt; class View {<br>&gt; @super(required) func viewDidLoad() { … }<br>&gt; }<br>&gt;<br>&gt; class Button : View {<br>&gt; override func viewDidLoad() { … }<br>&gt; }<br>&gt;<br>&gt; class Widget : View {<br>&gt; override func viewDidLoad() {<br>&gt; super.viewDidLoad()<br>&gt; …<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; In this extension of your example Button will cause an error because it<br>&gt; overrides viewDidLoad() but fails to call the parent’s method as required<br>&gt; by the @super attribute. However, Widget compiles successfully because it<br>&gt; follows the requirement.<br>&gt;<br>&gt; So the options for @super would be:<br>&gt;<br>&gt;<br>&gt;    - *required: *child-class must call parent implementation of this<br>&gt;    method.<br>&gt;    - *optional:* default behaviour, child can choose whether to call the<br>&gt;    parent’s method.<br>&gt;    - *denied:* child may not call parent’s method (useful if it makes<br>&gt;    assumptions that a child-class may not follow), but can still<br>&gt;    extend/override.<br>&gt;<br>&gt;<br>&gt; I think this would be a more flexible solution to the problem, and put the<br>&gt; decision in the hands of those writing classes designed for inheritance.<br>&gt; I’m not 100% sure of whether to rename override to extend, I like extend<br>&gt; better personally, but it probably doesn’t matter overall.<br>&gt;<br>&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi!<br>&gt;<br>&gt; I would like to suggest to replace the override keyword for functions by<br>&gt; something like extend and replace or to add an annotation like<br>&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt; The reason for this is, that it might happen, that one forgets to call the<br>&gt; super’s implementation in an overridden function or if one reads the code<br>&gt; it might not be obvious why the super’s implementation is not called:<br>&gt;<br>&gt; class View {<br>&gt;   func viewDidLoad() {<br>&gt;      // does something<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; class Button: View {<br>&gt;  override func viewDidLoad() {<br>&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;      // do something other<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; The compiler will accept if one overrides a superclass’s function but does<br>&gt; not call the superclass’s implementation which is often ok. The developer<br>&gt; should clearly state that he doesn’t want to call the superclass’s<br>&gt; implementation, otherwise the compiler should throw an error.<br>&gt;<br>&gt; // Example for extending a function<br>&gt; class Button: View {<br>&gt;  extend func viewDidLoad() {<br>&gt;      super.viewDidLoad()<br>&gt;      // do something<br>&gt;   }<br>&gt;<br>&gt;  extend func viewDidAppear() {<br>&gt;      // do something<br>&gt;   } // &lt;— the compiler should throw an error here.<br>&gt; }<br>&gt;<br>&gt; // Example for replacing a function<br>&gt; class Geometry {<br>&gt;   func volume() -&gt; Double {<br>&gt;      return 0;<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; class Cube: Geometry {<br>&gt;   var length: Double = 0.0<br>&gt;   replace func volume() -&gt; Double {<br>&gt;      let v = length * length * length<br>&gt;      return v<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Cheers,<br>&gt; Florian<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/c01ceb44/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 16, 2016 at 03:00:00am</p></header><div class="content"><p>Any clarity on when to use @ to prefix a keyword?<br>On Mon, Feb 15, 2016 at 4:53 PM Vanderlei Martinelli via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 to @super :-)<br>&gt;<br>&gt; On Mon, Feb 15, 2016 at 8:52 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is an interesting idea, and fits well with the theme of preventing<br>&gt;&gt; mistakes in Swift, but I think that the proposed solution isn’t flexible<br>&gt;&gt; enough, as there are cases for inheritance patterns where extending doesn’t<br>&gt;&gt; actually make sense, so having to specify an exception every time could<br>&gt;&gt; quickly become annoying.<br>&gt;&gt;<br>&gt;&gt; I think the better solution is to instead allow super-classes to specify<br>&gt;&gt; whether or not their method must be called when overridden/extended. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; class View {<br>&gt;&gt; @super(required) func viewDidLoad() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Button : View {<br>&gt;&gt; override func viewDidLoad() { … }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Widget : View {<br>&gt;&gt; override func viewDidLoad() {<br>&gt;&gt; super.viewDidLoad()<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In this extension of your example Button will cause an error because it<br>&gt;&gt; overrides viewDidLoad() but fails to call the parent’s method as required<br>&gt;&gt; by the @super attribute. However, Widget compiles successfully because it<br>&gt;&gt; follows the requirement.<br>&gt;&gt;<br>&gt;&gt; So the options for @super would be:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - *required: *child-class must call parent implementation of this<br>&gt;&gt;    method.<br>&gt;&gt;    - *optional:* default behaviour, child can choose whether to call the<br>&gt;&gt;    parent’s method.<br>&gt;&gt;    - *denied:* child may not call parent’s method (useful if it makes<br>&gt;&gt;    assumptions that a child-class may not follow), but can still<br>&gt;&gt;    extend/override.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think this would be a more flexible solution to the problem, and put<br>&gt;&gt; the decision in the hands of those writing classes designed for<br>&gt;&gt; inheritance. I’m not 100% sure of whether to rename override to extend, I<br>&gt;&gt; like extend better personally, but it probably doesn’t matter overall.<br>&gt;&gt;<br>&gt;&gt; On 15 Feb 2016, at 20:57, Florian Liefers via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi!<br>&gt;&gt;<br>&gt;&gt; I would like to suggest to replace the override keyword for functions by<br>&gt;&gt; something like extend and replace or to add an annotation like<br>&gt;&gt; @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; The reason for this is, that it might happen, that one forgets to call<br>&gt;&gt; the super’s implementation in an overridden function or if one reads the<br>&gt;&gt; code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt;<br>&gt;&gt; class View {<br>&gt;&gt;   func viewDidLoad() {<br>&gt;&gt;      // does something<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Button: View {<br>&gt;&gt;  override func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;&gt;      // do something other<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The compiler will accept if one overrides a superclass’s function but<br>&gt;&gt; does not call the superclass’s implementation which is often ok. The<br>&gt;&gt; developer should clearly state that he doesn’t want to call the<br>&gt;&gt; superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt;<br>&gt;&gt; // Example for extending a function<br>&gt;&gt; class Button: View {<br>&gt;&gt;  extend func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()<br>&gt;&gt;      // do something<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;  extend func viewDidAppear() {<br>&gt;&gt;      // do something<br>&gt;&gt;   } // &lt;— the compiler should throw an error here.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; // Example for replacing a function<br>&gt;&gt; class Geometry {<br>&gt;&gt;   func volume() -&gt; Double {<br>&gt;&gt;      return 0;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class Cube: Geometry {<br>&gt;&gt;   var length: Double = 0.0<br>&gt;&gt;   replace func volume() -&gt; Double {<br>&gt;&gt;      let v = length * length * length<br>&gt;&gt;      return v<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Cheers,<br>&gt;&gt; Florian<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/0f69ebd3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>February 16, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Florian,<br></p><p>I have always taken care of this problem in other languages without recurring to specialized language features.  For example:<br></p><p>class Foo {<br>    func _someMethod() {<br>	// Do something important<br>	…<br></p><p>	// Now give subclassers a chance to do something<br>	someMethod()<br>    }<br></p><p>    func someMethod() {<br>	// Default does nothing<br>    }<br>}<br></p><p>This way you are in control when someone else overrides someMethod since _someMethod() does the important stuff first and then calls someMethod() to allow those extending the class to do something. <br></p><p>Also, I can modify _someMethod() and move the “Do something important” part to be after the call to someMethod().  <br></p><p><br></p><p><br>&gt; On Feb 15, 2016, at 3:57 PM, Florian Liefers via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi!<br>&gt; <br>&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt; <br>&gt; class View {<br>&gt;   func viewDidLoad() {<br>&gt;      // does something<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Button: View {<br>&gt;  override func viewDidLoad() {<br>&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;      // do something other<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt; <br>&gt; // Example for extending a function<br>&gt; class Button: View {<br>&gt;  extend func viewDidLoad() {<br>&gt;      super.viewDidLoad()<br>&gt;      // do something<br>&gt;   }<br>&gt; <br>&gt;  extend func viewDidAppear() {<br>&gt;      // do something<br>&gt;   } // &lt;— the compiler should throw an error here.<br>&gt; }<br>&gt; <br>&gt; // Example for replacing a function<br>&gt; class Geometry {<br>&gt;   func volume() -&gt; Double {<br>&gt;      return 0;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; class Cube: Geometry {<br>&gt;   var length: Double = 0.0<br>&gt;   replace func volume() -&gt; Double {<br>&gt;      let v = length * length * length<br>&gt;      return v<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Cheers,<br>&gt; Florian<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/b424f672/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/671aaf492518a334ad3b9243cf2b1328?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Florian Liefers</string> &lt;florian at liefers.com&gt;<p>February 17, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Recardo,<br></p><p>this will only work for calls inside the superclass, but for calls from outside the class you have no control. If one calls Foo().someMethod() directly, _someMethod is not executed.<br></p><p>— Florian<br></p><p>&gt; Am 16.02.2016 um 23:43 schrieb Ricardo Parada &lt;rparada at mac.com&gt;:<br>&gt; <br>&gt; Hi Florian,<br>&gt; <br>&gt; I have always taken care of this problem in other languages without recurring to specialized language features.  For example:<br>&gt; <br>&gt; class Foo {<br>&gt;     func _someMethod() {<br>&gt; 	// Do something important<br>&gt; 	…<br>&gt; <br>&gt; 	// Now give subclassers a chance to do something<br>&gt; 	someMethod()<br>&gt;     }<br>&gt; <br>&gt;     func someMethod() {<br>&gt; 	// Default does nothing<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This way you are in control when someone else overrides someMethod since _someMethod() does the important stuff first and then calls someMethod() to allow those extending the class to do something. <br>&gt; <br>&gt; Also, I can modify _someMethod() and move the “Do something important” part to be after the call to someMethod().  <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 15, 2016, at 3:57 PM, Florian Liefers via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi!<br>&gt;&gt; <br>&gt;&gt; I would like to suggest to replace the override keyword for functions by something like extend and replace or to add an annotation like @SuppressSuperCall (don’t know a good name for it).<br>&gt;&gt; The reason for this is, that it might happen, that one forgets to call the super’s implementation in an overridden function or if one reads the code it might not be obvious why the super’s implementation is not called:<br>&gt;&gt; <br>&gt;&gt; class View {<br>&gt;&gt;   func viewDidLoad() {<br>&gt;&gt;      // does something<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Button: View {<br>&gt;&gt;  override func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()   // &lt;— this might be forgotten<br>&gt;&gt;      // do something other<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler will accept if one overrides a superclass’s function but does not call the superclass’s implementation which is often ok. The developer should clearly state that he doesn’t want to call the superclass’s implementation, otherwise the compiler should throw an error.<br>&gt;&gt; <br>&gt;&gt; // Example for extending a function<br>&gt;&gt; class Button: View {<br>&gt;&gt;  extend func viewDidLoad() {<br>&gt;&gt;      super.viewDidLoad()<br>&gt;&gt;      // do something<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;  extend func viewDidAppear() {<br>&gt;&gt;      // do something<br>&gt;&gt;   } // &lt;— the compiler should throw an error here.<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Example for replacing a function<br>&gt;&gt; class Geometry {<br>&gt;&gt;   func volume() -&gt; Double {<br>&gt;&gt;      return 0;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cube: Geometry {<br>&gt;&gt;   var length: Double = 0.0<br>&gt;&gt;   replace func volume() -&gt; Double {<br>&gt;&gt;      let v = length * length * length<br>&gt;&gt;      return v<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Florian<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Replace the override keyword by &#39;extend&#39; and &#39;replace&#39; or add an annotation like @SuppressSuperCall</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 17, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 16 Feb 2016, at 22:43, Ricardo Parada via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Florian,<br>&gt; <br>&gt; I have always taken care of this problem in other languages without recurring to specialized language features.  For example:<br>&gt; <br>&gt; class Foo {<br>&gt;     func _someMethod() {<br>&gt; 	// Do something important<br>&gt; 	…<br>&gt; <br>&gt; 	// Now give subclassers a chance to do something<br>&gt; 	someMethod()<br>&gt;     }<br>&gt; <br>&gt;     func someMethod() {<br>&gt; 	// Default does nothing<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; This way you are in control when someone else overrides someMethod since _someMethod() does the important stuff first and then calls someMethod() to allow those extending the class to do something. <br>&gt; <br>&gt; Also, I can modify _someMethod() and move the “Do something important” part to be after the call to someMethod().  <br></p><p>Is that the correct way around? I would have thought that _someMethod() would be the no-op that sub-classes can override? In languages where I’ve done this I would usually use doSomeMethod() but whatever.<br></p><p>While it’s a valid design pattern, it doesn’t really work in Swift due to the lack of a protected (sub-classes only) visibility type.<br>Even if we did have protected visibility, the other problem is that you still have a single function to override, so what happens when you want a second level of extension? Either the child method has to hope that further sub-classes don’t mess it up, or they have to mark it as final and declare their own new child method for each level below them. Aside from being a fun thing to find names for, it could get messy very quickly, it’d be much cleaner supported by a language feature, and could actually be more explicitly defined as well.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160217/d3bf6466/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
