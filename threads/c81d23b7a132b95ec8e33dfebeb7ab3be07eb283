<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/97ef005c28fc33d19118ecb65fb436e7?s=50"></div><header><strong>The swift didn&#39;t conform the calling convention for ppc64le</strong> from <string>bluedream</string> &lt;48825004 at qq.com&gt;<p>March  8, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi, all,<br></p><p>I am trying the swift compiler these days in ppc64le, and found that, if the function return type is aggr, the code swift generated didn&#39;t conform the ppc64le ABI.<br></p><p>&gt; cat test.swift <br>func test() -&gt; (Bool, Double, Int){<br>    return (true,3.0,3);<br>}<br></p><p>test();<br></p><p>&gt; swiftc test.swift -emit-ir<br>; ModuleID = &#39;-&#39;<br>target datalayout = &quot;e-m:e-i64:64-n32:64&quot;<br>target triple = &quot;powerpc64le-unknown-linux-gnu&quot;<br>...<br>define protected signext i32 @main(i32 signext, i8**) #0 {<br>entry:<br>  %2 = bitcast i8** %1 to i8*<br>  store i32 %0, i32* getelementptr inbounds (%Vs5Int32, %Vs5Int32* @_TZvOs7Process5_argcVs5Int32, i32 0, i32 0), align 4<br>  call void @swift_once(i64* @globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_token3, i8* bitcast (void ()* @globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3 to i8*))<br>  store i8* %2, i8** getelementptr inbounds (%Sp, %Sp* @_TZvOs7Process11_unsafeArgvGSpGSpVs4Int8__, i32 0, i32 0), align 8<br>  %3 = call { i1, double, i64 } @_TF4test4testFT_TSbSdSi_()<br>  %4 = extractvalue { i1, double, i64 } %3, 0<br>  %5 = extractvalue { i1, double, i64 } %3, 1<br>  %6 = extractvalue { i1, double, i64 } %3, 2<br>  ret i32 0<br>}<br></p><p>We can see that, swift emit the  { i1, double, i64 } as its return type and llvm will pass the return value of _TF4test4testFT_TSbSdSi_ by register.<br>&gt; objdump -dr test.o<br>...<br>            4c: R_PPC64_TOC16_HA    .toc+0x18<br>  50:    00 00 63 e8     ld      r3,0(r3)<br>            50: R_PPC64_TOC16_LO_DS    .toc+0x18<br>  54:    60 00 9f e8     ld      r4,96(r31)<br>  58:    00 00 83 f8     std     r4,0(r3)<br>  5c:    01 00 00 48     bl      5c &lt;main+0x5c&gt;<br>            5c: R_PPC64_REL24    _TF4test4testFT_TSbSdSi_<br>  60:    00 00 00 60     nop<br></p><p>However, for ppc64le ABI, this should be passed by address. See what clang emit the ir for return aggr of this type.<br></p><p>&gt; cat test2.cpp <br>struct A {<br>bool b;<br>double d;<br>long long m;<br>};<br></p><p>A test();<br></p><p>int main() {<br>    test();<br>    return 0;<br>}<br>&gt; clang test2.cpp -S -emit-llvm <br>&gt; cat test2.ll <br>; ModuleID = &#39;test2.cpp&#39;<br>target datalayout = &quot;e-m:e-i64:64-n32:64&quot;<br>target triple = &quot;powerpc64le-unknown-linux-gnu&quot;<br></p><p>%struct.A = type { i8, double, i64 }<br></p><p>; Function Attrs: norecurse<br>define signext i32 @main() #0 {<br>  %1 = alloca i32, align 4<br>  %2 = alloca %struct.A, align 8<br>  store i32 0, i32* %1, align 4<br>  call void @_Z4testv(%struct.A* sret %2)<br>  ret i32 0<br>}<br></p><p>declare void @_Z4testv(%struct.A* sret) #1<br></p><p>Clang frontend will place it as the first parameter of the function. That would cause serious issues if we are linking with code write from other language(i.e. c/c++). Any comments?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160308/c81db283/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>The swift didn&#39;t conform the calling convention for ppc64le</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  7, 2016 at 10:00:00pm</p></header><div class="content"><p>+John<br></p><p>On Mon, Mar 7, 2016 at 10:16 PM, bluedream via swift-dev<br>&lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hi, all,<br>&gt;<br>&gt; I am trying the swift compiler these days in ppc64le, and found that, if the<br>&gt; function return type is aggr, the code swift generated didn&#39;t conform the<br>&gt; ppc64le ABI.<br>&gt;<br>&gt;&gt; cat test.swift<br>&gt; func test() -&gt; (Bool, Double, Int){<br>&gt;     return (true,3.0,3);<br>&gt; }<br>&gt;<br>&gt; test();<br>&gt;<br>&gt;&gt; swiftc test.swift -emit-ir<br>&gt; ; ModuleID = &#39;-&#39;<br>&gt; target datalayout = &quot;e-m:e-i64:64-n32:64&quot;<br>&gt; target triple = &quot;powerpc64le-unknown-linux-gnu&quot;<br>&gt; ...<br>&gt; define protected signext i32 @main(i32 signext, i8**) #0 {<br>&gt; entry:<br>&gt;   %2 = bitcast i8** %1 to i8*<br>&gt;   store i32 %0, i32* getelementptr inbounds (%Vs5Int32, %Vs5Int32*<br>&gt; @_TZvOs7Process5_argcVs5Int32, i32 0, i32 0), align 4<br>&gt;   call void @swift_once(i64*<br>&gt; @globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_token3, i8* bitcast (void<br>&gt; ()* @globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3 to i8*))<br>&gt;   store i8* %2, i8** getelementptr inbounds (%Sp, %Sp*<br>&gt; @_TZvOs7Process11_unsafeArgvGSpGSpVs4Int8__, i32 0, i32 0), align 8<br>&gt;   %3 = call { i1, double, i64 } @_TF4test4testFT_TSbSdSi_()<br>&gt;   %4 = extractvalue { i1, double, i64 } %3, 0<br>&gt;   %5 = extractvalue { i1, double, i64 } %3, 1<br>&gt;   %6 = extractvalue { i1, double, i64 } %3, 2<br>&gt;   ret i32 0<br>&gt; }<br>&gt;<br>&gt; We can see that, swift emit the { i1, double, i64 } as its return type and<br>&gt; llvm will pass the return value of _TF4test4testFT_TSbSdSi_ by register.<br>&gt;&gt; objdump -dr test.o<br>&gt; ...<br>&gt;             4c: R_PPC64_TOC16_HA    .toc+0x18<br>&gt;   50:    00 00 63 e8     ld      r3,0(r3)<br>&gt;             50: R_PPC64_TOC16_LO_DS    .toc+0x18<br>&gt;   54:    60 00 9f e8     ld      r4,96(r31)<br>&gt;   58:    00 00 83 f8     std     r4,0(r3)<br>&gt;   5c:    01 00 00 48     bl      5c &lt;main+0x5c&gt;<br>&gt;             5c: R_PPC64_REL24    _TF4test4testFT_TSbSdSi_<br>&gt;   60:    00 00 00 60     nop<br>&gt;<br>&gt; However, for ppc64le ABI, this should be passed by address. See what clang<br>&gt; emit the ir for return aggr of this type.<br>&gt;<br>&gt;&gt; cat test2.cpp<br>&gt; struct A {<br>&gt; bool b;<br>&gt; double d;<br>&gt; long long m;<br>&gt; };<br>&gt;<br>&gt; A test();<br>&gt;<br>&gt; int main() {<br>&gt;     test();<br>&gt;     return 0;<br>&gt; }<br>&gt;&gt; clang test2.cpp -S -emit-llvm<br>&gt;&gt; cat test2.ll<br>&gt; ; ModuleID = &#39;test2.cpp&#39;<br>&gt; target datalayout = &quot;e-m:e-i64:64-n32:64&quot;<br>&gt; target triple = &quot;powerpc64le-unknown-linux-gnu&quot;<br>&gt;<br>&gt; %struct.A = type { i8, double, i64 }<br>&gt;<br>&gt; ; Function Attrs: norecurse<br>&gt; define signext i32 @main() #0 {<br>&gt;   %1 = alloca i32, align 4<br>&gt;   %2 = alloca %struct.A, align 8<br>&gt;   store i32 0, i32* %1, align 4<br>&gt;   call void @_Z4testv(%struct.A* sret %2)<br>&gt;   ret i32 0<br>&gt; }<br>&gt;<br>&gt; declare void @_Z4testv(%struct.A* sret) #1<br>&gt;<br>&gt; Clang frontend will place it as the first parameter of the function. That<br>&gt; would cause serious issues if we are linking with code write from other<br>&gt; language(i.e. c/c++). Any comments?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>The swift didn&#39;t conform the calling convention for ppc64le</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 09:00:00am</p></header><div class="content"><p>Swift does not use the C calling convention.<br></p><p>-Joe<br></p><p>&gt; On Mar 7, 2016, at 10:16 PM, bluedream via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, all,<br>&gt; <br>&gt; I am trying the swift compiler these days in ppc64le, and found that, if the function return type is aggr, the code swift generated didn&#39;t conform the ppc64le ABI.<br>&gt; <br>&gt; &gt; cat test.swift <br>&gt; func test() -&gt; (Bool, Double, Int){<br>&gt;     return (true,3.0,3);<br>&gt; }<br>&gt; <br>&gt; test();<br>&gt; <br>&gt; &gt; swiftc test.swift -emit-ir<br>&gt; ; ModuleID = &#39;-&#39;<br>&gt; target datalayout = &quot;e-m:e-i64:64-n32:64&quot;<br>&gt; target triple = &quot;powerpc64le-unknown-linux-gnu&quot;<br>&gt; ...<br>&gt; define protected signext i32 @main(i32 signext, i8**) #0 {<br>&gt; entry:<br>&gt;   %2 = bitcast i8** %1 to i8*<br>&gt;   store i32 %0, i32* getelementptr inbounds (%Vs5Int32, %Vs5Int32* @_TZvOs7Process5_argcVs5Int32, i32 0, i32 0), align 4<br>&gt;   call void @swift_once(i64* @globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_token3, i8* bitcast (void ()* @globalinit_33_1BDF70FFC18749BAB495A73B459ED2F0_func3 to i8*))<br>&gt;   store i8* %2, i8** getelementptr inbounds (%Sp, %Sp* @_TZvOs7Process11_unsafeArgvGSpGSpVs4Int8__, i32 0, i32 0), align 8<br>&gt;   %3 = call { i1, double, i64 } @_TF4test4testFT_TSbSdSi_()<br>&gt;   %4 = extractvalue { i1, double, i64 } %3, 0<br>&gt;   %5 = extractvalue { i1, double, i64 } %3, 1<br>&gt;   %6 = extractvalue { i1, double, i64 } %3, 2<br>&gt;   ret i32 0<br>&gt; }<br>&gt; <br>&gt; We can see that, swift emit the { i1, double, i64 } as its return type and llvm will pass the return value of _TF4test4testFT_TSbSdSi_ by register.<br>&gt; &gt; objdump -dr test.o<br>&gt; ...<br>&gt;             4c: R_PPC64_TOC16_HA    .toc+0x18<br>&gt;   50:    00 00 63 e8     ld      r3,0(r3)<br>&gt;             50: R_PPC64_TOC16_LO_DS    .toc+0x18<br>&gt;   54:    60 00 9f e8     ld      r4,96(r31)<br>&gt;   58:    00 00 83 f8     std     r4,0(r3)<br>&gt;   5c:    01 00 00 48     bl      5c &lt;main+0x5c&gt;<br>&gt;             5c: R_PPC64_REL24    _TF4test4testFT_TSbSdSi_<br>&gt;   60:    00 00 00 60     nop<br>&gt; <br>&gt; However, for ppc64le ABI, this should be passed by address. See what clang emit the ir for return aggr of this type.<br>&gt; <br>&gt; &gt; cat test2.cpp <br>&gt; struct A {<br>&gt; bool b;<br>&gt; double d;<br>&gt; long long m;<br>&gt; };<br>&gt; <br>&gt; A test();<br>&gt; <br>&gt; int main() {<br>&gt;     test();<br>&gt;     return 0;<br>&gt; }<br>&gt; &gt; clang test2.cpp -S -emit-llvm <br>&gt; &gt; cat test2.ll <br>&gt; ; ModuleID = &#39;test2.cpp&#39;<br>&gt; target datalayout = &quot;e-m:e-i64:64-n32:64&quot;<br>&gt; target triple = &quot;powerpc64le-unknown-linux-gnu&quot;<br>&gt; <br>&gt; %struct.A = type { i8, double, i64 }<br>&gt; <br>&gt; ; Function Attrs: norecurse<br>&gt; define signext i32 @main() #0 {<br>&gt;   %1 = alloca i32, align 4<br>&gt;   %2 = alloca %struct.A, align 8<br>&gt;   store i32 0, i32* %1, align 4<br>&gt;   call void @_Z4testv(%struct.A* sret %2)<br>&gt;   ret i32 0<br>&gt; }<br>&gt; <br>&gt; declare void @_Z4testv(%struct.A* sret) #1<br>&gt; <br>&gt; Clang frontend will place it as the first parameter of the function. That would cause serious issues if we are linking with code write from other language(i.e. c/c++). Any comments?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160308/1558e039/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>The swift didn&#39;t conform the calling convention for ppc64le</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 8, 2016, at 9:57 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift does not use the C calling convention.<br></p><p>…except for things that come from or are explicitly exported as C entry points.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
