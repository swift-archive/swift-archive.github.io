<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>[Pitch] Richer function identifiers, simpler function types</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>This is a great idea!<br>I&#39;d love to see this in Swift 3.<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;EBAF6231-ECB0-483B-A647-3629A7DAB44A at iki.fi&gt; <br></p><p>This is another reaction to SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; to which I&#39;m mildly against.<br></p><p>I&#39;d like to propose the following language changes to simplify function types and clarify what a function&#39;s name is. What gets removed is already ambiguous. And what is added makes higher-level programming with functions considerably simpler than currently. Furthermore, the proposed change considerably limits what constitutes the overload set of a function, which probably also speeds up the compilation process.<br></p><p>Let&#39;s consider the following declarations:<br></p><p>    func foo()                      // #1 Function named &#39;foo(_)&#39; with type &#39;() -&gt; ()&#39;.<br>    func foo(x: Int) -&gt; Int          // #2 Function named &#39;foo(x:)&#39; with type &#39;Int -&gt; Int&#39; (not an overload).<br>    func foo(_ x: Int) -&gt; Int        // #3 Function named &#39;foo(_:)&#39; with type &#39;Int -&gt; Int&#39;<br>    func foo(_ x: (Int, Int)) -&gt; Int // #4 Function named &#39;foo(_:)&#39; with type &#39;(Int, Int) -&gt; Int&#39; (overload of #3).<br>    func foo(x: Int, y: Int) -&gt; Int  // #5 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>    func foo(x: Int, y: Int) -&gt; Bool // #6 Function named &#39;foo(x:y:)&#39; with type &#39;(Int, Int) -&gt; Bool&#39; (overload of #5).<br>    let foo: Int                    // error: invalid redeclaration of &#39;foo&#39; (previously declared as a function)<br>    let baz: (Int, Int) -&gt; Int      // #7 Variable named &#39;baz&#39; with type &#39;(Int, Int) -&gt; Int&#39;.<br>    class Bar {<br>        func baz()                  // #8 Method named &#39;Bar.baz(_)&#39; with type &#39;Bar -&gt; () -&gt; ()&#39;.<br>        func baz(x y: Int)          // #9 Method named &#39;Bar.baz(x:)&#39; with type &#39;Bar -&gt; Int -&gt; ()&#39;.<br>        static func baz(x: Int = 0)  // #10 Static method named &#39;Bar.Self.baz(x:)&#39; with type &#39;Int -&gt; ()&#39;.<br>    }<br>    let f1 = foo                    // error: not a function reference, did you mean &#39;foo(_)&#39;?<br>    let f2 = foo as () -&gt; ()        // error: not a function reference, did you mean &#39;foo(_)&#39;?<br>    let f3 = foo(_)                  // #11 Function reference to #1. Has type &#39;() -&gt; ()&#39;.<br>    let f4 = foo(x:)                // #12 Function reference to #2. Has type &#39;Int -&gt; Int&#39;.<br>    let f5 = foo(_:)                // error: ambiguous function reference. Could be &#39;Int -&gt; Int&#39; or &#39;(Int, Int) -&gt; Int&#39;<br>    let f6 = foo(_:) as Int -&gt; Int  // #13 Function reference to #3. Has type &#39;Int -&gt; Int&#39;.<br>    let f7 = foo(_:) as (Int, Int) -&gt; Int // #14 Function reference to #4. Has type &#39;(Int, Int) -&gt; Int&#39;.<br>    let x1: Int = foo(x:y:)(1, 2)    // #15 Function application of #5. Picks the right overload by explicit return type.<br>    let x2: Bool = foo(x:y:)((1, 2)) // #16 Function application of #6. Allowing a tuple here causes no ambiguity.<br>    let f9 = baz                    // #17 Function reference synonymous to #7. Has type &#39;(Int, Int) -&gt; Int&#39;.<br>    let bar = Bar()<br>    let f10 = bar.baz                // error: not a function reference, did you mean &#39;bar.baz(_)&#39; or &#39;bar.baz(x:)&#39;?<br>    let f11 = bar.baz(_)            // #18 Function synonymous to the closure &#39;{ bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br>    let f12 = bar.baz(x:)            // #19 Function synonymous to the closure &#39;{ bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>    let f13 = Bar.Self.baz(x:)      // #20 Function synonymous to the closure &#39;{ Bar.baz(x: $0) }&#39; with type &#39;Int -&gt; ()&#39;.<br>    let f14 = Bar.Self.baz(_)        // #21 Function synonymous to the closure &#39;{ Bar.baz() }&#39; with type &#39;() -&gt; ()&#39;.<br></p><p>The following list of proposed changes sum up what&#39;s new above.<br></p><p>C1: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by adding the underscore-in-parentheses syntax `foo(_)` to refer to the zero-argument function #1.<br></p><p>C2: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by removing the ambiguity between instance and type members. From now on, `Bar.baz(_)` <br></p><p>C3: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; by banning the use of base name only to refer to a function, i.e. neither `foo` nor `Bar.baz` can be used to refer to refer to any of #1–#6 or #8–#10.<br></p><p>C4: Extend SE-0021 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0021-generalized-naming.md&gt; to allow the selective omission of defaulted arguments, e.g. `let f = print(_:separator:)` creates the function variable `f: (Any, String) -&gt; ()` equivalent to `{ print($0, separator: $1) }`.<br></p><p>C5: Clarify the language specification by stating that functions with different labels (e.g. `foo(_:)` vs. `foo(x:)`) are not overloads of each other. Instead, two functions are considered overloads of each other if only if they have matching base names (e.g. `foo`) and matching argument labels (e.g. `(x:y:)`) but differing argument or return types (e.g. #3 and #4, or #5 and #6).<br></p><p>C6: Clarify that by using the base name `foo` for a function, the same scope cannot define a variable with the name `foo`. And, vice versa, in a scope that defines a variable named `foo`, there can be no function `foo(...)` defined at the same scope level.<br></p><p>The implications are:<br></p><p>I1: The use of a function&#39;s base name to refer to a function will cease to work. It has, however, been buggy up to this date. Consider the following:<br></p><p>    let f = [Int].prefix // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br></p><p>    let g1 = [Int].dropFirst // Inexplicably chooses the &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39; overload!<br>    let g2 = [Int].dropFirst as [Int] -&gt; () -&gt; ArraySlice&lt;Int&gt; // Disambiguate by type.<br></p><p>    let h1 = [Int].sorted // Chooses the &#39;[Int] -&gt; () -&gt; [Int]&#39; overload, unlike &#39;dropFirst&#39; above.<br>    let h2 = [Int].sorted as [Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int] // Disambiguate by type.<br></p><p>With the proposed changes, the above becomes:<br></p><p>    let f = [Int].prefix(_:)    // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br></p><p>    let g1 = [Int].dropFirst(_:) // &#39;[Int] -&gt; Int -&gt; ArraySlice&lt;Int&gt;&#39;<br>    let g2 = [Int].dropFirst(_)  // &#39;[Int] -&gt; () -&gt; ArraySlice&lt;Int&gt;&#39;<br></p><p>    let h1 = [Int].sorted(_)                // &#39;[Int] -&gt; () -&gt; [Int]&#39;<br>    let h2 = [Int].sorted(isOrderedBefore:) // &#39;[Int] -&gt; ((Int, Int) -&gt; Bool) -&gt; [Int]&#39;<br></p><p>I2: When referring to functions the argument labels disappear in the returned function. That&#39;s a good thing because there&#39;s no generic way to call functions with arguments, and that&#39;s why closures too always come without argument labels. We don&#39;t, however, lose any clarity at the point where the function reference is passed as an argument because function references always contain the labels in the new notation. (Also, see the future directions for an idea how argument labels can be restored in the function variable.)<br></p><p>I3: Function argument lists are no longer that special and there&#39;s no need to notate single-n-tuple argument lists separately from n-argument functions, i.e. SE-0066 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md&gt; is not really needed anymore. The new intuition here is that it&#39;s the function&#39;s name that defines how a function can be called, not its type.<br></p><p>I4: Because function variables cannot be overloaded, we can without ambiguity allow all of the following &quot;tuple splatting&quot;:<br></p><p>    let tuple1 = (1, 2)<br>    let tuple2 = (x: 1, y: 2)<br>    let tuple3 = (a: 1, b: 2)<br>    let y1 = foo(tuple1)      // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>    let y2 = foo(tuple2)      // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>    let y3 = foo(tuple3)      // Not a &quot;tuple splat&quot;, calls #4 as normal.<br>    let y4 = foo(_:)(1, 2)    // Not a &quot;tuple splat&quot;, calls the reference to #4 as normal.<br>    let y5 = foo(_:)((1, 2))  // &quot;Tuple splat&quot;, calls #4.<br>    let y6 = foo(_:)(((1, 2))) // &quot;Tuple splat&quot;, calls #4. Nothing special here, just an unnecessary pair of parens.<br>    let y7 = foo(_:)(tuple1)  // &quot;Tuple splat&quot;, calls #4.<br>    let y8 = foo(_:)(tuple2)  // &quot;Tuple splat&quot;, calls #4. The labelled tuple type is compatible with &#39;(Int, Int)&#39;.<br>    let z1 = foo(x:y:)(tuple1) as Int // &quot;Tuple splat&quot;, calls #5 because the return type is explicitly &#39;Int&#39;.<br>    let z2 = foo(x:y:)(tuple2) as Int // &quot;Tuple splat&quot;, calls #5. The labels don&#39;t really matter here.<br>    let z3 = foo(x:y:)(tuple3) as Int // &quot;Tuple splat&quot;, calls #5. Like above, any tuple labels are compatible in the call.<br>    let z4 = (foo(x:y:) as (Int, Int) -&gt; Bool)(tuple3) // Here&#39;s another way to explicitly pick up the overload.<br></p><p>Future directions<br></p><p>F1: In this proposal, I made a difference between function identifier names and variable identifier names. However, it could be well allowed to use function-like names for function variables when clarity is needed. Then calling a block would require the argument labels just like functions:<br></p><p>    let block(value:) = {value in ...}<br>    block(value: 1)<br></p><p>    func foo(_ isOrderedBefore(lhs:rhs:): (Int, Int) -&gt; Bool) {<br>        let x = isOrderedBefore(lhs: 1, rhs: 2)<br>    }<br></p><p>F2: The following idea probably divides opinions, but because function variables are unambiguous, we could even allow calling them without parentheses like in Haskell. That would open up many doors to currying and building highly composable functional libraries:<br></p><p>    let f = {x in ...}<br>    let y = f 1 // calls &#39;f&#39; with an &#39;Int&#39;<br>    let z = f (1, 2) // calls &#39;f&#39; with an &#39;(Int, Int)&#39;<br></p><p>F3: And if that was allowed, maybe it could be possible to define functions with variable-like names and currying too, but now I&#39;m getting too far. I think the proposal is worth considering even if we never go to the direction of Haskell in this way.<br></p><p>— Pyry<br></p><p><br></p><p><br>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
