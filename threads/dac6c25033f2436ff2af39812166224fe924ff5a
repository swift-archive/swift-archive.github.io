<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d3a2e43276a7051960a44d28c326fb0?s=50"></div><header><strong>Set size of byte array</strong> from <string>KS Sreeram</string> &lt;ks at claylabs.com&gt;<p>August  5, 2016 at 12:00:00pm</p></header><div class="content"><p>Hello<br></p><p>I’m trying to initialize a byte-array efficiently with minimal copying with the following steps:<br></p><p>1. Create an empty byte array.<br>2. Reserve sufficient capacity in the array.<br>3. Use mutable pointers into the array to fill in the data.<br>4. The actual size that was filled is known only after it is filled in.<br>5. I would like to set the size of the array to the actual size.<br></p><p>I couldn’t find any methods for doing the last step. Is there a way to do this?<br></p><p>Thanks in advance!<br></p><p>KS Sreeram<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Set size of byte array</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August  5, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 4, 2016, at 11:42 PM, KS Sreeram via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m trying to initialize a byte-array efficiently with minimal copying with the following steps:<br>&gt; <br>&gt; 1. Create an empty byte array.<br>&gt; 2. Reserve sufficient capacity in the array.<br>&gt; 3. Use mutable pointers into the array to fill in the data.<br>&gt; 4. The actual size that was filled is known only after it is filled in.<br>&gt; 5. I would like to set the size of the array to the actual size.<br>&gt; <br>&gt; I couldn’t find any methods for doing the last step. Is there a way to do this?<br></p><p>I don&#39;t believe this is possible with an Array; the only way to work with uninitialized memory is with an UnsafeMutablePointer.<br></p><p>The simplest solution is probably to load the data into an allocated chunk of memory with an UnsafeMutablePointer and then create an NSData object to keep track of its lifetime. The `init(bytesNoCopy:length:deallocator:)` initializer can be used to make sure it deallocates the memory correctly.<br></p><p>If you don&#39;t *need* to use mutable pointers to fill the array, however, a custom SequenceType might be a better option. For instance, you could write a type like this which returns the data a byte at a time:<br></p><p>	struct MyDataSource: SequenceType, GeneratorType {<br>		...<br>		<br>		init(...) {<br>			...<br>		}<br>		<br>		var initialCapacity: Int {<br>			...guess at the capacity...<br>		}<br>		<br>		mutating func next() -&gt; UInt8? {<br>			...determine and return the next byte, or nil if you&#39;ve reached the end...<br>		}<br>	}<br></p><p>Then you can write something like this:<br></p><p>	var source = MyDataSource(...)<br>	var array: [UInt8] = []<br>	array.reserveCapacity(source.initialCapacity)<br>	array.appendContentsOf(source)<br></p><p>And, et voila, `array` is full of your bytes. From what I can tell, if the capacity is already there, the standard library effectively uses a loop as tight as any you could hope for:<br></p><p>    let base = buffer.firstElementAddress<br></p><p>    while (nextItem != nil) &amp;&amp; count &lt; capacity {<br>      (base + count).initialize(to: nextItem!)<br>      count += 1<br>      nextItem = stream.next()<br>    }<br>    buffer.count = count<br></p><p>So I suspect a custom SequenceType will perform much better than you would first guess.<br></p><p>Hope this helps,<br>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d3a2e43276a7051960a44d28c326fb0?s=50"></div><header><strong>Set size of byte array</strong> from <string>KS Sreeram</string> &lt;ks at claylabs.com&gt;<p>August  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 05-Aug-2016, at 4:02 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t believe this is possible with an Array; the only way to work with uninitialized memory is with an UnsafeMutablePointer.<br>&gt; <br>&gt; The simplest solution is probably to load the data into an allocated chunk of memory with an UnsafeMutablePointer and then create an NSData object to keep track of its lifetime. The `init(bytesNoCopy:length:deallocator:)` initializer can be used to make sure it deallocates the memory correctly.<br></p><p>Thanks for the tip. This does mean I have to give up the niceties of arrays post initialization.<br></p><p>&gt; <br>&gt; If you don&#39;t *need* to use mutable pointers to fill the array, however, a custom SequenceType might be a better option. For instance, you could write a type like this which returns the data a byte at a time:<br>&gt; <br>&gt; 	struct MyDataSource: SequenceType, GeneratorType {<br>&gt; <br>&gt; Then you can write something like this:<br>&gt; <br>&gt; 	var source = MyDataSource(...)<br>&gt; 	var array: [UInt8] = []<br>&gt; 	array.reserveCapacity(source.initialCapacity)<br>&gt; 	array.appendContentsOf(source)<br>&gt; <br>&gt; And, et voila, `array` is full of your bytes. From what I can tell, if the capacity is already there, the standard library effectively uses a loop as tight as any you could hope for:<br>&gt; <br>&gt;    let base = buffer.firstElementAddress<br>&gt; <br>&gt;    while (nextItem != nil) &amp;&amp; count &lt; capacity {<br>&gt;      (base + count).initialize(to: nextItem!)<br>&gt;      count += 1<br>&gt;      nextItem = stream.next()<br>&gt;    }<br>&gt;    buffer.count = count<br>&gt; <br>&gt; So I suspect a custom SequenceType will perform much better than you would first guess.<br></p><p><br>The code I’m working on essentially does serialization. It’s not really amenable to the inversion of control required for generators.<br></p><p>Best<br>KS Sreeram<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
