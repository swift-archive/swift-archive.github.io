<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 29, 2016 at 06:00:00pm</p></header><div class="content"><p>The intent of my function wasn’t very clear, but it was supposed to return a sequence that contains *all* consecutive pairs, i.e. (0 ..&lt; 4).pairs would result in [(0, 1), (1, 2), (2, 3)].<br></p><p>&gt; on Fri Aug 26 2016, Tim Vermeulen&lt;swift-evolution at swift.org&gt;wrote:<br>&gt; <br>&gt; &gt; This is when I first wanted to pass an optional for the `first` parameter:<br>&gt; &gt; <br>&gt; &gt; extension Sequence {<br>&gt; &gt; <br>&gt; &gt; /// Returns a sequence of pairs of consecutive elements<br>&gt; &gt; /// of the sequence, in order.<br>&gt; &gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt; &gt; var iterator = makeIterator()<br>&gt; &gt; <br>&gt; &gt; let firstPair = iterator.next().flatMap { first in<br>&gt; &gt; iterator.next().map { second in (first, second) }<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; // I can&#39;t do this, because `firstPair` is optional<br>&gt; &gt; let seq = sequence(first: firstPair) { _, second in<br>&gt; &gt; guard let next = iterator.next() else { return nil }<br>&gt; &gt; return (second, next)<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; return AnySequence(seq)<br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; }<br>&gt; &gt; <br>&gt; &gt; In this particular case, finding a workaround is fairly easy (with a<br>&gt; &gt; guard and `return AnySequence([])` in the `else` block). However, this<br>&gt; &gt; becomes less elegant if you just want to iterate over it rather than<br>&gt; &gt; wrap it in AnySequence.<br>&gt; This is why we have sequence(state:next:)<br>&gt; <br>&gt; <br>&gt; extension Sequence {<br>&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt; /// of the sequence, in order.<br>&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt; return AnySequence(<br>&gt; sequence(<br>&gt; state: makeIterator(),<br>&gt; next: { (iter: inout Iterator) in<br>&gt; iter.next().flatMap { first in<br>&gt; iter.next().map { (first, $0) }<br>&gt; }<br>&gt; })<br>&gt; )<br>&gt; }<br>&gt; }<br>&gt; <br>&gt; for j in 0..&lt;10 {<br>&gt; print(Array((0..&lt;j).pairs))<br>&gt; }<br>&gt; <br>&gt; HTH,<br>&gt; Dave<br>&gt; &gt; <br>&gt; &gt; &gt; Hi Tim,<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; After having a quick conversation with Dave, here is the question I<br>&gt; &gt; &gt; should have asked right away: can you share the typical problem you<br>&gt; &gt; &gt; are solving with your overload of the `sequence(first:next:)`<br>&gt; &gt; &gt; function?<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Max<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; On Aug 20, 2016, at 2:26 AM, Tim<br>&gt; &gt; &gt; &gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; What you’re saying makes sense, and I might not have brought this<br>&gt; &gt; &gt; &gt; up in the first place if `first.map { sequence(first: $0, next:<br>&gt; &gt; &gt; &gt; next } ?? []` worked. The main annoyance is that the best solution<br>&gt; &gt; &gt; &gt; (currently) seems to be to copy the source code and make a change.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; (cc-ing Jordan Rose because of a related swift-users thread) This<br>&gt; &gt; &gt; &gt; might be a bit of a stretch, but can’t Swift upcast sequences to<br>&gt; &gt; &gt; &gt; AnySequence implicitly, like is done with AnyHashable? That would<br>&gt; &gt; &gt; &gt; make `first.map { sequence(first: $0, next: next } ?? []`<br>&gt; &gt; &gt; &gt; instantly valid, I think. There’s also something to be said for<br>&gt; &gt; &gt; &gt; consistency between type erasers. (I’m not necessarily talking<br>&gt; &gt; &gt; &gt; about Swift 3)<br>&gt; &gt; &gt; &gt; &gt; On 20 Aug 2016, at 02:22, Max<br>&gt; &gt; &gt; &gt; &gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; Hi Tim,<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; I still believe that having 2 termination conditions is<br>&gt; &gt; &gt; &gt; &gt; wrong. But I guess we need a tie breaker here, someone with a<br>&gt; &gt; &gt; &gt; &gt; strong opinion about the problem.<br>&gt; &gt; &gt; &gt; &gt; As Kevin mentioned we are very late in the release process, so<br>&gt; &gt; &gt; &gt; &gt; waiting for another opinion for a day or two won’t change<br>&gt; &gt; &gt; &gt; &gt; anything, really.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work.<br>&gt; &gt; &gt; &gt; &gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol<br>&gt; &gt; &gt; &gt; &gt; conformance to the `UnfoldSequence`, this snippet will compile<br>&gt; &gt; &gt; &gt; &gt; just fine. One downside is that the `ExpressibleByArrayLiteral`<br>&gt; &gt; &gt; &gt; &gt; protocol allows creating non-empty sequences as well, which does<br>&gt; &gt; &gt; &gt; &gt; not make sense for the `UnfoldSequence`.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; Max<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; On 19 Aug 2016, at 19:48, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; AFAIK this issue has never been discussed with<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(first:next:) before. It certainly wasn&#39;t brought up<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; during review.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; As for my opinion, I&#39;m really not sure. I was going to point<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; out that right now sequence(first:next:) guarantees that the<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; first element of the resulting sequence is the value<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; provided as &quot;first&quot;, but it occurs to me that if you treat<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; the nil result from next() as an element, then this still<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; holds true. So I guess my biggest worry is this change will<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; make it harder to use sequence(first:next:) to produce<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; sequences of optional values.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; I don’t think producing sequences of optional values would<br>&gt; &gt; &gt; &gt; &gt; &gt; really be a problem, because type inference will figure this<br>&gt; &gt; &gt; &gt; &gt; &gt; out based on whether you treat the argument to the `next`<br>&gt; &gt; &gt; &gt; &gt; &gt; closure as an optional or not. And if you only do things in<br>&gt; &gt; &gt; &gt; &gt; &gt; `next` that work both with optionals and non-optionals (very<br>&gt; &gt; &gt; &gt; &gt; &gt; unlikely), you can always manually specify the type of the<br>&gt; &gt; &gt; &gt; &gt; &gt; sequence.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; -Kevin Ballard<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Do you remember the problem of non-emptiness being<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; discussed before? And if not, what’s your opinion on the<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; proposed change?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks,<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Max<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Aug 19, 2016, at 7:53 AM, Tim<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Max, thanks for having a look.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; A big part of why I’m not really happy with the current<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; implementation is that the function always produces a<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; nonempty sequence, though the compiler doesn’t know<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; it. `sequence(first: first, next: next).last` returns an<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; optional, even though it can’t possibly be nil. The same<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; goes for something like `sequence(first: 5, next: { $0 *<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; 3 }).first(where: { $0&gt;1000 })`, because the sequence is<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; infinite, which means `first(while:)` will either keep<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; running forever, or return a non-optional.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt;T?)—returns any sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T?)—returns a nonempty sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T)—returns an infinite sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Default implementations for methods on sequences would<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; either return optionals or non-optionals depending on<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; their emptiness/finiteness. We just have the first kind<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; of sequence right now, so in that regard it would make<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sense to also give `sequence(first:next)` the<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; corresponding signature.Later, when the language /<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; standard library supports the other two kinds of<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequences (if that ever happens), the other versions<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; could be added.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Another reason that makes me think that the version that<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; accepts an optional `first` argument is more natural, is<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; the fact that the function body doesn’t need to be<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; changed at all. It supports optional seeds by design;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; only the signature prevents it.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I know these arguments might not be very convincing, but<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I feel like Swift misses an opportunity if it<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; unnecessarily constrains the `first` parameter to be<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; non-optional. The `.lazy.flatMap({ $0 })` alternative<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; that you pointed out does work, but it makes everything<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; very unreadable: not just the `.lazy.flatMap({ $0 })`<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; part, but also the body of the `next` parameter because<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; you’re now dealing with optionals (i.e. you have to<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; `flatMap` over the closure argument). The best solution<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I’ve come up with is to copy the `sequence(first:next)`<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; implementation from the source code and change the<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; signature. :-/<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; `sequence(state:next:)` isn’t very appropriate for this<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; task either, because naive usage with an optional seed<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; has the downside of being unnecessarily eager just like<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; a naive `sequence(first:next)` implementation (as<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; described in a comment in the source code).<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On 19 Aug 2016, at 00:18, Max<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Tim,<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks for bringing this up.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Here are my thoughts on the change you’re proposing.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt;T?) -&gt;UnfoldFirstSequence&lt;T&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; To me the type of the function as it is tells a clear<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; story of what’s going to happen: take the `first`,<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; make it a head of the resulting sequence, and then try<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; to produce the tail by a series of applications of<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; `next`. The only thing that controls when the sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; generation terminates is the result of `next`.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; If we change the type of `first` to an Optional&lt;T&gt;, it<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; would make the termination condition<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; non-trivial. After all, the only thing it would do is<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; try to unwrap the `first`, before doing what it needs<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; to, but we already have a `map` for that. One should<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; be able to simply do the `first.map { sequence(first:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; $0, next: next) } ?? []` but that won’t work with the<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; types very well, unfortunately.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; As an alternative, `let first: Int? = ...;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(first: first, next: next).flatMap({$0})` (or<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; even `.lazy.flatMap({$0})`) will do the right thing<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; without making an API more complex.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I see the point of `sequence(first:next:)` to be<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; precisely the &quot;generate the non-empty sequence using a<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; seed and a simple producer&quot;, for anything more than<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; that, there is `sequence(state:next:)`.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; What do you think?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Max<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(first:next:) takes a non-optional first<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; argument. Is there a reason for that?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(state:next:) allows empty sequences, and I<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; don’t see why sequence(first:next:) shouldn’t. The<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; fix would be to simply add the `?` in the function<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; signature; no other changes are required to make it<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; work.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution-m3FHrko0VLw at public.gmane.orgg)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; --<br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>August 30, 2016 at 10:00:00am</p></header><div class="content"><p>FWIW, the ‘classical’ way of doing what I think you’re trying to do is:<br></p><p>extension Sequence {<br>  var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>    return AnySequence(zip(self, self.dropFirst()))<br>  }<br>}<br></p><p>Does it have the right behavior?<br></p><p>Max<br></p><p>&gt; On Aug 29, 2016, at 9:45 AM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The intent of my function wasn’t very clear, but it was supposed to return a sequence that contains *all* consecutive pairs, i.e. (0 ..&lt; 4).pairs would result in [(0, 1), (1, 2), (2, 3)].<br>&gt; <br>&gt;&gt; on Fri Aug 26 2016, Tim Vermeulen&lt;swift-evolution at swift.org&gt;wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This is when I first wanted to pass an optional for the `first` parameter:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt;&gt;&gt; /// of the sequence, in order.<br>&gt;&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt;&gt;&gt; var iterator = makeIterator()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let firstPair = iterator.next().flatMap { first in<br>&gt;&gt;&gt; iterator.next().map { second in (first, second) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // I can&#39;t do this, because `firstPair` is optional<br>&gt;&gt;&gt; let seq = sequence(first: firstPair) { _, second in<br>&gt;&gt;&gt; guard let next = iterator.next() else { return nil }<br>&gt;&gt;&gt; return (second, next)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return AnySequence(seq)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this particular case, finding a workaround is fairly easy (with a<br>&gt;&gt;&gt; guard and `return AnySequence([])` in the `else` block). However, this<br>&gt;&gt;&gt; becomes less elegant if you just want to iterate over it rather than<br>&gt;&gt;&gt; wrap it in AnySequence.<br>&gt;&gt; This is why we have sequence(state:next:)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; extension Sequence {<br>&gt;&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt;&gt; /// of the sequence, in order.<br>&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt;&gt; return AnySequence(<br>&gt;&gt; sequence(<br>&gt;&gt; state: makeIterator(),<br>&gt;&gt; next: { (iter: inout Iterator) in<br>&gt;&gt; iter.next().flatMap { first in<br>&gt;&gt; iter.next().map { (first, $0) }<br>&gt;&gt; }<br>&gt;&gt; })<br>&gt;&gt; )<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; for j in 0..&lt;10 {<br>&gt;&gt; print(Array((0..&lt;j).pairs))<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; HTH,<br>&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After having a quick conversation with Dave, here is the question I<br>&gt;&gt;&gt;&gt; should have asked right away: can you share the typical problem you<br>&gt;&gt;&gt;&gt; are solving with your overload of the `sequence(first:next:)`<br>&gt;&gt;&gt;&gt; function?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 20, 2016, at 2:26 AM, Tim<br>&gt;&gt;&gt;&gt;&gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt; What you’re saying makes sense, and I might not have brought this<br>&gt;&gt;&gt;&gt;&gt; up in the first place if `first.map { sequence(first: $0, next:<br>&gt;&gt;&gt;&gt;&gt; next } ?? []` worked. The main annoyance is that the best solution<br>&gt;&gt;&gt;&gt;&gt; (currently) seems to be to copy the source code and make a change.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (cc-ing Jordan Rose because of a related swift-users thread) This<br>&gt;&gt;&gt;&gt;&gt; might be a bit of a stretch, but can’t Swift upcast sequences to<br>&gt;&gt;&gt;&gt;&gt; AnySequence implicitly, like is done with AnyHashable? That would<br>&gt;&gt;&gt;&gt;&gt; make `first.map { sequence(first: $0, next: next } ?? []`<br>&gt;&gt;&gt;&gt;&gt; instantly valid, I think. There’s also something to be said for<br>&gt;&gt;&gt;&gt;&gt; consistency between type erasers. (I’m not necessarily talking<br>&gt;&gt;&gt;&gt;&gt; about Swift 3)<br>&gt;&gt;&gt;&gt;&gt;&gt; On 20 Aug 2016, at 02:22, Max<br>&gt;&gt;&gt;&gt;&gt;&gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still believe that having 2 termination conditions is<br>&gt;&gt;&gt;&gt;&gt;&gt; wrong. But I guess we need a tie breaker here, someone with a<br>&gt;&gt;&gt;&gt;&gt;&gt; strong opinion about the problem.<br>&gt;&gt;&gt;&gt;&gt;&gt; As Kevin mentioned we are very late in the release process, so<br>&gt;&gt;&gt;&gt;&gt;&gt; waiting for another opinion for a day or two won’t change<br>&gt;&gt;&gt;&gt;&gt;&gt; anything, really.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work.<br>&gt;&gt;&gt;&gt;&gt;&gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; conformance to the `UnfoldSequence`, this snippet will compile<br>&gt;&gt;&gt;&gt;&gt;&gt; just fine. One downside is that the `ExpressibleByArrayLiteral`<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol allows creating non-empty sequences as well, which does<br>&gt;&gt;&gt;&gt;&gt;&gt; not make sense for the `UnfoldSequence`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:48, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AFAIK this issue has never been discussed with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) before. It certainly wasn&#39;t brought up<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; during review.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for my opinion, I&#39;m really not sure. I was going to point<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out that right now sequence(first:next:) guarantees that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; first element of the resulting sequence is the value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; provided as &quot;first&quot;, but it occurs to me that if you treat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the nil result from next() as an element, then this still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; holds true. So I guess my biggest worry is this change will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it harder to use sequence(first:next:) to produce<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences of optional values.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think producing sequences of optional values would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; really be a problem, because type inference will figure this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; out based on whether you treat the argument to the `next`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; closure as an optional or not. And if you only do things in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `next` that work both with optionals and non-optionals (very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; unlikely), you can always manually specify the type of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you remember the problem of non-emptiness being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussed before? And if not, what’s your opinion on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed change?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A big part of why I’m not really happy with the current<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation is that the function always produces a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nonempty sequence, though the compiler doesn’t know<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it. `sequence(first: first, next: next).last` returns an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optional, even though it can’t possibly be nil. The same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; goes for something like `sequence(first: 5, next: { $0 *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3 }).first(where: { $0&gt;1000 })`, because the sequence is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; infinite, which means `first(while:)` will either keep<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; running forever, or return a non-optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt;T?)—returns any sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T?)—returns a nonempty sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T)—returns an infinite sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Default implementations for methods on sequences would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either return optionals or non-optionals depending on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their emptiness/finiteness. We just have the first kind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of sequence right now, so in that regard it would make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense to also give `sequence(first:next)` the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; corresponding signature.Later, when the language /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library supports the other two kinds of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences (if that ever happens), the other versions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could be added.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another reason that makes me think that the version that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; accepts an optional `first` argument is more natural, is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fact that the function body doesn’t need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; changed at all. It supports optional seeds by design;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only the signature prevents it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know these arguments might not be very convincing, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I feel like Swift misses an opportunity if it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unnecessarily constrains the `first` parameter to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-optional. The `.lazy.flatMap({ $0 })` alternative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that you pointed out does work, but it makes everything<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; very unreadable: not just the `.lazy.flatMap({ $0 })`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; part, but also the body of the `next` parameter because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you’re now dealing with optionals (i.e. you have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `flatMap` over the closure argument). The best solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve come up with is to copy the `sequence(first:next)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation from the source code and change the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; signature. :-/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; task either, because naive usage with an optional seed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; has the downside of being unnecessarily eager just like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a naive `sequence(first:next)` implementation (as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; described in a comment in the source code).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt;T?) -&gt;UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; story of what’s going to happen: take the `first`,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it a head of the resulting sequence, and then try<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to produce the tail by a series of applications of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `next`. The only thing that controls when the sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would make the termination condition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-trivial. After all, the only thing it would do is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; try to unwrap the `first`, before doing what it needs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to, but we already have a `map` for that. One should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be able to simply do the `first.map { sequence(first:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; $0, next: next) } ?? []` but that won’t work with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types very well, unfortunately.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first: first, next: next).flatMap({$0})` (or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; even `.lazy.flatMap({$0})`) will do the right thing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without making an API more complex.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; precisely the &quot;generate the non-empty sequence using a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; seed and a simple producer&quot;, for anything more than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument. Is there a reason for that?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(state:next:) allows empty sequences, and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t see why sequence(first:next:) shouldn’t. The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fix would be to simply add the `?` in the function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; signature; no other changes are required to make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution-m3FHrko0VLw at public.gmane.orgg)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; --<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 30, 2016 at 08:00:00pm</p></header><div class="content"><p>That works, though it calls `next()` on an iterator twice as often as is necessary… Either way, it’s not that important. There are ways around not having an optional `first` parameter. When I brought it up I thought it was just an oversight, but now that it turns out it isn’t (and there are reasonable alternatives), I’m quite fine with its current implementation. :)<br></p><p>&gt; On 30 Aug 2016, at 19:13, Max Moiseev &lt;moiseev at apple.com&gt; wrote:<br>&gt; <br>&gt; FWIW, the ‘classical’ way of doing what I think you’re trying to do is:<br>&gt; <br>&gt; extension Sequence {<br>&gt;  var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>&gt;    return AnySequence(zip(self, self.dropFirst()))<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Does it have the right behavior?<br>&gt; <br>&gt; Max<br>&gt; <br>&gt;&gt; On Aug 29, 2016, at 9:45 AM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The intent of my function wasn’t very clear, but it was supposed to return a sequence that contains *all* consecutive pairs, i.e. (0 ..&lt; 4).pairs would result in [(0, 1), (1, 2), (2, 3)].<br>&gt;&gt; <br>&gt;&gt;&gt; on Fri Aug 26 2016, Tim Vermeulen&lt;swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is when I first wanted to pass an optional for the `first` parameter:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt;&gt;&gt;&gt; /// of the sequence, in order.<br>&gt;&gt;&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt;&gt;&gt;&gt; var iterator = makeIterator()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let firstPair = iterator.next().flatMap { first in<br>&gt;&gt;&gt;&gt; iterator.next().map { second in (first, second) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // I can&#39;t do this, because `firstPair` is optional<br>&gt;&gt;&gt;&gt; let seq = sequence(first: firstPair) { _, second in<br>&gt;&gt;&gt;&gt; guard let next = iterator.next() else { return nil }<br>&gt;&gt;&gt;&gt; return (second, next)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return AnySequence(seq)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this particular case, finding a workaround is fairly easy (with a<br>&gt;&gt;&gt;&gt; guard and `return AnySequence([])` in the `else` block). However, this<br>&gt;&gt;&gt;&gt; becomes less elegant if you just want to iterate over it rather than<br>&gt;&gt;&gt;&gt; wrap it in AnySequence.<br>&gt;&gt;&gt; This is why we have sequence(state:next:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt;&gt;&gt; /// of the sequence, in order.<br>&gt;&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt;&gt;&gt; return AnySequence(<br>&gt;&gt;&gt; sequence(<br>&gt;&gt;&gt; state: makeIterator(),<br>&gt;&gt;&gt; next: { (iter: inout Iterator) in<br>&gt;&gt;&gt; iter.next().flatMap { first in<br>&gt;&gt;&gt; iter.next().map { (first, $0) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; })<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for j in 0..&lt;10 {<br>&gt;&gt;&gt; print(Array((0..&lt;j).pairs))<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HTH,<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After having a quick conversation with Dave, here is the question I<br>&gt;&gt;&gt;&gt;&gt; should have asked right away: can you share the typical problem you<br>&gt;&gt;&gt;&gt;&gt; are solving with your overload of the `sequence(first:next:)`<br>&gt;&gt;&gt;&gt;&gt; function?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 20, 2016, at 2:26 AM, Tim<br>&gt;&gt;&gt;&gt;&gt;&gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; What you’re saying makes sense, and I might not have brought this<br>&gt;&gt;&gt;&gt;&gt;&gt; up in the first place if `first.map { sequence(first: $0, next:<br>&gt;&gt;&gt;&gt;&gt;&gt; next } ?? []` worked. The main annoyance is that the best solution<br>&gt;&gt;&gt;&gt;&gt;&gt; (currently) seems to be to copy the source code and make a change.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (cc-ing Jordan Rose because of a related swift-users thread) This<br>&gt;&gt;&gt;&gt;&gt;&gt; might be a bit of a stretch, but can’t Swift upcast sequences to<br>&gt;&gt;&gt;&gt;&gt;&gt; AnySequence implicitly, like is done with AnyHashable? That would<br>&gt;&gt;&gt;&gt;&gt;&gt; make `first.map { sequence(first: $0, next: next } ?? []`<br>&gt;&gt;&gt;&gt;&gt;&gt; instantly valid, I think. There’s also something to be said for<br>&gt;&gt;&gt;&gt;&gt;&gt; consistency between type erasers. (I’m not necessarily talking<br>&gt;&gt;&gt;&gt;&gt;&gt; about Swift 3)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 20 Aug 2016, at 02:22, Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I still believe that having 2 termination conditions is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong. But I guess we need a tie breaker here, someone with a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; strong opinion about the problem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Kevin mentioned we are very late in the release process, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; waiting for another opinion for a day or two won’t change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything, really.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to the `UnfoldSequence`, this snippet will compile<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; just fine. One downside is that the `ExpressibleByArrayLiteral`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol allows creating non-empty sequences as well, which does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not make sense for the `UnfoldSequence`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:48, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AFAIK this issue has never been discussed with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) before. It certainly wasn&#39;t brought up<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; during review.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for my opinion, I&#39;m really not sure. I was going to point<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out that right now sequence(first:next:) guarantees that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; first element of the resulting sequence is the value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; provided as &quot;first&quot;, but it occurs to me that if you treat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the nil result from next() as an element, then this still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; holds true. So I guess my biggest worry is this change will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it harder to use sequence(first:next:) to produce<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences of optional values.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think producing sequences of optional values would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; really be a problem, because type inference will figure this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out based on whether you treat the argument to the `next`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; closure as an optional or not. And if you only do things in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `next` that work both with optionals and non-optionals (very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unlikely), you can always manually specify the type of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you remember the problem of non-emptiness being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussed before? And if not, what’s your opinion on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed change?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A big part of why I’m not really happy with the current<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation is that the function always produces a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nonempty sequence, though the compiler doesn’t know<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it. `sequence(first: first, next: next).last` returns an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optional, even though it can’t possibly be nil. The same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; goes for something like `sequence(first: 5, next: { $0 *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3 }).first(where: { $0&gt;1000 })`, because the sequence is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; infinite, which means `first(while:)` will either keep<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; running forever, or return a non-optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt;T?)—returns any sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T?)—returns a nonempty sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T)—returns an infinite sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Default implementations for methods on sequences would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either return optionals or non-optionals depending on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their emptiness/finiteness. We just have the first kind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of sequence right now, so in that regard it would make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense to also give `sequence(first:next)` the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; corresponding signature.Later, when the language /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library supports the other two kinds of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences (if that ever happens), the other versions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could be added.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another reason that makes me think that the version that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; accepts an optional `first` argument is more natural, is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fact that the function body doesn’t need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; changed at all. It supports optional seeds by design;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only the signature prevents it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know these arguments might not be very convincing, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I feel like Swift misses an opportunity if it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unnecessarily constrains the `first` parameter to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-optional. The `.lazy.flatMap({ $0 })` alternative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that you pointed out does work, but it makes everything<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; very unreadable: not just the `.lazy.flatMap({ $0 })`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; part, but also the body of the `next` parameter because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you’re now dealing with optionals (i.e. you have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `flatMap` over the closure argument). The best solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve come up with is to copy the `sequence(first:next)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation from the source code and change the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; signature. :-/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; task either, because naive usage with an optional seed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; has the downside of being unnecessarily eager just like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a naive `sequence(first:next)` implementation (as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; described in a comment in the source code).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt;T?) -&gt;UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; story of what’s going to happen: take the `first`,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it a head of the resulting sequence, and then try<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to produce the tail by a series of applications of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `next`. The only thing that controls when the sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would make the termination condition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-trivial. After all, the only thing it would do is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; try to unwrap the `first`, before doing what it needs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to, but we already have a `map` for that. One should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be able to simply do the `first.map { sequence(first:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; $0, next: next) } ?? []` but that won’t work with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types very well, unfortunately.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first: first, next: next).flatMap({$0})` (or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; even `.lazy.flatMap({$0})`) will do the right thing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without making an API more complex.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; precisely the &quot;generate the non-empty sequence using a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; seed and a simple producer&quot;, for anything more than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument. Is there a reason for that?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(state:next:) allows empty sequences, and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t see why sequence(first:next:) shouldn’t. The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fix would be to simply add the `?` in the function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; signature; no other changes are required to make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution-m3FHrko0VLw at public.gmane.orgg)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>August 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Max Moiseev wrote:<br>&gt; <br>&gt; FWIW, the ‘classical’ way of doing what I think you’re trying to do is:<br>&gt; <br>&gt; extension Sequence {<br>&gt;  var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>&gt;    return AnySequence(zip(self, self.dropFirst()))<br>&gt;  }<br>&gt; }<br>&gt; <br>&gt; Does it have the right behavior?<br></p><p>It doesn&#39;t if the sequence is single-pass or if iterating over it multiple times has other unwanted side-effects.<br></p><p>— Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c53218a6524f4d644b6a75a4441ea631?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Max Moiseev</string> &lt;moiseev at apple.com&gt;<p>August 31, 2016 at 11:00:00am</p></header><div class="content"><p>Right… Good catch!<br></p><p>&gt; On Aug 31, 2016, at 9:45 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Max Moiseev wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, the ‘classical’ way of doing what I think you’re trying to do is:<br>&gt;&gt; <br>&gt;&gt; extension Sequence {<br>&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>&gt;&gt;   return AnySequence(zip(self, self.dropFirst()))<br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Does it have the right behavior?<br>&gt; <br>&gt; It doesn&#39;t if the sequence is single-pass or if iterating over it multiple times has other unwanted side-effects.<br>&gt; <br>&gt; — Pyry<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September  1, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Aug 30 2016, Max Moiseev &lt;moiseev-AT-apple.com&gt; wrote:<br></p><p>&gt; FWIW, the ‘classical’ way of doing what I think you’re trying to do is:<br>&gt;<br>&gt; extension Sequence {<br>&gt;   var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>&gt;     return AnySequence(zip(self, self.dropFirst()))<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; Does it have the right behavior?<br></p><p>Cute, but that one requires that self is a collection (depends on<br>multipass behavior)<br></p><p>&gt;<br>&gt; Max<br>&gt;<br>&gt;&gt; On Aug 29, 2016, at 9:45 AM, Tim Vermeulen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The intent of my function wasn’t very clear, but it was supposed to<br>&gt;&gt; return a sequence that contains *all* consecutive pairs, i.e. (0 ..&lt;<br>&gt;&gt; 4).pairs would result in [(0, 1), (1, 2), (2, 3)].<br>&gt;&gt; <br>&gt;&gt;&gt; on Fri Aug 26 2016, Tim Vermeulen&lt;swift-evolution at swift.org&gt;wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is when I first wanted to pass an optional for the `first` parameter:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt;&gt;&gt;&gt; /// of the sequence, in order.<br>&gt;&gt;&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt;&gt;&gt;&gt; var iterator = makeIterator()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let firstPair = iterator.next().flatMap { first in<br>&gt;&gt;&gt;&gt; iterator.next().map { second in (first, second) }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // I can&#39;t do this, because `firstPair` is optional<br>&gt;&gt;&gt;&gt; let seq = sequence(first: firstPair) { _, second in<br>&gt;&gt;&gt;&gt; guard let next = iterator.next() else { return nil }<br>&gt;&gt;&gt;&gt; return (second, next)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; return AnySequence(seq)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this particular case, finding a workaround is fairly easy (with a<br>&gt;&gt;&gt;&gt; guard and `return AnySequence([])` in the `else` block). However, this<br>&gt;&gt;&gt;&gt; becomes less elegant if you just want to iterate over it rather than<br>&gt;&gt;&gt;&gt; wrap it in AnySequence.<br>&gt;&gt;&gt; This is why we have sequence(state:next:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Sequence {<br>&gt;&gt;&gt; /// Returns a sequence of pairs of consecutive elements<br>&gt;&gt;&gt; /// of the sequence, in order.<br>&gt;&gt;&gt; var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt;{<br>&gt;&gt;&gt; return AnySequence(<br>&gt;&gt;&gt; sequence(<br>&gt;&gt;&gt; state: makeIterator(),<br>&gt;&gt;&gt; next: { (iter: inout Iterator) in<br>&gt;&gt;&gt; iter.next().flatMap { first in<br>&gt;&gt;&gt; iter.next().map { (first, $0) }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; })<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for j in 0..&lt;10 {<br>&gt;&gt;&gt; print(Array((0..&lt;j).pairs))<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; HTH,<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After having a quick conversation with Dave, here is the question I<br>&gt;&gt;&gt;&gt;&gt; should have asked right away: can you share the typical problem you<br>&gt;&gt;&gt;&gt;&gt; are solving with your overload of the `sequence(first:next:)`<br>&gt;&gt;&gt;&gt;&gt; function?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Aug 20, 2016, at 2:26 AM, Tim<br>&gt;&gt;&gt;&gt;&gt;&gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; What you’re saying makes sense, and I might not have brought this<br>&gt;&gt;&gt;&gt;&gt;&gt; up in the first place if `first.map { sequence(first: $0, next:<br>&gt;&gt;&gt;&gt;&gt;&gt; next } ?? []` worked. The main annoyance is that the best solution<br>&gt;&gt;&gt;&gt;&gt;&gt; (currently) seems to be to copy the source code and make a change.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; (cc-ing Jordan Rose because of a related swift-users thread) This<br>&gt;&gt;&gt;&gt;&gt;&gt; might be a bit of a stretch, but can’t Swift upcast sequences to<br>&gt;&gt;&gt;&gt;&gt;&gt; AnySequence implicitly, like is done with AnyHashable? That would<br>&gt;&gt;&gt;&gt;&gt;&gt; make `first.map { sequence(first: $0, next: next } ?? []`<br>&gt;&gt;&gt;&gt;&gt;&gt; instantly valid, I think. There’s also something to be said for<br>&gt;&gt;&gt;&gt;&gt;&gt; consistency between type erasers. (I’m not necessarily talking<br>&gt;&gt;&gt;&gt;&gt;&gt; about Swift 3)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 20 Aug 2016, at 02:22, Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I still believe that having 2 termination conditions is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrong. But I guess we need a tie breaker here, someone with a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; strong opinion about the problem.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As Kevin mentioned we are very late in the release process, so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; waiting for another opinion for a day or two won’t change<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; anything, really.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; conformance to the `UnfoldSequence`, this snippet will compile<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; just fine. One downside is that the `ExpressibleByArrayLiteral`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol allows creating non-empty sequences as well, which does<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; not make sense for the `UnfoldSequence`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 19:48, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; AFAIK this issue has never been discussed with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) before. It certainly wasn&#39;t brought up<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; during review.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As for my opinion, I&#39;m really not sure. I was going to point<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out that right now sequence(first:next:) guarantees that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; first element of the resulting sequence is the value<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; provided as &quot;first&quot;, but it occurs to me that if you treat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the nil result from next() as an element, then this still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; holds true. So I guess my biggest worry is this change will<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it harder to use sequence(first:next:) to produce<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences of optional values.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think producing sequences of optional values would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; really be a problem, because type inference will figure this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; out based on whether you treat the argument to the `next`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; closure as an optional or not. And if you only do things in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `next` that work both with optionals and non-optionals (very<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unlikely), you can always manually specify the type of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Do you remember the problem of non-emptiness being<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; discussed before? And if not, what’s your opinion on the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; proposed change?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 19, 2016, at 7:53 AM, Tim<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Max, thanks for having a look.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; A big part of why I’m not really happy with the current<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation is that the function always produces a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nonempty sequence, though the compiler doesn’t know<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; it. `sequence(first: first, next: next).last` returns an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; optional, even though it can’t possibly be nil. The same<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; goes for something like `sequence(first: 5, next: { $0 *<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3 }).first(where: { $0&gt;1000 })`, because the sequence is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; infinite, which means `first(while:)` will either keep<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; running forever, or return a non-optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt;T?)—returns any sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T?)—returns a nonempty sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T)—returns an infinite sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Default implementations for methods on sequences would<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; either return optionals or non-optionals depending on<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their emptiness/finiteness. We just have the first kind<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of sequence right now, so in that regard it would make<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sense to also give `sequence(first:next)` the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; corresponding signature.Later, when the language /<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; standard library supports the other two kinds of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences (if that ever happens), the other versions<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; could be added.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another reason that makes me think that the version that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; accepts an optional `first` argument is more natural, is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the fact that the function body doesn’t need to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; changed at all. It supports optional seeds by design;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; only the signature prevents it.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I know these arguments might not be very convincing, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I feel like Swift misses an opportunity if it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; unnecessarily constrains the `first` parameter to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-optional. The `.lazy.flatMap({ $0 })` alternative<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that you pointed out does work, but it makes everything<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; very unreadable: not just the `.lazy.flatMap({ $0 })`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; part, but also the body of the `next` parameter because<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; you’re now dealing with optionals (i.e. you have to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `flatMap` over the closure argument). The best solution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’ve come up with is to copy the `sequence(first:next)`<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; implementation from the source code and change the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; signature. :-/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `sequence(state:next:)` isn’t very appropriate for this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; task either, because naive usage with an optional seed<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; has the downside of being unnecessarily eager just like<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a naive `sequence(first:next)` implementation (as<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; described in a comment in the source code).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 19 Aug 2016, at 00:18, Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi Tim,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for bringing this up.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here are my thoughts on the change you’re proposing.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt;T?) -&gt;UnfoldFirstSequence&lt;T&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me the type of the function as it is tells a clear<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; story of what’s going to happen: take the `first`,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; make it a head of the resulting sequence, and then try<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to produce the tail by a series of applications of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; `next`. The only thing that controls when the sequence<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; generation terminates is the result of `next`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If we change the type of `first` to an Optional&lt;T&gt;, it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would make the termination condition<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; non-trivial. After all, the only thing it would do is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; try to unwrap the `first`, before doing what it needs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to, but we already have a `map` for that. One should<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; be able to simply do the `first.map { sequence(first:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; $0, next: next) } ?? []` but that won’t work with the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types very well, unfortunately.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As an alternative, `let first: Int? = ...;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first: first, next: next).flatMap({$0})` (or<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; even `.lazy.flatMap({$0})`) will do the right thing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; without making an API more complex.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I see the point of `sequence(first:next:)` to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; precisely the &quot;generate the non-empty sequence using a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; seed and a simple producer&quot;, for anything more than<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that, there is `sequence(state:next:)`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Max<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(first:next:) takes a non-optional first<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument. Is there a reason for that?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence(state:next:) allows empty sequences, and I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; don’t see why sequence(first:next:) shouldn’t. The<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fix would be to simply add the `?` in the function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; signature; no other changes are required to make it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; work.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution-m3FHrko0VLw at public.gmane.orgg)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
