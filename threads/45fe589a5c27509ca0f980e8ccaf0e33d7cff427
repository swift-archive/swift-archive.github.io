<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 08:00:00pm</p></header><div class="content"><p>I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomStringProjectable` respectively<br></p><p>I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;.<br></p><p>Thanks,<br>Matthew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/45fef427/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27cba2e668c6c6fb1f1d4669b1474397?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Arthur Ariel Sabintsev</string> &lt;arthur at sabintsev.com&gt;<p>December 12, 2015 at 10:00:00pm</p></header><div class="content"><p>&quot;The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomStringProjectable` respectively”<br></p><p>I think the second CustomStringProjectable was meant to be CustomDebugStringProjectable.<br></p><p>+1 to this change as it further builds upon the protocol naming conventions that were standardized in Swift 2.0.  <br></p><p>Best,<br></p><p>Arthur / Sabintsev.com<br></p><p>On December 12, 2015 at 9:40:32 PM, Matthew Johnson via swift-evolution (swift-evolution at swift.org) wrote:<br></p><p>CustomStringProjectable<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/66786dd1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 12, 2015 at 09:00:00pm</p></header><div class="content"><p>Yes Arthur, you are correct.  That was a copy / paste error.  The second should have been `CustomDebugStringProjectable`.<br></p><p>I’m glad you like the proposal!<br></p><p><br>&gt; On Dec 12, 2015, at 9:28 PM, Arthur Sabintsev &lt;arthur at sabintsev.com&gt; wrote:<br>&gt; <br>&gt; &quot;The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomStringProjectable` respectively”<br>&gt; <br>&gt; I think the second CustomStringProjectable was meant to be CustomDebugStringProjectable.<br>&gt; <br>&gt; +1 to this change as it further builds upon the protocol naming conventions that were standardized in Swift 2.0.  <br>&gt; <br>&gt; Best,<br>&gt; <br>&gt; Arthur / Sabintsev.com &lt;http://sabintsev.com/&gt;<br>&gt; On December 12, 2015 at 9:40:32 PM, Matthew Johnson via swift-evolution (swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;) wrote:<br>&gt; <br>&gt;&gt; CustomStringProjectable<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/374db2eb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>Bumping this thread.  There wasn’t much response to the initial post, which may have been because Saturday night is probably not the best time to post a proposal.  :)<br></p><p>You can find the draft here: https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;<br></p><p>The little feedback I did receive was positive.<br></p><p>Matthew<br></p><p>&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomDebugStringProjectable` respectively<br>&gt; <br>&gt; I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;.<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/6bf22e5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>And adding:<br></p><p>I *hate* Convertible in its current form. Per your current write-up, the protocols should cover initialized from, converted to, and a mix. Let me suggest:<br></p><p>* can be initialized from: Instantiable, Initializable<br>* can be converted to: Expressible, Presentable, Projectable<br>* can be represented as and instantiated by: Convertible<br></p><p>For example, IntegerLiteralInitializable, CustomStringRepresentationExpressible, and DoubleTypeConvertible.<br></p><p>-- Erica<br></p><p><br>&gt; On Dec 15, 2015, at 9:28 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Bumping this thread.  There wasn’t much response to the initial post, which may have been because Saturday night is probably not the best time to post a proposal.  :)<br>&gt; <br>&gt; You can find the draft here: https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;<br>&gt; <br>&gt; The little feedback I did receive was positive.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomDebugStringProjectable` respectively<br>&gt;&gt; <br>&gt;&gt; I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/675a399f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>Thanks for your input Erica!  I would be happy with any convention that establishes clarity and consistency.<br></p><p>I wrote the proposal the way I did as it is the minimum change from current state that would establish clarity and consistency.  My rationale was the smaller the change, the greater the chance of acceptance.<br></p><p>It would be great to hear whether the community would prefer minimal change or wants to make a larger change if a better end result is possible that way.<br></p><p>Matthew<br></p><p>&gt; On Dec 15, 2015, at 11:39 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; And adding:<br>&gt; <br>&gt; I *hate* Convertible in its current form. Per your current write-up, the protocols should cover initialized from, converted to, and a mix. Let me suggest:<br>&gt; <br>&gt; * can be initialized from: Instantiable, Initializable<br>&gt; * can be converted to: Expressible, Presentable, Projectable<br>&gt; * can be represented as and instantiated by: Convertible<br>&gt; <br>&gt; For example, IntegerLiteralInitializable, CustomStringRepresentationExpressible, and DoubleTypeConvertible.<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 9:28 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Bumping this thread.  There wasn’t much response to the initial post, which may have been because Saturday night is probably not the best time to post a proposal.  :)<br>&gt;&gt; <br>&gt;&gt; You can find the draft here: https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;<br>&gt;&gt; <br>&gt;&gt; The little feedback I did receive was positive.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomDebugStringProjectable` respectively<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/91b4068e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 10:00:00am</p></header><div class="content"><p>The great advantage of basic renaming is that migration is super-simple. And now that I think about it, CustomStringRepresentable is probably a lot better than CustomStringRepresentationExpressible<br></p><p>It&#39;s easy enough to take some time, throw some options out there, and come up with names that better represent the concepts in question (the big win of your proposal) and then vote for the best.<br></p><p>-- E<br>p.s. Does anyone ever actually use debugString stuff? I love it in concept but I find that I use it about 0% of the time<br></p><p><br>&gt; On Dec 15, 2015, at 10:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks for your input Erica!  I would be happy with any convention that establishes clarity and consistency.<br>&gt; <br>&gt; I wrote the proposal the way I did as it is the minimum change from current state that would establish clarity and consistency.  My rationale was the smaller the change, the greater the chance of acceptance.<br>&gt; <br>&gt; It would be great to hear whether the community would prefer minimal change or wants to make a larger change if a better end result is possible that way.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 11:39 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; And adding:<br>&gt;&gt; <br>&gt;&gt; I *hate* Convertible in its current form. Per your current write-up, the protocols should cover initialized from, converted to, and a mix. Let me suggest:<br>&gt;&gt; <br>&gt;&gt; * can be initialized from: Instantiable, Initializable<br>&gt;&gt; * can be converted to: Expressible, Presentable, Projectable<br>&gt;&gt; * can be represented as and instantiated by: Convertible<br>&gt;&gt; <br>&gt;&gt; For example, IntegerLiteralInitializable, CustomStringRepresentationExpressible, and DoubleTypeConvertible.<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 9:28 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Bumping this thread.  There wasn’t much response to the initial post, which may have been because Saturday night is probably not the best time to post a proposal.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can find the draft here: https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The little feedback I did receive was positive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomDebugStringProjectable` respectively<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/00d649d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; p.s. Does anyone ever actually use debugString stuff? I love it in<br>concept but I find that I use it about 0% of the time<br>Composite types (array, optional, ...) display debugString output<br></p><p>On Tue, Dec 15, 2015 at 20:59 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The great advantage of basic renaming is that migration is super-simple.<br>&gt; And now that I think about it, CustomStringRepresentable is probably a<br>&gt; lot better than CustomStringRepresentationExpressible<br>&gt;<br>&gt; It&#39;s easy enough to take some time, throw some options out there, and come<br>&gt; up with names that better represent the concepts in question (the big win<br>&gt; of your proposal) and then vote for the best.<br>&gt;<br>&gt; -- E<br>&gt; p.s. Does anyone ever actually use debugString stuff? I love it in concept<br>&gt; but I find that I use it about 0% of the time<br>&gt;<br>&gt;<br>&gt; On Dec 15, 2015, at 10:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Thanks for your input Erica!  I would be happy with any convention that<br>&gt; establishes clarity and consistency.<br>&gt;<br>&gt; I wrote the proposal the way I did as it is the minimum change from<br>&gt; current state that would establish clarity and consistency.  My rationale<br>&gt; was the smaller the change, the greater the chance of acceptance.<br>&gt;<br>&gt; It would be great to hear whether the community would prefer minimal<br>&gt; change or wants to make a larger change if a better end result is possible<br>&gt; that way.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Dec 15, 2015, at 11:39 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; And adding:<br>&gt;<br>&gt; I *hate* Convertible in its current form. Per your current write-up, the<br>&gt; protocols should cover initialized from, converted to, and a mix. Let me<br>&gt; suggest:<br>&gt;<br>&gt; * can be initialized from: Instantiable, Initializable<br>&gt; * can be converted to: Expressible, Presentable, Projectable<br>&gt; * can be represented as and instantiated by: Convertible<br>&gt;<br>&gt; For example, IntegerLiteralInitializable,<br>&gt; CustomStringRepresentationExpressible, and DoubleTypeConvertible.<br>&gt;<br>&gt; -- Erica<br>&gt;<br>&gt;<br>&gt; On Dec 15, 2015, at 9:28 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Bumping this thread.  There wasn’t much response to the initial post,<br>&gt; which may have been because Saturday night is probably not the best time to<br>&gt; post a proposal.  :)<br>&gt;<br>&gt; You can find the draft here:<br>&gt; https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md<br>&gt;<br>&gt; The little feedback I did receive was positive.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I have drafted a proposal to establish precise conventional meaning for<br>&gt; the use of `Convertible`, `Representable`, and `Projectable` protocol<br>&gt; suffixes.  The proposal would require renaming `CustomStringConvertible`<br>&gt; and `CustomDebugStringConvertible` to `CustomStringProjectable`<br>&gt; and `CustomDebugStringProjectable` respectively<br>&gt;<br>&gt; I am seeking input on the proposal before submitting a PR.  The full draft<br>&gt; can found at<br>&gt; https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md<br>&gt; .<br>&gt;<br>&gt; Thanks,<br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/8d01cd98/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; It&#39;s easy enough to take some time, throw some options out there, and come up with names that better represent the concepts in question (the big win of your proposal) and then vote for the best.<br></p><p>Sure, that sounds like a great idea to me as long as the core team is willing to consider a larger scale change to existing names (primarily all the *LiteralConvertible protocols).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; The great advantage of basic renaming is that migration is super-simple.<br></p><p>Renaming is simple but communicating and re-educating everyone using Swift is somewhat less so.  I don&#39;t mind it but imagine some would and some will argue against a larger change on that basis.  Personally, I would like it if we go with the best names we can come up with so I do nudge in this direction.<br></p><p><br>&gt; And now that I think about it, CustomStringRepresentable is probably a lot better than CustomStringRepresentationExpressible<br></p><p>Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br></p><p>Matthew<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/99f42667/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 11:15 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The great advantage of basic renaming is that migration is super-simple.<br>&gt; <br>&gt; Renaming is simple but communicating and re-educating everyone using Swift is somewhat less so.  I don&#39;t mind it but imagine some would and some will argue against a larger change on that basis.  Personally, I would like it if we go with the best names we can come up with so I do nudge in this direction.<br></p><p>There is ample precedent however. If memory serves: the printable protocol, the playground quicklook one, etc<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 11:15 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; And now that I think about it, CustomStringRepresentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt; <br>&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; <br></p><p>Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br></p><p>-- Erica<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/1a5967e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt; <br>&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt; <br>&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br></p><p>I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br></p><p>So I suggest:<br></p><p>	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>	<br>	protocol RawRepresentable {…}<br>	<br>	protocol CustomStringConvertible {…}<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br></p><p>&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt; <br>&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt; <br>&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt; <br>&gt; So I suggest:<br>&gt; <br>&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt; 	<br>&gt; 	protocol RawRepresentable {…}<br>&gt; 	<br>&gt; 	protocol CustomStringConvertible {…}<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>Terms currently on the table:<br>can be initialized from: Instantiable, Initializable, Establishable<br>can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>can be converted to: Representable, Expressible, Presentable, Projectable<br>can be represented as and instantiated by: Convertible, Representable<br></p><p>I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br></p><p>To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br></p><p>To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br></p><p>The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br></p><p>I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br></p><p>Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br></p><p>Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>LogicValue became BooleanType<br>Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br></p><p>-- Erica<br></p><p><br>&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt; <br>&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt; <br>&gt;&gt; So I suggest:<br>&gt;&gt; <br>&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt; 	<br>&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt; 	<br>&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/9f26ca2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 08:00:00pm</p></header><div class="content"><p>Thank you for taking the time to put together this summary and analysis Erica!  <br></p><p>In thinking about this further I am not convinced that separating the initializer and factory method variants into separate conventions is a good idea.  If we do that it would raise a question as to whether we should also have variations of the bidirectional protocol for both initializers and factory methods and I think that is going to far.  So I am currently leaning towards sticking with three conventions.<br></p><p>If we do that I definitely lean towards Creatable.  While initializers do not create an instance directly an instance is created every time they are used (leaving failable and throwing initializers aside for sake of discussion).  Calling an initializer does “produce something new and cause it to exist”.  It seems appropriate to me.  An alternative might be Constructible, however that doesn’t seem appropriate in Swift as it implicitly references “constructor” in a programming context.<br></p><p>BTW, the factory method case seems especially important to consider in the context of the problems with retroactively conforming classes in Foundation and other Apple frameworks to protocols which include object instantiation.  It isn’t clear yet how that problem will be solved and it is possible that we may see a solution that works for factory methods sooner than (or in lieu of) a solution that works for initializers.  The factory method case is potentially more tractable because the return type is specified in the function declaration rather than being implicit.<br></p><p>Matthew<br></p><p><br>&gt; On Dec 15, 2015, at 6:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Terms currently on the table:<br>&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt; <br>&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt; <br>&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt; <br>&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt; <br>&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt; <br>&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt; <br>&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt; <br>&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt; LogicValue became BooleanType<br>&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/01d4ad32/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December 15, 2015 at 08:00:00pm</p></header><div class="content"><p>For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br></p><p>For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br></p><p>Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br></p><p>-DW<br></p><p><br>&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Terms currently on the table:<br>&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt; <br>&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt; <br>&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt; <br>&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt; <br>&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt; <br>&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt; <br>&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt; <br>&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt; LogicValue became BooleanType<br>&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt; <br>&gt; -- Erica<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/d149f5e8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br></p><p>I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br></p><p>I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br></p><p>It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br></p><p>&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br></p><p>I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br></p><p>&gt; <br>&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Terms currently on the table:<br>&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt; <br>&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt; <br>&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt; <br>&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt; <br>&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt; <br>&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt; <br>&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt; LogicValue became BooleanType<br>&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt; <br>&gt;&gt; -- Erica<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/ca648d7b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 08:00:00pm</p></header><div class="content"><p>I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br></p><p>This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br></p><p>-- E, who thinks you&#39;re in good shape to move forward either way<br></p><p><br>&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt; <br>&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt; <br>&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt; <br>&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt; <br>&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt; <br>&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/2248e83c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00am</p></header><div class="content"><p>It would be helpful if someone from the core team can comment on whether you would prefer:<br></p><p>1. A bug report (unlikely as it changes public API)<br>2. The current proposal with minimal changes to current state<br>3. A proposal with larger changes containing the names preferred by the authors without regard for current state<br>4. A proposal with several options to be considered and selected from during review.<br></p><p>I will update my PR accordingly.<br></p><p>Thanks,<br>Matthew<br></p><p>&gt; On Dec 15, 2015, at 9:46 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br>&gt; <br>&gt; This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br>&gt; <br>&gt; -- E, who thinks you&#39;re in good shape to move forward either way<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt;&gt; <br>&gt;&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt;&gt; <br>&gt;&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt;&gt; <br>&gt;&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt;&gt; <br>&gt;&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt;&gt; <br>&gt;&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/c9dabfab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Requesting a team ruling on the next step, please Re: Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 16, 2015 at 08:00:00am</p></header><div class="content"><p>Thank you<br></p><p>&gt; On Dec 16, 2015, at 8:20 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; It would be helpful if someone from the core team can comment on whether you would prefer:<br>&gt; <br>&gt; 1. A bug report (unlikely as it changes public API)<br>&gt; 2. The current proposal with minimal changes to current state<br>&gt; 3. A proposal with larger changes containing the names preferred by the authors without regard for current state<br>&gt; 4. A proposal with several options to be considered and selected from during review.<br>&gt; <br>&gt; I will update my PR accordingly.<br>&gt; <br>&gt; Thanks,<br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 9:46 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br>&gt;&gt; <br>&gt;&gt; This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br>&gt;&gt; <br>&gt;&gt; -- E, who thinks you&#39;re in good shape to move forward either way<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/338f385e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Requesting a team ruling on the next step, please Re: Proposal: conversion protocol naming conventions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 08:00:00am</p></header><div class="content"><p>Hi Erica, Matthew, et. al.<br></p><p>I&#39;ve been watching this discussion with interest; thank you for initiating it—but I&#39;ve just returned from vacation to over 6K (!) new emails and haven&#39;t had time to dive into this yet.  <br></p><p>As noted below, it&#39;s an API change so, a formal proposals will be needed, though I&#39;m not sure I understand the distinctions between 2, 3, and 4 below.   I think the eventual proposal should for changes that enshrine these patterns in the API guidelines, and as a consequence applies the new guidelines to the standard library.<br></p><p>However, I think the standard library team probably ought to weigh in on the specifics before we move on to next steps.  At a high level, I like the direction of this proposal; it addresses a real naming issue that had escaped my notice.  I&#39;ll try to respond with specifics this afternoon, after I&#39;ve had a chance to read through it in detail and after a meeting of the team that has been developing the API guidelines.<br></p><p>Thanks again for your efforts and your patience,<br>Dave<br></p><p>&gt; On Dec 16, 2015, at 7:55 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thank you<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 8:20 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It would be helpful if someone from the core team can comment on whether you would prefer:<br>&gt;&gt; <br>&gt;&gt; 1. A bug report (unlikely as it changes public API)<br>&gt;&gt; 2. The current proposal with minimal changes to current state<br>&gt;&gt; 3. A proposal with larger changes containing the names preferred by the authors without regard for current state<br>&gt;&gt; 4. A proposal with several options to be considered and selected from during review.<br>&gt;&gt; <br>&gt;&gt; I will update my PR accordingly.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 9:46 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E, who thinks you&#39;re in good shape to move forward either way<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt;&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt;&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt;&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt;&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt;&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/69417d82/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Requesting a team ruling on the next step, please Re: Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 10:00:00am</p></header><div class="content"><p>Thanks Dave, I appreciate the feedback and am happy to hear that you would like to solve the problem it addresses.<br></p><p>The proposal itself is somewhat out of date at this point so please be sure to catch up on the discussion in this thread when catching up.<br></p><p>And take your time.  There is certainly no rush on this, we just wanted to know how we should proceed.  Waiting for the API guideline team to discuss is a very reasonable answer!<br></p><p>Matthew<br></p><p><br>&gt; On Dec 16, 2015, at 10:36 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Erica, Matthew, et. al.<br>&gt; <br>&gt; I&#39;ve been watching this discussion with interest; thank you for initiating it—but I&#39;ve just returned from vacation to over 6K (!) new emails and haven&#39;t had time to dive into this yet.  <br>&gt; <br>&gt; As noted below, it&#39;s an API change so, a formal proposals will be needed, though I&#39;m not sure I understand the distinctions between 2, 3, and 4 below.   I think the eventual proposal should for changes that enshrine these patterns in the API guidelines, and as a consequence applies the new guidelines to the standard library.<br>&gt; <br>&gt; However, I think the standard library team probably ought to weigh in on the specifics before we move on to next steps.  At a high level, I like the direction of this proposal; it addresses a real naming issue that had escaped my notice.  I&#39;ll try to respond with specifics this afternoon, after I&#39;ve had a chance to read through it in detail and after a meeting of the team that has been developing the API guidelines.<br>&gt; <br>&gt; Thanks again for your efforts and your patience,<br>&gt; Dave<br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 7:55 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thank you<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 8:20 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be helpful if someone from the core team can comment on whether you would prefer:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. A bug report (unlikely as it changes public API)<br>&gt;&gt;&gt; 2. The current proposal with minimal changes to current state<br>&gt;&gt;&gt; 3. A proposal with larger changes containing the names preferred by the authors without regard for current state<br>&gt;&gt;&gt; 4. A proposal with several options to be considered and selected from during review.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I will update my PR accordingly.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 9:46 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- E, who thinks you&#39;re in good shape to move forward either way<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a04f6cd8/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Requesting a team ruling on the next step, please Re: Proposal: conversion protocol naming conventions</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 16, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 16, 2015, at 8:47 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Thanks Dave, I appreciate the feedback and am happy to hear that you would like to solve the problem it addresses.<br>&gt; <br>&gt; The proposal itself is somewhat out of date at this point so please be sure to catch up on the discussion in this thread when catching up.<br></p><p>In that case it would be very helpful if you&#39;d update the proposal with whatever you consider to be the best answer to date.<br></p><p>&gt; And take your time.  There is certainly no rush on this, we just wanted to know how we should proceed.  Waiting for the API guideline team to discuss is a very reasonable answer!<br></p><p>Thanks again,<br>Dave<br></p><p>&gt; Matthew<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 16, 2015, at 10:36 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Erica, Matthew, et. al.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve been watching this discussion with interest; thank you for initiating it—but I&#39;ve just returned from vacation to over 6K (!) new emails and haven&#39;t had time to dive into this yet.  <br>&gt;&gt; <br>&gt;&gt; As noted below, it&#39;s an API change so, a formal proposals will be needed, though I&#39;m not sure I understand the distinctions between 2, 3, and 4 below.   I think the eventual proposal should for changes that enshrine these patterns in the API guidelines, and as a consequence applies the new guidelines to the standard library.<br>&gt;&gt; <br>&gt;&gt; However, I think the standard library team probably ought to weigh in on the specifics before we move on to next steps.  At a high level, I like the direction of this proposal; it addresses a real naming issue that had escaped my notice.  I&#39;ll try to respond with specifics this afternoon, after I&#39;ve had a chance to read through it in detail and after a meeting of the team that has been developing the API guidelines.<br>&gt;&gt; <br>&gt;&gt; Thanks again for your efforts and your patience,<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 7:55 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 8:20 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would be helpful if someone from the core team can comment on whether you would prefer:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. A bug report (unlikely as it changes public API)<br>&gt;&gt;&gt;&gt; 2. The current proposal with minimal changes to current state<br>&gt;&gt;&gt;&gt; 3. A proposal with larger changes containing the names preferred by the authors without regard for current state<br>&gt;&gt;&gt;&gt; 4. A proposal with several options to be considered and selected from during review.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I will update my PR accordingly.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 9:46 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- E, who thinks you&#39;re in good shape to move forward either way<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/a2f1b585/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Requesting a team ruling on the next step, please Re: Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; In that case it would be very helpful if you&#39;d update the proposal with whatever you consider to be the best answer to date.<br></p><p>Yes, of course. :)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/831942ae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Requesting a team ruling on the next step, please Re: Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 16, 2015 at 09:00:00pm</p></header><div class="content"><p>An updated draft of this proposal is available at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;<br></p><p><br></p><p>&gt; On Dec 16, 2015, at 10:53 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 16, 2015, at 8:47 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks Dave, I appreciate the feedback and am happy to hear that you would like to solve the problem it addresses.<br>&gt;&gt; <br>&gt;&gt; The proposal itself is somewhat out of date at this point so please be sure to catch up on the discussion in this thread when catching up.<br>&gt; <br>&gt; In that case it would be very helpful if you&#39;d update the proposal with whatever you consider to be the best answer to date.<br>&gt; <br>&gt;&gt; And take your time.  There is certainly no rush on this, we just wanted to know how we should proceed.  Waiting for the API guideline team to discuss is a very reasonable answer!<br>&gt; <br>&gt; Thanks again,<br>&gt; Dave<br>&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 16, 2015, at 10:36 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Erica, Matthew, et. al.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve been watching this discussion with interest; thank you for initiating it—but I&#39;ve just returned from vacation to over 6K (!) new emails and haven&#39;t had time to dive into this yet.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As noted below, it&#39;s an API change so, a formal proposals will be needed, though I&#39;m not sure I understand the distinctions between 2, 3, and 4 below.   I think the eventual proposal should for changes that enshrine these patterns in the API guidelines, and as a consequence applies the new guidelines to the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, I think the standard library team probably ought to weigh in on the specifics before we move on to next steps.  At a high level, I like the direction of this proposal; it addresses a real naming issue that had escaped my notice.  I&#39;ll try to respond with specifics this afternoon, after I&#39;ve had a chance to read through it in detail and after a meeting of the team that has been developing the API guidelines.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks again for your efforts and your patience,<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 16, 2015, at 7:55 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 16, 2015, at 8:20 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be helpful if someone from the core team can comment on whether you would prefer:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. A bug report (unlikely as it changes public API)<br>&gt;&gt;&gt;&gt;&gt; 2. The current proposal with minimal changes to current state<br>&gt;&gt;&gt;&gt;&gt; 3. A proposal with larger changes containing the names preferred by the authors without regard for current state<br>&gt;&gt;&gt;&gt;&gt; 4. A proposal with several options to be considered and selected from during review.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I will update my PR accordingly.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 9:46 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I suggest you run this by team members to see if they want this as a bug report or a formal proposal. Either way, I suggest you offer the Swift.team a bunch of names in the order you prefer for the three cases (glomming together factory/init) without having to settle on any of them specifically.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This is kind of a no-brainer implementation-wise and I think offering better names for common protocol patterns is a big win for long-term language coherence. Swift.central has a history of improving names and I suspect there&#39;s at least one or two members who drove those efforts.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- E, who thinks you&#39;re in good shape to move forward either way<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 8:34 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For &quot;build via factory method&quot;, why not Factory or Manufacturer?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don’t think that accurately portrays this case.  The Factory and Factory Method patterns are quite different.  We are talking about factory methods that create instances of the conforming type itself with a parameter of the type described by the protocol.  We are not discussing a type that is a factory producing instances of other types.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It is probably better to form protocol naming conventions around the high level purpose of the protocol and not how that purpose is fulfilled by the protocol.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; For &quot;can be converted to&quot;, I can understand wanting to stay away from Convertible - but we should avoid it for round-trip conversions as well. To convert is the action of changing from one form to another (water into wine), without regards to changing back. Convertible is a property, and thus often means you are able to change from one form to another repeatedly. But there are edge cases for both conditions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I am definitely not in love with Convertible.  It does seem to have a lot of potential for confusion exhibited by its use for different senses in the standard library.  Do you have any suggestions of this?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Converters to string form are difficult as there is a certain amount of presentation. An NSDate needs to understand a locale, a floating point number or currency may have desired display rules beyond a locale. This is I suspect why there is a CustomDebugStringConvertible variant that possibly exposes more/different info.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Terms currently on the table:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be initialized from: Instantiable, Initializable, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can build via factory method: Creatable, Building, Producer/Producing, Establishable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be converted to: Representable, Expressible, Presentable, Projectable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can be represented as and instantiated by: Convertible, Representable<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to courteously disagree with Brent (&quot;I actually think `Representable` better implies two-way than `Convertible` does&quot;). Here&#39;s my reasoning. Convertible implies a commutative or two-way relation. For example, a convertible car can be converted to a sedan style or an open style. A convertible sofa can act as a bed or a sofa. Convertible suggests a R b as well as b R a. The word means to change into a different form and be used in a different way. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To represent means to serve as or to take the place of by accruing characteristics or qualities. This suggests that a R b is not the same as b R a. My lawyer can represent my legal interests but I cannot represent my lawyer in court. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To create means to produce something new and cause it to exist. This is semantically distant from initializing. The current (badly named) IntegerLiteralConvertible means &quot;a conforming construct can use an integer literal to establish an instance of itself&quot;. There are, as Matthew points out two tasks that might arise through protocols: the creation of an instance through a factory method and the creation an instance by passing a separate type to an initializer.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The latter case is what we see throughout and commonly in the current Swift standard library: A.init(b) -&gt; a. Of the words that have been brought up so far, to instantiate and to initialize are the only two that describe this task. I do not believe this is well described  as conversion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I assume the factory style is A.staticMethod(...) -&gt; a. In such case, I&#39;ve collected your suggestions plus a few others above.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Of these, I most prefer initializable (DoubleLiteralInitializable), convertible (RawConvertible, StringLiteralConvertible), and representable (CustomStringRepresentable). I have no particular feelings about factory methods at this time.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Finally, I grabbed the following from a quick search of release notes, just to get a sense that protocol renaming does happen:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; LogicValue became BooleanType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Printable and DebugPrintable became CustomStringConvertible, CustomDebugStringConvertible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ExtensibleCollectionType was folded into RangeReplaceableCollectionType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- Erica<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 4:40 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I really like Creatable for the first as it is general enough to handle initializers an factory methods.  Great idea!  Alternatively, we could use that for a fourth category covering factory methods and stick with Initializable for the first case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 5:30 PM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; resentable is probably a lot better than CustomStringRepresentationExpressible<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Representable is what I would have used if I wasn&#39;t trying to make a minimal change or if RawRepresentable didn&#39;t already use it for bidirectional conversion, so I agree that it is better than both Expressible and Projectable.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let&#39;s run with the idea that everything is up for grabs and that better names will better serve the developer community in the long run. In such a case, if the core naming patterns were established as Convertible for bidirectional conversion, would RawConvertible be such a bad thing?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I actually think `Representable` better implies two-way than `Convertible` does. A representation is a way of expressing something in a different form; a conversion is a specific act of transforming one thing to another. To me, the former sounds more like a round trip than the latter.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So I suggest:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol IntegerLiteralInitializable {...} // or maybe ‘Creatable’, to cover the factory method case?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol RawRepresentable {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	protocol CustomStringConvertible {…}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151216/6fbc7be7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 15, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; I am not convinced that distinct conventions for the initializer case and the factory method case are worthwhile.  They are two mechanisms for taking an instance of one type and getting back an instance of another type.  In a significant sense the use of an initializer or a factory method is an &quot;implementation detail&quot; of the protocol.	<br></p><p>I agree. (The comment suggesting “Creatable” was meant to suggest that “Creatable” might be a better term than “Initializable” because it’s more inclusive, not to suggest that we should use both “Initializable” and “Creatable” in different cases.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 15, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; * can be initialized from: Instantiable, Initializable<br></p><p>It probably makes sense to consider protocols that use factory methods rather than initializers for the &quot;from&quot; case.  Instantiable seems a bit clunky but does make more sense in the context of factory methods.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/e5aa3c3a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>December 15, 2015 at 09:00:00am</p></header><div class="content"><p>There&#39;s something really promising here with respect to initialization and output.<br></p><p>-- E<br></p><p><br>&gt; On Dec 15, 2015, at 9:28 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Bumping this thread.  There wasn’t much response to the initial post, which may have been because Saturday night is probably not the best time to post a proposal.  :)<br>&gt; <br>&gt; You can find the draft here: https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;<br>&gt; <br>&gt; The little feedback I did receive was positive.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomDebugStringProjectable` respectively<br>&gt;&gt; <br>&gt;&gt; I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md &lt;https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md&gt;.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/4f55e44d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f98dc2a5a610100f8528eeeb2ff3c282?s=50"></div><header><strong>Proposal: conversion protocol naming conventions</strong> from <string>Andrew Brown</string> &lt;a.br at me.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>+1 from me.<br>Proposal is &#39;simple&#39; and helps improve the overall clarity of the language.<br>Perhaps add CustomStringProjectable and deprecate CustomStringConvertible in 2.2?<br></p><p>ABR.<br></p><p>&gt; On 15 Dec 2015, at 16:28, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Bumping this thread.  There wasn’t much response to the initial post, which may have been because Saturday night is probably not the best time to post a proposal.  :)<br>&gt; <br>&gt; You can find the draft here: https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md<br>&gt; <br>&gt; The little feedback I did receive was positive.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt;&gt; On Dec 12, 2015, at 8:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have drafted a proposal to establish precise conventional meaning for the use of `Convertible`, `Representable`, and `Projectable` protocol suffixes.  The proposal would require renaming `CustomStringConvertible` and `CustomDebugStringConvertible` to `CustomStringProjectable` and `CustomDebugStringProjectable` respectively<br>&gt;&gt; <br>&gt;&gt; I am seeking input on the proposal before submitting a PR.  The full draft can found at https://github.com/anandabits/swift-evolution/blob/conversion-protocol-conventions/proposals/0000-conversion-protocol-conventions.md.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151215/ac2dc567/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
