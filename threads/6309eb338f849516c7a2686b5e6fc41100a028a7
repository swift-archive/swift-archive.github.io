<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>Fw: Re: Proposal: CustomConvertible protocol</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>December  4, 2015 at 03:00:00pm</p></header><div class="content"><p>I know that, but I couldn?t describe it better. I mean implicit casts are already there and do look the same:<br></p><p>class A {}<br>class B: A {}<br></p><p>let someA: A = B() // this works fine<br></p><p>protocol C {}<br></p><p>class D: C {}<br></p><p>let someC: C = D() // this works fine too<br>Sure it depends on the context, but the implicit cast functionality could be extended on my opinion.<br></p><p>I build a little prototype to be able to automatically cast math expression. It looks something like this:<br></p><p>let someDouble = Double(UInt(0) + Int(1)) // + is overloaded<br></p><p>// sometimes the compiler complains so I need to write this  <br></p><p>let someDouble = Double(UInt(0) + Int(1) as Expression)<br></p><p>// it would look better if we had implicit conversion enabled trough constructors<br>let someDouble: Double = UInt(0) + Int(1)<br></p><p>// or<br>let someDouble: Double = UInt(0) + Int(1) as Expression<br></p><p><br></p><p><br>??<br>Regards Adrian<br></p><p>Am 4. Dezember 2015 bei 15:15:59, Stepan Hruda (stepan.hruda at gmail.com) schrieb:<br></p><p>This is not how *LiteralConvertible protocols work, though. You can only initialize variables with specific literal values recognized by the parser, it never magically casts a type to a different type for you. Similar implicit casts in my opinion confuse whoever reads the code afterwards.<br></p><p>```<br>class SomeConvertible: BooleanLiteralConvertible {<br>? ? typealias BooleanLiteralType = Bool<br>? ? let boolean: Bool<br></p><p>? ? internal required init(booleanLiteral value: SomeConvertible.BooleanLiteralType) {<br>? ? ? ? self.boolean = value<br>? ? }<br>}<br></p><p>func getBoolean() -&gt; Bool {<br>? ? return false<br>}<br></p><p>let validConvertible: SomeConvertible = false<br>// Line below doesn?t compile<br>let invalidConvertible: SomeConvertible = getBoolean()<br>```<br></p><p><br></p><p><br>On Fri, Dec 4, 2015 at 8:51 AM, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br></p><p>We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.<br></p><p>Swift introduced a few Convertible protocols, but it still needs some more If you ask me.<br></p><p>Something like this:<br></p><p>public protocol CustomConvertible {<br>      <br>    typealias CustomType<br>      <br>    public init(value: Self.CustomType) // or in a better way I can&#39;t come up with<br>}<br></p><p>But it should work in a way that we could create more different types like enums and ErrorType.<br></p><p>protocol AConvertible: CustomConvertible { /* some stuff here*/ }<br>protocol BConvertible: CustomConvertible { /* some stuff here*/ }<br></p><p>struct A {<br>    var foo: Int = 0<br>}<br></p><p>struct B {<br>    var boo: String = &quot;Hello World&quot;<br>}<br></p><p>struct C: AConvertible, BConvertible {<br>      <br>    typealias CustomAType = A<br>    typealias CustomBType = B<br>      <br>    var magical: SomeType<br>          <br>    init(value: CustomAType) {<br>        // implement it<br>    }<br>      <br>    init(value: CustomBType) {<br>        // implement it<br>    }<br>}<br></p><p>//===========================<br></p><p>let firstC: C = A() // this is what I&#39;m missing in Swift<br>let secondC: C = B() // this would be a great syntax sugar<br></p><p>What do you think?<br></p><p><br></p><p>??<br>Regards Adrian<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151204/630928a7/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>Proposal: CustomConvertible protocol</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>December  4, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On 4 Dec 2015, at 14:27, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt; <br>&gt; I know that, but I couldn?t describe it better. I mean implicit casts are already there and do look the same:<br>&gt; <br>&gt; class A {}<br>&gt; class B: A {}<br>&gt; <br>&gt; let someA: A = B() // this works fine<br>&gt; <br>&gt; protocol C {}<br>&gt; <br>&gt; class D: C {}<br>&gt; <br>&gt; let someC: C = D() // this works fine too<br></p><p>Neither of these are casts. someA is actually  a reference to the B. someC is a reference to a D (I?m not sure how the mechanism worked for structs conforming to protocols, but there?s still no instance conversion) <br></p><p><br>&gt; <br>&gt; Sure it depends on the context, but the implicit cast functionality could be extended on my opinion. <br>&gt; <br>&gt; I build a little prototype to be able to automatically cast math expression. It looks something like this:<br>&gt; <br>&gt; let someDouble = Double(UInt(0) + Int(1)) // + is overloaded<br>&gt; <br>&gt; // sometimes the compiler complains so I need to write this  <br>&gt; <br>&gt; let someDouble = Double(UInt(0) + Int(1) as Expression)<br>&gt; <br>&gt; // it would look better if we had implicit conversion enabled trough constructors<br>&gt; let someDouble: Double = UInt(0) + Int(1)<br>&gt; <br>&gt; // or<br>&gt; let someDouble: Double = UInt(0) + Int(1) as Expression<br>&gt; <br>&gt; <br></p><p>This used to come up on the Apple lists. A deliberate design decision was taken early on to require explicit conversion for arithmetic types on the grounds that implicit casts are a common source of error. I don?t think any proposal to add them back in is going to get very far.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; ? <br>&gt; Regards Adrian<br>&gt; <br>&gt; Am 4. Dezember 2015 bei 15:15:59, Stepan Hruda (stepan.hruda at gmail.com) schrieb:<br>&gt; <br>&gt;&gt; This is not how *LiteralConvertible protocols work, though. You can only initialize variables with specific literal values recognized by the parser, it never magically casts a type to a different type for you. Similar implicit casts in my opinion confuse whoever reads the code afterwards.<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; class SomeConvertible: BooleanLiteralConvertible {<br>&gt;&gt;     typealias BooleanLiteralType = Bool<br>&gt;&gt;     let boolean: Bool<br>&gt;&gt; <br>&gt;&gt;     internal required init(booleanLiteral value: SomeConvertible.BooleanLiteralType) {<br>&gt;&gt;         self.boolean = value<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func getBoolean() -&gt; Bool {<br>&gt;&gt;     return false<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let validConvertible: SomeConvertible = false<br>&gt;&gt; // Line below doesn?t compile<br>&gt;&gt; let invalidConvertible: SomeConvertible = getBoolean()<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, Dec 4, 2015 at 8:51 AM, Adrian Zubarev &lt;adrian.zubarev at devandartist.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We have finally a corner where people can share their ideas on how Swift can be improved, and I?m glad my ideas might be part of this fun.<br>&gt;&gt; <br>&gt;&gt; Swift introduced a few Convertible protocols, but it still needs some more If you ask me.<br>&gt;&gt; <br>&gt;&gt; Something like this:<br>&gt;&gt; <br>&gt;&gt; public protocol CustomConvertible {<br>&gt;&gt;       <br>&gt;&gt;     typealias CustomType<br>&gt;&gt;       <br>&gt;&gt;     public init(value: Self.CustomType) // or in a better way I can&#39;t come up with<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; But it should work in a way that we could create more different types like enums and ErrorType.<br>&gt;&gt; <br>&gt;&gt; protocol AConvertible: CustomConvertible { /* some stuff here*/ }<br>&gt;&gt; protocol BConvertible: CustomConvertible { /* some stuff here*/ }<br>&gt;&gt; <br>&gt;&gt; struct A {<br>&gt;&gt;     var foo: Int = 0<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct B {<br>&gt;&gt;     var boo: String = &quot;Hello World&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct C: AConvertible, BConvertible {<br>&gt;&gt;       <br>&gt;&gt;     typealias CustomAType = A<br>&gt;&gt;     typealias CustomBType = B<br>&gt;&gt;       <br>&gt;&gt;     var magical: SomeType<br>&gt;&gt;           <br>&gt;&gt;     init(value: CustomAType) {<br>&gt;&gt;         // implement it<br>&gt;&gt;     }<br>&gt;&gt;       <br>&gt;&gt;     init(value: CustomBType) {<br>&gt;&gt;         // implement it<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; //===========================<br>&gt;&gt; <br>&gt;&gt; let firstC: C = A() // this is what I&#39;m missing in Swift<br>&gt;&gt; let secondC: C = B() // this would be a great syntax sugar<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ? <br>&gt;&gt; Regards Adrian<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
