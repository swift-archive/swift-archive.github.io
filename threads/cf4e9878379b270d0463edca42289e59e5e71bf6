<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 14, 2016 at 02:00:00pm</p></header><div class="content"><p>Proposal link: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>Hello Swift Community, <br></p><p>The review of &quot;SE-0117: Default classes to be non-subclassable publicly&quot; ran from July 5…11, 2016.  As expected, this proposal was extremely polarizing, with valid arguments on both sides.  The opinions held by supporters and opposers are held very strongly, and hundreds of emails were generated in a healthy debate about this topic.<br></p><p>The review manager read every post on this topic, and the core team discussed this topic at length.  The core team concluded three things: <br></p><p> - First, the core team *agrees with conviction* that it is the right default for public classes to be non-subclassable outside their module, unless they carry some additional indication from the API author that the class was designed to be subclassed.<br> - Second, there was insufficient discussion about anything *other* than the first point.  The proposal also contains the “overridable” concept, which is highly impactful, but lacked significant discussion.<br> - Third, the core team agrees that the concrete syntax of “subclassable class” is … suboptimal.<br></p><p>On the first point, there are three related arguments against SE-0117:<br></p><p>- First is that clients of Apple frameworks often choose to subclass classes that Apple publicly documents as being “not for subclassing”, as a way of “getting their job done,” typically as a way to work around claimed bugs in Apple frameworks.  The core team and others at Apple feel that this argument is analogous to the argument that Swift should “support method swizzling by default”.  Swift loves dynamic features, but has already taken a stance against unanticipated method swizzling, by requiring an API author to indicate where they allow method swizzling with the ‘dynamic’ keyword.  Almost all classes vended by Apple APIs are subclassable (which isn’t changed by this proposal) so this argument is not compelling to the core team, nor is it consistent with the existing design of Swift.  It is also important to note that Cocoa also makes heavy use of delegation (via protocols) which allows client code to customize framework behavior without subclassing.<br></p><p>- Second is that clients of some other public API vended by a non-Apple framework (e.g. a SwiftPM package) may end up in a situation where the framework author didn’t consider subclass-ability, but the client desires it.  In this situation, the core team feels that a bigger problem happened: the vendor of the framework did not completely consider the use cases of the framework.  This might have happened due to the framework not using sufficient black box unit testing, a failure of the imagination of the designer in terms of use cases, or because they have a bug in their framework that needs unanticipated subclass-ability in order to “get a job done”.  Similar to the first point, the core team feels that the language is not the right place to solve this problem.  Instead, there is a simple and general solution: communicate with the framework author and get them to add the capabilities that you desire.  If they simply need to add subclass-ability, then that is no problem: it is a source-compatible change to a dependency.<br></p><p>- Third is a longer-term meta-concern, wherein a few people are concerned that future pure-Swift APIs will not consider subclass-ability in their design and will accidentally choose-by-omission to prevent subclass-ability on a future pure-Swift API (vended by Apple or otherwise).  The core team feels that this is an extremely unlikely situation for several reasons.  First of which is that it heavily overlaps the first two concerns.  More significantly, any newly-designed and from-scratch APIs that are intended for Swift-only clients will make use of a breadth of abstractions supported by Swift—structs, enums, protocols, classes.  The primary reasons to use classes in Swift are subclassability and reference semantics, so the core team feels that the likelihood of accidental omission is small.  Likewise, the decision to require every member of a public class to be marked public in Swift indicates a commitment (in line with SE-0117) that expects cross-module API authors to think carefully about the API they are authoring as well as their use cases.<br></p><p>To reiterate, as a summary, the core team *agrees with conviction* that it is the right default for public classes to be non-subclassable outside their module, unless they carry some additional indication by the API author that the class was designed to be subclassed.  However, it does not yet have an opinion as to what that concrete syntax is.<br></p><p>------8&lt;-------<br></p><p>To sum this all up, the core team is rejecting this proposal and requesting a revision to change the concrete syntax to “public open class Foo” instead of “subclassable class Foo&quot;.  This approach satisfies the *unwavering* goal of requiring additional thought when publishing a class as public API, makes subclass-ability orthogonal to access control, and (admittedly as a bit of a swift-evolution process hack) asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>The core team appreciates that this is a situation where it is impossible to please everyone, while also recognizing that the challenges faced by developers of pure-Swift code are not exactly analogous to those faced by Objective-C developers.  Thank you to the many and diverse opinions and perspectives that have come in as part of this review cycle!<br></p><p> -Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160714/cf4e1bf6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July 14, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; To sum this all up, the core team is … requesting a revision to change the concrete syntax to “public open class Foo” instead of “subclassable class Foo”.<br></p><p>Yes, +1 to “public open Foo” instead of “subclassable Foo”.<br></p><p>Presumably “open” without “public” is an error…?<br></p><p>&gt; [The core team] asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>Tentative +1 to this, though I’m open to hearing arguments otherwise.<br></p><p>One could make a good case for overridable being the sensible default and require an explicit “final,” just as for internal subclassing. I lean against this for two reasons:<br></p><p>Explicit “overridable” is consistent with the general principle of explicit exposure of public promises in public APIs.<br>When a class is declared public, its members are still internal by default. By analogy, class-level “open” shouldn’t make members overridable by default either. With a language like Swift that encourages developers to lean on the compiler for verification, setting consistent expectations is crucial, and this behavior seems more consistent to me.<br></p><p>I look at this proposal primarily from the point of view of a library author who is trying to design their API right, and is looking for assistance from the language in achieving that goal. The core team’s proposals seem consistent with this.<br></p><p>This makes me wonder whether we should remove member-level “final” from the language, and require “overridable” (i.e. final methods by default) even for members of non-open classes just for consistency and simplicity. That may be a separate proposal, but does seem like it needs consideration for Swift 3.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/a946378a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July 14, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 4:18 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To sum this all up, the core team is … requesting a revision to change the concrete syntax to “public open class Foo” instead of “subclassable class Foo”.<br>&gt; <br>&gt; Yes, +1 to “public open Foo” instead of “subclassable Foo”.<br>&gt; <br>&gt; Presumably “open” without “public” is an error…?<br>&gt; <br>&gt;&gt; [The core team] asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>I don’t see a reason for the openness/overridability/virtualness/finalness of a member to be more complex than a boolean. That is, while classes can be final, sealed or open, I believe members should only be “open” or “final”. I don’t see use cases to have members that are only overridable in-module but not by external parties. <br></p><p>As we suspect an API designer to indicate whether a class is overridable or not by third parties and to determine whether members are exposed to third parties, I would expect them to also want to dictate *how* said type is overridable by third parties (e.g. which members are overridable). <br></p><p>Whether we are open by default or final by default allows them to do this, but transitioning from final to open shouldn’t break existing API usage on revision. You won’t have someone accidentally using your library in a way you didn’t intend to support because you forgot to mark a method as ‘open’. Therefore, I lean toward final by default.<br></p><p>&gt; This makes me wonder whether we should remove member-level “final” from the language, and require “overridable” (i.e. final methods by default) even for members of non-open classes just for consistency and simplicity. That may be a separate proposal, but does seem like it needs consideration for Swift 3.<br></p><p>In an inheritance chain, we have to decide whether a subclass inherits the method openness. If so, “final override” could still be valid. Otherwise, I agree about removing member-level ‘final&#39;<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/d1598252/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July 14, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 5:56 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 4:18 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [The core team] asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br>&gt; <br>&gt; I don’t see a reason for the openness/overridability/virtualness/finalness of a member to be more complex than a boolean. That is, while classes can be final, sealed or open, I believe members should only be “open” or “final”. I don’t see use cases to have members that are only overridable in-module but not by external parties.<br></p><p>I tend to agree with that. The “overridable internally, final for the public” mode seems like it might have some use, but feels awfully esoteric.<br></p><p>&gt;&gt; This makes me wonder whether we should remove member-level “final” from the language, and require “overridable” (i.e. final methods by default) even for members of non-open classes just for consistency and simplicity. That may be a separate proposal, but does seem like it needs consideration for Swift 3.<br>&gt; <br>&gt; In an inheritance chain, we have to decide whether a subclass inherits the method openness. If so, “final override” could still be valid. Otherwise, I agree about removing member-level ‘final’<br></p><p>My gut feeling is that “final override” is also a bit esoteric — too much to justify keeping a whole keyword in the language.<br></p><p>A compelling use case for either of these allegedly esoteric things could easily sway me.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/346602bb/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>July 15, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 11:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To sum this all up, the core team is rejecting this proposal and requesting a revision to change the concrete syntax to “public open class Foo” instead of “subclassable class Foo&quot;.  This approach satisfies the *unwavering* goal of requiring additional thought when publishing a class as public API, makes subclass-ability orthogonal to access control, and (admittedly as a bit of a swift-evolution process hack) asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>+1 on open instead of subclassable.<br></p><p>As per the overridability I&#39;m coming back and forth. There are certainly classes where you want just a few things to be overridable and then there are classes where you want almost everything overridable.<br></p><p>I would personally prefer not overridable by default, but also an addition of a modifier on open that would allow to specify default overridability:<br></p><p>// by default everything is overridable<br>open(override) class Bar<br></p><p>Alternatives: open(members), open(all)<br></p><p>This, however, requires a new keyword for &quot;closing&quot; a member within the module:<br></p><p>// Not allowed overriding beyond the module.<br>closed func foo()<br></p><p>BTW I&#39;m not a fan of the keyword &quot;overridable&quot; at all. Imagine that you subclass the class in another module, override the method and expose it for yet another module and keep the overridability:<br></p><p>overridable override func foo()<br></p><p>I&#39;d prefer the open keyword to be reused here.<br></p><p>&gt; <br>&gt;  -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/cc828aa5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; - Second is that clients of some other public API vended by a non-Apple framework (e.g. a SwiftPM package) may end up in a situation where the framework author didn’t consider subclass-ability, but the client desires it.  In this situation, the core team feels that a bigger problem happened: the vendor of the framework did not completely consider the use cases of the framework.  This might have happened due to the framework not using sufficient black box unit testing, a failure of the imagination of the designer in terms of use cases, or because they have a bug in their framework that needs unanticipated subclass-ability in order to “get a job done”.<br></p><p>Or because the framework was developed in the real world, rather than Elysium, and real-world framework developers just about *never* anticipate every single way someone might use their framework (Indeed, if developers were capable of such a thing, there would be no need for third-party software in the first place).<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/6bc60793/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 10:58 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; - Second is that clients of some other public API vended by a non-Apple framework (e.g. a SwiftPM package) may end up in a situation where the framework author didn’t consider subclass-ability, but the client desires it.  In this situation, the core team feels that a bigger problem happened: the vendor of the framework did not completely consider the use cases of the framework.  This might have happened due to the framework not using sufficient black box unit testing, a failure of the imagination of the designer in terms of use cases, or because they have a bug in their framework that needs unanticipated subclass-ability in order to “get a job done”.<br>&gt; <br>&gt; Or because the framework was developed in the real world, rather than Elysium, and real-world framework developers just about *never* anticipate every single way someone might use their framework (Indeed, if developers were capable of such a thing, there would be no need for third-party software in the first place).<br></p><p>I’m not sure what you’re trying to say.  I agree that it is clearly the case that a framework author cannot anticipate every single use case of their framework.  <br></p><p>However, it is just as clearly the case that “unanticipated subclassability” isn’t a general solution to that problem.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160714/862f83c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 15, 2016, at 8:26 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 10:58 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Second is that clients of some other public API vended by a non-Apple framework (e.g. a SwiftPM package) may end up in a situation where the framework author didn’t consider subclass-ability, but the client desires it.  In this situation, the core team feels that a bigger problem happened: the vendor of the framework did not completely consider the use cases of the framework.  This might have happened due to the framework not using sufficient black box unit testing, a failure of the imagination of the designer in terms of use cases, or because they have a bug in their framework that needs unanticipated subclass-ability in order to “get a job done”.<br>&gt;&gt; <br>&gt;&gt; Or because the framework was developed in the real world, rather than Elysium, and real-world framework developers just about *never* anticipate every single way someone might use their framework (Indeed, if developers were capable of such a thing, there would be no need for third-party software in the first place).<br>&gt; <br>&gt; I’m not sure what you’re trying to say.  I agree that it is clearly the case that a framework author cannot anticipate every single use case of their framework.  <br>&gt; <br>&gt; However, it is just as clearly the case that “unanticipated subclassability” isn’t a general solution to that problem.<br></p><p>I think seeing it as &#39;clear&#39; is pure perspective, rather than fact. For instance it might ba apple&#39;s perspective, but not red hat&#39;s (consider that it took 10 years to be able to delete apps from our devices... indicating that from apple&#39;s view point there seems to be a mindset that we cannot do things opportunistically, assuming the consequences of our choices, which does exist in others parts of the technology planet).<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/071e4f0e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 15, 2016 at 11:00:00am</p></header><div class="content"><p>On Jul 15, 2016, at 9:36 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or because the framework was developed in the real world, rather than Elysium, and real-world framework developers just about *never* anticipate every single way someone might use their framework (Indeed, if developers were capable of such a thing, there would be no need for third-party software in the first place).<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you’re trying to say.  I agree that it is clearly the case that a framework author cannot anticipate every single use case of their framework.  <br>&gt;&gt; <br>&gt;&gt; However, it is just as clearly the case that “unanticipated subclassability” isn’t a general solution to that problem.<br>&gt; <br>&gt; I think seeing it as &#39;clear&#39; is pure perspective, rather than fact. For instance it might ba apple&#39;s perspective, but not red hat&#39;s (consider that it took 10 years to be able to delete apps from our devices... indicating that from apple&#39;s view point there seems to be a mindset that we cannot do things opportunistically, assuming the consequences of our choices, which does exist in others parts of the technology planet).<br></p><p>I think you’re missing my point: if a framework vendor fails to anticipate some use-case, and the affected part of their API is defined in terms of structs and enums, then subclassability is immaterial.  Allowing unanticipated subclassability could address some slice of the problem, but it is “clearly” not a general solution to problem of an API vendor providing an insufficient API.<br></p><p>Also keep in mind that many other things in Swift (e.g. methods not being public by default, not being “dynamic” by default) already cut across this.  All of this means that while the experiences using Objective-C frameworks can and should inform this discussion, but it does not translate “directly&quot; to Swift.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4cf8c436da98736ad247681dc6c89a0?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Mike Sanderson</string> &lt;m at mikesand.com&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Jul 15, 2016 at 2:26 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jul 14, 2016, at 10:58 PM, Charles Srstka &lt;cocoadev at charlessoft.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Jul 14, 2016, at 4:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; - Second is that clients of some other public API vended by a non-Apple<br>&gt; framework (e.g. a SwiftPM package) may end up in a situation where the<br>&gt; framework author didn’t consider subclass-ability, but the client desires<br>&gt; it.  In this situation, the core team feels that a bigger problem happened:<br>&gt; the vendor of the framework did not completely consider the use cases of<br>&gt; the framework.  This might have happened due to the framework not using<br>&gt; sufficient black box unit testing, a failure of the imagination of the<br>&gt; designer in terms of use cases, or because they have a bug in their<br>&gt; framework that needs unanticipated subclass-ability in order to “get a job<br>&gt; done”.<br>&gt;<br>&gt;<br>&gt; Or because the framework was developed in the real world, rather than<br>&gt; Elysium, and real-world framework developers just about *never* anticipate<br>&gt; every single way someone might use their framework (Indeed, if developers<br>&gt; were capable of such a thing, there would be no need for third-party<br>&gt; software in the first place).<br>&gt;<br>&gt;<br>&gt; I’m not sure what you’re trying to say.  I agree that it is clearly the<br>&gt; case that a framework author cannot anticipate every single use case of<br>&gt; their framework.<br>&gt;<br>&gt; However, it is just as clearly the case that “unanticipated<br>&gt; subclassability” isn’t a general solution to that problem.<br>&gt;<br></p><p>In the case of open-source frameworks, there is a better solution, simply<br>to fork. Fork, make the alteration, point the dependency manager to the<br>fork, and if you think it&#39;s of general applicability, submit a pull request.<br></p><p>And this does happen all the time. Not just unanticipated use cases, but<br>general bugs, bugs from a particular way it&#39;s used, some tweaks to adjust<br>some variable, need something fixed to be altered, designers ask for<br>something to be moved 10 pixels to the left, etc., including things<br>subclassing wouldn&#39;t even be able to fix. I&#39;ve had to do this more than a<br>few times, and it actually never occurred to me to make a subclass for this<br>reason. A proposal that closed off the only way or the best way to handle<br>these cases would be unwelcome, but this doesn&#39;t do that.<br></p><p>It&#39;s another topic, but I think having a fork of open-source dependencies<br>anyway is prudent, as our friends in javascript learned with their recent<br>Node Package Manager left-pad fiasco. The left-pad fiasco also indicated<br>that relying on framework authors to be communicative or to be maintaining<br>their work or even to be not deliberately spiteful, is not good practice.<br>Fortunately in the case of open-source we do have that control; in the case<br>of Apple frameworks the assurances offered as part of sending it for<br>revision are welcome; and if this puts onus on publishers of third-party<br>close-source frameworks, ok.<br></p><p>-MikeSand<br></p><p><br></p><p>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/0c272ea7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>July 15, 2016 at 09:00:00am</p></header><div class="content"><p>I have deliberately kept away from the discussion on this topic, as I didn’t feel like I can contribute in any meaningful way. In all honesty, I have barely used ‚traditional’ OOP paradigms in the last few years at all. While OOP is a useful tool and its great for modelling certain relationship and problems, I agree with the sentiment expressed by the core team that ‚open by default‘ OOP introduces a great deal of complexity for the framework creator, framework client and the compiler alike. Objective-C, with its dynamic message dispatch is a great example of a feature that is very flexible and quite beautiful, but at the same time so inherently unsafe, that it can easily be abused - AND that has been abused extensively. <br></p><p>The fact is, the programming languages we are using currently don’t do a very good job in declaring, describing and enforcing invariants/contracts. More often than not, the invariants are expressed informally (if they are expressed at all). Under such circumstances, more openness means more chance to break things long-term. Until a more general solution can be found (API access roles? state invariants declarations?) anything that makes things more explicit is a good thing in my book. <br></p><p><br>&gt; On 15 Jul 2016, at 07:58, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Or because the framework was developed in the real world, rather than Elysium, and real-world framework developers just about *never* anticipate every single way someone might use their framework (Indeed, if developers were capable of such a thing, there would be no need for third-party software in the first place).<br></p><p>If I am selling a frying pen, I am really not interested in people using it as a hammer ;) To be honest, I don’t really understand your post. A framework has a particular application domain and caters to certain use cases. It either meets its design goals or not. What does it have to do with need for third-party software? And how does ability to subclass makes it any better? <br></p><p>— T<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 2:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>To be clear: You want this discussion to happen in the next review thread, rather than in this thread?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>July 15, 2016 at 02:00:00am</p></header><div class="content"><p>FWIW, I&#39;m still against this proposal, but since it will be accepted regardless, here are my thoughts:<br></p><p>• Open keyword is significantly better. <br>• Members should be *open* by default, and final should be opt-in. If you&#39;re opening up a class for subclassing, my gut says you should allow the client to do as they wish. If only one or two methods should be overridable, I think delegation (via protocols) is a much better solution.<br>• I feel like final and open are now *almost* on the same axis, but not quite; open controls subclassability outside module, but final controls it for both. Why not use access control modifiers, such as:<br></p><p>- public(open)<br>- internal(open) (default)<br>- fileprivate(open)<br>- private(open) = final<br></p><p>Then, we could remove the &quot;final&quot; keyword from the language completely, and use access control as normal. I feel like this unifies everything much better (private(open) does seem a little weird though).<br></p><p>On Jul 15, 2016, at 1:27 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Jul 14, 2016, at 2:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br>&gt; <br>&gt; To be clear: You want this discussion to happen in the next review thread, rather than in this thread?<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9df907a6d7a4e317834a3c3816987a8a?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre Elder</string> &lt;son_gohan at mac.com&gt;<p>July 16, 2016 at 07:00:00am</p></header><div class="content"><p>2016/07/15 16:37、Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; FWIW, I&#39;m still against this proposal, but since it will be accepted regardless, here are my thoughts:<br>&gt; <br>&gt; • Open keyword is significantly better. <br>&gt; • Members should be *open* by default, and final should be opt-in. If you&#39;re opening up a class for subclassing, my gut says you should allow the client to do as they wish.<br>If you have a class that was not open yet, just making it open wouldn&#39;t expose any members: it would then just be subclassable.<br></p><p>If the act of making the class open doesn&#39;t implicitly make overriding possible, well all you can do then is add methods, and that can be done with extensions anyways, so it&#39;s not as useful and makes the public open class {} pattern just by itself not so useful imho... 😬<br></p><p>Also, the keyword &#39;open&#39; itself may imply &#39;hey I&#39;m open, please do what you want with my public members&#39;, whereas &#39;subclassable&#39; is more specific in intention...  (but that&#39;s just me, so n=1 and all that)<br></p><p>TLDR; +1 to the above: simpler is better and defaulting to overridable for public members on an open class is simpler... invariants can be protected by the &#39;final&#39; keyword.<br></p><p>If we were to default to non-overridable, a more consistent &#39;open&#39; on the method is preferred over overridable for me... open class, open method... much better imho...<br></p><p>&gt;  If only one or two methods should be overridable, I think delegation (via protocols) is a much better solution.<br></p><p>Delegation and protocols all the way!<br></p><p>&gt; • I feel like final and open are now *almost* on the same axis, but not quite; open controls subclassability outside module, but final controls it for both. Why not use access control modifiers, such as:<br>&gt; <br>&gt; - public(open)<br>&gt; - internal(open) (default)<br>&gt; - fileprivate(open)<br>&gt; - private(open) = final<br>&gt; <br>&gt; Then, we could remove the &quot;final&quot; keyword from the language completely, and use access control as normal. I feel like this unifies everything much better (private(open) does seem a little weird though).<br>I think it does feel a little weird, and maybe makes things more complicated... for example, private(open) by itself doesn&#39;t tell me at a glance what consumers of the framework will see... maybe this because of the &#39;open&#39; being there... it feels like just plain &#39;private&#39; is better... then I can reason, &#39;oh this is only a private class, I&#39;m the author so I can do what I want here&#39; or &#39;oh, this ones public but not open&#39;... maybe I&#39;m wrong though.... 🙃<br></p><p>Thanks,<br></p><p>Andre<br></p><p>&gt; On Jul 15, 2016, at 1:27 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 14, 2016, at 2:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br>&gt;&gt; <br>&gt;&gt; To be clear: You want this discussion to happen in the next review thread, rather than in this thread?<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/b9ff3527/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Le 16 juil. 2016 à 00:31, Andre Elder via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; 2016/07/15 16:37、Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; FWIW, I&#39;m still against this proposal, but since it will be accepted regardless, here are my thoughts:<br>&gt;&gt; <br>&gt;&gt; • Open keyword is significantly better. <br>&gt;&gt; • Members should be *open* by default, and final should be opt-in. If you&#39;re opening up a class for subclassing, my gut says you should allow the client to do as they wish.<br>&gt; If you have a class that was not open yet, just making it open wouldn&#39;t expose any members: it would then just be subclassable.<br>&gt; <br>&gt; If the act of making the class open doesn&#39;t implicitly make overriding possible, well all you can do then is add methods, and that can be done with extensions anyways, so it&#39;s not as useful and makes the public open class {} pattern just by itself not so useful imho... 😬<br>&gt; <br>&gt; Also, the keyword &#39;open&#39; itself may imply &#39;hey I&#39;m open, please do what you want with my public members&#39;, whereas &#39;subclassable&#39; is more specific in intention...  (but that&#39;s just me, so n=1 and all that)<br>&gt; <br>&gt; TLDR; +1 to the above: simpler is better and defaulting to overridable for public members on an open class is simpler... invariants can be protected by the &#39;final&#39; keyword.<br>&gt; <br>&gt; If we were to default to non-overridable, a more consistent &#39;open&#39; on the method is preferred over overridable for me... open class, open method... much better imho...<br></p><p>Do we really need an open keyword ?<br></p><p>As already said, if open does nothing more than allowing the class to be subclassed, why not simply make the class subclassable if it contains at least one overridable member ?<br></p><p>In case we require an open keyword, what would happen if someone mark a member overridable, but does not make the class open ? Will the compiler emit an error, or make the class implicitly « open » ? <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/ddf94596/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30e3591a1afb94308593c435111126c1?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Andre</string> &lt;pyunpyun at me.com&gt;<p>July 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; 2016/07/16 21:37、Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; のメール：<br>&gt; <br>&gt;&gt; Le 16 juil. 2016 à 00:31, Andre Elder via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; 2016/07/15 16:37、Riley Testut via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; FWIW, I&#39;m still against this proposal, but since it will be accepted regardless, here are my thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • Open keyword is significantly better. <br>&gt;&gt;&gt; • Members should be *open* by default, and final should be opt-in. If you&#39;re opening up a class for subclassing, my gut says you should allow the client to do as they wish.<br>&gt;&gt; If you have a class that was not open yet, just making it open wouldn&#39;t expose any members: it would then just be subclassable.<br>&gt;&gt; <br>&gt;&gt; If the act of making the class open doesn&#39;t implicitly make overriding possible, well all you can do then is add methods, and that can be done with extensions anyways, so it&#39;s not as useful and makes the public open class {} pattern just by itself not so useful imho... 😬<br>&gt;&gt; <br>&gt;&gt; Also, the keyword &#39;open&#39; itself may imply &#39;hey I&#39;m open, please do what you want with my public members&#39;, whereas &#39;subclassable&#39; is more specific in intention...  (but that&#39;s just me, so n=1 and all that)<br>&gt;&gt; <br>&gt;&gt; TLDR; +1 to the above: simpler is better and defaulting to overridable for public members on an open class is simpler... invariants can be protected by the &#39;final&#39; keyword.<br>&gt;&gt; <br>&gt;&gt; If we were to default to non-overridable, a more consistent &#39;open&#39; on the method is preferred over overridable for me... open class, open method... much better imho...<br>&gt; <br>&gt; Do we really need an open keyword ?<br>&gt; <br>&gt; As already said, if open does nothing more than allowing the class to be subclassed, why not simply make the class subclassable if it contains at least one overridable member ?<br>Thats a good point actually… but looks like Review #2 has already started… and &#39;open&#39; is available for both class and method there… I suppose its the whole &quot;default to safe&quot;, just in case someone made one method &#39;open&#39; they may not have intended to actually make the whole class open… (also see below)<br></p><p>&gt; In case we require an open keyword, what would happen if someone mark a member overridable, but does not make the class open ? Will the compiler emit an error, or make the class implicitly « open » ? <br>In proposal #2 looks like it would generate an error, but Xiaodi Wu has said that it should be allowed and not generate an error per SE-0025 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;.<br> &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md#complications-with-private-types&gt;Take a look at &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md#complications-with-private-types&gt;: &quot;The compiler should not warn when a broader level of access control is used within a type with more restrictive access, such as internal within a private type.&quot;<br></p><p>- Andre<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/f53be13f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>Swift has always gone towards making declarations explicit to read. Having open on thé class declaration makes it so you don&#39;t have to go hunting into its members to see if it contains an open member.<br></p><p>Other comments inline:<br></p><p>&gt; On 16 Jul 2016, at 14:49, Andre via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 2016/07/16 21:37、Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; のメール：<br>&gt;&gt; <br>&gt;&gt;&gt; Le 16 juil. 2016 à 00:31, Andre Elder via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/07/15 16:37、Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I&#39;m still against this proposal, but since it will be accepted regardless, here are my thoughts:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; • Open keyword is significantly better. <br>&gt;&gt;&gt;&gt; • Members should be *open* by default, and final should be opt-in. If you&#39;re opening up a class for subclassing, my gut says you should allow the client to do as they wish.<br>&gt;&gt;&gt; If you have a class that was not open yet, just making it open wouldn&#39;t expose any members: it would then just be subclassable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the act of making the class open doesn&#39;t implicitly make overriding possible, well all you can do then is add methods, and that can be done with extensions anyways, so it&#39;s not as useful and makes the public open class {} pattern just by itself not so useful imho... 😬<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also, the keyword &#39;open&#39; itself may imply &#39;hey I&#39;m open, please do what you want with my public members&#39;, whereas &#39;subclassable&#39; is more specific in intention...  (but that&#39;s just me, so n=1 and all that)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; TLDR; +1 to the above: simpler is better and defaulting to overridable for public members on an open class is simpler... invariants can be protected by the &#39;final&#39; keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we were to default to non-overridable, a more consistent &#39;open&#39; on the method is preferred over overridable for me... open class, open method... much better imho...<br>&gt;&gt; <br>&gt;&gt; Do we really need an open keyword ?<br>&gt;&gt; <br>&gt;&gt; As already said, if open does nothing more than allowing the class to be subclassed, why not simply make the class subclassable if it contains at least one overridable member ?<br>&gt; Thats a good point actually… but looks like Review #2 has already started… and &#39;open&#39; is available for both class and method there… I suppose its the whole &quot;default to safe&quot;, just in case someone made one method &#39;open&#39; they may not have intended to actually make the whole class open… (also see below)<br>&gt; <br>&gt;&gt; In case we require an open keyword, what would happen if someone mark a member overridable, but does not make the class open ? Will the compiler emit an error, or make the class implicitly « open » ? <br>&gt; In proposal #2 looks like it would generate an error, but Xiaodi Wu has said that it should be allowed and not generate an error per SE-0025.<br>&gt; Take a look at: &quot;The compiler should not warn when a broader level of access control is used within a type with more restrictive access, such as internal within a private type.&quot;<br></p><p>I&#39;m fairly sure that does not apply to open as it&#39;s fairly orthogonal to other access control modifiers.<br></p><p>&gt; - Andre<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/88b777dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 16, 2016 at 10:00:00am</p></header><div class="content"><p>What happens if I want an `internal` subclass of an `open` class?<br></p><p>On Sat, Jul 16, 2016 at 10:09 AM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift has always gone towards making declarations explicit to read. Having<br>&gt; open on thé class declaration makes it so you don&#39;t have to go hunting into<br>&gt; its members to see if it contains an open member.<br>&gt;<br>&gt; Other comments inline:<br>&gt;<br>&gt; On 16 Jul 2016, at 14:49, Andre via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; 2016/07/16 21:37、Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; のメール：<br>&gt;<br>&gt; Le 16 juil. 2016 à 00:31, Andre Elder via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; 2016/07/15 16:37、Riley Testut via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; FWIW, I&#39;m still against this proposal, but since it will be accepted<br>&gt; regardless, here are my thoughts:<br>&gt;<br>&gt; • Open keyword is significantly better.<br>&gt; • Members should be *open* by default, and final should be opt-in. If<br>&gt; you&#39;re opening up a class for subclassing, my gut says you should allow the<br>&gt; client to do as they wish.<br>&gt;<br>&gt; If you have a class that was not open yet, just making it open wouldn&#39;t<br>&gt; expose any members: it would then just be subclassable.<br>&gt;<br>&gt; If the act of making the class open doesn&#39;t implicitly make overriding<br>&gt; possible, well all you can do then is add methods, and that can be done<br>&gt; with extensions anyways, so it&#39;s not as useful and makes the *public open<br>&gt; class {}* pattern *just* by itself not so useful imho... 😬<br>&gt;<br>&gt; Also, the keyword &#39;open&#39; itself may imply &#39;hey I&#39;m open, please do what<br>&gt; you want with my public members&#39;, whereas &#39;subclassable&#39; is more specific<br>&gt; in intention...  (but that&#39;s just me, so n=1 and all that)<br>&gt;<br>&gt; TLDR; +1 to the above: simpler is better and defaulting to overridable for<br>&gt; public members on an open class is simpler... invariants can be protected<br>&gt; by the &#39;final&#39; keyword.<br>&gt;<br>&gt; If we were to default to non-overridable, a more consistent &#39;open&#39; on the<br>&gt; method is preferred over overridable for me... open class, open method...<br>&gt; much better imho...<br>&gt;<br>&gt;<br>&gt; Do we really need an open keyword ?<br>&gt;<br>&gt; As already said, if open does nothing more than allowing the class to be<br>&gt; subclassed, why not simply make the class subclassable if it contains at<br>&gt; least one overridable member ?<br>&gt;<br>&gt; Thats a good point actually… but looks like Review #2 has already started…<br>&gt; and &#39;open&#39; is available for both class and method there… I suppose its the<br>&gt; whole &quot;default to safe&quot;, just in case someone made one method &#39;open&#39; they<br>&gt; may not have intended to actually make the whole class open… (also see<br>&gt; below)<br>&gt;<br>&gt; In case we require an open keyword, what would happen if someone mark a<br>&gt; member overridable, but does not make the class open ? Will the compiler<br>&gt; emit an error, or make the class implicitly « open » ?<br>&gt;<br>&gt; In proposal #2 looks like it would generate an error, but Xiaodi Wu has<br>&gt; said that it should be allowed and not generate an error per SE-0025<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; .<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md#complications-with-private-types&gt;Take<br>&gt; a look at<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md#complications-with-private-types&gt;:<br>&gt; &quot;The compiler should not warn when a broader level of access control is<br>&gt; used within a type with more restrictive access, such as internal within<br>&gt; a private type.&quot;<br>&gt;<br>&gt;<br>&gt; I&#39;m fairly sure that does not apply to open as it&#39;s fairly orthogonal to<br>&gt; other access control modifiers.<br>&gt;<br>&gt; - Andre<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/f562ebf1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What happens if I want an `internal` subclass of an `open` class? <br></p><p>That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br></p><p>If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br></p><p>We might think about creating ‘sealed’ protocols, too.<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 16 Jul 2016, at 16:32, Karl &lt;raziel.im+swift-users at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; What happens if I want an `internal` subclass of an `open` class? <br>&gt; <br>&gt; That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br>&gt; <br>&gt; If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br>&gt; <br>&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt; <br>&gt; Karl<br></p><p>Sorry to mail 3 times in a row, but as I finished I remembered a concrete example of where sealed protocols would be helpful:<br></p><p>UIKit has a UITextInput protocol, which is used by custom text object which want to interact with the keyboard. It has a delegate property, of type UITextInputDelegate (another protocol).<br></p><p>I have seen lots of people try to have their own objects conform to UITextInputDelegate and set themselves as the delegate on a UITextInput object. That is the wrong usage of the property. You are never supposed to conform to UITextInputDelegate; the system has something which conforms to it, and it will set itself as your delegate at some point during text input. You use it to notify the system about changes to the text content and selection region.<br></p><p>https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextInputDelegate_Protocol/index.html<br></p><p>If it was a sealed protocol, the UIKit API authors would be able to more clearly communicate this intention and people wouldn’t be able to fall in this trap. The only other way they could do it would be to use a concrete final type, which evidently they didn’t want to do (possibly because it has internal subclasses and can’t be final).<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0735d3bf1d76c0385258ac7a2a22d6fe?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Károly Lőrentey</string> &lt;karoly at lorentey.hu&gt;<p>July 17, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 2016. Jul 16., at 16:45, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sorry to mail 3 times in a row, but as I finished I remembered a concrete example of where sealed protocols would be helpful:<br>&gt; <br>&gt; UIKit has a UITextInput protocol, which is used by custom text object which want to interact with the keyboard. It has a delegate property, of type UITextInputDelegate (another protocol).<br>&gt; <br>&gt; I have seen lots of people try to have their own objects conform to UITextInputDelegate and set themselves as the delegate on a UITextInput object. That is the wrong usage of the property. You are never supposed to conform to UITextInputDelegate; the system has something which conforms to it, and it will set itself as your delegate at some point during text input. You use it to notify the system about changes to the text content and selection region.<br>&gt; <br>&gt; https://developer.apple.com/library/ios/documentation/UIKit/Reference/UITextInputDelegate_Protocol/index.html<br>&gt; <br>&gt; If it was a sealed protocol, the UIKit API authors would be able to more clearly communicate this intention and people wouldn’t be able to fall in this trap. The only other way they could do it would be to use a concrete final type, which evidently they didn’t want to do (possibly because it has internal subclasses and can’t be final).<br></p><p>I think there is at least one legitimate case where you&#39;d still want to implement these kinds of protocols: when you&#39;re writing unit tests and you want to create a mock delegate to verify that your code calls the delegate methods correctly.<br></p><p>Also, interface inheritance is much less dangerous than implementation inheritance; I can&#39;t think of a case where allowing external code to implement a protocol could lead to maintenance problems for the framework author like subclassing does. (Although I agree the user confusion that you described occurs a lot.)<br></p><p>Karoly<br>@lorentey<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 16, 2016 at 11:00:00am</p></header><div class="content"><p>Yes, sorry, my point was that this consideration isn&#39;t spelled out.<br></p><p>Another question is whether or not making a subclass of an open class<br>public by default is what we want. I see why it would be, I just think that<br>it is a wrinkle to default to internal otherwise but not here.<br></p><p><br>On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;<br>&gt; That should be allowable. You may want some optimised implementations,<br>&gt; similar to how Apple used class-clusters in Obj-C. I don’t think that same<br>&gt; pattern is exactly possible in Swift (I don’t think a class can set ‘self’<br>&gt; in its initialiser, or at least it couldn’t in Swift 1). But the same<br>&gt; principle applies - you may want a public class which you don’t allow<br>&gt; others to subclass, but you might have a static method or other function<br>&gt; which returns an internal optimised implementation.<br>&gt;<br>&gt; If you used a protocol rather than a concrete type in that case,<br>&gt; theoretically others could conform to it and throw their own objects back<br>&gt; at your code, which goes against the point of this proposal.<br>&gt;<br>&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;<br>&gt; Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/c0b255d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 16, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out. <br>&gt; <br>&gt; Another question is whether or not making a subclass of an open class public by default is what we want. I see why it would be, I just think that it is a wrinkle to default to internal otherwise but not here.<br></p><p>I can&#39;t think of any good reason to assume a specific class should be public just because it is a subclass of an open class.  The internal default would still be the right default in this case.<br></p><p>&gt; <br>&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt; <br>&gt;&gt; That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br>&gt;&gt; <br>&gt;&gt; If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br>&gt;&gt; <br>&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/de5fc2d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out. <br>&gt;&gt; <br>&gt;&gt; Another question is whether or not making a subclass of an open class public by default is what we want. I see why it would be, I just think that it is a wrinkle to default to internal otherwise but not here.<br>&gt; <br>&gt; I can&#39;t think of any good reason to assume a specific class should be public just because it is a subclass of an open class.  The internal default would still be the right default in this case.<br></p><p>Right, there&#39;s no new restriction here.  Of course you can make a private or internal subclass of a public open class — otherwise, you&#39;d have to publicize every subclass of (say) UIViewController.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt; <br>&gt;&gt; That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br>&gt;&gt; <br>&gt;&gt; If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br>&gt;&gt; <br>&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt; <br>&gt;&gt; Karl<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/ffc8b170/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&quot;open is invalid on declarations that are not also public (see the<br>Alternatives discussion for rationale).&quot;<br>+<br></p><p>&quot;If an open class inherits an open method from a superclass, that method<br>remains open. If it overrides an open method from a superclass, the<br>override is implicitly open if it is not final.&quot;<br></p><p>I understand that the intent is probably not to say that subclasses are<br>public by default. My point is that those two statements, without an<br>explicit spelling out of the implicit access level, could lead me to<br>believe that subclasses are implicitly public by default. It is open to<br>interpretation. Neither the prose nor the code examples address it.<br></p><p><br>On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out.<br>&gt;<br>&gt; Another question is whether or not making a subclass of an open class<br>&gt; public by default is what we want. I see why it would be, I just think that<br>&gt; it is a wrinkle to default to internal otherwise but not here.<br>&gt;<br>&gt;<br>&gt; I can&#39;t think of any good reason to assume a specific class should be<br>&gt; public just because it is a subclass of an open class.  The internal<br>&gt; default would still be the right default in this case.<br>&gt;<br>&gt;<br>&gt; Right, there&#39;s no new restriction here.  Of course you can make a private<br>&gt; or internal subclass of a public open class — otherwise, you&#39;d have to<br>&gt; publicize every subclass of (say) UIViewController.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;<br>&gt;&gt; That should be allowable. You may want some optimised implementations,<br>&gt;&gt; similar to how Apple used class-clusters in Obj-C. I don’t think that same<br>&gt;&gt; pattern is exactly possible in Swift (I don’t think a class can set ‘self’<br>&gt;&gt; in its initialiser, or at least it couldn’t in Swift 1). But the same<br>&gt;&gt; principle applies - you may want a public class which you don’t allow<br>&gt;&gt; others to subclass, but you might have a static method or other function<br>&gt;&gt; which returns an internal optimised implementation.<br>&gt;&gt;<br>&gt;&gt; If you used a protocol rather than a concrete type in that case,<br>&gt;&gt; theoretically others could conform to it and throw their own objects back<br>&gt;&gt; at your code, which goes against the point of this proposal.<br>&gt;&gt;<br>&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;<br>&gt;&gt; Karl<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/52d1216b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 16, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 11:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; &quot;open is invalid on declarations that are not also public (see the Alternatives discussion for rationale).&quot;<br>&gt; <br>&gt; +<br>&gt; <br>&gt; &quot;If an open class inherits an open method from a superclass, that method remains open. If it overrides an open method from a superclass, the override is implicitly open if it is not final.&quot;<br>&gt; <br>&gt; I understand that the intent is probably not to say that subclasses are public by default. My point is that those two statements, without an explicit spelling out of the implicit access level, could lead me to believe that subclasses are implicitly public by default. It is open to interpretation. Neither the prose nor the code examples address it.<br></p><p>I see your general point.  I&#39;ll think about how to re-word this; it may be sufficient to just remove the requirement that open methods appear in open classes.  Suffice it for me to say now, officially, that this proposal does not require classes to be public or open just because they override open methods from an open superclass.<br></p><p>John.<br></p><p>&gt; <br>&gt; <br>&gt; On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another question is whether or not making a subclass of an open class public by default is what we want. I see why it would be, I just think that it is a wrinkle to default to internal otherwise but not here.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t think of any good reason to assume a specific class should be public just because it is a subclass of an open class.  The internal default would still be the right default in this case.<br>&gt; <br>&gt; Right, there&#39;s no new restriction here.  Of course you can make a private or internal subclass of a public open class — otherwise, you&#39;d have to publicize every subclass of (say) UIViewController.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Karl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/900d5ec7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sat, Jul 16, 2016 at 1:16 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jul 16, 2016, at 11:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;<br>&gt; &quot;open is invalid on declarations that are not also public (see the<br>&gt; Alternatives discussion for rationale).&quot;<br>&gt; +<br>&gt;<br>&gt; &quot;If an open class inherits an open method from a superclass, that method<br>&gt; remains open. If it overrides an open method from a superclass, the<br>&gt; override is implicitly open if it is not final.&quot;<br>&gt;<br>&gt; I understand that the intent is probably not to say that subclasses are<br>&gt; public by default. My point is that those two statements, without an<br>&gt; explicit spelling out of the implicit access level, could lead me to<br>&gt; believe that subclasses are implicitly public by default. It is open to<br>&gt; interpretation. Neither the prose nor the code examples address it.<br>&gt;<br>&gt;<br>&gt; I see your general point.  I&#39;ll think about how to re-word this; it may be<br>&gt; sufficient to just remove the requirement that open methods appear in open<br>&gt; classes.  Suffice it for me to say now, officially, that this proposal does<br>&gt; not require classes to be public or open just because they override open<br>&gt; methods from an open superclass.<br>&gt;<br></p><p>It might be barely sufficient solely to remove the requirement that open<br>methods appear in open classes. However, if my subclass is internal, I<br>shouldn&#39;t be required to declare a `public override` of an open method just<br>to satisfy the rules for `open`, which would be forced by the rule that<br>`open` is invalid on declarations that are not also `public` combined with<br>the rule that overrides of an open method are by default open.<br></p><p>This would degrade the developer experience significantly, since a<br>beginning developer writing only internal subclasses for their own app<br>would now be required to litter either `public override` or `final<br>override` throughout their code in the ordinary course of subclassing. On<br>reconsideration, it might be best if overrides are not implicitly open.<br></p><p><br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out.<br>&gt;&gt;<br>&gt;&gt; Another question is whether or not making a subclass of an open class<br>&gt;&gt; public by default is what we want. I see why it would be, I just think that<br>&gt;&gt; it is a wrinkle to default to internal otherwise but not here.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I can&#39;t think of any good reason to assume a specific class should be<br>&gt;&gt; public just because it is a subclass of an open class.  The internal<br>&gt;&gt; default would still be the right default in this case.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Right, there&#39;s no new restriction here.  Of course you can make a private<br>&gt;&gt; or internal subclass of a public open class — otherwise, you&#39;d have to<br>&gt;&gt; publicize every subclass of (say) UIViewController.<br>&gt;&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That should be allowable. You may want some optimised implementations,<br>&gt;&gt;&gt; similar to how Apple used class-clusters in Obj-C. I don’t think that same<br>&gt;&gt;&gt; pattern is exactly possible in Swift (I don’t think a class can set ‘self’<br>&gt;&gt;&gt; in its initialiser, or at least it couldn’t in Swift 1). But the same<br>&gt;&gt;&gt; principle applies - you may want a public class which you don’t allow<br>&gt;&gt;&gt; others to subclass, but you might have a static method or other function<br>&gt;&gt;&gt; which returns an internal optimised implementation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you used a protocol rather than a concrete type in that case,<br>&gt;&gt;&gt; theoretically others could conform to it and throw their own objects back<br>&gt;&gt;&gt; at your code, which goes against the point of this proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Karl<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/a7fe17a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 02:00:00pm</p></header><div class="content"><p>On Sat, Jul 16, 2016 at 1:48 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Sat, Jul 16, 2016 at 1:16 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 16, 2016, at 11:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &quot;open is invalid on declarations that are not also public (see the<br>&gt;&gt; Alternatives discussion for rationale).&quot;<br>&gt;&gt; +<br>&gt;&gt;<br>&gt;&gt; &quot;If an open class inherits an open method from a superclass, that method<br>&gt;&gt; remains open. If it overrides an open method from a superclass, the<br>&gt;&gt; override is implicitly open if it is not final.&quot;<br>&gt;&gt;<br>&gt;&gt; I understand that the intent is probably not to say that subclasses are<br>&gt;&gt; public by default. My point is that those two statements, without an<br>&gt;&gt; explicit spelling out of the implicit access level, could lead me to<br>&gt;&gt; believe that subclasses are implicitly public by default. It is open to<br>&gt;&gt; interpretation. Neither the prose nor the code examples address it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I see your general point.  I&#39;ll think about how to re-word this; it may<br>&gt;&gt; be sufficient to just remove the requirement that open methods appear in<br>&gt;&gt; open classes.  Suffice it for me to say now, officially, that this proposal<br>&gt;&gt; does not require classes to be public or open just because they override<br>&gt;&gt; open methods from an open superclass.<br>&gt;&gt;<br>&gt;<br>&gt; It might be barely sufficient solely to remove the requirement that open<br>&gt; methods appear in open classes. However, if my subclass is internal, I<br>&gt; shouldn&#39;t be required to declare a `public override` of an open method just<br>&gt; to satisfy the rules for `open`, which would be forced by the rule that<br>&gt; `open` is invalid on declarations that are not also `public` combined with<br>&gt; the rule that overrides of an open method are by default open.<br>&gt;<br>&gt; This would degrade the developer experience significantly, since a<br>&gt; beginning developer writing only internal subclasses for their own app<br>&gt; would now be required to litter either `public override` or `final<br>&gt; override` throughout their code in the ordinary course of subclassing. On<br>&gt; reconsideration, it might be best if overrides are not implicitly open.<br>&gt;<br></p><p>I should add: independent of the issue above for internal subclasses in<br>apps that don&#39;t vend an API having &quot;public&quot; overrides, it seems to me most<br>consistent with the general aim of the proposal that open overrides should<br>be marked as such by the subclass&#39;s owner. The same logic that requires<br>explicit use of `open` for subclass declarations should require them for<br>overridden methods. (Whereas, clearly, inherited methods that don&#39;t show up<br>at all in the code inside the subclass are a different ballgame.)<br></p><p><br>&gt;<br>&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another question is whether or not making a subclass of an open class<br>&gt;&gt;&gt; public by default is what we want. I see why it would be, I just think that<br>&gt;&gt;&gt; it is a wrinkle to default to internal otherwise but not here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can&#39;t think of any good reason to assume a specific class should be<br>&gt;&gt;&gt; public just because it is a subclass of an open class.  The internal<br>&gt;&gt;&gt; default would still be the right default in this case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right, there&#39;s no new restriction here.  Of course you can make a<br>&gt;&gt;&gt; private or internal subclass of a public open class — otherwise, you&#39;d have<br>&gt;&gt;&gt; to publicize every subclass of (say) UIViewController.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That should be allowable. You may want some optimised implementations,<br>&gt;&gt;&gt;&gt; similar to how Apple used class-clusters in Obj-C. I don’t think that same<br>&gt;&gt;&gt;&gt; pattern is exactly possible in Swift (I don’t think a class can set ‘self’<br>&gt;&gt;&gt;&gt; in its initialiser, or at least it couldn’t in Swift 1). But the same<br>&gt;&gt;&gt;&gt; principle applies - you may want a public class which you don’t allow<br>&gt;&gt;&gt;&gt; others to subclass, but you might have a static method or other function<br>&gt;&gt;&gt;&gt; which returns an internal optimised implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you used a protocol rather than a concrete type in that case,<br>&gt;&gt;&gt;&gt; theoretically others could conform to it and throw their own objects back<br>&gt;&gt;&gt;&gt; at your code, which goes against the point of this proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/ddaa9951/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July 16, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jul 16, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Sat, Jul 16, 2016 at 1:16 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; On Jul 16, 2016, at 11:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt;&gt; &quot;open is invalid on declarations that are not also public (see the Alternatives discussion for rationale).&quot;<br>&gt;&gt; <br>&gt;&gt; +<br>&gt;&gt; <br>&gt;&gt; &quot;If an open class inherits an open method from a superclass, that method remains open. If it overrides an open method from a superclass, the override is implicitly open if it is not final.&quot;<br>&gt;&gt; <br>&gt;&gt; I understand that the intent is probably not to say that subclasses are public by default. My point is that those two statements, without an explicit spelling out of the implicit access level, could lead me to believe that subclasses are implicitly public by default. It is open to interpretation. Neither the prose nor the code examples address it.<br>&gt; <br>&gt; I see your general point.  I&#39;ll think about how to re-word this; it may be sufficient to just remove the requirement that open methods appear in open classes.  Suffice it for me to say now, officially, that this proposal does not require classes to be public or open just because they override open methods from an open superclass.<br>&gt; <br>&gt; It might be barely sufficient solely to remove the requirement that open methods appear in open classes. However, if my subclass is internal, I shouldn&#39;t be required to declare a `public override` of an open method just to satisfy the rules for `open`, which would be forced by the rule that `open` is invalid on declarations that are not also `public`<br></p><p>This rule only applies to explicit uses of &quot;open&quot;.  A method that is implicitly open due to overriding does not have this restriction.<br></p><p>In general, my intent in writing this proposal was to cover the important interactions, not to write a fully precise specification.  The general rule about overrides having to be at least as accessible as the minimum of their class and their overridden method still applies, superseded only by the rule that it is acceptable to drop the &quot;open&quot; on a public open override.<br></p><p>&gt; combined with the rule that overrides of an open method are by default open.<br></p><p>&gt; This would degrade the developer experience significantly, since a beginning developer writing only internal subclasses for their own app would now be required to litter either `public override` or `final override` throughout their code in the ordinary course of subclassing. On reconsideration, it might be best if overrides are not implicitly open.<br></p><p>I continue to think &quot;override&quot; is sufficient communication here.  We&#39;re not going to have a model where the inherited open API of the superclass becomes non-open in the subclass.  We don&#39;t want the mere existence of an override in the subclass to change that because it&#39;s a fairly core goal that the existence of an override (at least one which doesn&#39;t covariantly refine the type) in a subclass should not affect source/binary compatibility.<br></p><p>John.<br></p><p><br>&gt; <br>&gt; <br>&gt; John.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another question is whether or not making a subclass of an open class public by default is what we want. I see why it would be, I just think that it is a wrinkle to default to internal otherwise but not here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can&#39;t think of any good reason to assume a specific class should be public just because it is a subclass of an open class.  The internal default would still be the right default in this case.<br>&gt;&gt; <br>&gt;&gt; Right, there&#39;s no new restriction here.  Of course you can make a private or internal subclass of a public open class — otherwise, you&#39;d have to publicize every subclass of (say) UIViewController.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/7ec0c983/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 07:00:00pm</p></header><div class="content"><p>Makes sense. Thanks for clarifying.<br></p><p><br>On Sat, Jul 16, 2016 at 14:17 John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Jul 16, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; On Sat, Jul 16, 2016 at 1:16 PM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Jul 16, 2016, at 11:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &quot;open is invalid on declarations that are not also public (see the<br>&gt;&gt; Alternatives discussion for rationale).&quot;<br>&gt;&gt; +<br>&gt;&gt;<br>&gt;&gt; &quot;If an open class inherits an open method from a superclass, that method<br>&gt;&gt; remains open. If it overrides an open method from a superclass, the<br>&gt;&gt; override is implicitly open if it is not final.&quot;<br>&gt;&gt;<br>&gt;&gt; I understand that the intent is probably not to say that subclasses are<br>&gt;&gt; public by default. My point is that those two statements, without an<br>&gt;&gt; explicit spelling out of the implicit access level, could lead me to<br>&gt;&gt; believe that subclasses are implicitly public by default. It is open to<br>&gt;&gt; interpretation. Neither the prose nor the code examples address it.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I see your general point.  I&#39;ll think about how to re-word this; it may<br>&gt;&gt; be sufficient to just remove the requirement that open methods appear in<br>&gt;&gt; open classes.  Suffice it for me to say now, officially, that this proposal<br>&gt;&gt; does not require classes to be public or open just because they override<br>&gt;&gt; open methods from an open superclass.<br>&gt;&gt;<br>&gt;<br>&gt; It might be barely sufficient solely to remove the requirement that open<br>&gt; methods appear in open classes. However, if my subclass is internal, I<br>&gt; shouldn&#39;t be required to declare a `public override` of an open method just<br>&gt; to satisfy the rules for `open`, which would be forced by the rule that<br>&gt; `open` is invalid on declarations that are not also `public`<br>&gt;<br>&gt;<br>&gt; This rule only applies to explicit uses of &quot;open&quot;.  A method that is<br>&gt; implicitly open due to overriding does not have this restriction.<br>&gt;<br>&gt; In general, my intent in writing this proposal was to cover the important<br>&gt; interactions, not to write a fully precise specification.  The general rule<br>&gt; about overrides having to be at least as accessible as the minimum of their<br>&gt; class and their overridden method still applies, superseded only by the<br>&gt; rule that it is acceptable to drop the &quot;open&quot; on a public open override.<br>&gt;<br>&gt; combined with the rule that overrides of an open method are by default<br>&gt; open.<br>&gt;<br>&gt;<br>&gt; This would degrade the developer experience significantly, since a<br>&gt; beginning developer writing only internal subclasses for their own app<br>&gt; would now be required to litter either `public override` or `final<br>&gt; override` throughout their code in the ordinary course of subclassing. On<br>&gt; reconsideration, it might be best if overrides are not implicitly open.<br>&gt;<br>&gt;<br>&gt; I continue to think &quot;override&quot; is sufficient communication here.  We&#39;re<br>&gt; not going to have a model where the inherited open API of the superclass<br>&gt; becomes non-open in the subclass.  We don&#39;t want the mere existence of an<br>&gt; override in the subclass to change that because it&#39;s a fairly core goal<br>&gt; that the existence of an override (at least one which doesn&#39;t covariantly<br>&gt; refine the type) in a subclass should not affect source/binary<br>&gt; compatibility.<br>&gt;<br>&gt; John.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; John.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Another question is whether or not making a subclass of an open class<br>&gt;&gt;&gt; public by default is what we want. I see why it would be, I just think that<br>&gt;&gt;&gt; it is a wrinkle to default to internal otherwise but not here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I can&#39;t think of any good reason to assume a specific class should be<br>&gt;&gt;&gt; public just because it is a subclass of an open class.  The internal<br>&gt;&gt;&gt; default would still be the right default in this case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right, there&#39;s no new restriction here.  Of course you can make a<br>&gt;&gt;&gt; private or internal subclass of a public open class — otherwise, you&#39;d have<br>&gt;&gt;&gt; to publicize every subclass of (say) UIViewController.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That should be allowable. You may want some optimised implementations,<br>&gt;&gt;&gt;&gt; similar to how Apple used class-clusters in Obj-C. I don’t think that same<br>&gt;&gt;&gt;&gt; pattern is exactly possible in Swift (I don’t think a class can set ‘self’<br>&gt;&gt;&gt;&gt; in its initialiser, or at least it couldn’t in Swift 1). But the same<br>&gt;&gt;&gt;&gt; principle applies - you may want a public class which you don’t allow<br>&gt;&gt;&gt;&gt; others to subclass, but you might have a static method or other function<br>&gt;&gt;&gt;&gt; which returns an internal optimised implementation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; If you used a protocol rather than a concrete type in that case,<br>&gt;&gt;&gt;&gt; theoretically others could conform to it and throw their own objects back<br>&gt;&gt;&gt;&gt; at your code, which goes against the point of this proposal.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/a21ae6fe/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 20, 2016 at 07:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 16, 2016, at 9:17 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 16, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; On Sat, Jul 16, 2016 at 1:16 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jul 16, 2016, at 11:03 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; &quot;open is invalid on declarations that are not also public (see the Alternatives discussion for rationale).&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;If an open class inherits an open method from a superclass, that method remains open. If it overrides an open method from a superclass, the override is implicitly open if it is not final.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I understand that the intent is probably not to say that subclasses are public by default. My point is that those two statements, without an explicit spelling out of the implicit access level, could lead me to believe that subclasses are implicitly public by default. It is open to interpretation. Neither the prose nor the code examples address it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see your general point.  I&#39;ll think about how to re-word this; it may be sufficient to just remove the requirement that open methods appear in open classes.  Suffice it for me to say now, officially, that this proposal does not require classes to be public or open just because they override open methods from an open superclass.<br>&gt;&gt; <br>&gt;&gt; It might be barely sufficient solely to remove the requirement that open methods appear in open classes. However, if my subclass is internal, I shouldn&#39;t be required to declare a `public override` of an open method just to satisfy the rules for `open`, which would be forced by the rule that `open` is invalid on declarations that are not also `public`<br>&gt; <br>&gt; This rule only applies to explicit uses of &quot;open&quot;.  A method that is implicitly open due to overriding does not have this restriction.<br>&gt; <br>&gt; In general, my intent in writing this proposal was to cover the important interactions, not to write a fully precise specification.  The general rule about overrides having to be at least as accessible as the minimum of their class and their overridden method still applies, superseded only by the rule that it is acceptable to drop the &quot;open&quot; on a public open override.<br>&gt; <br>&gt;&gt; combined with the rule that overrides of an open method are by default open.<br>&gt; <br>&gt;&gt; This would degrade the developer experience significantly, since a beginning developer writing only internal subclasses for their own app would now be required to litter either `public override` or `final override` throughout their code in the ordinary course of subclassing. On reconsideration, it might be best if overrides are not implicitly open.<br>&gt; <br>&gt; I continue to think &quot;override&quot; is sufficient communication here.  We&#39;re not going to have a model where the inherited open API of the superclass becomes non-open in the subclass.<br></p><p>the logic of the proposal would dictate that it did: by subclasing the original type into a new type, the programmer is effectively removing any of the original guaranties that the first programmer made about how cohesively all paths into the type operated. The new code defines a new outer boundary for the subtype that has every reason not to be trusted by default to be working for subclasing, for the same reasons the original types could not be implicitely trusted either.<br></p><p>&gt;  We don&#39;t want the mere existence of an override in the subclass to change that because it&#39;s a fairly core goal that the existence of an override (at least one which doesn&#39;t covariantly refine the type) in a subclass should not affect source/binary compatibility.<br>&gt; <br>&gt; John.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Jul 16, 2016 at 1:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 9:32 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jul 16, 2016, at 10:59 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes, sorry, my point was that this consideration isn&#39;t spelled out. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Another question is whether or not making a subclass of an open class public by default is what we want. I see why it would be, I just think that it is a wrinkle to default to internal otherwise but not here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I can&#39;t think of any good reason to assume a specific class should be public just because it is a subclass of an open class.  The internal default would still be the right default in this case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right, there&#39;s no new restriction here.  Of course you can make a private or internal subclass of a public open class — otherwise, you&#39;d have to publicize every subclass of (say) UIViewController.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sat, Jul 16, 2016 at 10:32 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; On 16 Jul 2016, at 16:10, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &gt; What happens if I want an `internal` subclass of an `open` class?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That should be allowable. You may want some optimised implementations, similar to how Apple used class-clusters in Obj-C. I don’t think that same pattern is exactly possible in Swift (I don’t think a class can set ‘self’ in its initialiser, or at least it couldn’t in Swift 1). But the same principle applies - you may want a public class which you don’t allow others to subclass, but you might have a static method or other function which returns an internal optimised implementation.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; If you used a protocol rather than a concrete type in that case, theoretically others could conform to it and throw their own objects back at your code, which goes against the point of this proposal.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; We might think about creating ‘sealed’ protocols, too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Karl<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160720/8411b6f2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 16, 2016 at 11:00:00am</p></header><div class="content"><p>On Sat, Jul 16, 2016 at 9:09 AM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Swift has always gone towards making declarations explicit to read. Having<br>&gt; open on thé class declaration makes it so you don&#39;t have to go hunting into<br>&gt; its members to see if it contains an open member.<br>&gt;<br>&gt; Other comments inline:<br>&gt;<br>&gt; On 16 Jul 2016, at 14:49, Andre via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; 2016/07/16 21:37、Jean-Daniel Dupas &lt;mailing at xenonium.com&gt; のメール：<br>&gt;<br>&gt; Le 16 juil. 2016 à 00:31, Andre Elder via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; 2016/07/15 16:37、Riley Testut via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; のメッセージ:<br>&gt;<br>&gt; FWIW, I&#39;m still against this proposal, but since it will be accepted<br>&gt; regardless, here are my thoughts:<br>&gt;<br>&gt; • Open keyword is significantly better.<br>&gt; • Members should be *open* by default, and final should be opt-in. If<br>&gt; you&#39;re opening up a class for subclassing, my gut says you should allow the<br>&gt; client to do as they wish.<br>&gt;<br>&gt; If you have a class that was not open yet, just making it open wouldn&#39;t<br>&gt; expose any members: it would then just be subclassable.<br>&gt;<br>&gt; If the act of making the class open doesn&#39;t implicitly make overriding<br>&gt; possible, well all you can do then is add methods, and that can be done<br>&gt; with extensions anyways, so it&#39;s not as useful and makes the *public open<br>&gt; class {}* pattern *just* by itself not so useful imho... 😬<br>&gt;<br>&gt; Also, the keyword &#39;open&#39; itself may imply &#39;hey I&#39;m open, please do what<br>&gt; you want with my public members&#39;, whereas &#39;subclassable&#39; is more specific<br>&gt; in intention...  (but that&#39;s just me, so n=1 and all that)<br>&gt;<br>&gt; TLDR; +1 to the above: simpler is better and defaulting to overridable for<br>&gt; public members on an open class is simpler... invariants can be protected<br>&gt; by the &#39;final&#39; keyword.<br>&gt;<br>&gt; If we were to default to non-overridable, a more consistent &#39;open&#39; on the<br>&gt; method is preferred over overridable for me... open class, open method...<br>&gt; much better imho...<br>&gt;<br>&gt;<br>&gt; Do we really need an open keyword ?<br>&gt;<br>&gt; As already said, if open does nothing more than allowing the class to be<br>&gt; subclassed, why not simply make the class subclassable if it contains at<br>&gt; least one overridable member ?<br>&gt;<br>&gt; Thats a good point actually… but looks like Review #2 has already started…<br>&gt; and &#39;open&#39; is available for both class and method there… I suppose its the<br>&gt; whole &quot;default to safe&quot;, just in case someone made one method &#39;open&#39; they<br>&gt; may not have intended to actually make the whole class open… (also see<br>&gt; below)<br>&gt;<br>&gt; In case we require an open keyword, what would happen if someone mark a<br>&gt; member overridable, but does not make the class open ? Will the compiler<br>&gt; emit an error, or make the class implicitly « open » ?<br>&gt;<br>&gt; In proposal #2 looks like it would generate an error, but Xiaodi Wu has<br>&gt; said that it should be allowed and not generate an error per SE-0025<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br>&gt; .<br>&gt;<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md#complications-with-private-types&gt;Take<br>&gt; a look at<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md#complications-with-private-types&gt;:<br>&gt; &quot;The compiler should not warn when a broader level of access control is<br>&gt; used within a type with more restrictive access, such as internal within<br>&gt; a private type.&quot;<br>&gt;<br>&gt;<br>&gt; I&#39;m fairly sure that does not apply to open as it&#39;s fairly orthogonal to<br>&gt; other access control modifiers.<br>&gt;<br></p><p>I agree that the statement in SE-0025 by itself doesn&#39;t necessary apply to<br>`open` because they are somewhat orthogonal. But the stated rationale in<br>SE-0025 applies equally to `open`, so I think this proposal would be<br>improved by having `open` behave similarly in this respect. Here&#39;s why:<br></p><p>The rationale stated in SE-0025 is that it allows a person who controls the<br>type to design as though it will have broader access than it actually does.<br>For instance, I can design an internal class as though it will be public,<br>and when I&#39;m satisfied with it, I can flip the switch and actually make it<br>public by adding a single access modifier. That rationale falls down for<br>classes if I cannot design a `public open` class without already making it<br>`public open`.<br></p><p>&gt; - Andre<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/24ff4154/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jul 14, 2016, at 11:27 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 14, 2016, at 2:39 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br>&gt; <br>&gt; To be clear: You want this discussion to happen in the next review thread, rather than in this thread?<br></p><p>Yep, I’ll kick off another review period as soon as the proposal is revised (hopefully today).<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>Despite of probably being one of the most passionate defenders against adding restrictions on subclassing, I&#39;ve to accept the clear statement made by the core team, so the imho only consequent answer to this question is requiring overridable on every single method:<br>- Whatever the perceived benefits of forbidding subclassing are, they are the same for each specific method<br>- It is the same principle that is applied to access control<br></p><p>For me, &quot;open&quot; has a tiny disadvantage, because I tend to read it as a verb, but it&#39;s most likely the best choice, and I recommend to re-use it and drop overridable:<br>- open is shorter<br>- open is less confusing<br>- access control follows the same principle of reuse<br></p><p>If the goal is taken serious, imho it is also questionable wether it is good to allow writing public properties without explicit rights to do so: It&#39;s a similar situation (you can read but not write vs. you can call but not override), and there is the proven template of default file access rights in UNIX.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/39945e41/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 14 Jul 2016, at 22:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To sum this all up, the core team is rejecting this proposal and requesting a revision to change the concrete syntax to “public open class Foo” instead of “subclassable class Foo&quot;.  <br></p><p>Minor point, but if we&#39;re going with the idea of public open and public final for declaration, is it worth re-raising the idea of bracketed accessibility modifiers? When fileprivate vs private was being discussed I was heavily in favour of private(file), private(scope) and private(module) (plus private(type) if we get that) to avoid polluting the language with more accessibility-specific keywords. This seems like a good time to mention it again, as we&#39;re now looking at even more keyword pollution:<br></p><p>	public(open)<br>	public(sealed)		// Probably not actually defined, but the default for a plain &quot;public&quot; declaration<br>	public(final)<br>	private(module)	// Replaces internal<br>	private(file)<br>	private(scope)		// Default for plain private<br></p><p>If we get a private(type) that&#39;s seven different keyword combinations for one feature, so I still very much prefer it being reduced to just public/private plus a modifier ;)<br></p><p>&gt; This approach satisfies the *unwavering* goal of requiring additional thought when publishing a class as public API, makes subclass-ability orthogonal to access control, and (admittedly as a bit of a swift-evolution process hack) asks the community for an in-depth discussion of the secondary points of the proposal: does it make sense to require every member to be marked as “overridable” in order to be overridden by an open subclass outside of the current module?<br></p><p>Personally I&#39;m fine with the proposal&#39;s original intent; public open gives a clear guarantee that overriding is okay, while plain public produces a warning encouraging developers to contact an API author if they choose to sub-class it anyway, as it may be unsafe. This lets them leave things nominally open, and address only the parts of their API that people actually want to sub-class, after all, predicting every possible use-case is a non-trivial challenge, and I think it&#39;s unreasonable to expect it of everyone.<br></p><p>That said, linters should probably highlight public declarations that lack open or final; if Xcode had a less obtrusive, purely informational, &quot;problem&quot; type then I&#39;d recommend that but that&#39;s a separate issue I think.<br></p><p>But yeah, I think it&#39;s important to avoid trying to force public open or public final only, as that could lead to bad habits with developers just defining whichever they feel is easiest, probably leading to loads of types that end up being final by default. Better IMO to let developers to define things the easy way first, then go back and decide what exactly needs to be sub-classable once any implementation issues have been resolved.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160715/243ab389/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 15, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;ll also stick with &quot;open&quot; for both class and methods and I believe<br>they should be required for both too. Just as I may not design a class<br>to be subclassable outside my library, I may not want to allow a<br>method to be overriden outside the library either (but I may want to<br>override it inside the library). It also produces a consistent<br>behaviour (sealed by default): if I have to mark a public class<br>subclassable, why allow every method in this class to be overridable<br>by default? If not, there would indeed be necessary the introduction<br>of the &quot;sealed&quot; keyword to ensure we could close overrides on those<br>public methods.<br></p><p>I&#39;m also not a fan of &quot;public(open)&quot; because that is how the language<br>seems poluted to me (&quot;public private(set)&quot; anyone? how is that clean?)<br>and I tend to avoid those at all cost.<br></p><p>L<br></p><p>On 15 July 2016 at 07:46, Haravikk via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On 14 Jul 2016, at 22:39, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; To sum this all up, the core team is rejecting this proposal and requesting<br>&gt; a revision to change the concrete syntax to “public open class Foo” instead<br>&gt; of “subclassable class Foo&quot;.<br>&gt;<br>&gt;<br>&gt; Minor point, but if we&#39;re going with the idea of public open and public<br>&gt; final for declaration, is it worth re-raising the idea of bracketed<br>&gt; accessibility modifiers? When fileprivate vs private was being discussed I<br>&gt; was heavily in favour of private(file), private(scope) and private(module)<br>&gt; (plus private(type) if we get that) to avoid polluting the language with<br>&gt; more accessibility-specific keywords. This seems like a good time to mention<br>&gt; it again, as we&#39;re now looking at even more keyword pollution:<br>&gt;<br>&gt; public(open)<br>&gt; public(sealed) // Probably not actually defined, but the default for a plain<br>&gt; &quot;public&quot; declaration<br>&gt; public(final)<br>&gt; private(module) // Replaces internal<br>&gt; private(file)<br>&gt; private(scope) // Default for plain private<br>&gt;<br>&gt; If we get a private(type) that&#39;s seven different keyword combinations for<br>&gt; one feature, so I still very much prefer it being reduced to just<br>&gt; public/private plus a modifier ;)<br>&gt;<br>&gt; This approach satisfies the *unwavering* goal of requiring additional<br>&gt; thought when publishing a class as public API, makes subclass-ability<br>&gt; orthogonal to access control, and (admittedly as a bit of a swift-evolution<br>&gt; process hack) asks the community for an in-depth discussion of the secondary<br>&gt; points of the proposal: does it make sense to require every member to be<br>&gt; marked as “overridable” in order to be overridden by an open subclass<br>&gt; outside of the current module?<br>&gt;<br>&gt;<br>&gt; Personally I&#39;m fine with the proposal&#39;s original intent; public open gives a<br>&gt; clear guarantee that overriding is okay, while plain public produces a<br>&gt; warning encouraging developers to contact an API author if they choose to<br>&gt; sub-class it anyway, as it may be unsafe. This lets them leave things<br>&gt; nominally open, and address only the parts of their API that people actually<br>&gt; want to sub-class, after all, predicting every possible use-case is a<br>&gt; non-trivial challenge, and I think it&#39;s unreasonable to expect it of<br>&gt; everyone.<br>&gt;<br>&gt; That said, linters should probably highlight public declarations that lack<br>&gt; open or final; if Xcode had a less obtrusive, purely informational,<br>&gt; &quot;problem&quot; type then I&#39;d recommend that but that&#39;s a separate issue I think.<br>&gt;<br>&gt; But yeah, I think it&#39;s important to avoid trying to force public open or<br>&gt; public final only, as that could lead to bad habits with developers just<br>&gt; defining whichever they feel is easiest, probably leading to loads of types<br>&gt; that end up being final by default. Better IMO to let developers to define<br>&gt; things the easy way first, then go back and decide what exactly needs to be<br>&gt; sub-classable once any implementation issues have been resolved.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Returned for revision] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 15 Jul 2016, at 12:46, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Jul 2016, at 22:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To sum this all up, the core team is rejecting this proposal and requesting a revision to change the concrete syntax to “public open class Foo” instead of “subclassable class Foo&quot;.  <br>&gt; <br>&gt; Minor point, but if we&#39;re going with the idea of public open and public final for declaration, is it worth re-raising the idea of bracketed accessibility modifiers? When fileprivate vs private was being discussed I was heavily in favour of private(file), private(scope) and private(module) (plus private(type) if we get that) to avoid polluting the language with more accessibility-specific keywords. This seems like a good time to mention it again, as we&#39;re now looking at even more keyword pollution:<br>&gt; <br>&gt; 	public(open)<br>&gt; 	public(sealed)		// Probably not actually defined, but the default for a plain &quot;public&quot; declaration<br>&gt; 	public(final)<br>&gt; 	private(module)	// Replaces internal<br>&gt; 	private(file)<br>&gt; 	private(scope)		// Default for plain private<br>&gt; <br>&gt; If we get a private(type) that&#39;s seven different keyword combinations for one feature, so I still very much prefer it being reduced to just public/private plus a modifier ;)<br></p><p>I think it makes sense to have it bracketed, but I’m not sure about replacing internal/private/fileprivate.<br></p><p>I’m thinking it should be:<br></p><p>public(open) class XYZ {}<br>public internal(open) class XYZ {}<br></p><p>Etc<br></p><p>I view it along the same lines as mutability for properties - I.e. “public private(set)”.<br></p><p>In that case, it would make sense to do the same for overridable members. You can only override members of an open class, so it makes sense to just use the “open” name in both places to denote that you may create your own versions of these things. An overriden method “is” an instance of the original method in the same way a derived class “is” an instance of its base class. My overriden “viewDidLoad” or whatever “is” the viewDidLoad for this class.<br></p><p>So to summarise, I think it should look like this (just showing off features, obviously it wouldn’t be okay to have public(open) members in an internal(open) class...):<br></p><p>public internal(open) XYZ {<br></p><p>    public private(set) var nonOverridable : Something<br>    public(open) var overridable : Something<br></p><p>    public(open) private(set) var getterOverridable : UIColor?   // In this case, the subclass can provide a value in its getter (e.g. backgroundColor) -<br>                                                                                                  // if it doesn’t (I.e. The type is optional), the base class may have a default value stored. I’m not sure… it’s an awkward one.<br></p><p>    public(open) func overridePointForSubclasses() {<br>        // Don’t you see so many functions named or documented like this? It’s nice that we’ll have them marked-up explicitly.<br>    }<br>}<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160716/933b272b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
