<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>stored properties in extensions (was: associated objects)</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>October 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I was thinking for reference types we would probably want to use the extra space in the refcount field (as discussed earlier in the thread).  For value types, we might want to have a single data structure (probably COW) holding all associated values for the value types on the stack frame.  That way, we don’t have to double the size of an Int if someone adds an associated value in one or two cases.  We only add a pointer size to the entire stack frame in the case where no value types have associated values.<br></p><p>Thoughts?<br></p><p>Thanks,<br>Jon<br></p><p>&gt; Karl, interesting point... perhaps a similar scheme could work for value<br>&gt; types (using the COW refcount)?<br>&gt; <br>&gt; On Thu, 13 Oct 2016 at 16:02 Karl Wagner &lt;razielim at gmail.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; That&#39;s great! I suppose the idea of allocating a bit of extra storage for<br>&gt; &gt; similar data in value types is some sort of heresy?<br>&gt; &gt;<br>&gt; &gt; Would there be a conceptual reason for that; which explains why it&#39;s okay<br>&gt; &gt; for reference-types but not for values? Personally I feel like it&#39;s a kind<br>&gt; &gt; of C legacy, due to performance and layout expectations that C sets about<br>&gt; &gt; value-types ¯\_(ツ)_/¯<br>&gt; &gt;<br>&gt; &gt; Karl<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt; On 12 Oct 2016, at 07:54, Greg Parker &lt;gparker at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Oct 11, 2016, at 3:02 PM, Jay Abbott via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Implementation idea No. 4:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; The basic concept is that the dynamic linker would fixup the offsets as<br>&gt; &gt; well as relocating the addersses, allowing the size of objects (and maybe<br>&gt; &gt; structs?) to change at link-time. The process might be something like this:<br>&gt; &gt;<br>&gt; &gt; * References to members defined in extensions would compile to have an<br>&gt; &gt; offset symbol instead of a value - so they can be fixed up later<br>&gt; &gt; * The linker would scan all the shared objects that are referenced (and<br>&gt; &gt; thus might get linked)<br>&gt; &gt; * Build up a list of Stored Properties In ExtensionS (SPIES, muhahaha) for<br>&gt; &gt; each class.<br>&gt; &gt; * Append the extra fields (increase the size the class), decide where each<br>&gt; &gt; member goes in the extended layout and fixup the offsets<br>&gt; &gt; * Carry on with normal relocation<br>&gt; &gt;<br>&gt; &gt; There are quite a few assumptions in the above, and probably quite a few<br>&gt; &gt; misunderstandings about how things work on my part too (I&#39;m not an expert<br>&gt; &gt; at this), however I think it should work in principle. Some questions about<br>&gt; &gt; my assumptions: Can linker know in advance all the potential modules that<br>&gt; &gt; could be linked, or is this done more lazily and it only knows about what<br>&gt; &gt; it&#39;s linking right now? Is it ok for the size to change - I don&#39;t know if<br>&gt; &gt; it&#39;s a static sizeof() or if it could be (or already is) stored in the isa?<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; This sort of scheme isn&#39;t dynamic enough. The worst-case is a extension in<br>&gt; &gt; a library that gets dlopen()ed at runtime on a class that is already<br>&gt; &gt; loaded. The build-time linker can&#39;t know anything about it. The loader and<br>&gt; &gt; the runtime will see it, but at that point the class may already be in use<br>&gt; &gt; and may already have instances allocated. If you want to handle the<br>&gt; &gt; dlopen() case then you need some way to add storage to arbitrary objects<br>&gt; &gt; that have already been allocated.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Ole Begemann wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; For what it&#39;s worth, Greg Parker (Cc&#39;ed) started a discussion back in<br>&gt; &gt; March that I think is relevant here:<br>&gt; &gt; https://lists.swift.org/pipermail/swift-dev/Week- &lt;https://lists.swift.org/pipermail/swift-dev/Week-&gt;<br>&gt; &gt; of-Mon-20160314/001424.html<br>&gt; &gt;<br>&gt; &gt; Here&#39;s the relevant part:<br>&gt; &gt;<br>&gt; &gt; &quot;I am considering a new representation for Swift refcounts and other<br>&gt; &gt; per-object data. This is an outline of the scheme. Comments and suggestions<br>&gt; &gt; welcome.<br>&gt; &gt;<br>&gt; &gt; Today, each object stores 64-bits of refcounts and flags after the isa<br>&gt; &gt; field.<br>&gt; &gt;<br>&gt; &gt; In this new system, each object would store a pointer-size field after the<br>&gt; &gt; isa field. This field would have two cases: it could store refcounts and<br>&gt; &gt; flags, or it could store a pointer to a side allocation that would store<br>&gt; &gt; refcounts and flags and additional per-object data.<br>&gt; &gt;<br>&gt; &gt; Advantages:<br>&gt; &gt; …<br>&gt; &gt; * Allows inexpensive per-object storage for future features like<br>&gt; &gt; associated references or class extensions with instance variables.<br>&gt; &gt; …&quot;<br>&gt; &gt;<br>&gt; &gt; I don&#39;t know the current status of this idea (implemented? planned?<br>&gt; &gt; abandoned?). Also, it&#39;s worth noting that this would only apply to classes,<br>&gt; &gt; not value types.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; I&#39;m working on this right now:<br>&gt; &gt; https://github.com/gparker42/swift/tree/new-refcount-representation &lt;https://github.com/gparker42/swift/tree/new-refcount-representation&gt;<br>&gt; &gt;<br>&gt; &gt; If it goes well it will provide the runtime implementation space needed<br>&gt; &gt; for associated objects or stored properties in extensions. Such storage<br>&gt; &gt; would be less efficient than &quot;real&quot; stored properties. Any object with that<br>&gt; &gt; storage attached would also suffer additional performance penalties to<br>&gt; &gt; refcounting and deallocation. On the plus side there is no memory penalty<br>&gt; &gt; to objects that don&#39;t have additional storage, and there is no contention<br>&gt; &gt; over a big global association table like there is in Objective-C&#39;s<br>&gt; &gt; associated object implementation.<br>&gt; &gt;<br>&gt; &gt; Note that the runtime implementation is not the only problem. The<br>&gt; &gt; optimizer folks hate the fact that stored properties in extensions defeat<br>&gt; &gt; the compiler&#39;s visibility into the deinit behavior of all types, even if<br>&gt; &gt; most types are unaffected at runtime.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Greg Parker     gparker at apple.com &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;     Runtime Wrangler<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161013/d3cf4ddc/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
