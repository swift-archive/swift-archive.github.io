<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br></p><p>Félix<br></p><p>Treat uniform tuples as collections<br></p><p>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>Author(s): Swift Developer &lt;https://github.com/swiftdev&gt;<br>Status: Awaiting review<br>Review manager: TBD<br></p><p>Introduction<br></p><p>This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br></p><p>Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009520.html&gt;<br>Motivation<br></p><p>Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br></p><p><br>Proposed solution<br></p><p>This proposal suggests adding CollectionType conformance to uniform tuples.<br></p><p><br>Detailed design<br></p><p>Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br></p><p>Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>Index: Int.<br>SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>count: the number of elements in the tuple.<br>first: tuple.0<br>isEmpty: false<br>subscript(_: Self.Index): single element at given index. Bounds-checked.<br>subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>startIndex: 0.<br>endIndex: count.<br>It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br></p><p><br>Impact on existing code<br></p><p>No impact on existing code; the feature is purely additive.<br></p><p><br>Alternatives considered<br></p><p>A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br></p><p>The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br></p><p>It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/ce8036fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 11, 2016 at 07:00:00pm</p></header><div class="content"><p>Looks good to me! <br></p><p>I’m all for keeping the static field access, too, because dropping it would mean having two very different kinds of tuples.<br></p><p>If Swift should ever get union types this proposal can seamlessly be extended to heterogenous tuples which would then conform to CollectionType like proposed but just with an Element type equal to the union of all types present in the tuple.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 11.02.2016 um 18:12 schrieb Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; Treat uniform tuples as collections<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br>&gt; <br>&gt; Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009520.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal suggests adding CollectionType conformance to uniform tuples.<br>&gt; <br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br>&gt; <br>&gt; Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>&gt; Index: Int.<br>&gt; SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>&gt; count: the number of elements in the tuple.<br>&gt; first: tuple.0<br>&gt; isEmpty: false<br>&gt; subscript(_: Self.Index): single element at given index. Bounds-checked.<br>&gt; subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>&gt; startIndex: 0.<br>&gt; endIndex: count.<br>&gt; It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; No impact on existing code; the feature is purely additive.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br>&gt; <br>&gt; The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br>&gt; <br>&gt; It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/0e2445b4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February 11, 2016 at 11:00:00am</p></header><div class="content"><p>I know their syntaxes are different, but aside from &quot;cleverness&quot; involving a union&#39;s memory layout and such, what can you do with a union that you can&#39;t do with an enum w/ associated values?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 11, 2016, at 10:35, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If Swift should ever get union types this proposal can seamlessly be extended to heterogenous tuples which would then conform to CollectionType like proposed but just with an Element type equal to the union of all types present in the tuple.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 11.02.2016 um 18:12 schrieb Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; Treat uniform tuples as collections<br>&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt; Author(s): Swift Developer<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal suggests adding CollectionType conformance to uniform tuples.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br>&gt;&gt; <br>&gt;&gt; Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>&gt;&gt; Index: Int.<br>&gt;&gt; SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>&gt;&gt; count: the number of elements in the tuple.<br>&gt;&gt; first: tuple.0<br>&gt;&gt; isEmpty: false<br>&gt;&gt; subscript(_: Self.Index): single element at given index. Bounds-checked.<br>&gt;&gt; subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>&gt;&gt; startIndex: 0.<br>&gt;&gt; endIndex: count.<br>&gt;&gt; It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; No impact on existing code; the feature is purely additive.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br>&gt;&gt; <br>&gt;&gt; The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br>&gt;&gt; <br>&gt;&gt; It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/6663803c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 12, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 11.02.2016 um 20:30 schrieb David Sweeris &lt;davesweeris at mac.com&gt;:<br>&gt; <br>&gt; I know their syntaxes are different, but aside from &quot;cleverness&quot; involving a union&#39;s memory layout and such, what can you do with a union that you can&#39;t do with an enum w/ associated values?<br></p><p>This, for example:<br></p><p>interface Set&lt;These&gt; {<br>    shared formal Set&lt;These | Those&gt; union&lt;Those&gt;(Set&lt;Those&gt; set);<br>    shared formal Set&lt;These &amp; Those&gt; intersection&lt;Those&gt;(Set&lt;Those&gt; set);<br>}<br></p><p>Taken from Gavin King&#39;s talk (idiom #7 and #8) here: <br>https://1bee51e9-a-62cb3a1a-s-sites.googlegroups.com/site/jugffm/home/04062014-ceylon-introduction/Ceylon%20German%20JUGs.pdf<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 10:35, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If Swift should ever get union types this proposal can seamlessly be extended to heterogenous tuples which would then conform to CollectionType like proposed but just with an Element type equal to the union of all types present in the tuple.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 11.02.2016 um 18:12 schrieb Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Félix<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Treat uniform tuples as collections<br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Author(s): Swift Developer<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal suggests adding CollectionType conformance to uniform tuples.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>&gt;&gt;&gt; Index: Int.<br>&gt;&gt;&gt; SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>&gt;&gt;&gt; count: the number of elements in the tuple.<br>&gt;&gt;&gt; first: tuple.0<br>&gt;&gt;&gt; isEmpty: false<br>&gt;&gt;&gt; subscript(_: Self.Index): single element at given index. Bounds-checked.<br>&gt;&gt;&gt; subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>&gt;&gt;&gt; startIndex: 0.<br>&gt;&gt;&gt; endIndex: count.<br>&gt;&gt;&gt; It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No impact on existing code; the feature is purely additive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/e0a28870/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 11, 2016 at 10:00:00am</p></header><div class="content"><p>Making tuples or other structural types able to conform to protocols has some implementation challenges—after all, we&#39;d also like some tuples to ultimately be Equatable/Hashable/Comparable as well.  Making homogeneous tuples subscriptable is easy progress that moves us in the right direction; we can consider protocol conformances later.<br></p><p>-Joe<br></p><p>&gt; On Feb 11, 2016, at 9:12 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt; Treat uniform tuples as collections<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br>&gt; <br>&gt; Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009520.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal suggests adding CollectionType conformance to uniform tuples.<br>&gt; <br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br>&gt; <br>&gt; Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>&gt; Index: Int.<br>&gt; SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>&gt; count: the number of elements in the tuple.<br>&gt; first: tuple.0<br>&gt; isEmpty: false<br>&gt; subscript(_: Self.Index): single element at given index. Bounds-checked.<br>&gt; subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>&gt; startIndex: 0.<br>&gt; endIndex: count.<br>&gt; It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; No impact on existing code; the feature is purely additive.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br>&gt; <br>&gt; The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br>&gt; <br>&gt; It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/2fc0f55d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>February 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 9:12 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br>This specific proposal is a non-starter for me, because it lands squarely in the &quot;death valley&quot; of being extremely invasive on the implementation while providing only a small amount of relative value.<br></p><p>Swift’s implementation—from semantic analysis through SIL and the runtime—assume that the only types that can conform to protocols are so-called “nominal” types, which have names that are meaningful in the runtime. Swift’s nominal types are structs, classes, enums, and protocols. Compound types such as functions, tuples, and protocol compositions, as well as aliases of types (typealiases), are not nominal. It is absolutely possible to generalize Swift’s implementation to deal with non-nominal types that conform to protocols, but it is going to be a significant amount of work across the compiler and runtime. That work is way out of scope of Swift 3, and needs to be justified by major improvements to the language.<br></p><p>Making some class of tuples conform to CollectionType isn’t a big enough justification. Giving me the ability, as a user, to extend tuple types to make them conform to a particular protocol myself might be big enough. For example, if I combined that with some kind of variadic generics, parameterized extensions, and conditional conformances, I could express “make any tuple of Hashable types Hashable”:<br></p><p>extension&lt;T... where T : Hashable...&gt; (T...) : Hashable {<br>  var hashValue: Int {<br>    return combineHash(self.hashValue...)<br>  }<br>}<br></p><p>I’m appropriating the syntax of C++11 variadic templates for this example, but essentially ’T’ is acting as a bunch of separate type parameters that can be expanded into separate type arguments with “T…”. While the syntax doesn’t matter so much, there is significant user-level impact here: one could use tuples as keys of a Dictionary or elements of a Set, make tuples conform to protocols for serialization, and so on.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Félix<br>&gt; <br>&gt; Treat uniform tuples as collections<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt; Author(s): Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br>&gt; <br>&gt; Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009520.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br>&gt; <br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; This proposal suggests adding CollectionType conformance to uniform tuples.<br>&gt; <br>&gt; <br>&gt; Detailed design<br>&gt; <br>&gt; Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br>&gt; <br>&gt; Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>&gt; Index: Int.<br>&gt; SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>&gt; count: the number of elements in the tuple.<br>&gt; first: tuple.0<br>&gt; isEmpty: false<br>&gt; subscript(_: Self.Index): single element at given index. Bounds-checked.<br>&gt; subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>&gt; startIndex: 0.<br>&gt; endIndex: count.<br>&gt; It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br>&gt; <br>&gt; <br>&gt; Impact on existing code<br>&gt; <br>&gt; No impact on existing code; the feature is purely additive.<br>&gt; <br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br>&gt; <br>&gt; The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br>&gt; <br>&gt; It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/c90f6586/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>February 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 12:59 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 9:12 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br>&gt; This specific proposal is a non-starter for me, because it lands squarely in the &quot;death valley&quot; of being extremely invasive on the implementation while providing only a small amount of relative value.<br>&gt; <br>&gt; Swift’s implementation—from semantic analysis through SIL and the runtime—assume that the only types that can conform to protocols are so-called “nominal” types, which have names that are meaningful in the runtime. Swift’s nominal types are structs, classes, enums, and protocols. Compound types such as functions, tuples, and protocol compositions, as well as aliases of types (typealiases), are not nominal. It is absolutely possible to generalize Swift’s implementation to deal with non-nominal types that conform to protocols, but it is going to be a significant amount of work across the compiler and runtime. That work is way out of scope of Swift 3, and needs to be justified by major improvements to the language.<br>&gt; <br>&gt; Making some class of tuples conform to CollectionType isn’t a big enough justification. Giving me the ability, as a user, to extend tuple types to make them conform to a particular protocol myself might be big enough. For example, if I combined that with some kind of variadic generics, parameterized extensions, and conditional conformances, I could express “make any tuple of Hashable types Hashable”:<br>&gt; <br>&gt; extension&lt;T... where T : Hashable...&gt; (T...) : Hashable {<br>&gt;   var hashValue: Int {<br>&gt;     return combineHash(self.hashValue...)<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; I’m appropriating the syntax of C++11 variadic templates for this example, but essentially ’T’ is acting as a bunch of separate type parameters that can be expanded into separate type arguments with “T…”. While the syntax doesn’t matter so much, there is significant user-level impact here: one could use tuples as keys of a Dictionary or elements of a Set, make tuples conform to protocols for serialization, and so on.<br></p><p>+1 to eventually having this kind of flexibility.  But I agree that baking special cases into the language itself is not necessary.  It can wait until we can have the general capability.<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt; Treat uniform tuples as collections<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;<br>&gt;&gt; Author(s): Swift Developer &lt;https://github.com/swiftdev&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal aims at adding collection operations to uniform tuples: tuples in which every element has the same type, and no element has a label.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Proposal: Contiguous Variables (A.K.A. Fixed Sized Array Type) &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160208/009520.html&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Fixed-size arrays in C structures are imported as tuples. This means that on the Swift side, developers therefore lose the ability to use even the most basic collection type operations on them, like subscripts. When collection operations are needed, it is usually necessary to transform the tuple into a full-fledged Swift Array using unsafe pointers.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; This proposal suggests adding CollectionType conformance to uniform tuples.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Any tuple of more than one element, in which every element has the same type, is eligible for CollectionType conformance. CollectionType elements are generated as such:<br>&gt;&gt; <br>&gt;&gt; Generator: opaque. Possibly based off UnsafeBufferPointers, possibly the same for all uniform tuples (to a generic parameter).<br>&gt;&gt; Index: Int.<br>&gt;&gt; SubSequence: Array, since tuples are value types and cannot be shared without being copied wholesale anyway, and the dynamic nature of SubSequence means that it usually is impossible to simply return a smaller tuple (whose size has to be known at compile-time).<br>&gt;&gt; count: the number of elements in the tuple.<br>&gt;&gt; first: tuple.0<br>&gt;&gt; isEmpty: false<br>&gt;&gt; subscript(_: Self.Index): single element at given index. Bounds-checked.<br>&gt;&gt; subscript(_: Range&lt;Self.Index&gt;): sub-sequence Array. Bounds-checked.<br>&gt;&gt; startIndex: 0.<br>&gt;&gt; endIndex: count.<br>&gt;&gt; It is worth noting that uniform tuples do not lose static field access. This avoids needlessly breaking existing code and allows developers to bypass bounds-checking for indices known to be safe.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; No impact on existing code; the feature is purely additive.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A simpler syntax to declare uniform tuples from Swift, like (Int x 4), was found to be contentious. This proposal forks off the original for incremental implementation of the feature.<br>&gt;&gt; <br>&gt;&gt; The original proposal only called for a subscript on uniform tuples. Adding full CollectionType support seemed simple enough and useful enough to suggest it.<br>&gt;&gt; <br>&gt;&gt; It was suggested that uniform tuples should lose their static field access syntax to ensure that there is Just One Way to access tuple elements. However, this could have surprising side effects on existing code and wouldn&#39;t be possible with generic code.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/d7ec5ace/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 11, 2016, at 10:59 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 11, 2016, at 9:12 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br>&gt; This specific proposal is a non-starter for me, because it lands squarely in the &quot;death valley&quot; of being extremely invasive on the implementation while providing only a small amount of relative value.<br></p><p>I agree with Doug on this.  I still think the right approach is to:<br></p><p>1) add a subscript on tuples with a consistent element kind.<br>2) add some type sugar for defining these types<br>3) consider a convenient form for defining an initializer on these.<br></p><p>To me, that is the order of priority.  Just getting #1 and #2 would seriously move the needle on making C arrays work better, with very little implementation complexity.  #3 would be nice, but seems less important.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/67d94d3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February 11, 2016 at 05:00:00pm</p></header><div class="content"><p>How realistic is it to also have a `count` getter? If we can&#39;t have `for elem in tuple`, at least that would allow `for i in 0..&lt;tuple.count`.<br></p><p>Félix<br></p><p>&gt; Le 11 févr. 2016 à 15:38:07, Chris Lattner &lt;clattner at apple.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 11, 2016, at 10:59 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 11, 2016, at 9:12 AM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since the original fixed-size array thread is somewhat stalling, I forked off the subscript part into this: Treat uniform tuples as collections &lt;https://github.com/zneak/swift-evolution/blob/uniform-tuples/proposals/00nn-collectiontype-for-tuples.md&gt;<br>&gt;&gt; This specific proposal is a non-starter for me, because it lands squarely in the &quot;death valley&quot; of being extremely invasive on the implementation while providing only a small amount of relative value.<br>&gt; <br>&gt; I agree with Doug on this.  I still think the right approach is to:<br>&gt; <br>&gt; 1) add a subscript on tuples with a consistent element kind.<br>&gt; 2) add some type sugar for defining these types<br>&gt; 3) consider a convenient form for defining an initializer on these.<br>&gt; <br>&gt; To me, that is the order of priority.  Just getting #1 and #2 would seriously move the needle on making C arrays work better, with very little implementation complexity.  #3 would be nice, but seems less important.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160211/281ff5e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>CollectionType on uniform tuples [forked off Contiguous Variables]</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; How realistic is it to also have a `count` getter? If we can&#39;t have `for elem in tuple`, at least that would allow `for i in 0..&lt;tuple.count`.<br></p><p>I do want a way to get the count (or you could call it the arity, doesn&#39;t really matter). The syntax is a bit of an issue, though. Four suggestions, each annotated with its flaw:<br></p><p>	typealias FourInts = (4 x Int)<br>	let fourInts = (1, 2, 3, 4)<br>	<br>	fourInts.arity		// might interfere with tuples that have an element labeled `arity`<br>	FourInts.arity		// didn&#39;t someone say SIL has trouble with things like properties on compound types?<br>	arity(FourInts)		// this is known at compile time, no need for a runtime function call<br>	#arity(FourInts)	// hash is kind of gross, and I&#39;m currently suspicious of all hash proposals<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
