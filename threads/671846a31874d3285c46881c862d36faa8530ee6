<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June  4, 2016 at 10:00:00pm</p></header><div class="content"><p>Hello, everyone.<br></p><p>I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br></p><p>https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a &lt;https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a&gt;<br></p><p>The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br></p><p>Cheers, <br>Paulo<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/67180ee6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June  4, 2016 at 10:00:00pm</p></header><div class="content"><p>You forgot one :-)<br>let capitalizedA = ModuleA {<br>    &quot;hello swift&quot;.capitalized()<br>}<br></p><p>+1 on finding a way to explicitly resolve naming collisions. I&#39;m generally in favor of something like #2 (or #3). A while back, there was a proposal to replace numerical operator precedence with a relative precedence system. I can&#39;t remember if it went through, but if so I would argue that the two systems should probably be the same, since they solve the same problem.<br></p><p>I would also suggest there be a way to import a module at a lower precedence than the current source file, for the purposes of &quot;overriding&quot; any top-level functions (or even types, I suppose).<br></p><p>Something like &quot;partially import ModuleA&quot; would solve the problem as well, but I can&#39;t think of anything resembling a practical syntax for specifying which parts.<br></p><p>- Dave Sweeris <br></p><p>&gt; On Jun 4, 2016, at 20:29, Paulo Faria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, everyone.<br>&gt; <br>&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt; <br>&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a<br>&gt; <br>&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt; <br>&gt; Cheers, <br>&gt; Paulo<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/d2587349/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  5, 2016 at 08:00:00am</p></header><div class="content"><p>IMO you have identified some of the symptoms of a larger issue with Swift. <br></p><p>Currently swift lets us group our code into modules. Within a module we can use folders to physically group the files, but this is not mandatory (and xcode does not by default align the logical and physical structure of a project). My observation of most github projects i read is that people struggle to organize the code, often resorting to adopting a black-socks with black-socks approach (extensions together, structs together...).<br></p><p>The result is that swift is great for small apps or libraries, but not so much for large amounts of code written by several people, when compared to what can be done with scala, java, c++, c#, kotlin, and even typescript. <br></p><p>Rather than the proposed solution, I would much rather see swift acquire sub-scoping inside modules (call it sub module or namespace) with local imports. I think addressing the symptomes by prioritizing imports will only make it easier to write more disorganized code.<br></p><p><br>&gt; On Jun 5, 2016, at 3:29 AM, Paulo Faria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello, everyone.<br>&gt; <br>&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt; <br>&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a<br>&gt; <br>&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt; <br>&gt; Cheers, <br>&gt; Paulo<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/ab076ba9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June  6, 2016 at 10:00:00am</p></header><div class="content"><p>Actually I don’t like the prioritization of the modules import. I’m much more in favor of disambiguating at call site. like we have to do in any other case of ambiguity in Swift. The concept of precedence is only present in operators and that makes sense because it’s in their nature. I think #4 or #5 or any other way to disambiguate at call site would be the most appropriate.<br></p><p><br></p><p>&gt; On Jun 4, 2016, at 10:29 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt; Hello, everyone.<br>&gt; <br>&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt; <br>&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a &lt;https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a&gt;<br>&gt; <br>&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt; <br>&gt; Cheers, <br>&gt; Paulo<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/6ac43442/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br></p><p>My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br></p><p>I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br></p><p>str.(ModuleA.capitalized)()<br></p><p>which I think has come up on-thread already. (It’s close to Paul’s &#39;::&#39;, anyway.)<br></p><p>A bonus is if we can use this same thing for globals. We have a problem today where “Foo.Bar” can’t refer to a member of a module if there’s also a type named “Foo”; changing the syntax to “Foo::Bar” or “Bar from Foo” (or adding it as an alternative) would solve that problem and provide consistency.<br></p><p>Sorry I don’t have anything too conclusive to add. My last point is that while we do have a problem today, it’s a problem we’ve lived with for two years, and any features we add to solve it are additive. That means it’s okay if we don’t come up with an answer in Swift 3.<br></p><p>Jordan<br></p><p><br>&gt; On Jun 6, 2016, at 06:47, Paulo Faria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Actually I don’t like the prioritization of the modules import. I’m much more in favor of disambiguating at call site. like we have to do in any other case of ambiguity in Swift. The concept of precedence is only present in operators and that makes sense because it’s in their nature. I think #4 or #5 or any other way to disambiguate at call site would be the most appropriate.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 4, 2016, at 10:29 PM, Paulo Faria &lt;paulo at zewo.io &lt;mailto:paulo at zewo.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello, everyone.<br>&gt;&gt; <br>&gt;&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a &lt;https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a&gt;<br>&gt;&gt; <br>&gt;&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt;&gt; <br>&gt;&gt; Cheers, <br>&gt;&gt; Paulo<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/39092e42/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 08:00:00am</p></header><div class="content"><p>C# has scoped imports to deal with this. I like it... (I went back to c# until swift 3 or 4 get more feature complete).<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt; <br>&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt; <br>&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt; <br>&gt; str.(ModuleA.capitalized)()<br>&gt; <br>&gt; which I think has come up on-thread already. (It’s close to Paul’s &#39;::&#39;, anyway.)<br>&gt; <br>&gt; A bonus is if we can use this same thing for globals. We have a problem today where “Foo.Bar” can’t refer to a member of a module if there’s also a type named “Foo”; changing the syntax to “Foo::Bar” or “Bar from Foo” (or adding it as an alternative) would solve that problem and provide consistency.<br>&gt; <br>&gt; Sorry I don’t have anything too conclusive to add. My last point is that while we do have a problem today, it’s a problem we’ve lived with for two years, and any features we add to solve it are additive. That means it’s okay if we don’t come up with an answer in Swift 3.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 6, 2016, at 06:47, Paulo Faria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Actually I don’t like the prioritization of the modules import. I’m much more in favor of disambiguating at call site. like we have to do in any other case of ambiguity in Swift. The concept of precedence is only present in operators and that makes sense because it’s in their nature. I think #4 or #5 or any other way to disambiguate at call site would be the most appropriate.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 4, 2016, at 10:29 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello, everyone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers, <br>&gt;&gt;&gt; Paulo<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/f4fd564c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; A bonus is if we can use this same thing for globals. We have a problem today where “Foo.Bar” can’t refer to a member of a module if there’s also a type named “Foo”; changing the syntax to “Foo::Bar” or “Bar from Foo” (or adding it as an alternative) would solve that problem and provide consistency.<br></p><p>So you mean the syntax for module namespacing would be “::” for everything? Yeah that would probably solve some other related problems as well. I’m not very fond of the “::” separator. But yeah, I think a different separator would be better than the “from” keyword, then. Maybe we can come up with a nicer separator? the options I can think of are (in order of preference):<br></p><p>Foo:Bar<br>Foo::Bar<br>Foo#Bar<br>Foo at Bar<br></p><p>Anything too different from this would be too exotic. Would there be too much problem with a single colon “:”?<br></p><p>struct Baz: Foo:Bar {<br>  ...<br>}<br></p><p>let dictionary: [Swift:String: Foo:Bar] = [:]<br></p><p>I’m sensing yes. :(<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt; <br>&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt; <br>&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt; <br>&gt; str.(ModuleA.capitalized)()<br>&gt; <br></p><p>Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br></p><p>public static func capitalized(self:String)() {}    <br></p><p>Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br></p><p>No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br></p><p>&gt; which I think has come up on-thread already. (It’s close to Paul’s &#39;::&#39;, anyway.)<br>&gt; <br>&gt; A bonus is if we can use this same thing for globals. We have a problem today where “Foo.Bar” can’t refer to a member of a module if there’s also a type named “Foo”; changing the syntax to “Foo::Bar” or “Bar from Foo” (or adding it as an alternative) would solve that problem and provide consistency.<br>&gt; <br>&gt; Sorry I don’t have anything too conclusive to add. My last point is that while we do have a problem today, it’s a problem we’ve lived with for two years, and any features we add to solve it are additive. That means it’s okay if we don’t come up with an answer in Swift 3.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 6, 2016, at 06:47, Paulo Faria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Actually I don’t like the prioritization of the modules import. I’m much more in favor of disambiguating at call site. like we have to do in any other case of ambiguity in Swift. The concept of precedence is only present in operators and that makes sense because it’s in their nature. I think #4 or #5 or any other way to disambiguate at call site would be the most appropriate.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 4, 2016, at 10:29 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello, everyone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers, <br>&gt;&gt;&gt; Paulo<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/05614338/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br></p><p>Care to explain a bit more what you mean with this? What is the improper  “understandment” and what would be the proper “understandment”?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 4:41 PM, Paulo Faria &lt;paulo at zewo.io&gt; wrote:<br>&gt; <br>&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt; <br>&gt; Care to explain a bit more what you mean with this? What is the improper  “understandment” and what would be the proper “understandment”?<br></p><p>IMVHO much of the extension code I saw was people cramming a lot of their business code inside UIView derivative extensions. Another use case I saw a lot was utility methods following the pattern of <br>	“http://www.whattheheck.com”<br>			.connect()<br>			.lookMaIcanWriteAnEntire()<br>			.applicationWithout()<br>			.havingTo()<br>			.promise(ToThinkTooMuch().aboutIt());<br></p><p>this is just an illustration, but we have all seen this, right?!<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/12ad2022/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt; <br>&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt; <br>&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt; <br>&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt; <br>&gt; <br>&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt; <br>&gt; public static func capitalized(self:String)() {}    <br>&gt; <br>&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt; <br>&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br></p><p>I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/5056049b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt; <br>&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt; <br>&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt; <br>&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt; <br>&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt; <br></p><p>sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br></p><p><br>This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>namespace HtmlAgilityPackPlus {<br>    using HtmlAgilityPack;<br></p><p>    public static class Extender {<br>        public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>            var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>            return n;<br>        }         <br>        public static HtmlNode FirstLink(this HtmlNode node) {<br>            var child = node.ChildOfType(&quot;a&quot;);<br>            return child;<br>        }<br>        public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>            var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>            return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>        }<br>    }<br>}<br></p><p>XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br></p><p><br>Now this is some Swift code (yes I am not bothering with the details)<br>module A ===<br></p><p>extension String {<br>    func oneA() {  }<br>    func twoA() {  }<br>    func threeA() {  }<br>}<br></p><p><br>module B ===<br></p><p>extension String {<br>    func oneB() {  }<br>    func twoB() {  }<br>    func threeB() {  }<br>}<br></p><p>We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>first a target type is decided by forming a scope<br>then many extension methods can be added together<br>Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>anonymity of the source<br>batch adds<br></p><p>as you can see, this is not how C# works.<br></p><p>So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br></p><p><br>My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br></p><p>This led to my proposal to ALSO support (not REPLACE) <br></p><p>module A ===<br>extension String {<br>    func oneA() {  }<br>    func twoA() {  }<br>    func threeA() {  }<br>}<br>// more like the GO syntax<br>public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br></p><p><br>module B ===<br>extension String {<br>    func oneB() {  }<br>    func twoB() {  }<br>    func threeB() {  }<br>}<br>// more like the c#/XText/XTend/... syntax<br>public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br></p><p>because we can now do the following without altering anything<br></p><p>import func moduleA.indexOfSubStringInReversedOrder<br>var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/27feb999/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 10:46, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt; <br>&gt; <br>&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt; <br>&gt; <br>&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt; namespace HtmlAgilityPackPlus {<br>&gt;     using HtmlAgilityPack;<br>&gt; <br>&gt;     public static class Extender {<br>&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;             return n;<br>&gt;         }         <br>&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;             return child;<br>&gt;         }<br>&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt; <br>&gt; <br>&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt; module A ===<br>&gt; <br>&gt; extension String {<br>&gt;     func oneA() {  }<br>&gt;     func twoA() {  }<br>&gt;     func threeA() {  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; module B ===<br>&gt; <br>&gt; extension String {<br>&gt;     func oneB() {  }<br>&gt;     func twoB() {  }<br>&gt;     func threeB() {  }<br>&gt; }<br>&gt; <br>&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt; first a target type is decided by forming a scope<br>&gt; then many extension methods can be added together<br>&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt; anonymity of the source<br>&gt; batch adds<br>&gt; <br>&gt; as you can see, this is not how C# works.<br>&gt; <br>&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt; <br>&gt; <br>&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt; <br>&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt; <br>&gt; module A ===<br>&gt; extension String {<br>&gt;     func oneA() {  }<br>&gt;     func twoA() {  }<br>&gt;     func threeA() {  }<br>&gt; }<br>&gt; // more like the GO syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt; <br>&gt; <br>&gt; module B ===<br>&gt; extension String {<br>&gt;     func oneB() {  }<br>&gt;     func twoB() {  }<br>&gt;     func threeB() {  }<br>&gt; }<br>&gt; // more like the c#/XText/XTend/... syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt; <br>&gt; because we can now do the following without altering anything<br>&gt; <br>&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br></p><p>This would let you pick one to prefer for the entire file, but still doesn’t let you refer to both methods in the same file. I consider anything like that to be an added feature, not the core one we’re missing.<br></p><p>(I happen to be strongly against this change, but I don’t think it’s relevant at the moment.)<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/57e26366/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>following on my last email: see down<br></p><p>&gt; On Jun 9, 2016, at 7:46 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt; <br>&gt; <br>&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt; <br>&gt; <br>&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt; namespace HtmlAgilityPackPlus {<br>&gt;     using HtmlAgilityPack;<br>&gt; <br>&gt;     public static class Extender {<br>&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;             return n;<br>&gt;         }         <br>&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;             return child;<br>&gt;         }<br>&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt; <br>&gt; <br>&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt; module A ===<br>&gt; <br>&gt; extension String {<br>&gt;     func oneA() {  }<br>&gt;     func twoA() {  }<br>&gt;     func threeA() {  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; module B ===<br>&gt; <br>&gt; extension String {<br>&gt;     func oneB() {  }<br>&gt;     func twoB() {  }<br>&gt;     func threeB() {  }<br>&gt; }<br>&gt; <br>&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt; first a target type is decided by forming a scope<br>&gt; then many extension methods can be added together<br>&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt; anonymity of the source<br>&gt; batch adds<br>&gt; <br>&gt; as you can see, this is not how C# works.<br>&gt; <br>&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt; <br>&gt; <br>&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt; <br>&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt; <br>&gt; module A ===<br>&gt; extension String {<br>&gt;     func oneA() {  }<br>&gt;     func twoA() {  }<br>&gt;     func threeA() {  }<br>&gt; }<br>&gt; // more like the GO syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt; <br>&gt; <br>&gt; module B ===<br>&gt; extension String {<br>&gt;     func oneB() {  }<br>&gt;     func twoB() {  }<br>&gt;     func threeB() {  }<br>&gt; }<br>&gt; // more like the c#/XText/XTend/... syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt; <br>&gt; because we can now do the following without altering anything<br>&gt; <br>&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br></p><p>then it is possible to <br>use extension blocks for adapter pattern / protocol compliance <br>use extension methods for small one-of helper bits that need precise identification<br></p><p>everyone happy :)  -  even the person writing the code in the compiler  [I think the first syntax is easier to parse () () ]<br></p><p><br>&gt; // more like the GO syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}   // more parsing before being sure<br>&gt; public static func indexOfSubStringInReversedOrder(String)(pattern:String) -&gt; Int {}    	// less parsing to identify it<br>&gt; <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/1153706a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 19:46 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt; <br>&gt; <br>&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt; <br>&gt; <br>&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt; namespace HtmlAgilityPackPlus {<br>&gt;     using HtmlAgilityPack;<br>&gt; <br>&gt;     public static class Extender {<br>&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;             return n;<br>&gt;         }         <br>&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;             return child;<br>&gt;         }<br>&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt; <br>&gt; <br>&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt; module A ===<br>&gt; <br>&gt; extension String {<br>&gt;     func oneA() {  }<br>&gt;     func twoA() {  }<br>&gt;     func threeA() {  }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; module B ===<br>&gt; <br>&gt; extension String {<br>&gt;     func oneB() {  }<br>&gt;     func twoB() {  }<br>&gt;     func threeB() {  }<br>&gt; }<br>&gt; <br>&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt; first a target type is decided by forming a scope<br>&gt; then many extension methods can be added together<br>&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt; anonymity of the source<br>&gt; batch adds<br>&gt; <br>&gt; as you can see, this is not how C# works.<br>&gt; <br>&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt; <br>&gt; <br>&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt; <br>&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt; <br>&gt; module A ===<br>&gt; extension String {<br>&gt;     func oneA() {  }<br>&gt;     func twoA() {  }<br>&gt;     func threeA() {  }<br>&gt; }<br>&gt; // more like the GO syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt; <br>&gt; <br>&gt; module B ===<br>&gt; extension String {<br>&gt;     func oneB() {  }<br>&gt;     func twoB() {  }<br>&gt;     func threeB() {  }<br>&gt; }<br>&gt; // more like the c#/XText/XTend/... syntax<br>&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt; <br>&gt; because we can now do the following without altering anything<br>&gt; <br>&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br>&gt; _______________________________________________<br></p><p><br>What hinders me in the case of Swift’s extensions to write<br></p><p>import func moduleA.String.oneB<br></p><p>This would achieve just the same thing.<br></p><p><br>-Thorsten<br></p><p><br></p><p>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/aa818568/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 1:01 PM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 09.06.2016 um 19:46 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt;&gt; namespace HtmlAgilityPackPlus {<br>&gt;&gt;     using HtmlAgilityPack;<br>&gt;&gt; <br>&gt;&gt;     public static class Extender {<br>&gt;&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;&gt;             return n;<br>&gt;&gt;         }         <br>&gt;&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;&gt;             return child;<br>&gt;&gt;         }<br>&gt;&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt;&gt; module A ===<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;     func oneA() {  }<br>&gt;&gt;     func twoA() {  }<br>&gt;&gt;     func threeA() {  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; module B ===<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;     func oneB() {  }<br>&gt;&gt;     func twoB() {  }<br>&gt;&gt;     func threeB() {  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt;&gt; first a target type is decided by forming a scope<br>&gt;&gt; then many extension methods can be added together<br>&gt;&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt;&gt; anonymity of the source<br>&gt;&gt; batch adds<br>&gt;&gt; <br>&gt;&gt; as you can see, this is not how C# works.<br>&gt;&gt; <br>&gt;&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt;&gt; <br>&gt;&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt;&gt; <br>&gt;&gt; module A ===<br>&gt;&gt; extension String {<br>&gt;&gt;     func oneA() {  }<br>&gt;&gt;     func twoA() {  }<br>&gt;&gt;     func threeA() {  }<br>&gt;&gt; }<br>&gt;&gt; // more like the GO syntax<br>&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; module B ===<br>&gt;&gt; extension String {<br>&gt;&gt;     func oneB() {  }<br>&gt;&gt;     func twoB() {  }<br>&gt;&gt;     func threeB() {  }<br>&gt;&gt; }<br>&gt;&gt; // more like the c#/XText/XTend/... syntax<br>&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt;&gt; <br>&gt;&gt; because we can now do the following without altering anything<br>&gt;&gt; <br>&gt;&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt;&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br>&gt;&gt; _______________________________________________<br>&gt; <br>&gt; <br>&gt; What hinders me in the case of Swift’s extensions to write<br>&gt; <br>&gt; import func moduleA.String.oneB<br>&gt; <br>&gt; This would achieve just the same thing.<br></p><p>There is also nothing preventing us from allowing named extensions in the future if compelling use cases emerge (at least one has been discussed in the past - initializing stored properties introduced in an extension).  That would allow you to say something like `import extension ModuleA.String.MyExtension` or something similar to target the entire extension in one statement.<br></p><p>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/6fbb88fa/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 8:01 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 09.06.2016 um 19:46 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt;&gt; namespace HtmlAgilityPackPlus {<br>&gt;&gt;     using HtmlAgilityPack;<br>&gt;&gt; <br>&gt;&gt;     public static class Extender {<br>&gt;&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;&gt;             return n;<br>&gt;&gt;         }         <br>&gt;&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;&gt;             return child;<br>&gt;&gt;         }<br>&gt;&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt;&gt; module A ===<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;     func oneA() {  }<br>&gt;&gt;     func twoA() {  }<br>&gt;&gt;     func threeA() {  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; module B ===<br>&gt;&gt; <br>&gt;&gt; extension String {<br>&gt;&gt;     func oneB() {  }<br>&gt;&gt;     func twoB() {  }<br>&gt;&gt;     func threeB() {  }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt;&gt; first a target type is decided by forming a scope<br>&gt;&gt; then many extension methods can be added together<br>&gt;&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt;&gt; anonymity of the source<br>&gt;&gt; batch adds<br>&gt;&gt; <br>&gt;&gt; as you can see, this is not how C# works.<br>&gt;&gt; <br>&gt;&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt;&gt; <br>&gt;&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt;&gt; <br>&gt;&gt; module A ===<br>&gt;&gt; extension String {<br>&gt;&gt;     func oneA() {  }<br>&gt;&gt;     func twoA() {  }<br>&gt;&gt;     func threeA() {  }<br>&gt;&gt; }<br>&gt;&gt; // more like the GO syntax<br>&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; module B ===<br>&gt;&gt; extension String {<br>&gt;&gt;     func oneB() {  }<br>&gt;&gt;     func twoB() {  }<br>&gt;&gt;     func threeB() {  }<br>&gt;&gt; }<br>&gt;&gt; // more like the c#/XText/XTend/... syntax<br>&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt;&gt; <br>&gt;&gt; because we can now do the following without altering anything<br>&gt;&gt; <br>&gt;&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt;&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br>&gt;&gt; _______________________________________________<br>&gt; <br>&gt; <br>&gt; What hinders me in the case of Swift’s extensions to write<br>&gt; <br>&gt; import func moduleA.String.oneB<br>&gt; <br>&gt; This would achieve just the same thing.<br>&gt; <br></p><p>hmmm….. I know… tempting, right?!    but how then does this not DESTROY the other behavior?!  “compiler, be smart… if I say nothing, then let the runtime loader import everything everywhere because it is still very useful even if I don’t want to recognize it right now. But then if I start to import something, then tell the runtime loader that he has to stop mocking about with all these extension blocks to String that he will find and just add the one method that I care about. and btw, remember to the other thing in all my other source files” I look forward to read the source code that will make it work, because I know I do not have the beginning of the imagination required to have a clue how it will look like.<br></p><p>cheers  :)<br></p><p><br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/9cfd964f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 11:12, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 8:01 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 09.06.2016 um 19:46 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt;&gt;&gt; namespace HtmlAgilityPackPlus {<br>&gt;&gt;&gt;     using HtmlAgilityPack;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public static class Extender {<br>&gt;&gt;&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;&gt;&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;&gt;&gt;             return n;<br>&gt;&gt;&gt;         }         <br>&gt;&gt;&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;&gt;&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;&gt;&gt;             return child;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;&gt;&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;&gt;&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt;&gt;&gt; module A ===<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;     func oneA() {  }<br>&gt;&gt;&gt;     func twoA() {  }<br>&gt;&gt;&gt;     func threeA() {  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module B ===<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;     func oneB() {  }<br>&gt;&gt;&gt;     func twoB() {  }<br>&gt;&gt;&gt;     func threeB() {  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt;&gt;&gt; first a target type is decided by forming a scope<br>&gt;&gt;&gt; then many extension methods can be added together<br>&gt;&gt;&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt;&gt;&gt; anonymity of the source<br>&gt;&gt;&gt; batch adds<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; as you can see, this is not how C# works.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module A ===<br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;     func oneA() {  }<br>&gt;&gt;&gt;     func twoA() {  }<br>&gt;&gt;&gt;     func threeA() {  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // more like the GO syntax<br>&gt;&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; module B ===<br>&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;     func oneB() {  }<br>&gt;&gt;&gt;     func twoB() {  }<br>&gt;&gt;&gt;     func threeB() {  }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // more like the c#/XText/XTend/... syntax<br>&gt;&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; because we can now do the following without altering anything<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt;&gt;&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What hinders me in the case of Swift’s extensions to write<br>&gt;&gt; <br>&gt;&gt; import func moduleA.String.oneB<br>&gt;&gt; <br>&gt;&gt; This would achieve just the same thing.<br>&gt;&gt; <br>&gt; <br>&gt; hmmm….. I know… tempting, right?!    but how then does this not DESTROY the other behavior?!  “compiler, be smart… if I say nothing, then let the runtime loader import everything everywhere because it is still very useful even if I don’t want to recognize it right now. But then if I start to import something, then tell the runtime loader that he has to stop mocking about with all these extension blocks to String that he will find and just add the one method that I care about. and btw, remember to the other thing in all my other source files” I look forward to read the source code that will make it work, because I know I do not have the beginning of the imagination required to have a clue how it will look like.<br></p><p>I&#39;m really not sure what you&#39;re talking about. Extension methods are resolved at compile-time, not run-time. (Except @objc extension methods, which are as dangerous as categories ever were, and which isn&#39;t changing.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/4fdd03e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 8:14 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 9, 2016, at 11:12, L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 9, 2016, at 8:01 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 09.06.2016 um 19:46 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 7:04 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 07:35, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 9, 2016, at 3:27 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi, Paulo. Thanks for bringing this up; it’s definitely an interesting problem to solve.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; My thoughts are mostly in line with yours, that disambiguation at the call site is the most Swift-like thing to do, at least as a first step. Maybe we can add some way to record general preferences, or maybe just asking people to define a wrapper function to put the disambiguation in one place is fine.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not particularly a fan of the “from” syntax or the “@“ syntax, but I don’t have anything better. (And the “not a fan” is entirely a taste thing, plus a general desire not to steal new keywords or operator characters. Neither of these are blockers.) I’ve been playing with silly things like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; str.(ModuleA.capitalized)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Seeing all these proposals that people make, it makes me thinks that extensions as they exist are not fully understood... People seem to consider them  like the Xtext/Xtend/c# extension METHODS, which means that maybe they should also be added to Swift, and people would not be confused:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public static func capitalized(self:String)() {}    <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Then these would be easily individually imported from module x,y or z with the current syntax, and then &quot;extension String {}&quot; would retain it current scoping behavior<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; No matter what, I think many extensions are just a bad outlook on OOD, but properly understood, they are great.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not sure what you mean. How does changing the declaration site solve the disambiguation problem at the call site? (And how do you think Swift extensions differ from C# extensions?)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sorry, I thought the example was clearer than it actually is (pb with writing thgs in a train)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is code I wrote a couple weeks ago (parsing some WWDC related things in C#):<br>&gt;&gt;&gt;&gt; namespace HtmlAgilityPackPlus {<br>&gt;&gt;&gt;&gt;     using HtmlAgilityPack;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     public static class Extender {<br>&gt;&gt;&gt;&gt;         public static HtmlNode ChildOfType(this HtmlNode node, string name) {<br>&gt;&gt;&gt;&gt;             var n = node.ChildNodes.Where( x =&gt; x.Name == name).First();<br>&gt;&gt;&gt;&gt;             return n;<br>&gt;&gt;&gt;&gt;         }         <br>&gt;&gt;&gt;&gt;         public static HtmlNode FirstLink(this HtmlNode node) {<br>&gt;&gt;&gt;&gt;             var child = node.ChildOfType(&quot;a&quot;);<br>&gt;&gt;&gt;&gt;             return child;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         public static HtmlNode FirstDescendantMatching(this HtmlNode node, Func&lt;HtmlNode, bool&gt; predicate) {<br>&gt;&gt;&gt;&gt;             var seq = node.Descendants().Where( x =&gt; predicate(x) );<br>&gt;&gt;&gt;&gt;             return ((seq?.Count() ?? 0) &gt; 0) ? seq.First() : null;<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; XText and XTend work the same (I think at some point so did kotlin, but I haven’t checked since the final)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now this is some Swift code (yes I am not bothering with the details)<br>&gt;&gt;&gt;&gt; module A ===<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;     func oneA() {  }<br>&gt;&gt;&gt;&gt;     func twoA() {  }<br>&gt;&gt;&gt;&gt;     func threeA() {  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; module B ===<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;     func oneB() {  }<br>&gt;&gt;&gt;&gt;     func twoB() {  }<br>&gt;&gt;&gt;&gt;     func threeB() {  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We could say that the Swift extension is a ‘batch’ oriented mechanism: <br>&gt;&gt;&gt;&gt; first a target type is decided by forming a scope<br>&gt;&gt;&gt;&gt; then many extension methods can be added together<br>&gt;&gt;&gt;&gt; Of course one can also add a single method at a time in as many single scopes. But the fact remains.. the syntax is oriented towards <br>&gt;&gt;&gt;&gt; anonymity of the source<br>&gt;&gt;&gt;&gt; batch adds<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; as you can see, this is not how C# works.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So now, given that context, I was suggesting that people seem to consider Swift extensions as something they currently are NOT: there is no way to pinpoint a particular extension in a particular module (import the module, inherit its extensions), there is NO way to target a given method in a given extension in a given module.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My point was to suggest that it may show that current extensions are invaluable for something like the adapter pattern (than you E. Gamma), but not entirely suited for the more fine-grained scenario that people keep use in the mail thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This led to my proposal to ALSO support (not REPLACE) <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; module A ===<br>&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;     func oneA() {  }<br>&gt;&gt;&gt;&gt;     func twoA() {  }<br>&gt;&gt;&gt;&gt;     func threeA() {  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // more like the GO syntax<br>&gt;&gt;&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String)(pattern:String) -&gt; Int {}    <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; module B ===<br>&gt;&gt;&gt;&gt; extension String {<br>&gt;&gt;&gt;&gt;     func oneB() {  }<br>&gt;&gt;&gt;&gt;     func twoB() {  }<br>&gt;&gt;&gt;&gt;     func threeB() {  }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // more like the c#/XText/XTend/... syntax<br>&gt;&gt;&gt;&gt; public static func indexOfSubStringInReversedOrder(self:String, pattern:String) -&gt; Int {}    <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; because we can now do the following without altering anything<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; import func moduleA.indexOfSubStringInReversedOrder<br>&gt;&gt;&gt;&gt; var idx = &quot;blahblahXYZblah&quot;.indexOfSubStringInReversedOrder(&quot;zyx&quot;)<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What hinders me in the case of Swift’s extensions to write<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import func moduleA.String.oneB<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would achieve just the same thing.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; hmmm….. I know… tempting, right?!    but how then does this not DESTROY the other behavior?!  “compiler, be smart… if I say nothing, then let the runtime loader import everything everywhere because it is still very useful even if I don’t want to recognize it right now. But then if I start to import something, then tell the runtime loader that he has to stop mocking about with all these extension blocks to String that he will find and just add the one method that I care about. and btw, remember to the other thing in all my other source files” I look forward to read the source code that will make it work, because I know I do not have the beginning of the imagination required to have a clue how it will look like.<br>&gt; <br>&gt; I&#39;m really not sure what you&#39;re talking about. Extension methods are resolved at compile-time, not run-time. (Except @objc extension methods, which are as dangerous as categories ever were, and which isn&#39;t changing.)<br>&gt; <br></p><p>this is wonderful news… all this time I was under the impression that <br></p><p>module MyApp {<br>source1.swift<br>import moduleA<br>var str = “sdfa”.extensionMethod()<br></p><p>source2.swift<br>import moduleB<br>var str = “sdfa”.extensionMethod()<br>}<br></p><p>was a problem… but it is not, because under the hood the definition of String changes depending on which source file I am looking at. The problem only occurs when both modules are imported in the same source file. I guess I never ran into it because I only use extensions as adapters.<br></p><p>thx.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/745be61e/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt; <br>&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a<br>&gt; <br>&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br></p><p>We already have the concept of prefixing a type name with a module to disambiguate when two modules have the same type. I wonder if we could do the same thing to disambiguate between conflicting extensions?<br></p><p>	import ModuleA<br>	import ModuleB<br>	<br>	(&quot;hello world&quot; as ModuleA.String).capitalized()	// Swift.String, with only APIs known to ModuleA<br>	(&quot;hello world&quot; as ModuleB.String).capitalized()	// Swift.String, with only APIs known to ModuleB<br>	&quot;hello world&quot;.capitalized()					// Still causes a compile-time error for ambiguity<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; I want to discuss the problem of name ambiguity when a computed property or function is defined with the same name and type in different modules. Currently there’s no way to disambiguate the implementation in use cases similar to the one contained in the gist below.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/paulofaria/f48d0b847a0fb7c125d163d0e349500a<br>&gt;&gt; <br>&gt;&gt; The gist also contains some informal proposals. The idea is to create a formal proposal based on the discussion that shall follow.<br>&gt; <br>&gt; We already have the concept of prefixing a type name with a module to disambiguate when two modules have the same type. I wonder if we could do the same thing to disambiguate between conflicting extensions?<br>&gt; <br>&gt;    import ModuleA<br>&gt;    import ModuleB<br>&gt;    <br>&gt;    (&quot;hello world&quot; as ModuleA.String).capitalized()    // Swift.String, with only APIs known to ModuleA<br>&gt;    (&quot;hello world&quot; as ModuleB.String).capitalized()    // Swift.String, with only APIs known to ModuleB<br>&gt;    &quot;hello world&quot;.capitalized()                    // Still causes a compile-time error for ambiguity<br>&gt; <br></p><p>That is one furious rewrite of the compiler/runtime (module loader, compliance table storage/dynamic resolution  ... ), starting with the fact that extensions do not have scopes and are not even types<br></p><p><br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  7, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; We already have the concept of prefixing a type name with a module to disambiguate when two modules have the same type. I wonder if we could do the same thing to disambiguate between conflicting extensions?<br>&gt; <br>&gt; 	import ModuleA<br>&gt; 	import ModuleB<br>&gt; 	<br>&gt; 	(&quot;hello world&quot; as ModuleA.String).capitalized()	// Swift.String, with only APIs known to ModuleA<br>&gt; 	(&quot;hello world&quot; as ModuleB.String).capitalized()	// Swift.String, with only APIs known to ModuleB<br>&gt; 	&quot;hello world&quot;.capitalized()					// Still causes a compile-time error for ambiguity<br></p><p>This only introduces a new kind of ambiguity since you can have both ModuleA and ModuleB declare something like<br></p><p>class String {<br>	/// ...<br>}<br></p><p>And now you have no idea if ModuleA.String refers to Swift.String extension in ModuleA or class String in ModuleA.<br></p><p><br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 7:09 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; We already have the concept of prefixing a type name with a module to disambiguate when two modules have the same type. I wonder if we could do the same thing to disambiguate between conflicting extensions?<br>&gt;&gt; <br>&gt;&gt; 	import ModuleA<br>&gt;&gt; 	import ModuleB<br>&gt;&gt; 	<br>&gt;&gt; 	(&quot;hello world&quot; as ModuleA.String).capitalized()	// Swift.String, with only APIs known to ModuleA<br>&gt;&gt; 	(&quot;hello world&quot; as ModuleB.String).capitalized()	// Swift.String, with only APIs known to ModuleB<br>&gt;&gt; 	&quot;hello world&quot;.capitalized()					// Still causes a compile-time error for ambiguity<br>&gt; <br>&gt; This only introduces a new kind of ambiguity since you can have both ModuleA and ModuleB declare something like<br>&gt; <br>&gt; class String {<br>&gt; 	/// ...<br>&gt; }<br>&gt; <br>&gt; And now you have no idea if ModuleA.String refers to Swift.String extension in ModuleA or class String in ModuleA.<br></p><p>Perhaps the disambiguation should be on the extension method, not the type:<br></p><p>	import ModuleA<br>	import ModuleB<br>	<br>	&quot;hello world”.ModuleA::capitalized()<br>	&quot;hello world”.ModuleB::capitalized()<br></p><p>(Insert your own namespace separator if :: gives you unpleasant C++ flashbacks.)<br></p><p>P<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt;&gt; We already have the concept of prefixing a type name with a module to disambiguate when two modules have the same type. I wonder if we could do the same thing to disambiguate between conflicting extensions?<br>&gt;&gt; <br>&gt;&gt;    import ModuleA<br>&gt;&gt;    import ModuleB<br>&gt;&gt;    <br>&gt;&gt;    (&quot;hello world&quot; as ModuleA.String).capitalized()    // Swift.String, with only APIs known to ModuleA<br>&gt;&gt;    (&quot;hello world&quot; as ModuleB.String).capitalized()    // Swift.String, with only APIs known to ModuleB<br>&gt;&gt;    &quot;hello world&quot;.capitalized()                    // Still causes a compile-time error for ambiguity<br>&gt; <br>&gt; This only introduces a new kind of ambiguity since you can have both ModuleA and ModuleB declare something like<br>&gt; <br>&gt; class String {<br>&gt;    /// ...<br>&gt; }<br>&gt; <br>&gt; And now you have no idea if ModuleA.String refers to Swift.String extension in ModuleA or class String in ModuleA.<br>&gt; <br></p><p>Keep in mind that extensions are not types. (See prev response)<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  7, 2016 at 02:00:00pm</p></header><div class="content"><p>I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a<br>modification:<br></p><p>    import ModuleA<br>    import ModuleB<br></p><p>    &quot;hello world&quot;.(capitalized from ModuleA)()<br>    &quot;hello world&quot;.(capitalized from ModuleB)()<br>    &quot;hello world&quot;.(someProperty from ModuleA)<br>    &quot;hello world&quot;.(someProperty from ModuleB)<br></p><p>The &quot;from&quot; keyword makes it clearer than arbitrary punctuation what&#39;s going<br>on, and extending the member reference syntax to support &quot;.(member from<br>Module)&quot; seems clearer than putting the &quot;from Module&quot; after the actual<br>call; we&#39;re saying &quot;look up the member named &#39;member&#39; on the receiver&#39;s<br>type inside Module&quot;, as opposed to having it look like the &quot;from&quot; applies<br>to the *expression*, which it doesn&#39;t.<br></p><p>Having the parens there is helpful in the property disambiguating case,<br>where we would otherwise have this:<br></p><p>    &quot;hello world&quot;.someProperty from ModuleB.bar<br></p><p>Is that a property &quot;bar&quot; on the result of &quot;someProperty&quot; from ModuleB, or<br>is that &quot;someProperty&quot; from submodule ModuleB.bar? This removes the<br>ambiguity:<br></p><p>    &quot;hello world&quot;.(someProperty from ModuleB).bar<br></p><p><br>On Tue, Jun 7, 2016 at 7:27 AM LM via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; &gt;&gt; We already have the concept of prefixing a type name with a module to<br>&gt; disambiguate when two modules have the same type. I wonder if we could do<br>&gt; the same thing to disambiguate between conflicting extensions?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    import ModuleA<br>&gt; &gt;&gt;    import ModuleB<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    (&quot;hello world&quot; as ModuleA.String).capitalized()    // Swift.String,<br>&gt; with only APIs known to ModuleA<br>&gt; &gt;&gt;    (&quot;hello world&quot; as ModuleB.String).capitalized()    // Swift.String,<br>&gt; with only APIs known to ModuleB<br>&gt; &gt;&gt;    &quot;hello world&quot;.capitalized()                    // Still causes a<br>&gt; compile-time error for ambiguity<br>&gt; &gt;<br>&gt; &gt; This only introduces a new kind of ambiguity since you can have both<br>&gt; ModuleA and ModuleB declare something like<br>&gt; &gt;<br>&gt; &gt; class String {<br>&gt; &gt;    /// ...<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; And now you have no idea if ModuleA.String refers to Swift.String<br>&gt; extension in ModuleA or class String in ModuleA.<br>&gt; &gt;<br>&gt;<br>&gt; Keep in mind that extensions are not types. (See prev response)<br>&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Brent Royal-Gordon<br>&gt; &gt;&gt; Architechies<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/70f74530/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt; <br>&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt; <br>&gt;     import ModuleA<br>&gt;     import ModuleB<br>&gt; <br>&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br></p><p>Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br></p><p>&gt; <br>&gt; The &quot;from&quot; keyword makes it clearer than arbitrary punctuation what&#39;s going on, and extending the member reference syntax to support &quot;.(member from Module)&quot; seems clearer than putting the &quot;from Module&quot; after the actual call; we&#39;re saying &quot;look up the member named &#39;member&#39; on the receiver&#39;s type inside Module&quot;, as opposed to having it look like the &quot;from&quot; applies to the *expression*, which it doesn&#39;t.<br>&gt; <br>&gt; Having the parens there is helpful in the property disambiguating case, where we would otherwise have this:<br>&gt; <br>&gt;     &quot;hello world&quot;.someProperty from ModuleB.bar<br>&gt; <br>&gt; Is that a property &quot;bar&quot; on the result of &quot;someProperty&quot; from ModuleB, or is that &quot;someProperty&quot; from submodule ModuleB.bar? This removes the ambiguity:<br>&gt; <br>&gt;     &quot;hello world&quot;.(someProperty from ModuleB).bar<br>&gt; <br>&gt; <br>&gt;&gt; On Tue, Jun 7, 2016 at 7:27 AM LM via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; &gt;&gt; We already have the concept of prefixing a type name with a module to disambiguate when two modules have the same type. I wonder if we could do the same thing to disambiguate between conflicting extensions?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    import ModuleA<br>&gt;&gt; &gt;&gt;    import ModuleB<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    (&quot;hello world&quot; as ModuleA.String).capitalized()    // Swift.String, with only APIs known to ModuleA<br>&gt;&gt; &gt;&gt;    (&quot;hello world&quot; as ModuleB.String).capitalized()    // Swift.String, with only APIs known to ModuleB<br>&gt;&gt; &gt;&gt;    &quot;hello world&quot;.capitalized()                    // Still causes a compile-time error for ambiguity<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This only introduces a new kind of ambiguity since you can have both ModuleA and ModuleB declare something like<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; class String {<br>&gt;&gt; &gt;    /// ...<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; And now you have no idea if ModuleA.String refers to Swift.String extension in ModuleA or class String in ModuleA.<br>&gt;&gt; &gt;<br>&gt;&gt; <br>&gt;&gt; Keep in mind that extensions are not types. (See prev response)<br>&gt;&gt; <br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; --<br>&gt;&gt; &gt;&gt; Brent Royal-Gordon<br>&gt;&gt; &gt;&gt; Architechies<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; _______________________________________________<br>&gt;&gt; &gt;&gt; swift-evolution mailing list<br>&gt;&gt; &gt;&gt; swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/286397c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt; <br>&gt;&gt;     import ModuleA<br>&gt;&gt;     import ModuleB<br>&gt;&gt; <br>&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt; <br>&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br></p><p>IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br></p><p>You can see this in the fact that two different files can see two different extension methods:<br></p><p>A.swift<br></p><p>    import ModuleA<br>    …<br>    &quot;hello world&quot;.capitalized()<br></p><p>B.swift<br></p><p>    import ModuleB<br>    …<br>    &quot;hello world&quot;.capitalized()<br></p><p>…even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br></p><p>If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br></p><p>Cheers, P<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/7f39267d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt; <br>&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt; <br>&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br></p><p>Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html<br></p><p>Joe Groff wrote:<br></p><p>“It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br></p><p>IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br></p><p>&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt; <br>&gt; A.swift<br>&gt; <br>&gt;     import ModuleA<br>&gt;     …<br>&gt;     &quot;hello world&quot;.capitalized()<br>&gt; <br>&gt; B.swift<br>&gt; <br>&gt;     import ModuleB<br>&gt;     …<br>&gt;     &quot;hello world&quot;.capitalized()<br>&gt; <br>&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt; <br>&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/16092cc2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>T1 =======<br>import Lib1<br>var str = func2()	// lib1<br></p><p>T2 =======<br>import Lib1<br>import func Lib2.func2<br>var str = func2()	// lib2<br></p><p>T3 =======<br>import Lib1<br>import func Lib2.func2<br>var str = “str”.allCaps()	// ERROR : ambiguous name<br></p><p><br>Lib1 ===========<br>public func func2() -&gt; String {<br>  return &quot;lib1&quot;<br>}<br>// only during T3<br>public extension String {<br>  public func allCaps() -&gt; String {<br>    return “lib1_&quot;<br>  }<br>}<br></p><p>Lib2 ===========<br>public func func2() -&gt; String {<br>  return &quot;lib2&quot;<br>}<br>// only during T3<br>public extension String {<br>  public func allCaps() -&gt; String {<br>    return &quot;lib2_&quot;<br>  }<br>}<br></p><p><br>T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br></p><p><br></p><p><br>&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt; <br>&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt; <br>&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html&gt;<br>&gt; <br>&gt; Joe Groff wrote:<br>&gt; <br>&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt; <br>&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt; <br>&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt; <br>&gt;&gt; A.swift<br>&gt;&gt; <br>&gt;&gt;     import ModuleA<br>&gt;&gt;     …<br>&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt; <br>&gt;&gt; B.swift<br>&gt;&gt; <br>&gt;&gt;     import ModuleB<br>&gt;&gt;     …<br>&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt; <br>&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt; <br>&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt; <br>&gt;&gt; Cheers, P<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/b2f85f15/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>and as you would expect … <br></p><p>T4 =======<br>import Lib1			// importing EVERYTHING from lib1<br>import func Lib2.func2		// importing ONLY func2 from lib2<br></p><p>var int1 = func1()		// 1 , because lib2::func2 is not ‘visible&#39;<br></p><p> —&gt; showing again how extensions are treated differently<br></p><p><br>Lib1 ===========<br>public func func1() -&gt; Int {<br>  return 1<br>}<br></p><p>Lib2 ===========<br>public func func1() -&gt; Int {<br>  return 2<br>}<br></p><p><br>from what I saw and read, this is a rather fundamental behavior that may not be easily negotiated.<br></p><p><br></p><p><br>&gt; On Jun 7, 2016, at 8:11 PM, L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; T1 =======<br>&gt; import Lib1<br>&gt; var str = func2()	// lib1<br>&gt; <br>&gt; T2 =======<br>&gt; import Lib1<br>&gt; import func Lib2.func2<br>&gt; var str = func2()	// lib2<br>&gt; <br>&gt; T3 =======<br>&gt; import Lib1<br>&gt; import func Lib2.func2<br>&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt; <br>&gt; <br>&gt; Lib1 ===========<br>&gt; public func func2() -&gt; String {<br>&gt;   return &quot;lib1&quot;<br>&gt; }<br>&gt; // only during T3<br>&gt; public extension String {<br>&gt;   public func allCaps() -&gt; String {<br>&gt;     return “lib1_&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Lib2 ===========<br>&gt; public func func2() -&gt; String {<br>&gt;   return &quot;lib2&quot;<br>&gt; }<br>&gt; // only during T3<br>&gt; public extension String {<br>&gt;   public func allCaps() -&gt; String {<br>&gt;     return &quot;lib2_&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt;&gt; <br>&gt;&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html&gt;<br>&gt;&gt; <br>&gt;&gt; Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt;&gt; <br>&gt;&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt;&gt; <br>&gt;&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/b398c00b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19ca8ea29768acdbb87dc016d7d9a8e4?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Paulo Faria</string> &lt;paulo at zewo.io&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>I’m thinking I’ll just go ahead and create a formal proposal with this:<br></p><p>Given<br>    ModuleA<br>        extension String {<br>            public func module() -&gt; String {<br>                return &quot;ModuleA&quot;<br>            }<br>        }<br></p><p>    ModuleB<br>        extension String {<br>            public func module() -&gt; String {<br>                return &quot;ModuleB&quot;<br>            }<br>        }<br></p><p>Problem<br>    ModuleC<br>        import ModuleA<br>        import ModuleB<br></p><p>        let module = &quot;hello swift”.module() // ambiguous<br></p><p>Proposal<br>    ModuleC<br>        import ModuleA<br>        import ModuleB<br></p><p>        let moduleA = (&quot;hello swift”.module() from ModuleA)<br>        print(moduleA) // prints &quot;ModuleA&quot;<br></p><p>        let moduleB = (&quot;hello swift”.module() from ModuleB)<br>        print(moduleB) // prints &quot;ModuleB&quot;<br></p><p>        let chainingExample = (&quot;hello swift”.module() from ModuleB).uppercased()<br>        print(chainingExample) // prints &quot;MODULEB&quot;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June  9, 2016 at 04:00:00pm</p></header><div class="content"><p>FWIW I don&#39;t like the variant with &#39;from&#39; keyword. Such syntax is too <br>verbose for me, this syntax requires braces, I need to parse whole contents <br>between braces to find out what is going here, we don&#39;t use words to <br>represent hierarchy i.e. when calling methods/props of instance or <br>referencing nested types (Type1.Type2).<br></p><p>IMO the best solution will be &#39;::&#39; as separator, so<br></p><p>(&quot;hello swift”.module() from ModuleA)<br></p><p>will be :<br></p><p>&quot;hello swift”.ModuleA::module()<br></p><p><br>On 08.06.2016 22:50, Paulo Faria via swift-evolution wrote:<br>&gt; I’m thinking I’ll just go ahead and create a formal proposal with this:<br>&gt;<br>&gt; Given<br>&gt;     ModuleA<br>&gt;         extension String {<br>&gt;             public func module() -&gt; String {<br>&gt;                 return &quot;ModuleA&quot;<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt;     ModuleB<br>&gt;         extension String {<br>&gt;             public func module() -&gt; String {<br>&gt;                 return &quot;ModuleB&quot;<br>&gt;             }<br>&gt;         }<br>&gt;<br>&gt; Problem<br>&gt;     ModuleC<br>&gt;         import ModuleA<br>&gt;         import ModuleB<br>&gt;<br>&gt;         let module = &quot;hello swift”.module() // ambiguous<br>&gt;<br>&gt; Proposal<br>&gt;     ModuleC<br>&gt;         import ModuleA<br>&gt;         import ModuleB<br>&gt;<br>&gt;         let moduleA = (&quot;hello swift”.module() from ModuleA)<br>&gt;         print(moduleA) // prints &quot;ModuleA&quot;<br>&gt;<br>&gt;         let moduleB = (&quot;hello swift”.module() from ModuleB)<br>&gt;         print(moduleB) // prints &quot;ModuleB&quot;<br>&gt;<br>&gt;         let chainingExample = (&quot;hello swift”.module() from ModuleB).uppercased()<br>&gt;         print(chainingExample) // prints &quot;MODULEB&quot;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; T1 =======<br>&gt; import Lib1<br>&gt; var str = func2()	// lib1<br>&gt; <br>&gt; T2 =======<br>&gt; import Lib1<br>&gt; import func Lib2.func2<br>&gt; var str = func2()	// lib2<br></p><p>Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br></p><p>-Thorsten <br></p><p>&gt; <br>&gt; T3 =======<br>&gt; import Lib1<br>&gt; import func Lib2.func2<br>&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt; <br>&gt; <br>&gt; Lib1 ===========<br>&gt; public func func2() -&gt; String {<br>&gt;   return &quot;lib1&quot;<br>&gt; }<br>&gt; // only during T3<br>&gt; public extension String {<br>&gt;   public func allCaps() -&gt; String {<br>&gt;     return “lib1_&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Lib2 ===========<br>&gt; public func func2() -&gt; String {<br>&gt;   return &quot;lib2&quot;<br>&gt; }<br>&gt; // only during T3<br>&gt; public extension String {<br>&gt;   public func allCaps() -&gt; String {<br>&gt;     return &quot;lib2_&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt;&gt; <br>&gt;&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html<br>&gt;&gt; <br>&gt;&gt; Joe Groff wrote:<br>&gt;&gt; <br>&gt;&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt;&gt; <br>&gt;&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt;&gt; <br>&gt;&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; B.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;     …<br>&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/5ef3a367/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; T1 =======<br>&gt;&gt; import Lib1<br>&gt;&gt; var str = func2()	// lib1<br>&gt;&gt; <br>&gt;&gt; T2 =======<br>&gt;&gt; import Lib1<br>&gt;&gt; import func Lib2.func2<br>&gt;&gt; var str = func2()	// lib2<br>&gt; <br>&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt; <br>&gt; -Thorsten <br></p><p><br>no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br></p><p><br>&gt;&gt; <br>&gt;&gt; T3 =======<br>&gt;&gt; import Lib1<br>&gt;&gt; import func Lib2.func2<br>&gt;&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Lib1 ===========<br>&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;   return &quot;lib1&quot;<br>&gt;&gt; }<br>&gt;&gt; // only during T3<br>&gt;&gt; public extension String {<br>&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;     return “lib1_&quot;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Lib2 ===========<br>&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;   return &quot;lib2&quot;<br>&gt;&gt; }<br>&gt;&gt; // only during T3<br>&gt;&gt; public extension String {<br>&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;     return &quot;lib2_&quot;<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Joe Groff wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A.swift<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; B.swift<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/abe7a36b/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  8, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 07.06.2016 um 22:27 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; T1 =======<br>&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt; var str = func2()	// lib1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; T2 =======<br>&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt; var str = func2()	// lib2<br>&gt;&gt; <br>&gt;&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br>&gt; <br>&gt; no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br></p><p>So it is dependent on the order of the imports? That’s rather fragile IMO and I would prefer having to solve clashes explicitly independent of import order, e.g. by having to hide the version from Lib1:<br></p><p>import Lib1 hiding func2  // strawman syntax<br>import func Lib2.func2<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; T3 =======<br>&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lib1 ===========<br>&gt;&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;&gt;   return &quot;lib1&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // only during T3<br>&gt;&gt;&gt; public extension String {<br>&gt;&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;&gt;     return “lib1_&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lib2 ===========<br>&gt;&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;&gt;   return &quot;lib2&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; // only during T3<br>&gt;&gt;&gt; public extension String {<br>&gt;&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;&gt;     return &quot;lib2_&quot;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Joe Groff wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A.swift<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; B.swift<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/374c4e20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 12:02, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 07.06.2016 um 22:27 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; T1 =======<br>&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt; var str = func2()	// lib1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; T2 =======<br>&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt; var str = func2()	// lib2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br>&gt; <br>&gt; So it is dependent on the order of the imports? That’s rather fragile IMO and I would prefer having to solve clashes explicitly independent of import order, e.g. by having to hide the version from Lib1:<br>&gt; <br>&gt; import Lib1 hiding func2  // strawman syntax<br>&gt; import func Lib2.func2<br></p><p>It doesn’t depend on the order, but it does consider naming a specific top-level value to be a “better” choice than importing the whole module, on the grounds that you wouldn’t have written it that way otherwise.<br></p><p>(I’ve been lukewarm on the entire feature of selective imports for a while since there are often a lot of helpers in the same module (think UITableView and UITableViewDataSource). We do seem to be gravitating towards making helper things nested, though (see SE-0086 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md&gt;).)<br></p><p>This is getting a little off-topic from the problem of disambiguating members, though.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/4aad52fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 9, 2016, at 3:04 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jun 8, 2016, at 12:02, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 22:27 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T1 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; var str = func2()	// lib1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T2 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt;&gt; var str = func2()	// lib2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br>&gt;&gt; <br>&gt;&gt; So it is dependent on the order of the imports? That’s rather fragile IMO and I would prefer having to solve clashes explicitly independent of import order, e.g. by having to hide the version from Lib1:<br>&gt;&gt; <br>&gt;&gt; import Lib1 hiding func2  // strawman syntax<br>&gt;&gt; import func Lib2.func2<br>&gt; <br>&gt; It doesn’t depend on the order, but it does consider naming a specific top-level value to be a “better” choice than importing the whole module, on the grounds that you wouldn’t have written it that way otherwise.<br></p><p>Yes, I&#39;m sorry. i should have written my example the other way around to show that swift consistently chooses specific over implied.<br></p><p>&gt; <br>&gt; (I’ve been lukewarm on the entire feature of selective imports for a while since there are often a lot of helpers in the same module (think UITableView and UITableViewDataSource). We do seem to be gravitating towards making helper things nested, though (see SE-0086).)<br>&gt; <br>&gt; This is getting a little off-topic from the problem of disambiguating members, though.<br>&gt; <br>&gt; Jordan<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/c07975d6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 03:04 schrieb Jordan Rose &lt;jordan_rose at apple.com&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 8, 2016, at 12:02, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 22:27 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T1 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; var str = func2()	// lib1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T2 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt;&gt; var str = func2()	// lib2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br>&gt;&gt; <br>&gt;&gt; So it is dependent on the order of the imports? That’s rather fragile IMO and I would prefer having to solve clashes explicitly independent of import order, e.g. by having to hide the version from Lib1:<br>&gt;&gt; <br>&gt;&gt; import Lib1 hiding func2  // strawman syntax<br>&gt;&gt; import func Lib2.func2<br>&gt; <br>&gt; It doesn’t depend on the order, but it does consider naming a specific top-level value to be a “better” choice than importing the whole module, on the grounds that you wouldn’t have written it that way otherwise.<br></p><p>Ah, that does make more sense! <br></p><p>-Thorsten<br></p><p><br>&gt; (I’ve been lukewarm on the entire feature of selective imports for a while since there are often a lot of helpers in the same module (think UITableView and UITableViewDataSource). We do seem to be gravitating towards making helper things nested, though (see SE-0086 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0086-drop-foundation-ns.md&gt;).)<br>&gt; <br>&gt; This is getting a little off-topic from the problem of disambiguating members, though.<br>&gt; <br>&gt; Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/8c28289a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 9:02 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 22:27 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; T1 =======<br>&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt; var str = func2()	// lib1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; T2 =======<br>&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt; var str = func2()	// lib2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br>&gt; <br>&gt; So it is dependent on the order of the imports?<br></p><p>Swift is a c-ish derivative-ish... intentionally.<br></p><p><br>&gt; That’s rather fragile IMO and I would prefer having to solve clashes explicitly independent of import order, e.g. by having to hide the version from Lib1:<br>&gt; <br>&gt; import Lib1 hiding func2  // strawman syntax<br>&gt; import func Lib2.func2<br></p><p>Interesting...<br></p><p><br>Or <br></p><p>Import func Lib2.func2   as  func2FromLib2<br></p><p>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; T3 =======<br>&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Lib1 ===========<br>&gt;&gt;&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;&gt;&gt;   return &quot;lib1&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // only during T3<br>&gt;&gt;&gt;&gt; public extension String {<br>&gt;&gt;&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;&gt;&gt;     return “lib1_&quot;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Lib2 ===========<br>&gt;&gt;&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;&gt;&gt;   return &quot;lib2&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; // only during T3<br>&gt;&gt;&gt;&gt; public extension String {<br>&gt;&gt;&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;&gt;&gt;     return &quot;lib2_&quot;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Joe Groff wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; A.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; B.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/a0b585f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 09.06.2016 um 07:55 schrieb L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Jun 8, 2016, at 9:02 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 07.06.2016 um 22:27 schrieb L Mihalkovic &lt;laurent.mihalkovic at gmail.com &lt;mailto:laurent.mihalkovic at gmail.com&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 7, 2016, at 9:47 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 07.06.2016 um 20:11 schrieb L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T1 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; var str = func2()	// lib1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T2 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt;&gt; var str = func2()	// lib2<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Shouldn&#39;t func2() be ambiguous here? It is imported from Lib1 and from Lib2.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; no, that is precisely the point .. it works!!  I am able to override whatever my laziness brought into scope from Lib1 (caused by my * import) with a meticulously chosen implementation from Lib2. It is brilliant. extensions on the other hand work differently (although something could undoubtedly be done about them, I cannot entirely convince myself that it is time well spent. It would be if that could be a stepping stone form something else (which I have not been able to identify so far).<br>&gt;&gt; <br>&gt;&gt; So it is dependent on the order of the imports? <br>&gt; <br>&gt; Swift is a c-ish derivative-ish... intentionally.<br>&gt; <br>&gt; <br>&gt;&gt; That’s rather fragile IMO and I would prefer having to solve clashes explicitly independent of import order, e.g. by having to hide the version from Lib1:<br>&gt;&gt; <br>&gt;&gt; import Lib1 hiding func2  // strawman syntax<br>&gt;&gt; import func Lib2.func2<br>&gt; <br>&gt; Interesting...<br>&gt; <br>&gt; <br>&gt; Or <br>&gt; <br>&gt; Import func Lib2.func2   as  func2FromLib2<br></p><p>Yes. Hiding and renaming would be great to have when importing.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T3 =======<br>&gt;&gt;&gt;&gt;&gt; import Lib1<br>&gt;&gt;&gt;&gt;&gt; import func Lib2.func2<br>&gt;&gt;&gt;&gt;&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Lib1 ===========<br>&gt;&gt;&gt;&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;   return &quot;lib1&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // only during T3<br>&gt;&gt;&gt;&gt;&gt; public extension String {<br>&gt;&gt;&gt;&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;     return “lib1_&quot;<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Lib2 ===========<br>&gt;&gt;&gt;&gt;&gt; public func func2() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;   return &quot;lib2&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; // only during T3<br>&gt;&gt;&gt;&gt;&gt; public extension String {<br>&gt;&gt;&gt;&gt;&gt;   public func allCaps() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;     return &quot;lib2_&quot;<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 6:45 PM, Paul Cantrell &lt;cantrell at pobox.com &lt;mailto:cantrell at pobox.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 11:36 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 10:47 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 7, 2016, at 4:53 PM, Tony Allevato &lt;allevato at google.com &lt;mailto:allevato at google.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like the &quot;from&quot; keyword the best, but I&#39;ll take my own stab at a modification:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleA)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(capitalized from ModuleB)()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleA)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.(someProperty from ModuleB)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hmmm... looks like an oxymoron in its own right... I was under the impression so far that the point of extensions was that they are not tied to a source. This brings us back full circle to the very definition of extensions... However you slice it, swift is lacking some scoping bellow modules, and/or arround some of the language features.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; IIRC, a member of the core team (Joe Groff, maybe?) indicated several months ago on the list that methods are internally namespaced to their module. Alas, I can’t find that message. It was a long time ago.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Ah, here it is: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/000928.html&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Joe Groff wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; “It&#39;s helpful to think of method names as being namespaced in Swift, by both their enclosing module and type. If two modules independently extend a protocol with a method of the same name, you still semantically have two distinct methods that dispatch independently. The extension would have to be factored into a common module both modules see for them to interact.”<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IOW, yes, Swift internally does something very much like &quot;hello world”.ModuleA::capitalized().<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; You can see this in the fact that two different files can see two different extension methods:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; A.swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleA<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; B.swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     import ModuleB<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     &quot;hello world&quot;.capitalized()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; …even if they end up compiled into the same binary. And that makes sense: A.swift only expected to see ModuleA’s extension, and was presumably coded around that expectation. That ModuleB happened to end up mixed into the same binary shouldn’t change the behavior of A.swift<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If my understand is correct, then my &quot;hello world”.ModuleA::capitalized() and your &quot;hello world&quot;.(capitalized from ModuleA)() are both just syntax to expose something that Swift already tracks internally.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Cheers, P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/229ba31c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Name disambiguation of computed property/function with same type defined in extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June  8, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 7, 2016, at 11:11, L Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; T1 =======<br>&gt; import Lib1<br>&gt; var str = func2()	// lib1<br>&gt; <br>&gt; T2 =======<br>&gt; import Lib1<br>&gt; import func Lib2.func2<br>&gt; var str = func2()	// lib2<br>&gt; <br>&gt; T3 =======<br>&gt; import Lib1<br>&gt; import func Lib2.func2<br>&gt; var str = “str”.allCaps()	// ERROR : ambiguous name<br>&gt; <br>&gt; <br>&gt; Lib1 ===========<br>&gt; public func func2() -&gt; String {<br>&gt;   return &quot;lib1&quot;<br>&gt; }<br>&gt; // only during T3<br>&gt; public extension String {<br>&gt;   public func allCaps() -&gt; String {<br>&gt;     return “lib1_&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Lib2 ===========<br>&gt; public func func2() -&gt; String {<br>&gt;   return &quot;lib2&quot;<br>&gt; }<br>&gt; // only during T3<br>&gt; public extension String {<br>&gt;   public func allCaps() -&gt; String {<br>&gt;     return &quot;lib2_&quot;<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; T3 shows how differently extensions are treated from all other exportable/importable artifacts:  extensions are NOT sensitive to the scope of imports. they are fully loaded as soon as the loader detects that the module is referenced (they come from their own table inside the module binary).<br></p><p>I personally consider this a longstanding bug, and would like extension member visibility to follow the same rules as top-level visibility. I don’t think that’s trivial to change, though; the lookup paths are very very different.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/7b4cd804/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
