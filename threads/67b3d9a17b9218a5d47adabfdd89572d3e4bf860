<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 12, 2016 at 04:00:00am</p></header><div class="content"><p>When I suggested this syntax in the acceptance thread for SE-0099, Chris said it should be written up as a proposal. I&#39;m sure this will get lost in the WWDC shuffle, but here goes.<br>Tuple-Based Compound Optional Binding<br>Proposal: TBD<br>Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;Introduction<br></p><p>This proposal enhances optional binding with a new, tuple-based syntax for binding multiple values. It replaces functionality lost in SE-0099 with a syntax compatible with the new design.<br></p><p>Swift Evolution Discussion: [Accepted with Revision] SE-0099 Restructuring Condition Clauses &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;Motivation<br></p><p>In Swift 2, it was possible to bind multiple optional values in a single if let, guard let, or while let clause:<br></p><p>guard let a = opt1, b = opt2, c = opt3 else { ... }<br>SE-0099 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified the syntax of conditional statements, but removed this feature so that , could instead separate different conditional clauses. Code like this must now use three separate optional binding clauses:<br></p><p>guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>The similar case clause sidesteps this problem because it can pattern-match tuples. Hence, you can put several patterns in a tuple on the left side of the =, and a matching number of values in a tuple on the right side, and match them all with one case clause:<br></p><p>guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>This doesn&#39;t conflict with the clause separation syntax because the commas are within parentheses. However, the analogous syntax for optional bindings is not permitted:<br></p><p>guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>// error: initializer for conditional binding must have <br>// Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka <br>// &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed Solution<br></p><p>We should extend optional binding clauses to permit a tuple of optional values on the right of the = and a tuple of constants with identical arity on the left. Swift should test each element of the tuple on the right, and if none of them are nil, bind them to the constants on the left.<br></p><p>Nothing in this proposal should change the way optional binding handles an optional tuple (T, U)?, as opposed to a tuple of optionals (T?, U?). Even an optional tuple of optionals (T?, U?)? should continue to be handled as before.<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed Design<br></p><p>No change to the formal grammar is necessary, as the pattern and initializer productions in the optional-binding-head rule can already match tuples:<br></p><p>optional-binding-head : &#39;let&#39; pattern initializer<br>Rather, Sema should be modified to detect this situation and generate appropriate code. Currently, TypeCheckPattern.cpp essentially converts let a = opt1 into case let a? = opt1; if this proposal is accepted, it should similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) = (opt1, opt2).<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge cases<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested tuples-of-optionals<br></p><p>Permitting deeper pattern matching of nested tuples is highly precedented by pattern matching, but is a niche feature. It should be supported if easily achievable.<br></p><p>guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions returning tuples of optionals<br></p><p>Ideally, optional bindings whose initializer is an expression evaluating to a tuple of optionals would be supported:<br></p><p>let tuple = (opt1, opt2)<br>if let (a, b) = tuple { ... }<br>However, I&#39;m not sure if Swift will have pinned down the type of the initializer at the point where it&#39;s generating the pattern. If this would be difficult or impossible to implement, Swift should continue to interpret code like this as attempting to bind an optional tuple, rather than a tuple of optionals.<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name patterns<br></p><p>In theory, Swift could allow you to bind a tuple of optionals to a single constant:<br></p><p>if let tuple = (opt1, opt2) { ... }<br>However, this seems error-prone; the pattern doesn&#39;t draw a very clear picture of the value being operated upon, so you could easily misinterpret it as binding an optional tuple. Because of this ambiguity, Swift should always interpret this construct as binding an optional tuple, rejecting it with a type error if necessary.<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal is additive compared to SE-0099, but in combination with it, essentially replaces the Swift 2.2 compound binding syntax with a different, incompatible one. When moving directly from Swift 2.2, the migrator should convert old-style compound optional binding clauses:<br></p><p>guard let a = opt1, b = opt2, c = opt3 else { ... }<br>Into the new, tuple-based ones:<br></p><p>guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2 and Swift 3, so projects which must support both can still perform multiple optional bindings in a single if statement without resorting to an #if swift(&gt;=3.0) build configuration:<br></p><p>guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives Considered<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not accepting this proposal<br></p><p>This proposal does not add new functionality; it merely removes keyword clutter. However, it offers a convenient replacement for a commonly-used feature which has just been removed as a result of grammatical ambiguity, not user confusion or lack of utility.<br></p><p> &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing similar standard library functionality<br></p><p>Rather than including this functionality in the compiler, the standard library could provide a series of functions like:<br></p><p>public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }<br>public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }<br>// etc.<br>These could then be used in a similar fashion to this proposal:<br></p><p>guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>However, because we do not have variadic generics, we would need to provide a set of overloads for different arities, and our support would be limited to the arities we chose to provide. (Support for tuples, as opposed to separate parameters, would require a second set of overloads). Meanwhile, the tuple matching syntax is already precedented in case conditionals, so extending it seems pretty natural. Providing this in the compiler seems like the right solution.<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/67b3f860/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 12 Jun 2016, at 14:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br></p><p>You mention `guard case` in the motivation, but I think for the uninitiated reader it would be fair to point out that the following example already works equivalently, with only a few extra characters:<br></p><p>guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br></p><p>Aside of that, it&#39;s yet more magic to our `if let` syntax but I don&#39;t mind, it would be useful at times.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/1349433f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; <br>&gt; You mention `guard case` in the motivation, but I think for the uninitiated reader it would be fair to point out that the following example already works equivalently, with only a few extra characters:<br>&gt; <br>&gt; guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br></p><p>It seems fair to mention that, so I&#39;ve added it to the &quot;Alternatives Considered&quot; entry for doing nothing.<br>Not accepting this proposal<br></p><p>This proposal does not add new functionality; it merely removes keyword clutter. However, it offers a convenient replacement for a commonly-used feature which has just been removed as a result of grammatical ambiguity, not user confusion or lack of utility.<br></p><p>The same functionality is also available through case conditions:<br></p><p>guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>However, all of optional binding is redundant with case conditions; we keep it anyway because it&#39;s a convenient shorthand and saves beginners from having to learn about pattern matching. Multiple bindings are a natural fit for the subset of case features available through optional binding.<br></p><p><br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/4f2bb833/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 14, 2016 at 03:00:00am</p></header><div class="content"><p>If Pyry’s suggestion remained the preferred way of unwrapping a tuple, could it also become the only way for unwrapping a single item?<br></p><p>guard case let a? = opt1 {...}<br>Or even shortened for matching optionals only:<br></p><p>guard let a? = opt1 {...}<br>Or even as has often been requested, to keep the same name:<br>guard let opt1? {...}<br>Multiples:<br>guard let (opt1?, opt2?, opt3?) {...}<br>guard let (a?, b?, c?) = (opt1, opt2, opt3) {...}<br>Sorry, not trying to derail, but it always has seemed like something shorter and more self explanatory could be made for optionals. `?` in pattern matching is a special syntax anyway, so why not make this common use case easier?<br></p><p>Patrick<br></p><p>		_____________________________<br>From: Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Sent: Sunday, June 12, 2016 10:04 PM<br>Subject: Re: [swift-evolution] [Draft] Tuple-Based Compound Optional Binding<br>To: Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>Cc: swift-evolution List &lt;swift-evolution at swift.org&gt;<br></p><p><br></p><p>On 12 Jun 2016, at 14:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>You mention `guard case` in the motivation, but I think for the uninitiated reader it would be fair to point out that the following example already works equivalently, with only a few extra characters:<br>guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>Aside of that, it&#39;s yet more magic to our `if let` syntax but I don&#39;t mind, it would be useful at times.<br>— Pyry<br></p><p><br></p><p>	<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160614/7023ac1f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 13, 2016 at 11:00:00pm</p></header><div class="content"><p>This has been suggested before, I believe. The core team has weighed in<br>several times; it seemed like there was some disagreement amongst them<br>whether the current syntax is the wisest, but the concluding statement<br>seemed uncontroversial: &quot;I don&#39;t think it&#39;s something we can change.&quot;<br></p><p>Source:<br>http://article.gmane.org/gmane.comp.lang.swift.evolution/15879/<br></p><p><br>On Mon, Jun 13, 2016 at 10:32 PM, Patrick Smith via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; If Pyry’s suggestion remained the preferred way of unwrapping a tuple,<br>&gt; could it also become the only way for unwrapping a single item?<br>&gt;<br>&gt; guard case let a? = opt1 {<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; Or even shortened for matching optionals only:<br>&gt;<br>&gt; guard let a? = opt1 {<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; Or even as has often been requested, to keep the same name:<br>&gt;<br>&gt; guard let opt1? {<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; Multiples:<br>&gt;<br>&gt; guard let (opt1?, opt2?, opt3?) {<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; guard let (a?, b?, c?) = (opt1, opt2, opt3) {<br>&gt; ...<br>&gt; }<br>&gt;<br>&gt; Sorry, not trying to derail, but it always has seemed like something<br>&gt; shorter and more self explanatory could be made for optionals. `?` in<br>&gt; pattern matching is a special syntax anyway, so why not make this common<br>&gt; use case easier?<br>&gt;<br>&gt; Patrick<br>&gt;<br>&gt; _____________________________<br>&gt; From: Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Sent: Sunday, June 12, 2016 10:04 PM<br>&gt; Subject: Re: [swift-evolution] [Draft] Tuple-Based Compound Optional<br>&gt; Binding<br>&gt; To: Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; Cc: swift-evolution List &lt;swift-evolution at swift.org&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 12 Jun 2016, at 14:46, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt;<br>&gt; You mention `guard case` in the motivation, but I think for the<br>&gt; uninitiated reader it would be fair to point out that the following example<br>&gt; already works equivalently, with only a few extra characters:<br>&gt;<br>&gt; guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt;<br>&gt; Aside of that, it&#39;s yet more magic to our `if let` syntax but I don&#39;t<br>&gt; mind, it would be useful at times.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/752c5b75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 13, 2016 at 11:00:00pm</p></header><div class="content"><p>Also, see:<br>https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br></p><p><br>On Mon, Jun 13, 2016 at 11:06 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; This has been suggested before, I believe. The core team has weighed in<br>&gt; several times; it seemed like there was some disagreement amongst them<br>&gt; whether the current syntax is the wisest, but the concluding statement<br>&gt; seemed uncontroversial: &quot;I don&#39;t think it&#39;s something we can change.&quot;<br>&gt;<br>&gt; Source:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/15879/<br>&gt;<br>&gt;<br>&gt; On Mon, Jun 13, 2016 at 10:32 PM, Patrick Smith via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; If Pyry’s suggestion remained the preferred way of unwrapping a tuple,<br>&gt;&gt; could it also become the only way for unwrapping a single item?<br>&gt;&gt;<br>&gt;&gt; guard case let a? = opt1 {<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Or even shortened for matching optionals only:<br>&gt;&gt;<br>&gt;&gt; guard let a? = opt1 {<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Or even as has often been requested, to keep the same name:<br>&gt;&gt;<br>&gt;&gt; guard let opt1? {<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Multiples:<br>&gt;&gt;<br>&gt;&gt; guard let (opt1?, opt2?, opt3?) {<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; guard let (a?, b?, c?) = (opt1, opt2, opt3) {<br>&gt;&gt; ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Sorry, not trying to derail, but it always has seemed like something<br>&gt;&gt; shorter and more self explanatory could be made for optionals. `?` in<br>&gt;&gt; pattern matching is a special syntax anyway, so why not make this common<br>&gt;&gt; use case easier?<br>&gt;&gt;<br>&gt;&gt; Patrick<br>&gt;&gt;<br>&gt;&gt; _____________________________<br>&gt;&gt; From: Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: Sunday, June 12, 2016 10:04 PM<br>&gt;&gt; Subject: Re: [swift-evolution] [Draft] Tuple-Based Compound Optional<br>&gt;&gt; Binding<br>&gt;&gt; To: Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt; Cc: swift-evolution List &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 12 Jun 2016, at 14:46, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You mention `guard case` in the motivation, but I think for the<br>&gt;&gt; uninitiated reader it would be fair to point out that the following example<br>&gt;&gt; already works equivalently, with only a few extra characters:<br>&gt;&gt;<br>&gt;&gt; guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Aside of that, it&#39;s yet more magic to our `if let` syntax but I don&#39;t<br>&gt;&gt; mind, it would be useful at times.<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/7492ff4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 14, 2016 at 07:00:00pm</p></header><div class="content"><p>Thanks Xiaodi. Interesting arguments there. It possibly seems a shame to me, because it has knock on effects of making other things more complicated. But I do see how for the most simple case of unwrapping a single Optional, it makes sense.<br></p><p>As much as I would like Brent’s proposal to make things easier to type, I think nesting things inside a tuple, where a reader must keep track of which input matches which output, could lead to harder to follow code.<br></p><p>In my own code I will probably stick to using the long form `guard let a = opt1, let b = opt2, let c = opt3 else { … }`, not because I would like typing it, but because it will be the most clear.<br></p><p>I would have loved for SE-0099 to have gone with semicolon/newline separators so I could write it like this, but alas:<br></p><p>guard<br>  let a = opt1<br>  let b = opt2<br>  let c = opt3<br>else {<br>  …<br>}<br></p><p><br>A different thought — maybe if Xcode had autocompletion to unwrap Optionals when inside an `if` or `guard` statement it would make things a lot easier. Just type the full name of the optional, then press escape, and then code will be suggested to unwrap it. Is the pain this proposal targets mainly in the writing more than reading?<br></p><p><br>guard opt·|·<br></p><p><br>guard let &lt;#placeholder#&gt; = opt1<br></p><p><br>guard let a = opt1<br></p><p><br>guard let a = opt1, opt2·|·<br></p><p><br>guard let a = opt1, let &lt;#placeholder#&gt; = opt2<br></p><p><br>guard let a = opt1, let b = opt2<br></p><p><br></p><p>Patrick<br></p><p>&gt; On 14 Jun 2016, at 2:07 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Also, see: https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt; <br>&gt; <br>&gt; On Mon, Jun 13, 2016 at 11:06 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt; This has been suggested before, I believe. The core team has weighed in several times; it seemed like there was some disagreement amongst them whether the current syntax is the wisest, but the concluding statement seemed uncontroversial: &quot;I don&#39;t think it&#39;s something we can change.&quot;<br>&gt; <br>&gt; Source:<br>&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/15879/ &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/15879/&gt;<br>&gt; <br>&gt; <br>&gt; On Mon, Jun 13, 2016 at 10:32 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; If Pyry’s suggestion remained the preferred way of unwrapping a tuple, could it also become the only way for unwrapping a single item?<br>&gt; <br>&gt; guard case let a? = opt1 {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; Or even shortened for matching optionals only:<br>&gt; <br>&gt; guard let a? = opt1 {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; Or even as has often been requested, to keep the same name:<br>&gt; <br>&gt; guard let opt1? {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; Multiples:<br>&gt; <br>&gt; guard let (opt1?, opt2?, opt3?) {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; guard let (a?, b?, c?) = (opt1, opt2, opt3) {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; Sorry, not trying to derail, but it always has seemed like something shorter and more self explanatory could be made for optionals. `?` in pattern matching is a special syntax anyway, so why not make this common use case easier?<br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt; _____________________________<br>&gt; From: Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Sent: Sunday, June 12, 2016 10:04 PM<br>&gt; Subject: Re: [swift-evolution] [Draft] Tuple-Based Compound Optional Binding<br>&gt; To: Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt;<br>&gt; Cc: swift-evolution List &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On 12 Jun 2016, at 14:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; <br>&gt; You mention `guard case` in the motivation, but I think for the uninitiated reader it would be fair to point out that the following example already works equivalently, with only a few extra characters:<br>&gt; <br>&gt; guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>&gt; <br>&gt; Aside of that, it&#39;s yet more magic to our `if let` syntax but I don&#39;t mind, it would be useful at times.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160614/649bb530/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 14, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 14, 2016, at 11:31 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks Xiaodi. Interesting arguments there. It possibly seems a shame to me, because it has knock on effects of making other things more complicated. But I do see how for the most simple case of unwrapping a single Optional, it makes sense.<br>&gt; <br>&gt; As much as I would like Brent’s proposal to make things easier to type, I think nesting things inside a tuple, where a reader must keep track of which input matches which output, could lead to harder to follow code.<br></p><p>Isomehow I think last yesterday&#39;s keynote should recast some expectations about the degree of complexity (richness) the language will ever reach... Somehow xamarin/c# might endupmbeing swift++ for many people<br></p><p><br>&gt; <br>&gt; In my own code I will probably stick to using the long form `guard let a = opt1, let b = opt2, let c = opt3 else { … }`, not because I would like typing it, but because it will be the most clear.<br>&gt; <br>&gt; I would have loved for SE-0099 to have gone with semicolon/newline separators so I could write it like this, but alas:<br>&gt; <br>&gt; guard<br>&gt;   let a = opt1<br>&gt;   let b = opt2<br>&gt;   let c = opt3<br>&gt; else {<br>&gt;   …<br>&gt; }<br>&gt; <br>&gt; <br>&gt; A different thought — maybe if Xcode had autocompletion to unwrap Optionals when inside an `if` or `guard` statement it would make things a lot easier. Just type the full name of the optional, then press escape, and then code will be suggested to unwrap it. Is the pain this proposal targets mainly in the writing more than reading?<br>&gt; <br>&gt; <br>&gt; guard opt·|·<br>&gt; <br>&gt; <br>&gt; guard let &lt;#placeholder#&gt; = opt1<br>&gt; <br>&gt; <br>&gt; guard let a = opt1<br>&gt; <br>&gt; <br>&gt; guard let a = opt1, opt2·|·<br>&gt; <br>&gt; <br>&gt; guard let a = opt1, let &lt;#placeholder#&gt; = opt2<br>&gt; <br>&gt; <br>&gt; guard let a = opt1, let b = opt2<br>&gt; <br>&gt; <br>&gt; <br>&gt; Patrick<br>&gt; <br>&gt;&gt; On 14 Jun 2016, at 2:07 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Also, see: https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mon, Jun 13, 2016 at 11:06 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; This has been suggested before, I believe. The core team has weighed in several times; it seemed like there was some disagreement amongst them whether the current syntax is the wisest, but the concluding statement seemed uncontroversial: &quot;I don&#39;t think it&#39;s something we can change.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Source:<br>&gt;&gt;&gt; http://article.gmane.org/gmane.comp.lang.swift.evolution/15879/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mon, Jun 13, 2016 at 10:32 PM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; If Pyry’s suggestion remained the preferred way of unwrapping a tuple, could it also become the only way for unwrapping a single item?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard case let a? = opt1 {<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or even shortened for matching optionals only:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let a? = opt1 {<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or even as has often been requested, to keep the same name:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let opt1? {<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Multiples:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let (opt1?, opt2?, opt3?) {<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let (a?, b?, c?) = (opt1, opt2, opt3) {<br>&gt;&gt;&gt;&gt; ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, not trying to derail, but it always has seemed like something shorter and more self explanatory could be made for optionals. `?` in pattern matching is a special syntax anyway, so why not make this common use case easier?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Patrick<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _____________________________<br>&gt;&gt;&gt;&gt; From: Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; Sent: Sunday, June 12, 2016 10:04 PM<br>&gt;&gt;&gt;&gt; Subject: Re: [swift-evolution] [Draft] Tuple-Based Compound Optional Binding<br>&gt;&gt;&gt;&gt; To: Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt;&gt;&gt;&gt; Cc: swift-evolution List &lt;swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 12 Jun 2016, at 14:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You mention `guard case` in the motivation, but I think for the uninitiated reader it would be fair to point out that the following example already works equivalently, with only a few extra characters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Aside of that, it&#39;s yet more magic to our `if let` syntax but I don&#39;t mind, it would be useful at times.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; — Pyry<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160614/6647f567/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 14, 2016, at 7:12 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Jun 14, 2016, at 11:31 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Thanks Xiaodi. Interesting arguments there. It possibly seems a shame to me, because it has knock on effects of making other things more complicated. But I do see how for the most simple case of unwrapping a single Optional, it makes sense.<br>&gt;&gt; <br>&gt;&gt; As much as I would like Brent’s proposal to make things easier to type, I think nesting things inside a tuple, where a reader must keep track of which input matches which output, could lead to harder to follow code.<br>&gt; <br>&gt; Isomehow I think last yesterday&#39;s keynote should recast some expectations about the degree of complexity (richness) the language will ever reach... Somehow xamarin/c# might endupmbeing swift++ for many people<br></p><p>How so? What proposals might the core team accept that would confirm your suspicions; would this be one of them? Maybe I should drop Swift and move to C#, if that language is going to end up so much better than Swift in the future. It&#39;s never good to be tied down to a single language.<br></p><p>Best,<br>Austin<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/dff551f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 5:04 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 14, 2016, at 7:12 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 14, 2016, at 11:31 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Thanks Xiaodi. Interesting arguments there. It possibly seems a shame to me, because it has knock on effects of making other things more complicated. But I do see how for the most simple case of unwrapping a single Optional, it makes sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As much as I would like Brent’s proposal to make things easier to type, I think nesting things inside a tuple, where a reader must keep track of which input matches which output, could lead to harder to follow code.<br>&gt;&gt; <br>&gt;&gt; Isomehow I think last yesterday&#39;s keynote should recast some expectations about the degree of complexity (richness) the language will ever reach... Somehow xamarin/c# might endupmbeing swift++ for many people<br>&gt; <br>&gt; How so? What proposals might the core team accept that would confirm your suspicions; would this be one of them? Maybe I should drop Swift and move to C#, if that language is going to end up so much better than Swift in the future. It&#39;s never good to be tied down to a single language.<br></p><p>I think it is non-disputable that objc is a very simple language when compared to more recent languages. Today swift is capable of doing a lot of things, while still being a simpler language than older ones. Si the question for some people might be how much richer will swift become? Will it rival scala&#39;s type system? Will it rival java/scala/kotlin/ceylon/c++ for the ability to organize large codebases? Will it have the runtime/compile time code fluidity of D? Etc.. The only way to find out is ... there is none. So then who is swift for? Apple wants it usable by people off the street... not people with a degree in computer science, but the people who may one day get a degree or not. So i wonder this plus the fact that objc was enough for so many years doesn&#39;t  simply mean that there is already a cap on the sophistication swift will ever get!!! that they will touch everything around it, before they push it. Today i have a degree of expressiveness with c# that i cannot have with swift, is the gap going to increase of decrease? That is what i care to know about before I advise large corps to invest in swift or not. bored/curious devs (i included) will always easily pick it up, but should i advise a CTO to invest on it... <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160615/7c545d95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 15, 2016 at 08:00:00pm</p></header><div class="content"><p>On 15.06.2016 18:42, L. Mihalkovic via swift-evolution wrote:<br>&gt;<br>&gt; On Jun 15, 2016, at 5:04 PM, Austin Zheng &lt;austinzheng at gmail.com<br>&gt; &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 14, 2016, at 7:12 AM, L. Mihalkovic via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 14, 2016, at 11:31 AM, Patrick Smith via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks Xiaodi. Interesting arguments there. It possibly seems a shame<br>&gt;&gt;&gt;&gt; to me, because it has knock on effects of making other things more<br>&gt;&gt;&gt;&gt; complicated. But I do see how for the most simple case of unwrapping a<br>&gt;&gt;&gt;&gt; single Optional, it makes sense.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As much as I would like Brent’s proposal to make things easier to type,<br>&gt;&gt;&gt;&gt; I think nesting things inside a tuple, where a reader must keep track<br>&gt;&gt;&gt;&gt; of which input matches which output, could lead to harder to follow code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Isomehow I think last yesterday&#39;s keynote should recast some<br>&gt;&gt;&gt; expectations about the degree of complexity (richness) the language will<br>&gt;&gt;&gt; ever reach... Somehow xamarin/c# might endupmbeing swift++ for many people<br>&gt;&gt;<br>&gt;&gt; How so? What proposals might the core team accept that would confirm your<br>&gt;&gt; suspicions; would this be one of them? Maybe I should drop Swift and move<br>&gt;&gt; to C#, if that language is going to end up so much better than Swift in<br>&gt;&gt; the future. It&#39;s never good to be tied down to a single language.<br>&gt;<br>&gt; I think it is non-disputable that objc is a very simple language when<br>&gt; compared to more recent languages. Today swift is capable of doing a lot of<br>&gt; things, while still being a simpler language than older ones. Si the<br>&gt; question for some people might be how much richer will swift become? Will<br>&gt; it rival scala&#39;s type system? Will it rival java/scala/kotlin/ceylon/c++<br>&gt; for the ability to organize large codebases? Will it have the<br>&gt; runtime/compile time code fluidity of D? Etc.. The only way to find out is<br>&gt; ... there is none. So then who is swift for? Apple wants it usable by<br>&gt; people off the street... not people with a degree in computer science, but<br>&gt; the people who may one day get a degree or not. So i wonder this plus the<br>&gt; fact that objc was enough for so many years doesn&#39;t  simply mean that there<br>&gt; is already a cap on the sophistication swift will ever get!!! that they<br>&gt; will touch everything around it, before they push it. Today i have a degree<br>&gt; of expressiveness with c# that i cannot have with swift, is the gap going<br>&gt; to increase of decrease? That is what i care to know about before I advise<br>&gt; large corps to invest in swift or not. bored/curious devs (i included) will<br>&gt; always easily pick it up, but should i advise a CTO to invest on it...<br>&gt;<br></p><p>Very interesting opinion, thank you for sharing your thoughts. I believe <br>many of us(here in mailing list) have the same thoughts and questions.<br></p><p>I&#39;d like to believe that Apple wants to make Swift be very easy and simple <br>on start, but very powerful and feature reach when you(as a developer) <br>grows and when you need &quot;more&quot;. So I hope Apple will keep Swift very simple <br>to start using by &quot;people off the street&quot;, but at the same time will <br>increase Swift features for &#39;advanced&#39; programming and keep the language on <br>the level near the other modern languages like C# and will adopt best <br>features/conceptions from other languages.<br></p><p>C# is more mature language but, relating to Apple development, you need to <br>deal with its runtime(Mono) and garbage collection. So there is some <br>drawbacks in using of C# also, as I understand.<br></p><p>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 15, 2016, at 7:53 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 15.06.2016 18:42, L. Mihalkovic via swift-evolution wrote:<br>&gt;&gt; <br>&gt;&gt; On Jun 15, 2016, at 5:04 PM, Austin Zheng &lt;austinzheng at gmail.com<br>&gt;&gt; &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 14, 2016, at 7:12 AM, L. Mihalkovic via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 14, 2016, at 11:31 AM, Patrick Smith via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks Xiaodi. Interesting arguments there. It possibly seems a shame<br>&gt;&gt;&gt;&gt;&gt; to me, because it has knock on effects of making other things more<br>&gt;&gt;&gt;&gt;&gt; complicated. But I do see how for the most simple case of unwrapping a<br>&gt;&gt;&gt;&gt;&gt; single Optional, it makes sense.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As much as I would like Brent’s proposal to make things easier to type,<br>&gt;&gt;&gt;&gt;&gt; I think nesting things inside a tuple, where a reader must keep track<br>&gt;&gt;&gt;&gt;&gt; of which input matches which output, could lead to harder to follow code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Isomehow I think last yesterday&#39;s keynote should recast some<br>&gt;&gt;&gt;&gt; expectations about the degree of complexity (richness) the language will<br>&gt;&gt;&gt;&gt; ever reach... Somehow xamarin/c# might endupmbeing swift++ for many people<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How so? What proposals might the core team accept that would confirm your<br>&gt;&gt;&gt; suspicions; would this be one of them? Maybe I should drop Swift and move<br>&gt;&gt;&gt; to C#, if that language is going to end up so much better than Swift in<br>&gt;&gt;&gt; the future. It&#39;s never good to be tied down to a single language.<br>&gt;&gt; <br>&gt;&gt; I think it is non-disputable that objc is a very simple language when<br>&gt;&gt; compared to more recent languages. Today swift is capable of doing a lot of<br>&gt;&gt; things, while still being a simpler language than older ones. Si the<br>&gt;&gt; question for some people might be how much richer will swift become? Will<br>&gt;&gt; it rival scala&#39;s type system? Will it rival java/scala/kotlin/ceylon/c++<br>&gt;&gt; for the ability to organize large codebases? Will it have the<br>&gt;&gt; runtime/compile time code fluidity of D? Etc.. The only way to find out is<br>&gt;&gt; ... there is none. So then who is swift for? Apple wants it usable by<br>&gt;&gt; people off the street... not people with a degree in computer science, but<br>&gt;&gt; the people who may one day get a degree or not. So i wonder this plus the<br>&gt;&gt; fact that objc was enough for so many years doesn&#39;t  simply mean that there<br>&gt;&gt; is already a cap on the sophistication swift will ever get!!! that they<br>&gt;&gt; will touch everything around it, before they push it. Today i have a degree<br>&gt;&gt; of expressiveness with c# that i cannot have with swift, is the gap going<br>&gt;&gt; to increase of decrease? That is what i care to know about before I advise<br>&gt;&gt; large corps to invest in swift or not. bored/curious devs (i included) will<br>&gt;&gt; always easily pick it up, but should i advise a CTO to invest on it...<br>&gt; <br>&gt; Very interesting opinion, thank you for sharing your thoughts. I believe many of us(here in mailing list) have the same thoughts and questions.<br>&gt; <br>&gt; I&#39;d like to believe that Apple wants to make Swift be very easy and simple on start, but very powerful and feature reach when you(as a developer) grows and when you need &quot;more&quot;. So I hope Apple will keep Swift very simple to start using by &quot;people off the street&quot;, but at the same time will increase Swift features for &#39;advanced&#39; programming and keep the language on the level near the other modern languages like C# and will adopt best features/conceptions from other languages.<br></p><p>I don&#39;t know about that... There r 2 ways to look at it.. 1) in complete isolation: then everything is possible, the sky is the limit, and guessing is just that. But there is another way to look at it 2) apple is apple is apple, so what they do today is the result of a decision yesterday, and every decision is part of series and therefore a hint about every other. So what would a single button mouse, a ever thinning chassis, the culture of amortizing the cost of prod dev over huge production runs covering 3 to 4 years, or the removal of so many features from so many apps have in common? I think it is a hint about how what role software plays in the company. And that I think gives an element of answer. Swift is 2y/o (5 if u count internal years), and today we r looking at v3.0, and what are the biggest announcements abt it @ wwdc?<br></p><p><br>&gt; C# is more mature language but, relating to Apple development, you need to deal with its runtime(Mono) and garbage collection. So there is some drawbacks in using of C# also, as I understand.<br></p><p>Maybe pb for watch os, likely irrelevant for the others. I thk the biggest pb in the arena is elsewhere. Apple does not like to share...<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>June 16, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m not really interested in a really rich language, just the most simple thing possible that lets me create rich apps. I like Vladimir’s description of there being more when you need it.<br></p><p>(I guess what I am concerned about is complexity as a writer. I want everything to be as consistent and logical as possible. I don’t really want any situations as a writer where I’m like ‘now hang on, this follows these particular rules’, or ‘this is this particular edge case’. I guess I’m a little worried about the piecemeal nature of the evolution process. Sometimes I think the way Apple works is so great since that they ‘marinate’ things for so long (e.g. Siri capabilities), they allow it internally to be discussed and prototyped and be released when it’s ready and not sooner.)<br></p><p>Patrick<br></p><p>&gt; On 16 Jun 2016, at 1:42 AM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On Jun 15, 2016, at 5:04 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 14, 2016, at 7:12 AM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 14, 2016, at 11:31 AM, Patrick Smith via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks Xiaodi. Interesting arguments there. It possibly seems a shame to me, because it has knock on effects of making other things more complicated. But I do see how for the most simple case of unwrapping a single Optional, it makes sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As much as I would like Brent’s proposal to make things easier to type, I think nesting things inside a tuple, where a reader must keep track of which input matches which output, could lead to harder to follow code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Isomehow I think last yesterday&#39;s keynote should recast some expectations about the degree of complexity (richness) the language will ever reach... Somehow xamarin/c# might endupmbeing swift++ for many people<br>&gt;&gt; <br>&gt;&gt; How so? What proposals might the core team accept that would confirm your suspicions; would this be one of them? Maybe I should drop Swift and move to C#, if that language is going to end up so much better than Swift in the future. It&#39;s never good to be tied down to a single language.<br>&gt; <br>&gt; I think it is non-disputable that objc is a very simple language when compared to more recent languages. Today swift is capable of doing a lot of things, while still being a simpler language than older ones. Si the question for some people might be how much richer will swift become? Will it rival scala&#39;s type system? Will it rival java/scala/kotlin/ceylon/c++ for the ability to organize large codebases? Will it have the runtime/compile time code fluidity of D? Etc.. The only way to find out is ... there is none. So then who is swift for? Apple wants it usable by people off the street... not people with a degree in computer science, but the people who may one day get a degree or not. So i wonder this plus the fact that objc was enough for so many years doesn&#39;t  simply mean that there is already a cap on the sophistication swift will ever get!!! that they will touch everything around it, before they push it. Today i have a degree of expressiveness with c# that i cannot have with swift, is the gap going to increase of decrease? That is what i care to know about before I advise large corps to invest in swift or not. bored/curious devs (i included) will always easily pick it up, but should i advise a CTO to invest on it... <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/371bdb1d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 12, 2016 at 01:00:00pm</p></header><div class="content"><p>On Sun, Jun 12, 2016 at 6:46 AM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris<br>&gt; said it should be written up as a proposal. I&#39;m sure this will get lost in<br>&gt; the WWDC shuffle, but here goes.<br>&gt; Tuple-Based Compound Optional Binding<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal enhances optional binding with a new, tuple-based syntax for<br>&gt; binding multiple values. It replaces functionality lost in SE-0099 with a<br>&gt; syntax compatible with the new design.<br>&gt;<br>&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099<br>&gt; Restructuring Condition Clauses<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; In Swift 2, it was possible to bind multiple optional values in a single if<br>&gt; let, guard let, or while let clause:<br>&gt;<br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;<br>&gt; SE-0099<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified<br>&gt; the syntax of conditional statements, but removed this feature so that , could<br>&gt; instead separate different conditional clauses. Code like this must now use<br>&gt; three separate optional binding clauses:<br>&gt;<br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;<br>&gt; The similar case clause sidesteps this problem because it can<br>&gt; pattern-match tuples. Hence, you can put several patterns in a tuple on the<br>&gt; left side of the =, and a matching number of values in a tuple on the<br>&gt; right side, and match them all with one case clause:<br>&gt;<br>&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt; This doesn&#39;t conflict with the clause separation syntax because the commas<br>&gt; are within parentheses. However, the analogous syntax for optional bindings<br>&gt; is not permitted:<br>&gt;<br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }// error: initializer for conditional binding must have // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; We should extend optional binding clauses to permit a tuple of optional<br>&gt; values on the right of the = and a tuple of constants with identical<br>&gt; arity on the left. Swift should test each element of the tuple on the<br>&gt; right, and if none of them are nil, bind them to the constants on the<br>&gt; left.<br>&gt;<br>&gt; Nothing in this proposal should change the way optional binding handles an *optional<br>&gt; tuple* (T, U)?, as opposed to a *tuple of optionals* (T?, U?). Even an<br>&gt; optional tuple of optionals (T?, U?)? should continue to be handled as<br>&gt; before.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; No change to the formal grammar is necessary, as the *pattern* and<br>&gt; *initializer* productions in the *optional-binding-head* rule can already<br>&gt; match tuples:<br>&gt;<br>&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt;<br>&gt; Rather, Sema should be modified to detect this situation and generate<br>&gt; appropriate code. Currently, TypeCheckPattern.cpp essentially converts let<br>&gt; a = opt1 into case let a? = opt1; if this proposal is accepted, it should<br>&gt; similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) =<br>&gt; (opt1, opt2).<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge<br>&gt; cases<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested<br>&gt; tuples-of-optionals<br>&gt;<br>&gt; Permitting deeper pattern matching of nested tuples is highly precedented<br>&gt; by pattern matching, but is a niche feature. It should be supported if<br>&gt; easily achievable.<br>&gt;<br>&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions<br>&gt; returning tuples of optionals<br>&gt;<br>&gt; Ideally, optional bindings whose *initializer* is an expression<br>&gt; evaluating to a tuple of optionals would be supported:<br>&gt;<br>&gt; let tuple = (opt1, opt2)if let (a, b) = tuple { ... }<br>&gt;<br>&gt; However, I&#39;m not sure if Swift will have pinned down the type of the<br>&gt; initializer at the point where it&#39;s generating the pattern. If this would<br>&gt; be difficult or impossible to implement, Swift should continue to interpret<br>&gt; code like this as attempting to bind an optional tuple, rather than a tuple<br>&gt; of optionals.<br>&gt;<br></p><p>I think this proposal is definitely worthy of consideration (and<br>implementation). I hesitate that what works or not is being proposed partly<br>on the basis of whether it&#39;s difficult to implement or not. If I could<br>offer a suggestion as to exactly which edge cases should work, I think it<br>should be based on this guideline that can be articulated cleanly:<br></p><p>Given `if let (a, b, c)...` or any other variation or edge case, transform<br>in your mind&#39;s eye to `if case let (a?, b?, c?)...`. That is, append `case`<br>before `let` and then append `?` immediately after each constant so<br>introduced. If the `if case let...` version would work, so should the `if<br>let...` version. By that rule of thumb, `if case let (a?, (b?, c?)) =<br>(opt1, (opt2, opt3))` would work if I&#39;m not mistaken, as would `if case let<br>(a?, b?) = tuple`, but `if case let tuple? = (opt1, opt2)` would not and<br>thus neither should `if let tuple = (opt1, opt2)`.<br></p><p><br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name<br>&gt; patterns<br>&gt;<br>&gt; In theory, Swift could allow you to bind a tuple of optionals to a single<br>&gt; constant:<br>&gt;<br>&gt; if let tuple = (opt1, opt2) { ... }<br>&gt;<br>&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear<br>&gt; picture of the value being operated upon, so you could easily misinterpret<br>&gt; it as binding an optional tuple. Because of this ambiguity, Swift should<br>&gt; always interpret this construct as binding an optional tuple, rejecting it<br>&gt; with a type error if necessary.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is additive compared to SE-0099, but in combination with it,<br>&gt; essentially replaces the Swift 2.2 compound binding syntax with a<br>&gt; different, incompatible one. When moving directly from Swift 2.2, the<br>&gt; migrator should convert old-style compound optional binding clauses:<br>&gt;<br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;<br>&gt; Into the new, tuple-based ones:<br>&gt;<br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2<br>&gt; and Swift 3, so projects which must support both can still perform multiple<br>&gt; optional bindings in a single if statement without resorting to an #if<br>&gt; swift(&gt;=3.0) build configuration:<br>&gt;<br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not<br>&gt; accepting this proposal<br>&gt;<br>&gt; This proposal does not add new functionality; it merely removes keyword<br>&gt; clutter. However, it offers a convenient replacement for a commonly-used<br>&gt; feature which has just been removed as a result of grammatical ambiguity,<br>&gt; not user confusion or lack of utility.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing<br>&gt; similar standard library functionality<br>&gt;<br>&gt; Rather than including this functionality in the compiler, the standard<br>&gt; library could provide a series of functions like:<br>&gt;<br>&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }// etc.<br>&gt;<br>&gt; These could then be used in a similar fashion to this proposal:<br>&gt;<br>&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt; However, because we do not have variadic generics, we would need to<br>&gt; provide a set of overloads for different arities, and our support would be<br>&gt; limited to the arities we chose to provide. (Support for tuples, as opposed<br>&gt; to separate parameters, would require a second set of overloads).<br>&gt; Meanwhile, the tuple matching syntax is already precedented in case conditionals,<br>&gt; so extending it seems pretty natural. Providing this in the compiler seems<br>&gt; like the right solution.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/5fd2a033/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 12, 2016 at 08:00:00pm</p></header><div class="content"><p>It takes reaching the last section of the proposal to understand that there is not real issue, that it does not add any functionality, and that it basically amount to stylistic preference for something. It might be more informative to start with that rather than leave it until the end.<br></p><p>&gt; On Jun 12, 2016, at 8:04 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Sun, Jun 12, 2016 at 6:46 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris said it should be written up as a proposal. I&#39;m sure this will get lost in the WWDC shuffle, but here goes.<br>&gt;&gt; Tuple-Based Compound Optional Binding<br>&gt;&gt; Proposal: TBD<br>&gt;&gt; Author: Brent Royal-Gordon<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal enhances optional binding with a new, tuple-based syntax for binding multiple values. It replaces functionality lost in SE-0099 with a syntax compatible with the new design.<br>&gt;&gt; <br>&gt;&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099 Restructuring Condition Clauses<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; In Swift 2, it was possible to bind multiple optional values in a single if let, guard let, or while let clause:<br>&gt;&gt; <br>&gt;&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;&gt; SE-0099 simplified the syntax of conditional statements, but removed this feature so that , could instead separate different conditional clauses. Code like this must now use three separate optional binding clauses:<br>&gt;&gt; <br>&gt;&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;&gt; The similar case clause sidesteps this problem because it can pattern-match tuples. Hence, you can put several patterns in a tuple on the left side of the =, and a matching number of values in a tuple on the right side, and match them all with one case clause:<br>&gt;&gt; <br>&gt;&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt; This doesn&#39;t conflict with the clause separation syntax because the commas are within parentheses. However, the analogous syntax for optional bindings is not permitted:<br>&gt;&gt; <br>&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt; // error: initializer for conditional binding must have <br>&gt;&gt; // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka <br>&gt;&gt; // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;&gt; Proposed Solution<br>&gt;&gt; <br>&gt;&gt; We should extend optional binding clauses to permit a tuple of optional values on the right of the = and a tuple of constants with identical arity on the left. Swift should test each element of the tuple on the right, and if none of them are nil, bind them to the constants on the left.<br>&gt;&gt; <br>&gt;&gt; Nothing in this proposal should change the way optional binding handles an optional tuple (T, U)?, as opposed to a tuple of optionals (T?, U?). Even an optional tuple of optionals (T?, U?)? should continue to be handled as before.<br>&gt;&gt; <br>&gt;&gt; Detailed Design<br>&gt;&gt; <br>&gt;&gt; No change to the formal grammar is necessary, as the pattern and initializer productions in the optional-binding-head rule can already match tuples:<br>&gt;&gt; <br>&gt;&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt;&gt; Rather, Sema should be modified to detect this situation and generate appropriate code. Currently, TypeCheckPattern.cpp essentially converts let a = opt1 into case let a? = opt1; if this proposal is accepted, it should similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) = (opt1, opt2).<br>&gt;&gt; <br>&gt;&gt; Edge cases<br>&gt;&gt; <br>&gt;&gt; Nested tuples-of-optionals<br>&gt;&gt; <br>&gt;&gt; Permitting deeper pattern matching of nested tuples is highly precedented by pattern matching, but is a niche feature. It should be supported if easily achievable.<br>&gt;&gt; <br>&gt;&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;&gt; Expressions returning tuples of optionals<br>&gt;&gt; <br>&gt;&gt; Ideally, optional bindings whose initializer is an expression evaluating to a tuple of optionals would be supported:<br>&gt;&gt; <br>&gt;&gt; let tuple = (opt1, opt2)<br>&gt;&gt; if let (a, b) = tuple { ... }<br>&gt;&gt; However, I&#39;m not sure if Swift will have pinned down the type of the initializer at the point where it&#39;s generating the pattern. If this would be difficult or impossible to implement, Swift should continue to interpret code like this as attempting to bind an optional tuple, rather than a tuple of optionals.<br>&gt;&gt; <br>&gt; <br>&gt; I think this proposal is definitely worthy of consideration (and implementation). I hesitate that what works or not is being proposed partly on the basis of whether it&#39;s difficult to implement or not. If I could offer a suggestion as to exactly which edge cases should work, I think it should be based on this guideline that can be articulated cleanly:<br>&gt; <br>&gt; Given `if let (a, b, c)...` or any other variation or edge case, transform in your mind&#39;s eye to `if case let (a?, b?, c?)...`. That is, append `case` before `let` and then append `?` immediately after each constant so introduced. If the `if case let...` version would work, so should the `if let...` version. By that rule of thumb, `if case let (a?, (b?, c?)) = (opt1, (opt2, opt3))` would work if I&#39;m not mistaken, as would `if case let (a?, b?) = tuple`, but `if case let tuple? = (opt1, opt2)` would not and thus neither should `if let tuple = (opt1, opt2)`.<br>&gt;  <br>&gt;&gt; Single-name patterns<br>&gt;&gt; <br>&gt;&gt; In theory, Swift could allow you to bind a tuple of optionals to a single constant:<br>&gt;&gt; <br>&gt;&gt; if let tuple = (opt1, opt2) { ... }<br>&gt;&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear picture of the value being operated upon, so you could easily misinterpret it as binding an optional tuple. Because of this ambiguity, Swift should always interpret this construct as binding an optional tuple, rejecting it with a type error if necessary.<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; This proposal is additive compared to SE-0099, but in combination with it, essentially replaces the Swift 2.2 compound binding syntax with a different, incompatible one. When moving directly from Swift 2.2, the migrator should convert old-style compound optional binding clauses:<br>&gt;&gt; <br>&gt;&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;&gt; Into the new, tuple-based ones:<br>&gt;&gt; <br>&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2 and Swift 3, so projects which must support both can still perform multiple optional bindings in a single if statement without resorting to an #if swift(&gt;=3.0) build configuration:<br>&gt;&gt; <br>&gt;&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; Not accepting this proposal<br>&gt;&gt; <br>&gt;&gt; This proposal does not add new functionality; it merely removes keyword clutter. However, it offers a convenient replacement for a commonly-used feature which has just been removed as a result of grammatical ambiguity, not user confusion or lack of utility.<br>&gt;&gt; <br>&gt;&gt; Providing similar standard library functionality<br>&gt;&gt; <br>&gt;&gt; Rather than including this functionality in the compiler, the standard library could provide a series of functions like:<br>&gt;&gt; <br>&gt;&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }<br>&gt;&gt; public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }<br>&gt;&gt; // etc.<br>&gt;&gt; These could then be used in a similar fashion to this proposal:<br>&gt;&gt; <br>&gt;&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt;&gt; However, because we do not have variadic generics, we would need to provide a set of overloads for different arities, and our support would be limited to the arities we chose to provide. (Support for tuples, as opposed to separate parameters, would require a second set of overloads). Meanwhile, the tuple matching syntax is already precedented in case conditionals, so extending it seems pretty natural. Providing this in the compiler seems like the right solution.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/1e5d2872/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 12, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; It takes reaching the last section of the proposal to understand that there is not real issue, that it does not add any functionality, and that it basically amount to stylistic preference for something. It might be more informative to start with that rather than leave it until the end.<br></p><p>You&#39;re right; it&#39;s quite fair to say that acknowledgement should be moved up front. At the same time, I can better justify why it&#39;s not a good solution to the problem.<br></p><p>Motivation<br></p><p>In Swift 2, it was possible to bind multiple optional values in a single if let, guard let, or while let clause:<br></p><p>guard let a = opt1, b = opt2, c = opt3 else { ... }<br>SE-0099 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified the syntax of conditional statements, but removed this feature so that , could instead separate different conditional clauses. Code like this must now use three separate optional binding clauses:<br></p><p>guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>The similar case clause sidesteps this problem because it can pattern-match tuples. Hence, you can put several patterns in a tuple on the left side of the =, and a matching number of values in a tuple on the right side, and match them all with one case clause. This doesn&#39;t conflict with the clause separation syntax because the commas are within parentheses.<br></p><p>In a pinch, this can be used to pattern-match against several optionals:<br></p><p>guard case let (a?, b?, c?) = (opt1, opt2, opt3) else { ... }<br>However, optional binding is itself redundant in exactly the same way. Optional binding exists because the pattern-matching syntax is too clumsy, and requires too much understanding from the user, for such a common operation. The same concerns apply when performing multiple optional bindings.<br></p><p>Swift&#39;s syntax actually permits you to write an optional binding clause analogous to the tuple pattern-match above:<br></p><p>guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>However, Swift does not interpret this as an attempt to bind several optionals inside a tuple; instead it assumes you want to bind and destructure an optional tuple, and type-checking fails because the tuple is not optional.<br></p><p>error: initializer for conditional binding must have Optional type, not <br>&#39;(Int?, Int?, Int?)&#39; (aka &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br></p><p><br>-- <br>Brent Royal-Gordon<br>Architechies<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/433a2988/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>June 12, 2016 at 07:00:00pm</p></header><div class="content"><p>This proposal should specify if the tuple is evaluated “eagerly” or as an “early-exit”. <br></p><p>That is, if we write `if let (foo,bar,baz) = (_foo(), _bar(), _baz())`, and _bar() -&gt; nil, will `_baz()` have been evaluated, or not?<br></p><p>I’d use this feature either way, but the proposal should have a clear statement on this point.<br></p><p>&gt; On Jun 12, 2016, at 6:46 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris said it should be written up as a proposal. I&#39;m sure this will get lost in the WWDC shuffle, but here goes.<br>&gt; Tuple-Based Compound Optional Binding<br>&gt; Proposal: TBD<br>&gt; Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal enhances optional binding with a new, tuple-based syntax for binding multiple values. It replaces functionality lost in SE-0099 with a syntax compatible with the new design.<br>&gt; <br>&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099 Restructuring Condition Clauses &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;Motivation<br>&gt; <br>&gt; In Swift 2, it was possible to bind multiple optional values in a single if let, guard let, or while let clause:<br>&gt; <br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt; SE-0099 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified the syntax of conditional statements, but removed this feature so that , could instead separate different conditional clauses. Code like this must now use three separate optional binding clauses:<br>&gt; <br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt; The similar case clause sidesteps this problem because it can pattern-match tuples. Hence, you can put several patterns in a tuple on the left side of the =, and a matching number of values in a tuple on the right side, and match them all with one case clause:<br>&gt; <br>&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt; This doesn&#39;t conflict with the clause separation syntax because the commas are within parentheses. However, the analogous syntax for optional bindings is not permitted:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; // error: initializer for conditional binding must have <br>&gt; // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka <br>&gt; // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; We should extend optional binding clauses to permit a tuple of optional values on the right of the = and a tuple of constants with identical arity on the left. Swift should test each element of the tuple on the right, and if none of them are nil, bind them to the constants on the left.<br>&gt; <br>&gt; Nothing in this proposal should change the way optional binding handles an optional tuple (T, U)?, as opposed to a tuple of optionals (T?, U?). Even an optional tuple of optionals (T?, U?)? should continue to be handled as before.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; No change to the formal grammar is necessary, as the pattern and initializer productions in the optional-binding-head rule can already match tuples:<br>&gt; <br>&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt; Rather, Sema should be modified to detect this situation and generate appropriate code. Currently, TypeCheckPattern.cpp essentially converts let a = opt1 into case let a? = opt1; if this proposal is accepted, it should similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) = (opt1, opt2).<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge cases<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested tuples-of-optionals<br>&gt; <br>&gt; Permitting deeper pattern matching of nested tuples is highly precedented by pattern matching, but is a niche feature. It should be supported if easily achievable.<br>&gt; <br>&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions returning tuples of optionals<br>&gt; <br>&gt; Ideally, optional bindings whose initializer is an expression evaluating to a tuple of optionals would be supported:<br>&gt; <br>&gt; let tuple = (opt1, opt2)<br>&gt; if let (a, b) = tuple { ... }<br>&gt; However, I&#39;m not sure if Swift will have pinned down the type of the initializer at the point where it&#39;s generating the pattern. If this would be difficult or impossible to implement, Swift should continue to interpret code like this as attempting to bind an optional tuple, rather than a tuple of optionals.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name patterns<br>&gt; <br>&gt; In theory, Swift could allow you to bind a tuple of optionals to a single constant:<br>&gt; <br>&gt; if let tuple = (opt1, opt2) { ... }<br>&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear picture of the value being operated upon, so you could easily misinterpret it as binding an optional tuple. Because of this ambiguity, Swift should always interpret this construct as binding an optional tuple, rejecting it with a type error if necessary.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is additive compared to SE-0099, but in combination with it, essentially replaces the Swift 2.2 compound binding syntax with a different, incompatible one. When moving directly from Swift 2.2, the migrator should convert old-style compound optional binding clauses:<br>&gt; <br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt; Into the new, tuple-based ones:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2 and Swift 3, so projects which must support both can still perform multiple optional bindings in a single if statement without resorting to an #if swift(&gt;=3.0) build configuration:<br>&gt; <br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not accepting this proposal<br>&gt; <br>&gt; This proposal does not add new functionality; it merely removes keyword clutter. However, it offers a convenient replacement for a commonly-used feature which has just been removed as a result of grammatical ambiguity, not user confusion or lack of utility.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing similar standard library functionality<br>&gt; <br>&gt; Rather than including this functionality in the compiler, the standard library could provide a series of functions like:<br>&gt; <br>&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }<br>&gt; public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }<br>&gt; // etc.<br>&gt; These could then be used in a similar fashion to this proposal:<br>&gt; <br>&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt; However, because we do not have variadic generics, we would need to provide a set of overloads for different arities, and our support would be limited to the arities we chose to provide. (Support for tuples, as opposed to separate parameters, would require a second set of overloads). Meanwhile, the tuple matching syntax is already precedented in case conditionals, so extending it seems pretty natural. Providing this in the compiler seems like the right solution.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160612/13b9d86a/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 13, 2016 at 12:00:00am</p></header><div class="content"><p>What&#39;s the behavior currently with `if case let (foo?, bar?, baz?)...`?<br>On Sun, Jun 12, 2016 at 19:53 plx via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This proposal should specify if the tuple is evaluated “eagerly” or as an<br>&gt; “early-exit”.<br>&gt;<br>&gt; That is, if we write `if let (foo,bar,baz) = (_foo(), _bar(), _baz())`,<br>&gt; and _bar() -&gt; nil, will `_baz()` have been evaluated, or not?<br>&gt;<br>&gt; I’d use this feature either way, but the proposal should have a clear<br>&gt; statement on this point.<br>&gt;<br>&gt; On Jun 12, 2016, at 6:46 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris<br>&gt; said it should be written up as a proposal. I&#39;m sure this will get lost in<br>&gt; the WWDC shuffle, but here goes.<br>&gt; Tuple-Based Compound Optional Binding<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal enhances optional binding with a new, tuple-based syntax for<br>&gt; binding multiple values. It replaces functionality lost in SE-0099 with a<br>&gt; syntax compatible with the new design.<br>&gt;<br>&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099<br>&gt; Restructuring Condition Clauses<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; In Swift 2, it was possible to bind multiple optional values in a single if<br>&gt; let, guard let, or while let clause:<br>&gt;<br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;<br>&gt; SE-0099<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified<br>&gt; the syntax of conditional statements, but removed this feature so that , could<br>&gt; instead separate different conditional clauses. Code like this must now use<br>&gt; three separate optional binding clauses:<br>&gt;<br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;<br>&gt; The similar case clause sidesteps this problem because it can<br>&gt; pattern-match tuples. Hence, you can put several patterns in a tuple on the<br>&gt; left side of the =, and a matching number of values in a tuple on the<br>&gt; right side, and match them all with one case clause:<br>&gt;<br>&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt; This doesn&#39;t conflict with the clause separation syntax because the commas<br>&gt; are within parentheses. However, the analogous syntax for optional bindings<br>&gt; is not permitted:<br>&gt;<br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }// error: initializer for conditional binding must have // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; We should extend optional binding clauses to permit a tuple of optional<br>&gt; values on the right of the = and a tuple of constants with identical<br>&gt; arity on the left. Swift should test each element of the tuple on the<br>&gt; right, and if none of them are nil, bind them to the constants on the<br>&gt; left.<br>&gt;<br>&gt; Nothing in this proposal should change the way optional binding handles an *optional<br>&gt; tuple* (T, U)?, as opposed to a *tuple of optionals* (T?, U?). Even an<br>&gt; optional tuple of optionals (T?, U?)? should continue to be handled as<br>&gt; before.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; No change to the formal grammar is necessary, as the *pattern* and<br>&gt; *initializer* productions in the *optional-binding-head* rule can already<br>&gt; match tuples:<br>&gt;<br>&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt;<br>&gt; Rather, Sema should be modified to detect this situation and generate<br>&gt; appropriate code. Currently, TypeCheckPattern.cpp essentially converts let<br>&gt; a = opt1 into case let a? = opt1; if this proposal is accepted, it should<br>&gt; similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) =<br>&gt; (opt1, opt2).<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge<br>&gt; cases<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested<br>&gt; tuples-of-optionals<br>&gt;<br>&gt; Permitting deeper pattern matching of nested tuples is highly precedented<br>&gt; by pattern matching, but is a niche feature. It should be supported if<br>&gt; easily achievable.<br>&gt;<br>&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions<br>&gt; returning tuples of optionals<br>&gt;<br>&gt; Ideally, optional bindings whose *initializer* is an expression<br>&gt; evaluating to a tuple of optionals would be supported:<br>&gt;<br>&gt; let tuple = (opt1, opt2)if let (a, b) = tuple { ... }<br>&gt;<br>&gt; However, I&#39;m not sure if Swift will have pinned down the type of the<br>&gt; initializer at the point where it&#39;s generating the pattern. If this would<br>&gt; be difficult or impossible to implement, Swift should continue to interpret<br>&gt; code like this as attempting to bind an optional tuple, rather than a tuple<br>&gt; of optionals.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name<br>&gt; patterns<br>&gt;<br>&gt; In theory, Swift could allow you to bind a tuple of optionals to a single<br>&gt; constant:<br>&gt;<br>&gt; if let tuple = (opt1, opt2) { ... }<br>&gt;<br>&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear<br>&gt; picture of the value being operated upon, so you could easily misinterpret<br>&gt; it as binding an optional tuple. Because of this ambiguity, Swift should<br>&gt; always interpret this construct as binding an optional tuple, rejecting it<br>&gt; with a type error if necessary.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal is additive compared to SE-0099, but in combination with it,<br>&gt; essentially replaces the Swift 2.2 compound binding syntax with a<br>&gt; different, incompatible one. When moving directly from Swift 2.2, the<br>&gt; migrator should convert old-style compound optional binding clauses:<br>&gt;<br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;<br>&gt; Into the new, tuple-based ones:<br>&gt;<br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2<br>&gt; and Swift 3, so projects which must support both can still perform multiple<br>&gt; optional bindings in a single if statement without resorting to an #if<br>&gt; swift(&gt;=3.0) build configuration:<br>&gt;<br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not<br>&gt; accepting this proposal<br>&gt;<br>&gt; This proposal does not add new functionality; it merely removes keyword<br>&gt; clutter. However, it offers a convenient replacement for a commonly-used<br>&gt; feature which has just been removed as a result of grammatical ambiguity,<br>&gt; not user confusion or lack of utility.<br>&gt;<br>&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing<br>&gt; similar standard library functionality<br>&gt;<br>&gt; Rather than including this functionality in the compiler, the standard<br>&gt; library could provide a series of functions like:<br>&gt;<br>&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }// etc.<br>&gt;<br>&gt; These could then be used in a similar fashion to this proposal:<br>&gt;<br>&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt;<br>&gt; However, because we do not have variadic generics, we would need to<br>&gt; provide a set of overloads for different arities, and our support would be<br>&gt; limited to the arities we chose to provide. (Support for tuples, as opposed<br>&gt; to separate parameters, would require a second set of overloads).<br>&gt; Meanwhile, the tuple matching syntax is already precedented in case conditionals,<br>&gt; so extending it seems pretty natural. Providing this in the compiler seems<br>&gt; like the right solution.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/89e345a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/57885cfd0c4b4db16653e76d9e6f0266?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Johan Jensen</string> &lt;jj at johanjensen.dk&gt;<p>June 13, 2016 at 09:00:00am</p></header><div class="content"><p>Currently `if case let (foo?, bar?, baz?) = (_foo(), _bar(), _baz())`, and<br>_bar() returns nil, then `_baz()` will not be evaluated.<br></p><p>On Mon, Jun 13, 2016 at 2:54 AM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; What&#39;s the behavior currently with `if case let (foo?, bar?, baz?)...`?<br>&gt;<br>&gt; On Sun, Jun 12, 2016 at 19:53 plx via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This proposal should specify if the tuple is evaluated “eagerly” or as an<br>&gt;&gt; “early-exit”.<br>&gt;&gt;<br>&gt;&gt; That is, if we write `if let (foo,bar,baz) = (_foo(), _bar(), _baz())`,<br>&gt;&gt; and _bar() -&gt; nil, will `_baz()` have been evaluated, or not?<br>&gt;&gt;<br>&gt;&gt; I’d use this feature either way, but the proposal should have a clear<br>&gt;&gt; statement on this point.<br>&gt;&gt;<br>&gt;&gt; On Jun 12, 2016, at 6:46 AM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris<br>&gt;&gt; said it should be written up as a proposal. I&#39;m sure this will get lost in<br>&gt;&gt; the WWDC shuffle, but here goes.<br>&gt;&gt; Tuple-Based Compound Optional Binding<br>&gt;&gt;<br>&gt;&gt;    - Proposal: TBD<br>&gt;&gt;    - Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt;&gt;    - Status: TBD<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal enhances optional binding with a new, tuple-based syntax<br>&gt;&gt; for binding multiple values. It replaces functionality lost in SE-0099 with<br>&gt;&gt; a syntax compatible with the new design.<br>&gt;&gt;<br>&gt;&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099<br>&gt;&gt; Restructuring Condition Clauses<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; In Swift 2, it was possible to bind multiple optional values in a single if<br>&gt;&gt; let, guard let, or while let clause:<br>&gt;&gt;<br>&gt;&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;&gt;<br>&gt;&gt; SE-0099<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified<br>&gt;&gt; the syntax of conditional statements, but removed this feature so that , could<br>&gt;&gt; instead separate different conditional clauses. Code like this must now use<br>&gt;&gt; three separate optional binding clauses:<br>&gt;&gt;<br>&gt;&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;&gt;<br>&gt;&gt; The similar case clause sidesteps this problem because it can<br>&gt;&gt; pattern-match tuples. Hence, you can put several patterns in a tuple on the<br>&gt;&gt; left side of the =, and a matching number of values in a tuple on the<br>&gt;&gt; right side, and match them all with one case clause:<br>&gt;&gt;<br>&gt;&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt;<br>&gt;&gt; This doesn&#39;t conflict with the clause separation syntax because the<br>&gt;&gt; commas are within parentheses. However, the analogous syntax for optional<br>&gt;&gt; bindings is not permitted:<br>&gt;&gt;<br>&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }// error: initializer for conditional binding must have // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed<br>&gt;&gt; Solution<br>&gt;&gt;<br>&gt;&gt; We should extend optional binding clauses to permit a tuple of optional<br>&gt;&gt; values on the right of the = and a tuple of constants with identical<br>&gt;&gt; arity on the left. Swift should test each element of the tuple on the<br>&gt;&gt; right, and if none of them are nil, bind them to the constants on the<br>&gt;&gt; left.<br>&gt;&gt;<br>&gt;&gt; Nothing in this proposal should change the way optional binding handles<br>&gt;&gt; an *optional tuple* (T, U)?, as opposed to a *tuple of optionals* (T?,<br>&gt;&gt; U?). Even an optional tuple of optionals (T?, U?)? should continue to be<br>&gt;&gt; handled as before.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; No change to the formal grammar is necessary, as the *pattern* and<br>&gt;&gt; *initializer* productions in the *optional-binding-head* rule can<br>&gt;&gt; already match tuples:<br>&gt;&gt;<br>&gt;&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt;&gt;<br>&gt;&gt; Rather, Sema should be modified to detect this situation and generate<br>&gt;&gt; appropriate code. Currently, TypeCheckPattern.cpp essentially converts let<br>&gt;&gt; a = opt1 into case let a? = opt1; if this proposal is accepted, it<br>&gt;&gt; should similarly convert let (a, b) = (opt1, opt2) into case let (a?,<br>&gt;&gt; b?) = (opt1, opt2).<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge<br>&gt;&gt; cases<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested<br>&gt;&gt; tuples-of-optionals<br>&gt;&gt;<br>&gt;&gt; Permitting deeper pattern matching of nested tuples is highly precedented<br>&gt;&gt; by pattern matching, but is a niche feature. It should be supported if<br>&gt;&gt; easily achievable.<br>&gt;&gt;<br>&gt;&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions<br>&gt;&gt; returning tuples of optionals<br>&gt;&gt;<br>&gt;&gt; Ideally, optional bindings whose *initializer* is an expression<br>&gt;&gt; evaluating to a tuple of optionals would be supported:<br>&gt;&gt;<br>&gt;&gt; let tuple = (opt1, opt2)if let (a, b) = tuple { ... }<br>&gt;&gt;<br>&gt;&gt; However, I&#39;m not sure if Swift will have pinned down the type of the<br>&gt;&gt; initializer at the point where it&#39;s generating the pattern. If this would<br>&gt;&gt; be difficult or impossible to implement, Swift should continue to interpret<br>&gt;&gt; code like this as attempting to bind an optional tuple, rather than a tuple<br>&gt;&gt; of optionals.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name<br>&gt;&gt; patterns<br>&gt;&gt;<br>&gt;&gt; In theory, Swift could allow you to bind a tuple of optionals to a single<br>&gt;&gt; constant:<br>&gt;&gt;<br>&gt;&gt; if let tuple = (opt1, opt2) { ... }<br>&gt;&gt;<br>&gt;&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear<br>&gt;&gt; picture of the value being operated upon, so you could easily misinterpret<br>&gt;&gt; it as binding an optional tuple. Because of this ambiguity, Swift should<br>&gt;&gt; always interpret this construct as binding an optional tuple, rejecting it<br>&gt;&gt; with a type error if necessary.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact<br>&gt;&gt; on Existing Code<br>&gt;&gt;<br>&gt;&gt; This proposal is additive compared to SE-0099, but in combination with<br>&gt;&gt; it, essentially replaces the Swift 2.2 compound binding syntax with a<br>&gt;&gt; different, incompatible one. When moving directly from Swift 2.2, the<br>&gt;&gt; migrator should convert old-style compound optional binding clauses:<br>&gt;&gt;<br>&gt;&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt;&gt;<br>&gt;&gt; Into the new, tuple-based ones:<br>&gt;&gt;<br>&gt;&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt;&gt;<br>&gt;&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2<br>&gt;&gt; and Swift 3, so projects which must support both can still perform multiple<br>&gt;&gt; optional bindings in a single if statement without resorting to an #if<br>&gt;&gt; swift(&gt;=3.0) build configuration:<br>&gt;&gt;<br>&gt;&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives<br>&gt;&gt; Considered<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not<br>&gt;&gt; accepting this proposal<br>&gt;&gt;<br>&gt;&gt; This proposal does not add new functionality; it merely removes keyword<br>&gt;&gt; clutter. However, it offers a convenient replacement for a commonly-used<br>&gt;&gt; feature which has just been removed as a result of grammatical ambiguity,<br>&gt;&gt; not user confusion or lack of utility.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing<br>&gt;&gt; similar standard library functionality<br>&gt;&gt;<br>&gt;&gt; Rather than including this functionality in the compiler, the standard<br>&gt;&gt; library could provide a series of functions like:<br>&gt;&gt;<br>&gt;&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }// etc.<br>&gt;&gt;<br>&gt;&gt; These could then be used in a similar fashion to this proposal:<br>&gt;&gt;<br>&gt;&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt;&gt;<br>&gt;&gt; However, because we do not have variadic generics, we would need to<br>&gt;&gt; provide a set of overloads for different arities, and our support would be<br>&gt;&gt; limited to the arities we chose to provide. (Support for tuples, as opposed<br>&gt;&gt; to separate parameters, would require a second set of overloads).<br>&gt;&gt; Meanwhile, the tuple matching syntax is already precedented in case conditionals,<br>&gt;&gt; so extending it seems pretty natural. Providing this in the compiler seems<br>&gt;&gt; like the right solution.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/21b8d069/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 13, 2016 at 09:00:00am</p></header><div class="content"><p>+1 from me; I never considered that I could do this using pattern matching of a tuple, and as Brent says this is a nicer shorthand for introducing users to conditional binding in advance of teaching the finer details of pattern matching, plus I prefer it visually.<br></p><p>&gt; On 12 Jun 2016, at 12:46, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris said it should be written up as a proposal. I&#39;m sure this will get lost in the WWDC shuffle, but here goes.<br>&gt; Tuple-Based Compound Optional Binding<br>&gt; Proposal: TBD<br>&gt; Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal enhances optional binding with a new, tuple-based syntax for binding multiple values. It replaces functionality lost in SE-0099 with a syntax compatible with the new design.<br>&gt; <br>&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099 Restructuring Condition Clauses &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;Motivation<br>&gt; <br>&gt; In Swift 2, it was possible to bind multiple optional values in a single if let, guard let, or while let clause:<br>&gt; <br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt; SE-0099 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified the syntax of conditional statements, but removed this feature so that , could instead separate different conditional clauses. Code like this must now use three separate optional binding clauses:<br>&gt; <br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt; The similar case clause sidesteps this problem because it can pattern-match tuples. Hence, you can put several patterns in a tuple on the left side of the =, and a matching number of values in a tuple on the right side, and match them all with one case clause:<br>&gt; <br>&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt; This doesn&#39;t conflict with the clause separation syntax because the commas are within parentheses. However, the analogous syntax for optional bindings is not permitted:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; // error: initializer for conditional binding must have <br>&gt; // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka <br>&gt; // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; We should extend optional binding clauses to permit a tuple of optional values on the right of the = and a tuple of constants with identical arity on the left. Swift should test each element of the tuple on the right, and if none of them are nil, bind them to the constants on the left.<br>&gt; <br>&gt; Nothing in this proposal should change the way optional binding handles an optional tuple (T, U)?, as opposed to a tuple of optionals (T?, U?). Even an optional tuple of optionals (T?, U?)? should continue to be handled as before.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; No change to the formal grammar is necessary, as the pattern and initializer productions in the optional-binding-head rule can already match tuples:<br>&gt; <br>&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt; Rather, Sema should be modified to detect this situation and generate appropriate code. Currently, TypeCheckPattern.cpp essentially converts let a = opt1 into case let a? = opt1; if this proposal is accepted, it should similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) = (opt1, opt2).<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge cases<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested tuples-of-optionals<br>&gt; <br>&gt; Permitting deeper pattern matching of nested tuples is highly precedented by pattern matching, but is a niche feature. It should be supported if easily achievable.<br>&gt; <br>&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions returning tuples of optionals<br>&gt; <br>&gt; Ideally, optional bindings whose initializer is an expression evaluating to a tuple of optionals would be supported:<br>&gt; <br>&gt; let tuple = (opt1, opt2)<br>&gt; if let (a, b) = tuple { ... }<br>&gt; However, I&#39;m not sure if Swift will have pinned down the type of the initializer at the point where it&#39;s generating the pattern. If this would be difficult or impossible to implement, Swift should continue to interpret code like this as attempting to bind an optional tuple, rather than a tuple of optionals.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name patterns<br>&gt; <br>&gt; In theory, Swift could allow you to bind a tuple of optionals to a single constant:<br>&gt; <br>&gt; if let tuple = (opt1, opt2) { ... }<br>&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear picture of the value being operated upon, so you could easily misinterpret it as binding an optional tuple. Because of this ambiguity, Swift should always interpret this construct as binding an optional tuple, rejecting it with a type error if necessary.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is additive compared to SE-0099, but in combination with it, essentially replaces the Swift 2.2 compound binding syntax with a different, incompatible one. When moving directly from Swift 2.2, the migrator should convert old-style compound optional binding clauses:<br>&gt; <br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt; Into the new, tuple-based ones:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2 and Swift 3, so projects which must support both can still perform multiple optional bindings in a single if statement without resorting to an #if swift(&gt;=3.0) build configuration:<br>&gt; <br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not accepting this proposal<br>&gt; <br>&gt; This proposal does not add new functionality; it merely removes keyword clutter. However, it offers a convenient replacement for a commonly-used feature which has just been removed as a result of grammatical ambiguity, not user confusion or lack of utility.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing similar standard library functionality<br>&gt; <br>&gt; Rather than including this functionality in the compiler, the standard library could provide a series of functions like:<br>&gt; <br>&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }<br>&gt; public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }<br>&gt; // etc.<br>&gt; These could then be used in a similar fashion to this proposal:<br>&gt; <br>&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt; However, because we do not have variadic generics, we would need to provide a set of overloads for different arities, and our support would be limited to the arities we chose to provide. (Support for tuples, as opposed to separate parameters, would require a second set of overloads). Meanwhile, the tuple matching syntax is already precedented in case conditionals, so extending it seems pretty natural. Providing this in the compiler seems like the right solution.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160613/498fd721/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 12, 2016, at 4:46 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris said it should be written up as a proposal. I&#39;m sure this will get lost in the WWDC shuffle, but here goes.<br></p><p>Hi Brent,<br></p><p>I’m sorry that I haven’t had time yet to read the down thread responses, but I don’t see how this can work:<br></p><p><br>“if let pattern = expr” is sugar for “if case let pattern? = expr”, so this would either:<br></p><p>a) only apply to tuple literals on the right side or<br>b) not work, since this syntax above already means “if case let (a,b,c)? = expr”.<br></p><p>If you pick a, then it is makes tuple literals inconsistent with other expressions, which seems to make the language more confusing and less orthogonal.<br></p><p>-Chris<br></p><p><br></p><p><br></p><p>&gt; Tuple-Based Compound Optional Binding<br>&gt; Proposal: TBD<br>&gt; Author: Brent Royal-Gordon &lt;https://github.com/brentdax&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal enhances optional binding with a new, tuple-based syntax for binding multiple values. It replaces functionality lost in SE-0099 with a syntax compatible with the new design.<br>&gt; <br>&gt; Swift Evolution Discussion: [Accepted with Revision] SE-0099 Restructuring Condition Clauses &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/19452/focus=20139&gt;<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#motivation&gt;Motivation<br>&gt; <br>&gt; In Swift 2, it was possible to bind multiple optional values in a single if let, guard let, or while let clause:<br>&gt; <br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt; SE-0099 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0099-conditionclauses.md&gt; simplified the syntax of conditional statements, but removed this feature so that , could instead separate different conditional clauses. Code like this must now use three separate optional binding clauses:<br>&gt; <br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt; The similar case clause sidesteps this problem because it can pattern-match tuples. Hence, you can put several patterns in a tuple on the left side of the =, and a matching number of values in a tuple on the right side, and match them all with one case clause:<br>&gt; <br>&gt; guard case (.none, .none, .none) = (opt1, opt2, opt3) else { ... }<br>&gt; This doesn&#39;t conflict with the clause separation syntax because the commas are within parentheses. However, the analogous syntax for optional bindings is not permitted:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; // error: initializer for conditional binding must have <br>&gt; // Optional type, not &#39;(Int?, Int?, Int?)&#39; (aka <br>&gt; // &#39;(Optional&lt;Int&gt;, Optional&lt;Int&gt;, Optional&lt;Int&gt;)&#39;)<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; We should extend optional binding clauses to permit a tuple of optional values on the right of the = and a tuple of constants with identical arity on the left. Swift should test each element of the tuple on the right, and if none of them are nil, bind them to the constants on the left.<br>&gt; <br>&gt; Nothing in this proposal should change the way optional binding handles an optional tuple (T, U)?, as opposed to a tuple of optionals (T?, U?). Even an optional tuple of optionals (T?, U?)? should continue to be handled as before.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; No change to the formal grammar is necessary, as the pattern and initializer productions in the optional-binding-head rule can already match tuples:<br>&gt; <br>&gt; optional-binding-head : &#39;let&#39; pattern initializer<br>&gt; Rather, Sema should be modified to detect this situation and generate appropriate code. Currently, TypeCheckPattern.cpp essentially converts let a = opt1 into case let a? = opt1; if this proposal is accepted, it should similarly convert let (a, b) = (opt1, opt2) into case let (a?, b?) = (opt1, opt2).<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#edge-cases&gt;Edge cases<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#nested-tuples-of-optionals&gt;Nested tuples-of-optionals<br>&gt; <br>&gt; Permitting deeper pattern matching of nested tuples is highly precedented by pattern matching, but is a niche feature. It should be supported if easily achievable.<br>&gt; <br>&gt; guard let (a, (b, c)) = (opt1, (opt2, opt3)) else { ... }<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#expressions-returning-tuples-of-optionals&gt;Expressions returning tuples of optionals<br>&gt; <br>&gt; Ideally, optional bindings whose initializer is an expression evaluating to a tuple of optionals would be supported:<br>&gt; <br>&gt; let tuple = (opt1, opt2)<br>&gt; if let (a, b) = tuple { ... }<br>&gt; However, I&#39;m not sure if Swift will have pinned down the type of the initializer at the point where it&#39;s generating the pattern. If this would be difficult or impossible to implement, Swift should continue to interpret code like this as attempting to bind an optional tuple, rather than a tuple of optionals.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#single-name-patterns&gt;Single-name patterns<br>&gt; <br>&gt; In theory, Swift could allow you to bind a tuple of optionals to a single constant:<br>&gt; <br>&gt; if let tuple = (opt1, opt2) { ... }<br>&gt; However, this seems error-prone; the pattern doesn&#39;t draw a very clear picture of the value being operated upon, so you could easily misinterpret it as binding an optional tuple. Because of this ambiguity, Swift should always interpret this construct as binding an optional tuple, rejecting it with a type error if necessary.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal is additive compared to SE-0099, but in combination with it, essentially replaces the Swift 2.2 compound binding syntax with a different, incompatible one. When moving directly from Swift 2.2, the migrator should convert old-style compound optional binding clauses:<br>&gt; <br>&gt; guard let a = opt1, b = opt2, c = opt3 else { ... }<br>&gt; Into the new, tuple-based ones:<br>&gt; <br>&gt; guard let (a, b, c) = (opt1, opt2, opt3) else { ... }<br>&gt; The &quot;one-let-per-binding&quot; syntax remains compatible with both Swift 2.2 and Swift 3, so projects which must support both can still perform multiple optional bindings in a single if statement without resorting to an #if swift(&gt;=3.0) build configuration:<br>&gt; <br>&gt; guard let a = opt1, let b = opt2, let c = opt3 else { ... }<br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#not-accepting-this-proposal&gt;Not accepting this proposal<br>&gt; <br>&gt; This proposal does not add new functionality; it merely removes keyword clutter. However, it offers a convenient replacement for a commonly-used feature which has just been removed as a result of grammatical ambiguity, not user confusion or lack of utility.<br>&gt; <br>&gt;  &lt;https://gist.github.com/brentdax/46c340c967358589ade5351531ac8920#providing-similar-standard-library-functionality&gt;Providing similar standard library functionality<br>&gt; <br>&gt; Rather than including this functionality in the compiler, the standard library could provide a series of functions like:<br>&gt; <br>&gt; public func all&lt;T, U&gt;(_ t: T?, _ u: U?) -&gt; (T, U)? { ... }<br>&gt; public func all&lt;T, U, V&gt;(_ t: T?, _ u: U?, _ v: V?) -&gt; (T, U, V)? { ... }<br>&gt; // etc.<br>&gt; These could then be used in a similar fashion to this proposal:<br>&gt; <br>&gt; guard let (a, b, c) = all(opt1, opt2, opt3) else { ... }<br>&gt; However, because we do not have variadic generics, we would need to provide a set of overloads for different arities, and our support would be limited to the arities we chose to provide. (Support for tuples, as opposed to separate parameters, would require a second set of overloads). Meanwhile, the tuple matching syntax is already precedented in case conditionals, so extending it seems pretty natural. Providing this in the compiler seems like the right solution.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/af4e9eca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Draft] Tuple-Based Compound Optional Binding</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 21, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 21, 2016, at 11:11 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 12, 2016, at 4:46 AM, Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; When I suggested this syntax in the acceptance thread for SE-0099, Chris said it should be written up as a proposal. I&#39;m sure this will get lost in the WWDC shuffle, but here goes.<br>&gt; <br>&gt; Hi Brent,<br>&gt; <br>&gt; I’m sorry that I haven’t had time yet to read the down thread responses, but I don’t see how this can work:<br>&gt; <br>&gt; <br>&gt; “if let pattern = expr” is sugar for “if case let pattern? = expr”, so this would either:<br>&gt; <br>&gt; a) only apply to tuple literals on the right side or<br>&gt; b) not work, since this syntax above already means “if case let (a,b,c)? = expr”.<br></p><p>Sorry, I mean that:<br></p><p>&quot;if let (a, b, c) = expr” <br>already means:<br>“if case let (a,b,c)? = expr”<br></p><p>since “expr” can be an optional tuple.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160621/ea14dd79/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
