<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: only allow capture of inout parameters in @noescape closures</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 28, 2016 at 11:00:00am</p></header><div class="content"><p>I think the time has come for us to limit the implicit capture of &#39;inout&#39; parameters to @noescape closures. In the early days before @noescape, we designed a semantics for capturing &quot;inout&quot; parameters that attempted to balance the constraints on inout with the usability of higher-order functions. Inout parameters don&#39;t pass a first-class reference as in other languages, but instead provide a limited lease to mutate a property for the duration of a call; this means closures can&#39;t extend the lifetime of that lease, so closures instead capture the local mutable copy of the inout parameter. This gives the expected behavior as long as closures over an inout parameter never escape their original scope, but leads to surprises as soon as those closures escape. This unintuitive behavior has made several &quot;Swift gotchas&quot; lists. Now that we can explicitly mark closures as not escaping, I think we should prevent &#39;inout&#39; parameters from being implicitly captured by escapable closures. There are several ways we can still support today&#39;s behavior:<br></p><p>- Encourage people to write the local copy themselves, if that&#39;s what they want:<br></p><p>func foo(inout x: Int) {<br>  var localX = x; defer { x = localX }<br></p><p>  // Asynchronously mutate localX, then wait for it to finish<br>  dispatch_async { mutate(&amp;localX) }<br>  dispatch_sync {}<br>}<br></p><p>- You can explicitly capture an immutable copy:<br></p><p>func foo(inout x: Int) {<br>  // We don&#39;t need to mutate or observe mutations on x in the async job<br>  dispatch_async {[x] in doStuffWithoutMutating(x) }<br>}<br></p><p>and/or we could introduce a new explicit capture kind for the current behavior:<br></p><p>func foo(inout x: Int) {<br>  // Explicitly capture the &#39;inout&#39; mutable shadow copy of x<br>  dispatch_async {[inout x] in mutate(&amp;x) }<br>  dispatch_sync { }<br>}<br></p><p>Making it explicit should make the behavior less surprising when it occurs. We should able to provide fixits to migrate code that relies on the current behavior as well. What do you all think?<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/d58382c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Pitch: only allow capture of inout parameters in @noescape closures</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m generally in favor of this. My biggest concern is when using<br>closures that are known not to escape the function but aren&#39;t marked as<br>@noescape. Sometimes this is just due to the frameworks not annotating<br>types properly, e.g. dispatch_sync()&#39;s closure isn&#39;t @noescaping.<br>Sometimes this is due to a function taking a closure that may escape<br>sometimes, but not escape at other times (e.g. UIView animation methods<br>usually don&#39;t escape the animation block, unless a non-zero delay is<br>provided). And sometimes this is due to synchronization at a level the<br>API doesn&#39;t know about, such as using dispatch_async + dispatch_group to<br>wait until a block has executed.<br></p><p>That said, if dispatch_sync() is fixed, then I think it&#39;s reasonable to<br>require people to use manual workarounds for the remaining issues (e.g.<br>writing a local copy themselves). Especially because capturing an inout<br>parameter in a block is a relatively rare thing to do anyway (I don&#39;t<br>think I&#39;ve ever actually done that myself, which is why I wasn&#39;t even<br>sure how Swift handled it).<br></p><p>The idea of using a capture list of [inout x] is interesting, but<br>ultimately confusing, because inout implies writeback semantics, when in<br>fact the closure wouldn&#39;t be doing writeback but would in fact be<br>closing over a shared mutable value (e.g. writeback implies there&#39;s a<br>specific point where the modified value becomes visible to the enclosing<br>scope, but that can&#39;t possibly work with non- at noescape closures because<br>there&#39;s no single point where the compiler knows it&#39;s appropriate to<br>insert the writeback). Based on that, I think the local copy version is<br>the most appropriate workaround.<br></p><p>So, given all that, +1 from me, but I really want to see dispatch_sync()<br>fixed as soon as possible (I want it fixed anyway, but I think<br>dispatch_sync() is the most likely candidate for unexpectedly hitting<br>this proposed limitation in Swift). I recognize that dispatch_sync()<br>isn&#39;t something the Swift team can fix (though Swift does have its own<br>copy of libdispatch, I assume that changes made to that don&#39;t actually<br>propagate upstream back to Apple&#39;s version), but since Swift core team<br>members are Apple employees, perhaps they can put some pressure on the<br>appropriate team to add the noescaping attribute to the appropriate<br>libdispatch APIs.<br></p><p>-Kevin Ballard<br></p><p>On Thu, Jan 28, 2016, at 11:58 AM, Joe Groff via swift-evolution wrote:<br>&gt; I think the time has come for us to limit the implicit capture of<br>&gt; &#39;inout&#39; parameters to @noescape closures. In the early days before<br>&gt; @noescape, we designed a semantics for capturing &quot;inout&quot; parameters<br>&gt; that attempted to balance the constraints on inout with the usability<br>&gt; of higher-order functions. Inout parameters don&#39;t pass a first-class<br>&gt; reference as in other languages, but instead provide a limited lease<br>&gt; to mutate a property for the duration of a call; this means closures<br>&gt; can&#39;t extend the lifetime of that lease, so closures instead capture<br>&gt; the local mutable copy of the inout parameter. This gives the expected<br>&gt; behavior as long as closures over an inout parameter never escape<br>&gt; their original scope, but leads to surprises as soon as those closures<br>&gt; escape. This unintuitive behavior has made several &quot;Swift gotchas&quot;<br>&gt; lists. Now that we can explicitly mark closures as not escaping, I<br>&gt; think we should prevent &#39;inout&#39; parameters from being implicitly<br>&gt; captured by escapable closures. There are several ways we can still<br>&gt; support today&#39;s behavior:<br>&gt;<br>&gt; - Encourage people to write the local copy themselves, if that&#39;s what<br>&gt;   they want:<br>&gt;<br>&gt;&gt; func foo(inout x: Int) {  var localX = x; defer { x = localX }<br>&gt;&gt;<br>&gt;&gt; // Asynchronously mutate localX, then wait for it to finish<br>&gt;&gt; dispatch_async { mutate(&amp;localX) }  dispatch_sync {} }<br>&gt;&gt;<br>&gt; - You can explicitly capture an immutable copy:<br>&gt;<br>&gt;&gt; func foo(inout x: Int) {  // We don&#39;t need to mutate or observe<br>&gt;&gt; mutations on x in the async job  dispatch_async {[x] in<br>&gt;&gt; doStuffWithoutMutating(x) } }<br>&gt;&gt;<br>&gt; and/or we could introduce a new explicit capture kind for the current<br>&gt; behavior:<br>&gt;<br>&gt;&gt; func foo(inout x: Int) {  // Explicitly capture the &#39;inout&#39; mutable<br>&gt;&gt; shadow copy of x  dispatch_async {[inout x] in mutate(&amp;x) }<br>&gt;&gt; dispatch_sync { } }<br>&gt;<br>&gt; Making it explicit should make the behavior less surprising when it<br>&gt; occurs. We should able to provide fixits to migrate code that relies<br>&gt; on the current behavior as well. What do you all think?<br>&gt;<br>&gt; -Joe<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/ec98ea96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pitch: only allow capture of inout parameters in @noescape closures</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>[ shameless plug for<br>https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md<br>]<br></p><p>On Thu, Jan 28, 2016 at 1:46 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m generally in favor of this. My biggest concern is when using closures<br>&gt; that are known not to escape the function but aren&#39;t marked as @noescape.<br>&gt; Sometimes this is just due to the frameworks not annotating types properly,<br>&gt; e.g. dispatch_sync()&#39;s closure isn&#39;t @noescaping. Sometimes this is due to<br>&gt; a function taking a closure that may escape sometimes, but not escape at<br>&gt; other times (e.g. UIView animation methods usually don&#39;t escape the<br>&gt; animation block, unless a non-zero delay is provided). And sometimes this<br>&gt; is due to synchronization at a level the API doesn&#39;t know about, such as<br>&gt; using dispatch_async + dispatch_group to wait until a block has executed.<br>&gt;<br>&gt; That said, if dispatch_sync() is fixed, then I think it&#39;s reasonable to<br>&gt; require people to use manual workarounds for the remaining issues (e.g.<br>&gt; writing a local copy themselves). Especially because capturing an inout<br>&gt; parameter in a block is a relatively rare thing to do anyway (I don&#39;t think<br>&gt; I&#39;ve ever actually done that myself, which is why I wasn&#39;t even sure how<br>&gt; Swift handled it).<br>&gt;<br>&gt; The idea of using a capture list of [inout x] is interesting, but<br>&gt; ultimately confusing, because inout implies writeback semantics, when in<br>&gt; fact the closure wouldn&#39;t be doing writeback but would in fact be closing<br>&gt; over a shared mutable value (e.g. writeback implies there&#39;s a specific<br>&gt; point where the modified value becomes visible to the enclosing scope, but<br>&gt; that can&#39;t possibly work with non- at noescape closures because there&#39;s no<br>&gt; single point where the compiler knows it&#39;s appropriate to insert the<br>&gt; writeback). Based on that, I think the local copy version is the most<br>&gt; appropriate workaround.<br>&gt;<br>&gt; So, given all that, +1 from me, but I really want to see dispatch_sync()<br>&gt; fixed as soon as possible (I want it fixed anyway, but I think<br>&gt; dispatch_sync() is the most likely candidate for unexpectedly hitting this<br>&gt; proposed limitation in Swift). I recognize that dispatch_sync() isn&#39;t<br>&gt; something the Swift team can fix (though Swift does have its own copy of<br>&gt; libdispatch, I assume that changes made to that don&#39;t actually propagate<br>&gt; upstream back to Apple&#39;s version), but since Swift core team members are<br>&gt; Apple employees, perhaps they can put some pressure on the appropriate team<br>&gt; to add the noescaping attribute to the appropriate libdispatch APIs.<br>&gt;<br>&gt; -Kevin Ballard<br>&gt;<br>&gt; On Thu, Jan 28, 2016, at 11:58 AM, Joe Groff via swift-evolution wrote:<br>&gt;<br>&gt; I think the time has come for us to limit the implicit capture of &#39;inout&#39;<br>&gt; parameters to @noescape closures. In the early days before @noescape, we<br>&gt; designed a semantics for capturing &quot;inout&quot; parameters that attempted to<br>&gt; balance the constraints on inout with the usability of higher-order<br>&gt; functions. Inout parameters don&#39;t pass a first-class reference as in other<br>&gt; languages, but instead provide a limited lease to mutate a property for the<br>&gt; duration of a call; this means closures can&#39;t extend the lifetime of that<br>&gt; lease, so closures instead capture the local mutable copy of the inout<br>&gt; parameter. This gives the expected behavior as long as closures over an<br>&gt; inout parameter never escape their original scope, but leads to surprises<br>&gt; as soon as those closures escape. This unintuitive behavior has made<br>&gt; several &quot;Swift gotchas&quot; lists. Now that we can explicitly mark closures as<br>&gt; not escaping, I think we should prevent &#39;inout&#39; parameters from being<br>&gt; implicitly captured by escapable closures. There are several ways we can<br>&gt; still support today&#39;s behavior:<br>&gt;<br>&gt; - Encourage people to write the local copy themselves, if that&#39;s what they<br>&gt; want:<br>&gt;<br>&gt;<br>&gt; func foo(inout x: Int) {<br>&gt;   var localX = x; defer { x = localX }<br>&gt;<br>&gt;   // Asynchronously mutate localX, then wait for it to finish<br>&gt;   dispatch_async { mutate(&amp;localX) }<br>&gt;   dispatch_sync {}<br>&gt; }<br>&gt;<br>&gt;<br>&gt; - You can explicitly capture an immutable copy:<br>&gt;<br>&gt;<br>&gt; func foo(inout x: Int) {<br>&gt;   // We don&#39;t need to mutate or observe mutations on x in the async job<br>&gt;   dispatch_async {[x] in doStuffWithoutMutating(x) }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; and/or we could introduce a new explicit capture kind for the current<br>&gt; behavior:<br>&gt;<br>&gt;<br>&gt; func foo(inout x: Int) {<br>&gt;   // Explicitly capture the &#39;inout&#39; mutable shadow copy of x<br>&gt;   dispatch_async {[inout x] in mutate(&amp;x) }<br>&gt;   dispatch_sync { }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Making it explicit should make the behavior less surprising when it<br>&gt; occurs. We should able to provide fixits to migrate code that relies on the<br>&gt; current behavior as well. What do you all think?<br>&gt;<br>&gt; -Joe<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/d2523cf4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Pitch: only allow capture of inout parameters in @noescape closures</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 from me, with no new capture kind. I think the workaround is easy enough that we don&#39;t need to worry about APIs that haven&#39;t been annotated yet, or APIs that are synchronous this time. Of course, it would be nice if the compiler could even insert the copy/writeback in a note fix-it.<br></p><p>Jordan<br></p><p>&gt; On Jan 28, 2016, at 11:58, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the time has come for us to limit the implicit capture of &#39;inout&#39; parameters to @noescape closures. In the early days before @noescape, we designed a semantics for capturing &quot;inout&quot; parameters that attempted to balance the constraints on inout with the usability of higher-order functions. Inout parameters don&#39;t pass a first-class reference as in other languages, but instead provide a limited lease to mutate a property for the duration of a call; this means closures can&#39;t extend the lifetime of that lease, so closures instead capture the local mutable copy of the inout parameter. This gives the expected behavior as long as closures over an inout parameter never escape their original scope, but leads to surprises as soon as those closures escape. This unintuitive behavior has made several &quot;Swift gotchas&quot; lists. Now that we can explicitly mark closures as not escaping, I think we should prevent &#39;inout&#39; parameters from being implicitly captured by escapable closures. There are several ways we can still support today&#39;s behavior:<br>&gt; <br>&gt; - Encourage people to write the local copy themselves, if that&#39;s what they want:<br>&gt; <br>&gt; func foo(inout x: Int) {<br>&gt;   var localX = x; defer { x = localX }<br>&gt; <br>&gt;   // Asynchronously mutate localX, then wait for it to finish<br>&gt;   dispatch_async { mutate(&amp;localX) }<br>&gt;   dispatch_sync {}<br>&gt; }<br>&gt; <br>&gt; - You can explicitly capture an immutable copy:<br>&gt; <br>&gt; func foo(inout x: Int) {<br>&gt;   // We don&#39;t need to mutate or observe mutations on x in the async job<br>&gt;   dispatch_async {[x] in doStuffWithoutMutating(x) }<br>&gt; }<br>&gt; <br>&gt; and/or we could introduce a new explicit capture kind for the current behavior:<br>&gt; <br>&gt; func foo(inout x: Int) {<br>&gt;   // Explicitly capture the &#39;inout&#39; mutable shadow copy of x<br>&gt;   dispatch_async {[inout x] in mutate(&amp;x) }<br>&gt;   dispatch_sync { }<br>&gt; }<br>&gt; <br>&gt; Making it explicit should make the behavior less surprising when it occurs. We should able to provide fixits to migrate code that relies on the current behavior as well. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/1669e727/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Pitch: only allow capture of inout parameters in @noescape closures</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 28, 2016, at 1:50 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 from me, with no new capture kind.<br></p><p>Me too: +1 from me, with no new capture kind. <br></p><p>-Chris<br></p><p><br>&gt; I think the workaround is easy enough that we don&#39;t need to worry about APIs that haven&#39;t been annotated yet, or APIs that are synchronous this time. Of course, it would be nice if the compiler could even insert the copy/writeback in a note fix-it.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 11:58, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think the time has come for us to limit the implicit capture of &#39;inout&#39; parameters to @noescape closures. In the early days before @noescape, we designed a semantics for capturing &quot;inout&quot; parameters that attempted to balance the constraints on inout with the usability of higher-order functions. Inout parameters don&#39;t pass a first-class reference as in other languages, but instead provide a limited lease to mutate a property for the duration of a call; this means closures can&#39;t extend the lifetime of that lease, so closures instead capture the local mutable copy of the inout parameter. This gives the expected behavior as long as closures over an inout parameter never escape their original scope, but leads to surprises as soon as those closures escape. This unintuitive behavior has made several &quot;Swift gotchas&quot; lists. Now that we can explicitly mark closures as not escaping, I think we should prevent &#39;inout&#39; parameters from being implicitly captured by escapable closures. There are several ways we can still support today&#39;s behavior:<br>&gt;&gt; <br>&gt;&gt; - Encourage people to write the local copy themselves, if that&#39;s what they want:<br>&gt;&gt; <br>&gt;&gt; func foo(inout x: Int) {<br>&gt;&gt;   var localX = x; defer { x = localX }<br>&gt;&gt; <br>&gt;&gt;   // Asynchronously mutate localX, then wait for it to finish<br>&gt;&gt;   dispatch_async { mutate(&amp;localX) }<br>&gt;&gt;   dispatch_sync {}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; - You can explicitly capture an immutable copy:<br>&gt;&gt; <br>&gt;&gt; func foo(inout x: Int) {<br>&gt;&gt;   // We don&#39;t need to mutate or observe mutations on x in the async job<br>&gt;&gt;   dispatch_async {[x] in doStuffWithoutMutating(x) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and/or we could introduce a new explicit capture kind for the current behavior:<br>&gt;&gt; <br>&gt;&gt; func foo(inout x: Int) {<br>&gt;&gt;   // Explicitly capture the &#39;inout&#39; mutable shadow copy of x<br>&gt;&gt;   dispatch_async {[inout x] in mutate(&amp;x) }<br>&gt;&gt;   dispatch_sync { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Making it explicit should make the behavior less surprising when it occurs. We should able to provide fixits to migrate code that relies on the current behavior as well. What do you all think?<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/f91f9298/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: only allow capture of inout parameters in @noescape closures</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Thanks for the feedback, everyone. I&#39;ve submitted a formal proposal:<br></p><p>https://github.com/jckarter/swift-evolution/blob/e89479c1a3ae9f37c217c8c3130c24b71c8909b3/proposals/XXXX-limit-inout-capture.md<br></p><p>-Joe<br></p><p>&gt; On Jan 28, 2016, at 11:58 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the time has come for us to limit the implicit capture of &#39;inout&#39; parameters to @noescape closures. In the early days before @noescape, we designed a semantics for capturing &quot;inout&quot; parameters that attempted to balance the constraints on inout with the usability of higher-order functions. Inout parameters don&#39;t pass a first-class reference as in other languages, but instead provide a limited lease to mutate a property for the duration of a call; this means closures can&#39;t extend the lifetime of that lease, so closures instead capture the local mutable copy of the inout parameter. This gives the expected behavior as long as closures over an inout parameter never escape their original scope, but leads to surprises as soon as those closures escape. This unintuitive behavior has made several &quot;Swift gotchas&quot; lists. Now that we can explicitly mark closures as not escaping, I think we should prevent &#39;inout&#39; parameters from being implicitly captured by escapable closures. There are several ways we can still support today&#39;s behavior:<br>&gt; <br>&gt; - Encourage people to write the local copy themselves, if that&#39;s what they want:<br>&gt; <br>&gt; func foo(inout x: Int) {<br>&gt;   var localX = x; defer { x = localX }<br>&gt; <br>&gt;   // Asynchronously mutate localX, then wait for it to finish<br>&gt;   dispatch_async { mutate(&amp;localX) }<br>&gt;   dispatch_sync {}<br>&gt; }<br>&gt; <br>&gt; - You can explicitly capture an immutable copy:<br>&gt; <br>&gt; func foo(inout x: Int) {<br>&gt;   // We don&#39;t need to mutate or observe mutations on x in the async job<br>&gt;   dispatch_async {[x] in doStuffWithoutMutating(x) }<br>&gt; }<br>&gt; <br>&gt; and/or we could introduce a new explicit capture kind for the current behavior:<br>&gt; <br>&gt; func foo(inout x: Int) {<br>&gt;   // Explicitly capture the &#39;inout&#39; mutable shadow copy of x<br>&gt;   dispatch_async {[inout x] in mutate(&amp;x) }<br>&gt;   dispatch_sync { }<br>&gt; }<br>&gt; <br>&gt; Making it explicit should make the behavior less surprising when it occurs. We should able to provide fixits to migrate code that relies on the current behavior as well. What do you all think?<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/8850ec53/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
