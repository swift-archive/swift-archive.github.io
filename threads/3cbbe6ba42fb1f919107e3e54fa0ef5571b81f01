<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>September 28, 2016 at 10:00:00pm</p></header><div class="content"><p>+1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br></p><p>&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; <br>&gt; Introducingindexed()collections<br>&gt; Proposal: TBD<br>&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; <br>&gt; <br>&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; <br>&gt; <br>&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt; <br>&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt; <br>&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; <br>&gt; Detailed Design<br>&gt; <br>&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt; <br>&gt; Impact on Existing Code<br>&gt; <br>&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; <br>&gt; Alternatives Considered<br>&gt; Not yet<br>&gt; <br>&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 28, 2016 at 01:00:00pm</p></header><div class="content"><p>That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection? The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br></p><p>-Kevin<br></p><p>On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt; <br>&gt; &gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; &gt; <br>&gt; &gt; Introducingindexed()collections<br>&gt; &gt; Proposal: TBD<br>&gt; &gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt; &gt; Status: TBD<br>&gt; &gt; Review manager: TBD<br>&gt; &gt; <br>&gt; &gt; Introduction<br>&gt; &gt; <br>&gt; &gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt; &gt; <br>&gt; &gt; Motivation<br>&gt; &gt; <br>&gt; &gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt; &gt; <br>&gt; &gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt; &gt; <br>&gt; &gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt; <br>&gt; &gt; Detailed Design<br>&gt; &gt; <br>&gt; &gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt; &gt; <br>&gt; &gt; Impact on Existing Code<br>&gt; &gt; <br>&gt; &gt; This proposal is purely additive and has no impact on existing code.<br>&gt; &gt; <br>&gt; &gt; Alternatives Considered<br>&gt; &gt; Not yet<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>September 28, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection?<br></p><p>I think there is a benefit. Something like `collection.indexed().reversed()` would benefit from that, and I think that could be useful.<br></p><p>&gt; The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br></p><p>Rather than introducing a new index for this, we can simply use the index of the base collection for subscripting.<br></p><p>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt;&gt; <br>&gt;&gt;&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introducingindexed()collections<br>&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 28, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Sep 28, 2016, at 01:54 PM, Tim Vermeulen wrote:<br>&gt; <br>&gt; &gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection?<br>&gt; <br>&gt; I think there is a benefit. Something like `collection.indexed().reversed()` would benefit from that, and I think that could be useful.<br></p><p>Perhaps, though you could just say `collection.reversed().indexed()` instead.<br></p><p>&gt; &gt; The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br>&gt; <br>&gt; Rather than introducing a new index for this, we can simply use the index of the base collection for subscripting.<br></p><p>That&#39;s actually a good idea, and if we do make it a collection this is probably how we should handle it. But I still argue that the ability to make something a collection doesn&#39;t mean it should be a collection, if there&#39;s no good reason for anyone to actually try to use it as such.<br></p><p> -Kevin<br></p><p>&gt; &gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt; &gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Introducingindexed()collections<br>&gt; &gt;&gt;&gt; Proposal: TBD<br>&gt; &gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt; &gt;&gt;&gt; Status: TBD<br>&gt; &gt;&gt;&gt; Review manager: TBD<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Detailed Design<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Impact on Existing Code<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; Alternatives Considered<br>&gt; &gt;&gt;&gt; Not yet<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>September 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 28 Sep 2016, at 22:57, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Sep 28, 2016, at 01:54 PM, Tim Vermeulen wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection?<br>&gt;&gt; <br>&gt;&gt; I think there is a benefit. Something like `collection.indexed().reversed()` would benefit from that, and I think that could be useful.<br>&gt; <br>&gt; Perhaps, though you could just say `collection.reversed().indexed()` instead.<br></p><p>This isn’t necessarily the same though, is it? The reversed collection might use different indices than the original collection.<br></p><p>&gt; <br>&gt;&gt;&gt; The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br>&gt;&gt; <br>&gt;&gt; Rather than introducing a new index for this, we can simply use the index of the base collection for subscripting.<br>&gt; <br>&gt; That&#39;s actually a good idea, and if we do make it a collection this is probably how we should handle it. But I still argue that the ability to make something a collection doesn&#39;t mean it should be a collection, if there&#39;s no good reason for anyone to actually try to use it as such.<br>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introducingindexed()collections<br>&gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 28, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Sep 28, 2016, at 02:02 PM, Tim Vermeulen wrote:<br>&gt; <br>&gt; &gt; On 28 Sep 2016, at 22:57, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; On Wed, Sep 28, 2016, at 01:54 PM, Tim Vermeulen wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection?<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; I think there is a benefit. Something like `collection.indexed().reversed()` would benefit from that, and I think that could be useful.<br>&gt; &gt; <br>&gt; &gt; Perhaps, though you could just say `collection.reversed().indexed()` instead.<br>&gt; <br>&gt; This isn’t necessarily the same though, is it? The reversed collection might use different indices than the original collection.<br></p><p>Either way you write it you&#39;re dealing with reversed indices.<br></p><p>-Kevin<br></p><p>&gt; &gt;&gt;&gt; The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Rather than introducing a new index for this, we can simply use the index of the base collection for subscripting.<br>&gt; &gt; <br>&gt; &gt; That&#39;s actually a good idea, and if we do make it a collection this is probably how we should handle it. But I still argue that the ability to make something a collection doesn&#39;t mean it should be a collection, if there&#39;s no good reason for anyone to actually try to use it as such.<br>&gt; &gt; <br>&gt; &gt; -Kevin<br>&gt; &gt; <br>&gt; &gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt; &gt;&gt;&gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Introducingindexed()collections<br>&gt; &gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt; &gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Introduction<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Motivation<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt; &gt;&gt;&gt;&gt;&gt; Not yet<br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>September 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On 28 Sep 2016, at 23:03, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Sep 28, 2016, at 02:02 PM, Tim Vermeulen wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Sep 2016, at 22:57, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:54 PM, Tim Vermeulen wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think there is a benefit. Something like `collection.indexed().reversed()` would benefit from that, and I think that could be useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps, though you could just say `collection.reversed().indexed()` instead.<br>&gt;&gt; <br>&gt;&gt; This isn’t necessarily the same though, is it? The reversed collection might use different indices than the original collection.<br>&gt; <br>&gt; Either way you write it you&#39;re dealing with reversed indices.<br></p><p>`collection.indexed().reversed()` will contain indices from the original collection (but in reversed order). `collection.reversed().indexed()` will contain indices from the collection returned by `reversed()`, which may have a different type than `Base.Index`. It’s a distinction.<br></p><p>This would compile:<br></p><p>let characters = &quot;Swift&quot;.characters<br></p><p>for (index, character) in characters.indexed().reversed() {<br>    print(characters[index], character)<br>}<br></p><p>This wouldn’t:<br></p><p>let characters = &quot;Swift&quot;.characters<br></p><p>for (index, character) in characters.reversed().indexed() {<br>    print(characters[index], character)<br>}<br></p><p>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Rather than introducing a new index for this, we can simply use the index of the base collection for subscripting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s actually a good idea, and if we do make it a collection this is probably how we should handle it. But I still argue that the ability to make something a collection doesn&#39;t mean it should be a collection, if there&#39;s no good reason for anyone to actually try to use it as such.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducingindexed()collections<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(https://github.com/natecook1000),Jacob Bandes-Storch(https://github.com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/5b56a3ed/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>September 28, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Sep 28, 2016, at 02:10 PM, Tim Vermeulen wrote:<br>&gt;<br>&gt;&gt; On 28 Sep 2016, at 23:03, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Wed, Sep 28, 2016, at 02:02 PM, Tim Vermeulen wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 28 Sep 2016, at 22:57, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:54 PM, Tim Vermeulen wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever<br>&gt;&gt;&gt;&gt;&gt;&gt; use this as a collection?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think there is a benefit. Something like<br>&gt;&gt;&gt;&gt;&gt; `collection.indexed().reversed()` would benefit from that, and I<br>&gt;&gt;&gt;&gt;&gt; think that could be useful.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Perhaps, though you could just say<br>&gt;&gt;&gt;&gt; `collection.reversed().indexed()` instead.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This isn’t necessarily the same though, is it? The reversed<br>&gt;&gt;&gt; collection might use different indices than the original collection.<br>&gt;&gt;<br>&gt;&gt; Either way you write it you&#39;re dealing with reversed indices.<br>&gt;<br>&gt; `collection.indexed().reversed()` will contain indices from the<br>&gt; original collection (but in reversed order).<br>&gt; `collection.reversed().indexed()` will contain indices from the<br>&gt; collection returned by `reversed()`, which may have a different type<br>&gt; than `Base.Index`. It’s a distinction.<br>&gt;<br>&gt; This would compile:<br>&gt;<br>&gt; let characters = &quot;Swift&quot;.characters<br>&gt;<br>&gt; for (index, character) in characters.indexed().reversed() {<br>&gt;     print(characters[index], character)<br>&gt; }<br>&gt;<br>&gt; This wouldn’t:<br>&gt;<br>&gt; let characters = &quot;Swift&quot;.characters<br>&gt;<br>&gt; for (index, character) in characters.reversed().indexed() {<br>&gt;     print(characters[index], character)<br>&gt; }<br></p><p>Oh you&#39;re right.<br></p><p>Still, it&#39;s a fair amount of complexity (handling bidirectional and random-<br>access collections on top of the regular collection) and I&#39;m not sure<br>it&#39;s worth the complexity just for reversed(). After all, you can always<br>fall back to the slightly uglier<br></p><p>for index in characters.indices.reversed() {<br>    let character = characters[index]<br>    ...<br>}<br></p><p>And it&#39;s worth pointing out that enumerated() doesn&#39;t return a<br>collection but nobody&#39;s been clamoring for reversed() support there.<br></p><p>-Kevin<br></p><p>&gt;&gt;<br>&gt;&gt; -Kevin<br>&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The whole point is to be used in a for loop. If it was a<br>&gt;&gt;&gt;&gt;&gt;&gt; collection then you&#39;d need to have an index for that collection,<br>&gt;&gt;&gt;&gt;&gt;&gt; so now you have an index that lets you get the index for another<br>&gt;&gt;&gt;&gt;&gt;&gt; collection, which is pretty useless because you could just be<br>&gt;&gt;&gt;&gt;&gt;&gt; using that underlying index to begin with.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Rather than introducing a new index for this, we can simply use<br>&gt;&gt;&gt;&gt;&gt; the index of the base collection for subscripting.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That&#39;s actually a good idea, and if we do make it a collection this<br>&gt;&gt;&gt;&gt; is probably how we should handle it. But I still argue that the<br>&gt;&gt;&gt;&gt; ability to make something a collection doesn&#39;t mean it should be a<br>&gt;&gt;&gt;&gt; collection, if there&#39;s no good reason for anyone to actually try to<br>&gt;&gt;&gt;&gt; use it as such.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why not `IndexedCollection`, which could also conform to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection? With conditional conformances to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; BidirectionalCollection and RandomAccessCollection. This<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wouldn’t penalise the performance with respect to a simple<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; `IndexedSequence`, would it?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gist here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducingindexed()collections<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica),Nate Cook<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (https://github.com/natecook1000),Jacob Bandes-Storch<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (https://github.com/jtbandes),Kevin Ballard<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (https://github.com/kballard)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal introducesindexed()to the standard library, a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; method on collections that returns an (index, element) tuple<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; pairs enumerating a sequence. The pair&#39;s first member is a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; monotonically incrementing integer starting at zero, and the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; second member is the corresponding element of the sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When working with arrays, the integer is coincidentally the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; same type and value as anArrayindex but the enumerated value is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; not generated with index-specific semantics. This may lead to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; confusion when developers attempt to subscript a non-array<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection with enumerated integers. It can introduce serious<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bugs when developers useenumerated()-based integer subscripting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; with non-zero-based array slices.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to create valid collection subscripts. This proposal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; introducesindexed()to produce a more semantically relevant<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence by pairing a collection&#39;sindiceswith its members.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; While it is trivial to create a solution in Swift, the most<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; common developer approach shown here calculates indexes twice:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (*idx*, *x*), where *idx* represents a   /// consecutive<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection index, and *x* represents an element of   /// the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return zip(indices, self)   } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; costly. In a lazy filtered collection, an index increment is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; potentially O(N). We feel this is better addressed introducing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; a new function into the Standard Library to provide a more<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; efficient design that avoids the attractive nuisance of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &quot;obvious&quot; solution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; their potentially high computation costs. We&#39;d create an<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterator that calculates each index once and then applies that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; index to subscript the collection. Implementation would take<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal is purely additive and has no impact on existing<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160928/41bbeebc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>September 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 28 Sep 2016, at 23:44, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Wed, Sep 28, 2016, at 02:10 PM, Tim Vermeulen wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 28 Sep 2016, at 23:03, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Sep 28, 2016, at 02:02 PM, Tim Vermeulen wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 28 Sep 2016, at 22:57, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:54 PM, Tim Vermeulen wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 28 Sep 2016, at 22:46, Kevin Ballard &lt;kevin at sb.org &lt;mailto:kevin at sb.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this as a collection?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think there is a benefit. Something like `collection.indexed().reversed()` would benefit from that, and I think that could be useful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Perhaps, though you could just say `collection.reversed().indexed()` instead.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This isn’t necessarily the same though, is it? The reversed collection might use different indices than the original collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Either way you write it you&#39;re dealing with reversed indices.<br>&gt;&gt; <br>&gt;&gt; `collection.indexed().reversed()` will contain indices from the original collection (but in reversed order). `collection.reversed().indexed()` will contain indices from the collection returned by `reversed()`, which may have a different type than `Base.Index`. It’s a distinction.<br>&gt;&gt; <br>&gt;&gt; This would compile:<br>&gt;&gt; <br>&gt;&gt; let characters = &quot;Swift&quot;.characters<br>&gt;&gt; <br>&gt;&gt; for (index, character) in characters.indexed().reversed() {<br>&gt;&gt;     print(characters[index], character)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This wouldn’t:<br>&gt;&gt; <br>&gt;&gt; let characters = &quot;Swift&quot;.characters<br>&gt;&gt; <br>&gt;&gt; for (index, character) in characters.reversed().indexed() {<br>&gt;&gt;     print(characters[index], character)<br>&gt;&gt; }<br>&gt; <br>&gt; Oh you&#39;re right.<br>&gt; <br>&gt; Still, it&#39;s a fair amount of complexity (handling bidirectional and random-access collections on top of the regular collection) and I&#39;m not sure it&#39;s worth the complexity just for reversed().<br></p><p>It’s very straight-forward to simply forward all requirements to the base collection. I just wrote it out, and it might even be less complex than the sequence approach, because we don’t need a custom iterator.<br></p><p>&gt; After all, you can always fall back to the slightly uglier<br>&gt; <br>&gt; for index in characters.indices.reversed() {<br>&gt;     let character = characters[index]<br>&gt;     ...<br>&gt; }<br></p><p>You could, but don’t forget that writing `characters.indexed().reversed()` in the case of `IndexedSequence` would still have the result you’d expect. It’s simply less efficient than necessary. Most people probably wouldn’t even realise that the more readable approach isn’t the most efficient one, here.<br></p><p>&gt; <br>&gt; And it&#39;s worth pointing out that enumerated() doesn&#39;t return a collection but nobody&#39;s been clamoring for reversed() support there.<br>&gt; <br>&gt; -Kevin<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The whole point is to be used in a for loop. If it was a collection then you&#39;d need to have an index for that collection, so now you have an index that lets you get the index for another collection, which is pretty useless because you could just be using that underlying index to begin with.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Rather than introducing a new index for this, we can simply use the index of the base collection for subscripting.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s actually a good idea, and if we do make it a collection this is probably how we should handle it. But I still argue that the ability to make something a collection doesn&#39;t mean it should be a collection, if there&#39;s no good reason for anyone to actually try to use it as such.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Kevin<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not `IndexedCollection`, which could also conform to Collection? With conditional conformances to BidirectionalCollection and RandomAccessCollection. This wouldn’t penalise the performance with respect to a simple `IndexedSequence`, would it?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2 &lt;https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3f2&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introducingindexed()collections<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Author:Erica Sadun(https://github.com/erica &lt;https://github.com/erica&gt;),Nate Cook(https://github.com/natecook1000 &lt;https://github.com/natecook1000&gt;),Jacob Bandes-Storch(https://github.com/jtbandes &lt;https://github.com/jtbandes&gt;),Kevin Ballard(https://github.com/kballard &lt;https://github.com/kballard&gt;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal introducesindexed()to the standard library, a method on collections that returns an (index, element) tuple sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd &lt;https://gist.github.com/erica/tbd&gt;)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The standard library&#39;senumerated()method returns a sequence of pairs enumerating a sequence. The pair&#39;s first member is a monotonically incrementing integer starting at zero, and the second member is the corresponding element of the sequence. When working with arrays, the integer is coincidentally the same type and value as anArrayindex but the enumerated value is not generated with index-specific semantics. This may lead to confusion when developers attempt to subscript a non-array collection with enumerated integers. It can introduce serious bugs when developers useenumerated()-based integer subscripting with non-zero-based array slices.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Indices have a specific, fixed meaning in Swift, which are used to create valid collection subscripts. This proposal introducesindexed()to produce a more semantically relevant sequence by pairing a collection&#39;sindiceswith its members. While it is trivial to create a solution in Swift, the most common developer approach shown here calculates indexes twice:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*), where *idx* represents a   /// consecutive collection index, and *x* represents an element of   /// the sequence.   func indexed() -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Incrementing an index in some collections can be unnecessarily costly. In a lazy filtered collection, an index increment is potentially O(N). We feel this is better addressed introducing a new function into the Standard Library to provide a more efficient design that avoids the attractive nuisance of the &quot;obvious&quot; solution.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detailed Design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Our vision ofindexed()bypasses duplicated index generation with their potentially high computation costs. We&#39;d create an iterator that calculates each index once and then applies that index to subscript the collection. Implementation would take place throughIndexedSequence, similar toEnumeratedSequence.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Impact on Existing Code<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal is purely additive and has no impact on existing code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Alternatives Considered<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Not yet<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/60b8d556/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal draft] Introducing `indexed()` collections</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>October  2, 2016 at 12:00:00am</p></header><div class="content"><p>On Wed, Sep 28, 2016 at 1:46 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That&#39;s a bunch of complexity for no benefit. Why would you ever use this<br>&gt; as a collection?<br></p><p><br>I think getting an element and an index simultaneously from, for instance,<br>collection.indexed().sorted(by:) or collection.indexed().first(where:)<br>could be quite useful.<br></p><p>Jacob<br></p><p><br>&gt; The whole point is to be used in a for loop. If it was a collection then<br>&gt; you&#39;d need to have an index for that collection, so now you have an index<br>&gt; that lets you get the index for another collection, which is pretty useless<br>&gt; because you could just be using that underlying index to begin with.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Wed, Sep 28, 2016, at 01:38 PM, Tim Vermeulen via swift-evolution wrote:<br>&gt; &gt; +1 for `indexed()`, but I’m not sure about `IndexedSequence`. Why not<br>&gt; `IndexedCollection`, which could also conform to Collection? With<br>&gt; conditional conformances to BidirectionalCollection and<br>&gt; RandomAccessCollection. This wouldn’t penalise the performance with respect<br>&gt; to a simple `IndexedSequence`, would it?<br>&gt; &gt;<br>&gt; &gt; &gt; Gist here:https://gist.github.com/erica/2b2d92e6db787d001c689d3e37a7c3<br>&gt; f2<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Introducingindexed()collections<br>&gt; &gt; &gt; Proposal: TBD<br>&gt; &gt; &gt; Author:Erica Sadun(https://github.com/erica),Nate Cook(<br>&gt; https://github.com/natecook1000),Jacob Bandes-Storch(https://github.<br>&gt; com/jtbandes),Kevin Ballard(https://github.com/kballard)<br>&gt; &gt; &gt; Status: TBD<br>&gt; &gt; &gt; Review manager: TBD<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Introduction<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This proposal introducesindexed()to the standard library, a method on<br>&gt; collections that returns an (index, element) tuple sequence.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Swift-evolution thread:TBD(https://gist.github.com/erica/tbd)<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Motivation<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; The standard library&#39;senumerated()method returns a sequence of pairs<br>&gt; enumerating a sequence. The pair&#39;s first member is a monotonically<br>&gt; incrementing integer starting at zero, and the second member is the<br>&gt; corresponding element of the sequence. When working with arrays, the<br>&gt; integer is coincidentally the same type and value as anArrayindex but the<br>&gt; enumerated value is not generated with index-specific semantics. This may<br>&gt; lead to confusion when developers attempt to subscript a non-array<br>&gt; collection with enumerated integers. It can introduce serious bugs when<br>&gt; developers useenumerated()-based integer subscripting with non-zero-based<br>&gt; array slices.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Indices have a specific, fixed meaning in Swift, which are used to<br>&gt; create valid collection subscripts. This proposal introducesindexed()to<br>&gt; produce a more semantically relevant sequence by pairing a<br>&gt; collection&#39;sindiceswith its members. While it is trivial to create a<br>&gt; solution in Swift, the most common developer approach shown here calculates<br>&gt; indexes twice:<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; extension Collection {   /// Returns a sequence of pairs (*idx*, *x*),<br>&gt; where *idx* represents a   /// consecutive collection index, and *x*<br>&gt; represents an element of   /// the sequence.   func indexed()<br>&gt; -&gt;Zip2Sequence&lt;Self.Indices, Self&gt;{     return zip(indices, self)   } }<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Incrementing an index in some collections can be unnecessarily costly.<br>&gt; In a lazy filtered collection, an index increment is potentially O(N). We<br>&gt; feel this is better addressed introducing a new function into the Standard<br>&gt; Library to provide a more efficient design that avoids the attractive<br>&gt; nuisance of the &quot;obvious&quot; solution.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Detailed Design<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Our vision ofindexed()bypasses duplicated index generation with their<br>&gt; potentially high computation costs. We&#39;d create an iterator that calculates<br>&gt; each index once and then applies that index to subscript the collection.<br>&gt; Implementation would take place throughIndexedSequence, similar<br>&gt; toEnumeratedSequence.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Impact on Existing Code<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; This proposal is purely additive and has no impact on existing code.<br>&gt; &gt; &gt;<br>&gt; &gt; &gt; Alternatives Considered<br>&gt; &gt; &gt; Not yet<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161002/b9b8e1ae/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
