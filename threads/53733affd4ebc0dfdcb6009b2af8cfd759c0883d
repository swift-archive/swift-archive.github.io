<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Problem with COW optimization</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>September 18, 2016 at 08:00:00pm</p></header><div class="content"><p>on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; Dear Swift community,<br>&gt;<br>&gt; currently I’m building a value type XML library which is baked behind<br>&gt; the scene with a reference type to manage graph traversing between<br>&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt; single problem atm.<br>&gt;<br>&gt; Image this xml tree:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt;     &lt;item/&gt;<br>&gt; &lt;/root&gt;<br>&gt; It’s just a root element with one single child. As for value types it<br>&gt; should be totally fine to do something like this:<br>&gt;<br>&gt; // The given xml tree<br>&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt; root.add(item)<br>&gt;<br>&gt; // The problematic behavior<br>&gt; root.add(root)<br>&gt; If this would be a simple value type without any references behind the<br>&gt; scenes you could imagine that the result of the last code line will<br>&gt; look like this:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt;     &lt;item/&gt;<br>&gt;     &lt;root&gt;<br>&gt;         &lt;item/&gt;<br>&gt;     &lt;/root&gt;<br>&gt; &lt;/root&gt;<br></p><p>Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>The simplest way to implement this tree is to use an Array for the child<br>nodes.<br></p><p>&gt; Basically we copied the whole tree and added it as the second child<br>&gt; into the original root element.<br>&gt;<br>&gt; As for COW optimization this is a problem, just because the passed<br>&gt; root is a copy of a struct that contains the exact same reference as<br>&gt; the original root element. <br></p><p>I don&#39;t understand why that&#39;s a problem.<br></p><p>&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt; the add method.<br></p><p>...as it should.<br></p><p>&gt; Is there any chance I could force my program to decrease the reference<br>&gt; counter of that last item after I’m sure I don’t need it?!<br></p><p>Which last item?  When are you sure you don&#39;t need it?  What result do<br>you hope for?<br></p><p>&gt; A few more details: inside the add method I’m always cloning the<br>&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt; I could possibly end up with a cycle graph, which would be really<br>&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt; anymore and I need a way to escape from it.<br>&gt;<br>&gt; I’d appreciate any suggestions and help. :)<br></p><p>It&#39;s not clear what you want to acheive nor can I picture the code<br>you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br></p><p>Sorry,<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 19, 2016 at 09:00:00am</p></header><div class="content"><p>Hello Dave,<br></p><p>thank you for trying to help me. I’ll try to explain the issue with some more details.<br></p><p>First here is some code:<br></p><p>extension XML {<br>     <br>    public struct Element {<br></p><p>        // public for testing  <br>        public var reference: Reference<br></p><p>        public var name: String { return self.reference.name }<br></p><p>        public var children: [Element] {<br>             <br>            return self.reference.children.flatMap {<br>                 <br>                guard case .element(let element) = $0.kind else { return nil }<br>                return Element(wrapping: element)<br>            }<br>        }<br>         <br>        public init(name: String) {<br>             <br>            self.reference = Reference(name: name)<br>        }<br></p><p>        public mutating func add(_ child: Element) {<br>             <br>            self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>        }<br>         <br>        // Ignore XML.Node, it&#39;s a String or Reference<br>        // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>        private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>             <br>            // Clone own reference all way up to the root<br>            if !isKnownUniquelyReferenced(&amp;self.reference) {<br>                 <br>                self.reference = Reference(cloning: self.reference, wholeTree: true)<br>            }<br>             <br>            // Extract a reference or just insert a string as a child<br>            guard case .element(let nodeReference) = node.kind else {<br>                 <br>                self.reference.insert(node, at: index)<br>                return<br>            }<br>             <br>            // Check for possible debelopment bug<br>            if nodeReference === self.reference {<br>                 <br>                fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>            }<br>             <br>            self.reference.insert(nodeReference, at: index)<br>        }<br>         <br>        ...<br>    }<br>}<br></p><p>extension XML.Element {<br>     <br>    // public for testing<br>    public class Reference : XML.Node {<br>         <br>        let name: String<br></p><p>        private(set) weak var parent: Reference?<br></p><p>        private(set) var children: [XML.Node]<br></p><p>        var kind: XML.Node.Kind { return .element(self) }<br></p><p>        ...<br>    }<br>}<br>Now lets focus on the problem.<br></p><p>Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br></p><p>Lets look again at the scenario I already described:<br></p><p>var root = XML.Element(name: &quot;root&quot;)<br>var elem = XML.Element(name: &quot;elem&quot;)<br></p><p>ObjectIdentifier(root.reference) // 0x000060000026ab40<br>ObjectIdentifier(elem.reference) // 0x000060800026bb00<br></p><p>isKnownUniquelyReferenced(&amp;root.reference) // true<br>isKnownUniquelyReferenced(&amp;elem.reference) // true<br></p><p>root.add(elem)<br></p><p>isKnownUniquelyReferenced(&amp;root.reference) // true<br></p><p>root.add(root)<br></p><p>// The reference of root has changed even if the second child  <br>// was cloned and added as a new object to the reference.<br>// 0x000060000026ab40 &lt;-- was thrown away<br>isKnownUniquelyReferenced(&amp;root.reference) // true<br></p><p>ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br></p><p>The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br></p><p>I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br></p><p>But I couldn’t find any API for that. :/<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br></p><p><br>on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; Dear Swift community,<br>&gt;<br>&gt; currently I’m building a value type XML library which is baked behind<br>&gt; the scene with a reference type to manage graph traversing between<br>&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt; single problem atm.<br>&gt;<br>&gt; Image this xml tree:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt; &lt;item/&gt;<br>&gt; &lt;/root&gt;<br>&gt; It’s just a root element with one single child. As for value types it<br>&gt; should be totally fine to do something like this:<br>&gt;<br>&gt; // The given xml tree<br>&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt; root.add(item)<br>&gt;<br>&gt; // The problematic behavior<br>&gt; root.add(root)<br>&gt; If this would be a simple value type without any references behind the<br>&gt; scenes you could imagine that the result of the last code line will<br>&gt; look like this:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt; &lt;item/&gt;<br>&gt; &lt;root&gt;<br>&gt; &lt;item/&gt;<br>&gt; &lt;/root&gt;<br>&gt; &lt;/root&gt;<br></p><p>Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>The simplest way to implement this tree is to use an Array for the child<br>nodes.<br></p><p>&gt; Basically we copied the whole tree and added it as the second child<br>&gt; into the original root element.<br>&gt;<br>&gt; As for COW optimization this is a problem, just because the passed<br>&gt; root is a copy of a struct that contains the exact same reference as<br>&gt; the original root element.  <br></p><p>I don&#39;t understand why that&#39;s a problem.<br></p><p>&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt; the add method.<br></p><p>...as it should.<br></p><p>&gt; Is there any chance I could force my program to decrease the reference<br>&gt; counter of that last item after I’m sure I don’t need it?!<br></p><p>Which last item? When are you sure you don&#39;t need it? What result do<br>you hope for?<br></p><p>&gt; A few more details: inside the add method I’m always cloning the<br>&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt; I could possibly end up with a cycle graph, which would be really<br>&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt; anymore and I need a way to escape from it.<br>&gt;<br>&gt; I’d appreciate any suggestions and help. :)<br></p><p>It&#39;s not clear what you want to acheive nor can I picture the code<br>you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br></p><p>Sorry,<br></p><p>--  <br>-Dave<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/a9dbaa31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>September 19, 2016 at 12:00:00pm</p></header><div class="content"><p>I think I just found a solution to my problem:<br></p><p>/// - Parameter child: The new `child` to add to the `children` array.<br>public mutating func add(_ child: Element) {<br></p><p>   let clonedChildReference = Reference(cloning: child.reference)<br>   let index = self.reference.children.endIndex<br>             <br>   self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>}<br>         <br>/// Warning: Pass only clonded nodes of type Element to this function!<br>private mutating func mutableInsert(_ node: XML.Node, at index: Int, isNotOwnReference: Bool) {<br></p><p>   // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>   //   we should rebuilt own reference.<br>   // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>   //   `isNotOwnReference` is true, we should rebuilt own reference.<br>   // * If `self.reference` is NOT uniquely referenced and `node` is a clone  <br>   //   reference to `self.reference` where is `isNotOwnReference` is false, we<br>   //   should check if there are more than **two** strong references to rebuild<br>   //   own reference, otherwise it&#39;s an implementation artifact and we can keep<br>   //   old reference (any `node` of type Reference is cloned before it&#39;s added  <br>   //   to the child array).<br>   let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>             <br>   var shouldRebuildReference = false<br>             <br>   switch node.kind {<br>                 <br>   case .element(_):<br>      let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>      shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>                 <br>   case .text(_):<br>      shouldRebuildReference = isNotKnownUniquelyReferenced<br>   }<br>             <br>   if shouldRebuildReference {<br>                 <br>      self.reference = Reference(cloning: self.reference, wholeTree: true)<br>   }<br></p><p>   self.reference.insert(node, at: index)<br>}<br>I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Hello Dave,<br></p><p>thank you for trying to help me. I’ll try to explain the issue with some more details.<br></p><p>First here is some code:<br></p><p>extension XML {<br>      <br>    public struct Element {<br></p><p>        // public for testing   <br>        public var reference: Reference<br></p><p>        public var name: String { return self.reference.name }<br></p><p>        public var children: [Element] {<br>              <br>            return self.reference.children.flatMap {<br>                  <br>                guard case .element(let element) = $0.kind else { return nil }<br>                return Element(wrapping: element)<br>            }<br>        }<br>          <br>        public init(name: String) {<br>              <br>            self.reference = Reference(name: name)<br>        }<br></p><p>        public mutating func add(_ child: Element) {<br>              <br>            self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>        }<br>          <br>        // Ignore XML.Node, it&#39;s a String or Reference<br>        // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>        private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>              <br>            // Clone own reference all way up to the root<br>            if !isKnownUniquelyReferenced(&amp;self.reference) {<br>                  <br>                self.reference = Reference(cloning: self.reference, wholeTree: true)<br>            }<br>              <br>            // Extract a reference or just insert a string as a child<br>            guard case .element(let nodeReference) = node.kind else {<br>                  <br>                self.reference.insert(node, at: index)<br>                return<br>            }<br>              <br>            // Check for possible debelopment bug<br>            if nodeReference === self.reference {<br>                  <br>                fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>            }<br>              <br>            self.reference.insert(nodeReference, at: index)<br>        }<br>          <br>        ...<br>    }<br>}<br></p><p>extension XML.Element {<br>      <br>    // public for testing<br>    public class Reference : XML.Node {<br>          <br>        let name: String<br></p><p>        private(set) weak var parent: Reference?<br></p><p>        private(set) var children: [XML.Node]<br></p><p>        var kind: XML.Node.Kind { return .element(self) }<br></p><p>        ...<br>    }<br>}<br>Now lets focus on the problem.<br></p><p>Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br></p><p>Lets look again at the scenario I already described:<br></p><p>var root = XML.Element(name: &quot;root&quot;)<br>var elem = XML.Element(name: &quot;elem&quot;)<br></p><p>ObjectIdentifier(root.reference) // 0x000060000026ab40<br>ObjectIdentifier(elem.reference) // 0x000060800026bb00<br></p><p>isKnownUniquelyReferenced(&amp;root.reference) // true<br>isKnownUniquelyReferenced(&amp;elem.reference) // true<br></p><p>root.add(elem)<br></p><p>isKnownUniquelyReferenced(&amp;root.reference) // true<br></p><p>root.add(root)<br></p><p>// The reference of root has changed even if the second child   <br>// was cloned and added as a new object to the reference.<br>// 0x000060000026ab40 &lt;-- was thrown away<br>isKnownUniquelyReferenced(&amp;root.reference) // true<br></p><p>ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br></p><p>The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br></p><p>I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br></p><p>But I couldn’t find any API for that. :/<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br></p><p><br>on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br></p><p>&gt; Dear Swift community,<br>&gt;<br>&gt; currently I’m building a value type XML library which is baked behind<br>&gt; the scene with a reference type to manage graph traversing between<br>&gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt; single problem atm.<br>&gt;<br>&gt; Image this xml tree:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt; &lt;item/&gt;<br>&gt; &lt;/root&gt;<br>&gt; It’s just a root element with one single child. As for value types it<br>&gt; should be totally fine to do something like this:<br>&gt;<br>&gt; // The given xml tree<br>&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt; root.add(item)<br>&gt;<br>&gt; // The problematic behavior<br>&gt; root.add(root)<br>&gt; If this would be a simple value type without any references behind the<br>&gt; scenes you could imagine that the result of the last code line will<br>&gt; look like this:<br>&gt;<br>&gt; &lt;root&gt;<br>&gt; &lt;item/&gt;<br>&gt; &lt;root&gt;<br>&gt; &lt;item/&gt;<br>&gt; &lt;/root&gt;<br>&gt; &lt;/root&gt;<br></p><p>Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>The simplest way to implement this tree is to use an Array for the child<br>nodes.<br></p><p>&gt; Basically we copied the whole tree and added it as the second child<br>&gt; into the original root element.<br>&gt;<br>&gt; As for COW optimization this is a problem, just because the passed<br>&gt; root is a copy of a struct that contains the exact same reference as<br>&gt; the original root element.<br></p><p>I don&#39;t understand why that&#39;s a problem.<br></p><p>&gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt; the add method.<br></p><p>...as it should.<br></p><p>&gt; Is there any chance I could force my program to decrease the reference<br>&gt; counter of that last item after I’m sure I don’t need it?!<br></p><p>Which last item? When are you sure you don&#39;t need it? What result do<br>you hope for?<br></p><p>&gt; A few more details: inside the add method I’m always cloning the<br>&gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt; I could possibly end up with a cycle graph, which would be really<br>&gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt; anymore and I need a way to escape from it.<br>&gt;<br>&gt; I’d appreciate any suggestions and help. :)<br></p><p>It&#39;s not clear what you want to acheive nor can I picture the code<br>you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br></p><p>Sorry,<br></p><p>--<br>-Dave<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/d22621c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>September 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 19, 2016, at 3:18 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think I just found a solution to my problem:<br>&gt; <br>&gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt; public mutating func add(_ child: Element) {<br>&gt; <br>&gt;    let clonedChildReference = Reference(cloning: child.reference)<br>&gt;    let index = self.reference.children.endIndex<br>&gt;              <br>&gt;    self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt; }<br>&gt;          <br>&gt; /// Warning: Pass only clonded nodes of type Element to this function!<br>&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int, isNotOwnReference: Bool) {<br>&gt; <br>&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt;    //   we should rebuilt own reference.<br>&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt;    //   `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a clone  <br>&gt;    //   reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt;    //   should check if there are more than **two** strong references to rebuild<br>&gt;    //   own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt;    //   old reference (any `node` of type Reference is cloned before it&#39;s added  <br>&gt;    //   to the child array).<br>&gt;    let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;              <br>&gt;    var shouldRebuildReference = false<br>&gt;              <br>&gt;    switch node.kind {<br>&gt;                  <br>&gt;    case .element(_):<br>&gt;       let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt;       shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;                  <br>&gt;    case .text(_):<br>&gt;       shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt;    }<br>&gt;              <br>&gt;    if shouldRebuildReference {<br>&gt;                  <br>&gt;       self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;    }<br>&gt; <br>&gt;    self.reference.insert(node, at: index)<br>&gt; }<br>&gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt; <br>If people are resorting to CFGetRetainCount, then we have a problem. The optimizer is not under any obligation to bump the refcount to 2.<br></p><p>There must be a better way to handle this. Rather than passing an<br>&#39;isNotOwnReference&#39; flag, I think you should determine whether a clone<br>is needed before passing the node into mutableInsert.<br></p><p>You effectively want an API like root.addSelf().<br></p><p>-Andy<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; Hello Dave,<br>&gt;&gt; <br>&gt;&gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;&gt; <br>&gt;&gt; First here is some code:<br>&gt;&gt; <br>&gt;&gt; extension XML {<br>&gt;&gt;       <br>&gt;&gt;     public struct Element {<br>&gt;&gt; <br>&gt;&gt;         // public for testing   <br>&gt;&gt;         public var reference: Reference<br>&gt;&gt; <br>&gt;&gt;         public var name: String { return self.reference.name }<br>&gt;&gt; <br>&gt;&gt;         public var children: [Element] {<br>&gt;&gt;               <br>&gt;&gt;             return self.reference.children.flatMap {<br>&gt;&gt;                   <br>&gt;&gt;                 guard case .element(let element) = $0.kind else { return nil }<br>&gt;&gt;                 return Element(wrapping: element)<br>&gt;&gt;             }<br>&gt;&gt;         }<br>&gt;&gt;           <br>&gt;&gt;         public init(name: String) {<br>&gt;&gt;               <br>&gt;&gt;             self.reference = Reference(name: name)<br>&gt;&gt;         }<br>&gt;&gt; <br>&gt;&gt;         public mutating func add(_ child: Element) {<br>&gt;&gt;               <br>&gt;&gt;             self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt;&gt;         }<br>&gt;&gt;           <br>&gt;&gt;         // Ignore XML.Node, it&#39;s a String or Reference<br>&gt;&gt;         // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt;&gt;         private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;&gt;               <br>&gt;&gt;             // Clone own reference all way up to the root<br>&gt;&gt;             if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;&gt;                   <br>&gt;&gt;                 self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt;             }<br>&gt;&gt;               <br>&gt;&gt;             // Extract a reference or just insert a string as a child<br>&gt;&gt;             guard case .element(let nodeReference) = node.kind else {<br>&gt;&gt;                   <br>&gt;&gt;                 self.reference.insert(node, at: index)<br>&gt;&gt;                 return<br>&gt;&gt;             }<br>&gt;&gt;               <br>&gt;&gt;             // Check for possible debelopment bug<br>&gt;&gt;             if nodeReference === self.reference {<br>&gt;&gt;                   <br>&gt;&gt;                 fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt;&gt;             }<br>&gt;&gt;               <br>&gt;&gt;             self.reference.insert(nodeReference, at: index)<br>&gt;&gt;         }<br>&gt;&gt;           <br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension XML.Element {<br>&gt;&gt;       <br>&gt;&gt;     // public for testing<br>&gt;&gt;     public class Reference : XML.Node {<br>&gt;&gt;           <br>&gt;&gt;         let name: String<br>&gt;&gt; <br>&gt;&gt;         private(set) weak var parent: Reference?<br>&gt;&gt; <br>&gt;&gt;         private(set) var children: [XML.Node]<br>&gt;&gt; <br>&gt;&gt;         var kind: XML.Node.Kind { return .element(self) }<br>&gt;&gt; <br>&gt;&gt;         ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Now lets focus on the problem.<br>&gt;&gt; <br>&gt;&gt; Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br>&gt;&gt; <br>&gt;&gt; Lets look again at the scenario I already described:<br>&gt;&gt; <br>&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;&gt; <br>&gt;&gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt;&gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;&gt; <br>&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;&gt; <br>&gt;&gt; root.add(elem)<br>&gt;&gt; <br>&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; <br>&gt;&gt; root.add(root)<br>&gt;&gt; <br>&gt;&gt; // The reference of root has changed even if the second child   <br>&gt;&gt; // was cloned and added as a new object to the reference.<br>&gt;&gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt; <br>&gt;&gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt;&gt; The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br>&gt;&gt; <br>&gt;&gt; The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br>&gt;&gt; <br>&gt;&gt; I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br>&gt;&gt; <br>&gt;&gt; But I couldn’t find any API for that. :/<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Dear Swift community,<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt;&gt; &gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt;&gt; &gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt;&gt; &gt; single problem atm.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Image this xml tree:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; &lt;root&gt;<br>&gt;&gt;&gt; &gt; &lt;item/&gt;<br>&gt;&gt;&gt; &gt; &lt;/root&gt;<br>&gt;&gt;&gt; &gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt;&gt; &gt; should be totally fine to do something like this:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // The given xml tree<br>&gt;&gt;&gt; &gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt;&gt; &gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt;&gt; &gt; root.add(item)<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; // The problematic behavior<br>&gt;&gt;&gt; &gt; root.add(root)<br>&gt;&gt;&gt; &gt; If this would be a simple value type without any references behind the<br>&gt;&gt;&gt; &gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt;&gt; &gt; look like this:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; &lt;root&gt;<br>&gt;&gt;&gt; &gt; &lt;item/&gt;<br>&gt;&gt;&gt; &gt; &lt;root&gt;<br>&gt;&gt;&gt; &gt; &lt;item/&gt;<br>&gt;&gt;&gt; &gt; &lt;/root&gt;<br>&gt;&gt;&gt; &gt; &lt;/root&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt;&gt;&gt; The simplest way to implement this tree is to use an Array for the child<br>&gt;&gt;&gt; nodes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt;&gt; &gt; into the original root element.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt;&gt; &gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt;&gt; &gt; the original root element.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt;&gt; &gt; the add method.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ...as it should.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt;&gt; &gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt;&gt;&gt; you hope for?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt;&gt; &gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt;&gt; &gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt;&gt; &gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt;&gt; &gt; anymore and I need a way to escape from it.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I’d appreciate any suggestions and help. :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt;&gt;&gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/78df34a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[swift-users] Problem with COW optimization</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>September 19, 2016 at 11:00:00pm</p></header><div class="content"><p>or could the problem be flip on its head and implemented with a normal reference type, dealing with threading issues instead of having to optimise CoW and still perhaps being open to spikes in memory bandwidth at the wrong time when the copy is actually performed?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 19 Sep 2016, at 22:46, Andrew Trick via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 19, 2016, at 3:18 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think I just found a solution to my problem:<br>&gt;&gt; <br>&gt;&gt; /// - Parameter child: The new `child` to add to the `children` array.<br>&gt;&gt; public mutating func add(_ child: Element) {<br>&gt;&gt; <br>&gt;&gt;    let clonedChildReference = Reference(cloning: child.reference)<br>&gt;&gt;    let index = self.reference.children.endIndex<br>&gt;&gt;              <br>&gt;&gt;    self.mutableInsert(clonedChildReference, at: index, isNotOwnReference: child.reference !== self.reference)<br>&gt;&gt; }<br>&gt;&gt;          <br>&gt;&gt; /// Warning: Pass only clonded nodes of type Element to this function!<br>&gt;&gt; private mutating func mutableInsert(_ node: XML.Node, at index: Int, isNotOwnReference: Bool) {<br>&gt;&gt; <br>&gt;&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a String,<br>&gt;&gt;    //   we should rebuilt own reference.<br>&gt;&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a Reference<br>&gt;&gt;    //   `isNotOwnReference` is true, we should rebuilt own reference.<br>&gt;&gt;    // * If `self.reference` is NOT uniquely referenced and `node` is a clone  <br>&gt;&gt;    //   reference to `self.reference` where is `isNotOwnReference` is false, we<br>&gt;&gt;    //   should check if there are more than **two** strong references to rebuild<br>&gt;&gt;    //   own reference, otherwise it&#39;s an implementation artifact and we can keep<br>&gt;&gt;    //   old reference (any `node` of type Reference is cloned before it&#39;s added  <br>&gt;&gt;    //   to the child array).<br>&gt;&gt;    let isNotKnownUniquelyReferenced = !isKnownUniquelyReferenced(&amp;self.reference)<br>&gt;&gt;              <br>&gt;&gt;    var shouldRebuildReference = false<br>&gt;&gt;              <br>&gt;&gt;    switch node.kind {<br>&gt;&gt;                  <br>&gt;&gt;    case .element(_):<br>&gt;&gt;       let hasMoreThanTwoStrongReferences = (CFGetRetainCount(self.reference) - 1) &gt; 2<br>&gt;&gt;       shouldRebuildReference = (isNotKnownUniquelyReferenced &amp;&amp; isNotOwnReference) || hasMoreThanTwoStrongReferences<br>&gt;&gt;                  <br>&gt;&gt;    case .text(_):<br>&gt;&gt;       shouldRebuildReference = isNotKnownUniquelyReferenced<br>&gt;&gt;    }<br>&gt;&gt;              <br>&gt;&gt;    if shouldRebuildReference {<br>&gt;&gt;                  <br>&gt;&gt;       self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    self.reference.insert(node, at: index)<br>&gt;&gt; }<br>&gt;&gt; I’m using CFGetRetainCount(self.reference) to catch that implementation artifact.<br>&gt;&gt; <br>&gt; If people are resorting to CFGetRetainCount, then we have a problem. The optimizer is not under any obligation to bump the refcount to 2.<br>&gt; <br>&gt; There must be a better way to handle this. Rather than passing an<br>&gt; &#39;isNotOwnReference&#39; flag, I think you should determine whether a clone<br>&gt; is needed before passing the node into mutableInsert.<br>&gt; <br>&gt; You effectively want an API like root.addSelf().<br>&gt; <br>&gt; -Andy<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 19. September 2016 um 09:59:24, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello Dave,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; thank you for trying to help me. I’ll try to explain the issue with some more details.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First here is some code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension XML {<br>&gt;&gt;&gt;       <br>&gt;&gt;&gt;     public struct Element {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // public for testing   <br>&gt;&gt;&gt;         public var reference: Reference<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         public var name: String { return self.reference.name }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         public var children: [Element] {<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             return self.reference.children.flatMap {<br>&gt;&gt;&gt;                   <br>&gt;&gt;&gt;                 guard case .element(let element) = $0.kind else { return nil }<br>&gt;&gt;&gt;                 return Element(wrapping: element)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;           <br>&gt;&gt;&gt;         public init(name: String) {<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             self.reference = Reference(name: name)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         public mutating func add(_ child: Element) {<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             self.mutableInsert(Reference(cloning: child.reference), at: self.reference.children.endIndex)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;           <br>&gt;&gt;&gt;         // Ignore XML.Node, it&#39;s a String or Reference<br>&gt;&gt;&gt;         // Parameter `Node` is assumed to be a clone of a reference passed to `add` or `insert` method.<br>&gt;&gt;&gt;         private mutating func mutableInsert(_ node: XML.Node, at index: Int) {<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             // Clone own reference all way up to the root<br>&gt;&gt;&gt;             if !isKnownUniquelyReferenced(&amp;self.reference) {<br>&gt;&gt;&gt;                   <br>&gt;&gt;&gt;                 self.reference = Reference(cloning: self.reference, wholeTree: true)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             // Extract a reference or just insert a string as a child<br>&gt;&gt;&gt;             guard case .element(let nodeReference) = node.kind else {<br>&gt;&gt;&gt;                   <br>&gt;&gt;&gt;                 self.reference.insert(node, at: index)<br>&gt;&gt;&gt;                 return<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             // Check for possible debelopment bug<br>&gt;&gt;&gt;             if nodeReference === self.reference {<br>&gt;&gt;&gt;                   <br>&gt;&gt;&gt;                 fatalError(&quot;wrong usage of `mutableInsert` function&quot;)<br>&gt;&gt;&gt;             }<br>&gt;&gt;&gt;               <br>&gt;&gt;&gt;             self.reference.insert(nodeReference, at: index)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;           <br>&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension XML.Element {<br>&gt;&gt;&gt;       <br>&gt;&gt;&gt;     // public for testing<br>&gt;&gt;&gt;     public class Reference : XML.Node {<br>&gt;&gt;&gt;           <br>&gt;&gt;&gt;         let name: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         private(set) weak var parent: Reference?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         private(set) var children: [XML.Node]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         var kind: XML.Node.Kind { return .element(self) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Now lets focus on the problem.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Every Element is baked with it’s own Reference to be able to traverse the tree from any of it’s node all way up to the root for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Lets look again at the scenario I already described:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt;&gt; var elem = XML.Element(name: &quot;elem&quot;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ObjectIdentifier(root.reference) // 0x000060000026ab40<br>&gt;&gt;&gt; ObjectIdentifier(elem.reference) // 0x000060800026bb00<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt;&gt; isKnownUniquelyReferenced(&amp;elem.reference) // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; root.add(elem)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; root.add(root)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // The reference of root has changed even if the second child   <br>&gt;&gt;&gt; // was cloned and added as a new object to the reference.<br>&gt;&gt;&gt; // 0x000060000026ab40 &lt;-- was thrown away<br>&gt;&gt;&gt; isKnownUniquelyReferenced(&amp;root.reference) // true<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ObjectIdentifier(root.reference) // 0x000060000026c680 &lt;— new one<br>&gt;&gt;&gt; The way I’m adding children to the tree is that every passed element of type XML.Element stores a Reference, which will be cloned and added as a new standalone object to the children array.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The same happens when we try adding root as it’s own child. We copy root struct which contains the same reference, then we clone it inside add method, then we pass the new object to the mutableInsert function. At that point we don’t need the old reference anymore, I’m speaking of root.add(root). The problem here is that at that time root.reference has 2 strong references which I cannot escape.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could workaround the problem if I knew the reference counter value, because I could check if the passed Element contains the same reference first. And if it does and we have exactly 2 strong references, I don’t need to recreate root.reference here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I couldn’t find any API for that. :/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 19. September 2016 um 05:50:57, Dave Abrahams via swift-users (swift-users at swift.org) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Sun Sep 18 2016, Adrian Zubarev &lt;swift-users-AT-swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Dear Swift community,<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; currently I’m building a value type XML library which is baked behind<br>&gt;&gt;&gt;&gt; &gt; the scene with a reference type to manage graph traversing between<br>&gt;&gt;&gt;&gt; &gt; nodes. I also like to COW optimize the xml graph, but I run into one<br>&gt;&gt;&gt;&gt; &gt; single problem atm.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Image this xml tree:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;root&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;item/&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;/root&gt;<br>&gt;&gt;&gt;&gt; &gt; It’s just a root element with one single child. As for value types it<br>&gt;&gt;&gt;&gt; &gt; should be totally fine to do something like this:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; // The given xml tree<br>&gt;&gt;&gt;&gt; &gt; var root = XML.Element(name: &quot;root&quot;)<br>&gt;&gt;&gt;&gt; &gt; let item = XML.Element(name: &quot;item&quot;)<br>&gt;&gt;&gt;&gt; &gt; root.add(item)<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; // The problematic behavior<br>&gt;&gt;&gt;&gt; &gt; root.add(root)<br>&gt;&gt;&gt;&gt; &gt; If this would be a simple value type without any references behind the<br>&gt;&gt;&gt;&gt; &gt; scenes you could imagine that the result of the last code line will<br>&gt;&gt;&gt;&gt; &gt; look like this:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;root&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;item/&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;root&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;item/&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;/root&gt;<br>&gt;&gt;&gt;&gt; &gt; &lt;/root&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yep, that&#39;s exactly the right answer for a tree with value semantics.<br>&gt;&gt;&gt;&gt; The simplest way to implement this tree is to use an Array for the child<br>&gt;&gt;&gt;&gt; nodes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Basically we copied the whole tree and added it as the second child<br>&gt;&gt;&gt;&gt; &gt; into the original root element.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; As for COW optimization this is a problem, just because the passed<br>&gt;&gt;&gt;&gt; &gt; root is a copy of a struct that contains the exact same reference as<br>&gt;&gt;&gt;&gt; &gt; the original root element.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t understand why that&#39;s a problem.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; isKnownUniquelyReferenced(&amp;self.reference) will result in false inside<br>&gt;&gt;&gt;&gt; &gt; the add method.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ...as it should.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; Is there any chance I could force my program to decrease the reference<br>&gt;&gt;&gt;&gt; &gt; counter of that last item after I’m sure I don’t need it?!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which last item? When are you sure you don&#39;t need it? What result do<br>&gt;&gt;&gt;&gt; you hope for?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; A few more details: inside the add method I’m always cloning the<br>&gt;&gt;&gt;&gt; &gt; passed reference just because graphs aren’t that trivial and otherwise<br>&gt;&gt;&gt;&gt; &gt; I could possibly end up with a cycle graph, which would be really<br>&gt;&gt;&gt;&gt; &gt; bad. After that job I’m sure that I don’t need the passed reference<br>&gt;&gt;&gt;&gt; &gt; anymore and I need a way to escape from it.<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I’d appreciate any suggestions and help. :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s not clear what you want to acheive nor can I picture the code<br>&gt;&gt;&gt;&gt; you&#39;re using to acheive it, so it&#39;s hard to give useful feedback.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-users mailing list<br>&gt;&gt;&gt;&gt; swift-users at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160919/e64667c8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
