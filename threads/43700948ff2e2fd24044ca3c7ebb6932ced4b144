<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March 26, 2016 at 07:00:00pm</p></header><div class="content"><p>UnsafePointer is most often used for interfacing with C libraries. They<br>will almost never add nullability annotations. It means that<br>UnsafePointer&lt;Type&gt;? will become an idiom. But we currently have a terser<br>form, and it&#39;s arguably clear from it that Pointer can be null.<br></p><p>90% of programmers and 99.9% of those working with C libraries are familiar<br>with concept of C pointer and null pointer. So it&#39;s clear for every one we<br>can call a programmer that *Pointer types contain plain C nullable pointers<br>with Swift whistles.<br></p><p>Overall, separating strongly connected concepts and then tying them<br>together using compiler magic just can&#39;t have a reasonable explanation.<br>~0x0 in UnsafeBufferPointer is utterly rediculous.<br></p><p>&gt; What is your evaluation of the proposal?<br>-1<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to<br>Swift?<br>No, I don&#39;t see any motivation for the change.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br>No, it&#39;s headed in the opposite direction.<br></p><p>&gt; If you have you used other languages or libraries with a similar feature,<br>how do you feel that this proposal compares to those?<br>Rust denotes pointers using * and has no problems with that.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading,<br>or an in-depth study?<br>Followed the discussion.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160326/4370b144/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 26, 2016, at 9:15, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; But we currently have a terser form, and it&#39;s arguably clear from it that Pointer can be null.<br></p><p>For the record, I literally talked to someone last week who didn&#39;t know that UnsafePointer can be null. :-) They thought we&#39;d already implemented this and there was a bug in the importer.<br></p><p>&gt; Overall, separating strongly connected concepts and then tying them together using compiler magic just can&#39;t have a reasonable explanation. ~0x0 in UnsafeBufferPointer is utterly rediculous.<br></p><p><br>I&#39;m not sure what this comment refers to. Can you explain?<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/f9280033/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>March 28, 2016 at 09:00:00pm</p></header><div class="content"><p>UnsafeBufferPointer is currently represented as a (nullable) C pointer plus<br>size. It can be implemented almost in pure Swift (with calls to C<br>functions).<br></p><p>After the proposal is accepted, it will be replaced with<br>Optional&lt;UnsafeBufferPointer&gt;. But it will require a compiler-only &quot;hack&quot;<br>for Optional not to require extra memory for nil (I assume, Optional will<br>look into address part of UnsafeBufferPointer). This symbiosis will have to<br>be built in the compiler, and I call that &quot;compiler magic&quot;.<br></p><p>The need for such magic is an argument for unified UnsafeBufferPointer to<br>be more &quot;natural&quot;. I&#39;m not going to say that this argument will seem strong<br>for everyone, though.<br></p><p>For that last statement, I was trying to say that we wouldn&#39;t need to<br>invent special value for &quot;empty&quot; UnsafeBufferPointer if we left everything<br>as it is now.<br></p><p>Also I agree that this change will be positive for use of *Pointer strictly<br>inside Swift. It is mainly interaction with C that will become more verbose.<br></p><p>2016-03-28 20:45 GMT+03:00 Jordan Rose &lt;jordan_rose at apple.com&gt;:<br></p><p>&gt;<br>&gt; On Mar 26, 2016, at 9:15, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; But we currently have a terser form, and it&#39;s arguably clear from it that<br>&gt; Pointer can be null.<br>&gt;<br>&gt;<br>&gt; For the record, I literally talked to someone last week who didn&#39;t know<br>&gt; that UnsafePointer can be null. :-) They thought we&#39;d already implemented<br>&gt; this and there was a bug in the importer.<br>&gt;<br>&gt; Overall, separating strongly connected concepts and then tying them<br>&gt; together using compiler magic just can&#39;t have a reasonable explanation.<br>&gt; ~0x0 in UnsafeBufferPointer is utterly rediculous.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure what this comment refers to. Can you explain?<br>&gt;<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/0d4e7502/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Review] SE-0055 Make unsafe pointer nullability explicit using Optional</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 28, 2016 at 11:00:00am</p></header><div class="content"><p>Thank you for elaborating on your concerns! Some responses below.<br></p><p>&gt; On Mar 28, 2016, at 11:09, Антон Жилин &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; UnsafeBufferPointer is currently represented as a (nullable) C pointer plus size. It can be implemented almost in pure Swift (with calls to C functions).<br>&gt; <br>&gt; After the proposal is accepted, it will be replaced with Optional&lt;UnsafeBufferPointer&gt;.<br></p><p>That is not the proposal; please re-read the section on UnsafeBufferPointer. &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md#unsafebufferpointer&gt; (You might not be happy with this version either, though.)<br></p><p>&gt; But it will require a compiler-only &quot;hack&quot; for Optional not to require extra memory for nil (I assume, Optional will look into address part of UnsafeBufferPointer). This symbiosis will have to be built in the compiler, and I call that &quot;compiler magic&quot;.<br></p><p>This is actually standard behavior for all enum types (guaranteed) and all struct types whose first property is such an enum or built-in type with available &quot;extra inhabitants&quot; (an optimization whose details may change in the future). This includes structs beginning with a non-optional AnyObject, and enum types you define like this:<br></p><p>enum Maybe&lt;T&gt; {<br>  case just(T)<br>  case nothing<br>}<br></p><p>If &#39;T&#39; is a type that has a known invalid representation, such as AnyObject, that representation will be used for the &#39;nothing&#39; case of &#39;Maybe&lt;T&gt;&#39;<br></p><p>Best,<br>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/26499534/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
