<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 25, 2016 at 10:00:00am</p></header><div class="content"><p>Originally I started this topic in a discussion thread but moved it now into its own proposal thread due the lack of feedback.<br></p><p>This proposal contains a breaking change!<br></p><p>You can read a formatted version here: https://gist.github.com/DevAndArtist/8f1113b6d5d0379ebf82bd227cf4a88d<br></p><p>Feel free to also provide feedback if you spot any typos or language mistakes I might have made.<br></p><p>Revising access modifiers on extensions<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>One great goal for Swift 3 is to sort out any source breaking language changes. This proposal aims to fix access modifier inconsistency on extensions compared to other scope declarations types.<br></p><p>Swift-evolution thread: [Proposal] Revising access modifiers on extensions<br></p><p>Motivation<br></p><p>When declaring members on extensions which don’t have an explicit access modifier in Swift 2.2, it is possible to create an implicitly public extension by applying a public modifier to at least one extension member.<br></p><p>public struct A { … }<br></p><p>/* implicitly public */ extension A {<br>     <br>    public var member1: SomeType { … }<br>    /* implicitly internal */ func member2() { … }<br>}<br></p><p>/* implicitly internal */ extension A {<br>     <br>    /* implicitly internal */ var member3: SomeType { … }<br>}<br>Furthermore in Swift 2.2 it is not allowed to apply an access modifier on extensions when a type inheritance clause is present:<br></p><p>public protocol B { … }<br></p><p>// &#39;public&#39; modifier cannot be used with<br>// extensions that declare protocol conformances<br>public extension A : B { … }<br>Proposed solution<br></p><p>Allow access modifier on extension when a type inheritance clause is present.<br></p><p>Remove the behavior of an implicit public extension.<br></p><p>This changes should make access modifier on extensions consistent to classes, structs and enums (and SE–0025).<br></p><p>The current grammar will not change:<br></p><p>extension-declaration → access-level-modifieropt extension type-identifier type-inheritance-clauseopt extension-body<br></p><p>extension-declaration → access-level-modifieropt extension type-identifier requirement-clause extension-body<br></p><p>extension-body → { declarationsopt }<br></p><p>Iff the access-level-modifier is not present, the access modifier on extensions should always be implicitly internal.<br></p><p>Public Api:<br></p><p>Current version:<br></p><p>//===— Implementation version —===//<br></p><p>public protocol Y {<br>     <br>    func member()<br>}<br></p><p>public struct X { … }<br></p><p>/* implicitly public */ extension X : Y {<br>     <br>    public func member() { … }<br>     <br>    /* implicitly internal */ func anotherMember() { … }<br>}<br></p><p>//===— Imported modele version —===//<br></p><p>public protocol Y {<br>     <br>    func member()<br>}<br></p><p>public struct X { … }<br></p><p>public extension X : Y {<br>     <br>    public func member() { … }<br>}<br>New Version:<br></p><p>//===— Implementation version —===//<br></p><p>…<br></p><p>public extension X : Y {<br>     <br>    public func member() { … }<br>     <br>    /* implicitly internal */ func anotherMember() { … }<br>}<br></p><p>//===— Imported modele version —===//<br></p><p>…<br></p><p>public extension X : Y {<br>     <br>    public func member() { … }<br>}<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator, by simply scanning the extension-body for at least one public modifier on its members. Iff a public modifier was found on any member, the migrator can add an explicit public modifier to the extension itself.<br></p><p>Alternatives considered<br></p><p>No other alternative were considered for this proposal.<br>Rationale<br></p><p>On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/e80e355c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 26, 2016 at 08:00:00pm</p></header><div class="content"><p>We’re running out of time, and there is still no feedback although Chris Lattner said to consider this topic in his thread: Partial list of open Swift 3 design topics<br></p><p>I’m not sure if we’re allowed to PR even if there is no feedback at all.<br>Again this is a breaking change!<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 25. Juni 2016 um 10:45:04, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Originally I started this topic in a discussion thread but moved it now into its own proposal thread due the lack of feedback.<br></p><p>This proposal contains a breaking change!<br></p><p>You can read a formatted version here: https://gist.github.com/DevAndArtist/8f1113b6d5d0379ebf82bd227cf4a88d<br></p><p>Feel free to also provide feedback if you spot any typos or language mistakes I might have made.<br></p><p>Revising access modifiers on extensions<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>One great goal for Swift 3 is to sort out any source breaking language changes. This proposal aims to fix access modifier inconsistency on extensions compared to other scope declarations types.<br></p><p>Swift-evolution thread: [Proposal] Revising access modifiers on extensions<br></p><p>Motivation<br></p><p>When declaring members on extensions which don’t have an explicit access modifier in Swift 2.2, it is possible to create an implicitly public extension by applying a public modifier to at least one extension member.<br></p><p>public struct A { … }<br></p><p>/* implicitly public */ extension A {<br>      <br>    public var member1: SomeType { … }<br>    /* implicitly internal */ func member2() { … }<br>}<br></p><p>/* implicitly internal */ extension A {<br>      <br>    /* implicitly internal */ var member3: SomeType { … }<br>}<br>Furthermore in Swift 2.2 it is not allowed to apply an access modifier on extensions when a type inheritance clause is present:<br></p><p>public protocol B { … }<br></p><p>// &#39;public&#39; modifier cannot be used with<br>// extensions that declare protocol conformances<br>public extension A : B { … }<br>Proposed solution<br></p><p>Allow access modifier on extension when a type inheritance clause is present.<br></p><p>Remove the behavior of an implicit public extension.<br></p><p>This changes should make access modifier on extensions consistent to classes, structs and enums (and SE–0025).<br></p><p>The current grammar will not change:<br></p><p>extension-declaration → access-level-modifieropt extension type-identifier type-inheritance-clauseopt extension-body<br></p><p>extension-declaration → access-level-modifieropt extension type-identifier requirement-clause extension-body<br></p><p>extension-body → { declarationsopt }<br></p><p>Iff the access-level-modifier is not present, the access modifier on extensions should always be implicitly internal.<br></p><p>Public Api:<br></p><p>Current version:<br></p><p>//===— Implementation version —===//<br></p><p>public protocol Y {<br>      <br>    func member()<br>}<br></p><p>public struct X { … }<br></p><p>/* implicitly public */ extension X : Y {<br>      <br>    public func member() { … }<br>      <br>    /* implicitly internal */ func anotherMember() { … }<br>}<br></p><p>//===— Imported modele version —===//<br></p><p>public protocol Y {<br>      <br>    func member()<br>}<br></p><p>public struct X { … }<br></p><p>public extension X : Y {<br>      <br>    public func member() { … }<br>}<br>New Version:<br></p><p>//===— Implementation version —===//<br></p><p>…<br></p><p>public extension X : Y {<br>      <br>    public func member() { … }<br>      <br>    /* implicitly internal */ func anotherMember() { … }<br>}<br></p><p>//===— Imported modele version —===//<br></p><p>…<br></p><p>public extension X : Y {<br>      <br>    public func member() { … }<br>}<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator, by simply scanning the extension-body for at least one public modifier on its members. Iff a public modifier was found on any member, the migrator can add an explicit public modifier to the extension itself.<br></p><p>Alternatives considered<br></p><p>No other alternative were considered for this proposal.<br>Rationale<br></p><p>On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/a12f41ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Proposal is moved to a git repo: https://github.com/DevAndArtist/swift-evolution/blob/extensions_access_modifiers/proposals/nnnn-extensions-access-modifiers.md<br></p><p>I also updated a few things for readability.<br>Revising access modifiers on extensions<br></p><p>Proposal: SE-NNNN<br>Author: Adrian Zubarev<br>Status: Awaiting review<br>Review manager: TBD<br>Introduction<br></p><p>One great goal for Swift 3 is to sort out any source breaking language changes. This proposal aims to fix access modifier inconsistency on extensions compared to other scope declarations types.<br></p><p>Swift-evolution thread: [Proposal] Revising access modifiers on extensions<br></p><p>Motivation<br></p><p>When declaring members on extensions which don’t have an explicit access modifier in Swift 2.2, it is possible to create an implicitly public extension by applying a public modifier to at least one extension member.<br></p><p>public struct A { … }<br></p><p>// Implicitly public  <br>extension A {<br>    public var member1: SomeType { … }<br>     <br>    // Implicitly internal  <br>    func member2() { … }<br>}<br></p><p>// Implicitly internal<br>extension A {<br></p><p>    // Implicitly internal<br>    var member3: SomeType { … }<br>}<br>Furthermore in Swift 2.2 it is not allowed to apply an access modifier on extensions when a type inheritance clause is present:<br></p><p>public protocol B { … }<br></p><p>// &#39;public&#39; modifier cannot be used with<br>// extensions that declare protocol conformances<br>public extension A : B { … }<br>Proposed solution<br></p><p>Allow access modifier on extensions when a type inheritance clause is present.<br></p><p>Remove the behavior of an implicit public extension.<br></p><p>This changes should make access modifier on extensions consistent to classes, structs and enums (and SE–0025).<br></p><p>The current grammar will not change:<br></p><p>extension-declaration → access-level-modifieropt extension type-identifier type-inheritance-clauseopt extension-body<br></p><p>extension-declaration → access-level-modifieropt extension type-identifier requirement-clause extension-body<br></p><p>extension-body → { declarationsopt }<br></p><p>Iff the access-level-modifier is not present, the access modifier on extensions should always be implicitly internal.<br></p><p>Impact on APIs:<br></p><p>Current version:<br></p><p>/// Implementation version<br>///========================<br></p><p>public protocol Y {<br>    func member()<br>}<br></p><p>public struct X { … }<br></p><p>// Implicitly public<br>extension X : Y {<br>    public func member() { ... }<br>     <br>    // Implicitly internal<br>    func anotherMember() { ... }<br>}<br></p><p>/// Imported modele version<br>///========================<br></p><p>public protocol Y {<br>    func member()<br>}<br></p><p>public struct X { ... }<br></p><p>// Missing `public` modifier<br>extension X : Y {<br>    public func member() { ... }<br>}<br>New Version:<br></p><p>/// Implementation version<br>///========================<br></p><p>public extension X : Y {<br>    public func member() { ... }<br>     <br>    // Implicitly internal  <br>    func anotherMember() { ... }<br>}<br></p><p>/// Imported modele version<br>///========================<br></p><p>public extension X : Y {<br>    public func member() { ... }<br>}<br>Impact on existing code<br></p><p>This is a source-breaking change that can be automated by a migrator, by simply scanning the extension-body for at least one public modifier on its members. Iff a public modifier was found on any member, the migrator can add an explicit public modifier to the extension itself.<br></p><p>Alternatives considered<br></p><p>No other alternative were considered for this proposal.<br>Rationale<br></p><p>On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/6c18681d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>There was an exchange in the past on how extensions are very different from swift nominal/structural types, and Doug even shared how adding scoping to extensions is not a trivial task by a long shot. In this context, talking about unifying modifier behaviors does not make much sense to me. I am not sure i understand what motivates this change.<br>Regards<br>(From mobile)<br></p><p>&gt; On Jun 26, 2016, at 8:59 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal is moved to a git repo: https://github.com/DevAndArtist/swift-evolution/blob/extensions_access_modifiers/proposals/nnnn-extensions-access-modifiers.md<br>&gt; <br>&gt; I also updated a few things for readability.<br>&gt; Revising access modifiers on extensions<br>&gt; <br>&gt; Proposal: SE-NNNN<br>&gt; Author: Adrian Zubarev<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; One great goal for Swift 3 is to sort out any source breaking language changes. This proposal aims to fix access modifier inconsistency on extensions compared to other scope declarations types.<br>&gt; <br>&gt; Swift-evolution thread: [Proposal] Revising access modifiers on extensions<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; When declaring members on extensions which don’t have an explicit access modifier in Swift 2.2, it is possible to create an implicitly public extension by applying a public modifier to at least one extension member.<br>&gt; <br>&gt; public struct A { … }<br>&gt; <br>&gt; // Implicitly public  <br>&gt; extension A {<br>&gt;     public var member1: SomeType { … }<br>&gt;      <br>&gt;     // Implicitly internal  <br>&gt;     func member2() { … }<br>&gt; }<br>&gt; <br>&gt; // Implicitly internal<br>&gt; extension A {<br>&gt; <br>&gt;     // Implicitly internal<br>&gt;     var member3: SomeType { … }<br>&gt; }<br>&gt; Furthermore in Swift 2.2 it is not allowed to apply an access modifier on extensions when a type inheritance clause is present:<br>&gt; <br>&gt; public protocol B { … }<br>&gt; <br>&gt; // &#39;public&#39; modifier cannot be used with<br>&gt; // extensions that declare protocol conformances<br>&gt; public extension A : B { … }<br>&gt; Proposed solution<br>&gt; <br>&gt; Allow access modifier on extensions when a type inheritance clause is present.<br>&gt; <br>&gt; Remove the behavior of an implicit public extension.<br>&gt; <br>&gt; This changes should make access modifier on extensions consistent to classes, structs and enums (and SE–0025).<br>&gt; <br>&gt; The current grammar will not change:<br>&gt; <br>&gt; extension-declaration → access-level-modifieropt extension type-identifier type-inheritance-clauseopt extension-body<br>&gt; <br>&gt; extension-declaration → access-level-modifieropt extension type-identifier requirement-clause extension-body<br>&gt; <br>&gt; extension-body → { declarationsopt }<br>&gt; <br>&gt; Iff the access-level-modifier is not present, the access modifier on extensions should always be implicitly internal.<br>&gt; <br>&gt; Impact on APIs:<br>&gt; <br>&gt; Current version:<br>&gt; <br>&gt; /// Implementation version<br>&gt; ///========================<br>&gt; <br>&gt; public protocol Y {<br>&gt;     func member()<br>&gt; }<br>&gt; <br>&gt; public struct X { … }<br>&gt; <br>&gt; // Implicitly public<br>&gt; extension X : Y {<br>&gt;     public func member() { ... }<br>&gt;      <br>&gt;     // Implicitly internal<br>&gt;     func anotherMember() { ... }<br>&gt; }<br>&gt; <br>&gt; /// Imported modele version<br>&gt; ///========================<br>&gt; <br>&gt; public protocol Y {<br>&gt;     func member()<br>&gt; }<br>&gt; <br>&gt; public struct X { ... }<br>&gt; <br>&gt; // Missing `public` modifier<br>&gt; extension X : Y {<br>&gt;     public func member() { ... }<br>&gt; }<br>&gt; New Version:<br>&gt; <br>&gt; /// Implementation version<br>&gt; ///========================<br>&gt; <br>&gt; public extension X : Y {<br>&gt;     public func member() { ... }<br>&gt;      <br>&gt;     // Implicitly internal  <br>&gt;     func anotherMember() { ... }<br>&gt; }<br>&gt; <br>&gt; /// Imported modele version<br>&gt; ///========================<br>&gt; <br>&gt; public extension X : Y {<br>&gt;     public func member() { ... }<br>&gt; }<br>&gt; Impact on existing code<br>&gt; <br>&gt; This is a source-breaking change that can be automated by a migrator, by simply scanning the extension-body for at least one public modifier on its members. Iff a public modifier was found on any member, the migrator can add an explicit public modifier to the extension itself.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; No other alternative were considered for this proposal.<br>&gt; Rationale<br>&gt; <br>&gt; On [Date], the core team decided to (TBD) this proposal. When the core team makes a decision regarding this proposal, their rationale for the decision will be written here.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a4333c10/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi, Adrian. Can you explain why you want to make this change? “public” on an extension doesn’t mean anything by itself because you can’t refer to an extension as an entity in and of itself. Access modifiers are disallowed on extensions with protocols because the conformance isn’t controlled by the access modifier and we didn’t want to give the impression that it would.<br></p><p>There’s really no such thing as an “implicitly public extension”. An extension is just a bag of additional members and conformances. An access modifier on the extension sets the default access level of members in the extension as a convenience.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/4e1ddaff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>Hi, Adrian. Can you explain why you want to make this change? “public” on an extension doesn’t mean anything by itself because you can’t refer to an extension as an entity in and of itself. Access modifiers are disallowed on extensions with protocols because the conformance isn’t controlled by the access modifier and we didn’t want to give the impression that it would.<br>Now that you mention this, I did again some tests and I think I now understand why controlling conformance with access modifier would be fatal, but I think this edge-case also can be banned easily.<br></p><p>My first though was looking like this:<br></p><p>public protocol A { func foo() }<br></p><p>public struct B {}<br></p><p>// If we had the same access control like on structs/ classes<br>// We could suppress the visibility (imagine: `internal struct B : A`)<br>internal extension B : A {<br>     <br>    /* implicitly internal */ func foo(){}  <br>     <br>    // Some other custom members for this extension bag<br>    func boo() {}<br>}<br>Next step would be to import the module and extend B with A again, because it isn’t visible for the imported module. And that would lead to a huge problem.<br>BUT this is a very wrong thought, because if extensions would have the same access control as other types, this edge case cannot happen at all. The conformance itself is applied on the type B and moved to its own extension bag. But because the extended type B is public the compiler must raise an error (Fix-me?) for this particular extension that it cannot be internal when its members are coming from a public protocol and must retain public (iff the extend type is public as well).<br></p><p>The example from above will become this:<br></p><p>public protocol A { func foo() }<br></p><p>public struct B {}<br></p><p>public extension B : A {<br>     <br>    public func foo(){}  <br>     <br>    // Access modifier on members won&#39;t be overridden by the extension access modifier anymore<br>    // And they will respect the access level boundary set by the extension<br>    func boo() {}<br>}<br>To sum this example up: the access modifier on extensions should only have control of its bag visibility in respect to the access level of the extended type. This would be consistent to structs, enums and classes.<br></p><p>In Swift we cannot suppress conformance visibility to lower visibility if the extended type is of higher or equal visibility as the protocol.<br></p><p>public protocol A { func foo() }<br></p><p>public struct B : A {<br>     <br>    // foo must retain public<br>    public func foo() {}<br>}<br></p><p>internal protocol C : A {<br>     <br>    // foo must retain internal<br>    // we cannot grant foo more visibility than the type its implemented in<br>    /* implicitly internal */ func foo() {}<br>}<br></p><p>// same for `fileprivate` and `private`<br>public &gt; internal &gt; fileprivate &gt;= private (Iff private is allowed at file scope.)<br></p><p>However we can grant visibility to members and still hide the conformance itself.<br></p><p>internal protocol A { func foo() }<br></p><p>public protocol B : A {<br>     <br>    // foo won&#39;t be visible when imported<br>    func foo() {}<br>}<br></p><p>public protocol C : A {<br>     <br>    // we can grant foo more visibility than it originally had<br>    // foo will be visible when imported, but the  <br>    // conformance to `A` will not be visible<br>    public func foo() {}<br>}<br>That said we could do the same with extensions as well.<br></p><p>internal protocol A { func foo() }<br></p><p>public struct B {}<br></p><p>public extension B : A {<br>     <br>    // we can grant foo visibility but still hide conformance to A<br>    // and move everything from `A` to an extra extension bag<br>    public func foo(){}  <br>     <br>    // Access modifier on members won&#39;t be overridden by the extension access modifier anymore<br>    // And they will respect the access level boundary set by the extension<br>    func boo() {}<br>}<br>This whole idea is to gain more consistent control of visibility and sort out the strange access control rules extensions currently have.<br></p><p>If I’m correct this also would allow us to nest extension (but this needs an other thread in the future) if there is any desire to do so:<br></p><p>internal protocol A {}<br></p><p>public struct B {<br>     <br>    public struct C {}<br>     <br>    /* implicitly internal */ extension C : A {}<br>}<br></p><p>// Nested extension would remove this<br>internal extension B.C : A {}<br>One other thing I’d like to mention is this from the imported stdlib:<br></p><p>extension ErrorProtocol {<br>}<br>How on earth is this possible?<br></p><p>public protocol A {}<br></p><p>public extension A {<br>     <br>    internal func foo()<br>}<br>The imported module would look like this, and there is no empty extension:<br></p><p>public protocol A {}<br>Lets examine the impact on default protocol implementations:<br></p><p>Currently we have this behavior:<br></p><p>public protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { /* implement */ }  <br>}<br>The imported version would look like this.<br></p><p>public protocol A {<br>    public func foo()<br>}<br>As the module user you have no clue that there might be a default implementation, but you sill will be able to use it, because when conforming to A you don’t have to implement foo. This implicitly signals you that there is indeed a default implemenation<br></p><p>struct B : A {} // This will be enough<br></p><p>A().foo() // this is fine<br>One could signal the module user that there is a default implementation by making the extension explicit public as well.<br></p><p>// explicitly marked as public to grant visibility to  <br>// the default implementation extension bag<br>public extension A {<br>     <br>    /// will do something cool<br>    func foo() { /* implement */ }  <br>}<br>The result of the imported module would change and look like this:<br></p><p>public protocol A {<br>    public func foo()<br>}<br></p><p>extension A {<br>     <br>    /// will do something cool<br>    public func foo()<br>}<br>With the proposed change all default implementations will become visible by default and I think this is great step as well.<br></p><p>This will also allow us to hide default implementation for the public usage but still use it internally, which is kinda cool.<br></p><p>There’s really no such thing as an “implicitly public extension”. An extension is just a bag of additional members and conformances. An access modifier on the extension sets the default access level of members in the extension as a convenience.<br>You had me at this point, I misunderstood the behavior completely. I’ll have to rewrite the proposal to the mentioned behavior from above.<br></p><p>Yet I have no idea how complicated this change might be to implement, but I feel like this is a reasonable change.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 02:41:28, Jordan Rose (jordan_rose at apple.com) schrieb:<br></p><p>Hi, Adrian. Can you explain why you want to make this change? “public” on an extension doesn’t mean anything by itself because you can’t refer to an extension as an entity in and of itself. Access modifiers are disallowed on extensions with protocols because the conformance isn’t controlled by the access modifier and we didn’t want to give the impression that it would.<br></p><p>There’s really no such thing as an “implicitly public extension”. An extension is just a bag of additional members and conformances. An access modifier on the extension sets the default access level of members in the extension as a convenience.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/25b7a2b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 11:00:00am</p></header><div class="content"><p>I did a mistake in my last reply which I’m correcting here. I meant structs instead of protocols B and C:<br></p><p>internal protocol A { func foo() }<br></p><p>public struct B : A {<br>      <br>    // foo won&#39;t be visible when imported<br>    func foo() {}<br>}<br></p><p>public struct C : A {<br>      <br>    // we can grant foo more visibility than it originally had<br>    // foo will be visible when imported, but the   <br>    // conformance to `A` will not be visible<br>    public func foo() {}<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 10:38:12, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>internal protocol A { func foo() }<br></p><p>public protocol B : A {<br>      <br>    // foo won&#39;t be visible when imported<br>    func foo() {}<br>}<br></p><p>public protocol C : A {<br>      <br>    // we can grant foo more visibility than it originally had<br>    // foo will be visible when imported, but the   <br>    // conformance to `A` will not be visible<br>    public func foo() {}<br>}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/9050c318/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 12:00:00pm</p></header><div class="content"><p>And yet another correction of the default protocol implementations part of my reply.<br></p><p>The imported module is correct, but the default implementation is not imported (I relied on Xcode which didn’t raise an error before I started building the project where I was using the module, and I didn’t build it at the first time).<br></p><p>So we’d need to implement foo by ourself.<br></p><p>struct B : A {<br>     <br>    public func foo() {}<br>}  <br>The rest of my reply should be fine. With the same access control it would be more clearer and intuitive how the extension will be imported.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 10:38:12, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Lets examine the impact on default protocol implementations:<br></p><p>Currently we have this behavior:<br></p><p>public protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { /* implement */ }   <br>}<br>The imported version would look like this.<br></p><p>public protocol A {<br>    public func foo()<br>}<br>As the module user you have no clue that there might be a default implementation, but you sill will be able to use it, because when conforming to A you don’t have to implement foo. This implicitly signals you that there is indeed a default implemenation<br></p><p>struct B : A {} // This will be enough<br></p><p>A().foo() // this is fine<br>One could signal the module user that there is a default implementation by making the extension explicit public as well.<br></p><p>// explicitly marked as public to grant visibility to   <br>// the default implementation extension bag<br>public extension A {<br>      <br>    /// will do something cool<br>    func foo() { /* implement */ }   <br>}<br>The result of the imported module would change and look like this:<br></p><p>public protocol A {<br>    public func foo()<br>}<br></p><p>extension A {<br>      <br>    /// will do something cool<br>    public func foo()<br>}<br>With the proposed change all default implementations will become visible by default and I think this is great step as well.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/2d284a25/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 02:00:00pm</p></header><div class="content"><p>I completely rewritten the proposal, you can read the formatted version here:<br></p><p>https://github.com/DevAndArtist/swift-evolution/blob/19f2583209a5763880e6f6fa6738ea0c6011f2d6/proposals/nnnn-extensions-access-modifiers.md<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 12:58:53, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>And yet another correction of the default protocol implementations part of my reply.<br></p><p>The imported module is correct, but the default implementation is not imported (I relied on Xcode which didn’t raise an error before I started building the project where I was using the module, and I didn’t build it at the first time).<br></p><p>So we’d need to implement foo by ourself.<br></p><p>struct B : A {<br>      <br>    public func foo() {}<br>}   <br>The rest of my reply should be fine. With the same access control it would be more clearer and intuitive how the extension will be imported.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 10:38:12, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Lets examine the impact on default protocol implementations:<br></p><p>Currently we have this behavior:<br></p><p>public protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { /* implement */ }    <br>}<br>The imported version would look like this.<br></p><p>public protocol A {<br>    public func foo()<br>}<br>As the module user you have no clue that there might be a default implementation, but you sill will be able to use it, because when conforming to A you don’t have to implement foo. This implicitly signals you that there is indeed a default implemenation<br></p><p>struct B : A {} // This will be enough<br></p><p>A().foo() // this is fine<br>One could signal the module user that there is a default implementation by making the extension explicit public as well.<br></p><p>// explicitly marked as public to grant visibility to    <br>// the default implementation extension bag<br>public extension A {<br>       <br>    /// will do something cool<br>    func foo() { /* implement */ }    <br>}<br>The result of the imported module would change and look like this:<br></p><p>public protocol A {<br>    public func foo()<br>}<br></p><p>extension A {<br>       <br>    /// will do something cool<br>    public func foo()<br>}<br>With the proposed change all default implementations will become visible by default and I think this is great step as well.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/05ca0d93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 02:00:00pm</p></header><div class="content"><p>Correcting myself over and over. Here is the correct url: https://github.com/DevAndArtist/swift-evolution/blob/extensions_access_modifiers/proposals/nnnn-extensions-access-modifiers.md<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 14:39:41, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>I completely rewritten the proposal, you can read the formatted version here:<br></p><p>https://github.com/DevAndArtist/swift-evolution/blob/19f2583209a5763880e6f6fa6738ea0c6011f2d6/proposals/nnnn-extensions-access-modifiers.md<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 12:58:53, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>And yet another correction of the default protocol implementations part of my reply.<br></p><p>The imported module is correct, but the default implementation is not imported (I relied on Xcode which didn’t raise an error before I started building the project where I was using the module, and I didn’t build it at the first time).<br></p><p>So we’d need to implement foo by ourself.<br></p><p>struct B : A {<br>       <br>    public func foo() {}<br>}    <br>The rest of my reply should be fine. With the same access control it would be more clearer and intuitive how the extension will be imported.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 27. Juni 2016 um 10:38:12, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>Lets examine the impact on default protocol implementations:<br></p><p>Currently we have this behavior:<br></p><p>public protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { /* implement */ }     <br>}<br>The imported version would look like this.<br></p><p>public protocol A {<br>    public func foo()<br>}<br>As the module user you have no clue that there might be a default implementation, but you sill will be able to use it, because when conforming to A you don’t have to implement foo. This implicitly signals you that there is indeed a default implemenation<br></p><p>struct B : A {} // This will be enough<br></p><p>A().foo() // this is fine<br>One could signal the module user that there is a default implementation by making the extension explicit public as well.<br></p><p>// explicitly marked as public to grant visibility to     <br>// the default implementation extension bag<br>public extension A {<br>        <br>    /// will do something cool<br>    func foo() { /* implement */ }     <br>}<br>The result of the imported module would change and look like this:<br></p><p>public protocol A {<br>    public func foo()<br>}<br></p><p>extension A {<br>        <br>    /// will do something cool<br>    public func foo()<br>}<br>With the proposed change all default implementations will become visible by default and I think this is great step as well.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/d6c8f9a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 27, 2016 at 11:00:00am</p></header><div class="content"><p>I still have no idea why you want to make this change, other than &quot;putting an access modifier on an extension is different from putting an access modifier on a type&quot;. Are you trying to hide protocol conformances that would be otherwise public? That has much greater consequences and a much stronger domino effect than what you&#39;ve discussed here.<br></p><p>Jordan<br></p><p><br>&gt; On Jun 27, 2016, at 5:44, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Correcting myself over and over. Here is the correct url: https://github.com/DevAndArtist/swift-evolution/blob/extensions_access_modifiers/proposals/nnnn-extensions-access-modifiers.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/extensions_access_modifiers/proposals/nnnn-extensions-access-modifiers.md&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 27. Juni 2016 um 14:39:41, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I completely rewritten the proposal, you can read the formatted version here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/DevAndArtist/swift-evolution/blob/19f2583209a5763880e6f6fa6738ea0c6011f2d6/proposals/nnnn-extensions-access-modifiers.md &lt;https://github.com/DevAndArtist/swift-evolution/blob/19f2583209a5763880e6f6fa6738ea0c6011f2d6/proposals/nnnn-extensions-access-modifiers.md&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 27. Juni 2016 um 12:58:53, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; And yet another correction of the default protocol implementations part of my reply.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The imported module is correct, but the default implementation is not imported (I relied on Xcode which didn’t raise an error before I started building the project where I was using the module, and I didn’t build it at the first time).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So we’d need to implement foo by ourself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct B : A {<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt;     public func foo() {}<br>&gt;&gt;&gt; }    <br>&gt;&gt;&gt; The rest of my reply should be fine. With the same access control it would be more clearer and intuitive how the extension will be imported.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Adrian Zubarev<br>&gt;&gt;&gt; Sent with Airmail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 27. Juni 2016 um 10:38:12, Adrian Zubarev (adrian.zubarev at devandartist.com &lt;mailto:adrian.zubarev at devandartist.com&gt;) schrieb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Lets examine the impact on default protocol implementations:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently we have this behavior:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public protocol A {<br>&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;     func foo() { /* implement */ }     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; The imported version would look like this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public protocol A {<br>&gt;&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; As the module user you have no clue that there might be a default implementation, but you sill will be able to use it, because when conforming to A you don’t have to implement foo. This implicitly signals you that there is indeed a default implemenation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; struct B : A {} // This will be enough<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A().foo() // this is fine<br>&gt;&gt;&gt;&gt; One could signal the module user that there is a default implementation by making the extension explicit public as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // explicitly marked as public to grant visibility to     <br>&gt;&gt;&gt;&gt; // the default implementation extension bag<br>&gt;&gt;&gt;&gt; public extension A {<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;     /// will do something cool<br>&gt;&gt;&gt;&gt;     func foo() { /* implement */ }     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; The result of the imported module would change and look like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public protocol A {<br>&gt;&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;         <br>&gt;&gt;&gt;&gt;     /// will do something cool<br>&gt;&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; With the proposed change all default implementations will become visible by default and I think this is great step as well.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/462be248/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>I still have no idea why you want to make this change, other than “putting an access modifier on an extension is different from putting an access modifier on a type”. Are you trying to hide protocol conformances that would be otherwise public?<br>In my proposal I cannot hide a public protocol conformance. Its not possible with normal types and it shouldn’t be possible with extensions as well. (Correct me if I’m wrong.) I really want the same access control behavior with extensions like whit classes, enums and structs. For new Swift developers such consistency would be great, because they won’t need to learn another access control behavior (second one goes to protocols).<br></p><p>As I showed in my proposal right now its possible to create three different version of public protocol default implementation:<br></p><p>public protocol A {<br>    func foo()<br>}    <br></p><p>extension A {<br>    public func foo() {}<br>}<br></p><p>public extension A {<br>    func foo() {}<br>}<br></p><p>public extension A {<br>    public func foo() {}<br>}<br>If it was a type and I wanted foo to be visible I’d do this:<br></p><p>public struct B {<br>    public func foo() {}<br>}<br>With the proposed content access control we’d have only one way for public protocol default implementation:<br></p><p>public extension A {<br>    public func foo() {}<br>}<br>Yet it fells strange when there is protocol conformance that we’re not allowed to use access modifier anymore for our extension bag.<br></p><p>// Assume `A` has no default implementation<br>// Extension must retain `public` because B is `public` and `A` as well<br>// Explicitly public which is crystal clear<br>public extension B : A {<br>     <br>    // foo must retain `public`<br>    public func foo()<br>     <br>    // custom member - implicitly internal - like on classes enums structs<br>    func member() {}<br>}<br>Some rules from the proposal:<br></p><p>Access modifier on extensions should respect the modifier of the extended type and the protocol to which it should conform.<br></p><p>Public protocol:<br></p><p>public type + public protocol = public extension<br>internal type + public protocol = internal extension<br>private type + public protocol = private extension<br>Internal protocol:<br></p><p>public type + internal protocol = public extension or internal extension<br>internal type + internal protocol = internal extension<br>private type + internal protocol = private extension<br>Private protocol:<br></p><p>public type + private protocol = public extension or internal extension or private extension<br>internal type + private protocol = internal extension or private extension<br>private type + private protocol = private extension<br>Multiple protocol conformance is decided analogously by using the highest access modifier from all protocols + the access level of the extended type.<br></p><p>That has much greater consequences and a much stronger domino effect than what you’ve discussed here.<br>Could you explain this a little more? Maybe I’m to blind to see what else could break this my proposal.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/f864aef7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 13:00, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I still have no idea why you want to make this change, other than “putting an access modifier on an extension is different from putting an access modifier on a type”. Are you trying to hide protocol conformances that would be otherwise public? <br>&gt; In my proposal I cannot hide a public protocol conformance. Its not possible with normal types and it shouldn’t be possible with extensions as well. (Correct me if I’m wrong.) I really want the same access control behavior with extensions like whit classes, enums and structs. For new Swift developers such consistency would be great, because they won’t need to learn another access control behavior (second one goes to protocols). <br>&gt; <br></p><p>If you want consistent behavior, the proposal should just be &quot;remove access modifiers from extensions&quot;. That way, access for members follows the same defaults as in the original type. The only purpose for access modifiers on extensions is to change the default, so if you don&#39;t like the behavior of changing the default, then the feature should be removed.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/89783e43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 28, 2016 at 12:00:00am</p></header><div class="content"><p>If you want consistent behavior, the proposal should just be “remove access modifiers from extensions”. That way, access for members follows the same defaults as in the original type. The only purpose for access modifiers on extensions is to change the default, so if you don’t like the behavior of changing the default, then the feature should be removed.<br>I’m a little confused right now, because to me “remove access modifiers from extensions” sounds like there will be no access modifier at all.<br></p><p>And yes I indeed don’t like that behavior, because it has a lot potential of confusion. Don’t get me wrong, now I do understand how it works, but the way it behaves is strange.<br></p><p>If we’d remove this feature, would extensions automatically work like I described in the proposal?<br></p><p>internal protocol A {<br>    func foo()<br>}<br></p><p>public struct B {}<br></p><p>// A is hidden<br>public extension B : A {<br>     <br>    // `foo` can be made visible<br>    public func foo() {}<br>}<br></p><p>// extension will be imported as<br></p><p>public extension B {<br>    public func foo()<br>}<br>Anything else I made need to change to drive my proposal into that direction?<br></p><p>I really appreciate your feedback. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/5321d2d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 28, 2016 at 12:00:00am</p></header><div class="content"><p>I apologize for all the typos I make, I’m way too tired and it’s already late night for me. (I just feel like I need to apologize :] )<br></p><p>I meant:<br></p><p>Anything else I may need to change to drive my proposal into that direction?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 28. Juni 2016 um 00:17:35, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>If you want consistent behavior, the proposal should just be “remove access modifiers from extensions”. That way, access for members follows the same defaults as in the original type. The only purpose for access modifiers on extensions is to change the default, so if you don’t like the behavior of changing the default, then the feature should be removed.<br>I’m a little confused right now, because to me “remove access modifiers from extensions” sounds like there will be no access modifier at all.<br></p><p>And yes I indeed don’t like that behavior, because it has a lot potential of confusion. Don’t get me wrong, now I do understand how it works, but the way it behaves is strange.<br></p><p>If we’d remove this feature, would extensions automatically work like I described in the proposal?<br></p><p>internal protocol A {<br>    func foo()<br>}<br></p><p>public struct B {}<br></p><p>// A is hidden<br>public extension B : A {<br>      <br>    // `foo` can be made visible<br>    public func foo() {}<br>}<br></p><p>// extension will be imported as<br></p><p>public extension B {<br>    public func foo()<br>}<br>Anything else I made need to change to drive my proposal into that direction?<br></p><p>I really appreciate your feedback. :)<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/e3f28b75/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>I would be against removing access modifiers on extensions. I actually don&#39;t see anything wrong with the way extensions work with modifiers right now.  Consistency for consistency&#39;s sake is never a good measurement if it is not addressing a pain point. <br></p><p>When ever I extend a swift standard type, I always make it &quot;fileprivate&quot; because I don&#39;t want to pollute autocomplete for that type. <br></p><p>fileprivate extension Int {<br>   func double() -&gt; Int {<br>       return self*2<br>   }<br>}<br></p><p>My understanding is that private / fileprivate was renamed/introduced to help with extensions. I don&#39;t think extensions need anymore complexities. I would hardly ever use private in swift 3 for example (when it gets implemented.) <br></p><p><br></p><p><br></p><p>&gt; On Jun 27, 2016, at 3:06 PM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 13:00, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I still have no idea why you want to make this change, other than “putting an access modifier on an extension is different from putting an access modifier on a type”. Are you trying to hide protocol conformances that would be otherwise public? <br>&gt;&gt; In my proposal I cannot hide a public protocol conformance. Its not possible with normal types and it shouldn’t be possible with extensions as well. (Correct me if I’m wrong.) I really want the same access control behavior with extensions like whit classes, enums and structs. For new Swift developers such consistency would be great, because they won’t need to learn another access control behavior (second one goes to protocols). <br>&gt;&gt; <br>&gt; <br>&gt; If you want consistent behavior, the proposal should just be &quot;remove access modifiers from extensions&quot;. That way, access for members follows the same defaults as in the original type. The only purpose for access modifiers on extensions is to change the default, so if you don&#39;t like the behavior of changing the default, then the feature should be removed.<br>&gt; <br>&gt; Jordan<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a1615686/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>How do private or fileprivate help extensions in general? Is really laziness a strong argument over consistency and clarity?<br></p><p>As for your example I’d have a pretty good solution (I can’t say this will be accepted, but the idea is great, at least I think that way. I’d propose for that feature after Swift 3 drops):<br></p><p>// Use correct consistent access control<br>fileprivate extension Int {<br>     <br>    // every member of a nameless group would be `fileprivate`<br>    fileprivate group {<br>     <br>       func double() -&gt; Int {<br>           return self*2<br>       }<br>        <br>       func member1() {}<br>       func member2() {}<br>       func member3() {}<br>       func member4() {}<br>    }<br>}<br>A group could do way more than just in this example: https://gist.github.com/DevAndArtist/c74f706febf93452999881335f6ca1f9<br></p><p>We’d move the behavior out into its own more powerful feature.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 28. Juni 2016 um 03:14:08, Jose Cheyo Jimenez (cheyo at masters3d.com) schrieb:<br></p><p>I would be against removing access modifiers on extensions. I actually don&#39;t see anything wrong with the way extensions work with modifiers right now.  Consistency for consistency&#39;s sake is never a good measurement if it is not addressing a pain point. <br></p><p>When ever I extend a swift standard type, I always make it &quot;fileprivate&quot; because I don&#39;t want to pollute autocomplete for that type. <br></p><p>fileprivate extension Int {<br>   func double() -&gt; Int {<br>       return self*2<br>   }<br>}<br></p><p>My understanding is that private / fileprivate was renamed/introduced to help with extensions. I don&#39;t think extensions need anymore complexities. I would hardly ever use private in swift 3 for example (when it gets implemented.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/74e54ae7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 12:40 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; How do private or fileprivate help extensions in general?<br>&gt; <br>https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0025-scoped-access-level.md&gt;<br></p><p>&gt; Is really laziness a strong argument over consistency and clarity? <br>&gt; <br>&gt; <br></p><p>What does ‘lazy’ have to do with anything in this proposal? Im confused. <br></p><p>I know that your desire is to make it consistent and thus clear but the reality is that <br>this proposal ( and `group` ) would just make the language complex and really confusing. <br></p><p><br>&gt; As for your example I’d have a pretty good solution (I can’t say this will be accepted, but the idea is great, at least I think that way. I’d propose for that feature after Swift 3 drops):<br>&gt; <br>&gt; // Use correct consistent access control<br>&gt; fileprivate extension Int {<br>&gt;      <br>&gt;     // every member of a nameless group would be `fileprivate`<br>&gt;     fileprivate group {<br>&gt;      <br>&gt;        func double() -&gt; Int {<br>&gt;            return self*2<br>&gt;        }<br>&gt;         <br>&gt;        func member1() {}<br>&gt;        func member2() {}<br>&gt;        func member3() {}<br>&gt;        func member4() {}<br>&gt;     }<br>&gt; }<br>&gt; A group could do way more than just in this example: https://gist.github.com/DevAndArtist/c74f706febf93452999881335f6ca1f9 &lt;https://gist.github.com/DevAndArtist/c74f706febf93452999881335f6ca1f9&gt;<br>&gt; We’d move the behavior out into its own more powerful feature.<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 28. Juni 2016 um 03:14:08, Jose Cheyo Jimenez (cheyo at masters3d.com &lt;mailto:cheyo at masters3d.com&gt;) schrieb:<br>&gt; <br>&gt;&gt; I would be against removing access modifiers on extensions. I actually don&#39;t see anything wrong with the way extensions work with modifiers right now.  Consistency for consistency&#39;s sake is never a good measurement if it is not addressing a pain point. <br>&gt;&gt; <br>&gt;&gt; When ever I extend a swift standard type, I always make it &quot;fileprivate&quot; because I don&#39;t want to pollute autocomplete for that type. <br>&gt;&gt; <br>&gt;&gt; fileprivate extension Int {<br>&gt;&gt;    func double() -&gt; Int {<br>&gt;&gt;        return self*2<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; My understanding is that private / fileprivate was renamed/introduced to help with extensions. I don&#39;t think extensions need anymore complexities. I would hardly ever use private in swift 3 for example (when it gets implemented.)<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/b9f1beb6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Laziness of typing out fileprivate on all extension members.<br></p><p>group is exactly what access modifier do right now on extensions.<br></p><p>Current access control on extensions is a mix of the access control from classes (enums and struct) and the access control from protocols (which is like groups will work). But the result isn’t great when it comes to conformances or default implementations. I already showed a few examples where it gets weird.<br></p><p>My opinion the the exact opposite, because I think it won’t be complex that way. People were already asking for something similar for declarations to group variables by an access modifier and reduce the boiler plate. An extra group scope won’t hurt you and it signals in a nice design where all group members will have the exact same access modifier.<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 28. Juni 2016 um 22:55:23, Jose Cheyo Jimenez (cheyo at masters3d.com) schrieb:<br></p><p>What does ‘lazy’ have to do with anything in this proposal? Im confused. <br></p><p>I know that your desire is to make it consistent and thus clear but the reality is that <br>this proposal ( and `group` ) would just make the language complex and really confusing. <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/8bbb9ef6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&quot;The access modifier of an extension sets the default modifier of its members which has no modifier applied to them.&quot;<br></p><p>I cannot understand the sentence, or the following:<br></p><p>&quot;If there the extension has no access modifier, then the default modifier of its members which has no explicit modifier will be internal if the extended type is either public or internal, or it will be private when the extended type is private(analogous for fileprivate).&quot;<br></p><p>But more importantly, I was under the impression that Doug had hinted that private (or likely more generally scoped) conformance on extension was a slipery slope with important impact on runtime performance.<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 27, 2016, at 2:39 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I completely rewritten the proposal, you can read the formatted version here:<br>&gt; <br>&gt; https://github.com/DevAndArtist/swift-evolution/blob/19f2583209a5763880e6f6fa6738ea0c6011f2d6/proposals/nnnn-extensions-access-modifiers.md<br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; <br>&gt; Am 27. Juni 2016 um 12:58:53, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt; <br>&gt;&gt; And yet another correction of the default protocol implementations part of my reply.<br>&gt;&gt; <br>&gt;&gt; The imported module is correct, but the default implementation is not imported (I relied on Xcode which didn’t raise an error before I started building the project where I was using the module, and I didn’t build it at the first time).<br>&gt;&gt; <br>&gt;&gt; So we’d need to implement foo by ourself.<br>&gt;&gt; <br>&gt;&gt; struct B : A {<br>&gt;&gt;       <br>&gt;&gt;     public func foo() {}<br>&gt;&gt; }   <br>&gt;&gt; The rest of my reply should be fine. With the same access control it would be more clearer and intuitive how the extension will be imported.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Adrian Zubarev<br>&gt;&gt; Sent with Airmail<br>&gt;&gt; <br>&gt;&gt; Am 27. Juni 2016 um 10:38:12, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br>&gt;&gt; <br>&gt;&gt;&gt; Lets examine the impact on default protocol implementations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently we have this behavior:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol A {<br>&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;     func foo() { /* implement */ }    <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The imported version would look like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol A {<br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; As the module user you have no clue that there might be a default implementation, but you sill will be able to use it, because when conforming to A you don’t have to implement foo. This implicitly signals you that there is indeed a default implemenation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct B : A {} // This will be enough<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A().foo() // this is fine<br>&gt;&gt;&gt; One could signal the module user that there is a default implementation by making the extension explicit public as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // explicitly marked as public to grant visibility to    <br>&gt;&gt;&gt; // the default implementation extension bag<br>&gt;&gt;&gt; public extension A {<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt;     /// will do something cool<br>&gt;&gt;&gt;     func foo() { /* implement */ }    <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; The result of the imported module would change and look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol A {<br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;        <br>&gt;&gt;&gt;     /// will do something cool<br>&gt;&gt;&gt;     public func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; With the proposed change all default implementations will become visible by default and I think this is great step as well.<br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/905222e4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>June 27, 2016 at 11:00:00pm</p></header><div class="content"><p>“The access modifier of an extension sets the default modifier of its members which has no modifier applied to them.”<br>public extension SomeType {<br>    func extensionMember() {}<br>}<br>“If there the extension has no access modifier, then the default modifier of its members which has no explicit modifier will be internal if the extended type is either public or internal, or it will be private when the extended type is private(analogous for fileprivate).”<br>// First<br>public/internal struct A {}<br></p><p>extension A {<br>     <br>    /* internal */ func member() {}<br>}<br></p><p>// Second<br>private struct B {}<br></p><p>extension B {<br>     <br>    /* private */ func member() {}<br>}<br>My English isn’t great, please don’t blame me for that. Feel free to correct me. I’d appreciate that. :)<br></p><p>But more importantly, I was under the impression that Doug had hinted that private (or likely more generally scoped) conformance on extension was a slipery slope with important impact on runtime performance.<br>I’m not an expert in this area, I really cannot tell. And I don’t want to dig in all these thousands of emails to find his talk. FWIW not every proposal does know the impact which will happen behind the scene. Even some simple change might have a huge impact (I don’t say this proposal is simple).<br></p><p>My personal vision of the access control is clarity and consistency. It would be much easier to have the same access control behavior on extensions like on classes, enums and structs.<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/54f7d09f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Revising access modifiers on extensions</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 28, 2016 at 05:00:00am</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 27, 2016, at 11:59 PM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; “The access modifier of an extension sets the default modifier of its members which has no modifier applied to them.”<br></p><p>I get it now.. &quot;which do not have their own localy defined modifier&quot;<br>&gt; public extension SomeType {<br>&gt;     func extensionMember() {}<br>&gt; }<br>&gt; “If there the extension has no access modifier, then the default modifier of its members which has no explicit modifier will be internal if the extended type is either public or internal, or it will be private when the extended type is private(analogous for fileprivate).”<br>&gt; // First<br>&gt; public/internal struct A {}<br>&gt; <br>&gt; extension A {<br>&gt;      <br>&gt;     /* internal */ func member() {}<br>&gt; }<br>&gt; <br>&gt; // Second<br>&gt; private struct B {}<br>&gt; <br>&gt; extension B {<br>&gt;      <br>&gt;     /* private */ func member() {}<br>&gt; }<br>&gt; My English isn’t great, please don’t blame me for that. Feel free to correct me. I’d appreciate that. :)<br>&gt; <br>I didn&#39;t, i just asked for clarification (i truly did not get the meaning). <br></p><p><br>&gt; But more importantly, I was under the impression that Doug had hinted that private (or likely more generally scoped) conformance on extension was a slipery slope with important impact on runtime performance.<br>&gt; I’m not an expert in this area, I really cannot tell. And I don’t want to dig in all these thousands of emails to find his talk. FWIW not every proposal does know the impact which will happen behind the scene. Even some simple change might have a huge impact (I don’t say this proposal is simple).<br>&gt; <br>I am no expert myself. I just happened to remember what looked like a partial answer. The generic manifesto has a section on &#39;Private Conformances&#39; that gives some interesting clues about what&#39;s involved in scoping extension based conformances.<br></p><p>&gt; My personal vision of the access control is clarity and consistency. It would be much easier to have the same access control behavior on extensions like on classes, enums and structs.<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/22308dd0/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
