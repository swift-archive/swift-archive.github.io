<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>May 22, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri May 20 2016, Matthew Johnson &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On May 20, 2016, at 7:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The Any-class requirement could replace the current `AnyObject`<br>&gt;&gt;&gt; protocol with a typealias like this: `typealias AnyObject =<br>&gt;&gt;&gt; Any&lt;class&gt;`<br>&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assume Swift would introduce Any-struct and Any-enum requirement<br>&gt;&gt;&gt; one day. How would one name a typealias for these, where `AnyClass`<br>&gt;&gt;&gt; means `AnyObject.Type`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to<br>&gt;&gt;&gt; `AnyClass`. If one would need the old `AnyClass` behavior it will<br>&gt;&gt;&gt; become `AnyClass.Type`.<br>&gt;&gt; <br>&gt;&gt; I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No<br>&gt;&gt; typealias, just directly using `Any&lt;&gt;`. We would also deprecate<br>&gt;&gt; `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do<br>&gt;&gt; this by providing `AnyObject` and `AnyClass` typealiases in Swift 3,<br>&gt;&gt; but marking them as deprecated.)<br>&gt;&gt; <br>&gt;&gt; I like this approach because it exposes people to `Any&lt;&gt;` and more<br>&gt;&gt; quickly gets them to see how it&#39;s connected to a protocol<br>&gt;&gt; declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;`<br>&gt;&gt; has other capabilities from that list, like the ability to handle<br>&gt;&gt; multiple protocols.<br>&gt;&gt; <br>&gt;&gt;&gt; In the future we could have typealiases like this, which are more clear:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt;&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt;&gt;&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br>&gt;&gt; <br>&gt;&gt; Even in the long term, I don&#39;t see any good reason to support<br>&gt;&gt; `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction*<br>&gt;&gt; between a struct and an enum; you can always implement something<br>&gt;&gt; enum-y using a struct with a mode field, or something struct-y using<br>&gt;&gt; an enum with associated values. `Bool`, for instance, was once an<br>&gt;&gt; enum and was changed to a struct for implementation reasons; this<br>&gt;&gt; change made no difference to how it was used.<br>&gt;&gt; <br>&gt;&gt; Now, there *is* a semantic distinction between struct/enum and<br>&gt;&gt; class—one is a value type, the other is a reference type. To support<br>&gt;&gt; that distinction, it might make sense to support an `Any&lt;value&gt;` or<br>&gt;&gt; `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;`<br>&gt;&gt; syntax, though, not a typealias.<br>&gt;<br>&gt; You can implement reference types with value semantics and value types<br>&gt; with reference semantics.  Until the compiler can verify value<br>&gt; semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The<br>&gt; semantic distinction is what is important.  There has been discussion<br>&gt; about strengthening the “value type == value semantics” and “reference<br>&gt; type == reference semantics” relations but that hasn’t yet moved<br>&gt; beyond talk.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; (I&#39;ve read the arguments about pure vs. non-pure value type<br>&gt;&gt; conformances and I&#39;m not convinced. It is always possible to<br>&gt;&gt; nominally &quot;conform&quot; to a protocol in a way that actually undermines<br>&gt;&gt; its guarantees; for example, you could implement<br>&gt;&gt; `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler<br>&gt;&gt; cannot reject all invalid conformances; it can only reject ones<br>&gt;&gt; which it can trivially show are invalid, because for instance they<br>&gt;&gt; do not even attempt to provide a required method. Similarly, the<br>&gt;&gt; compiler may not be able to prove you are providing value semantics,<br>&gt;&gt; but it *can* reject conformances of reference types to a protocol<br>&gt;&gt; requiring value semantics, since those cannot possibly be valid<br>&gt;&gt; conformances.<br>&gt;<br>&gt; Immutable reference types actually *can* provide valid value semantics<br>&gt; (at least as long as as they can provide their own implementation of<br>&gt; `==` which I believe Dave A is arguing against).<br></p><p>I am not making a strong argument against that, though it might be<br>reasonable.  I am mostly arguing in favor of a default definition of ==<br>for all reference types that is equivalent to ===.<br></p><p>&gt; There is a big difference between semantics that the compiler *could*<br>&gt; but *does not yet* verify and semantics that simply cannot be<br>&gt; verified.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; Incidentally, I am not convinced that it *ever* makes sense to have<br>&gt;&gt; a mutating protocol which does not specify either value or reference<br>&gt;&gt; semantics.<br>&gt;&gt; The only intentional Stdlib examples I&#39;m aware of are<br>&gt;&gt; `IteratorProtocol` and `OutputStream`, and I think both of those<br>&gt;&gt; should be reference-only.<br>&gt;&gt; <br>&gt;&gt; (On the other hand, it might make sense to be able to mark a struct<br>&gt;&gt; or enum as &quot;this is actually a reference type&quot;. For instance, if you<br>&gt;&gt; import libc, UnsafeMutablePointer&lt;FILE&gt; is essentially a reference<br>&gt;&gt; type. But on the gripping hand, you *could*, and perhaps should,<br>&gt;&gt; just wrap it in a class, either through importer magic or a<br>&gt;&gt; manually-created type. That would permit you to conform it to<br>&gt;&gt; reference-typed mutating protocols.))<br>&gt;<br>&gt; This is a good example of why the semantics aren’t so simple.  <br>&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; * There *are* some distinctions, particularly in pattern matching, but protocols can&#39;t model them anyway. Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br>&gt;&gt; <br>&gt;&gt;    protocol OptionalProtocol { <br>&gt;&gt;        associatedtype W<br>&gt;&gt;        static var none: Self { get } <br>&gt;&gt;        static func some(value: W) -&gt; Self <br>&gt;&gt;    } <br>&gt;&gt;    extension Optional: OptionalProtocol {<br>&gt;&gt;        typealias W = Wrapped<br>&gt;&gt;    }<br>&gt;<br>&gt; I think there was discussion at some point about introducing enum case<br>&gt; requirements into protocols.  But that is mostly tangential to this<br>&gt; discussion.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Rename `AnyObject` to `AnyClass` and drop current `AnyClass`</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 22, 2016, at 1:23 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri May 20 2016, Matthew Johnson &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On May 20, 2016, at 7:40 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The Any-class requirement could replace the current `AnyObject`<br>&gt;&gt;&gt;&gt; protocol with a typealias like this: `typealias AnyObject =<br>&gt;&gt;&gt;&gt; Any&lt;class&gt;`<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Assume Swift would introduce Any-struct and Any-enum requirement<br>&gt;&gt;&gt;&gt; one day. How would one name a typealias for these, where `AnyClass`<br>&gt;&gt;&gt;&gt; means `AnyObject.Type`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest we drop the current `AnyClass` and rename `AnyObject` to<br>&gt;&gt;&gt;&gt; `AnyClass`. If one would need the old `AnyClass` behavior it will<br>&gt;&gt;&gt;&gt; become `AnyClass.Type`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose that we deprecate `AnyObject` in favor of `Any&lt;class&gt;`. No<br>&gt;&gt;&gt; typealias, just directly using `Any&lt;&gt;`. We would also deprecate<br>&gt;&gt;&gt; `AnyClass` in favor of `Any&lt;class&gt;.Type`. (Presumably we would do<br>&gt;&gt;&gt; this by providing `AnyObject` and `AnyClass` typealiases in Swift 3,<br>&gt;&gt;&gt; but marking them as deprecated.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this approach because it exposes people to `Any&lt;&gt;` and more<br>&gt;&gt;&gt; quickly gets them to see how it&#39;s connected to a protocol<br>&gt;&gt;&gt; declaration&#39;s conformance list. They might then guess that `Any&lt;&gt;`<br>&gt;&gt;&gt; has other capabilities from that list, like the ability to handle<br>&gt;&gt;&gt; multiple protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the future we could have typealiases like this, which are more clear:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `typealias AnyClass = Any&lt;class&gt;`<br>&gt;&gt;&gt;&gt; `typealias AnyStruct = Any&lt;struct&gt;`<br>&gt;&gt;&gt;&gt; `typealias AnyEnum = Any&lt;enum&gt;`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Even in the long term, I don&#39;t see any good reason to support<br>&gt;&gt;&gt; `Any&lt;struct&gt;` vs. `Any&lt;enum&gt;`. There is no semantic distinction*<br>&gt;&gt;&gt; between a struct and an enum; you can always implement something<br>&gt;&gt;&gt; enum-y using a struct with a mode field, or something struct-y using<br>&gt;&gt;&gt; an enum with associated values. `Bool`, for instance, was once an<br>&gt;&gt;&gt; enum and was changed to a struct for implementation reasons; this<br>&gt;&gt;&gt; change made no difference to how it was used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, there *is* a semantic distinction between struct/enum and<br>&gt;&gt;&gt; class—one is a value type, the other is a reference type. To support<br>&gt;&gt;&gt; that distinction, it might make sense to support an `Any&lt;value&gt;` or<br>&gt;&gt;&gt; `Any&lt;!class&gt;` syntax. Again, I would prefer to use the raw `Any&lt;&gt;`<br>&gt;&gt;&gt; syntax, though, not a typealias.<br>&gt;&gt; <br>&gt;&gt; You can implement reference types with value semantics and value types<br>&gt;&gt; with reference semantics.  Until the compiler can verify value<br>&gt;&gt; semantics I am not sure there is a benefit to `any&lt;value&gt;`.  The<br>&gt;&gt; semantic distinction is what is important.  There has been discussion<br>&gt;&gt; about strengthening the “value type == value semantics” and “reference<br>&gt;&gt; type == reference semantics” relations but that hasn’t yet moved<br>&gt;&gt; beyond talk.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (I&#39;ve read the arguments about pure vs. non-pure value type<br>&gt;&gt;&gt; conformances and I&#39;m not convinced. It is always possible to<br>&gt;&gt;&gt; nominally &quot;conform&quot; to a protocol in a way that actually undermines<br>&gt;&gt;&gt; its guarantees; for example, you could implement<br>&gt;&gt;&gt; `RangeReplaceableCollection.remove(at:)` as a no-op. The compiler<br>&gt;&gt;&gt; cannot reject all invalid conformances; it can only reject ones<br>&gt;&gt;&gt; which it can trivially show are invalid, because for instance they<br>&gt;&gt;&gt; do not even attempt to provide a required method. Similarly, the<br>&gt;&gt;&gt; compiler may not be able to prove you are providing value semantics,<br>&gt;&gt;&gt; but it *can* reject conformances of reference types to a protocol<br>&gt;&gt;&gt; requiring value semantics, since those cannot possibly be valid<br>&gt;&gt;&gt; conformances.<br>&gt;&gt; <br>&gt;&gt; Immutable reference types actually *can* provide valid value semantics<br>&gt;&gt; (at least as long as as they can provide their own implementation of<br>&gt;&gt; `==` which I believe Dave A is arguing against).<br>&gt; <br>&gt; I am not making a strong argument against that, though it might be<br>&gt; reasonable.  I am mostly arguing in favor of a default definition of ==<br>&gt; for all reference types that is equivalent to ===.<br></p><p>Sorry I misunderstood.  To make sure I understand clearly: you’re not arguing against reference types with value semantics, just that we should allow reference semantics to be assumed unless custom equality is implemented.  Is that correct?  <br></p><p>&gt; <br>&gt;&gt; There is a big difference between semantics that the compiler *could*<br>&gt;&gt; but *does not yet* verify and semantics that simply cannot be<br>&gt;&gt; verified.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Incidentally, I am not convinced that it *ever* makes sense to have<br>&gt;&gt;&gt; a mutating protocol which does not specify either value or reference<br>&gt;&gt;&gt; semantics.<br>&gt;&gt;&gt; The only intentional Stdlib examples I&#39;m aware of are<br>&gt;&gt;&gt; `IteratorProtocol` and `OutputStream`, and I think both of those<br>&gt;&gt;&gt; should be reference-only.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (On the other hand, it might make sense to be able to mark a struct<br>&gt;&gt;&gt; or enum as &quot;this is actually a reference type&quot;. For instance, if you<br>&gt;&gt;&gt; import libc, UnsafeMutablePointer&lt;FILE&gt; is essentially a reference<br>&gt;&gt;&gt; type. But on the gripping hand, you *could*, and perhaps should,<br>&gt;&gt;&gt; just wrap it in a class, either through importer magic or a<br>&gt;&gt;&gt; manually-created type. That would permit you to conform it to<br>&gt;&gt;&gt; reference-typed mutating protocols.))<br>&gt;&gt; <br>&gt;&gt; This is a good example of why the semantics aren’t so simple.  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * There *are* some distinctions, particularly in pattern matching, but protocols can&#39;t model them anyway. Incidentally, it is not possible to satisfy static property/method requirements with cases, but it probably should be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   protocol OptionalProtocol { <br>&gt;&gt;&gt;       associatedtype W<br>&gt;&gt;&gt;       static var none: Self { get } <br>&gt;&gt;&gt;       static func some(value: W) -&gt; Self <br>&gt;&gt;&gt;   } <br>&gt;&gt;&gt;   extension Optional: OptionalProtocol {<br>&gt;&gt;&gt;       typealias W = Wrapped<br>&gt;&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; I think there was discussion at some point about introducing enum case<br>&gt;&gt; requirements into protocols.  But that is mostly tangential to this<br>&gt;&gt; discussion.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/70a6c534/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
