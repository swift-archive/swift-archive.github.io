<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68d21c811b4f037d9cbd43013319f9b4?s=50"></div><header><strong>More fine tuning optimization to swift compiler</strong> from <string>Muse M</string> &lt;james.lei65 at gmail.com&gt;<p>August  8, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m not sure if this is the right channel to discuss on optimization switch<br></p><p>We are aware the 3 options:<br>-O<br>-Ofast<br>-Ounchecked<br></p><p>As we can see, we rarely use -Ounchecked for safety reason and there aren&#39;t<br>much info on what are the tradeoff. if there are performance reason that<br>will need to improve loop or maths optimization or allow developers to<br>fine-tuning in various area, we could add more options to compiler.<br></p><p>-OLoop (Optimize loop with safety)<br>-OFunc (Optimize function calls)<br>and so on.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160808/9353c990/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>More fine tuning optimization to swift compiler</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August  9, 2016 at 08:00:00am</p></header><div class="content"><p>My understanding is that -Ounchecked removes integer overflow checks and array bound checks.<br></p><p>What type of optimizations would -Oloop and -Ofunction do?<br></p><p>Félix<br></p><p>&gt; Le 7 août 2016 à 19:27:56, Muse M via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;m not sure if this is the right channel to discuss on optimization switch<br>&gt; <br>&gt; We are aware the 3 options:<br>&gt; -O<br>&gt; -Ofast<br>&gt; -Ounchecked<br>&gt; <br>&gt; As we can see, we rarely use -Ounchecked for safety reason and there aren&#39;t much info on what are the tradeoff. if there are performance reason that will need to improve loop or maths optimization or allow developers to fine-tuning in various area, we could add more options to compiler.<br>&gt; <br>&gt; -OLoop (Optimize loop with safety)<br>&gt; -OFunc (Optimize function calls)<br>&gt; and so on.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/12cf6e70/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68d21c811b4f037d9cbd43013319f9b4?s=50"></div><header><strong>More fine tuning optimization to swift compiler</strong> from <string>Muse M</string> &lt;james.lei65 at gmail.com&gt;<p>August 10, 2016 at 12:00:00am</p></header><div class="content"><p>-Oloop<br>Correction: it should be similar to GCC -funroll-loops<br>On other option if we have 1,000,000&#39;s loops or array, it&#39;s bad for one<br>core to handle 100% of the calculations and other cores are idle, the idea<br>could be optimize loops to share/split workload across all available CPU<br>cores.<br></p><p>-Ofunction<br>Is a dummy example for other example.<br></p><p>On Tue, Aug 9, 2016 at 11:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; My understanding is that -Ounchecked removes integer overflow checks and<br>&gt; array bound checks.<br>&gt;<br>&gt; What type of optimizations would -Oloop and -Ofunction do?<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 7 août 2016 à 19:27:56, Muse M via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I&#39;m not sure if this is the right channel to discuss on optimization switch<br>&gt;<br>&gt; We are aware the 3 options:<br>&gt; -O<br>&gt; -Ofast<br>&gt; -Ounchecked<br>&gt;<br>&gt; As we can see, we rarely use -Ounchecked for safety reason and there<br>&gt; aren&#39;t much info on what are the tradeoff. if there are performance reason<br>&gt; that will need to improve loop or maths optimization or allow developers to<br>&gt; fine-tuning in various area, we could add more options to compiler.<br>&gt;<br>&gt; -OLoop (Optimize loop with safety)<br>&gt; -OFunc (Optimize function calls)<br>&gt; and so on.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160810/ac796255/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>More fine tuning optimization to swift compiler</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>August  9, 2016 at 05:00:00pm</p></header><div class="content"><p>I believe the -O is already able to loop unroll, but now C-Style loop is<br>gone, and maybe will be more &quot;difficult&quot; to compiler make this<br>optimization, except of course using range literals.<br></p><p>Em ter, 9 de ago de 2016 às 13:10, Muse M via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; -Oloop<br>&gt; Correction: it should be similar to GCC -funroll-loops<br>&gt; On other option if we have 1,000,000&#39;s loops or array, it&#39;s bad for one<br>&gt; core to handle 100% of the calculations and other cores are idle, the idea<br>&gt; could be optimize loops to share/split workload across all available CPU<br>&gt; cores.<br>&gt;<br>&gt; -Ofunction<br>&gt; Is a dummy example for other example.<br>&gt;<br>&gt; On Tue, Aug 9, 2016 at 11:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt;<br>&gt;&gt; My understanding is that -Ounchecked removes integer overflow checks and<br>&gt;&gt; array bound checks.<br>&gt;&gt;<br>&gt;&gt; What type of optimizations would -Oloop and -Ofunction do?<br>&gt;&gt;<br>&gt;&gt; Félix<br>&gt;&gt;<br>&gt;&gt; Le 7 août 2016 à 19:27:56, Muse M via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure if this is the right channel to discuss on optimization<br>&gt;&gt; switch<br>&gt;&gt;<br>&gt;&gt; We are aware the 3 options:<br>&gt;&gt; -O<br>&gt;&gt; -Ofast<br>&gt;&gt; -Ounchecked<br>&gt;&gt;<br>&gt;&gt; As we can see, we rarely use -Ounchecked for safety reason and there<br>&gt;&gt; aren&#39;t much info on what are the tradeoff. if there are performance reason<br>&gt;&gt; that will need to improve loop or maths optimization or allow developers to<br>&gt;&gt; fine-tuning in various area, we could add more options to compiler.<br>&gt;&gt;<br>&gt;&gt; -OLoop (Optimize loop with safety)<br>&gt;&gt; -OFunc (Optimize function calls)<br>&gt;&gt; and so on.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/1b9f7f7f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f8978dbb959b069613e2d027420615f?s=50"></div><header><strong>More fine tuning optimization to swift compiler</strong> from <string>Erik Eckstein</string> &lt;eeckstein at apple.com&gt;<p>August  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 10:19 AM, Wallacy via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe the -O is already able to loop unroll<br></p><p>correct<br></p><p>&gt; , but now C-Style loop is gone, and maybe will be more &quot;difficult&quot; to compiler make this optimization, except of course using range literals.<br>&gt; <br>&gt; Em ter, 9 de ago de 2016 às 13:10, Muse M via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt; -Oloop<br>&gt; Correction: it should be similar to GCC -funroll-loops<br>&gt; On other option if we have 1,000,000&#39;s loops or array, it&#39;s bad for one core to handle 100% of the calculations and other cores are idle, the idea could be optimize loops to share/split workload across all available CPU cores. <br>&gt; <br>&gt; -Ofunction<br>&gt; Is a dummy example for other example.<br>&gt; <br>&gt; On Tue, Aug 9, 2016 at 11:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt; My understanding is that -Ounchecked removes integer overflow checks and array bound checks.<br>&gt; <br>&gt; What type of optimizations would -Oloop and -Ofunction do?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 7 août 2016 à 19:27:56, Muse M via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure if this is the right channel to discuss on optimization switch<br>&gt;&gt; <br>&gt;&gt; We are aware the 3 options:<br>&gt;&gt; -O<br>&gt;&gt; -Ofast<br>&gt;&gt; -Ounchecked<br></p><p>We have -O and -Ounchecked.<br>-Ofast is obsolete.<br></p><p><br>&gt;&gt; <br>&gt;&gt; As we can see, we rarely use -Ounchecked for safety reason and there aren&#39;t much info on what are the tradeoff. if there are performance reason that will need to improve loop or maths optimization or allow developers to fine-tuning in various area, we could add more options to compiler.<br>&gt;&gt; <br>&gt;&gt; -OLoop (Optimize loop with safety)<br>&gt;&gt; -OFunc (Optimize function calls)<br>&gt;&gt; and so on.<br>&gt;&gt; <br></p><p>I think you are asking for a way to fine tune optimizations for a specific purpose.<br>Fine-tuning optimizations is mostly intended for small parts of the code, like a function or even a loop.<br>But optimization switches apply to the whole module (assuming whole-module-optimization). So an optimization switch is not really a good tool for fine tuning.<br></p><p>In general I believe there must be a good justification for adding an optimization switch/mode. E.g. it must be well understandable what it does and what&#39;s the difference to existing optimization modes.<br></p><p>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/5b145af2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>More fine tuning optimization to swift compiler</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August  9, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Aug 9, 2016, at 10:46 AM, Erik Eckstein via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 9, 2016, at 10:19 AM, Wallacy via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe the -O is already able to loop unroll<br>&gt; <br>&gt; correct<br>&gt; <br>&gt;&gt; , but now C-Style loop is gone, and maybe will be more &quot;difficult&quot; to compiler make this optimization, except of course using range literals.<br>&gt;&gt; <br>&gt;&gt; Em ter, 9 de ago de 2016 às 13:10, Muse M via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; escreveu:<br>&gt;&gt; -Oloop<br>&gt;&gt; Correction: it should be similar to GCC -funroll-loops<br>&gt;&gt; On other option if we have 1,000,000&#39;s loops or array, it&#39;s bad for one core to handle 100% of the calculations and other cores are idle, the idea could be optimize loops to share/split workload across all available CPU cores. <br>&gt;&gt; <br>&gt;&gt; -Ofunction<br>&gt;&gt; Is a dummy example for other example.<br>&gt;&gt; <br>&gt;&gt; On Tue, Aug 9, 2016 at 11:21 PM, Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt; wrote:<br>&gt;&gt; My understanding is that -Ounchecked removes integer overflow checks and array bound checks.<br>&gt;&gt; <br>&gt;&gt; What type of optimizations would -Oloop and -Ofunction do?<br>&gt;&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 7 août 2016 à 19:27:56, Muse M via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure if this is the right channel to discuss on optimization switch<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We are aware the 3 options:<br>&gt;&gt;&gt; -O<br>&gt;&gt;&gt; -Ofast<br>&gt;&gt;&gt; -Ounchecked<br>&gt; <br>&gt; We have -O and -Ounchecked.<br>&gt; -Ofast is obsolete.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As we can see, we rarely use -Ounchecked for safety reason and there aren&#39;t much info on what are the tradeoff. if there are performance reason that will need to improve loop or maths optimization or allow developers to fine-tuning in various area, we could add more options to compiler.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -OLoop (Optimize loop with safety)<br>&gt;&gt;&gt; -OFunc (Optimize function calls)<br>&gt;&gt;&gt; and so on.<br>&gt;&gt;&gt; <br>&gt; <br>&gt; I think you are asking for a way to fine tune optimizations for a specific purpose.<br>&gt; Fine-tuning optimizations is mostly intended for small parts of the code, like a function or even a loop.<br>&gt; But optimization switches apply to the whole module (assuming whole-module-optimization). So an optimization switch is not really a good tool for fine tuning.<br>&gt; <br>&gt; In general I believe there must be a good justification for adding an optimization switch/mode. E.g. it must be well understandable what it does and what&#39;s the difference to existing optimization modes.<br></p><p>Right.  Global optimization switches are generally a bad move; it&#39;s almost always better to have something more locally-scoped, like perhaps an OpenMP-like annotation on a loop encouraging it to be unrolled or parallelized.<br></p><p>John.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160809/da951700/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
