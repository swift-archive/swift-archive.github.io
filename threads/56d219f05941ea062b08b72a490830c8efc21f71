<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[SIL] Deconstructing partial_apply</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September  6, 2016 at 03:00:00pm</p></header><div class="content"><p>Last week, I put some effort into trying to reduce the power of SIL&#39;s infamous partial_apply instruction. The instruction was intended to make representation and optimization of closures easy by avoiding concretization of the closure type and layout, but in practice, the complexity of dealing with ARC and the differing ownership needs for closure objects vs normal function arguments makes the abstraction unwieldy to understand and work with. As we look into adding new features that rely on static analysis and optimization of SIL, such as the borrow model, partial_apply is going to be a continuing drag on development. I have a work-in-progress branch to make SILGen generate at least some closures by explicit box allocation and initialization:<br></p><p>https://github.com/apple/swift/pull/4565 &lt;https://github.com/apple/swift/pull/4565&gt;<br></p><p>My idea is to get to a point where all partial_apply does is bind the thin invocation function to its context object to build the &quot;thick&quot; function value. I&#39;m using the existing infrastructure for @box types in SIL to represent a closure allocation, using tuples to aggregate multiple captures. This is enough to get a start on the project, but there a few limitations and inefficiencies to this approach, and I wanted some feedback on how to tackle these problems:<br></p><p>(A) Aggregating contexts as tuples imposes some unnecessary abstraction limitations on capture layout, and would potentially force otherwise unnecessary metadata instantiation for tuple types. Tuples need to tolerate potentially being accessed as fully generic (T, U, V) types (and possibly variadic (T...) types, should we add variadics in the future), which limits the layout optimizations we can potentially do with them. Closure contexts don&#39;t need to support generic abstraction, since the details of layout only need to be known by the closure&#39;s invocation function and its enclosing scope, so we should have full freedom for layout optimization like we have with structs and classes.<br>(B) Boxed tuples can&#39;t represent captured type information for forming closures in generic contexts. Closure contexts need to be able to provide type metadata to the invocation function for execution of generic code and layout of the context object itself.<br></p><p>One idea I&#39;m entertaining is, instead of relying on structural box types, to introduce &quot;nominal&quot; box layouts, which can give an identity to a particular closure layout, thereby addressing problem (A), and can potentially carry a generic signature to represent captured type metadata, addressing (B). For example, in code like this:<br></p><p>	var escaper: () -&gt; ()<br>	func foo(x: Bool, y: Bool) {<br>	  escaper = { _ = x; _ = y }<br>	}<br></p><p>We&#39;d emit something like this SIL:<br></p><p>	// Closure layout for closure inside foo<br>	sil_box_layout foo.1 {<br>	  let x: Bool<br>	  let y: Bool<br>	}<br></p><p>	sil @foo : $(Bool, Bool) -&gt; () {<br>	entry(%x : $Bool, %y : $Bool):<br>	  // Allocate a box with the layout for this closure<br>	  %context = alloc_box foo.1<br>	  // Initialize the members<br>	  %context.x = project_box %context, #x<br>	  store %x to %context.x<br>	  %context.y = project_box %context, #y<br>	  store %y to %closure.y<br>	  // Bind to the invocation function<br>	  %closure = partial_apply @foo.1(%closure)<br>	  assign %closure to @escaper<br>	  return<br>	}<br></p><p>	// Invocation function for the closure<br>	sil @foo.1 : $(@box foo.1) -&gt; () {<br>	entry(%context : $@box foo.1):<br>	  // Load captured locals out of context<br>	  %context.x = project_box %context, #x<br>	  %x = load %context.x<br>	  %context.y = project_box %context, #y<br>	  %y = load %context.y<br>	  // do nothing<br>	  release %context<br>	  return<br>	}<br></p><p>The unique box layout gives us license to pack those bools into a single word, or a tagged pointer, or do other fancy layout optimizations. For generic closures, a box layout could be generic, so that something like this:<br></p><p>	func bar&lt;T&gt;(x: T, y: T) {<br>	  escaper = { _ = x; _ = y }<br>	}<br></p><p>lowers to:<br></p><p>	// Closure layout for closure inside bar, which captures type info<br>	sil_closure_layout bar.1&lt;A&gt; {<br>	  let x: T<br>	  let y: T<br>	}<br></p><p>	sil @bar : $&lt;B&gt; (B, B) -&gt; () {<br>	entry(%x : $*B, %y : $*B):<br>	  // Allocate a box with the layout for this closure, bound to this generic context<br>	  %context = alloc_box bar.1&lt;B&gt;<br>	  // Initialize the members<br>	  %context.x = project_box %context, #x<br>	  copy_addr %x to [init] %context.x<br>	  %context.y = project_box %context, #y<br>	  copy_addr %y to [init] %closure.y<br>	  // Bind to the invocation function<br>	  %closure = partial_apply @bar.1&lt;B&gt;(%closure)<br>	  assign %closure to @escaper<br>	  return<br>	}<br>  <br>	sil @bar.1 : $&lt;C&gt; (@box bar.1&lt;C&gt;) { ... }<br></p><p>As a hack, we can guarantee in the polymorphic convention that a generic box context parameter acts as a type metadata source for its generic parameters, similar to what we do with &#39;self&#39; in class and protocol method signatures. Having an opening instruction might be a better long-term solution, though, and could make generic boxes also useful for representing copy-on-write existentials and GADT enum payloads. This is just a rough sketch of an idea; I&#39;m open to other approaches. We&#39;ve talked about tracking the SIL-level layout of structs, enums, and classes in SIL separate from the Swift level, so representing box layouts concretely feels consistent with that potential direction. OTOH, at this point, we&#39;d be constructing a lot of SIL data structures for every closure.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160906/56d21f71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[SIL] Deconstructing partial_apply</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>September  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 6, 2016, at 3:36 PM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; Last week, I put some effort into trying to reduce the power of SIL&#39;s infamous partial_apply instruction. The instruction was intended to make representation and optimization of closures easy by avoiding concretization of the closure type and layout, but in practice, the complexity of dealing with ARC and the differing ownership needs for closure objects vs normal function arguments makes the abstraction unwieldy to understand and work with. As we look into adding new features that rely on static analysis and optimization of SIL, such as the borrow model, partial_apply is going to be a continuing drag on development. I have a work-in-progress branch to make SILGen generate at least some closures by explicit box allocation and initialization:<br>&gt; <br>&gt; https://github.com/apple/swift/pull/4565 &lt;https://github.com/apple/swift/pull/4565&gt;<br>&gt; <br>&gt; My idea is to get to a point where all partial_apply does is bind the thin invocation function to its context object to build the &quot;thick&quot; function value.<br></p><p>Hooray!<br></p><p>&gt; I&#39;m using the existing infrastructure for @box types in SIL to represent a closure allocation, using tuples to aggregate multiple captures. This is enough to get a start on the project, but there a few limitations and inefficiencies to this approach, and I wanted some feedback on how to tackle these problems:<br>&gt; <br>&gt; (A) Aggregating contexts as tuples imposes some unnecessary abstraction limitations on capture layout, and would potentially force otherwise unnecessary metadata instantiation for tuple types. Tuples need to tolerate potentially being accessed as fully generic (T, U, V) types (and possibly variadic (T...) types, should we add variadics in the future), which limits the layout optimizations we can potentially do with them. Closure contexts don&#39;t need to support generic abstraction, since the details of layout only need to be known by the closure&#39;s invocation function and its enclosing scope, so we should have full freedom for layout optimization like we have with structs and classes.<br>&gt; (B) Boxed tuples can&#39;t represent captured type information for forming closures in generic contexts. Closure contexts need to be able to provide type metadata to the invocation function for execution of generic code and layout of the context object itself.<br>&gt; <br>&gt; One idea I&#39;m entertaining is, instead of relying on structural box types, to introduce &quot;nominal&quot; box layouts, which can give an identity to a particular closure layout, thereby addressing problem (A), and can potentially carry a generic signature to represent captured type metadata, addressing (B). For example, in code like this:<br></p><p>This makes a lot of sense to me.<br></p><p>One goal here should be to allow the box layout to be easily cloned and modified, e.g. to promote a capture to a value capture, or to eliminate a capture that&#39;s provably unused.<br></p><p>&gt; <br>&gt; 	var escaper: () -&gt; ()<br>&gt; 	func foo(x: Bool, y: Bool) {<br>&gt; 	  escaper = { _ = x; _ = y }<br>&gt; 	}<br>&gt; <br>&gt; We&#39;d emit something like this SIL:<br>&gt; <br>&gt; 	// Closure layout for closure inside foo<br>&gt; 	sil_box_layout foo.1 {<br>&gt; 	  let x: Bool<br>&gt; 	  let y: Bool<br>&gt; 	}<br>&gt; <br>&gt; 	sil @foo : $(Bool, Bool) -&gt; () {<br>&gt; 	entry(%x : $Bool, %y : $Bool):<br>&gt; 	  // Allocate a box with the layout for this closure<br>&gt; 	  %context = alloc_box foo.1<br>&gt; 	  // Initialize the members<br>&gt; 	  %context.x = project_box %context, #x<br>&gt; 	  store %x to %context.x<br>&gt; 	  %context.y = project_box %context, #y<br>&gt; 	  store %y to %closure.y<br>&gt; 	  // Bind to the invocation function<br>&gt; 	  %closure = partial_apply @foo.1(%closure)<br>&gt; 	  assign %closure to @escaper<br>&gt; 	  return<br>&gt; 	}<br>&gt; <br>&gt; 	// Invocation function for the closure<br>&gt; 	sil @foo.1 : $(@box foo.1) -&gt; () {<br>&gt; 	entry(%context : $@box foo.1):<br>&gt; 	  // Load captured locals out of context<br>&gt; 	  %context.x = project_box %context, #x<br>&gt; 	  %x = load %context.x<br>&gt; 	  %context.y = project_box %context, #y<br>&gt; 	  %y = load %context.y<br>&gt; 	  // do nothing<br>&gt; 	  release %context<br>&gt; 	  return<br>&gt; 	}<br>&gt; <br>&gt; The unique box layout gives us license to pack those bools into a single word, or a tagged pointer, or do other fancy layout optimizations. For generic closures, a box layout could be generic, so that something like this:<br>&gt; <br>&gt; 	func bar&lt;T&gt;(x: T, y: T) {<br>&gt; 	  escaper = { _ = x; _ = y }<br>&gt; 	}<br>&gt; <br>&gt; lowers to:<br>&gt; <br>&gt; 	// Closure layout for closure inside bar, which captures type info<br>&gt; 	sil_closure_layout bar.1&lt;A&gt; {<br>&gt; 	  let x: T<br>&gt; 	  let y: T<br>&gt; 	}<br>&gt; <br>&gt; 	sil @bar : $&lt;B&gt; (B, B) -&gt; () {<br>&gt; 	entry(%x : $*B, %y : $*B):<br>&gt; 	  // Allocate a box with the layout for this closure, bound to this generic context<br>&gt; 	  %context = alloc_box bar.1&lt;B&gt;<br>&gt; 	  // Initialize the members<br>&gt; 	  %context.x = project_box %context, #x<br>&gt; 	  copy_addr %x to [init] %context.x<br>&gt; 	  %context.y = project_box %context, #y<br>&gt; 	  copy_addr %y to [init] %closure.y<br>&gt; 	  // Bind to the invocation function<br>&gt; 	  %closure = partial_apply @bar.1&lt;B&gt;(%closure)<br>&gt; 	  assign %closure to @escaper<br>&gt; 	  return<br>&gt; 	}<br>&gt;   <br>&gt; 	sil @bar.1 : $&lt;C&gt; (@box bar.1&lt;C&gt;) { ... }<br>&gt; <br>&gt; As a hack, we can guarantee in the polymorphic convention that a generic box context parameter acts as a type metadata source for its generic parameters, similar to what we do with &#39;self&#39; in class and protocol method signatures. Having an opening instruction might be a better long-term solution, though, and could make generic boxes also useful for representing copy-on-write existentials and GADT enum payloads.<br></p><p>I suspect we&#39;d want both.  We can require the generic signature of the context to match the applied function, just to make it easy.<br></p><p>John.<br></p><p>&gt; This is just a rough sketch of an idea; I&#39;m open to other approaches. We&#39;ve talked about tracking the SIL-level layout of structs, enums, and classes in SIL separate from the Swift level, so representing box layouts concretely feels consistent with that potential direction. OTOH, at this point, we&#39;d be constructing a lot of SIL data structures for every closure.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160907/1b599bdd/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
