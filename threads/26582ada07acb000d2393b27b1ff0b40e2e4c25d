<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/23bb59b802aac41afdf8ffffae1040d5?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Alex Martini</string> &lt;amartini at apple.com&gt;<p>March 16, 2016 at 05:00:00pm</p></header><div class="content"><p>To help keep proposals moving forward, the Swift core team has set aside some time specifically for design discussions of upcoming proposals.  Below are some rough notes from the yesterday&#39;s discussion.<br></p><p>These are informal comments, intended to guide the proposals in directions that draw constructive feedback. You are welcome to ignore the feedback, agree with it, or disagree with it.  As always, the formal decision doesn&#39;t happen until after the review period ends.<br></p><p>SE-0047 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0047&gt;<br>This is about switching the polarity of @warn_unused_result and renaming it to @discardable as something on the return type.<br></p><p>Is there a subtype conversion? Is Void -&gt; Int a subtype or supertype of Void -&gt; Void? No, it’s not; we just have a special rule for closures.<br></p><p>If we put this in the type system, we would want it to be a function attribute rather than a declaration attribute. It’s not obvious why it’s a bad idea to have this in the type system... It’s a little bit outside the bounds of what the type system normally does; it’s not that important of a semantic property.<br></p><p>It looks like the proposal has an error in the second to last line before “Mutating Variants” – it should either be a hard error or nothing. Also the case below:<br></p><p>let x = f<br>x()<br>c = x()<br>In the more general case, if x is a closure...<br></p><p>How many cases are there where you want to mark the result as discardable so you don’t have to write _ = foo() to explicitly silence the warning about an unused result?<br></p><p>We almost certainly don’t want to allow overloading based on this. Does the propagation even work? If you have a compose operator that takes T -&gt; U and U -&gt; V and try to pass it a T -&gt; discardable U you won’t get a discardable V unless we make it a full qualifier in the type system.<br></p><p>Ok... if we don’t make it part of the function type, where would we want the attribute to go? This is similar to how we place inout. It would be similar to how we place @autoclosure but that attribute is currently not quite right.<br></p><p>It would be consistent to put it on the function declaration. There are other places though where we might want attributes on the function type that are understood to not effect the actual function type, such as some kind of ownership rules.<br></p><p>func f () -&gt; @discardable Int  // we&#39;re saying this is valid<br>let x: () -&gt; @discardable Int  // but we wouldn&#39;t let you write this<br></p><p>func g() -&gt; @convention(block) () -&gt; () {...} // we wouldn&#39;t allow this either<br>In that last case, you can put attributes on types. We like how putting the @discardable on the type because of how it reads, but it’s not on the type.<br></p><p>Counterpoint: It’s actually more semantically part of the function. You don’t have a “discardable integer”, you have a function whose result is discardable.<br></p><p><br></p><p>SE-0042 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0042&gt;<br>Right now if you access an instance method on a type, you get this curried thing that accepts “self” and then the members. It’s not useful for the standard library because they want flattened functions. And for mutable methods, because of how the in-out duration lasts, we end up with a miscompile that scribbles over random memory.<br></p><p>Looking to the future, we can get operators on the type. Then operators would have the same type in both cases.<br></p><p>We probably don’t need migration. If you wrote #selector(foo as Bar) before, the Bar part will change. But that’s not very common and #selector is still pretty new.<br></p><p><br></p><p>SE-0043 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0043&gt;<br>This seems like a simple generalization of our rules. People coming from the ML family would just expect this to work. It’s a resonable expectation.<br></p><p><br>SE-0048 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0048&gt;<br>This is straightforward and 95% implemented. The contentious point is that it starts simple: you can’t add constraints to the type alias.<br></p><p>We want to avoid type-based metaprogramming.<br></p><p>Unclear if this would work:<br></p><p>typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>It need to infer that T must be hashable. Maybe it’s only 85% implemented.<br></p><p><br>SE-0049 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0049&gt;<br>In short, @noescape and @autoclosure are attributes on the parameter. We got away with it before, but now that we’re requiring you to manually uncurry, you can’t write things that you used to be able to write. None of this makes sense; we should only accept these attributes in the type position.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160316/2658c25d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 23, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 5:27 PM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To help keep proposals moving forward, the Swift core team has set aside some time specifically for design discussions of upcoming proposals.  Below are some rough notes from the yesterday&#39;s discussion.<br>&gt; <br>&gt; These are informal comments, intended to guide the proposals in directions that draw constructive feedback. You are welcome to ignore the feedback, agree with it, or disagree with it.  As always, the formal decision doesn&#39;t happen until after the review period ends.<br>&gt; <br>&gt; SE-0048 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0048&gt;<br>&gt; This is straightforward and 95% implemented. The contentious point is that it starts simple: you can’t add constraints to the type alias.<br>&gt; <br>&gt; We want to avoid type-based metaprogramming.<br>&gt; <br>&gt; Unclear if this would work:<br>&gt; <br>&gt; typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>&gt; It need to infer that T must be hashable. Maybe it’s only 85% implemented.<br>&gt; <br>&gt; <br></p><p>Clarification here: the example is<br></p><p>typealias DictionaryToStrings&lt;T&gt; = Dictionary&lt;T, String&gt;<br></p><p>Either we infer T to require Hashable, or we call this ill-formed and require the user to write<br></p><p>typealias DictionaryToStrings&lt;T: Hashable&gt; = Dictionary&lt;T, String&gt;<br></p><p><br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/6870942d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>I actually do prefer the explicit variant without type inference as I find it much clearer to see what the typealias requires.<br></p><p>-Thorsten <br></p><p>&gt; Am 23.03.2016 um 17:38 schrieb Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Clarification here: the example is<br>&gt; <br>&gt; typealias DictionaryToStrings&lt;T&gt; = Dictionary&lt;T, String&gt;<br>&gt; <br>&gt; Either we infer T to require Hashable, or we call this ill-formed and require the user to write<br>&gt; <br>&gt; typealias DictionaryToStrings&lt;T: Hashable&gt; = Dictionary&lt;T, String&gt;<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/3deb7450/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 23, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 10:36 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I actually do prefer the explicit variant without type inference as I find it much clearer to see what the typealias requires.<br></p><p>As do I. Also, we don’t currently have any place in the language where we infer constraints from the *definition* of an entity.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 23.03.2016 um 17:38 schrieb Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Clarification here: the example is<br>&gt;&gt; <br>&gt;&gt; typealias DictionaryToStrings&lt;T&gt; = Dictionary&lt;T, String&gt;<br>&gt;&gt; <br>&gt;&gt; Either we infer T to require Hashable, or we call this ill-formed and require the user to write<br>&gt;&gt; <br>&gt;&gt; typealias DictionaryToStrings&lt;T: Hashable&gt; = Dictionary&lt;T, String&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/86356815/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>On Wed, Mar 23, 2016 at 10:42 AM Douglas Gregor via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 23, 2016, at 10:36 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; I actually do prefer the explicit variant without type inference as I find<br>&gt; it much clearer to see what the typealias requires.<br>&gt;<br>&gt;<br>&gt; As do I. Also, we don’t currently have any place in the language where we<br>&gt; infer constraints from the *definition* of an entity.<br>&gt;<br>&gt;<br>I strongly favor being explicit.<br></p><p>-Shawn<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/e801ed74/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 10:57 AM, Shawn Erickson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Wed, Mar 23, 2016 at 10:42 AM Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 10:36 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I actually do prefer the explicit variant without type inference as I find it much clearer to see what the typealias requires.<br>&gt; <br>&gt; As do I. Also, we don’t currently have any place in the language where we infer constraints from the *definition* of an entity.<br>&gt; <br>&gt; <br>&gt; I strongly favor being explicit.<br></p><p>Thanks, I agree, I modified the proposal to include that.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/3102372d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Notes from Swift core team 2016-03-15 design discussion</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>March 23, 2016 at 06:00:00pm</p></header><div class="content"><p>In the future, can you make each SE-**** into a link to the github page of the proposal?<br></p><p>Michael<br></p><p>&gt; On Mar 16, 2016, at 5:27 PM, Alex Martini via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To help keep proposals moving forward, the Swift core team has set aside some time specifically for design discussions of upcoming proposals.  Below are some rough notes from the yesterday&#39;s discussion.<br>&gt; <br>&gt; These are informal comments, intended to guide the proposals in directions that draw constructive feedback. You are welcome to ignore the feedback, agree with it, or disagree with it.  As always, the formal decision doesn&#39;t happen until after the review period ends.<br>&gt; <br>&gt; SE-0047 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0047&gt;<br>&gt; This is about switching the polarity of @warn_unused_result and renaming it to @discardable as something on the return type.<br>&gt; <br>&gt; Is there a subtype conversion? Is Void -&gt; Int a subtype or supertype of Void -&gt; Void? No, it’s not; we just have a special rule for closures.<br>&gt; <br>&gt; If we put this in the type system, we would want it to be a function attribute rather than a declaration attribute. It’s not obvious why it’s a bad idea to have this in the type system... It’s a little bit outside the bounds of what the type system normally does; it’s not that important of a semantic property.<br>&gt; <br>&gt; It looks like the proposal has an error in the second to last line before “Mutating Variants” – it should either be a hard error or nothing. Also the case below:<br>&gt; <br>&gt; let x = f<br>&gt; x()<br>&gt; c = x()<br>&gt; In the more general case, if x is a closure...<br>&gt; <br>&gt; How many cases are there where you want to mark the result as discardable so you don’t have to write _ = foo() to explicitly silence the warning about an unused result?<br>&gt; <br>&gt; We almost certainly don’t want to allow overloading based on this. Does the propagation even work? If you have a compose operator that takes T -&gt; U and U -&gt; V and try to pass it a T -&gt; discardable U you won’t get a discardable V unless we make it a full qualifier in the type system.<br>&gt; <br>&gt; Ok... if we don’t make it part of the function type, where would we want the attribute to go? This is similar to how we place inout. It would be similar to how we place @autoclosure but that attribute is currently not quite right.<br>&gt; <br>&gt; It would be consistent to put it on the function declaration. There are other places though where we might want attributes on the function type that are understood to not effect the actual function type, such as some kind of ownership rules.<br>&gt; <br>&gt; func f () -&gt; @discardable Int  // we&#39;re saying this is valid<br>&gt; let x: () -&gt; @discardable Int  // but we wouldn&#39;t let you write this<br>&gt; <br>&gt; func g() -&gt; @convention(block) () -&gt; () {...} // we wouldn&#39;t allow this either<br>&gt; In that last case, you can put attributes on types. We like how putting the @discardable on the type because of how it reads, but it’s not on the type.<br>&gt; <br>&gt; Counterpoint: It’s actually more semantically part of the function. You don’t have a “discardable integer”, you have a function whose result is discardable.<br>&gt; <br>&gt; <br>&gt; <br>&gt; SE-0042 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0042&gt;<br>&gt; Right now if you access an instance method on a type, you get this curried thing that accepts “self” and then the members. It’s not useful for the standard library because they want flattened functions. And for mutable methods, because of how the in-out duration lasts, we end up with a miscompile that scribbles over random memory.<br>&gt; <br>&gt; Looking to the future, we can get operators on the type. Then operators would have the same type in both cases.<br>&gt; <br>&gt; We probably don’t need migration. If you wrote #selector(foo as Bar) before, the Bar part will change. But that’s not very common and #selector is still pretty new.<br>&gt; <br>&gt; <br>&gt; <br>&gt; SE-0043 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0043&gt;<br>&gt; This seems like a simple generalization of our rules. People coming from the ML family would just expect this to work. It’s a resonable expectation.<br>&gt; <br>&gt; <br>&gt; SE-0048 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0048&gt;<br>&gt; This is straightforward and 95% implemented. The contentious point is that it starts simple: you can’t add constraints to the type alias.<br>&gt; <br>&gt; We want to avoid type-based metaprogramming.<br>&gt; <br>&gt; Unclear if this would work:<br>&gt; <br>&gt; typealias StringDictionary&lt;T&gt; = Dictionary&lt;String, T&gt;<br>&gt; It need to infer that T must be hashable. Maybe it’s only 85% implemented.<br>&gt; <br>&gt; <br>&gt; SE-0049 &lt;file:///Users/alexmartini/DevPubs%20Git%20Repositories/Swift%20Language%20Review/_build/html/LR_MeetingNotes/MeetingNotes-03-15-2016.html#se-0049&gt;<br>&gt; In short, @noescape and @autoclosure are attributes on the parameter. We got away with it before, but now that we’re requiring you to manually uncurry, you can’t write things that you used to be able to write. None of this makes sense; we should only accept these attributes in the type position.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/0cbf0ce5/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
