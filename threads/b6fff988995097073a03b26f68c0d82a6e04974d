<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8941ad1d64fca59301084a03cb75956c?s=50"></div><header><strong>Chaining struct-mutating funcs</strong> from <string>Fritz Anderson</string> &lt;fritza at manoverboard.org&gt;<p>August  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Swift 3 as of Xcode 8.0b4<br></p><p>TL;DR: I have a struct value type backed by a copy-on-write mutable buffer. You use it to perform arithmetic on the buffers. The most expressive way to do this efficiently is to chain the arithmetic operators so each mutates the same buffer. Swift does not like to chain mutating operators — it treats the result of each step as immutable, so you can’t continue the chain. I can’t argue; the syntax apparently can&#39;t express anything else.<br></p><p>All the alternatives I see are ugly-to-dangerous.<br></p><p>Have I missed something, I hope? Please make a fool of me.<br></p><p>	— F<br></p><p>The details of my use case or implementation are off-topic; even if mine are ill-considered, surely apt ones exist. Unless you can demonstrate there are none.<br></p><p>The vDSP_* functions in Apple’s Accelerate framework are declared in C to operate on naked float or double pointers. I decided to represent such Float buffers in Swift by a struct (call it ManagedFloatBuffer) containing a reference to a FloatBuffer, which is a final specialization of class ManagedBuffer&lt;Int, Float&gt;.<br></p><p>(The names are a work-in-progress. Just remember: ManagedFloatBuffer is a value type that can copy-on-write to a reference to FloatBuffer, a backing store for a bunch of Floats.)<br></p><p>The nonmutating funcs:<br></p><p>    func subtract(_ other: ManagedFloatBuffer) -&gt; ManagedFloatBuffer<br>    func subtract(_ scalar: Float) -&gt; ManagedFloatBuffer<br></p><p>are straightforward. They return new ManagedFloatBuffer values. You can chain further calls to simplify a complex calculation that is neither intricate nor tied up in temporaries:<br></p><p>    let sum²OfResiduals = speeds<br>        .subtract(cameraSpeed.mean)<br>        .multiply(feetToMeters)<br>        .sumOfSquares<br></p><p>Great. And vDSP gets you about a 40% boost. (The compiler itself seems to do a pretty good job of auto-vectorizing; the unoptimized code is a couple of orders of magnitude slower.) But as you chain the immutables, you generate new FloatBuffers to hold the intermediate results. For long chains, you end up allocating new buffers (which turns out to be expensive on the time scale of vectorized math) and copying large buffers into them that you are about to discard. I want my Swift code to be as performant as C, but safer and more expressive.<br></p><p>So how about some mutating functions to change a ManagedFloatBuffer’s bytes in-place (copying-on-write as needed so you can preserve intermediate values)?<br></p><p>    mutating func reduce(by other: ManagedFloatBuffer) -&gt; ManagedFloatBuffer<br>    mutating func reduce(by scalar: Float) -&gt; ManagedFloatBuffer<br></p><p>These return self, because I’d hoped I could chain operators as I did with the non-mutating versions.<br></p><p>The compiler doesn’t like this. It says reduce(by:) returns an immutable value, so you can’t chain mutating functions.<br></p><p>(I can see an issue in that when the first func&#39;s self is copied as the return value that is used as the second func’s self,  that could make two surviving references to the same buffer, so a buffer copy would happen when you mutate the second func’s self anyway. I’m not sure the compiler has to do that, but I can see how it might be hard to account for otherwise. Hey, it’s a tail call, right? SMOP, not source-breaking at all.)<br></p><p>StackOverflow invites me to eat cake: Make the mutable operand inout to funcs I call one by one. Something like:<br></p><p>    multiply(perspectiveCorrections, into: &amp;pixelXes)<br>    sin(of: &amp;pixelXes)<br>    multiply(pixelXes, into: &amp;speeds)<br>    multiply(feetToMeters, into: &amp;speeds)<br>    subtract(cameraSpeed.mean, from: &amp;speeds)<br>    let sumSquaredOfResiduals = speeds.sumOfSquares<br></p><p>    // grodiness deliberately enhanced for illustration<br></p><p>I’d rather not. The thing to be calculated is named at the bottom of the paragraph. The intermediate steps must preserve names that change meaning line-by-line. You have to study the code to recognize it as a single arithmetic expression.<br></p><p>And by the by, if a vector operand is itself the result of a mutating operation, the dependency graph becomes a nightmare to read — I can’t be sure the illustration even expresses a plausible calculation.<br></p><p>Thinking up more reasons to hate this solution is a fun parlor game you and your family can play at home.<br></p><p>Strictly speaking, the compiler is right: I don’t see any language construct that expresses that a returned value type that may be mutated by a chained func. Am I correct?<br></p><p>I’m not at all happy with turning ManagedFloatBuffer into a class. Intuitively, this is a value type. Passing a packet of Floats into a func (or into another thread, as one does with math) and finding your Floats had changed in the mean time is… surprising.<br></p><p>I’m not optimistic, but I have to ask: Is there a way to do this — to take mutability down an operator chain?<br></p><p>	— F<br></p><p><br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160805/b6ff974d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Chaining struct-mutating funcs</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Since your backing buffer is copy-on-write, you can do the in-place mutation optimization in your immutable implementations, something like this:<br></p><p>class C {<br>  var value: Int<br>  init(value: Int) { self.value = value }<br>}<br></p><p>struct S { var c: C }<br></p><p>func addInts(x: S, y: S) -&gt; S {<br>  var tmp = x<br>  // Don&#39;t use x after this point so that it gets forwarded into tmp<br>  if isKnownUniquelyReferenced(&amp;tmp.c) {<br>    tmp.c.value += y.c.value<br>    return tmp<br>  } else {<br>    return S(c: C(value: tmp.c.value + y.c.value))<br>  }<br>}<br></p><p>which should let you get similar efficiency to the mutating formulation while using semantically immutable values.<br></p><p>-Joe<br></p><p>&gt; On Aug 5, 2016, at 2:35 PM, Fritz Anderson via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift 3 as of Xcode 8.0b4<br>&gt; <br>&gt; TL;DR: I have a struct value type backed by a copy-on-write mutable buffer. You use it to perform arithmetic on the buffers. The most expressive way to do this efficiently is to chain the arithmetic operators so each mutates the same buffer. Swift does not like to chain mutating operators — it treats the result of each step as immutable, so you can’t continue the chain. I can’t argue; the syntax apparently can&#39;t express anything else.<br>&gt; <br>&gt; All the alternatives I see are ugly-to-dangerous.<br>&gt; <br>&gt; Have I missed something, I hope? Please make a fool of me.<br>&gt; <br>&gt; 	— F<br>&gt; <br>&gt; The details of my use case or implementation are off-topic; even if mine are ill-considered, surely apt ones exist. Unless you can demonstrate there are none.<br>&gt; <br>&gt; The vDSP_* functions in Apple’s Accelerate framework are declared in C to operate on naked float or double pointers. I decided to represent such Float buffers in Swift by a struct (call it ManagedFloatBuffer) containing a reference to a FloatBuffer, which is a final specialization of class ManagedBuffer&lt;Int, Float&gt;.<br>&gt; <br>&gt; (The names are a work-in-progress. Just remember: ManagedFloatBuffer is a value type that can copy-on-write to a reference to FloatBuffer, a backing store for a bunch of Floats.)<br>&gt; <br>&gt; The nonmutating funcs:<br>&gt; <br>&gt;     func subtract(_ other: ManagedFloatBuffer) -&gt; ManagedFloatBuffer<br>&gt;     func subtract(_ scalar: Float) -&gt; ManagedFloatBuffer<br>&gt; <br>&gt; are straightforward. They return new ManagedFloatBuffer values. You can chain further calls to simplify a complex calculation that is neither intricate nor tied up in temporaries:<br>&gt; <br>&gt;     let sum²OfResiduals = speeds<br>&gt;         .subtract(cameraSpeed.mean)<br>&gt;         .multiply(feetToMeters)<br>&gt;         .sumOfSquares<br>&gt; <br>&gt; Great. And vDSP gets you about a 40% boost. (The compiler itself seems to do a pretty good job of auto-vectorizing; the unoptimized code is a couple of orders of magnitude slower.) But as you chain the immutables, you generate new FloatBuffers to hold the intermediate results. For long chains, you end up allocating new buffers (which turns out to be expensive on the time scale of vectorized math) and copying large buffers into them that you are about to discard. I want my Swift code to be as performant as C, but safer and more expressive.<br>&gt; <br>&gt; So how about some mutating functions to change a ManagedFloatBuffer’s bytes in-place (copying-on-write as needed so you can preserve intermediate values)?<br>&gt; <br>&gt;     mutating func reduce(by other: ManagedFloatBuffer) -&gt; ManagedFloatBuffer<br>&gt;     mutating func reduce(by scalar: Float) -&gt; ManagedFloatBuffer<br>&gt; <br>&gt; These return self, because I’d hoped I could chain operators as I did with the non-mutating versions.<br>&gt; <br>&gt; The compiler doesn’t like this. It says reduce(by:) returns an immutable value, so you can’t chain mutating functions.<br>&gt; <br>&gt; (I can see an issue in that when the first func&#39;s self is copied as the return value that is used as the second func’s self,  that could make two surviving references to the same buffer, so a buffer copy would happen when you mutate the second func’s self anyway. I’m not sure the compiler has to do that, but I can see how it might be hard to account for otherwise. Hey, it’s a tail call, right? SMOP, not source-breaking at all.)<br>&gt; <br>&gt; StackOverflow invites me to eat cake: Make the mutable operand inout to funcs I call one by one. Something like:<br>&gt; <br>&gt;     multiply(perspectiveCorrections, into: &amp;pixelXes)<br>&gt;     sin(of: &amp;pixelXes)<br>&gt;     multiply(pixelXes, into: &amp;speeds)<br>&gt;     multiply(feetToMeters, into: &amp;speeds)<br>&gt;     subtract(cameraSpeed.mean, from: &amp;speeds)<br>&gt;     let sumSquaredOfResiduals = speeds.sumOfSquares<br>&gt; <br>&gt;     // grodiness deliberately enhanced for illustration<br>&gt; <br>&gt; I’d rather not. The thing to be calculated is named at the bottom of the paragraph. The intermediate steps must preserve names that change meaning line-by-line. You have to study the code to recognize it as a single arithmetic expression.<br>&gt; <br>&gt; And by the by, if a vector operand is itself the result of a mutating operation, the dependency graph becomes a nightmare to read — I can’t be sure the illustration even expresses a plausible calculation.<br>&gt; <br>&gt; Thinking up more reasons to hate this solution is a fun parlor game you and your family can play at home.<br>&gt; <br>&gt; Strictly speaking, the compiler is right: I don’t see any language construct that expresses that a returned value type that may be mutated by a chained func. Am I correct?<br>&gt; <br>&gt; I’m not at all happy with turning ManagedFloatBuffer into a class. Intuitively, this is a value type. Passing a packet of Floats into a func (or into another thread, as one does with math) and finding your Floats had changed in the mean time is… surprising.<br>&gt; <br>&gt; I’m not optimistic, but I have to ask: Is there a way to do this — to take mutability down an operator chain?<br>&gt; <br>&gt; 	— F<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160805/b8d26f47/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
