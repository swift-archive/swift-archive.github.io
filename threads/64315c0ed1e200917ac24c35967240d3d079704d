<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 19, 2016 at 09:00:00pm</p></header><div class="content"><p>Surprisingly, this code does not compile:<br></p><p>    func foo(val: Int) { }<br></p><p>    func bar(closure: (Int,Int) -&gt; Void) {<br>        closure(0, 1)<br>    }<br></p><p>    bar { foo($0) }       // compiler error<br>    bar { foo($1) }       // just dandy<br>    bar { foo($0 + $1) }  // also works<br></p><p>The compiler error is:<br></p><p>    Cannot convert value of type (Int, Int) to expected argument type Int<br></p><p>It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br></p><p>This is certainly confusing. I’m posting to the list after receiving two Siesta user questions in the same day that both boil down to this issue.<br></p><p>Even if you do understand the behavior, it’s a real nuisance: it prevents concise implementation of a multi-arg closure which wants to ignore all but its first argument. Instead, such a closure has to drop back to the more verbose syntax:<br></p><p>    bar { a, _ in foo(a) }   // sigh<br></p><p>…or use this legibility-proof workaround:<br></p><p>    bar { foo($0.0) }   // yuck! wat?!<br></p><p>(Note that this problem exists only for the first argument; a closure that wants to ignore all but the second has no such problem.)<br></p><p>This behavior contradicts the Swift documentation, which clearly says that $0 refers to the first argument:<br></p><p>&gt; Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.<br></p><p>And:<br></p><p>&gt; A closure may omit names for its parameters. Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.<br></p><p><br>I can’t find anything in the docs that mentions this “all args tuple” behavior, so perhaps it’s a bug? Let me know if it is, and I’ll just file a bug report for it.<br></p><p>However the “whole tuple” behavior does seem to be intentional, and preserving that while fixing the problem above appears to require a language change. Thus…<br></p><p>Proposal<br></p><p>The implicit closure variable $0 should always refer to the closure’s first argument, and a different implicit name — perhaps $* or $_ or $... — should refer to the all-args tuple.<br></p><p>Thoughts?<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/6431704d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 19, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Surprisingly, this code does not compile:<br>&gt; <br>&gt;     func foo(val: Int) { }<br>&gt; <br>&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;         closure(0, 1)<br>&gt;     }<br>&gt; <br>&gt;     bar { foo($0) }       // compiler error<br>&gt;     bar { foo($1) }       // just dandy<br>&gt;     bar { foo($0 + $1) }  // also works<br>&gt; <br>&gt; The compiler error is:<br>&gt; <br>&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt; <br>&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br></p><p>It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br></p><p>Anyway, it’s a bug and doesn’t need to go through evolution.<br></p><p>John.<br></p><p><br>&gt; <br>&gt; This is certainly confusing. I’m posting to the list after receiving two Siesta user questions in the same day that both boil down to this issue.<br>&gt; <br>&gt; Even if you do understand the behavior, it’s a real nuisance: it prevents concise implementation of a multi-arg closure which wants to ignore all but its first argument. Instead, such a closure has to drop back to the more verbose syntax:<br>&gt; <br>&gt;     bar { a, _ in foo(a) }   // sigh<br>&gt; <br>&gt; …or use this legibility-proof workaround:<br>&gt; <br>&gt;     bar { foo($0.0) }   // yuck! wat?!<br>&gt; <br>&gt; (Note that this problem exists only for the first argument; a closure that wants to ignore all but the second has no such problem.)<br>&gt; <br>&gt; This behavior contradicts the Swift documentation, which clearly says that $0 refers to the first argument:<br>&gt; <br>&gt;&gt; Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.<br>&gt; <br>&gt; And:<br>&gt; <br>&gt;&gt; A closure may omit names for its parameters. Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.<br>&gt; <br>&gt; <br>&gt; I can’t find anything in the docs that mentions this “all args tuple” behavior, so perhaps it’s a bug? Let me know if it is, and I’ll just file a bug report for it.<br>&gt; <br>&gt; However the “whole tuple” behavior does seem to be intentional, and preserving that while fixing the problem above appears to require a language change. Thus…<br>&gt; <br>&gt; Proposal<br>&gt; <br>&gt; The implicit closure variable $0 should always refer to the closure’s first argument, and a different implicit name — perhaps $* or $_ or $... — should refer to the all-args tuple.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/c6e1e484/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt; <br>&gt; It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt; <br>&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br></p><p>Roger that. Filed the bug: https://bugs.swift.org/browse/SR-586 &lt;https://bugs.swift.org/browse/SR-586&gt;<br></p><p>Thanks!<br></p><p>P<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/40bf6027/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 20:35 , John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Surprisingly, this code does not compile:<br>&gt;&gt; <br>&gt;&gt;     func foo(val: Int) { }<br>&gt;&gt; <br>&gt;&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;&gt;         closure(0, 1)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     bar { foo($0) }       // compiler error<br>&gt;&gt;     bar { foo($1) }       // just dandy<br>&gt;&gt;     bar { foo($0 + $1) }  // also works<br>&gt;&gt; <br>&gt;&gt; The compiler error is:<br>&gt;&gt; <br>&gt;&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt;&gt; <br>&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt; <br>&gt; It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt; <br>&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br></p><p>I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br></p><p>I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br></p><p>Jordan<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/6dda15de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 8:57 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 19, 2016, at 20:35 , John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Surprisingly, this code does not compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func foo(val: Int) { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;&gt;&gt;         closure(0, 1)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     bar { foo($0) }       // compiler error<br>&gt;&gt;&gt;     bar { foo($1) }       // just dandy<br>&gt;&gt;&gt;     bar { foo($0 + $1) }  // also works<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler error is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt;&gt; <br>&gt;&gt; It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt;&gt; <br>&gt;&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br>&gt; <br>&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt; <br>&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br></p><p>In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/57df0f51/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 :-)<br></p><p>-Thorsten<br></p><p>&gt; Am 20.01.2016 um 18:49 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/a2bb852f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 20, 2016 at 12:00:00pm</p></header><div class="content"><p>Since $&lt;identifier&gt; is reserved for the repl/debugger, $&lt;operator character&gt; is troublesome for parsing, and $&lt;reserved character&gt; could result in odd special cases or limitations in language evolution - how about just $ ?<br></p><p>e.g., $0 is semantically a shortcut for $.0<br></p><p>-DW<br></p><p>&gt; On Jan 20, 2016, at 10:49 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 8:57 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 20:35 , John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Surprisingly, this code does not compile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func foo(val: Int) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;&gt;&gt;&gt;         closure(0, 1)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     bar { foo($0) }       // compiler error<br>&gt;&gt;&gt;&gt;     bar { foo($1) }       // just dandy<br>&gt;&gt;&gt;&gt;     bar { foo($0 + $1) }  // also works<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler error is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br>&gt;&gt; <br>&gt;&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt;&gt; <br>&gt;&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br>&gt; <br>&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/622829d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>That’s a good idea!<br></p><p>-Thorsten<br></p><p>PS: we might also use $0 for the tuple and $1, … for the args, like regex syntax does ($0 = whole match, $1 = first group etc.). This would not work so well with the general zero-based index behavior of Swift.<br></p><p><br>&gt; Am 20.01.2016 um 20:05 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Since $&lt;identifier&gt; is reserved for the repl/debugger, $&lt;operator character&gt; is troublesome for parsing, and $&lt;reserved character&gt; could result in odd special cases or limitations in language evolution - how about just $ ?<br>&gt; <br>&gt; e.g., $0 is semantically a shortcut for $.0<br>&gt; <br>&gt; -DW<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>January 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 9:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jan 20, 2016, at 8:57 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 20:35 , John McCall via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Surprisingly, this code does not compile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func foo(val: Int) { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;&gt;&gt;&gt;         closure(0, 1)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     bar { foo($0) }       // compiler error<br>&gt;&gt;&gt;&gt;     bar { foo($1) }       // just dandy<br>&gt;&gt;&gt;&gt;     bar { foo($0 + $1) }  // also works<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler error is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br>&gt;&gt; <br>&gt;&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt;&gt; <br>&gt;&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br>&gt; <br>&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br></p><p>Yeah, that makes sense to me.  $_, clearly. :)<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/6afd41b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>January 20, 2016 at 02:00:00pm</p></header><div class="content"><p>`$$` Doesn&#39;t take another sigil away and shouldn&#39;t be ambiguous since it<br>isn&#39;t used in current syntax.<br></p><p><br>On Wed, Jan 20, 2016 at 2:39 PM, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 20, 2016, at 9:49 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;<br>&gt; On Jan 20, 2016, at 8:57 AM, Jordan Rose via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 19, 2016, at 20:35 , John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Surprisingly, this code does not compile:<br>&gt;<br>&gt;     func foo(val: Int) { }<br>&gt;<br>&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;         closure(0, 1)<br>&gt;     }<br>&gt;<br>&gt;     bar { foo($0) }       // compiler error<br>&gt;     bar { foo($1) }       // just dandy<br>&gt;     bar { foo($0 + $1) }  // also works<br>&gt;<br>&gt; The compiler error is:<br>&gt;<br>&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt;<br>&gt; It appears that the meaning of $0 is overloaded: it can refer either to<br>&gt; the tuple of all arguments, or to just the first argument. The presence of<br>&gt; another placeholder variable ($1 in the third example) seems to trigger<br>&gt; the latter behavior.<br>&gt;<br>&gt;<br>&gt; It’s dumber than that.  The type-checker assumes that the closure has a<br>&gt; tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the<br>&gt; closure.  Thus, a two-argument closure falls down if you ignore the second<br>&gt; argument.  It’s dumb, and we’ve known about it for a long time; and yet<br>&gt; it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt;<br>&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br>&gt;<br>&gt;<br>&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally<br>&gt; useful for forwarding arguments. (For a while I had it as a fix-it for<br>&gt; doing function representation conversions.)<br>&gt;<br>&gt; I agree that having it always be the first argument is less surprising and<br>&gt; probably more generally useful, though.<br>&gt;<br>&gt;<br>&gt; In the spirit of the Great Argument Simplification to distinguish<br>&gt; arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like<br>&gt; sigil to bind &quot;all arguments&quot; distinct from $0.<br>&gt;<br>&gt;<br>&gt; Yeah, that makes sense to me.  $_, clearly. :)<br>&gt;<br>&gt; John.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/6095d191/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 20, 2016 at 02:00:00pm</p></header><div class="content"><p>On Jan 20, 2016, at 9:49 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt;&gt; <br>&gt;&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br>&gt; <br>&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br></p><p>Likewise, on the caller side, we should have a “splat” sigil to splat a tuple into the argument list of a call.  We need a similar thing for varargs to enable vararg forwarding as well.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/c80f752b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 21, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 4:55 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jan 20, 2016, at 9:49 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br>&gt;&gt; <br>&gt;&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br>&gt; <br>&gt; Likewise, on the caller side, we should have a “splat” sigil to splat a tuple into the argument list of a call.  We need a similar thing for varargs to enable vararg forwarding as well.<br></p><p>Where does this leave the discussion, then? I’ve filed it as a bug, though there’s disagreement about whether it is.<br></p><p>Can we split this into two questions? My wish and dream would to get $0 fixed to match the docs (i.e. only match the first param) in 2.2. That’s an ongoing pain point.<br></p><p>The $* (or similar) feature would be handy, but seems like it should be accompanied by a larger vararg splatting discussion, and should probably fall to Swift 4+ given the release goals for Swift 3 — which is fine with me, but I’d really hate to have to wait that long to see $0 fixed.<br></p><p>Cheers,<br></p><p>Paul<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/c344056b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 3:05 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 4:55 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 9:49 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 10:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 19, 2016, at 7:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It’s dumber than that.  The type-checker assumes that the closure has a tuple of arguments ($0, $1, …, $N), where $N is the largest N seen in the closure.  Thus, a two-argument closure falls down if you ignore the second argument.  It’s dumb, and we’ve known about it for a long time; and yet it’s been remarkably annoying to fix, and so we haven’t yet.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyway, it’s a bug and doesn’t need to go through evolution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br>&gt;&gt; <br>&gt;&gt; Likewise, on the caller side, we should have a “splat” sigil to splat a tuple into the argument list of a call.  We need a similar thing for varargs to enable vararg forwarding as well.<br>&gt; <br>&gt; Where does this leave the discussion, then? I’ve filed it as a bug, though there’s disagreement about whether it is.<br>&gt; <br>&gt; Can we split this into two questions? My wish and dream would to get $0 fixed to match the docs (i.e. only match the first param) in 2.2. That’s an ongoing pain point.<br>&gt; <br>&gt; The $* (or similar) feature would be handy, but seems like it should be accompanied by a larger vararg splatting discussion, and should probably fall to Swift 4+ given the release goals for Swift 3 — which is fine with me, but I’d really hate to have to wait that long to see $0 fixed.<br></p><p>Bumping this. I don’t much care about the $* question, but am eager to see the $0 overloading fixed.<br></p><p>Can the core team make a call on whether I should write a proposal to make that happen, or whether filing the bug is sufficient?<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 1:05 PM, Paul Cantrell &lt;cantrell at pobox.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 4:55 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jan 20, 2016, at 9:49 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wouldn&#39;t go as far as to say it&#39;s a bug. It&#39;s known and occasionally useful for forwarding arguments. (For a while I had it as a fix-it for doing function representation conversions.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree that having it always be the first argument is less surprising and probably more generally useful, though.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the spirit of the Great Argument Simplification to distinguish arguments from tuples, we probably ought to introduce a separate &#39;$*&#39;-like sigil to bind &quot;all arguments&quot; distinct from $0.<br>&gt;&gt; <br>&gt;&gt; Likewise, on the caller side, we should have a “splat” sigil to splat a tuple into the argument list of a call.  We need a similar thing for varargs to enable vararg forwarding as well.<br>&gt; <br>&gt; Where does this leave the discussion, then? I’ve filed it as a bug, though there’s disagreement about whether it is.<br>&gt; <br>&gt; Can we split this into two questions? My wish and dream would to get $0 fixed to match the docs (i.e. only match the first param) in 2.2. That’s an ongoing pain point.<br>&gt; <br>&gt; The $* (or similar) feature would be handy, but seems like it should be accompanied by a larger vararg splatting discussion, and should probably fall to Swift 4+ given the release goals for Swift 3 — which is fine with me, but I’d really hate to have to wait that long to see $0 fixed.<br></p><p>I’m sorry, I’ve lost context on what the proposal here is.  Can you please restate it?  To me, it seems most natural that $0 always refer to the first parameter of a closure.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/87e6929f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 10:09, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m sorry, I’ve lost context on what the proposal here is.  Can you please restate it?  To me, it seems most natural that $0 always refer to the first parameter of a closure.<br>&gt; <br>&gt; -Chris<br></p><p><br>Paul Cantrell’s original post documented behavior which causes $0 to sometimes refer to a tuple of all the arguments instead of the just first argument. John McCall said it was bug, but then Jordan Rose replied and said, ”I wouldn’t go as far as to say it’s a bug. It’s known and occasionally useful for forwarding arguments&quot;. My understanding is that everyone agrees on two things: the bug should eventually be fixed, and the bug’s functionality is actually kinda cool (when it’s not biting you) and there should still be a way to invoke it. The debate was over whether to do it now and make $*, $_, $$, $…, or $# (I think that’s all of them) be the “all args” tuple, or whether we should wait fix it until Swift gets “a more complete revision of the varargs system” (which was assumed to be at least Swift 4).<br></p><p>At least that’s how I understand it. Here’s Paul’s original post:<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 19, 2016, at 19:20, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Surprisingly, this code does not compile:<br>&gt; <br>&gt;     func foo(val: Int) { }<br>&gt; <br>&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;         closure(0, 1)<br>&gt;     }<br>&gt; <br>&gt;     bar { foo($0) }       // compiler error<br>&gt;     bar { foo($1) }       // just dandy<br>&gt;     bar { foo($0 + $1) }  // also works<br>&gt; <br>&gt; The compiler error is:<br>&gt; <br>&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt; <br>&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt; <br>&gt; This is certainly confusing. I’m posting to the list after receiving two Siesta user questions in the same day that both boil down to this issue.<br>&gt; <br>&gt; Even if you do understand the behavior, it’s a real nuisance: it prevents concise implementation of a multi-arg closure which wants to ignore all but its first argument. Instead, such a closure has to drop back to the more verbose syntax:<br>&gt; <br>&gt;     bar { a, _ in foo(a) }   // sigh<br>&gt; <br>&gt; …or use this legibility-proof workaround:<br>&gt; <br>&gt;     bar { foo($0.0) }   // yuck! wat?!<br>&gt; <br>&gt; (Note that this problem exists only for the first argument; a closure that wants to ignore all but the second has no such problem.)<br>&gt; <br>&gt; This behavior contradicts the Swift documentation, which clearly says that $0 refers to the first argument:<br>&gt; <br>&gt;&gt; Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.<br>&gt; <br>&gt; And:<br>&gt; <br>&gt;&gt; A closure may omit names for its parameters. Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.<br>&gt; <br>&gt; <br>&gt; I can’t find anything in the docs that mentions this “all args tuple” behavior, so perhaps it’s a bug? Let me know if it is, and I’ll just file a bug report for it.<br>&gt; <br>&gt; However the “whole tuple” behavior does seem to be intentional, and preserving that while fixing the problem above appears to require a language change. Thus…<br>&gt; <br>&gt; Proposal<br>&gt; <br>&gt; The implicit closure variable $0 should always refer to the closure’s first argument, and a different implicit name — perhaps $* or $_ or $... — should refer to the all-args tuple.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/d547cf1f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>January 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 2:20 PM, Dave via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 10:09, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m sorry, I’ve lost context on what the proposal here is.  Can you please restate it?  To me, it seems most natural that $0 always refer to the first parameter of a closure.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Paul Cantrell’s original post documented behavior which causes $0 to sometimes refer to a tuple of all the arguments instead of the just first argument. John McCall said it was bug, but then Jordan Rose replied and said, ”I wouldn’t go as far as to say it’s a bug. It’s known and occasionally useful for forwarding arguments&quot;. My understanding is that everyone agrees on two things: the bug should eventually be fixed, and the bug’s functionality is actually kinda cool (when it’s not biting you) and there should still be a way to invoke it. The debate was over whether to do it now and make $*, $_, $$, $…, or $# (I think that’s all of them) be the “all args” tuple, or whether we should wait fix it until Swift gets “a more complete revision of the varargs system” (which was assumed to be at least Swift 4).<br></p><p>An excellent summary, to which I’d just add: it’s unclear to me whether we need to wait for $* (or whatever the new language feature is) in order to make the “$0 is always the first arg” fix. So there is a third option, which I’d prefer:<br></p><p>1. Declare current “$0 is sometimes a tuple” behavior a bug.<br>2. Fix it soon so that $0 is always the first arg, maybe even in 2.x.<br>3. Implement either $* and/or more comprehensive advanced varargs later, probably in 4+.<br></p><p>The case for this approach is:<br></p><p>• the current behavior of $0 is somewhat nonsensical,<br>• confusion caused by this behavior is common, and<br>• use of $0 as an all-args tuple is rare and (mostly) easy to work around.<br></p><p>However, this approach hinges on deciding whether the current behavior is a bug or a feature. That&#39;s a call I think the core team has to make.<br></p><p>Cheers, P<br></p><p><br>&gt; <br>&gt; At least that’s how I understand it. Here’s Paul’s original post:<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 19:20, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Surprisingly, this code does not compile:<br>&gt;&gt; <br>&gt;&gt;     func foo(val: Int) { }<br>&gt;&gt; <br>&gt;&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;&gt;         closure(0, 1)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     bar { foo($0) }       // compiler error<br>&gt;&gt;     bar { foo($1) }       // just dandy<br>&gt;&gt;     bar { foo($0 + $1) }  // also works<br>&gt;&gt; <br>&gt;&gt; The compiler error is:<br>&gt;&gt; <br>&gt;&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt;&gt; <br>&gt;&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt;&gt; <br>&gt;&gt; This is certainly confusing. I’m posting to the list after receiving two Siesta user questions in the same day that both boil down to this issue.<br>&gt;&gt; <br>&gt;&gt; Even if you do understand the behavior, it’s a real nuisance: it prevents concise implementation of a multi-arg closure which wants to ignore all but its first argument. Instead, such a closure has to drop back to the more verbose syntax:<br>&gt;&gt; <br>&gt;&gt;     bar { a, _ in foo(a) }   // sigh<br>&gt;&gt; <br>&gt;&gt; …or use this legibility-proof workaround:<br>&gt;&gt; <br>&gt;&gt;     bar { foo($0.0) }   // yuck! wat?!<br>&gt;&gt; <br>&gt;&gt; (Note that this problem exists only for the first argument; a closure that wants to ignore all but the second has no such problem.)<br>&gt;&gt; <br>&gt;&gt; This behavior contradicts the Swift documentation, which clearly says that $0 refers to the first argument:<br>&gt;&gt; <br>&gt;&gt;&gt; Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.<br>&gt;&gt; <br>&gt;&gt; And:<br>&gt;&gt; <br>&gt;&gt;&gt; A closure may omit names for its parameters. Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I can’t find anything in the docs that mentions this “all args tuple” behavior, so perhaps it’s a bug? Let me know if it is, and I’ll just file a bug report for it.<br>&gt;&gt; <br>&gt;&gt; However the “whole tuple” behavior does seem to be intentional, and preserving that while fixing the problem above appears to require a language change. Thus…<br>&gt;&gt; <br>&gt;&gt; Proposal<br>&gt;&gt; <br>&gt;&gt; The implicit closure variable $0 should always refer to the closure’s first argument, and a different implicit name — perhaps $* or $_ or $... — should refer to the all-args tuple.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; Paul<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/66b0e8f6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Proposal: Make $0 always refer to a closure’s first argument</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>January 21, 2016 at 02:00:00pm</p></header><div class="content"><p>I like the idea of distinguishing full argument tuple from its members. <br></p><p>I dislike $_ because the meaning of _ is more &quot;wildcard ignore&quot; than &quot;wildcard match and represent&quot;<br>I also dislike $* (product) and $... (because it&#39;s just horrible)<br></p><p>I don&#39;t mind $$ or $#, and could see adding $$.0 or $#.1 aliases for $0 and $1.<br></p><p>-- E<br></p><p>&gt; On Jan 19, 2016, at 8:20 PM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Surprisingly, this code does not compile:<br>&gt; <br>&gt;     func foo(val: Int) { }<br>&gt; <br>&gt;     func bar(closure: (Int,Int) -&gt; Void) {<br>&gt;         closure(0, 1)<br>&gt;     }<br>&gt; <br>&gt;     bar { foo($0) }       // compiler error<br>&gt;     bar { foo($1) }       // just dandy<br>&gt;     bar { foo($0 + $1) }  // also works<br>&gt; <br>&gt; The compiler error is:<br>&gt; <br>&gt;     Cannot convert value of type (Int, Int) to expected argument type Int<br>&gt; <br>&gt; It appears that the meaning of $0 is overloaded: it can refer either to the tuple of all arguments, or to just the first argument. The presence of another placeholder variable ($1 in the third example) seems to trigger the latter behavior.<br>&gt; <br>&gt; This is certainly confusing. I’m posting to the list after receiving two Siesta user questions in the same day that both boil down to this issue.<br>&gt; <br>&gt; Even if you do understand the behavior, it’s a real nuisance: it prevents concise implementation of a multi-arg closure which wants to ignore all but its first argument. Instead, such a closure has to drop back to the more verbose syntax:<br>&gt; <br>&gt;     bar { a, _ in foo(a) }   // sigh<br>&gt; <br>&gt; …or use this legibility-proof workaround:<br>&gt; <br>&gt;     bar { foo($0.0) }   // yuck! wat?!<br>&gt; <br>&gt; (Note that this problem exists only for the first argument; a closure that wants to ignore all but the second has no such problem.)<br>&gt; <br>&gt; This behavior contradicts the Swift documentation, which clearly says that $0 refers to the first argument:<br>&gt; <br>&gt;&gt; Swift automatically provides shorthand argument names to inline closures, which can be used to refer to the values of the closure’s arguments by the names $0, $1, $2, and so on.<br>&gt; <br>&gt; And:<br>&gt; <br>&gt;&gt; A closure may omit names for its parameters. Its parameters are then implicitly named $ followed by their position: $0, $1, $2, and so on.<br>&gt; <br>&gt; <br>&gt; I can’t find anything in the docs that mentions this “all args tuple” behavior, so perhaps it’s a bug? Let me know if it is, and I’ll just file a bug report for it.<br>&gt; <br>&gt; However the “whole tuple” behavior does seem to be intentional, and preserving that while fixing the problem above appears to require a language change. Thus…<br>&gt; <br>&gt; Proposal<br>&gt; <br>&gt; The implicit closure variable $0 should always refer to the closure’s first argument, and a different implicit name — perhaps $* or $_ or $... — should refer to the all-args tuple.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; Paul<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/bf5602e8/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
