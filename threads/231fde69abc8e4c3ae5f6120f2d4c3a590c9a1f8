<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 27, 2016 at 11:00:00am</p></header><div class="content"><p>From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br></p><p>I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br></p><p>I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br></p><p>protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { .. default implementation … }<br>}<br></p><p>type B: A {<br></p><p>    override required func foo () { … overrides implementation … }<br>}<br></p><p><br>I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br></p><p>Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both? <br></p><p>type B: A, C {<br>    override required func foo() { A.foo(); C.foo() }<br>}<br></p><p>Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br></p><p>type B: A {<br>    override required func foo() { A.foo(); … my custom behavior … }<br>}<br></p><p>cc’ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br></p><p>— E <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/231fa1f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 27, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 10:10 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt; <br>&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt; <br>&gt; I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br>&gt; <br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt; <br>&gt; type B: A {<br>&gt; <br>&gt;     override required func foo () { … overrides implementation … }<br>&gt; }<br></p><p>A couple questions about your pitch:<br></p><p>1) What is “required” doing there? <br></p><p>2) Is “override” only required when there is a default implementation of the protocol requirement, or is it required whenever you are implementing a protocol requirement?<br></p><p>	* If the former, it might be the case that it’s too easy to forget to add the “override” keyword (because it’s needed for some implementations of protocol requirements but not others), which undercuts the value of having it.<br></p><p>	* If the latter, “override” is probably the wrong keyword because it’s not overriding anything in the common case of implementing a non-defaulted requirement.<br></p><p>&gt; I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt; <br>&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both? <br>&gt; <br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br></p><p>I think the right answer here is for the compiler to produce an ambiguity if you don’t implement the requirement yourself, and then solving your “related topic 2” lets you choose which implementation you want.<br></p><p>&gt; Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt; <br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt; }<br></p><p>Seems totally reasonable to me. One ugly syntax: A.foo(self)(), leveraging the currying of self?<br></p><p>&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br></p><p>My objections are described here:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.devel/1799/focus=1831 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1799/focus=1831&gt;<br></p><p>Essentially, my argument is that the point of “override” (as pitched above) is to declare the user’s intent to implement a requirement. I feel that the explicit protocol conformance (&quot;type B : A”) declares that intent, and that various common conventions (e.g., one conformance per extension, where the extension is primarily there to conform to the protocol) reinforce intent well enough for the compiler to do a good job here. I’d prefer that over another boilerplate-y keyword.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/f42616e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>On Apr 27, 2016, at 12:25 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; On Apr 27, 2016, at 10:10 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt;&gt; <br>&gt;&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt;&gt; <br>&gt;&gt; I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;     func foo() { .. default implementation … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; type B: A {<br>&gt;&gt; <br>&gt;&gt;     override required func foo () { … overrides implementation … }<br>&gt;&gt; }<br>&gt; <br>&gt; A couple questions about your pitch:<br>&gt; <br>&gt; 1) What is “required” doing there? <br></p><p>I threw it in not because I’m tied to it but because I wanted it to be part of the conversation.<br>This is a requirement from conforming to the protocol.<br></p><p>&gt; 2) Is “override” only required when there is a default implementation of the protocol requirement, or is it required whenever you are implementing a protocol requirement?<br></p><p>Override is only because it is overriding the default implementation of the protocol requirement. Without that default implementation there would be no override, it would simply be satisfying the requirement.<br></p><p>&gt; 	* If the former, it might be the case that it’s too easy to forget to add the “override” keyword (because it’s needed for some implementations of protocol requirements but not others), which undercuts the value of having it.<br></p><p>Forcing the override keyword makes it clear at the definition point that the story extends beyond the method or whatever to point to a default implementation that is being replaced. I *really* like having that reference in terms of both code construction (“I am doing this as a deliberate act”) with the compiler complaining otherwise, and in terms of code self documentation (“I know this was added deliberately, what default did it override?”)<br></p><p>&gt; 	* If the latter, “override” is probably the wrong keyword because it’s not overriding anything in the common case of implementing a non-defaulted requirement.<br></p><p>It would be pointless if it’s just satisfying a requirement. That’s why  introduced both keywords into the discussion. (And because I’m still being influenced by the “near miss” conversation.)<br></p><p>&gt; I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt;&gt; <br>&gt;&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both? <br>&gt;&gt; <br>&gt;&gt; type B: A, C {<br>&gt;&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt;&gt; }<br>&gt; <br>&gt; I think the right answer here is for the compiler to produce an ambiguity if you don’t implement the requirement yourself, and then solving your “related topic 2” lets you choose which implementation you want.<br></p><p>How do you choose which one? What syntax? For example:<br></p><p>required func foo = A.foo<br></p><p>would be the simplest approach<br></p><p>&gt; <br>&gt;&gt; Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt;&gt; <br>&gt;&gt; type B: A {<br>&gt;&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt;&gt; }<br>&gt; <br>&gt; Seems totally reasonable to me. One ugly syntax: A.foo(self)(), leveraging the currying of self?<br></p><p>Ugly but it would pretty much do it for me. It offers an expressive way to say “Please execute the A.foo behavior using the self instance”. Does 3 still support this?<br></p><p>&gt; <br>&gt;&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br>&gt; <br>&gt; My objections are described here:<br>&gt; <br>&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.devel/1799/focus=1831 &lt;http://thread.gmane.org/gmane.comp.lang.swift.devel/1799/focus=1831&gt;<br>&gt; <br>&gt; Essentially, my argument is that the point of “override” (as pitched above) is to declare the user’s intent to implement a requirement. I feel that the explicit protocol conformance (&quot;type B : A”) declares that intent, and that various common conventions (e.g., one conformance per extension, where the extension is primarily there to conform to the protocol) reinforce intent well enough for the compiler to do a good job here. I’d prefer that over another boilerplate-y keyword.<br>&gt; <br>&gt; 	- Doug<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/b67d2ddb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Inline<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Apr 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 27, 2016, at 12:25 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 27, 2016, at 10:10 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;     func foo() { .. default implementation … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type B: A {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     override required func foo () { … overrides implementation … }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A couple questions about your pitch:<br>&gt;&gt; <br>&gt;&gt; 1) What is “required” doing there? <br>&gt; <br>&gt; I threw it in not because I’m tied to it but because I wanted it to be part of the conversation.<br>&gt; This is a requirement from conforming to the protocol.<br>&gt; <br>&gt;&gt; 2) Is “override” only required when there is a default implementation of the protocol requirement, or is it required whenever you are implementing a protocol requirement?<br>&gt; <br>&gt; Override is only because it is overriding the default implementation of the protocol requirement. Without that default implementation there would be no override, it would simply be satisfying the requirement.<br>&gt; <br>&gt;&gt; 	* If the former, it might be the case that it’s too easy to forget to add the “override” keyword (because it’s needed for some implementations of protocol requirements but not others), which undercuts the value of having it.<br>&gt; <br>&gt; Forcing the override keyword makes it clear at the definition point that the story extends beyond the method or whatever to point to a default implementation that is being replaced. I *really* like having that reference in terms of both code construction (“I am doing this as a deliberate act”) with the compiler complaining otherwise, and in terms of code self documentation (“I know this was added deliberately, what default did it override?”)<br>&gt; <br>&gt;&gt; 	* If the latter, “override” is probably the wrong keyword because it’s not overriding anything in the common case of implementing a non-defaulted requirement.<br>&gt; <br>&gt; It would be pointless if it’s just satisfying a requirement. That’s why  introduced both keywords into the discussion. (And because I’m still being influenced by the “near miss” conversation.)<br>&gt; <br></p><p>One could always argue that should protocol definitions ever be allowed to contain default implementations ala-java default methods, the distinction between former and latter would go away, and it would be happy anticipation to have mandated *override* all along in all cases, ensuring that future default methods would not accidentally take precedence of current code or wind up being treated differently than other overrides.<br></p><p><br></p><p>&gt;&gt; I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type B: A, C {<br>&gt;&gt;&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think the right answer here is for the compiler to produce an ambiguity if you don’t implement the requirement yourself, and then solving your “related topic 2” lets you choose which implementation you want.<br>&gt; <br>&gt; How do you choose which one? What syntax? For example:<br>&gt; <br>&gt; required func foo = A.foo<br>&gt; <br>&gt; would be the simplest approach<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type B: A {<br>&gt;&gt;&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Seems totally reasonable to me. One ugly syntax: A.foo(self)(), leveraging the currying of self?<br>&gt; <br>&gt; Ugly but it would pretty much do it for me. It offers an expressive way to say “Please execute the A.foo behavior using the self instance”. Does 3 still support this?<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br>&gt;&gt; <br>&gt;&gt; My objections are described here:<br>&gt;&gt; <br>&gt;&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.devel/1799/focus=1831<br>&gt;&gt; <br>&gt;&gt; Essentially, my argument is that the point of “override” (as pitched above) is to declare the user’s intent to implement a requirement. I feel that the explicit protocol conformance (&quot;type B : A”) declares that intent, and that various common conventions (e.g., one conformance per extension, where the extension is primarily there to conform to the protocol) reinforce intent well enough for the compiler to do a good job here. I’d prefer that over another boilerplate-y keyword.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/ae6eee78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 12:45 PM, L. Mihalkovic &lt;laurent.mihalkovic at gmail.com&gt; wrote:<br>&gt; <br>&gt; Inline<br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Apr 27, 2016, at 9:31 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 27, 2016, at 12:25 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 27, 2016, at 10:10 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;     func foo() { .. default implementation … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; type B: A {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     override required func foo () { … overrides implementation … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A couple questions about your pitch:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) What is “required” doing there? <br>&gt;&gt; <br>&gt;&gt; I threw it in not because I’m tied to it but because I wanted it to be part of the conversation.<br>&gt;&gt; This is a requirement from conforming to the protocol.<br>&gt;&gt; <br>&gt;&gt;&gt; 2) Is “override” only required when there is a default implementation of the protocol requirement, or is it required whenever you are implementing a protocol requirement?<br>&gt;&gt; <br>&gt;&gt; Override is only because it is overriding the default implementation of the protocol requirement. Without that default implementation there would be no override, it would simply be satisfying the requirement.<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If the former, it might be the case that it’s too easy to forget to add the “override” keyword (because it’s needed for some implementations of protocol requirements but not others), which undercuts the value of having it.<br>&gt;&gt; <br>&gt;&gt; Forcing the override keyword makes it clear at the definition point that the story extends beyond the method or whatever to point to a default implementation that is being replaced. I *really* like having that reference in terms of both code construction (“I am doing this as a deliberate act”) with the compiler complaining otherwise, and in terms of code self documentation (“I know this was added deliberately, what default did it override?”)<br>&gt;&gt; <br>&gt;&gt;&gt; 	* If the latter, “override” is probably the wrong keyword because it’s not overriding anything in the common case of implementing a non-defaulted requirement.<br>&gt;&gt; <br>&gt;&gt; It would be pointless if it’s just satisfying a requirement. That’s why  introduced both keywords into the discussion. (And because I’m still being influenced by the “near miss” conversation.)<br>&gt;&gt; <br>&gt; <br>&gt; One could always argue that should protocol definitions ever be allowed to contain default implementations ala-java default methods,<br></p><p>I fully expect this will happen someday. It would have happened when protocol extensions were introduced except that the implementation was a bit more involved than we had time for.<br></p><p><br>&gt; the distinction between former and latter would go away, and it would be happy anticipation to have mandated *override* all along in all cases, ensuring that future default methods would not accidentally take precedence of current code or wind up being treated differently than other overrides.<br></p><p>Please spell out the scenario you are talking about.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/3af5a680/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 10:00:00am</p></header><div class="content"><p>Draft. Criticism and suggestions both welcome. -- E<br></p><p>Requiring Proactive Overrides for Default Protocol Implementations<br></p><p>Proposal: tbd<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: tbd<br>Review manager: tbd<br> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;Introduction<br></p><p>This proposal enhances protocol implementation safety. It incorporates two keywords that cooperate with compiler checks to limit &quot;near miss&quot; implementation errors and accidental member overrides.<br></p><p>This proposal was discussed on the Swift Evolution list in the [Pitch] Requiring proactive overrides for default protocol implementations. &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread<br></p><p> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;Motivation<br></p><p>The proposal introduces a mandatory required keyword that marks members as fulfiling protocol requirements. This expansion reduces the risk of near-miss implementations (for example, adding thud(x: Double) when thud(x: Float)is required), provides in-line documentation of why the member has been included, thereby enhancing the code-level documentation at the implementation point, and supports compile-time checks for protocol conformance.<br></p><p>This proposal extends the override keyword to protocol conformance. The Swift Programming Language describes the way subclass methods must override implementations established in superclasses. Methods on a subclass that override the superclass’s implementation are marked with *override*—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br></p><p>Adding an override requirement expands this cautious approach to protocols. Developers must override implementations inherited from protocol extensions with the override keyword. And the compiler will flag uses of override where member implementations do not, in fact, override an existing implementation. The keyword prevents accidental overrides, where a sensible member name conflicts with signatures established in the protocol conformance and forces users to proactively select a version in favor of existing protocol extensions.<br></p><p> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail Design<br></p><p>The override keyword is extended to protocol inheritance, and when used prefers the overridden behavior to the default behavior. <br>Swift will prefer an overridden implementation in preference in reverse hierarchical order: type extensions take precedence over type declarations over protocol extensions over protocol declarations (assuming protocol declarations eventually adopt default implementations).<br>The required keyword marks a member as satisfying a protocol requirement, whether in protocol extensions, type declarations, or type extensions.<br> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required Protocol Members<br></p><p>Protocol requirements are marked with required for compile-time checks of intentional conformance.<br></p><p>protocol A { <br>    func foo() <br>    func bar()<br>    func blort()<br>    func gar()<br>}<br></p><p>extension A {<br>    required func blort() {} // Correct, required by `A`<br>    func womble() {} // Correct, new method in extension<br>    func gar() {} // Incorrect: Compiler says: add `required` keyword or remove implementation<br>}<br></p><p>struct B: A {<br>    required func foo() {} // Correct<br>    required func far() {} // Near miss. Compiler: rename method or drop required keyword<br>    func bar() {} // Possible accidental name match. Compiler: rename method or add required keyword<br>}<br> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member Overrides<br></p><p>Overrides are marked with override to ensure intent.<br></p><p>protocol A { <br>    func foo() <br>    func bar()<br>    func blort()<br>    func gar()<br>}<br></p><p>extension A {<br>    required func foo() {} // correct<br>    func womble() {} // correct<br>}<br></p><p>struct B: A {<br>    required func bar() {} // correct<br>    required func foo() {} // incorrect: Compiler says: add `override` keyword or remove implementation<br>     func womble() {} // incorrect: Compiler says add `override` keyword or remove implementation. `required` is not needed as `womble` is not a required protocol member.<br>}<br> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling Changes<br></p><p>Default implementations can be added or removed at any time, as can type conformance implementations:<br></p><p>**Original**	**Change**	**Outcome**<br>Some member implemented in type	Protocol adds that member	Must add `required` to type implementation or rename member to avoid conflict<br>Some member implemented in type, marked as `required`	Protocol removes that member or it never existed	Must remove `required` from type implementation<br>Some member implemented in type, marked as `override`	Protocol extension removes that member or it never existed	Must remove `override` from type implementation<br>Some member implemented in typed, member not mentioned in protocol	Extension adds default version of member	Type implementation must add `override` keyword<br>`required` member implemented in type	Default member added	Must add `override` or remove type implementation<br>`override required` member implemented in type	Remove default member	Must remove `override` in type implementation<br>`override required` member implemented in type	Remove type member implementation	Default implementation now used<br>Type member uses `required` keyword	Protocol removes requirement or never had it	Type implementation must remove `required` keyword<br>Protocol declares required member	Extension implements default implementation	Extension must add `required` keyword, differentiating default implementations from added behavior<br>Swift adds default implementations to protocols as well as extensions	Protocol adds default implementation	Type implementation must use both `required` and `override` keywords. Protocol extension must use `override` keyword. Order of preference goes: overriden member, overriden extension, protocol default implementation<br> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple Conformance Conflict<br></p><p>Consider the following situation. For the sake of future-proofing, this example includes default protocol implementations although they do not yet exist in Swift.<br></p><p>protocol A { func foo() {...default...} }<br>protocol B { func foo() {...default...} }<br>extension A { override required func foo() {...A extension...} }<br>Type CType: A, B {}<br>In this example, the compiler emits a warning that &quot;CType cannot unambiguously differentiate which version of foo to use for CType instances&quot;. If the CType type were to be removed or either of its conformances erased, there would be no compiler issues.<br></p><p>To fix this scenario, CType must implement a version of foo that resolves the conflict:<br></p><p>Type CType: A, B { override required func foo() { <br>    // either<br>    A.foo(self)() // uses the A extension default implementation<br>    // or<br>    B.foo(self)() // uses the B protocol default implementation<br>    // or both, one after the other, etc.<br>}<br>In this rewrite, foo is unambiguously referenced for CType instance members.<br></p><p> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>These changes introduce mandates that do not exist in today&#39;s Swift code and will require migration. The migrator (and compiler) must detect both scenarios: that a member satisfies a protocol requirement and needs the required keyword, and that a member overrides a default implementation (in current Swift, only in extensions) and needs the overridekeyword.<br></p><p>In the degenerate case that protocol extensions provide two distinct default implementations of the same member (whether required or not), the override version should always be preferred. When multiple override versions exist, the compiler should emit a warning about ambiguous resolution.<br></p><p>Using type currying, e.g. A.foo(self) should always resolve using the rules enumerated earlier in this proposal, moving from type extensions to types to protocol extension to protocols.<br></p><p> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives Considered<br></p><p>Not at this time.<br></p><p> &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements and Thanks<br></p><p>Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br></p><p><br></p><p><br>&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/343425dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>How is retroactive modeling accommodated in this scheme? Say I want to<br>conform three types I don&#39;t own to a protocol of my design and supply a<br>default implementation for a protocol requirement. How would I go about it?<br>On Thu, Apr 28, 2016 at 11:53 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Draft. Criticism and suggestions both welcome. -- E<br>&gt;<br>&gt; Requiring Proactive Overrides for Default Protocol Implementations<br>&gt;<br>&gt;    - Proposal: tbd<br>&gt;    - Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: tbd<br>&gt;    - Review manager: tbd<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal enhances protocol implementation safety. It incorporates two<br>&gt; keywords that cooperate with compiler checks to limit &quot;near miss&quot;<br>&gt; implementation errors and accidental member overrides.<br>&gt;<br>&gt; *This proposal was discussed on the Swift Evolution list in the [Pitch]<br>&gt; Requiring proactive overrides for default protocol implementations.<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread*<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The proposal introduces a mandatory required keyword that marks members<br>&gt; as fulfiling protocol requirements. This expansion reduces the risk of<br>&gt; near-miss implementations (for example, adding thud(x: Double) when thud(x:<br>&gt; Float)is required), provides in-line documentation of why the member has<br>&gt; been included, thereby enhancing the code-level documentation at the<br>&gt; implementation point, and supports compile-time checks for protocol<br>&gt; conformance.<br>&gt;<br>&gt; This proposal extends the override keyword to protocol conformance. The<br>&gt; Swift Programming Language describes the way subclass methods must override<br>&gt; implementations established in superclasses. *Methods on a subclass that<br>&gt; override the superclass’s implementation are marked with **override**—overriding<br>&gt; a method by accident, without override, is detected by the compiler as an<br>&gt; error. The compiler also detects methods with override that don’t actually<br>&gt; override any method in the superclass.*<br>&gt;<br>&gt; Adding an override requirement expands this cautious approach to<br>&gt; protocols. Developers must override implementations inherited from protocol<br>&gt; extensions with the override keyword. And the compiler will flag uses of<br>&gt; override where member implementations do not, in fact, override an<br>&gt; existing implementation. The keyword prevents accidental overrides, where a<br>&gt; sensible member name conflicts with signatures established in the protocol<br>&gt; conformance and forces users to proactively select a version in favor of<br>&gt; existing protocol extensions.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail<br>&gt; Design<br>&gt;<br>&gt;    - The override keyword is extended to protocol inheritance, and when<br>&gt;    used prefers the overridden behavior to the default behavior.<br>&gt;    - Swift will prefer an overridden implementation in preference in<br>&gt;    reverse hierarchical order: type extensions take precedence over type<br>&gt;    declarations over protocol extensions over protocol declarations (assuming<br>&gt;    protocol declarations eventually adopt default implementations).<br>&gt;    - The required keyword marks a member as satisfying a protocol<br>&gt;    requirement, whether in protocol extensions, type declarations, or type<br>&gt;    extensions.<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required<br>&gt; Protocol Members<br>&gt;<br>&gt; Protocol requirements are marked with required for compile-time checks of<br>&gt; intentional conformance.<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt;     func bar()<br>&gt;     func blort()<br>&gt;     func gar()<br>&gt; }<br>&gt; extension A {<br>&gt;     required func blort() {} // Correct, required by `A`<br>&gt;     func womble() {} // Correct, new method in extension<br>&gt;     func gar() {} // Incorrect: Compiler says: add `required` keyword or remove implementation<br>&gt; }<br>&gt; struct B: A {<br>&gt;     required func foo() {} // Correct<br>&gt;     required func far() {} // Near miss. Compiler: rename method or drop required keyword<br>&gt;     func bar() {} // Possible accidental name match. Compiler: rename method or add required keyword<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member<br>&gt; Overrides<br>&gt;<br>&gt; Overrides are marked with override to ensure intent.<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt;     func bar()<br>&gt;     func blort()<br>&gt;     func gar()<br>&gt; }<br>&gt; extension A {<br>&gt;     required func foo() {} // correct<br>&gt;     func womble() {} // correct<br>&gt; }<br>&gt; struct B: A {<br>&gt;     required func bar() {} // correct<br>&gt;     required func foo() {} // incorrect: Compiler says: add `override` keyword or remove implementation<br>&gt;      func womble() {} // incorrect: Compiler says add `override` keyword or remove implementation. `required` is not needed as `womble` is not a required protocol member.<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling<br>&gt; Changes<br>&gt;<br>&gt; Default implementations can be added or removed at any time, as can type<br>&gt; conformance implementations:<br>&gt; **Original** **Change** **Outcome**<br>&gt; Some member implemented in type Protocol adds that member Must add<br>&gt; `required` to type implementation or rename member to avoid conflict<br>&gt; Some member implemented in type, marked as `required` Protocol removes<br>&gt; that member or it never existed Must remove `required` from type<br>&gt; implementation<br>&gt; Some member implemented in type, marked as `override` Protocol extension<br>&gt; removes that member or it never existed Must remove `override` from type<br>&gt; implementation<br>&gt; Some member implemented in typed, member not mentioned in protocol Extension<br>&gt; adds default version of member Type implementation must add `override`<br>&gt; keyword<br>&gt; `required` member implemented in type Default member added Must add<br>&gt; `override` or remove type implementation<br>&gt; `override required` member implemented in type Remove default member Must<br>&gt; remove `override` in type implementation<br>&gt; `override required` member implemented in type Remove type member<br>&gt; implementation Default implementation now used<br>&gt; Type member uses `required` keyword Protocol removes requirement or never<br>&gt; had it Type implementation must remove `required` keyword<br>&gt; Protocol declares required member Extension implements default<br>&gt; implementation Extension must add `required` keyword, differentiating<br>&gt; default implementations from added behavior<br>&gt; Swift adds default implementations to protocols as well as extensions Protocol<br>&gt; adds default implementation Type implementation must use both `required`<br>&gt; and `override` keywords. Protocol extension must use `override` keyword.<br>&gt; Order of preference goes: overriden member, overriden extension, protocol<br>&gt; default implementation<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple<br>&gt; Conformance Conflict<br>&gt;<br>&gt; Consider the following situation. For the sake of future-proofing, this<br>&gt; example includes default protocol implementations although they do not yet<br>&gt; exist in Swift.<br>&gt;<br>&gt; protocol A { func foo() {...default...} }protocol B { func foo() {...default...} }extension A { override required func foo() {...A extension...} }Type CType: A, B {}<br>&gt;<br>&gt; In this example, the compiler emits a warning that &quot;CType cannot<br>&gt; unambiguously differentiate which version of foo to use for CType instances&quot;.<br>&gt; If the CType type were to be removed or either of its conformances erased,<br>&gt; there would be no compiler issues.<br>&gt;<br>&gt; To fix this scenario, CType must implement a version of foo that resolves<br>&gt; the conflict:<br>&gt;<br>&gt; Type CType: A, B { override required func foo() {<br>&gt;     // either<br>&gt;     A.foo(self)() // uses the A extension default implementation<br>&gt;     // or<br>&gt;     B.foo(self)() // uses the B protocol default implementation<br>&gt;     // or both, one after the other, etc.<br>&gt; }<br>&gt;<br>&gt; In this rewrite, foo is unambiguously referenced for CType instance<br>&gt; members.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; These changes introduce mandates that do not exist in today&#39;s Swift code<br>&gt; and will require migration. The migrator (and compiler) must detect both<br>&gt; scenarios: that a member satisfies a protocol requirement and needs the<br>&gt; required keyword, and that a member overrides a default implementation<br>&gt; (in current Swift, only in extensions) and needs the overridekeyword.<br>&gt;<br>&gt; In the degenerate case that protocol extensions provide two distinct<br>&gt; default implementations of the same member (whether required or not), the<br>&gt; override version should always be preferred. When multiple override versions<br>&gt; exist, the compiler should emit a warning about ambiguous resolution.<br>&gt;<br>&gt; Using type currying, e.g. A.foo(self) should always resolve using the<br>&gt; rules enumerated earlier in this proposal, moving from type extensions to<br>&gt; types to protocol extension to protocols.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt; Not at this time.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements<br>&gt; and Thanks<br>&gt; Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/81b64810/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; <br>&gt; On Apr 28, 2016, at 11:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; How is retroactive modeling accommodated in this scheme? Say I want to conform three types I don&#39;t own to a protocol of my design and supply a default implementation for a protocol requirement. How would I go about it?<br></p><p>extension NotMyType: ProtocolIdesigned {...}<br></p><p>extension NotMyProtocol {<br>     required func method1() {...}<br>     override required func method2() {...} // assumes NMP has already provided default<br>     func newThing() {...}<br>}<br></p><p>The only tricky bit is when NotMyProtocol already has a default required func implementation and an override required func implementation (although that should be rare). In such case, you probably have to create a new protocol DerivedProtocol: NotMyProtocol and work from there. The override in the DerivedProtocol will then take priority over the override in NotMyProtocol.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 12:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016 at 12:25 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; &gt;<br>&gt; &gt; On Apr 28, 2016, at 11:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; How is retroactive modeling accommodated in this scheme? Say I want to<br>&gt; conform three types I don&#39;t own to a protocol of my design and supply a<br>&gt; default implementation for a protocol requirement. How would I go about it?<br>&gt;<br>&gt; extension NotMyType: ProtocolIdesigned {...}<br>&gt;<br>&gt; extension NotMyProtocol {<br>&gt;      required func method1() {...}<br>&gt;      override required func method2() {...} // assumes NMP has already<br>&gt; provided default<br>&gt;      func newThing() {...}<br>&gt; }<br>&gt;<br>&gt; The only tricky bit is when NotMyProtocol already has a default required<br>&gt; func implementation and an override required func implementation (although<br>&gt; that should be rare). In such case, you probably have to create a new<br>&gt; protocol DerivedProtocol: NotMyProtocol and work from there. The override<br>&gt; in the DerivedProtocol will then take priority over the override in<br>&gt; NotMyProtocol.<br>&gt;<br></p><p>Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own.<br>Let me restate. Given three types I don&#39;t own as follows:<br></p><p>```<br>struct A {<br>    func frobnicate() { print(&quot;A&quot;) }<br>}<br>struct B {<br>    func frobnicate() { print(&quot;B&quot;) }<br>}<br>struct C { }<br>```<br></p><p>I want to conform them to a protocol of my own design, Frobnicatable, and<br>supply a default `frobnicate()`:<br></p><p>```<br>protocol Frobnicatable {<br>    func frobnicate()<br>}<br>extension Frobnicatable {<br>    func frobnicate() { print(&quot;Default&quot;) }<br>}<br>extension A: Frobnicatable { }<br>extension B: Frobnicatable { }<br>extension C: Frobnicatable { }<br></p><p>let c = C()<br>c.frobnicate() // &quot;Default&quot;<br>```<br></p><p>(Yes, I realize there are issues regarding static and dynamic dispatch that<br>limit the utility of this particular example--let&#39;s leave those aside for<br>now.)<br>Where would I affix keywords such as `required` and `override` to make this<br>work after implementation of your proposal?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/6c421d2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>I&#39;m glad you brought this up and provided a clear example Xiaodi.<br></p><p>Erica, as I mentioned a few days ago (and Dave A gave +1) this proposal cannot break retroactive modeling if it is going to fly.  Can you please update it to clarify how you envision it interacts with retroactive modeling?  Would these new keywords only be required when the conformance is declared in the same module as the method? <br></p><p>Sent from my iPad<br></p><p>&gt; On Apr 28, 2016, at 12:48 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Thu, Apr 28, 2016 at 12:25 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Apr 28, 2016, at 11:05 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; How is retroactive modeling accommodated in this scheme? Say I want to conform three types I don&#39;t own to a protocol of my design and supply a default implementation for a protocol requirement. How would I go about it?<br>&gt;&gt; <br>&gt;&gt; extension NotMyType: ProtocolIdesigned {...}<br>&gt;&gt; <br>&gt;&gt; extension NotMyProtocol {<br>&gt;&gt;      required func method1() {...}<br>&gt;&gt;      override required func method2() {...} // assumes NMP has already provided default<br>&gt;&gt;      func newThing() {...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The only tricky bit is when NotMyProtocol already has a default required func implementation and an override required func implementation (although that should be rare). In such case, you probably have to create a new protocol DerivedProtocol: NotMyProtocol and work from there. The override in the DerivedProtocol will then take priority over the override in NotMyProtocol.<br>&gt; <br>&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt; <br>&gt; ```<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt; <br>&gt; I want to conform them to a protocol of my own design, Frobnicatable, and supply a default `frobnicate()`:<br>&gt; <br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt; <br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt; <br>&gt; (Yes, I realize there are issues regarding static and dynamic dispatch that limit the utility of this particular example--let&#39;s leave those aside for now.)<br>&gt; Where would I affix keywords such as `required` and `override` to make this work after implementation of your proposal?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/e99292dd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br></p><p>```<br>struct A : Frobnicate {<br>    override required func frobnicate() { print(&quot;A&quot;) } // &quot;A&quot;, or delete to get default<br>}<br>struct B: Frobnicate {<br>    override required func frobnicate() { print(&quot;B&quot;) } // &quot;B&quot;, or delete to get default<br>}<br>struct C: Frobnicate  { }<br>```<br></p><p>-- E<br></p><p><br>&gt; On Apr 28, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt; <br>&gt; ```<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt; <br>&gt; I want to conform them to a protocol of my own design, Frobnicatable, and supply a default `frobnicate()`:<br>&gt; <br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt; <br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt; <br>&gt; (Yes, I realize there are issues regarding static and dynamic dispatch that limit the utility of this particular example--let&#39;s leave those aside for now.)<br>&gt; Where would I affix keywords such as `required` and `override` to make this work after implementation of your proposal?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/b3d9af95/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 28, 2016, at 1:09 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt; <br>&gt; ```<br>&gt; struct A : Frobnicate {<br>&gt;     override required func frobnicate() { print(&quot;A&quot;) } // &quot;A&quot;, or delete to get default<br>&gt; }<br>&gt; struct B: Frobnicate {<br>&gt;     override required func frobnicate() { print(&quot;B&quot;) } // &quot;B&quot;, or delete to get default<br>&gt; }<br>&gt; struct C: Frobnicate  { }<br>&gt; ```<br>&gt; <br>We can&#39;t add the keywords if the structs are defined in a module we import but don&#39;t own.  We are only declaring the conformance retroactively.  The ability to do this is a crucial aspect of generic programming.  It isn&#39;t yet clear how your proposal handles retroactive modeling.<br></p><p>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; struct A {<br>&gt;&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt;&gt; }<br>&gt;&gt; struct B {<br>&gt;&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt;&gt; }<br>&gt;&gt; struct C { }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I want to conform them to a protocol of my own design, Frobnicatable, and supply a default `frobnicate()`:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; protocol Frobnicatable {<br>&gt;&gt;     func frobnicate()<br>&gt;&gt; }<br>&gt;&gt; extension Frobnicatable {<br>&gt;&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt;&gt; }<br>&gt;&gt; extension A: Frobnicatable { }<br>&gt;&gt; extension B: Frobnicatable { }<br>&gt;&gt; extension C: Frobnicatable { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; c.frobnicate() // &quot;Default&quot;<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; (Yes, I realize there are issues regarding static and dynamic dispatch that limit the utility of this particular example--let&#39;s leave those aside for now.)<br>&gt;&gt; Where would I affix keywords such as `required` and `override` to make this work after implementation of your proposal?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/b4fad8c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Right, sorry, I should have clarified. The scenario to be supported here is<br>that the code for structs A, B, and C cannot be modified. They could be<br>part of the stdlib, for example, or a closed-source third-party library.<br></p><p><br>On Thu, Apr 28, 2016 at 1:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Apr 28, 2016, at 1:09 PM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t<br>&gt; own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt;<br>&gt; ```<br>&gt; struct A : Frobnicate {<br>&gt;     override required func frobnicate() { print(&quot;A&quot;) } // &quot;A&quot;, or delete<br>&gt; to get default<br>&gt; }<br>&gt; struct B: Frobnicate {<br>&gt;     override required func frobnicate() { print(&quot;B&quot;) } // &quot;B&quot;, or delete<br>&gt; to get default<br>&gt; }<br>&gt; struct C: Frobnicate  { }<br>&gt; ```<br>&gt;<br>&gt; We can&#39;t add the keywords if the structs are defined in a module we import<br>&gt; but don&#39;t own.  We are only declaring the conformance retroactively.  The<br>&gt; ability to do this is a crucial aspect of generic programming.  It isn&#39;t<br>&gt; yet clear how your proposal handles retroactive modeling.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On Apr 28, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t<br>&gt; own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt;<br>&gt; ```<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt;<br>&gt; I want to conform them to a protocol of my own design, Frobnicatable, and<br>&gt; supply a default `frobnicate()`:<br>&gt;<br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt;<br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt;<br>&gt; (Yes, I realize there are issues regarding static and dynamic dispatch<br>&gt; that limit the utility of this particular example--let&#39;s leave those aside<br>&gt; for now.)<br>&gt; Where would I affix keywords such as `required` and `override` to make<br>&gt; this work after implementation of your proposal?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/5630611d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 12:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; We can&#39;t add the keywords if the structs are defined in a module we import but don&#39;t own.  We are only declaring the conformance retroactively.  The ability to do this is a crucial aspect of generic programming.  It isn&#39;t yet clear how your proposal handles retroactive modeling.<br></p><p>These are compile-time checks and should not affect compiled code.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/182b1530/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 28, 2016, at 5:49 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 12:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; We can&#39;t add the keywords if the structs are defined in a module we import but don&#39;t own.  We are only declaring the conformance retroactively.  The ability to do this is a crucial aspect of generic programming.  It isn&#39;t yet clear how your proposal handles retroactive modeling.<br>&gt; <br>&gt; These are compile-time checks and should not affect compiled code.<br></p><p>Does that mean the conformance declaration will be accepted by the compiler under your proposal?  I would really like to see this called out explicitly in the proposal.<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/393781bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>It is a good idea to explicitly document the behaviour that this<br>requirement for override is a compile time check only and does not mean<br>that already compiled code has to be recompiled to allow a protocol to be<br>retroactively fitted to an already compiled type.<br></p><p>On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Apr 28, 2016, at 5:49 PM, Erica Sadun &lt;erica at ericasadun.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;erica at ericasadun.com&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Apr 28, 2016, at 12:18 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;matthew at anandabits.com&#39;);&gt;&gt; wrote:<br>&gt; We can&#39;t add the keywords if the structs are defined in a module we import<br>&gt; but don&#39;t own.  We are only declaring the conformance retroactively.  The<br>&gt; ability to do this is a crucial aspect of generic programming.  It isn&#39;t<br>&gt; yet clear how your proposal handles retroactive modeling.<br>&gt;<br>&gt;<br>&gt; These are compile-time checks and should not affect compiled code.<br>&gt;<br>&gt;<br>&gt; Does that mean the conformance declaration will be accepted by the<br>&gt; compiler under your proposal?  I would really like to see this called out<br>&gt; explicitly in the proposal.<br>&gt;<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br></p><p>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/1e28dd94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>On Apr 28, 2016, at 5:09 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; It is a good idea to explicitly document the behaviour that this requirement for override is a compile time check only and does not mean that already compiled code has to be recompiled to allow a protocol to be retroactively fitted to an already compiled type.<br>&gt; <br></p><p>At this time, default protocol implementations do not exist.<br></p><p>At compilation time, either a protocol default exists or it does not. The goal of this proposal is to increase safety through syntax. <br></p><p>What is the current behavior where a subclass is pre-compiled and the superclass then changes through an extension to implement a member that the already compiled subclass had implemented but not as an override?<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Does that mean the conformance declaration will be accepted by the compiler under your proposal?  I would really like to see this called out explicitly in the proposal.<br></p><p>I&#39;m making live updates at the gist in response to on-list discussions:<br></p><p>https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a&gt;<br></p><p>If you have specific suggestions for modifications, I&#39;ll be happy to evaluate for incorporation.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/89fadb91/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 06:00:00pm</p></header><div class="content"><p>Why allow both `override` and `required`? I understand you mean it to<br>indicate that you&#39;re overriding a requirement, but does that provide any<br>additional safety? Both say &quot;I intend to name something the same as<br>something else.&quot;<br></p><p>In addition, the juxtaposition of both keywords can be misunderstood.<br>Specifically: required suggests that something not otherwise there must be<br>there. Override suggests that there&#39;s already something there. The act of<br>overriding can never itself be &quot;required.&quot; It&#39;s could be thought of as an<br>oxymoron to have both, no?<br></p><p>On Thu, Apr 28, 2016 at 6:20 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Does that mean the conformance declaration will be accepted by the<br>&gt;&gt; compiler under your proposal?  I would really like to see this called out<br>&gt;&gt; explicitly in the proposal.<br>&gt;&gt;<br>&gt;<br>&gt; I&#39;m making live updates at the gist in response to on-list discussions:<br>&gt;<br>&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt;<br>&gt; If you have specific suggestions for modifications, I&#39;ll be happy to<br>&gt; evaluate for incorporation.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/4a6695f4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 28, 2016 at 06:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 28, 2016, at 6:20 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Does that mean the conformance declaration will be accepted by the compiler under your proposal?  I would really like to see this called out explicitly in the proposal.<br>&gt; <br>&gt; I&#39;m making live updates at the gist in response to on-list discussions:<br>&gt; <br>&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt; <br>&gt; If you have specific suggestions for modifications, I&#39;ll be happy to evaluate for incorporation.<br></p><p>Unfortunately I don&#39;t have specific suggestions as there are flaws with all of the approaches I can think of.  However, I do think *something* needs to be specified regarding behavior when retroactively conforming a type from a different module which doesn&#39;t know anything about the protocol but does implement the requirements (as normal methods).  I can&#39;t determine how I feel about this proposal without seeing it clearly specified.<br></p><p><br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/e988c578/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;m not sure that I&#39;m entirely happy with this distinction between already<br>compiled types and ones that have not yet been compiled. It&#39;s a common<br>Swift idiom to implement protocol requirements in extensions, which<br>encourages a kind of modularity, if you will. Every so often (and maybe<br>this isn&#39;t best practice), I incorporate third-party code into a project in<br>source form and not as a compiled library (with attribution, and in<br>compliance with the license, etc., obviously). Often these are little<br>snippets, perhaps useful helper functions or types. The beauty of<br>extensions is that I can extend these as necessary without touching the<br>original code. The point is, here one would not be able to implement<br>certain things in that way if this proposal is adopted. To say that the<br>workaround is just editing the original code is deeply unsatisfying,<br>because it would be equally valid to say that the same workaround applies<br>to stripping out extensions altogether for non-imported types.<br></p><p><br>On Thu, Apr 28, 2016 at 6:09 PM, Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It is a good idea to explicitly document the behaviour that this<br>&gt; requirement for override is a compile time check only and does not mean<br>&gt; that already compiled code has to be recompiled to allow a protocol to be<br>&gt; retroactively fitted to an already compiled type.<br>&gt;<br>&gt;<br>&gt; On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Apr 28, 2016, at 5:49 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 28, 2016, at 12:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; We can&#39;t add the keywords if the structs are defined in a module we<br>&gt;&gt; import but don&#39;t own.  We are only declaring the conformance<br>&gt;&gt; retroactively.  The ability to do this is a crucial aspect of generic<br>&gt;&gt; programming.  It isn&#39;t yet clear how your proposal handles retroactive<br>&gt;&gt; modeling.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; These are compile-time checks and should not affect compiled code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Does that mean the conformance declaration will be accepted by the<br>&gt;&gt; compiler under your proposal?  I would really like to see this called out<br>&gt;&gt; explicitly in the proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; --<br>&gt; -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/f40c5402/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Can you give me a specific example of where this approach fails for you?<br></p><p>-- E<br></p><p><br>&gt; On Apr 28, 2016, at 5:24 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m not sure that I&#39;m entirely happy with this distinction between already compiled types and ones that have not yet been compiled. It&#39;s a common Swift idiom to implement protocol requirements in extensions, which encourages a kind of modularity, if you will. Every so often (and maybe this isn&#39;t best practice), I incorporate third-party code into a project in source form and not as a compiled library (with attribution, and in compliance with the license, etc., obviously). Often these are little snippets, perhaps useful helper functions or types. The beauty of extensions is that I can extend these as necessary without touching the original code. The point is, here one would not be able to implement certain things in that way if this proposal is adopted. To say that the workaround is just editing the original code is deeply unsatisfying, because it would be equally valid to say that the same workaround applies to stripping out extensions altogether for non-imported types.<br>&gt; <br>&gt; <br>&gt; On Thu, Apr 28, 2016 at 6:09 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It is a good idea to explicitly document the behaviour that this requirement for override is a compile time check only and does not mean that already compiled code has to be recompiled to allow a protocol to be retroactively fitted to an already compiled type.<br>&gt; <br>&gt; <br>&gt; On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Apr 28, 2016, at 5:49 PM, Erica Sadun &lt;erica at ericasadun.com &lt;&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 28, 2016, at 12:18 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;&gt;&gt; wrote:<br>&gt;&gt;&gt; We can&#39;t add the keywords if the structs are defined in a module we import but don&#39;t own.  We are only declaring the conformance retroactively.  The ability to do this is a crucial aspect of generic programming.  It isn&#39;t yet clear how your proposal handles retroactive modeling.<br>&gt;&gt; <br>&gt;&gt; These are compile-time checks and should not affect compiled code.<br>&gt; <br>&gt; Does that mean the conformance declaration will be accepted by the compiler under your proposal?  I would really like to see this called out explicitly in the proposal.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/88318c79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016 at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; Can you give me a specific example of where this approach fails for you?<br>&gt;<br>&gt; -- E<br>&gt;<br></p><p><br>Sure, I&#39;ll describe one (renaming some things for clarity and stripping out<br>the meat of the code, because it&#39;s not relevant and because it&#39;s not<br>elegant)--<br></p><p>In one file, I have:<br></p><p>```<br>class PortedTransfom {<br>// this class was ported from C++<br>// it transforms input FP values to output values in a complicated way<br>// it&#39;s a standalone entity and the algorithm is even under patent<br>// (not owned by me, though it&#39;s legal for me to use it for my purposes)<br>// for this reason, this ported code lives in its own file<br>}<br>```<br></p><p>In another file, I have:<br></p><p>```<br>class MyAsinhTransform {<br>// this class was written by me<br>// nothing earth-shattering here<br>}<br></p><p>class MyLogTransform {<br>// also written by me<br>}<br></p><p>class MyLinearTransform {<br>// also written by me<br>}<br>```<br></p><p>Transforming values one-at-a-time isn&#39;t fast enough, so in another file, I<br>have:<br></p><p>```<br>import Accelerate<br></p><p>protocol AcceleratedTransform {<br>  func scale(_: [Double]) -&gt; [Double]<br>  func unscale(_: [Double]) -&gt; [Double]<br>// other functions here<br>// some are already implemented in PortedTransform, though<br>}<br>extension AcceleratedTransform {<br>// default implementations for some functions<br>// but not `scale(_:)` and `unscale(_:)`, obviously<br>}<br></p><p>extension MyAsinhTransform : AcceleratedTransform {<br>// use BLAS to implement scale(_:) and unscale(_:)<br>// and override some default implementations<br>}<br></p><p>extension MyLogTransform : AcceleratedTransform {<br>// use BLAS to implement scale(_:) and unscale(_:)<br>// and override some default implementations<br>}<br></p><p>extension  MyLinearTransform : AcceleratedTransform {<br>// use BLAS to implement scale(_:) and unscale(_:)<br>// and override some default implementations<br>}<br></p><p>extension PortedTransform : AcceleratedTransform {<br>// use BLAS to implement scale(_:) and unscale(_:)<br>}<br>```<br></p><p>On Apr 28, 2016, at 5:24 PM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;m not sure that I&#39;m entirely happy with this distinction between already<br>&gt; compiled types and ones that have not yet been compiled. It&#39;s a common<br>&gt; Swift idiom to implement protocol requirements in extensions, which<br>&gt; encourages a kind of modularity, if you will. Every so often (and maybe<br>&gt; this isn&#39;t best practice), I incorporate third-party code into a project in<br>&gt; source form and not as a compiled library (with attribution, and in<br>&gt; compliance with the license, etc., obviously). Often these are little<br>&gt; snippets, perhaps useful helper functions or types. The beauty of<br>&gt; extensions is that I can extend these as necessary without touching the<br>&gt; original code. The point is, here one would not be able to implement<br>&gt; certain things in that way if this proposal is adopted. To say that the<br>&gt; workaround is just editing the original code is deeply unsatisfying,<br>&gt; because it would be equally valid to say that the same workaround applies<br>&gt; to stripping out extensions altogether for non-imported types.<br>&gt;<br>&gt;<br>&gt; On Thu, Apr 28, 2016 at 6:09 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; It is a good idea to explicitly document the behaviour that this<br>&gt;&gt; requirement for override is a compile time check only and does not mean<br>&gt;&gt; that already compiled code has to be recompiled to allow a protocol to be<br>&gt;&gt; retroactively fitted to an already compiled type.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Friday, 29 April 2016, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 28, 2016, at 5:49 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Apr 28, 2016, at 12:18 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; We can&#39;t add the keywords if the structs are defined in a module we<br>&gt;&gt;&gt; import but don&#39;t own.  We are only declaring the conformance<br>&gt;&gt;&gt; retroactively.  The ability to do this is a crucial aspect of generic<br>&gt;&gt;&gt; programming.  It isn&#39;t yet clear how your proposal handles retroactive<br>&gt;&gt;&gt; modeling.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These are compile-time checks and should not affect compiled code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Does that mean the conformance declaration will be accepted by the<br>&gt;&gt;&gt; compiler under your proposal?  I would really like to see this called out<br>&gt;&gt;&gt; explicitly in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; -- Howard.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/2014e415/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 6:20 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Thu, Apr 28, 2016 at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; Can you give me a specific example of where this approach fails for you?<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; Sure, I&#39;ll describe one (renaming some things for clarity and stripping out the meat of the code, because it&#39;s not relevant and because it&#39;s not elegant)--<br>&gt; <br>&gt; In one file, I have:<br>&gt; <br>&gt; ```<br>&gt; class PortedTransfom {<br>&gt; // this class was ported from C++<br>&gt; // it transforms input FP values to output values in a complicated way<br>&gt; // it&#39;s a standalone entity and the algorithm is even under patent<br>&gt; // (not owned by me, though it&#39;s legal for me to use it for my purposes)<br>&gt; // for this reason, this ported code lives in its own file<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; In another file, I have:<br>&gt; <br>&gt; ```<br>&gt; class MyAsinhTransform {<br>&gt; // this class was written by me<br>&gt; // nothing earth-shattering here<br>&gt; }<br>&gt; <br>&gt; class MyLogTransform {<br>&gt; // also written by me<br>&gt; }<br>&gt; <br>&gt; class MyLinearTransform {<br>&gt; // also written by me<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; Transforming values one-at-a-time isn&#39;t fast enough, so in another file, I have:<br>&gt; <br>&gt; ```<br>&gt; import Accelerate<br>&gt; <br>&gt; protocol AcceleratedTransform {<br>&gt;   func scale(_: [Double]) -&gt; [Double]<br>&gt;   func unscale(_: [Double]) -&gt; [Double]<br>&gt; // other functions here<br>&gt; // some are already implemented in PortedTransform, though<br>&gt; }<br>&gt; extension AcceleratedTransform {<br>&gt; // default implementations for some functions<br>&gt; // but not `scale(_:)` and `unscale(_:)`, obviously<br>&gt; }<br>&gt; <br>&gt; extension MyAsinhTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; // and override some default implementations<br>&gt; }<br>&gt; <br>&gt; extension MyLogTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; // and override some default implementations<br>&gt; }<br>&gt; <br>&gt; extension  MyLinearTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; // and override some default implementations<br>&gt; }<br>&gt; <br>&gt; extension PortedTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; }<br>&gt; ```<br></p><p>I think I&#39;m missing something here in terms of a question.  Your imported stuff is your imported stuff.<br>Your extension implements &quot;required&quot; elements but not scale or unscale.<br></p><p>If you extend MyAsinhTransform, you do required but not override for scale/unscale. You do required override for anything you replace from AcceleratedTransform.<br>What is BLAS? And what are you specifically asking about?<br></p><p>-- E, apologizing for not understanding<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/605b0bae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016 at 8:32 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 28, 2016, at 6:20 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Thu, Apr 28, 2016 at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt; Can you give me a specific example of where this approach fails for you?<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; Sure, I&#39;ll describe one (renaming some things for clarity and stripping<br>&gt; out the meat of the code, because it&#39;s not relevant and because it&#39;s not<br>&gt; elegant)--<br>&gt;<br>&gt; In one file, I have:<br>&gt;<br>&gt; ```<br>&gt; class PortedTransfom {<br>&gt; // this class was ported from C++<br>&gt; // it transforms input FP values to output values in a complicated way<br>&gt; // it&#39;s a standalone entity and the algorithm is even under patent<br>&gt; // (not owned by me, though it&#39;s legal for me to use it for my purposes)<br>&gt; // for this reason, this ported code lives in its own file<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; In another file, I have:<br>&gt;<br>&gt; ```<br>&gt; class MyAsinhTransform {<br>&gt; // this class was written by me<br>&gt; // nothing earth-shattering here<br>&gt; }<br>&gt;<br>&gt; class MyLogTransform {<br>&gt; // also written by me<br>&gt; }<br>&gt;<br>&gt; class MyLinearTransform {<br>&gt; // also written by me<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; Transforming values one-at-a-time isn&#39;t fast enough, so in another file, I<br>&gt; have:<br>&gt;<br>&gt; ```<br>&gt; import Accelerate<br>&gt;<br>&gt; protocol AcceleratedTransform {<br>&gt;   func scale(_: [Double]) -&gt; [Double]<br>&gt;   func unscale(_: [Double]) -&gt; [Double]<br>&gt; // other functions here<br>&gt; // some are already implemented in PortedTransform, though<br>&gt; }<br>&gt; extension AcceleratedTransform {<br>&gt; // default implementations for some functions<br>&gt; // but not `scale(_:)` and `unscale(_:)`, obviously<br>&gt; }<br>&gt;<br>&gt; extension MyAsinhTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; // and override some default implementations<br>&gt; }<br>&gt;<br>&gt; extension MyLogTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; // and override some default implementations<br>&gt; }<br>&gt;<br>&gt; extension  MyLinearTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; // and override some default implementations<br>&gt; }<br>&gt;<br>&gt; extension PortedTransform : AcceleratedTransform {<br>&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; I think I&#39;m missing something here in terms of a question.  Your imported<br>&gt; stuff is your imported stuff.<br>&gt; Your extension implements &quot;required&quot; elements but not scale or unscale.<br>&gt;<br>&gt; If you extend MyAsinhTransform, you do required but not override for<br>&gt; scale/unscale. You do required override for anything you replace from<br>&gt; AcceleratedTransform.<br>&gt; What is BLAS? And what are you specifically asking about?<br>&gt;<br>&gt; -- E, apologizing for not understanding<br>&gt;<br>&gt;<br>Sorry, stripped out a little too much, I guess. Let me expand a little:<br></p><p>In this example, `PortedTransform` has, by virtue of how it works, an upper<br>bound and lower bound for valid input (among other interesting methods and<br>properties). Exceed those bounds for your input and `PortedTransform`<br>regurgitates garbage but does not throw any kind of error. Obviously,<br>linear transform does not care about such silly things because it can<br>transform essentially any FP input value, while the log transform simply<br>traps when it encounters a negative value (which, as a precondition, it<br>should never encounter).<br></p><p>BLAS is an accelerated linear algebra library; Apple has implemented a very<br>nicely optimized one as part of its Accelerate framework. I use BLAS to<br>sum, for example, two arrays of floating point values--it&#39;s very, very<br>highly optimized. In that situation, there&#39;s no trapping when a single<br>value is out of bounds (I get NaNs instead), and thus I must determine<br>bounds in order to anticipate when the output will be garbage or NaN.<br>(There are, as part of the Accelerate framework, accelerated functions to<br>clamp entire arrays to given bounds with maximal efficiency).<br></p><p>For accelerated scaling and unscaling, then, it is essentially always<br>necessary to compute upper and lower bounds even when that&#39;s unnecessary<br>for non-accelerated scaling and unscaling, which operates on one value at a<br>time. For that reason, `AcceleratedTransform` requires methods that compute<br>upper and lower bounds, and provides a default implementation of<br>accelerated clamping that calls those bound-computing methods and then uses<br>the results as parameters when calling functions in Accelerate.framework.<br>Methods for the computation of bounds already exist in `PortedTransform`<br>but not in my own transforms. With your proposal, how would I retroactively<br>model this requirement without touching code for `PortedTransform` and<br>without compiling this one class into its own library? I&#39;d like to be able<br>to take advantage of the maximum possible compiler optimization, and<br>optimizing across module boundaries is (as far as I understand) a little<br>dicier. (Moreover, for MyLinTransform, I override the clamping method to<br>return the input without calling out to any framework functions because I<br>know a priori that the bounds are -infinity and infinity. I think that<br>override will still be possible under your proposal, though.)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/83397212/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>On Apr 28, 2016, at 8:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Sorry, stripped out a little too much, I guess. Let me expand a little:<br>&gt; <br>&gt; In this example, `PortedTransform` has, by virtue of how it works, an upper bound and lower bound for valid input (among other interesting methods and properties). Exceed those bounds for your input and `PortedTransform` regurgitates garbage but does not throw any kind of error. Obviously, linear transform does not care about such silly things because it can transform essentially any FP input value, while the log transform simply traps when it encounters a negative value (which, as a precondition, it should never encounter).<br>&gt; <br>&gt; BLAS is an accelerated linear algebra library; Apple has implemented a very nicely optimized one as part of its Accelerate framework. I use BLAS to sum, for example, two arrays of floating point values--it&#39;s very, very highly optimized. In that situation, there&#39;s no trapping when a single value is out of bounds (I get NaNs instead), and thus I must determine bounds in order to anticipate when the output will be garbage or NaN. (There are, as part of the Accelerate framework, accelerated functions to clamp entire arrays to given bounds with maximal efficiency).<br>&gt; <br>&gt; For accelerated scaling and unscaling, then, it is essentially always necessary to compute upper and lower bounds even when that&#39;s unnecessary for non-accelerated scaling and unscaling, which operates on one value at a time. For that reason, `AcceleratedTransform` requires methods that compute upper and lower bounds, and provides a default implementation of accelerated clamping that calls those bound-computing methods and then uses the results as parameters when calling functions in Accelerate.framework. Methods for the computation of bounds already exist in `PortedTransform` but not in my own transforms. With your proposal, how would I retroactively model this requirement without touching code for `PortedTransform` and without compiling this one class into its own library? I&#39;d like to be able to take advantage of the maximum possible compiler optimization, and optimizing across module boundaries is (as far as I understand) a little dicier. (Moreover, for MyLinTransform, I override the clamping method to return the input without calling out to any framework functions because I know a priori that the bounds are -infinity and infinity. I think that override will still be possible under your proposal, though.)<br></p><p>Without actually trying to understand the details of your math stuff:<br></p><p>* If you add a required member in a declaration or extension that declares conformance, it is &#39;required&#39;. <br>* If it is already defaulted, it is `override required`. <br>* If it is already defaulted but not required, it is `override`<br>* If someone else implements the stuff, you still have to pull it in somehow, but if you do so by conforming to another protocol with an extension, it&#39;s not your business, so you don&#39;t use any keywords.<br></p><p>You use keywords only for stuff that you specifically write, that clarifies the context in which you are writing it. If you do not own a protocol, an extension, or an implementation, you do not change or markup the protocol, extension, or implementation. You&#39;re just offering the compiler hints that your otherwise questionable decisions are fully intentional: when overriding an existing implementation and when conforming by supplying a required member.<br></p><p>-- E, who still probably missed your point and again apologizes<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/6011f419/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016 at 9:25 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; On Apr 28, 2016, at 8:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Sorry, stripped out a little too much, I guess. Let me expand a little:<br>&gt;<br>&gt; In this example, `PortedTransform` has, by virtue of how it works, an<br>&gt; upper bound and lower bound for valid input (among other interesting<br>&gt; methods and properties). Exceed those bounds for your input and<br>&gt; `PortedTransform` regurgitates garbage but does not throw any kind of<br>&gt; error. Obviously, linear transform does not care about such silly things<br>&gt; because it can transform essentially any FP input value, while the log<br>&gt; transform simply traps when it encounters a negative value (which, as a<br>&gt; precondition, it should never encounter).<br>&gt;<br>&gt; BLAS is an accelerated linear algebra library; Apple has implemented a<br>&gt; very nicely optimized one as part of its Accelerate framework. I use BLAS<br>&gt; to sum, for example, two arrays of floating point values--it&#39;s very, very<br>&gt; highly optimized. In that situation, there&#39;s no trapping when a single<br>&gt; value is out of bounds (I get NaNs instead), and thus I must determine<br>&gt; bounds in order to anticipate when the output will be garbage or NaN.<br>&gt; (There are, as part of the Accelerate framework, accelerated functions to<br>&gt; clamp entire arrays to given bounds with maximal efficiency).<br>&gt;<br>&gt; For accelerated scaling and unscaling, then, it is essentially always<br>&gt; necessary to compute upper and lower bounds even when that&#39;s unnecessary<br>&gt; for non-accelerated scaling and unscaling, which operates on one value at a<br>&gt; time. For that reason, `AcceleratedTransform` requires methods that compute<br>&gt; upper and lower bounds, and provides a default implementation of<br>&gt; accelerated clamping that calls those bound-computing methods and then uses<br>&gt; the results as parameters when calling functions in Accelerate.framework.<br>&gt; Methods for the computation of bounds already exist in `PortedTransform`<br>&gt; but not in my own transforms. With your proposal, how would I retroactively<br>&gt; model this requirement without touching code for `PortedTransform` and<br>&gt; without compiling this one class into its own library? I&#39;d like to be able<br>&gt; to take advantage of the maximum possible compiler optimization, and<br>&gt; optimizing across module boundaries is (as far as I understand) a little<br>&gt; dicier. (Moreover, for MyLinTransform, I override the clamping method to<br>&gt; return the input without calling out to any framework functions because I<br>&gt; know a priori that the bounds are -infinity and infinity. I think that<br>&gt; override will still be possible under your proposal, though.)<br>&gt;<br>&gt;<br>&gt; Without actually trying to understand the details of your math stuff:<br>&gt;<br>&gt; * If you add a required member in a declaration or extension that declares<br>&gt; conformance, it is &#39;required&#39;.<br>&gt; * If it is already defaulted, it is `override required`.<br>&gt; * If it is already defaulted but not required, it is `override`<br>&gt; * If someone else implements the stuff, you still have to pull it in<br>&gt; somehow, but if you do so by conforming to another protocol with an<br>&gt; extension, it&#39;s not your business, so you don&#39;t use any keywords.<br>&gt;<br>&gt; You use keywords only for stuff that you specifically write, that<br>&gt; clarifies the context in which you are writing it. If you do not own a<br>&gt; protocol, an extension, or an implementation, you do not change or markup<br>&gt; the protocol, extension, or implementation. You&#39;re just offering the<br>&gt; compiler hints that your otherwise questionable decisions are fully<br>&gt; intentional: when overriding an existing implementation and when conforming<br>&gt; by supplying a required member.<br>&gt;<br>&gt; -- E, who still probably missed your point and again apologizes<br>&gt;<br></p><p>I do not own the code, I do not write the code, but I am compiling it. The<br>compiler does not know I do not own the code, and it will try to force me<br>to edit it. Which it is physically possible for me to do, but perhaps not<br>legally so, or perhaps it is not best practice because it&#39;s third-party<br>code and I cannot upstream that change (nor would it make sense to do so<br>without also upstreaming the actual extensions I am writing, which are<br>out-of-scope for the upstream project).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/07a23000/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 8:25 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 28, 2016, at 8:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, stripped out a little too much, I guess. Let me expand a little:<br>&gt;&gt; <br>&gt;&gt; In this example, `PortedTransform` has, by virtue of how it works, an upper bound and lower bound for valid input (among other interesting methods and properties). Exceed those bounds for your input and `PortedTransform` regurgitates garbage but does not throw any kind of error. Obviously, linear transform does not care about such silly things because it can transform essentially any FP input value, while the log transform simply traps when it encounters a negative value (which, as a precondition, it should never encounter).<br>&gt;&gt; <br>&gt;&gt; BLAS is an accelerated linear algebra library; Apple has implemented a very nicely optimized one as part of its Accelerate framework. I use BLAS to sum, for example, two arrays of floating point values--it&#39;s very, very highly optimized. In that situation, there&#39;s no trapping when a single value is out of bounds (I get NaNs instead), and thus I must determine bounds in order to anticipate when the output will be garbage or NaN. (There are, as part of the Accelerate framework, accelerated functions to clamp entire arrays to given bounds with maximal efficiency).<br>&gt;&gt; <br>&gt;&gt; For accelerated scaling and unscaling, then, it is essentially always necessary to compute upper and lower bounds even when that&#39;s unnecessary for non-accelerated scaling and unscaling, which operates on one value at a time. For that reason, `AcceleratedTransform` requires methods that compute upper and lower bounds, and provides a default implementation of accelerated clamping that calls those bound-computing methods and then uses the results as parameters when calling functions in Accelerate.framework. Methods for the computation of bounds already exist in `PortedTransform` but not in my own transforms. With your proposal, how would I retroactively model this requirement without touching code for `PortedTransform` and without compiling this one class into its own library? I&#39;d like to be able to take advantage of the maximum possible compiler optimization, and optimizing across module boundaries is (as far as I understand) a little dicier. (Moreover, for MyLinTransform, I override the clamping method to return the input without calling out to any framework functions because I know a priori that the bounds are -infinity and infinity. I think that override will still be possible under your proposal, though.)<br>&gt; <br>&gt; Without actually trying to understand the details of your math stuff:<br>&gt; <br>&gt; * If you add a required member in a declaration or extension that declares conformance, it is &#39;required&#39;. <br>&gt; * If it is already defaulted, it is `override required`. <br>&gt; * If it is already defaulted but not required, it is `override`<br>&gt; * If someone else implements the stuff, you still have to pull it in somehow, but if you do so by conforming to another protocol with an extension, it&#39;s not your business, so you don&#39;t use any keywords.<br>&gt; <br>&gt; You use keywords only for stuff that you specifically write, that clarifies the context in which you are writing it. If you do not own a protocol, an extension, or an implementation, you do not change or markup the protocol, extension, or implementation. You&#39;re just offering the compiler hints that your otherwise questionable decisions are fully intentional: when overriding an existing implementation and when conforming by supplying a required member.<br>&gt; <br>&gt; -- E, who still probably missed your point and again apologizes<br></p><p>* If this is not Swift code it is not affected.<br>* If it is Swift code, either use #if swift(&gt;= blah) workarounds or propose that SwiftPM support earlier Swift compilation rules.<br>* If this is adopted and the code is in Swift 3, it would already have compliances and you do not need to add anything<br></p><p>Under what scenario could you possibly use 3rd party Swift 3 code (assuming adoption) that would require annotation/changing?<br></p><p>--  Erica<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/49306490/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 09:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016 at 9:40 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; Without actually trying to understand the details of your math stuff:<br>&gt;<br>&gt; * If you add a required member in a declaration or extension that declares<br>&gt; conformance, it is &#39;required&#39;.<br>&gt; * If it is already defaulted, it is `override required`.<br>&gt; * If it is already defaulted but not required, it is `override`<br>&gt; * If someone else implements the stuff, you still have to pull it in<br>&gt; somehow, but if you do so by conforming to another protocol with an<br>&gt; extension, it&#39;s not your business, so you don&#39;t use any keywords.<br>&gt;<br>&gt; You use keywords only for stuff that you specifically write, that<br>&gt; clarifies the context in which you are writing it. If you do not own a<br>&gt; protocol, an extension, or an implementation, you do not change or markup<br>&gt; the protocol, extension, or implementation. You&#39;re just offering the<br>&gt; compiler hints that your otherwise questionable decisions are fully<br>&gt; intentional: when overriding an existing implementation and when conforming<br>&gt; by supplying a required member.<br>&gt;<br>&gt; -- E, who still probably missed your point and again apologizes<br>&gt;<br>&gt;<br>&gt; * If this is not Swift code it is not affected.<br>&gt; * If it is Swift code, either use #if swift(&gt;= blah) workarounds or<br>&gt; propose that SwiftPM support earlier Swift compilation rules.<br>&gt; * If this is adopted and the code is in Swift 3, it would already have<br>&gt; compliances and you do not need to add anything<br>&gt;<br>&gt; Under what scenario could you possibly use 3rd party Swift 3 code<br>&gt; (assuming adoption) that would require annotation/changing?<br>&gt;<br></p><p>Let&#39;s return to the toy example. Suppose I license the following code from<br>a third party. I am allowed to incorporate it unmodified into my project:<br></p><p>```<br>// I cannot touch any of the following code<br>struct A {<br>    func frobnicate() { print(&quot;A&quot;) }<br>}<br>struct B {<br>    func frobnicate() { print(&quot;B&quot;) }<br>}<br>struct C { }<br>```<br></p><p>The code above has three types that conform to no protocols. Nothing would<br>change on adoption of your proposal. As licensed to me from the third<br>party, there are no protocols for it to conform to.<br></p><p>Now, in a separate file, as part of my own code, I want to conform these<br>three types to a protocol of my own design, Frobnicatable, and supply a<br>default `frobnicate()`:<br></p><p>```<br>protocol Frobnicatable {<br>    func frobnicate()<br>}<br>extension Frobnicatable {<br>    func frobnicate() { print(&quot;Default&quot;) }<br>}<br>extension A: Frobnicatable { }<br>extension B: Frobnicatable { }<br>extension C: Frobnicatable { }<br></p><p>let a = A()<br>a.frobnicate() // &quot;A&quot;<br>let c = C()<br>c.frobnicate() // &quot;Default&quot;<br>```<br></p><p>It seems like there is nothing I can do to make this work upon<br>implementation of your proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/3e24c532/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 8:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Let&#39;s return to the toy example. Suppose I license the following code from a third party. I am allowed to incorporate it unmodified into my project:<br>&gt; <br>&gt; ```<br>&gt; // I cannot touch any of the following code<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt; <br>&gt; The code above has three types that conform to no protocols. Nothing would change on adoption of your proposal. As licensed to me from the third party, there are no protocols for it to conform to.<br>&gt; <br>&gt; Now, in a separate file, as part of my own code, I want to conform these three types to a protocol of my own design, Frobnicatable, and supply a default `frobnicate()`:<br>&gt; <br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt; <br>&gt; let a = A()<br>&gt; a.frobnicate() // &quot;A&quot;<br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt; <br>&gt; It seems like there is nothing I can do to make this work upon implementation of your proposal.<br></p><p>Is this your desired behavior or is this the behavior you expect?<br>By implementing a default, you inherit that behavior in all three, because *you* added it.<br>I expect the compiler to complain at your default because you did not mark it as required.<br></p><p>If you want to use the inherent frobnicate and not the default one that you just added,<br>you will need to do something like:<br></p><p>extension A: Frobnicate {<br>   override required frobnicate = A.frobnicate<br>}<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/31ee6cae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 10:00:00pm</p></header><div class="content"><p>On Thu, Apr 28, 2016 at 9:53 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 28, 2016, at 8:46 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; Let&#39;s return to the toy example. Suppose I license the following code from<br>&gt; a third party. I am allowed to incorporate it unmodified into my project:<br>&gt;<br>&gt; ```<br>&gt; // I cannot touch any of the following code<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt;<br>&gt; The code above has three types that conform to no protocols. Nothing would<br>&gt; change on adoption of your proposal. As licensed to me from the third<br>&gt; party, there are no protocols for it to conform to.<br>&gt;<br>&gt; Now, in a separate file, as part of my own code, I want to conform these<br>&gt; three types to a protocol of my own design, Frobnicatable, and supply a<br>&gt; default `frobnicate()`:<br>&gt;<br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt;<br>&gt; let a = A()<br>&gt; a.frobnicate() // &quot;A&quot;<br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt;<br>&gt; It seems like there is nothing I can do to make this work upon<br>&gt; implementation of your proposal.<br>&gt;<br>&gt;<br>&gt; Is this your desired behavior or is this the behavior you expect?<br>&gt; By implementing a default, you inherit that behavior in all three, because<br>&gt; *you* added it.<br>&gt; I expect the compiler to complain at your default because you did not mark<br>&gt; it as required.<br>&gt;<br>&gt; If you want to use the inherent frobnicate and not the default one that<br>&gt; you just added,<br>&gt; you will need to do something like:<br>&gt;<br>&gt; extension A: Frobnicate {<br>&gt;    override required frobnicate = A.frobnicate<br>&gt; }<br>&gt;<br></p><p>What&#39;s shown in comments is how it *currently* behaves. That can be<br>verified in a playground (or the IBM sandbox online). I&#39;m not sure I have a<br>strong opinion yet on how it *should* behave, although what I&#39;m asking is<br>whether I *can* make it behave in the same way as it does currently.<br></p><p>If what you show above as a solution is part of your proposal, then that<br>should be sufficient to support my use case. Please do document it in the<br>text though. IMO, this is key. It&#39;s not enough to say, just modify the<br>original code, or just use a compiled module, or hope that the code is<br>written in something other than Swift 3.<br></p><p>I still have reservations about requiring both `override` and `required`,<br>which current Swift syntax never does. I understand what you&#39;re getting at,<br>but I&#39;m not sure making the distinction between `override` and `override<br>required` will provide additional safety in practice. My reasoning:<br>`override` implies that there&#39;s an implementation provided somewhere, and<br>`required` implies there&#39;s a protocol requirement somewhere, but either one<br>alone is sufficient to tell the compiler &quot;yes, I intend to write a function<br>with the same name as something else--please tell me if I failed to do so.&quot;<br>What would be lost (safety-wise) if we followed Swift precedent, and<br>`override required` got simplified to `override`?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/90a67520/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 30, 2016 at 12:00:00pm</p></header><div class="content"><p>I like your example because it focusses on the scenarios I often have to deal with: namely to inherit working code that is lacking flexibility and/or abstraction (extensibility). Then I have to find convoluted ways to retrofit some abstractions that do not alter the original code, but let me introduce containment around it so that I can later remove it or extend it despite its author. Java is very flexible in that matter, and it would be great if swift did not get in the way in the name of focussing on forward design (the design of the original author I usually have to dance around). It is IMO part of the magic of typescript: that you can go so far as organize conformance completely unbeknownst to the original loosely (poorly?) defined code.<br></p><p>Regards<br>(From mobile)<br></p><p>&gt; On Apr 29, 2016, at 4:46 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, Apr 28, 2016 at 9:40 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Without actually trying to understand the details of your math stuff:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * If you add a required member in a declaration or extension that declares conformance, it is &#39;required&#39;. <br>&gt;&gt;&gt; * If it is already defaulted, it is `override required`. <br>&gt;&gt;&gt; * If it is already defaulted but not required, it is `override`<br>&gt;&gt;&gt; * If someone else implements the stuff, you still have to pull it in somehow, but if you do so by conforming to another protocol with an extension, it&#39;s not your business, so you don&#39;t use any keywords.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You use keywords only for stuff that you specifically write, that clarifies the context in which you are writing it. If you do not own a protocol, an extension, or an implementation, you do not change or markup the protocol, extension, or implementation. You&#39;re just offering the compiler hints that your otherwise questionable decisions are fully intentional: when overriding an existing implementation and when conforming by supplying a required member.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- E, who still probably missed your point and again apologizes<br>&gt;&gt; <br>&gt;&gt; * If this is not Swift code it is not affected.<br>&gt;&gt; * If it is Swift code, either use #if swift(&gt;= blah) workarounds or propose that SwiftPM support earlier Swift compilation rules.<br>&gt;&gt; * If this is adopted and the code is in Swift 3, it would already have compliances and you do not need to add anything<br>&gt;&gt; <br>&gt;&gt; Under what scenario could you possibly use 3rd party Swift 3 code (assuming adoption) that would require annotation/changing?<br>&gt; <br>&gt; Let&#39;s return to the toy example. Suppose I license the following code from a third party. I am allowed to incorporate it unmodified into my project:<br>&gt; <br>&gt; ```<br>&gt; // I cannot touch any of the following code<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt; <br>&gt; The code above has three types that conform to no protocols. Nothing would change on adoption of your proposal. As licensed to me from the third party, there are no protocols for it to conform to.<br>&gt; <br>&gt; Now, in a separate file, as part of my own code, I want to conform these three types to a protocol of my own design, Frobnicatable, and supply a default `frobnicate()`:<br>&gt; <br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt; <br>&gt; let a = A()<br>&gt; a.frobnicate() // &quot;A&quot;<br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt; <br>&gt; It seems like there is nothing I can do to make this work upon implementation of your proposal.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/9e2046c9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April 30, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree that a keyword indicating intent would be nice, but I can&#39;t get<br>behind override if what you&#39;re doing is providing your own implementation.<br>I understand that we are trying to avoid adding keywords but could<br>`implement` or a synonym work? If you override something that your<br>superclass implements then you wouldn&#39;t need the `implement` keyword, just<br>`override`. This has the benefit of making it clear that the method came<br>from a protocol and not a superclass.<br></p><p>TJ<br></p><p>On Sat, Apr 30, 2016 at 6:01 AM, L. Mihalkovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I like your example because it focusses on the scenarios I often have to<br>&gt; deal with: namely to inherit working code that is lacking flexibility<br>&gt; and/or abstraction (extensibility). Then I have to find convoluted ways to<br>&gt; retrofit some abstractions that do not alter the original code, but let me<br>&gt; introduce containment around it so that I can later remove it or extend it<br>&gt; *despite* its author. Java is very flexible in that matter, and it would<br>&gt; be great if swift did not get in the way in the name of focussing on<br>&gt; forward design (the design of the original author I usually have to dance<br>&gt; around). It is IMO part of the magic of typescript: that you can go so far<br>&gt; as organize conformance completely unbeknownst to the original loosely<br>&gt; (poorly?) defined code.<br>&gt;<br>&gt; Regards<br>&gt; (From mobile)<br>&gt;<br>&gt; On Apr 29, 2016, at 4:46 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Thu, Apr 28, 2016 at 9:40 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Without actually trying to understand the details of your math stuff:<br>&gt;&gt;<br>&gt;&gt; * If you add a required member in a declaration or extension that<br>&gt;&gt; declares conformance, it is &#39;required&#39;.<br>&gt;&gt; * If it is already defaulted, it is `override required`.<br>&gt;&gt; * If it is already defaulted but not required, it is `override`<br>&gt;&gt; * If someone else implements the stuff, you still have to pull it in<br>&gt;&gt; somehow, but if you do so by conforming to another protocol with an<br>&gt;&gt; extension, it&#39;s not your business, so you don&#39;t use any keywords.<br>&gt;&gt;<br>&gt;&gt; You use keywords only for stuff that you specifically write, that<br>&gt;&gt; clarifies the context in which you are writing it. If you do not own a<br>&gt;&gt; protocol, an extension, or an implementation, you do not change or markup<br>&gt;&gt; the protocol, extension, or implementation. You&#39;re just offering the<br>&gt;&gt; compiler hints that your otherwise questionable decisions are fully<br>&gt;&gt; intentional: when overriding an existing implementation and when conforming<br>&gt;&gt; by supplying a required member.<br>&gt;&gt;<br>&gt;&gt; -- E, who still probably missed your point and again apologizes<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; * If this is not Swift code it is not affected.<br>&gt;&gt; * If it is Swift code, either use #if swift(&gt;= blah) workarounds or<br>&gt;&gt; propose that SwiftPM support earlier Swift compilation rules.<br>&gt;&gt; * If this is adopted and the code is in Swift 3, it would already have<br>&gt;&gt; compliances and you do not need to add anything<br>&gt;&gt;<br>&gt;&gt; Under what scenario could you possibly use 3rd party Swift 3 code<br>&gt;&gt; (assuming adoption) that would require annotation/changing?<br>&gt;&gt;<br>&gt;<br>&gt; Let&#39;s return to the toy example. Suppose I license the following code from<br>&gt; a third party. I am allowed to incorporate it unmodified into my project:<br>&gt;<br>&gt; ```<br>&gt; // I cannot touch any of the following code<br>&gt; struct A {<br>&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt; }<br>&gt; struct B {<br>&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt; }<br>&gt; struct C { }<br>&gt; ```<br>&gt;<br>&gt; The code above has three types that conform to no protocols. Nothing would<br>&gt; change on adoption of your proposal. As licensed to me from the third<br>&gt; party, there are no protocols for it to conform to.<br>&gt;<br>&gt; Now, in a separate file, as part of my own code, I want to conform these<br>&gt; three types to a protocol of my own design, Frobnicatable, and supply a<br>&gt; default `frobnicate()`:<br>&gt;<br>&gt; ```<br>&gt; protocol Frobnicatable {<br>&gt;     func frobnicate()<br>&gt; }<br>&gt; extension Frobnicatable {<br>&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt; }<br>&gt; extension A: Frobnicatable { }<br>&gt; extension B: Frobnicatable { }<br>&gt; extension C: Frobnicatable { }<br>&gt;<br>&gt; let a = A()<br>&gt; a.frobnicate() // &quot;A&quot;<br>&gt; let c = C()<br>&gt; c.frobnicate() // &quot;Default&quot;<br>&gt; ```<br>&gt;<br>&gt; It seems like there is nothing I can do to make this work upon<br>&gt; implementation of your proposal.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/1d6b72f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 30, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Apr 30, 2016, at 10:19 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I agree that a keyword indicating intent would be nice, but I can&#39;t get behind override if what you&#39;re doing is providing your own implementation. I understand that we are trying to avoid adding keywords but could `implement` or a synonym work? If you override something that your superclass implements then you wouldn&#39;t need the `implement` keyword, just `override`. This has the benefit of making it clear that the method came from a protocol and not a superclass. <br>&gt; <br>&gt; TJ<br></p><p>The discussion is pretty dead right now, but the key point is that override would only be used when replacing another required implementation member, not when just conforming by implementing a required member.<br></p><p>-- E<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 28, 2016 at 09:00:00pm</p></header><div class="content"><p>My bad for such a convoluted example. All of this is trying to say<br>something rather simple:<br></p><p>I&#39;m sure almost all of you who&#39;ve worked with C++ have used Boost<br>header-only libraries. Many of them are really nice.<br></p><p>There are reasons why third-party Swift code might be distributed by one<br>person and incorporated by another person in source form, a la Boost<br>header-only libraries. One of these reasons would be that some compiler<br>optimizations are not possible across module boundaries. With the<br>implementation of your proposal, such third-party code could not be both<br>incorporated as source (as opposed to a compiled module) and extended in<br>certain ways without modifying the code itself. To me, that&#39;s a loss.<br></p><p><br>On Thu, Apr 28, 2016 at 9:11 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; On Thu, Apr 28, 2016 at 8:32 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 28, 2016, at 6:20 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Thu, Apr 28, 2016 at 6:44 PM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Can you give me a specific example of where this approach fails for you?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -- E<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sure, I&#39;ll describe one (renaming some things for clarity and stripping<br>&gt;&gt; out the meat of the code, because it&#39;s not relevant and because it&#39;s not<br>&gt;&gt; elegant)--<br>&gt;&gt;<br>&gt;&gt; In one file, I have:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; class PortedTransfom {<br>&gt;&gt; // this class was ported from C++<br>&gt;&gt; // it transforms input FP values to output values in a complicated way<br>&gt;&gt; // it&#39;s a standalone entity and the algorithm is even under patent<br>&gt;&gt; // (not owned by me, though it&#39;s legal for me to use it for my purposes)<br>&gt;&gt; // for this reason, this ported code lives in its own file<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; In another file, I have:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; class MyAsinhTransform {<br>&gt;&gt; // this class was written by me<br>&gt;&gt; // nothing earth-shattering here<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class MyLogTransform {<br>&gt;&gt; // also written by me<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; class MyLinearTransform {<br>&gt;&gt; // also written by me<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; Transforming values one-at-a-time isn&#39;t fast enough, so in another file,<br>&gt;&gt; I have:<br>&gt;&gt;<br>&gt;&gt; ```<br>&gt;&gt; import Accelerate<br>&gt;&gt;<br>&gt;&gt; protocol AcceleratedTransform {<br>&gt;&gt;   func scale(_: [Double]) -&gt; [Double]<br>&gt;&gt;   func unscale(_: [Double]) -&gt; [Double]<br>&gt;&gt; // other functions here<br>&gt;&gt; // some are already implemented in PortedTransform, though<br>&gt;&gt; }<br>&gt;&gt; extension AcceleratedTransform {<br>&gt;&gt; // default implementations for some functions<br>&gt;&gt; // but not `scale(_:)` and `unscale(_:)`, obviously<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension MyAsinhTransform : AcceleratedTransform {<br>&gt;&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt;&gt; // and override some default implementations<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension MyLogTransform : AcceleratedTransform {<br>&gt;&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt;&gt; // and override some default implementations<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension  MyLinearTransform : AcceleratedTransform {<br>&gt;&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt;&gt; // and override some default implementations<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension PortedTransform : AcceleratedTransform {<br>&gt;&gt; // use BLAS to implement scale(_:) and unscale(_:)<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I think I&#39;m missing something here in terms of a question.  Your imported<br>&gt;&gt; stuff is your imported stuff.<br>&gt;&gt; Your extension implements &quot;required&quot; elements but not scale or unscale.<br>&gt;&gt;<br>&gt;&gt; If you extend MyAsinhTransform, you do required but not override for<br>&gt;&gt; scale/unscale. You do required override for anything you replace from<br>&gt;&gt; AcceleratedTransform.<br>&gt;&gt; What is BLAS? And what are you specifically asking about?<br>&gt;&gt;<br>&gt;&gt; -- E, apologizing for not understanding<br>&gt;&gt;<br>&gt;&gt;<br>&gt; Sorry, stripped out a little too much, I guess. Let me expand a little:<br>&gt;<br>&gt; In this example, `PortedTransform` has, by virtue of how it works, an<br>&gt; upper bound and lower bound for valid input (among other interesting<br>&gt; methods and properties). Exceed those bounds for your input and<br>&gt; `PortedTransform` regurgitates garbage but does not throw any kind of<br>&gt; error. Obviously, linear transform does not care about such silly things<br>&gt; because it can transform essentially any FP input value, while the log<br>&gt; transform simply traps when it encounters a negative value (which, as a<br>&gt; precondition, it should never encounter).<br>&gt;<br>&gt; BLAS is an accelerated linear algebra library; Apple has implemented a<br>&gt; very nicely optimized one as part of its Accelerate framework. I use BLAS<br>&gt; to sum, for example, two arrays of floating point values--it&#39;s very, very<br>&gt; highly optimized. In that situation, there&#39;s no trapping when a single<br>&gt; value is out of bounds (I get NaNs instead), and thus I must determine<br>&gt; bounds in order to anticipate when the output will be garbage or NaN.<br>&gt; (There are, as part of the Accelerate framework, accelerated functions to<br>&gt; clamp entire arrays to given bounds with maximal efficiency).<br>&gt;<br>&gt; For accelerated scaling and unscaling, then, it is essentially always<br>&gt; necessary to compute upper and lower bounds even when that&#39;s unnecessary<br>&gt; for non-accelerated scaling and unscaling, which operates on one value at a<br>&gt; time. For that reason, `AcceleratedTransform` requires methods that compute<br>&gt; upper and lower bounds, and provides a default implementation of<br>&gt; accelerated clamping that calls those bound-computing methods and then uses<br>&gt; the results as parameters when calling functions in Accelerate.framework.<br>&gt; Methods for the computation of bounds already exist in `PortedTransform`<br>&gt; but not in my own transforms. With your proposal, how would I retroactively<br>&gt; model this requirement without touching code for `PortedTransform` and<br>&gt; without compiling this one class into its own library? I&#39;d like to be able<br>&gt; to take advantage of the maximum possible compiler optimization, and<br>&gt; optimizing across module boundaries is (as far as I understand) a little<br>&gt; dicier. (Moreover, for MyLinTransform, I override the clamping method to<br>&gt; return the input without calling out to any framework functions because I<br>&gt; know a priori that the bounds are -infinity and infinity. I think that<br>&gt; override will still be possible under your proposal, though.)<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/e6f5d5c1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>April 30, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 8:09 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt; <br>&gt; ```<br>&gt; struct A : Frobnicate {<br>&gt;     override required func frobnicate() { print(&quot;A&quot;) } // &quot;A&quot;, or delete to get default<br>&gt; }<br>&gt; struct B: Frobnicate {<br>&gt;     override required func frobnicate() { print(&quot;B&quot;) } // &quot;B&quot;, or delete to get default<br>&gt; }<br>&gt; struct C: Frobnicate  { }<br>&gt; ```<br></p><p>These are a couple of derived situations: <br>&gt; struct IAssumeThisIsAProblem : Frobnicate {<br>&gt;     required func frobnicate() { print(&quot;A&quot;) } <br>&gt; }<br></p><p><br>&gt; struct IAssumeThisIsAnotherProblem  Frobnicate {<br>&gt;     override func frobnicate() { print(&quot;A&quot;) } <br>&gt; }<br></p><p><br>What happens in both cases?<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 11:48 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, that&#39;s not my question, which doesn&#39;t involve protocols I don&#39;t own. Let me restate. Given three types I don&#39;t own as follows:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; struct A {<br>&gt;&gt;     func frobnicate() { print(&quot;A&quot;) }<br>&gt;&gt; }<br>&gt;&gt; struct B {<br>&gt;&gt;     func frobnicate() { print(&quot;B&quot;) }<br>&gt;&gt; }<br>&gt;&gt; struct C { }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; I want to conform them to a protocol of my own design, Frobnicatable, and supply a default `frobnicate()`:<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; protocol Frobnicatable {<br>&gt;&gt;     func frobnicate()<br>&gt;&gt; }<br>&gt;&gt; extension Frobnicatable {<br>&gt;&gt;     func frobnicate() { print(&quot;Default&quot;) }<br>&gt;&gt; }<br>&gt;&gt; extension A: Frobnicatable { }<br>&gt;&gt; extension B: Frobnicatable { }<br>&gt;&gt; extension C: Frobnicatable { }<br>&gt;&gt; <br>&gt;&gt; let c = C()<br>&gt;&gt; c.frobnicate() // &quot;Default&quot;<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; (Yes, I realize there are issues regarding static and dynamic dispatch that limit the utility of this particular example--let&#39;s leave those aside for now.)<br>&gt;&gt; Where would I affix keywords such as `required` and `override` to make this work after implementation of your proposal?<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160430/b848b358/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Erica,<br>In general I fully support this proposal. IMO Swift should be more explicit <br>on what method in class/struct is required by protocol and if it overrides <br>default implementation in protocol extension.<br></p><p>Actually, personally I like the idea that we need even separate base class <br>inheritance declaration and protocol conformance like in Java:<br>class A:B implements C {..} or class A:B::C {}.. or even specify which <br>protocol exactly requires this method like<br>func f() requiredBy SomeProto {} ...<br>but never mind :-)<br></p><p>Also your proposal should protect from such situations:<br>1. We use some 3rd party class AClass that implements AProtocol<br>2. We write extension to AProtocol, added new method ANewMethod<br>3. Then, we update the source of that AClass, and in new version of it the <br>same ANewMethod was introduced(like in our AProtocol)<br>4. Now we have methods with same name in AClass and in protocol extension <br>without any error/warning<br></p><p>Small fix(I think):<br>-----<br>protocol A..<br>protocol B..<br>extension A { override required func foo() {...A extension...} }<br>Type CType: A, B {}<br>-----<br> &gt;&gt;&gt; don&#39;t you want to write just &#39;required&#39; here, not &#39;override required&#39; ?<br></p><p><br>Right now we have protocol extension&#39;s priority over type definition:<br>------------<br>protocol A {}<br></p><p>class C:A {<br>     func y() { print(&quot;Y in C&quot;) }<br>}<br></p><p>extension A { func y() {print(&quot;Y in A&quot;)} }<br></p><p>var c : A = C()<br>c.y() // Y in A here<br>-----------<br>so, it seems like you need to add this to &quot;Impact on Existing Code&quot;<br>I.e. now, when someone declared an protocol extension, it will get this <br>method in class instance. Your proposal says we&#39;ll have class ext -&gt; <br>class-&gt; protocol ex. -&gt; protocol. Or I missed something?<br></p><p>Also, can&#39;t we just use &#39;override&#39; instead of &#39;required&#39;?<br>I.e. in protocol extension &#39;override&#39; means - implements something, that <br>was declared already in protocol. In class methods declaration &#39;override&#39; <br>will mean &#39;overrides base class&#39;es implementation, or method in protocol <br>extension, or implements protocol requirement&#39;. I don&#39;t see the clear need <br>of &#39;required&#39; keyword here. I mean for me just &#39;override&#39; will say &#39;this <br>method is already declared somewhere&#39;.<br></p><p>On 28.04.2016 19:53, Erica Sadun via swift-evolution wrote:<br>&gt; Draft. Criticism and suggestions both welcome. -- E<br>&gt;<br>&gt;<br>&gt;   Requiring Proactive Overrides for Default Protocol Implementations<br>&gt;<br>&gt;   * Proposal: tbd<br>&gt;   * Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;   * Status: tbd<br>&gt;   * Review manager: tbd<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;Introduction<br>&gt;<br>&gt; This proposal enhances protocol implementation safety. It incorporates two<br>&gt; keywords that cooperate with compiler checks to limit &quot;near miss&quot;<br>&gt; implementation errors and accidental member overrides.<br>&gt;<br>&gt; /This proposal was discussed on the Swift Evolution list in the [Pitch]<br>&gt; Requiring proactive overrides for default protocol implementations.<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread/<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;Motivation<br>&gt;<br>&gt; The proposal introduces a mandatory |required| keyword that marks members<br>&gt; as fulfiling protocol requirements. This expansion reduces the risk of<br>&gt; near-miss implementations (for example, adding |thud(x:<br>&gt; Double)| when |thud(x: Float)|is required), provides in-line documentation<br>&gt; of why the member has been included, thereby enhancing the code-level<br>&gt; documentation at the implementation point, and supports compile-time checks<br>&gt; for protocol conformance.<br>&gt;<br>&gt; This proposal extends the |override| keyword to protocol conformance. The<br>&gt; Swift Programming Language describes the way subclass methods must override<br>&gt; implementations established in superclasses. /Methods on a subclass that<br>&gt; override the superclass’s implementation are marked with<br>&gt; */|override|*/—overriding a method by accident, without override, is<br>&gt; detected by the compiler as an error. The compiler also detects methods<br>&gt; with override that don’t actually override any method in the superclass./<br>&gt;<br>&gt; Adding an |override| requirement expands this cautious approach to<br>&gt; protocols. Developers must override implementations inherited from protocol<br>&gt; extensions with the |override| keyword. And the compiler will flag uses<br>&gt; of |override| where member implementations do not, in fact, override an<br>&gt; existing implementation. The keyword prevents accidental overrides, where a<br>&gt; sensible member name conflicts with signatures established in the protocol<br>&gt; conformance and forces users to proactively select a version in favor of<br>&gt; existing protocol extensions.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail<br>&gt;     Design<br>&gt;<br>&gt;   * The |override| keyword is extended to protocol inheritance, and when<br>&gt;     used prefers the overridden behavior to the default behavior.<br>&gt;   * Swift will prefer an overridden implementation in preference in reverse<br>&gt;     hierarchical order: type extensions take precedence over type<br>&gt;     declarations over protocol extensions over protocol declarations<br>&gt;     (assuming protocol declarations eventually adopt default implementations).<br>&gt;   * The |required| keyword marks a member as satisfying a protocol<br>&gt;     requirement, whether in protocol extensions, type declarations, or type<br>&gt;     extensions.<br>&gt;<br>&gt;<br>&gt;         &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required<br>&gt;         Protocol Members<br>&gt;<br>&gt; Protocol requirements are marked with |required| for compile-time checks of<br>&gt; intentional conformance.<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt;     func bar()<br>&gt;     func blort()<br>&gt;     func gar()<br>&gt; }<br>&gt;<br>&gt; extension A {<br>&gt;     required func blort() {} // Correct, required by `A`<br>&gt;     func womble() {} // Correct, new method in extension<br>&gt;     func gar() {} // Incorrect: Compiler says: add `required` keyword or remove implementation<br>&gt; }<br>&gt;<br>&gt; struct B: A {<br>&gt;     required func foo() {} // Correct<br>&gt;     required func far() {} // Near miss. Compiler: rename method or drop required keyword<br>&gt;     func bar() {} // Possible accidental name match. Compiler: rename method or add required<br>&gt; keyword<br>&gt; }<br>&gt;<br>&gt;<br>&gt;         &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member<br>&gt;         Overrides<br>&gt;<br>&gt; Overrides are marked with |override| to ensure intent.<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt;     func bar()<br>&gt;     func blort()<br>&gt;     func gar()<br>&gt; }<br>&gt;<br>&gt; extension A {<br>&gt;     required func foo() {} // correct<br>&gt;     func womble() {} // correct<br>&gt; }<br>&gt;<br>&gt; struct B: A {<br>&gt;     required func bar() {} // correct<br>&gt;     required func foo() {} // incorrect: Compiler says: add `override` keyword or remove implementation<br>&gt;      func womble() {} // incorrect: Compiler says add `override` keyword or remove<br>&gt; implementation. `required` is not needed as `womble` is not a required<br>&gt; protocol member.<br>&gt; }<br>&gt;<br>&gt;<br>&gt;         &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling<br>&gt;         Changes<br>&gt;<br>&gt; Default implementations can be added or removed at any time, as can type<br>&gt; conformance implementations:<br>&gt;<br>&gt; **Original**	**Change**	**Outcome**<br>&gt; Some member implemented in type	Protocol adds that member	Must add<br>&gt; `required` to type implementation or rename member to avoid conflict<br>&gt; Some member implemented in type, marked as `required`	Protocol removes that<br>&gt; member or it never existed	Must remove `required` from type implementation<br>&gt; Some member implemented in type, marked as `override`	Protocol extension<br>&gt; removes that member or it never existed	Must remove `override` from type<br>&gt; implementation<br>&gt; Some member implemented in typed, member not mentioned in protocol<br>&gt; Extension adds default version of member	Type implementation must add<br>&gt; `override` keyword<br>&gt; `required` member implemented in type	Default member added	Must add<br>&gt; `override` or remove type implementation<br>&gt; `override required` member implemented in type	Remove default member	Must<br>&gt; remove `override` in type implementation<br>&gt; `override required` member implemented in type	Remove type member<br>&gt; implementation	Default implementation now used<br>&gt; Type member uses `required` keyword	Protocol removes requirement or never<br>&gt; had it	Type implementation must remove `required` keyword<br>&gt; Protocol declares required member	Extension implements default<br>&gt; implementation	Extension must add `required` keyword, differentiating<br>&gt; default implementations from added behavior<br>&gt; Swift adds default implementations to protocols as well as extensions<br>&gt; Protocol adds default implementation	Type implementation must use both<br>&gt; `required` and `override` keywords. Protocol extension must use `override`<br>&gt; keyword. Order of preference goes: overriden member, overriden extension,<br>&gt; protocol default implementation<br>&gt;<br>&gt;<br>&gt;         &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple<br>&gt;         Conformance Conflict<br>&gt;<br>&gt; Consider the following situation. For the sake of future-proofing, this<br>&gt; example includes default protocol implementations although they do not yet<br>&gt; exist in Swift.<br>&gt;<br>&gt; protocol A { func foo() {...default...} }<br>&gt; protocol B { func foo() {...default...} }<br>&gt; extension A { override required func foo() {...A extension...} }<br>&gt; Type CType: A, B {}<br>&gt;<br>&gt; In this example, the compiler emits a warning that &quot;CType cannot<br>&gt; unambiguously differentiate which version of |foo| to use<br>&gt; for |CType| instances&quot;. If the CType type were to be removed or either of<br>&gt; its conformances erased, there would be no compiler issues.<br>&gt;<br>&gt; To fix this scenario, CType must implement a version of foo that resolves<br>&gt; the conflict:<br>&gt;<br>&gt; Type CType: A, B { override required func foo() {<br>&gt;     // either<br>&gt;     A.foo(self)() // uses the A extension default implementation<br>&gt;     // or<br>&gt;     B.foo(self)() // uses the B protocol default implementation<br>&gt;     // or both, one after the other, etc.<br>&gt; }<br>&gt;<br>&gt; In this rewrite, |foo| is unambiguously referenced for |CType| instance<br>&gt; members.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact<br>&gt;     on Existing Code<br>&gt;<br>&gt; These changes introduce mandates that do not exist in today&#39;s Swift code<br>&gt; and will require migration. The migrator (and compiler) must detect both<br>&gt; scenarios: that a member satisfies a protocol requirement and needs<br>&gt; the |required| keyword, and that a member overrides a default<br>&gt; implementation (in current Swift, only in extensions) and needs<br>&gt; the |override|keyword.<br>&gt;<br>&gt; In the degenerate case that protocol extensions provide two distinct<br>&gt; default implementations of the same member (whether required or not),<br>&gt; the |override| version should always be preferred. When<br>&gt; multiple |override| versions exist, the compiler should emit a warning<br>&gt; about ambiguous resolution.<br>&gt;<br>&gt; Using type currying, e.g. |A.foo(self)| should always resolve using the<br>&gt; rules enumerated earlier in this proposal, moving from type extensions to<br>&gt; types to protocol extension to protocols.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives<br>&gt;     Considered<br>&gt;<br>&gt; Not at this time.<br>&gt;<br>&gt;<br>&gt;     &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements<br>&gt;     and Thanks<br>&gt;<br>&gt; Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com<br>&gt;&gt; &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May  9, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Erica, could you clarify, what is state of this proposal and your plans <br>regarding it? I believe we certainly should make Swift more explicit <br>regarding what methods in type are required by the conformed protocol and <br>what methods are required(and which are &#39;optional&#39;) in protocol extensions.<br></p><p>Right now there is a discussion regarding &#39;optional&#39; keyword(&quot;Modify <br>optional method semantics for swift&quot;), and I remembered your proposal..<br></p><p>Probably &#39;optional&#39; keyword for non-required methods in extension instead <br>of marking &#39;required&#39; methods will looks better(as they are optional to the <br>protocol itself), what do you think?<br>I.e.<br></p><p>protocol A {<br>     func foo()<br>     func bar()<br>     func blort()<br>     func gar()<br>}<br></p><p>extension A {<br>     //required func blort() {} // Correct, required by `A`<br>     //func womble() {} // Correct, new method in extension<br>     //func gar() {} // Incorrect: Compiler says: add `required` keyword..<br></p><p>     func blort() {} // Correct, was introduced in `A`<br>     optional func womble() {} // Correct, new(optional) method in extension<br>     optional func gar() {} // Incorrect: Compiler says: remove `optional`..<br>}<br></p><p>struct B: A {<br>     required func foo() {} // Correct<br>     required func far() {} // Near miss. Compiler: rename method or drop <br>required keyword<br>     func bar() {} // Possible accidental name match. Compiler: rename <br>method or add required keyword<br></p><p>     func womble() {} // ?? how this method should be &#39;marked&#39; ??<br>}<br></p><p>(But personally I think one *overload* keyword will do the job in both <br>cases - in extension and in type declaration)<br></p><p>Regarding this &quot;func womble()&quot; questions.. I think we need *at least* <br>compilation warning that *at the moment of compilation*, B.womble may(?) <br>conflicts with extension of A.womble.<br></p><p>Personaly I was not expecting to get the result of this code:<br></p><p>protocol A {<br>   func a()<br>}<br></p><p>extension A {<br>    func b() { print(&quot;(b) in A&quot;) }<br>}<br></p><p>struct C : A {<br>     func a() {}<br>     func b() { print(&quot;(b) in C&quot;) }<br>}<br></p><p>var c : A = C()<br>c.b()  // (b) in A<br></p><p><br>&gt; On 28.04.2016 19:53, Erica Sadun via swift-evolution wrote:<br>&gt;&gt; Draft. Criticism and suggestions both welcome. -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;   Requiring Proactive Overrides for Default Protocol Implementations<br>&gt;&gt;<br>&gt;&gt;   * Proposal: tbd<br>&gt;&gt;   * Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;   * Status: tbd<br>&gt;&gt;   * Review manager: tbd2<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;Introduction<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This proposal enhances protocol implementation safety. It incorporates two<br>&gt;&gt; keywords that cooperate with compiler checks to limit &quot;near miss&quot;<br>&gt;&gt; implementation errors and accidental member overrides.<br>&gt;&gt;<br>&gt;&gt; /This proposal was discussed on the Swift Evolution list in the [Pitch]<br>&gt;&gt; Requiring proactive overrides for default protocol implementations.<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread/<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;Motivation<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The proposal introduces a mandatory |required| keyword that marks members<br>&gt;&gt; as fulfiling protocol requirements. This expansion reduces the risk of<br>&gt;&gt; near-miss implementations (for example, adding |thud(x:<br>&gt;&gt; Double)| when |thud(x: Float)|is required), provides in-line documentation<br>&gt;&gt; of why the member has been included, thereby enhancing the code-level<br>&gt;&gt; documentation at the implementation point, and supports compile-time checks<br>&gt;&gt; for protocol conformance.<br>&gt;&gt;<br>&gt;&gt; This proposal extends the |override| keyword to protocol conformance. The<br>&gt;&gt; Swift Programming Language describes the way subclass methods must override<br>&gt;&gt; implementations established in superclasses. /Methods on a subclass that<br>&gt;&gt; override the superclass’s implementation are marked with<br>&gt;&gt; */|override|*/—overriding a method by accident, without override, is<br>&gt;&gt; detected by the compiler as an error. The compiler also detects methods<br>&gt;&gt; with override that don’t actually override any method in the superclass./<br>&gt;&gt;<br>&gt;&gt; Adding an |override| requirement expands this cautious approach to<br>&gt;&gt; protocols. Developers must override implementations inherited from protocol<br>&gt;&gt; extensions with the |override| keyword. And the compiler will flag uses<br>&gt;&gt; of |override| where member implementations do not, in fact, override an<br>&gt;&gt; existing implementation. The keyword prevents accidental overrides, where a<br>&gt;&gt; sensible member name conflicts with signatures established in the protocol<br>&gt;&gt; conformance and forces users to proactively select a version in favor of<br>&gt;&gt; existing protocol extensions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail<br>&gt;&gt;<br>&gt;&gt;     Design<br>&gt;&gt;<br>&gt;&gt;   * The |override| keyword is extended to protocol inheritance, and when<br>&gt;&gt;     used prefers the overridden behavior to the default behavior.<br>&gt;&gt;   * Swift will prefer an overridden implementation in preference in reverse<br>&gt;&gt;     hierarchical order: type extensions take precedence over type<br>&gt;&gt;     declarations over protocol extensions over protocol declarations<br>&gt;&gt;     (assuming protocol declarations eventually adopt default<br>&gt;&gt; implementations).<br>&gt;&gt;   * The |required| keyword marks a member as satisfying a protocol<br>&gt;&gt;     requirement, whether in protocol extensions, type declarations, or type<br>&gt;&gt;     extensions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required<br>&gt;&gt;<br>&gt;&gt;         Protocol Members<br>&gt;&gt;<br>&gt;&gt; Protocol requirements are marked with |required| for compile-time checks of<br>&gt;&gt; intentional conformance.<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func foo()<br>&gt;&gt;     func bar()<br>&gt;&gt;     func blort()<br>&gt;&gt;     func gar()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;     required func blort() {} // Correct, required by `A`<br>&gt;&gt;     func womble() {} // Correct, new method in extension<br>&gt;&gt;     func gar() {} // Incorrect: Compiler says: add `required` keyword or<br>&gt;&gt; remove implementation<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct B: A {<br>&gt;&gt;     required func foo() {} // Correct<br>&gt;&gt;     required func far() {} // Near miss. Compiler: rename method or drop<br>&gt;&gt; required keyword<br>&gt;&gt;     func bar() {} // Possible accidental name match. Compiler: rename<br>&gt;&gt; method or add required<br>&gt;&gt; keyword<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member<br>&gt;&gt;<br>&gt;&gt;         Overrides<br>&gt;&gt;<br>&gt;&gt; Overrides are marked with |override| to ensure intent.<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func foo()<br>&gt;&gt;     func bar()<br>&gt;&gt;     func blort()<br>&gt;&gt;     func gar()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;     required func foo() {} // correct<br>&gt;&gt;     func womble() {} // correct<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct B: A {<br>&gt;&gt;     required func bar() {} // correct<br>&gt;&gt;     required func foo() {} // incorrect: Compiler says: add `override`<br>&gt;&gt; keyword or remove implementation<br>&gt;&gt;      func womble() {} // incorrect: Compiler says add `override` keyword<br>&gt;&gt; or remove<br>&gt;&gt; implementation. `required` is not needed as `womble` is not a required<br>&gt;&gt; protocol member.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling<br>&gt;&gt;<br>&gt;&gt;         Changes<br>&gt;&gt;<br>&gt;&gt; Default implementations can be added or removed at any time, as can type<br>&gt;&gt; conformance implementations:<br>&gt;&gt;<br>&gt;&gt; **Original**    **Change**    **Outcome**<br>&gt;&gt; Some member implemented in type    Protocol adds that member    Must add<br>&gt;&gt; `required` to type implementation or rename member to avoid conflict<br>&gt;&gt; Some member implemented in type, marked as `required`    Protocol removes<br>&gt;&gt; that<br>&gt;&gt; member or it never existed    Must remove `required` from type<br>&gt;&gt; implementation<br>&gt;&gt; Some member implemented in type, marked as `override`    Protocol extension<br>&gt;&gt; removes that member or it never existed    Must remove `override` from type<br>&gt;&gt; implementation<br>&gt;&gt; Some member implemented in typed, member not mentioned in protocol<br>&gt;&gt; Extension adds default version of member    Type implementation must add<br>&gt;&gt; `override` keyword<br>&gt;&gt; `required` member implemented in type    Default member added    Must add<br>&gt;&gt; `override` or remove type implementation<br>&gt;&gt; `override required` member implemented in type    Remove default<br>&gt;&gt; member    Must<br>&gt;&gt; remove `override` in type implementation<br>&gt;&gt; `override required` member implemented in type    Remove type member<br>&gt;&gt; implementation    Default implementation now used<br>&gt;&gt; Type member uses `required` keyword    Protocol removes requirement or never<br>&gt;&gt; had it    Type implementation must remove `required` keyword<br>&gt;&gt; Protocol declares required member    Extension implements default<br>&gt;&gt; implementation    Extension must add `required` keyword, differentiating<br>&gt;&gt; default implementations from added behavior<br>&gt;&gt; Swift adds default implementations to protocols as well as extensions<br>&gt;&gt; Protocol adds default implementation    Type implementation must use both<br>&gt;&gt; `required` and `override` keywords. Protocol extension must use `override`<br>&gt;&gt; keyword. Order of preference goes: overriden member, overriden extension,<br>&gt;&gt; protocol default implementation<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple<br>&gt;&gt;<br>&gt;&gt;         Conformance Conflict<br>&gt;&gt;<br>&gt;&gt; Consider the following situation. For the sake of future-proofing, this<br>&gt;&gt; example includes default protocol implementations although they do not yet<br>&gt;&gt; exist in Swift.<br>&gt;&gt;<br>&gt;&gt; protocol A { func foo() {...default...} }<br>&gt;&gt; protocol B { func foo() {...default...} }<br>&gt;&gt; extension A { override required func foo() {...A extension...} }<br>&gt;&gt; Type CType: A, B {}<br>&gt;&gt;<br>&gt;&gt; In this example, the compiler emits a warning that &quot;CType cannot<br>&gt;&gt; unambiguously differentiate which version of |foo| to use<br>&gt;&gt; for |CType| instances&quot;. If the CType type were to be removed or either of<br>&gt;&gt; its conformances erased, there would be no compiler issues.<br>&gt;&gt;<br>&gt;&gt; To fix this scenario, CType must implement a version of foo that resolves<br>&gt;&gt; the conflict:<br>&gt;&gt;<br>&gt;&gt; Type CType: A, B { override required func foo() {<br>&gt;&gt;     // either<br>&gt;&gt;     A.foo(self)() // uses the A extension default implementation<br>&gt;&gt;     // or<br>&gt;&gt;     B.foo(self)() // uses the B protocol default implementation<br>&gt;&gt;     // or both, one after the other, etc.<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; In this rewrite, |foo| is unambiguously referenced for |CType| instance<br>&gt;&gt; members.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact<br>&gt;&gt;<br>&gt;&gt;     on Existing Code<br>&gt;&gt;<br>&gt;&gt; These changes introduce mandates that do not exist in today&#39;s Swift code<br>&gt;&gt; and will require migration. The migrator (and compiler) must detect both<br>&gt;&gt; scenarios: that a member satisfies a protocol requirement and needs<br>&gt;&gt; the |required| keyword, and that a member overrides a default<br>&gt;&gt; implementation (in current Swift, only in extensions) and needs<br>&gt;&gt; the |override|keyword.<br>&gt;&gt;<br>&gt;&gt; In the degenerate case that protocol extensions provide two distinct<br>&gt;&gt; default implementations of the same member (whether required or not),<br>&gt;&gt; the |override| version should always be preferred. When<br>&gt;&gt; multiple |override| versions exist, the compiler should emit a warning<br>&gt;&gt; about ambiguous resolution.<br>&gt;&gt;<br>&gt;&gt; Using type currying, e.g. |A.foo(self)| should always resolve using the<br>&gt;&gt; rules enumerated earlier in this proposal, moving from type extensions to<br>&gt;&gt; types to protocol extension to protocols.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives<br>&gt;&gt;<br>&gt;&gt;     Considered<br>&gt;&gt;<br>&gt;&gt; Not at this time.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements<br>&gt;&gt;<br>&gt;&gt;     and Thanks<br>&gt;&gt;<br>&gt;&gt; Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com<br>&gt;&gt;&gt; &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May  9, 2016 at 12:00:00pm</p></header><div class="content"><p>The pitch was not warmly received. If you want to pick it up and run with it, go ahead. <br>https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a&gt;<br></p><p>I have a running list of dead or deferred ideas here: https://gist.github.com/erica/9eae0d949297509ad86e<br></p><p><br>-- E<br></p><p>&gt; On May 9, 2016, at 11:49 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Erica, could you clarify, what is state of this proposal and your plans regarding it? I believe we certainly should make Swift more explicit regarding what methods in type are required by the conformed protocol and what methods are required(and which are &#39;optional&#39;) in protocol extensions.<br>&gt; <br>&gt; Right now there is a discussion regarding &#39;optional&#39; keyword(&quot;Modify optional method semantics for swift&quot;), and I remembered your proposal..<br>&gt; <br>&gt; Probably &#39;optional&#39; keyword for non-required methods in extension instead of marking &#39;required&#39; methods will looks better(as they are optional to the protocol itself), what do you think?<br>&gt; I.e.<br>&gt; <br>&gt; protocol A {<br>&gt;    func foo()<br>&gt;    func bar()<br>&gt;    func blort()<br>&gt;    func gar()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;    //required func blort() {} // Correct, required by `A`<br>&gt;    //func womble() {} // Correct, new method in extension<br>&gt;    //func gar() {} // Incorrect: Compiler says: add `required` keyword..<br>&gt; <br>&gt;    func blort() {} // Correct, was introduced in `A`<br>&gt;    optional func womble() {} // Correct, new(optional) method in extension<br>&gt;    optional func gar() {} // Incorrect: Compiler says: remove `optional`..<br>&gt; }<br>&gt; <br>&gt; struct B: A {<br>&gt;    required func foo() {} // Correct<br>&gt;    required func far() {} // Near miss. Compiler: rename method or drop required keyword<br>&gt;    func bar() {} // Possible accidental name match. Compiler: rename method or add required keyword<br>&gt; <br>&gt;    func womble() {} // ?? how this method should be &#39;marked&#39; ??<br>&gt; }<br>&gt; <br>&gt; (But personally I think one *overload* keyword will do the job in both cases - in extension and in type declaration)<br>&gt; <br>&gt; Regarding this &quot;func womble()&quot; questions.. I think we need *at least* compilation warning that *at the moment of compilation*, B.womble may(?) conflicts with extension of A.womble.<br>&gt; <br>&gt; Personaly I was not expecting to get the result of this code:<br>&gt; <br>&gt; protocol A {<br>&gt;  func a()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;   func b() { print(&quot;(b) in A&quot;) }<br>&gt; }<br>&gt; <br>&gt; struct C : A {<br>&gt;    func a() {}<br>&gt;    func b() { print(&quot;(b) in C&quot;) }<br>&gt; }<br>&gt; <br>&gt; var c : A = C()<br>&gt; c.b()  // (b) in A<br>&gt; <br>&gt; <br>&gt;&gt; On 28.04.2016 19:53, Erica Sadun via swift-evolution wrote:<br>&gt;&gt;&gt; Draft. Criticism and suggestions both welcome. -- E<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Requiring Proactive Overrides for Default Protocol Implementations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  * Proposal: tbd<br>&gt;&gt;&gt;  * Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;&gt;  * Status: tbd<br>&gt;&gt;&gt;  * Review manager: tbd2<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal enhances protocol implementation safety. It incorporates two<br>&gt;&gt;&gt; keywords that cooperate with compiler checks to limit &quot;near miss&quot;<br>&gt;&gt;&gt; implementation errors and accidental member overrides.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /This proposal was discussed on the Swift Evolution list in the [Pitch]<br>&gt;&gt;&gt; Requiring proactive overrides for default protocol implementations.<br>&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread/<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal introduces a mandatory |required| keyword that marks members<br>&gt;&gt;&gt; as fulfiling protocol requirements. This expansion reduces the risk of<br>&gt;&gt;&gt; near-miss implementations (for example, adding |thud(x:<br>&gt;&gt;&gt; Double)| when |thud(x: Float)|is required), provides in-line documentation<br>&gt;&gt;&gt; of why the member has been included, thereby enhancing the code-level<br>&gt;&gt;&gt; documentation at the implementation point, and supports compile-time checks<br>&gt;&gt;&gt; for protocol conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal extends the |override| keyword to protocol conformance. The<br>&gt;&gt;&gt; Swift Programming Language describes the way subclass methods must override<br>&gt;&gt;&gt; implementations established in superclasses. /Methods on a subclass that<br>&gt;&gt;&gt; override the superclass’s implementation are marked with<br>&gt;&gt;&gt; */|override|*/—overriding a method by accident, without override, is<br>&gt;&gt;&gt; detected by the compiler as an error. The compiler also detects methods<br>&gt;&gt;&gt; with override that don’t actually override any method in the superclass./<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Adding an |override| requirement expands this cautious approach to<br>&gt;&gt;&gt; protocols. Developers must override implementations inherited from protocol<br>&gt;&gt;&gt; extensions with the |override| keyword. And the compiler will flag uses<br>&gt;&gt;&gt; of |override| where member implementations do not, in fact, override an<br>&gt;&gt;&gt; existing implementation. The keyword prevents accidental overrides, where a<br>&gt;&gt;&gt; sensible member name conflicts with signatures established in the protocol<br>&gt;&gt;&gt; conformance and forces users to proactively select a version in favor of<br>&gt;&gt;&gt; existing protocol extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  * The |override| keyword is extended to protocol inheritance, and when<br>&gt;&gt;&gt;    used prefers the overridden behavior to the default behavior.<br>&gt;&gt;&gt;  * Swift will prefer an overridden implementation in preference in reverse<br>&gt;&gt;&gt;    hierarchical order: type extensions take precedence over type<br>&gt;&gt;&gt;    declarations over protocol extensions over protocol declarations<br>&gt;&gt;&gt;    (assuming protocol declarations eventually adopt default<br>&gt;&gt;&gt; implementations).<br>&gt;&gt;&gt;  * The |required| keyword marks a member as satisfying a protocol<br>&gt;&gt;&gt;    requirement, whether in protocol extensions, type declarations, or type<br>&gt;&gt;&gt;    extensions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Protocol Members<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocol requirements are marked with |required| for compile-time checks of<br>&gt;&gt;&gt; intentional conformance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;    func foo()<br>&gt;&gt;&gt;    func bar()<br>&gt;&gt;&gt;    func blort()<br>&gt;&gt;&gt;    func gar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;    required func blort() {} // Correct, required by `A`<br>&gt;&gt;&gt;    func womble() {} // Correct, new method in extension<br>&gt;&gt;&gt;    func gar() {} // Incorrect: Compiler says: add `required` keyword or<br>&gt;&gt;&gt; remove implementation<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct B: A {<br>&gt;&gt;&gt;    required func foo() {} // Correct<br>&gt;&gt;&gt;    required func far() {} // Near miss. Compiler: rename method or drop<br>&gt;&gt;&gt; required keyword<br>&gt;&gt;&gt;    func bar() {} // Possible accidental name match. Compiler: rename<br>&gt;&gt;&gt; method or add required<br>&gt;&gt;&gt; keyword<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Overrides<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overrides are marked with |override| to ensure intent.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;    func foo()<br>&gt;&gt;&gt;    func bar()<br>&gt;&gt;&gt;    func blort()<br>&gt;&gt;&gt;    func gar()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;    required func foo() {} // correct<br>&gt;&gt;&gt;    func womble() {} // correct<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct B: A {<br>&gt;&gt;&gt;    required func bar() {} // correct<br>&gt;&gt;&gt;    required func foo() {} // incorrect: Compiler says: add `override`<br>&gt;&gt;&gt; keyword or remove implementation<br>&gt;&gt;&gt;     func womble() {} // incorrect: Compiler says add `override` keyword<br>&gt;&gt;&gt; or remove<br>&gt;&gt;&gt; implementation. `required` is not needed as `womble` is not a required<br>&gt;&gt;&gt; protocol member.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Changes<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Default implementations can be added or removed at any time, as can type<br>&gt;&gt;&gt; conformance implementations:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; **Original**    **Change**    **Outcome**<br>&gt;&gt;&gt; Some member implemented in type    Protocol adds that member    Must add<br>&gt;&gt;&gt; `required` to type implementation or rename member to avoid conflict<br>&gt;&gt;&gt; Some member implemented in type, marked as `required`    Protocol removes<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; member or it never existed    Must remove `required` from type<br>&gt;&gt;&gt; implementation<br>&gt;&gt;&gt; Some member implemented in type, marked as `override`    Protocol extension<br>&gt;&gt;&gt; removes that member or it never existed    Must remove `override` from type<br>&gt;&gt;&gt; implementation<br>&gt;&gt;&gt; Some member implemented in typed, member not mentioned in protocol<br>&gt;&gt;&gt; Extension adds default version of member    Type implementation must add<br>&gt;&gt;&gt; `override` keyword<br>&gt;&gt;&gt; `required` member implemented in type    Default member added    Must add<br>&gt;&gt;&gt; `override` or remove type implementation<br>&gt;&gt;&gt; `override required` member implemented in type    Remove default<br>&gt;&gt;&gt; member    Must<br>&gt;&gt;&gt; remove `override` in type implementation<br>&gt;&gt;&gt; `override required` member implemented in type    Remove type member<br>&gt;&gt;&gt; implementation    Default implementation now used<br>&gt;&gt;&gt; Type member uses `required` keyword    Protocol removes requirement or never<br>&gt;&gt;&gt; had it    Type implementation must remove `required` keyword<br>&gt;&gt;&gt; Protocol declares required member    Extension implements default<br>&gt;&gt;&gt; implementation    Extension must add `required` keyword, differentiating<br>&gt;&gt;&gt; default implementations from added behavior<br>&gt;&gt;&gt; Swift adds default implementations to protocols as well as extensions<br>&gt;&gt;&gt; Protocol adds default implementation    Type implementation must use both<br>&gt;&gt;&gt; `required` and `override` keywords. Protocol extension must use `override`<br>&gt;&gt;&gt; keyword. Order of preference goes: overriden member, overriden extension,<br>&gt;&gt;&gt; protocol default implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Conformance Conflict<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider the following situation. For the sake of future-proofing, this<br>&gt;&gt;&gt; example includes default protocol implementations although they do not yet<br>&gt;&gt;&gt; exist in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A { func foo() {...default...} }<br>&gt;&gt;&gt; protocol B { func foo() {...default...} }<br>&gt;&gt;&gt; extension A { override required func foo() {...A extension...} }<br>&gt;&gt;&gt; Type CType: A, B {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this example, the compiler emits a warning that &quot;CType cannot<br>&gt;&gt;&gt; unambiguously differentiate which version of |foo| to use<br>&gt;&gt;&gt; for |CType| instances&quot;. If the CType type were to be removed or either of<br>&gt;&gt;&gt; its conformances erased, there would be no compiler issues.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To fix this scenario, CType must implement a version of foo that resolves<br>&gt;&gt;&gt; the conflict:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Type CType: A, B { override required func foo() {<br>&gt;&gt;&gt;    // either<br>&gt;&gt;&gt;    A.foo(self)() // uses the A extension default implementation<br>&gt;&gt;&gt;    // or<br>&gt;&gt;&gt;    B.foo(self)() // uses the B protocol default implementation<br>&gt;&gt;&gt;    // or both, one after the other, etc.<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this rewrite, |foo| is unambiguously referenced for |CType| instance<br>&gt;&gt;&gt; members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These changes introduce mandates that do not exist in today&#39;s Swift code<br>&gt;&gt;&gt; and will require migration. The migrator (and compiler) must detect both<br>&gt;&gt;&gt; scenarios: that a member satisfies a protocol requirement and needs<br>&gt;&gt;&gt; the |required| keyword, and that a member overrides a default<br>&gt;&gt;&gt; implementation (in current Swift, only in extensions) and needs<br>&gt;&gt;&gt; the |override|keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the degenerate case that protocol extensions provide two distinct<br>&gt;&gt;&gt; default implementations of the same member (whether required or not),<br>&gt;&gt;&gt; the |override| version should always be preferred. When<br>&gt;&gt;&gt; multiple |override| versions exist, the compiler should emit a warning<br>&gt;&gt;&gt; about ambiguous resolution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using type currying, e.g. |A.foo(self)| should always resolve using the<br>&gt;&gt;&gt; rules enumerated earlier in this proposal, moving from type extensions to<br>&gt;&gt;&gt; types to protocol extension to protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not at this time.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    and Thanks<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com<br>&gt;&gt;&gt;&gt; &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160509/6604e114/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 10, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m thinking about this.. but first, could someone *please* <br>describe(clarify) the behavior of the next code and if that behavior is <br>expected and if we really need exactly this behavior and if we can(I mean <br>if it is not too hard) change this.. :<br></p><p>protocol A {<br>}<br></p><p>extension A {<br>     func a() { print(&quot;(a) in extension of A&quot;) }<br></p><p>     static func b() {print(&quot;(static b) in extension of A&quot;)}<br>}<br></p><p>struct S : A {<br>     func a() { print(&quot;(a) in S&quot;) }<br></p><p>     static func b() {print(&quot;(static b) in S&quot;)}<br>}<br></p><p>var s : A = S()<br></p><p>print(&quot;s.dynamicType = &quot;, s.dynamicType)<br>s.a()<br>s.dynamicType.b()<br></p><p>Result is :<br></p><p>s.dynamicType =  S<br>(a) in extension of A<br>(static b) in extension of A<br></p><p>IMO This is definitely not the &quot;less surprising&quot; behavior.<br>Thank you.<br></p><p>On 09.05.2016 21:03, Erica Sadun wrote:<br>&gt; The pitch was not warmly received. If you want to pick it up and run with<br>&gt; it, go ahead.<br>&gt; https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a<br>&gt;<br>&gt; I have a running list of dead or deferred ideas<br>&gt; here: https://gist.github.com/erica/9eae0d949297509ad86e<br>&gt;<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;&gt; On May 9, 2016, at 11:49 AM, Vladimir.S &lt;svabox at gmail.com<br>&gt;&gt; &lt;mailto:svabox at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi Erica, could you clarify, what is state of this proposal and your<br>&gt;&gt; plans regarding it? I believe we certainly should make Swift more<br>&gt;&gt; explicit regarding what methods in type are required by the conformed<br>&gt;&gt; protocol and what methods are required(and which are &#39;optional&#39;) in<br>&gt;&gt; protocol extensions.<br>&gt;&gt;<br>&gt;&gt; Right now there is a discussion regarding &#39;optional&#39; keyword(&quot;Modify<br>&gt;&gt; optional method semantics for swift&quot;), and I remembered your proposal..<br>&gt;&gt;<br>&gt;&gt; Probably &#39;optional&#39; keyword for non-required methods in extension instead<br>&gt;&gt; of marking &#39;required&#39; methods will looks better(as they are optional to<br>&gt;&gt; the protocol itself), what do you think?<br>&gt;&gt; I.e.<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;    func foo()<br>&gt;&gt;    func bar()<br>&gt;&gt;    func blort()<br>&gt;&gt;    func gar()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;    //required func blort() {} // Correct, required by `A`<br>&gt;&gt;    //func womble() {} // Correct, new method in extension<br>&gt;&gt;    //func gar() {} // Incorrect: Compiler says: add `required` keyword..<br>&gt;&gt;<br>&gt;&gt;    func blort() {} // Correct, was introduced in `A`<br>&gt;&gt;    optional func womble() {} // Correct, new(optional) method in extension<br>&gt;&gt;    optional func gar() {} // Incorrect: Compiler says: remove `optional`..<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct B: A {<br>&gt;&gt;    required func foo() {} // Correct<br>&gt;&gt;    required func far() {} // Near miss. Compiler: rename method or drop<br>&gt;&gt; required keyword<br>&gt;&gt;    func bar() {} // Possible accidental name match. Compiler: rename<br>&gt;&gt; method or add required keyword<br>&gt;&gt;<br>&gt;&gt;    func womble() {} // ?? how this method should be &#39;marked&#39; ??<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; (But personally I think one *overload* keyword will do the job in both<br>&gt;&gt; cases - in extension and in type declaration)<br>&gt;&gt;<br>&gt;&gt; Regarding this &quot;func womble()&quot; questions.. I think we need *at least*<br>&gt;&gt; compilation warning that *at the moment of compilation*, B.womble may(?)<br>&gt;&gt; conflicts with extension of A.womble.<br>&gt;&gt;<br>&gt;&gt; Personaly I was not expecting to get the result of this code:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;  func a()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;   func b() { print(&quot;(b) in A&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; struct C : A {<br>&gt;&gt;    func a() {}<br>&gt;&gt;    func b() { print(&quot;(b) in C&quot;) }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; var c : A = C()<br>&gt;&gt; c.b()  // (b) in A<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On 28.04.2016 19:53, Erica Sadun via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Draft. Criticism and suggestions both welcome. -- E<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  Requiring Proactive Overrides for Default Protocol Implementations<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  * Proposal: tbd<br>&gt;&gt;&gt;&gt;  * Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt;&gt;&gt;  * Status: tbd<br>&gt;&gt;&gt;&gt;  * Review manager: tbd2<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal enhances protocol implementation safety. It incorporates two<br>&gt;&gt;&gt;&gt; keywords that cooperate with compiler checks to limit &quot;near miss&quot;<br>&gt;&gt;&gt;&gt; implementation errors and accidental member overrides.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /This proposal was discussed on the Swift Evolution list in the [Pitch]<br>&gt;&gt;&gt;&gt; Requiring proactive overrides for default protocol implementations.<br>&gt;&gt;&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread/<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The proposal introduces a mandatory |required| keyword that marks members<br>&gt;&gt;&gt;&gt; as fulfiling protocol requirements. This expansion reduces the risk of<br>&gt;&gt;&gt;&gt; near-miss implementations (for example, adding |thud(x:<br>&gt;&gt;&gt;&gt; Double)| when |thud(x: Float)|is required), provides in-line documentation<br>&gt;&gt;&gt;&gt; of why the member has been included, thereby enhancing the code-level<br>&gt;&gt;&gt;&gt; documentation at the implementation point, and supports compile-time checks<br>&gt;&gt;&gt;&gt; for protocol conformance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This proposal extends the |override| keyword to protocol conformance. The<br>&gt;&gt;&gt;&gt; Swift Programming Language describes the way subclass methods must override<br>&gt;&gt;&gt;&gt; implementations established in superclasses. /Methods on a subclass that<br>&gt;&gt;&gt;&gt; override the superclass’s implementation are marked with<br>&gt;&gt;&gt;&gt; */|override|*/—overriding a method by accident, without override, is<br>&gt;&gt;&gt;&gt; detected by the compiler as an error. The compiler also detects methods<br>&gt;&gt;&gt;&gt; with override that don’t actually override any method in the superclass./<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Adding an |override| requirement expands this cautious approach to<br>&gt;&gt;&gt;&gt; protocols. Developers must override implementations inherited from protocol<br>&gt;&gt;&gt;&gt; extensions with the |override| keyword. And the compiler will flag uses<br>&gt;&gt;&gt;&gt; of |override| where member implementations do not, in fact, override an<br>&gt;&gt;&gt;&gt; existing implementation. The keyword prevents accidental overrides, where a<br>&gt;&gt;&gt;&gt; sensible member name conflicts with signatures established in the protocol<br>&gt;&gt;&gt;&gt; conformance and forces users to proactively select a version in favor of<br>&gt;&gt;&gt;&gt; existing protocol extensions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    Design<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  * The |override| keyword is extended to protocol inheritance, and when<br>&gt;&gt;&gt;&gt;    used prefers the overridden behavior to the default behavior.<br>&gt;&gt;&gt;&gt;  * Swift will prefer an overridden implementation in preference in reverse<br>&gt;&gt;&gt;&gt;    hierarchical order: type extensions take precedence over type<br>&gt;&gt;&gt;&gt;    declarations over protocol extensions over protocol declarations<br>&gt;&gt;&gt;&gt;    (assuming protocol declarations eventually adopt default<br>&gt;&gt;&gt;&gt; implementations).<br>&gt;&gt;&gt;&gt;  * The |required| keyword marks a member as satisfying a protocol<br>&gt;&gt;&gt;&gt;    requirement, whether in protocol extensions, type declarations, or type<br>&gt;&gt;&gt;&gt;    extensions.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;        Protocol Members<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Protocol requirements are marked with |required| for compile-time checks of<br>&gt;&gt;&gt;&gt; intentional conformance.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;    func foo()<br>&gt;&gt;&gt;&gt;    func bar()<br>&gt;&gt;&gt;&gt;    func blort()<br>&gt;&gt;&gt;&gt;    func gar()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;    required func blort() {} // Correct, required by `A`<br>&gt;&gt;&gt;&gt;    func womble() {} // Correct, new method in extension<br>&gt;&gt;&gt;&gt;    func gar() {} // Incorrect: Compiler says: add `required` keyword or<br>&gt;&gt;&gt;&gt; remove implementation<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct B: A {<br>&gt;&gt;&gt;&gt;    required func foo() {} // Correct<br>&gt;&gt;&gt;&gt;    required func far() {} // Near miss. Compiler: rename method or drop<br>&gt;&gt;&gt;&gt; required keyword<br>&gt;&gt;&gt;&gt;    func bar() {} // Possible accidental name match. Compiler: rename<br>&gt;&gt;&gt;&gt; method or add required<br>&gt;&gt;&gt;&gt; keyword<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;        Overrides<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Overrides are marked with |override| to ensure intent.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;&gt;    func foo()<br>&gt;&gt;&gt;&gt;    func bar()<br>&gt;&gt;&gt;&gt;    func blort()<br>&gt;&gt;&gt;&gt;    func gar()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;&gt;    required func foo() {} // correct<br>&gt;&gt;&gt;&gt;    func womble() {} // correct<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct B: A {<br>&gt;&gt;&gt;&gt;    required func bar() {} // correct<br>&gt;&gt;&gt;&gt;    required func foo() {} // incorrect: Compiler says: add `override`<br>&gt;&gt;&gt;&gt; keyword or remove implementation<br>&gt;&gt;&gt;&gt;     func womble() {} // incorrect: Compiler says add `override` keyword<br>&gt;&gt;&gt;&gt; or remove<br>&gt;&gt;&gt;&gt; implementation. `required` is not needed as `womble` is not a required<br>&gt;&gt;&gt;&gt; protocol member.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;        Changes<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Default implementations can be added or removed at any time, as can type<br>&gt;&gt;&gt;&gt; conformance implementations:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; **Original**    **Change**    **Outcome**<br>&gt;&gt;&gt;&gt; Some member implemented in type    Protocol adds that member    Must add<br>&gt;&gt;&gt;&gt; `required` to type implementation or rename member to avoid conflict<br>&gt;&gt;&gt;&gt; Some member implemented in type, marked as `required`    Protocol removes<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; member or it never existed    Must remove `required` from type<br>&gt;&gt;&gt;&gt; implementation<br>&gt;&gt;&gt;&gt; Some member implemented in type, marked as `override`    Protocol extension<br>&gt;&gt;&gt;&gt; removes that member or it never existed    Must remove `override` from type<br>&gt;&gt;&gt;&gt; implementation<br>&gt;&gt;&gt;&gt; Some member implemented in typed, member not mentioned in protocol<br>&gt;&gt;&gt;&gt; Extension adds default version of member    Type implementation must add<br>&gt;&gt;&gt;&gt; `override` keyword<br>&gt;&gt;&gt;&gt; `required` member implemented in type    Default member added    Must add<br>&gt;&gt;&gt;&gt; `override` or remove type implementation<br>&gt;&gt;&gt;&gt; `override required` member implemented in type    Remove default<br>&gt;&gt;&gt;&gt; member    Must<br>&gt;&gt;&gt;&gt; remove `override` in type implementation<br>&gt;&gt;&gt;&gt; `override required` member implemented in type    Remove type member<br>&gt;&gt;&gt;&gt; implementation    Default implementation now used<br>&gt;&gt;&gt;&gt; Type member uses `required` keyword    Protocol removes requirement or<br>&gt;&gt;&gt;&gt; never<br>&gt;&gt;&gt;&gt; had it    Type implementation must remove `required` keyword<br>&gt;&gt;&gt;&gt; Protocol declares required member    Extension implements default<br>&gt;&gt;&gt;&gt; implementation    Extension must add `required` keyword, differentiating<br>&gt;&gt;&gt;&gt; default implementations from added behavior<br>&gt;&gt;&gt;&gt; Swift adds default implementations to protocols as well as extensions<br>&gt;&gt;&gt;&gt; Protocol adds default implementation    Type implementation must use both<br>&gt;&gt;&gt;&gt; `required` and `override` keywords. Protocol extension must use `override`<br>&gt;&gt;&gt;&gt; keyword. Order of preference goes: overriden member, overriden extension,<br>&gt;&gt;&gt;&gt; protocol default implementation<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;        Conformance Conflict<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Consider the following situation. For the sake of future-proofing, this<br>&gt;&gt;&gt;&gt; example includes default protocol implementations although they do not yet<br>&gt;&gt;&gt;&gt; exist in Swift.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; protocol A { func foo() {...default...} }<br>&gt;&gt;&gt;&gt; protocol B { func foo() {...default...} }<br>&gt;&gt;&gt;&gt; extension A { override required func foo() {...A extension...} }<br>&gt;&gt;&gt;&gt; Type CType: A, B {}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In this example, the compiler emits a warning that &quot;CType cannot<br>&gt;&gt;&gt;&gt; unambiguously differentiate which version of |foo| to use<br>&gt;&gt;&gt;&gt; for |CType| instances&quot;. If the CType type were to be removed or either of<br>&gt;&gt;&gt;&gt; its conformances erased, there would be no compiler issues.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; To fix this scenario, CType must implement a version of foo that resolves<br>&gt;&gt;&gt;&gt; the conflict:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Type CType: A, B { override required func foo() {<br>&gt;&gt;&gt;&gt;    // either<br>&gt;&gt;&gt;&gt;    A.foo(self)() // uses the A extension default implementation<br>&gt;&gt;&gt;&gt;    // or<br>&gt;&gt;&gt;&gt;    B.foo(self)() // uses the B protocol default implementation<br>&gt;&gt;&gt;&gt;    // or both, one after the other, etc.<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In this rewrite, |foo| is unambiguously referenced for |CType| instance<br>&gt;&gt;&gt;&gt; members.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    on Existing Code<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; These changes introduce mandates that do not exist in today&#39;s Swift code<br>&gt;&gt;&gt;&gt; and will require migration. The migrator (and compiler) must detect both<br>&gt;&gt;&gt;&gt; scenarios: that a member satisfies a protocol requirement and needs<br>&gt;&gt;&gt;&gt; the |required| keyword, and that a member overrides a default<br>&gt;&gt;&gt;&gt; implementation (in current Swift, only in extensions) and needs<br>&gt;&gt;&gt;&gt; the |override|keyword.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In the degenerate case that protocol extensions provide two distinct<br>&gt;&gt;&gt;&gt; default implementations of the same member (whether required or not),<br>&gt;&gt;&gt;&gt; the |override| version should always be preferred. When<br>&gt;&gt;&gt;&gt; multiple |override| versions exist, the compiler should emit a warning<br>&gt;&gt;&gt;&gt; about ambiguous resolution.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Using type currying, e.g. |A.foo(self)| should always resolve using the<br>&gt;&gt;&gt;&gt; rules enumerated earlier in this proposal, moving from type extensions to<br>&gt;&gt;&gt;&gt; types to protocol extension to protocols.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    Considered<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Not at this time.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;    and Thanks<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:dgregor at apple.com&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 28, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi, Erica. Sorry for not participating in the first round here. I’m…not so happy with this direction, for a number of reasons. (I apologize for the laundry list, but they’re not really related complaints.)<br></p><p>- ‘required’ already means something today: it means “this initializer must be present on all subclasses”. The reason it only applies to initializers is because all other members are always present on all subclasses.<br></p><p>(Counter-argument: using ‘required’ on an initializer could be seen as making an implicit protocol, just for that class hierarchy.)<br></p><p>- ‘override’ likewise already has a meaning; allowing ‘override’ to be satisfied by a protocol requirement means that it might miss an override intended for a superclass—or inadvertently become one when an SDK is updated.<br></p><p>(Counter-argument: that last can happen to protocols already.)<br></p><p>- This doesn’t cover cases where methods in one protocol extension satisfy requirements in another.<br></p><p>- This doesn’t cover retroactive modeling.<br></p><p>- I’m not sure what it means to &quot;prefer an overridden implementation in preference in reverse hierarchical order: type extensions take precedence over type declarations over protocol extensions over protocol declarations (assuming protocol declarations eventually adopt default implementations)”. Protocol conformance is decided at compile time; there won’t ever be any members in type extensions that take precedent over a type declaration without causing a conflict. (That is, currently you are not allowed to define such a member.)<br></p><p>- A member in the type does not “override&quot; a member in a protocol extension today, because such a call is not dynamically dispatched. Making protocol extension members dynamically dispatched is challenging at the least and would require an implementation plan in the proposal.<br></p><p>- Thank you for writing up all of the source compatibility cases! I think there’s no issue with binary compatibility, since IIUC the proposal doesn’t change how anything is implemented, and we think we know how to handle binary compatibility there. But I’d like to think about it a little more.<br></p><p>- The “A.foo(self)()” syntax is clever, but it doesn’t work correctly for mutating methods (because you can’t curry an inout). On the other hand, JoeG already brought up the idea of making ‘self’ the first argument of the implicit static member. It still doesn’t solve the problem of picking a protocol extension, but that’s not new. (This isn’t a complaint, I guess, just a note.)<br></p><p><br>I’m not sure I have a meaningful summary or conclusion, but I’d be hesitant to do all of this without these concerns being addressed.<br></p><p>Jordan<br></p><p><br></p><p>&gt; On Apr 28, 2016, at 09:53, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; Draft. Criticism and suggestions both welcome. -- E<br>&gt; <br>&gt; Requiring Proactive Overrides for Default Protocol Implementations<br>&gt; <br>&gt; Proposal: tbd<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: tbd<br>&gt; Review manager: tbd<br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal enhances protocol implementation safety. It incorporates two keywords that cooperate with compiler checks to limit &quot;near miss&quot; implementation errors and accidental member overrides.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [Pitch] Requiring proactive overrides for default protocol implementations. &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15496&gt; thread<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#motivation&gt;Motivation<br>&gt; <br>&gt; The proposal introduces a mandatory required keyword that marks members as fulfiling protocol requirements. This expansion reduces the risk of near-miss implementations (for example, adding thud(x: Double) when thud(x: Float)is required), provides in-line documentation of why the member has been included, thereby enhancing the code-level documentation at the implementation point, and supports compile-time checks for protocol conformance.<br>&gt; <br>&gt; This proposal extends the override keyword to protocol conformance. The Swift Programming Language describes the way subclass methods must override implementations established in superclasses. Methods on a subclass that override the superclass’s implementation are marked with *override*—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt; <br>&gt; Adding an override requirement expands this cautious approach to protocols. Developers must override implementations inherited from protocol extensions with the override keyword. And the compiler will flag uses of override where member implementations do not, in fact, override an existing implementation. The keyword prevents accidental overrides, where a sensible member name conflicts with signatures established in the protocol conformance and forces users to proactively select a version in favor of existing protocol extensions.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#detail-design&gt;Detail Design<br>&gt; <br>&gt; The override keyword is extended to protocol inheritance, and when used prefers the overridden behavior to the default behavior. <br>&gt; Swift will prefer an overridden implementation in preference in reverse hierarchical order: type extensions take precedence over type declarations over protocol extensions over protocol declarations (assuming protocol declarations eventually adopt default implementations).<br>&gt; The required keyword marks a member as satisfying a protocol requirement, whether in protocol extensions, type declarations, or type extensions.<br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#required-protocol-members&gt;Required Protocol Members<br>&gt; <br>&gt; Protocol requirements are marked with required for compile-time checks of intentional conformance.<br>&gt; <br>&gt; protocol A { <br>&gt;     func foo() <br>&gt;     func bar()<br>&gt;     func blort()<br>&gt;     func gar()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;     required func blort() {} // Correct, required by `A`<br>&gt;     func womble() {} // Correct, new method in extension<br>&gt;     func gar() {} // Incorrect: Compiler says: add `required` keyword or remove implementation<br>&gt; }<br>&gt; <br>&gt; struct B: A {<br>&gt;     required func foo() {} // Correct<br>&gt;     required func far() {} // Near miss. Compiler: rename method or drop required keyword<br>&gt;     func bar() {} // Possible accidental name match. Compiler: rename method or add required keyword<br>&gt; }<br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#member-overrides&gt;Member Overrides<br>&gt; <br>&gt; Overrides are marked with override to ensure intent.<br>&gt; <br>&gt; protocol A { <br>&gt;     func foo() <br>&gt;     func bar()<br>&gt;     func blort()<br>&gt;     func gar()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;     required func foo() {} // correct<br>&gt;     func womble() {} // correct<br>&gt; }<br>&gt; <br>&gt; struct B: A {<br>&gt;     required func bar() {} // correct<br>&gt;     required func foo() {} // incorrect: Compiler says: add `override` keyword or remove implementation<br>&gt;      func womble() {} // incorrect: Compiler says add `override` keyword or remove implementation. `required` is not needed as `womble` is not a required protocol member.<br>&gt; }<br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#handling-changes&gt;Handling Changes<br>&gt; <br>&gt; Default implementations can be added or removed at any time, as can type conformance implementations:<br>&gt; <br>&gt; **Original**	**Change**	**Outcome**<br>&gt; Some member implemented in type	Protocol adds that member	Must add `required` to type implementation or rename member to avoid conflict<br>&gt; Some member implemented in type, marked as `required`	Protocol removes that member or it never existed	Must remove `required` from type implementation<br>&gt; Some member implemented in type, marked as `override`	Protocol extension removes that member or it never existed	Must remove `override` from type implementation<br>&gt; Some member implemented in typed, member not mentioned in protocol	Extension adds default version of member	Type implementation must add `override` keyword<br>&gt; `required` member implemented in type	Default member added	Must add `override` or remove type implementation<br>&gt; `override required` member implemented in type	Remove default member	Must remove `override` in type implementation<br>&gt; `override required` member implemented in type	Remove type member implementation	Default implementation now used<br>&gt; Type member uses `required` keyword	Protocol removes requirement or never had it	Type implementation must remove `required` keyword<br>&gt; Protocol declares required member	Extension implements default implementation	Extension must add `required` keyword, differentiating default implementations from added behavior<br>&gt; Swift adds default implementations to protocols as well as extensions	Protocol adds default implementation	Type implementation must use both `required` and `override` keywords. Protocol extension must use `override` keyword. Order of preference goes: overriden member, overriden extension, protocol default implementation<br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#multiple-conformance-conflict&gt;Multiple Conformance Conflict<br>&gt; <br>&gt; Consider the following situation. For the sake of future-proofing, this example includes default protocol implementations although they do not yet exist in Swift.<br>&gt; <br>&gt; protocol A { func foo() {...default...} }<br>&gt; protocol B { func foo() {...default...} }<br>&gt; extension A { override required func foo() {...A extension...} }<br>&gt; Type CType: A, B {}<br>&gt; In this example, the compiler emits a warning that &quot;CType cannot unambiguously differentiate which version of foo to use for CType instances&quot;. If the CType type were to be removed or either of its conformances erased, there would be no compiler issues.<br>&gt; <br>&gt; To fix this scenario, CType must implement a version of foo that resolves the conflict:<br>&gt; <br>&gt; Type CType: A, B { override required func foo() { <br>&gt;     // either<br>&gt;     A.foo(self)() // uses the A extension default implementation<br>&gt;     // or<br>&gt;     B.foo(self)() // uses the B protocol default implementation<br>&gt;     // or both, one after the other, etc.<br>&gt; }<br>&gt; In this rewrite, foo is unambiguously referenced for CType instance members.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; These changes introduce mandates that do not exist in today&#39;s Swift code and will require migration. The migrator (and compiler) must detect both scenarios: that a member satisfies a protocol requirement and needs the required keyword, and that a member overrides a default implementation (in current Swift, only in extensions) and needs the overridekeyword.<br>&gt; <br>&gt; In the degenerate case that protocol extensions provide two distinct default implementations of the same member (whether required or not), the override version should always be preferred. When multiple override versions exist, the compiler should emit a warning about ambiguous resolution.<br>&gt; <br>&gt; Using type currying, e.g. A.foo(self) should always resolve using the rules enumerated earlier in this proposal, moving from type extensions to types to protocol extension to protocols.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; Not at this time.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/fc66e6f6335750d737e5512797e8284a#acknowledgements-and-thanks&gt;Acknowledgements and Thanks<br>&gt; <br>&gt; Thanks, Doug Gregor, Jordan Rose, and Joe Groff<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Apr 27, 2016, at 6:07 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/117454b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 28, 2016 at 09:00:00pm</p></header><div class="content"><p>[resending without quoting the proposal, because apparently that made Mail emit garbage today]<br></p><p><br>Hi, Erica. Sorry for not participating in the first round here. I’m…not so happy with this direction, for a number of reasons. (I apologize for the laundry list, but they’re not really related complaints.)<br></p><p>- ‘required’ already means something today: it means “this initializer must be present on all subclasses”. The reason it only applies to initializers is because all other members are always present on all subclasses.<br></p><p>(Counter-argument: using ‘required’ on an initializer could be seen as making an implicit protocol, just for that class hierarchy.)<br></p><p>- ‘override’ likewise already has a meaning; allowing ‘override’ to be satisfied by a protocol requirement means that it might miss an override intended for a superclass—or inadvertently become one when an SDK is updated.<br></p><p>(Counter-argument: that last can happen to protocols already.)<br></p><p>- This doesn’t cover cases where methods in one protocol extension satisfy requirements in another.<br></p><p>- This doesn’t cover retroactive modeling.<br></p><p>- I’m not sure what it means to &quot;prefer an overridden implementation in preference in reverse hierarchical order: type extensions take precedence over type declarations over protocol extensions over protocol declarations (assuming protocol declarations eventually adopt default implementations)”. Protocol conformance is decided at compile time; there won’t ever be any members in type extensions that take precedent over a type declaration without causing a conflict. (That is, currently you are not allowed to define such a member.)<br></p><p>- A member in the type does not “override&quot; a member in a protocol extension today, because such a call is not dynamically dispatched. Making protocol extension members dynamically dispatched is challenging at the least and would require an implementation plan in the proposal.<br></p><p>- Thank you for writing up all of the source compatibility cases! I think there’s no issue with binary compatibility, since IIUC the proposal doesn’t change how anything is implemented, and we think we know how to handle binary compatibility there. But I’d like to think about it a little more.<br></p><p>- The “A.foo(self)()” syntax is clever, but it doesn’t work correctly for mutating methods (because you can’t curry an inout). On the other hand, JoeG already brought up the idea of making ‘self’ the first argument of the implicit static member. It still doesn’t solve the problem of picking a protocol extension, but that’s not new. (This isn’t a complaint, I guess, just a note.)<br></p><p><br>I’m not sure I have a meaningful summary or conclusion, but I’d be hesitant to do all of this without these concerns being addressed.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/f596abe1/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>On Apr 28, 2016, at 10:00 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; Hi, Erica. Sorry for not participating in the first round here. I’m…not so happy with this direction, for a number of reasons. (I apologize for the laundry list, but they’re not really related complaints.)<br>&gt; <br>&gt; - ‘required’ already means something today: it means “this initializer must be present on all subclasses”. The reason it only applies to initializers is because all other members are always present on all subclasses.<br>&gt; <br>&gt; (Counter-argument: using ‘required’ on an initializer could be seen as making an implicit protocol, just for that class hierarchy.)<br>&gt; <br>&gt; - ‘override’ likewise already has a meaning; allowing ‘override’ to be satisfied by a protocol requirement means that it might miss an override intended for a superclass—or inadvertently become one when an SDK is updated.<br>&gt; <br>&gt; (Counter-argument: that last can happen to protocols already.)<br>&gt; <br>&gt; - This doesn’t cover cases where methods in one protocol extension satisfy requirements in another.<br>&gt; <br>&gt; - This doesn’t cover retroactive modeling.<br>&gt; <br>&gt; - I’m not sure what it means to &quot;prefer an overridden implementation in preference in reverse hierarchical order: type extensions take precedence over type declarations over protocol extensions over protocol declarations (assuming protocol declarations eventually adopt default implementations)”. Protocol conformance is decided at compile time; there won’t ever be any members in type extensions that take precedent over a type declaration without causing a conflict. (That is, currently you are not allowed to define such a member.)<br>&gt; <br>&gt; - A member in the type does not “override&quot; a member in a protocol extension today, because such a call is not dynamically dispatched. Making protocol extension members dynamically dispatched is challenging at the least and would require an implementation plan in the proposal.<br>&gt; <br>&gt; - Thank you for writing up all of the source compatibility cases! I think there’s no issue with binary compatibility, since IIUC the proposal doesn’t change how anything is implemented, and we think we know how to handle binary compatibility there. But I’d like to think about it a little more.<br>&gt; <br>&gt; - The “A.foo(self)()” syntax is clever, but it doesn’t work correctly for mutating methods (because you can’t curry an inout). On the other hand, JoeG already brought up the idea of making ‘self’ the first argument of the implicit static member. It still doesn’t solve the problem of picking a protocol extension, but that’s not new. (This isn’t a complaint, I guess, just a note.)<br>&gt; <br>&gt; <br>&gt; I’m not sure I have a meaningful summary or conclusion, but I’d be hesitant to do all of this without these concerns being addressed.<br>&gt; <br>&gt; Jordan<br></p><p>I&#39;ve arrived at the &quot;just table it and find something more productive to work on&quot; stage.  This pitch grew out of my conviction that doing &quot;near miss&quot; detection was the wrong approach for supporting and documenting developer intent decisions. If there&#39;s no strong support my the core concept (enhancing safety by introducing semantic compiler hints) then all the implementation details in the world don&#39;t get me anywhere.<br></p><p>Without developing a quorum that supports the underlying philosophy, regardless of implementation, I&#39;m not going to push this any further. The gist is updated but I have no plans to further mold it into a proposal.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/ae81b490/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 29, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;d be keenly interested in something that would improve the experience of<br>conforming a type to a protocol. I think others would as well. A<br>sufficiently sophisticated solution would:<br></p><p>* catch unintentional typos that cause required functions to be incorrectly<br>named<br>* show, ideally prospectively, which required functions have default<br>implementations<br>* clarify (and this is obviously a cherry-on-top scenario) what protocol<br>requirements any particular function helps to satisfy as well as which<br>combination of implementations is used to synthesize a default<br>implementation of another function (e.g. &lt;= synthesized from &lt; and ==; this<br>would help to determine whether it might be more efficient to roll your own<br>override)<br>* support all retroactive modeling scenarios currently supported<br></p><p>I tried to propose a keyword-based solution (less sophisticated than yours)<br>a while back, and I&#39;ve been convinced that the drawbacks in terms of<br>decreased expressiveness in retroactive modeling might be insurmountable.<br>Perhaps it would be worthwhile exploring improvements in tooling and<br>documentation (including annotation of the code itself) in order to address<br>some of these areas?<br>On Fri, Apr 29, 2016 at 09:14 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Apr 28, 2016, at 10:00 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt;<br>&gt; Hi, Erica. Sorry for not participating in the first round here. I’m…not so<br>&gt; happy with this direction, for a number of reasons. (I apologize for the<br>&gt; laundry list, but they’re not really related complaints.)<br>&gt;<br>&gt; - ‘required’ already means something today: it means “this initializer<br>&gt; must be present on all subclasses”. The reason it only applies<br>&gt; to initializers is because all other members are always present on all<br>&gt; subclasses.<br>&gt;<br>&gt; (Counter-argument: using ‘required’ on an initializer could be seen as<br>&gt; making an implicit protocol, just for that class hierarchy.)<br>&gt;<br>&gt; - ‘override’ likewise already has a meaning; allowing ‘override’ to be<br>&gt; satisfied by a protocol requirement means that it might miss an<br>&gt; override intended for a superclass—or inadvertently become one when an SDK<br>&gt; is updated.<br>&gt;<br>&gt; (Counter-argument: that last can happen to protocols already.)<br>&gt;<br>&gt; - This doesn’t cover cases where methods in one protocol extension satisfy<br>&gt; requirements in another.<br>&gt;<br>&gt; - This doesn’t cover retroactive modeling.<br>&gt;<br>&gt; - I’m not sure what it means to &quot;prefer an overridden implementation in<br>&gt; preference in reverse hierarchical order: type extensions take precedence<br>&gt; over type declarations over protocol extensions over protocol declarations<br>&gt; (assuming protocol declarations eventually adopt default implementations)”.<br>&gt; Protocol conformance is decided at compile time; there won’t ever be any<br>&gt; members in type extensions that take precedent over a type declaration<br>&gt; without causing a conflict. (That is, currently you are not allowed to<br>&gt; define such a member.)<br>&gt;<br>&gt; - A member in the type does *not* “override&quot; a member in a protocol<br>&gt; extension today, because such a call is not dynamically dispatched. Making<br>&gt; protocol extension members dynamically dispatched is challenging at the<br>&gt; least and would require an implementation plan in the proposal.<br>&gt;<br>&gt; - Thank you for writing up all of the source compatibility cases! I<br>&gt; *think* there’s no issue with binary compatibility, since IIUC the<br>&gt; proposal doesn’t change how anything is implemented, and we think we know<br>&gt; how to handle binary compatibility there. But I’d like to think about it<br>&gt; a little more.<br>&gt;<br>&gt; - The “A.foo(self)()” syntax is clever, but it doesn’t work correctly for<br>&gt; mutating methods (because you can’t curry an inout). On the other hand,<br>&gt; JoeG already brought up the idea of making ‘self’ the first argument of the<br>&gt; implicit static member. It still doesn’t solve the problem of *picking* a<br>&gt; protocol extension, but that’s not new. (This isn’t a complaint, I guess,<br>&gt; just a note.)<br>&gt;<br>&gt;<br>&gt; I’m not sure I have a meaningful summary or conclusion, but I’d be<br>&gt; hesitant to do all of this without these concerns being addressed.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt; I&#39;ve arrived at the &quot;just table it and find something more productive to<br>&gt; work on&quot; stage.  This pitch grew out of my conviction that doing &quot;near<br>&gt; miss&quot; detection was the wrong approach for supporting and documenting<br>&gt; developer intent decisions. If there&#39;s no strong support my the core<br>&gt; concept (enhancing safety by introducing semantic compiler hints) then all<br>&gt; the implementation details in the world don&#39;t get me anywhere.<br>&gt;<br>&gt; Without developing a quorum that supports the underlying philosophy,<br>&gt; regardless of implementation, I&#39;m not going to push this any further. The<br>&gt; gist is updated but I have no plans to further mold it into a proposal.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/029196f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 8:38 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I&#39;d be keenly interested in something that would improve the experience of conforming a type to a protocol. I think others would as well. A sufficiently sophisticated solution would:<br>&gt; <br>&gt; * catch unintentional typos that cause required functions to be incorrectly named<br>&gt; * show, ideally prospectively, which required functions have default implementations<br>&gt; * clarify (and this is obviously a cherry-on-top scenario) what protocol requirements any particular function helps to satisfy as well as which combination of implementations is used to synthesize a default implementation of another function (e.g. &lt;= synthesized from &lt; and ==; this would help to determine whether it might be more efficient to roll your own override)<br>&gt; * support all retroactive modeling scenarios currently supported<br>&gt; <br>&gt; I tried to propose a keyword-based solution (less sophisticated than yours) a while back, and I&#39;ve been convinced that the drawbacks in terms of decreased expressiveness in retroactive modeling might be insurmountable. Perhaps it would be worthwhile exploring improvements in tooling and documentation (including annotation of the code itself) in order to address some of these areas?<br></p><p>Hop over to the protocol non-conformance clause thread for a moment, if you could.<br></p><p>-- E<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>April 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 29, 2016, at 10:38 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d be keenly interested in something that would improve the experience of conforming a type to a protocol. I think others would as well. A sufficiently sophisticated solution would:<br>&gt; <br>&gt; * catch unintentional typos that cause required functions to be incorrectly named<br>&gt; * show, ideally prospectively, which required functions have default implementations<br>&gt; * clarify (and this is obviously a cherry-on-top scenario) what protocol requirements any particular function helps to satisfy as well as which combination of implementations is used to synthesize a default implementation of another function (e.g. &lt;= synthesized from &lt; and ==; this would help to determine whether it might be more efficient to roll your own override)<br>&gt; * support all retroactive modeling scenarios currently supported<br>&gt; <br>&gt; I tried to propose a keyword-based solution (less sophisticated than yours) a while back, and I&#39;ve been convinced that the drawbacks in terms of decreased expressiveness in retroactive modeling might be insurmountable. Perhaps it would be worthwhile exploring improvements in tooling and documentation (including annotation of the code itself) in order to address some of these areas?<br></p><p>Yeah, I think this is something that tooling / editors could really help with.  I would love it if when I typed:<br></p><p>	struct Foo: Bar<br></p><p>or<br></p><p>	extension Foo: Bar<br></p><p>a skeleton with the missing Bar APIs was auto-generated for me to fill in.  This would make it much easier to get conformances right, and require less typing instead of more.<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>April 29, 2016 at 10:00:00pm</p></header><div class="content"><p>I believe the following idea was brought up on the list the last time this topic came up, but I think it has a number of advantages and gets rid of the need for a &#39;required&#39; keyword completely. I have reservations on the &#39;override&#39; keyword as well, but the following idea would not preclude adding the &#39;override&#39; keyword.<br></p><p>If an extension adds protocol conformance, only methods implementing the protocol are allowed in the body.  All methods from the protocol do not need to be implemented in the extension, so long as the type conforms overall.<br></p><p>struct Foo {<br>   func a() {}<br>}<br></p><p>protocol A {<br>   func a()<br>}<br>protocol B {<br>   func b()<br>}<br>protocol C {} <br></p><p><br>extension Foo: A { } // retroactive modeling, no error<br></p><p>extension Foo: B {<br>   func b() {} // compiles, but &quot;near miss&quot; would not<br>}<br></p><p>extension Foo: C {<br>   func d() {} // error, d() not part of protocol C<br>}<br></p><p>Advantages:<br>- Clarifies intent... If you are implementing a method in an extension that declares a protocol conformance, it has to satisfy that one of that protocol&#39;s requirements<br>- Eliminates &quot;near-miss&quot; mistakes when implementing a function in an extension that declares protocol conformance, even in protocol has a default implementation (it would be an error to implement the non-matching-but-almost func)<br>- Fully supports retroactive modeling<br>- No new keywords required<br></p><p>Disadvantages:<br>- Source breaking change for any code that currently declares protocol conformance in an extension and implements an unrelated method<br>- Potential inconsistency with base type declaration (does this rule apply only to extensions or the initial declaration of the type?)<br>- Does not stop you from accidentally writing a implementation for a method that already has a default implementation in the protocol (though nothing here precludes the addition of adding &#39;override&#39; as well)<br></p><p>Effectively, the only change required to current code would be to modify the above implementation of:<br></p><p>extension Foo: C {<br>   func d() {}<br>}<br></p><p>To read:<br></p><p>extension Foo: C {}<br>extension Foo {<br>   func d() {}<br>}<br></p><p>On Apr 29, 2016, at 11:44, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 29, 2016, at 10:38 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d be keenly interested in something that would improve the experience of conforming a type to a protocol. I think others would as well. A sufficiently sophisticated solution would:<br>&gt;&gt; <br>&gt;&gt; * catch unintentional typos that cause required functions to be incorrectly named<br>&gt;&gt; * show, ideally prospectively, which required functions have default implementations<br>&gt;&gt; * clarify (and this is obviously a cherry-on-top scenario) what protocol requirements any particular function helps to satisfy as well as which combination of implementations is used to synthesize a default implementation of another function (e.g. &lt;= synthesized from &lt; and ==; this would help to determine whether it might be more efficient to roll your own override)<br>&gt;&gt; * support all retroactive modeling scenarios currently supported<br>&gt;&gt; <br>&gt;&gt; I tried to propose a keyword-based solution (less sophisticated than yours) a while back, and I&#39;ve been convinced that the drawbacks in terms of decreased expressiveness in retroactive modeling might be insurmountable. Perhaps it would be worthwhile exploring improvements in tooling and documentation (including annotation of the code itself) in order to address some of these areas?<br>&gt; <br>&gt; Yeah, I think this is something that tooling / editors could really help with.  I would love it if when I typed:<br>&gt; <br>&gt;   struct Foo: Bar<br>&gt; <br>&gt; or<br>&gt; <br>&gt;   extension Foo: Bar<br>&gt; <br>&gt; a skeleton with the missing Bar APIs was auto-generated for me to fill in.  This would make it much easier to get conformances right, and require less typing instead of more.<br>&gt; <br>&gt; – Steve<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 27, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 12:31 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; On Apr 27, 2016, at 12:25 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 27, 2016, at 10:10 AM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {<br>&gt;&gt;&gt;     func foo()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension A {<br>&gt;&gt;&gt;     func foo() { .. default implementation … }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type B: A {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     override required func foo () { … overrides implementation … }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; A couple questions about your pitch:<br>&gt;&gt; <br>&gt;&gt; 1) What is “required” doing there? <br>&gt; <br>&gt; I threw it in not because I’m tied to it but because I wanted it to be part of the conversation.<br>&gt; This is a requirement from conforming to the protocol.<br></p><p>Ah. Note that this isn’t *quite* the meaning of “required” for initializers of classes (where it means “my subclasses must override this”), but in practice it’s basically the only reason why anyone uses “required” for initializers.<br></p><p>&gt; <br>&gt;&gt; 2) Is “override” only required when there is a default implementation of the protocol requirement, or is it required whenever you are implementing a protocol requirement?<br>&gt; <br>&gt; Override is only because it is overriding the default implementation of the protocol requirement. Without that default implementation there would be no override, it would simply be satisfying the requirement.<br></p><p>For me, this doesn’t provide additional value of “required”: i.e., the value of having a keyword here is in telling me that I failed to implement a requirement when I’ve clearly said that I wanted to implement a requirement. Whether there was a default there or not isn’t really very interesting. Plus, a default could be added later to a requirement that I implement: that change has zero impact on how my code works (before or after), but now I’d be require to add an “override” keyword when I recompile.<br></p><p>Contrast that with classes: if you recompile against a new version of a library and the compiler tells you that you need to add “override”, it’s serious because the semantics of your program will change if you’re now overriding something that you weren’t before.<br></p><p>&gt; <br>&gt;&gt; 	* If the former, it might be the case that it’s too easy to forget to add the “override” keyword (because it’s needed for some implementations of protocol requirements but not others), which undercuts the value of having it.<br>&gt; <br>&gt; Forcing the override keyword makes it clear at the definition point that the story extends beyond the method or whatever to point to a default implementation that is being replaced. I *really* like having that reference in terms of both code construction (“I am doing this as a deliberate act”) with the compiler complaining otherwise, and in terms of code self documentation (“I know this was added deliberately, what default did it override?”)<br></p><p>I see the former (“I am doing this as a deliberate act”)  as a very common complaint; the latter not nearly as much. What motivates that? And does it justify adding a *second* keyword to these declarations?<br></p><p>&gt;&gt; I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type B: A, C {<br>&gt;&gt;&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I think the right answer here is for the compiler to produce an ambiguity if you don’t implement the requirement yourself, and then solving your “related topic 2” lets you choose which implementation you want.<br>&gt; <br>&gt; How do you choose which one? What syntax? For example:<br>&gt; <br>&gt; required func foo = A.foo<br>&gt; <br>&gt; would be the simplest approach<br></p><p>type B: A, C {<br>  override required func foo() { A.foo(self)() }<br>}<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; type B: A {<br>&gt;&gt;&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Seems totally reasonable to me. One ugly syntax: A.foo(self)(), leveraging the currying of self?<br>&gt; <br>&gt; Ugly but it would pretty much do it for me. It offers an expressive way to say “Please execute the A.foo behavior using the self instance”. Does 3 still support this?<br></p><p>Probably not? I actually don’t know ;)<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/768e1944/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 6:03 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; 2) Is “override” only required when there is a default implementation of the protocol requirement, or is it required whenever you are implementing a protocol requirement?<br>&gt;&gt; <br>&gt;&gt; Override is only because it is overriding the default implementation of the protocol requirement. Without that default implementation there would be no override, it would simply be satisfying the requirement.<br>&gt; <br>&gt; For me, this doesn’t provide additional value of “required”: i.e., the value of having a keyword here is in telling me that I failed to implement a requirement when I’ve clearly said that I wanted to implement a requirement. Whether there was a default there or not isn’t really very interesting. Plus, a default could be added later to a requirement that I implement: that change has zero impact on how my code works (before or after), but now I’d be require to add an “override” keyword when I recompile.<br>&gt; <br>&gt; Contrast that with classes: if you recompile against a new version of a library and the compiler tells you that you need to add “override”, it’s serious because the semantics of your program will change if you’re now overriding something that you weren’t before.<br></p><p>Consider these situations:<br></p><p>* I use the word &#39;required&#39; but I use a Double in the signature instead of a Float. Compiler detects. Instant alert on the mismatch.<br>* I implement a required member but fail to use the word required. Compiler detects. Instant alert: this is a required member, did you intend to use this signature for that purpose?<br>* I implement a required member. I then later provide a default. Compiler detects. &quot;This version will be overridden by the default version the protocol and/or extension. Either remove this implementation or add the override keyword to prefer it to the default version.&quot;<br>* I implement a default version and then later implement the required member. Compiler detects Same warning as above. <br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 	* If the former, it might be the case that it’s too easy to forget to add the “override” keyword (because it’s needed for some implementations of protocol requirements but not others), which undercuts the value of having it.<br>&gt;&gt; <br>&gt;&gt; Forcing the override keyword makes it clear at the definition point that the story extends beyond the method or whatever to point to a default implementation that is being replaced. I *really* like having that reference in terms of both code construction (“I am doing this as a deliberate act”) with the compiler complaining otherwise, and in terms of code self documentation (“I know this was added deliberately, what default did it override?”)<br>&gt; <br>&gt; I see the former (“I am doing this as a deliberate act”)  as a very common complaint; the latter not nearly as much. What motivates that? And does it justify adding a *second* keyword to these declarations?<br></p><p>I think I caught the gist in the situations above. If not, will respond further.<br></p><p>&gt; <br>&gt;&gt;&gt; I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; type B: A, C {<br>&gt;&gt;&gt;&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the right answer here is for the compiler to produce an ambiguity if you don’t implement the requirement yourself, and then solving your “related topic 2” lets you choose which implementation you want.<br>&gt;&gt; <br>&gt;&gt; How do you choose which one? What syntax? For example:<br>&gt;&gt; <br>&gt;&gt; required func foo = A.foo<br>&gt;&gt; <br>&gt;&gt; would be the simplest approach<br>&gt; <br>&gt; type B: A, C {<br>&gt;   override required func foo() { A.foo(self)() }<br>&gt; }<br></p><p>+1<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; type B: A {<br>&gt;&gt;&gt;&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Seems totally reasonable to me. One ugly syntax: A.foo(self)(), leveraging the currying of self?<br>&gt;&gt; <br>&gt;&gt; Ugly but it would pretty much do it for me. It offers an expressive way to say “Please execute the A.foo behavior using the self instance”. Does 3 still support this?<br>&gt; <br>&gt; Probably not? I actually don’t know ;)<br></p><p>I vaguely remember some stuff being changed. I&#39;d normally try to test but I can&#39;t get a dev build to work in Xcode since the March 24 build. :(<br></p><p>-- E<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/bb51ce63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 29, 2016 at 10:00:00am</p></header><div class="content"><p>Hey, what annotations would I have in this case:<br></p><p>Module 1:<br></p><p>Type AType { func foo() { ... } }<br></p><p>Module 2:<br></p><p>import Module1protocol A { func foo() {...default...} }extension AType: A {}<br></p><p><br></p><p>Also, for your *alternatives* section:<br></p><p>protocol A { func foo() {...default...} }Type AType: A {<br>    func A.foo() {...replacement...}<br>}<br></p><p><br>I actually prefer this alternative, I think it fixes many issues.<br></p><p><br>On Thu, Apr 28, 2016 at 12:47 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 27, 2016, at 6:03 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;<br>&gt; 2) Is “override” only required when there is a default implementation of<br>&gt; the protocol requirement, or is it required whenever you are implementing a<br>&gt; protocol requirement?<br>&gt;<br>&gt;<br>&gt; Override is only because it is overriding the default implementation of<br>&gt; the protocol requirement. Without that default implementation there would<br>&gt; be no override, it would simply be satisfying the requirement.<br>&gt;<br>&gt;<br>&gt; For me, this doesn’t provide additional value of “required”: i.e., the<br>&gt; value of having a keyword here is in telling me that I failed to implement<br>&gt; a requirement when I’ve clearly said that I wanted to implement a<br>&gt; requirement. Whether there was a default there or not isn’t really very<br>&gt; interesting. Plus, a default could be added later to a requirement that I<br>&gt; implement: that change has zero impact on how my code works (before or<br>&gt; after), but now I’d be require to add an “override” keyword when I<br>&gt; recompile.<br>&gt;<br>&gt; Contrast that with classes: if you recompile against a new version of a<br>&gt; library and the compiler tells you that you need to add “override”, it’s<br>&gt; serious because the semantics of your program will change if you’re now<br>&gt; overriding something that you weren’t before.<br>&gt;<br>&gt;<br>&gt; Consider these situations:<br>&gt;<br>&gt; * I use the word &#39;required&#39; but I use a Double in the signature instead of<br>&gt; a Float. Compiler detects. Instant alert on the mismatch.<br>&gt; * I implement a required member but fail to use the word required.<br>&gt; Compiler detects. Instant alert: this is a required member, did you intend<br>&gt; to use this signature for that purpose?<br>&gt; * I implement a required member. I then later provide a default. Compiler<br>&gt; detects. &quot;This version will be overridden by the default version the<br>&gt; protocol and/or extension. Either remove this implementation or add the<br>&gt; override keyword to prefer it to the default version.&quot;<br>&gt; * I implement a default version and then later implement the required<br>&gt; member. Compiler detects Same warning as above.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; * If the former, it might be the case that it’s too easy to forget to add<br>&gt; the “override” keyword (because it’s needed for some implementations of<br>&gt; protocol requirements but not others), which undercuts the value of having<br>&gt; it.<br>&gt;<br>&gt;<br>&gt; Forcing the override keyword makes it clear at the definition point that<br>&gt; the story extends beyond the method or whatever to point to a default<br>&gt; implementation that is being replaced. I *really* like having that<br>&gt; reference in terms of both code construction (“I am doing this as a<br>&gt; deliberate act”) with the compiler complaining otherwise, and in terms of<br>&gt; code self documentation (“I know this was added deliberately, what default<br>&gt; did it override?”)<br>&gt;<br>&gt;<br>&gt; I see the former (“I am doing this as a deliberate act”)  as a very common<br>&gt; complaint; the latter not nearly as much. What motivates that? And does it<br>&gt; justify adding a *second* keyword to these declarations?<br>&gt;<br>&gt;<br>&gt; I think I caught the gist in the situations above. If not, will respond<br>&gt; further.<br>&gt;<br>&gt;<br>&gt; I’d also like to bring up two related topics, although they probably<br>&gt; should at some point move to their own thread if they have any legs:<br>&gt;<br>&gt;<br>&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt; unrelated protocols both require the same member and offer different<br>&gt; default implementations. Can they specify which implementation to accept or<br>&gt; somehow run both?<br>&gt;<br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I think the right answer here is for the compiler to produce an ambiguity<br>&gt; if you don’t implement the requirement yourself, and then solving your<br>&gt; “related topic 2” lets you choose which implementation you want.<br>&gt;<br>&gt;<br>&gt; How do you choose which one? What syntax? For example:<br>&gt;<br>&gt; required func foo = A.foo<br>&gt;<br>&gt; would be the simplest approach<br>&gt;<br>&gt;<br>&gt; type B: A, C {<br>&gt;   override required func foo() { A.foo(self)() }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt;<br>&gt; Related topic 2: How can a consumer “inherit” the behavior of the default<br>&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt; works. I’d like to be able to call A.foo() and then add custom follow-on<br>&gt; behavior rather than entirely replacing the behavior.<br>&gt;<br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Seems totally reasonable to me. One ugly syntax: A.foo(self)(), leveraging<br>&gt; the currying of self?<br>&gt;<br>&gt;<br>&gt; Ugly but it would pretty much do it for me. It offers an expressive way to<br>&gt; say “Please execute the A.foo behavior using the self instance”. Does 3<br>&gt; still support this?<br>&gt;<br>&gt;<br>&gt; Probably not? I actually don’t know ;)<br>&gt;<br>&gt;<br>&gt; I vaguely remember some stuff being changed. I&#39;d normally try to test but<br>&gt; I can&#39;t get a dev build to work in Xcode since the March 24 build. :(<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/8be10348/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 6:44 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hey, what annotations would I have in this case:<br>&gt; <br>&gt; Module 1:<br>&gt; Type AType { func foo() { ... } }<br>&gt; Module 2:<br>&gt; import Module1<br>&gt; protocol A { func foo() {...default...} }<br>&gt; extension AType: A {}<br>&gt; <br></p><p>No annotations. AType&#39;s implementation of foo is unrelated to its conformance, which is satisfied by its existing foo method.<br></p><p><br>&gt; Also, for your alternatives section:<br>&gt; <br>&gt; protocol A { func foo() {...default...} }<br>&gt; Type AType: A {<br>&gt;     func A.foo() {...replacement...}<br>&gt; }<br>&gt; <br>&gt; I actually prefer this alternative, I think it fixes many issues.<br></p><p>Protocol default implementations do not yet exist.  <br></p><p>In this second, you&#39;re suggesting instead of doing &quot;override required&quot;, you use a naming approach that ties the implementation the specific protocol. I&#39;m not really won over by this approach:<br></p><p>* It does clarify why the method is included<br>* It does not clarify that the method overrides an existing implementation.<br>* It could be more easily confused when members are required by multiple protocols.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/4e8d8812/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 29, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks for clarifying, my responses are inline.<br></p><p>On Fri, Apr 29, 2016 at 10:51 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Apr 28, 2016, at 6:44 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; Hey, what annotations would I have in this case:<br>&gt;<br>&gt; Module 1:<br>&gt;<br>&gt; Type AType { func foo() { ... } }<br>&gt;<br>&gt; Module 2:<br>&gt;<br>&gt; import Module1protocol A { func foo() {...default...} }extension AType: A {}<br>&gt;<br>&gt;<br>&gt;<br>&gt; No annotations. AType&#39;s implementation of foo is unrelated to its<br>&gt; conformance, which is satisfied by its existing foo method.<br>&gt;<br></p><p>Thanks, that resolves my misunderstanding. I thought there would need to be<br>an override or similar.<br></p><p><br>&gt;<br>&gt;<br>&gt; Also, for your *alternatives* section:<br>&gt;<br>&gt; protocol A { func foo() {...default...} }Type AType: A {<br>&gt;     func A.foo() {...replacement...}<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I actually prefer this alternative, I think it fixes many issues.<br>&gt;<br>&gt;<br>&gt; Protocol default implementations do not yet exist.<br>&gt;<br>&gt; In this second, you&#39;re suggesting instead of doing &quot;override required&quot;,<br>&gt; you use a naming approach that ties the implementation the specific<br>&gt; protocol. I&#39;m not really won over by this approach:<br>&gt;<br>&gt; * It does clarify why the method is included<br>&gt; * It does not clarify that the method overrides an existing implementation.<br>&gt;<br>I agree with this, your `override` keyword would work well here.<br></p><p>* It could be more easily confused when members are required by multiple<br>&gt; protocols.<br>&gt;<br>I see this as a feature. I think this member should *only* implement it for<br>a single protocol.<br></p><p>If you have the same member in multiple protocols, then they potentially<br>(probably) do different things. They may want different implementations. If<br>the member is meant to represent the same thing, then it should be<br>extracted into a common protocol.<br></p><p><br>&gt; -- E<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/45e3cb7a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ece55ca3fe50dca9c70bcd914acb48a5?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Judge</string> &lt;matthew.judge at gmail.com&gt;<p>April 29, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Apr 28, 2016, at 20:51, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 28, 2016, at 6:44 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hey, what annotations would I have in this case:<br>&gt;&gt; <br>&gt;&gt; Module 1:<br>&gt;&gt; Type AType { func foo() { ... } }<br>&gt;&gt; Module 2:<br>&gt;&gt; import Module1<br>&gt;&gt; protocol A { func foo() {...default...} }<br>&gt;&gt; extension AType: A {}<br>&gt; <br>&gt; No annotations. AType&#39;s implementation of foo is unrelated to its conformance, which is satisfied by its existing foo method.<br>&gt; <br></p><p>How does this match the first line in your &quot;Handling Changes&quot; table?<br></p><p>(from your table, for reference)<br>Original:  Some  member implemented in type<br>Change:  Protocol adds that member<br>Outcome:  Must add &#39;required&#39; to type implementation or rename member to avoid conflict<br></p><p>&gt;&gt; Also, for your alternatives section:<br>&gt;&gt; <br>&gt;&gt; protocol A { func foo() {...default...} }<br>&gt;&gt; Type AType: A {<br>&gt;&gt;     func A.foo() {...replacement...}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I actually prefer this alternative, I think it fixes many issues.<br>&gt; <br>&gt; Protocol default implementations do not yet exist.  <br>&gt; <br>&gt; In this second, you&#39;re suggesting instead of doing &quot;override required&quot;, you use a naming approach that ties the implementation the specific protocol. I&#39;m not really won over by this approach:<br>&gt; <br>&gt; * It does clarify why the method is included<br>&gt; * It does not clarify that the method overrides an existing implementation.<br>&gt; * It could be more easily confused when members are required by multiple protocols.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/c684b127/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 27, 2016 at 09:00:00pm</p></header><div class="content"><p>IMO very important questions and suggestions.<br></p><p>Firstly, wanted to ask about &quot;required&quot; keyword in your examples - do we <br>expect to have it in meaning &quot;implementing the protocol method&quot; ? I&#39;d like <br>to have it very much.<br></p><p>* About the &quot;override&quot; keyword : +1 from me. We should be clear and <br>explicit if we override method from default protocol implementation.<br>Right now (as I understand) we have some mess when class and protocol has <br>the same methods. For example :<br></p><p>protocol A {}<br></p><p>extension A {<br>     func y() {print(&quot;Y in A&quot;)}<br>}<br></p><p>class C:A {<br>     func y() {<br>         print(&quot;Y in C&quot;)<br>     }<br>}<br></p><p>var c : A = C()<br>c.y() // what do you expect? &quot;Y in A&quot; is here. I expected &quot;Y in C&quot;<br></p><p><br>Related topic 1&amp;2 : IMO as soon as we have implementation in our protocols, <br>and in this case they are &#39;like&#39; classes, we need to be able to deal with <br>these default methods implemented in protocols.<br></p><p>I.e. my point is if we allow protocols to be &#39;like&#39; classes (to have <br>implementations in methods), we need the tools(override,super.xxx) &#39;like&#39; <br>we have when inherit one class from another.<br></p><p>On 27.04.2016 20:10, Erica Sadun via swift-evolution wrote:<br>&gt; From the Swift Programming Language: /Methods on a subclass that override<br>&gt; the superclass’s implementation are marked with override—overriding a<br>&gt; method by accident, without override, is detected by the compiler as an<br>&gt; error. The compiler also detects methods with override that don’t actually<br>&gt; override any method in the superclass./<br>&gt;<br>&gt; I would like to extend this cautious approach to protocols, forcing the<br>&gt; developer to deliberately override an implementation that’s inherited from<br>&gt; a protocol extension. This would prevent accidental overrides and force the<br>&gt; user to proactively choose to implement a version of a protocol member that<br>&gt; already exists in the protocol extension.<br>&gt;<br>&gt; I envision this as using the same `override` keyword that’s used in class<br>&gt; based inheritance but extend it to protocol inheritance:<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt;<br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt;<br>&gt; type B: A {<br>&gt;<br>&gt;     override required func foo () { … overrides implementation … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I’d also like to bring up two related topics, although they probably should<br>&gt; at some point move to their own thread if they have any legs:<br>&gt;<br>&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt; unrelated protocols both require the same member and offer different<br>&gt; default implementations. Can they specify which implementation to accept or<br>&gt; somehow run both?<br>&gt;<br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt;<br>&gt; Related topic 2: How can a consumer “inherit” the behavior of the default<br>&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt; works. I’d like to be able to call A.foo() and then add custom follow-on<br>&gt; behavior rather than entirely replacing the behavior.<br>&gt;<br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt; }<br>&gt;<br>&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has<br>&gt; already expressed some objections so I want him to  have the opportunity to<br>&gt; bring that discussion here.<br>&gt;<br>&gt; — E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 12:39 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; IMO very important questions and suggestions.<br>&gt; <br>&gt; Firstly, wanted to ask about &quot;required&quot; keyword in your examples - do we expect to have it in meaning &quot;implementing the protocol method&quot; ? I&#39;d like to have it very much.<br></p><p>I included it to mean “implementing a required protocol method”, providing a compile-time check that specifically addresses the same kind of issue as “near miss” detection. <br></p><p>&gt; * About the &quot;override&quot; keyword : +1 from me. We should be clear and explicit if we override method from default protocol implementation.<br>&gt; Right now (as I understand) we have some mess when class and protocol has the same methods. For example :<br>&gt; <br>&gt; protocol A {}<br>&gt; <br>&gt; extension A {<br>&gt;    func y() {print(&quot;Y in A&quot;)}<br>&gt; }<br>&gt; <br>&gt; class C:A {<br>&gt;    func y() {<br>&gt;        print(&quot;Y in C&quot;)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; var c : A = C()<br>&gt; c.y() // what do you expect? &quot;Y in A&quot; is here. I expected &quot;Y in C”<br></p><p>overriding a defaulted method without specific clarity of intent should raise a compiler warning. It is a likely spot where a developer may have acted without meaning to. Mandating override introduces another level of safety.<br></p><p>&gt; Related topic 1&amp;2 : IMO as soon as we have implementation in our protocols, and in this case they are &#39;like&#39; classes, we need to be able to deal with these default methods implemented in protocols.<br>&gt; <br>&gt; I.e. my point is if we allow protocols to be &#39;like&#39; classes (to have implementations in methods), we need the tools(override,super.xxx) &#39;like&#39; we have when inherit one class from another.<br>&gt; <br>&gt; On 27.04.2016 20:10, Erica Sadun via swift-evolution wrote:<br>&gt;&gt; From the Swift Programming Language: /Methods on a subclass that override<br>&gt;&gt; the superclass’s implementation are marked with override—overriding a<br>&gt;&gt; method by accident, without override, is detected by the compiler as an<br>&gt;&gt; error. The compiler also detects methods with override that don’t actually<br>&gt;&gt; override any method in the superclass./<br>&gt;&gt; <br>&gt;&gt; I would like to extend this cautious approach to protocols, forcing the<br>&gt;&gt; developer to deliberately override an implementation that’s inherited from<br>&gt;&gt; a protocol extension. This would prevent accidental overrides and force the<br>&gt;&gt; user to proactively choose to implement a version of a protocol member that<br>&gt;&gt; already exists in the protocol extension.<br>&gt;&gt; <br>&gt;&gt; I envision this as using the same `override` keyword that’s used in class<br>&gt;&gt; based inheritance but extend it to protocol inheritance:<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;    func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;    func foo() { .. default implementation … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; type B: A {<br>&gt;&gt; <br>&gt;&gt;    override required func foo () { … overrides implementation … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I’d also like to bring up two related topics, although they probably should<br>&gt;&gt; at some point move to their own thread if they have any legs:<br>&gt;&gt; <br>&gt;&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt;&gt; unrelated protocols both require the same member and offer different<br>&gt;&gt; default implementations. Can they specify which implementation to accept or<br>&gt;&gt; somehow run both?<br>&gt;&gt; <br>&gt;&gt; type B: A, C {<br>&gt;&gt;    override required func foo() { A.foo(); C.foo() }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Related topic 2: How can a consumer “inherit” the behavior of the default<br>&gt;&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt;&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt;&gt; works. I’d like to be able to call A.foo() and then add custom follow-on<br>&gt;&gt; behavior rather than entirely replacing the behavior.<br>&gt;&gt; <br>&gt;&gt; type B: A {<br>&gt;&gt;    override required func foo() { A.foo(); … my custom behavior … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has<br>&gt;&gt; already expressed some objections so I want him to  have the opportunity to<br>&gt;&gt; bring that discussion here.<br>&gt;&gt; <br>&gt;&gt; — E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/743ea9b8e49fa6a8390b2f4b3e1a588f?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Jerome ALVES</string> &lt;j.alves at me.com&gt;<p>April 27, 2016 at 10:00:00pm</p></header><div class="content"><p>What if... <br></p><p>FooBar.framework defines :<br>public protocol A {<br>    func foo()<br>}<br>public type B: A {<br>    public func foo () { <br>          … implementation … <br>    }<br>}<br></p><p>Other module defines :<br>import FooBar<br>extension A {<br>    func foo() { .. default implementation … }<br>}<br></p><p><br>Jérôme <br></p><p>&gt; Le 27 avr. 2016 à 19:10, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt; <br>&gt; type B: A {<br>&gt; <br>&gt;     override required func foo () { … overrides implementation … }<br>&gt; }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/219306f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/19e063a2e39db5f58ed5ab02d14c1879?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Matthew Johnson</string> &lt;musical.matthew at mac.com&gt;<p>April 27, 2016 at 03:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 27, 2016, at 3:08 PM, Jérôme ALVES via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What if... <br>&gt; <br>&gt; FooBar.framework defines :<br>&gt; public protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt; public type B: A {<br>&gt;     public func foo () { <br>&gt;           … implementation … <br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Other module defines :<br>&gt; import FooBar<br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt; <br></p><p>This is a good example.  More generally, we should be sure that any change we make here does not interfere with retroactive modeling.<br></p><p>&gt; <br>&gt; Jérôme <br>&gt; <br>&gt;&gt; Le 27 avr. 2016 à 19:10, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;     func foo() { .. default implementation … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; type B: A {<br>&gt;&gt; <br>&gt;&gt;     override required func foo () { … overrides implementation … }<br>&gt;&gt; }<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/a2d1f319/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 27, 2016 at 02:00:00pm</p></header><div class="content"><p>On Apr 27, 2016, at 2:08 PM, Jérôme ALVES &lt;j.alves at me.com&gt; wrote:<br>&gt; <br>&gt; What if... <br>&gt; <br>&gt; FooBar.framework defines :<br>&gt; public protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt; public type B: A {<br>&gt;     public func foo () { <br>&gt;           … implementation … <br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Other module defines :<br>&gt; import FooBar<br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt; <br></p><p>Under these circumstances because of the mandatory import statement, there is no difference between the extension being defined in or outside the module, so long as the other module access is public. If it is not visible to the conforming protocol, there is no issue.<br></p><p>Conflicts of multiple protocol default implementations would need to be resolved exactly the same way as previously discussed, the only difference being namespacing:<br></p><p>required foo = OtherModule.A.foo<br></p><p>— E<br></p><p>&gt; <br>&gt; Jérôme <br>&gt; <br>&gt; Le 27 avr. 2016 à 19:10, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt; <br>&gt;&gt; protocol A {<br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension A {<br>&gt;&gt;     func foo() { .. default implementation … }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; type B: A {<br>&gt;&gt; <br>&gt;&gt;     override required func foo () { … overrides implementation … }<br>&gt;&gt; }<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/82b50b85/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>April 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Having to specify override to override the implementation of protocol leads one further down the path that the protocol’s implementation is actually being overridden.  However, currently that is not the case.  If the protocol’s definition was actually being overridden, I think you would have a good case.  But swift, as it exists today, will still call the protocol’s default implementation if accessed through the protocol type.  So it isn’t really overriding the implementation of the protocol:<br></p><p>For example:<br></p><p><br>protocol Test {<br></p><p>}<br></p><p><br></p><p>extension Test {<br></p><p>    var hello: String {<br></p><p>        return &quot;hello&quot;<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>class A: Test {<br></p><p>}<br></p><p><br></p><p>class B: Test {<br></p><p><br></p><p>    var hello: String {<br></p><p>        return &quot;see ya&quot;<br></p><p>    }<br></p><p>}<br></p><p><br></p><p>print( A().hello ) // hello<br></p><p>print( B().hello ) // see ya<br></p><p><br>let test1: Test = A()<br></p><p>print( test1.hello )  // hello<br></p><p><br>let test2: Test = B()<br></p><p>print( test2.hello ) // hello  &lt;== not &quot;see ya&quot;<br></p><p><br>Thanks,<br></p><p>Tod Cunningham<br></p><p>From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>Reply-To: Erica Sadun &lt;erica at ericasadun.com&lt;mailto:erica at ericasadun.com&gt;&gt;<br>Date: Wednesday, April 27, 2016 at 1:10 PM<br>To: swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;, Jordan Rose &lt;jordan_rose at apple.com&lt;mailto:jordan_rose at apple.com&gt;&gt;, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt;<br>Subject: [swift-evolution] [Pitch] Requiring proactive overrides for default protocol implementations.<br></p><p>From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br></p><p>I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br></p><p>I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br></p><p>protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { .. default implementation … }<br>}<br></p><p>type B: A {<br></p><p>    override required func foo () { … overrides implementation … }<br>}<br></p><p><br>I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br></p><p>Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both?<br></p><p>type B: A, C {<br>    override required func foo() { A.foo(); C.foo() }<br>}<br></p><p>Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br></p><p>type B: A {<br>    override required func foo() { A.foo(); … my custom behavior … }<br>}<br></p><p>cc’ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br></p><p>— E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>April 27, 2016 at 09:00:00pm</p></header><div class="content"><p>I still think that the type of the reference governs which code runs feels so vestigial of a part of C++ I always disliked (default if you are not using the virtual keyword). Especially dealing with protocols that have generally always be interpreted to be abstract API contracts.<br></p><p>I would say to have dynamic dispatching to be default unless the compiler knows there is no sideffect (no difference if an instance is referred through a certain reference type or another) or the used specified a a keyword in the public protocol interface.<br></p><p>[[iOS messageWithData:ideas] broadcast]<br></p><p>&gt; On 27 Apr 2016, at 21:17, Tod Cunningham via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Having to specify override to override the implementation of protocol leads one further down the path that the protocol’s implementation is actually being overridden.  However, currently that is not the case.  If the protocol’s definition was actually being overridden, I think you would have a good case.  But swift, as it exists today, will still call the protocol’s default implementation if accessed through the protocol type.  So it isn’t really overriding the implementation of the protocol:<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; <br>&gt; protocol Test {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; extension Test {<br>&gt; <br>&gt;    var hello: String {<br>&gt; <br>&gt;        return &quot;hello&quot;<br>&gt; <br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; class A: Test {<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; class B: Test {<br>&gt; <br>&gt; <br>&gt; <br>&gt;    var hello: String {<br>&gt; <br>&gt;        return &quot;see ya&quot;<br>&gt; <br>&gt;    }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; print( A().hello ) // hello<br>&gt; <br>&gt; print( B().hello ) // see ya<br>&gt; <br>&gt; <br>&gt; let test1: Test = A()<br>&gt; <br>&gt; print( test1.hello )  // hello<br>&gt; <br>&gt; <br>&gt; let test2: Test = B()<br>&gt; <br>&gt; print( test2.hello ) // hello  &lt;== not &quot;see ya&quot;<br>&gt; <br>&gt; <br>&gt; Thanks,<br>&gt; <br>&gt; Tod Cunningham<br>&gt; <br>&gt; From: &lt;swift-evolution-bounces at swift.org&lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Reply-To: Erica Sadun &lt;erica at ericasadun.com&lt;mailto:erica at ericasadun.com&gt;&gt;<br>&gt; Date: Wednesday, April 27, 2016 at 1:10 PM<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt;, Jordan Rose &lt;jordan_rose at apple.com&lt;mailto:jordan_rose at apple.com&gt;&gt;, Douglas Gregor &lt;dgregor at apple.com&lt;mailto:dgregor at apple.com&gt;&gt;<br>&gt; Subject: [swift-evolution] [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt; <br>&gt; From the Swift Programming Language: Methods on a subclass that override the superclass’s implementation are marked with override—overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don’t actually override any method in the superclass.<br>&gt; <br>&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that’s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt; <br>&gt; I envision this as using the same `override` keyword that’s used in class based inheritance but extend it to protocol inheritance:<br>&gt; <br>&gt; protocol A {<br>&gt;    func foo()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;    func foo() { .. default implementation … }<br>&gt; }<br>&gt; <br>&gt; type B: A {<br>&gt; <br>&gt;    override required func foo () { … overrides implementation … }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I’d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt; <br>&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both?<br>&gt; <br>&gt; type B: A, C {<br>&gt;    override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt; <br>&gt; Related topic 2: How can a consumer “inherit” the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I’d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt; <br>&gt; type B: A {<br>&gt;    override required func foo() { A.foo(); … my custom behavior … }<br>&gt; }<br>&gt; <br>&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br>&gt; <br>&gt; — E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 28, 2016 at 10:00:00am</p></header><div class="content"><p>I think that you should *always* have to write `override` when implementing<br>a protocol method, you can think of this as override an abstract<br>declaration. In particular I think the following should be enforced:<br></p><p>    protocol A { func a() }<br>    extension A { override func a() { ... } }<br>    struct AnA: A { override func a() { ... } }<br></p><p>    protocol B { func b() }<br>    struct AB: B { override func b() { ... } }<br></p><p>I think this change will work out well since it mimics what happened in<br>Java, originally the Java annotation `@Override` was used much like<br>`override` is currently used in Swift. However it was problematic and was<br>changed so that you always add the annotation, as shown above (in the<br>Swift context). One of the big advantages of this change is that the error<br>messages are much better (this was very noticeable in Java).<br></p><p>This proposal has come up before on swift-evolution, so it obviously has<br>some support.<br></p><p>On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; From the Swift Programming Language: *Methods on a subclass that override<br>&gt; the superclass’s implementation are marked with override—overriding a<br>&gt; method by accident, without override, is detected by the compiler as an<br>&gt; error. The compiler also detects methods with override that don’t actually<br>&gt; override any method in the superclass.*<br>&gt;<br>&gt; I would like to extend this cautious approach to protocols, forcing the<br>&gt; developer to deliberately override an implementation that’s inherited from<br>&gt; a protocol extension. This would prevent accidental overrides and force the<br>&gt; user to proactively choose to implement a version of a protocol member that<br>&gt; already exists in the protocol extension.<br>&gt;<br>&gt; I envision this as using the same `override` keyword that’s used in class<br>&gt; based inheritance but extend it to protocol inheritance:<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt;<br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt;<br>&gt; type B: A {<br>&gt;<br>&gt;     override required func foo () { … overrides implementation … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I’d also like to bring up two related topics, although they probably<br>&gt; should at some point move to their own thread if they have any legs:<br>&gt;<br>&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt; unrelated protocols both require the same member and offer different<br>&gt; default implementations. Can they specify which implementation to accept or<br>&gt; somehow run both?<br>&gt;<br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt;<br>&gt; Related topic 2: How can a consumer “inherit” the behavior of the default<br>&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt; works. I’d like to be able to call A.foo() and then add custom follow-on<br>&gt; behavior rather than entirely replacing the behavior.<br>&gt;<br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt; }<br>&gt;<br>&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has<br>&gt; already expressed some objections so I want him to  have the opportunity to<br>&gt; bring that discussion here.<br>&gt;<br>&gt; — E<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/8124e5b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b74cd4039f0c53145a186868ab569c0?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Josh Parmenter</string> &lt;jparmenter at vectorform.com&gt;<p>April 28, 2016 at 12:00:00am</p></header><div class="content"><p>On Apr 27, 2016, at 17:23, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>I think that you should *always* have to write `override` when implementing a protocol method, you can think of this as override an abstract declaration. In particular I think the following should be enforced:<br></p><p>    protocol A { func a() }<br>    extension A { override func a() { ... } }<br>    struct AnA: A { override func a() { ... } }<br></p><p>    protocol B { func b() }<br>    struct AB: B { override func b() { ... } }<br></p><p><br>I&#39;m rather new to the list - but I would like to say that I agree with this. I think it gives clarity both to code readability, and for learning the language.<br>Best<br>Josh<br></p><p>I think this change will work out well since it mimics what happened in Java, originally the Java annotation `@Override` was used much like `override` is currently used in Swift. However it was problematic and was changed so that you always add the annotation, as shown above (in the Swift context). One of the big advantages of this change is that the error messages are much better (this was very noticeable in Java).<br></p><p>This proposal has come up before on swift-evolution, so it obviously has some support.<br></p><p>On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;From the Swift Programming Language: Methods on a subclass that override the superclass&#39;s implementation are marked with override-overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don&#39;t actually override any method in the superclass.<br></p><p>I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that&#39;s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br></p><p>I envision this as using the same `override` keyword that&#39;s used in class based inheritance but extend it to protocol inheritance:<br></p><p>protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { .. default implementation ... }<br>}<br></p><p>type B: A {<br></p><p>    override required func foo () { ... overrides implementation ... }<br>}<br></p><p><br>I&#39;d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br></p><p>Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both?<br></p><p>type B: A, C {<br>    override required func foo() { A.foo(); C.foo() }<br>}<br></p><p>Related topic 2: How can a consumer &quot;inherit&quot; the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I&#39;d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br></p><p>type B: A {<br>    override required func foo() { A.foo(); ... my custom behavior ... }<br>}<br></p><p>cc&#39;ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br></p><p>- E<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>April 28, 2016 at 01:00:00am</p></header><div class="content"><p>I think it would be odd and confusing to always have to use override when implementing protocol methods (especially protocol methods without default implementations).   To me override is telling me that there is another implementation, and I am for lack of a better word overriding that implementation.   However, for a protocol w/o a default implementation, there is no implementation.  You aren’t overriding anything.  You are just conforming to a signature.  Now protocol’s with default implementations there could be a case made for using override.  Expect Swift current implementation doesn&#39;t really override the default implementation, as shown in my example.  The other issues would be if I am overriding  something, I would expect to be able to execute the default implementation from within my override. <br></p><p>It might be nice to have some syntax that would identify the protocol that is being implemented at the point of the implementation. For example (although I don&#39;t like this syntax):<br>   func (protocolname1, protocolname2) commonmethod() -&gt; Void { .. the implementation.. }<br></p><p>- Tod Cunningham<br>________________________________________<br>From: swift-evolution-bounces at swift.org &lt;swift-evolution-bounces at swift.org&gt; on behalf of Josh Parmenter via swift-evolution &lt;swift-evolution at swift.org&gt;<br>Sent: Wednesday, April 27, 2016 8:27 PM<br>To: Howard Lovatt<br>Cc: swift-evolution<br>Subject: Re: [swift-evolution] [Pitch] Requiring proactive overrides for default protocol implementations.<br></p><p>On Apr 27, 2016, at 17:23, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br></p><p>I think that you should *always* have to write `override` when implementing a protocol method, you can think of this as override an abstract declaration. In particular I think the following should be enforced:<br></p><p>    protocol A { func a() }<br>    extension A { override func a() { ... } }<br>    struct AnA: A { override func a() { ... } }<br></p><p>    protocol B { func b() }<br>    struct AB: B { override func b() { ... } }<br></p><p><br>I&#39;m rather new to the list - but I would like to say that I agree with this. I think it gives clarity both to code readability, and for learning the language.<br>Best<br>Josh<br></p><p>I think this change will work out well since it mimics what happened in Java, originally the Java annotation `@Override` was used much like `override` is currently used in Swift. However it was problematic and was changed so that you always add the annotation, as shown above (in the Swift context). One of the big advantages of this change is that the error messages are much better (this was very noticeable in Java).<br></p><p>This proposal has come up before on swift-evolution, so it obviously has some support.<br></p><p>On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;From the Swift Programming Language: Methods on a subclass that override the superclass&#39;s implementation are marked with override-overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don&#39;t actually override any method in the superclass.<br></p><p>I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that&#39;s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br></p><p>I envision this as using the same `override` keyword that&#39;s used in class based inheritance but extend it to protocol inheritance:<br></p><p>protocol A {<br>    func foo()<br>}<br></p><p>extension A {<br>    func foo() { .. default implementation ... }<br>}<br></p><p>type B: A {<br></p><p>    override required func foo () { ... overrides implementation ... }<br>}<br></p><p><br>I&#39;d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br></p><p>Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both?<br></p><p>type B: A, C {<br>    override required func foo() { A.foo(); C.foo() }<br>}<br></p><p>Related topic 2: How can a consumer &quot;inherit&quot; the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I&#39;d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br></p><p>type B: A {<br>    override required func foo() { A.foo(); ... my custom behavior ... }<br>}<br></p><p>cc&#39;ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br></p><p>- E<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 28, 2016 at 11:00:00am</p></header><div class="content"><p>@Tod,<br></p><p>This was a concern when Java changed the behaviour of `@Override`, but it<br>didn&#39;t pan out. Everyone, even those with reservations, grew to like the<br>new behaviour. I think the much improved error messages from the compiler<br>helped, e.g.:<br></p><p>    protocol ViewObserver {<br>        func append(observer observer: Observer)<br>        func remove(observer observer: Observer)<br>        func removeAll()<br>    }<br>    struct AViewObserver: ViewObserver {<br>        func apend(observer observer: Observer) {<br>            ...<br>        }<br>        func remove(observer observer: Observer) {<br>            ...<br>        }<br>        func removeAll() {<br>            ...<br>        }<br>    }<br></p><p>The only error you get at present with the above is that `AViewObserver`<br>does not conform to `ViewObserver`, it doesn&#39;t tell you why. With the<br>change the compiler would highlight that `apend` doesn&#39;t override `append`<br>:(.<br></p><p><br>  -- Howard.<br></p><p>On 28 April 2016 at 11:17, Tod Cunningham &lt;tcunningham at vectorform.com&gt;<br>wrote:<br></p><p>&gt; I think it would be odd and confusing to always have to use override when<br>&gt; implementing protocol methods (especially protocol methods without default<br>&gt; implementations).   To me override is telling me that there is another<br>&gt; implementation, and I am for lack of a better word overriding that<br>&gt; implementation.   However, for a protocol w/o a default implementation,<br>&gt; there is no implementation.  You aren’t overriding anything.  You are just<br>&gt; conforming to a signature.  Now protocol’s with default implementations<br>&gt; there could be a case made for using override.  Expect Swift current<br>&gt; implementation doesn&#39;t really override the default implementation, as shown<br>&gt; in my example.  The other issues would be if I am overriding  something, I<br>&gt; would expect to be able to execute the default implementation from within<br>&gt; my override.<br>&gt;<br>&gt; It might be nice to have some syntax that would identify the protocol that<br>&gt; is being implemented at the point of the implementation. For example<br>&gt; (although I don&#39;t like this syntax):<br>&gt;    func (protocolname1, protocolname2) commonmethod() -&gt; Void { .. the<br>&gt; implementation.. }<br>&gt;<br>&gt; - Tod Cunningham<br>&gt; ________________________________________<br>&gt; From: swift-evolution-bounces at swift.org &lt;swift-evolution-bounces at swift.org&gt;<br>&gt; on behalf of Josh Parmenter via swift-evolution &lt;swift-evolution at swift.org<br>&gt; &gt;<br>&gt; Sent: Wednesday, April 27, 2016 8:27 PM<br>&gt; To: Howard Lovatt<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Pitch] Requiring proactive overrides for<br>&gt; default protocol implementations.<br>&gt;<br>&gt; On Apr 27, 2016, at 17:23, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt; I think that you should *always* have to write `override` when<br>&gt; implementing a protocol method, you can think of this as override an<br>&gt; abstract declaration. In particular I think the following should be<br>&gt; enforced:<br>&gt;<br>&gt;     protocol A { func a() }<br>&gt;     extension A { override func a() { ... } }<br>&gt;     struct AnA: A { override func a() { ... } }<br>&gt;<br>&gt;     protocol B { func b() }<br>&gt;     struct AB: B { override func b() { ... } }<br>&gt;<br>&gt;<br>&gt; I&#39;m rather new to the list - but I would like to say that I agree with<br>&gt; this. I think it gives clarity both to code readability, and for learning<br>&gt; the language.<br>&gt; Best<br>&gt; Josh<br>&gt;<br>&gt; I think this change will work out well since it mimics what happened in<br>&gt; Java, originally the Java annotation `@Override` was used much like<br>&gt; `override` is currently used in Swift. However it was problematic and was<br>&gt; changed so that you always add the annotation, as shown above (in the Swift<br>&gt; context). One of the big advantages of this change is that the error<br>&gt; messages are much better (this was very noticeable in Java).<br>&gt;<br>&gt; This proposal has come up before on swift-evolution, so it obviously has<br>&gt; some support.<br>&gt;<br>&gt; On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; From the Swift Programming Language: Methods on a subclass that override<br>&gt; the superclass&#39;s implementation are marked with override-overriding a<br>&gt; method by accident, without override, is detected by the compiler as an<br>&gt; error. The compiler also detects methods with override that don&#39;t actually<br>&gt; override any method in the superclass.<br>&gt;<br>&gt; I would like to extend this cautious approach to protocols, forcing the<br>&gt; developer to deliberately override an implementation that&#39;s inherited from<br>&gt; a protocol extension. This would prevent accidental overrides and force the<br>&gt; user to proactively choose to implement a version of a protocol member that<br>&gt; already exists in the protocol extension.<br>&gt;<br>&gt; I envision this as using the same `override` keyword that&#39;s used in class<br>&gt; based inheritance but extend it to protocol inheritance:<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt;<br>&gt; extension A {<br>&gt;     func foo() { .. default implementation ... }<br>&gt; }<br>&gt;<br>&gt; type B: A {<br>&gt;<br>&gt;     override required func foo () { ... overrides implementation ... }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I&#39;d also like to bring up two related topics, although they probably<br>&gt; should at some point move to their own thread if they have any legs:<br>&gt;<br>&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt; unrelated protocols both require the same member and offer different<br>&gt; default implementations. Can they specify which implementation to accept or<br>&gt; somehow run both?<br>&gt;<br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt;<br>&gt; Related topic 2: How can a consumer &quot;inherit&quot; the behavior of the default<br>&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt; works. I&#39;d like to be able to call A.foo() and then add custom follow-on<br>&gt; behavior rather than entirely replacing the behavior.<br>&gt;<br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); ... my custom behavior ... }<br>&gt; }<br>&gt;<br>&gt; cc&#39;ing in Jordan who suggested a new thread on this and Doug, who has<br>&gt; already expressed some objections so I want him to  have the opportunity to<br>&gt; bring that discussion here.<br>&gt;<br>&gt; - E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/849a926a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>April 28, 2016 at 12:00:00am</p></header><div class="content"><p>I would prefer the “override” only apply to methods that already had default protocol implementations, because then it could help avoid the mistake of overriding a default implementation that you didn’t realize was there, thinking that this was a method that you needed to supply.<br></p><p>Charles<br></p><p>&gt; On Apr 27, 2016, at 8:26 PM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; @Tod,<br>&gt; <br>&gt; This was a concern when Java changed the behaviour of `@Override`, but it didn&#39;t pan out. Everyone, even those with reservations, grew to like the new behaviour. I think the much improved error messages from the compiler helped, e.g.:<br>&gt; <br>&gt;     protocol ViewObserver { <br>&gt;         func append(observer observer: Observer) <br>&gt;         func remove(observer observer: Observer)<br>&gt;         func removeAll()<br>&gt;     }<br>&gt;     struct AViewObserver: ViewObserver {<br>&gt;         func apend(observer observer: Observer) {<br>&gt;             ...<br>&gt;         }<br>&gt;         func remove(observer observer: Observer) {<br>&gt;             ...<br>&gt;         }<br>&gt;         func removeAll() {<br>&gt;             ...<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; The only error you get at present with the above is that `AViewObserver` does not conform to `ViewObserver`, it doesn&#39;t tell you why. With the change the compiler would highlight that `apend` doesn&#39;t override `append` :(.<br>&gt; <br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 28 April 2016 at 11:17, Tod Cunningham &lt;tcunningham at vectorform.com &lt;mailto:tcunningham at vectorform.com&gt;&gt; wrote:<br>&gt; I think it would be odd and confusing to always have to use override when implementing protocol methods (especially protocol methods without default implementations).   To me override is telling me that there is another implementation, and I am for lack of a better word overriding that implementation.   However, for a protocol w/o a default implementation, there is no implementation.  You aren’t overriding anything.  You are just conforming to a signature.  Now protocol’s with default implementations there could be a case made for using override.  Expect Swift current implementation doesn&#39;t really override the default implementation, as shown in my example.  The other issues would be if I am overriding  something, I would expect to be able to execute the default implementation from within my override.<br>&gt; <br>&gt; It might be nice to have some syntax that would identify the protocol that is being implemented at the point of the implementation. For example (although I don&#39;t like this syntax):<br>&gt;    func (protocolname1, protocolname2) commonmethod() -&gt; Void { .. the implementation.. }<br>&gt; <br>&gt; - Tod Cunningham<br>&gt; ________________________________________<br>&gt; From: swift-evolution-bounces at swift.org &lt;mailto:swift-evolution-bounces at swift.org&gt; &lt;swift-evolution-bounces at swift.org &lt;mailto:swift-evolution-bounces at swift.org&gt;&gt; on behalf of Josh Parmenter via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; Sent: Wednesday, April 27, 2016 8:27 PM<br>&gt; To: Howard Lovatt<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Pitch] Requiring proactive overrides for default protocol implementations.<br>&gt; <br>&gt; On Apr 27, 2016, at 17:23, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; <br>&gt; I think that you should *always* have to write `override` when implementing a protocol method, you can think of this as override an abstract declaration. In particular I think the following should be enforced:<br>&gt; <br>&gt;     protocol A { func a() }<br>&gt;     extension A { override func a() { ... } }<br>&gt;     struct AnA: A { override func a() { ... } }<br>&gt; <br>&gt;     protocol B { func b() }<br>&gt;     struct AB: B { override func b() { ... } }<br>&gt; <br>&gt; <br>&gt; I&#39;m rather new to the list - but I would like to say that I agree with this. I think it gives clarity both to code readability, and for learning the language.<br>&gt; Best<br>&gt; Josh<br>&gt; <br>&gt; I think this change will work out well since it mimics what happened in Java, originally the Java annotation `@Override` was used much like `override` is currently used in Swift. However it was problematic and was changed so that you always add the annotation, as shown above (in the Swift context). One of the big advantages of this change is that the error messages are much better (this was very noticeable in Java).<br>&gt; <br>&gt; This proposal has come up before on swift-evolution, so it obviously has some support.<br>&gt; <br>&gt; On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt; From the Swift Programming Language: Methods on a subclass that override the superclass&#39;s implementation are marked with override-overriding a method by accident, without override, is detected by the compiler as an error. The compiler also detects methods with override that don&#39;t actually override any method in the superclass.<br>&gt; <br>&gt; I would like to extend this cautious approach to protocols, forcing the developer to deliberately override an implementation that&#39;s inherited from a protocol extension. This would prevent accidental overrides and force the user to proactively choose to implement a version of a protocol member that already exists in the protocol extension.<br>&gt; <br>&gt; I envision this as using the same `override` keyword that&#39;s used in class based inheritance but extend it to protocol inheritance:<br>&gt; <br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt; <br>&gt; extension A {<br>&gt;     func foo() { .. default implementation ... }<br>&gt; }<br>&gt; <br>&gt; type B: A {<br>&gt; <br>&gt;     override required func foo () { ... overrides implementation ... }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I&#39;d also like to bring up two related topics, although they probably should at some point move to their own thread if they have any legs:<br>&gt; <br>&gt; Related topic 1: How should a consumer handle a situation where two unrelated protocols both require the same member and offer different default implementations. Can they specify which implementation to accept or somehow run both?<br>&gt; <br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt; <br>&gt; Related topic 2: How can a consumer &quot;inherit&quot; the behavior of the default implementation (like calling super.foo() in classes) and then extend that behavior further. This is a bit similar to how the initialization chaining works. I&#39;d like to be able to call A.foo() and then add custom follow-on behavior rather than entirely replacing the behavior.<br>&gt; <br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); ... my custom behavior ... }<br>&gt; }<br>&gt; <br>&gt; cc&#39;ing in Jordan who suggested a new thread on this and Doug, who has already expressed some objections so I want him to  have the opportunity to bring that discussion here.<br>&gt; <br>&gt; - E<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/98101214/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>April 28, 2016 at 02:00:00pm</p></header><div class="content"><p>I wrote a proposal few weeks ago about &quot;Complete Composition Model&quot; in<br>Swift, but still not finish (too many details)...<br></p><p>In my proposal, i thought about the problem in this topic. However after<br>thinking more generally, I found it best to solve in other direction:<br></p><p>- Every time one default protocol implementations is provide, the generated<br>Header will include de &quot;default&quot; at beginner.<br>-- No source code change, the change is just for generated header. For<br>Frameworks and libs, will apear em the &quot;final generated header&quot; of course.<br>But for changes in our own module, will apear on xcode generated header,<br>auto complete, detail tab, changes in color code, etc...<br></p><p>The ideia is provide a way to &quot;see&quot; more easily if a method has a default<br>implementation, but does not change de code itself because this<br>implementation can be made any time by someone, without break anything.<br></p><p>- Every time we &quot;re implement&quot; one default protocol implementation for<br>other module with already have this &quot;default&quot; keyword, we need to provide a<br>&quot;implements&quot; (or require) keyword to avoid a compiler warning.<br>-- Do not put a keyword to tell if you are implementing a protocol<br>requirement is not exactly a error, but can be considered if you previously<br>know about default implementation. No keyword is needed if no default<br>implementations is provided, but can be used for clarify the intention.<br></p><p>- For or own module, xcode / auto-complete, detail tab, color code, etc...<br>can tel you about the &quot;has default implementation&quot; without the warning.<br></p><p>At end of the day, there no need to any noise to tell something about<br>default implementation, just a little help.<br></p><p>If we make &quot;everything explicit&quot;, inference type will be abolished.<br>Sometimes we can count on to develop &quot;look the metadatas/interfaces&quot;<br></p><p>If someone wants I can post the proposal I have written tomorrow.<br></p><p>Em qui, 28 de abr de 2016 às 02:08, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; I would prefer the “override” only apply to methods that already had<br>&gt; default protocol implementations, because then it could help avoid the<br>&gt; mistake of overriding a default implementation that you didn’t realize was<br>&gt; there, thinking that this was a method that you needed to supply.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; On Apr 27, 2016, at 8:26 PM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; @Tod,<br>&gt;<br>&gt; This was a concern when Java changed the behaviour of `@Override`, but it<br>&gt; didn&#39;t pan out. Everyone, even those with reservations, grew to like the<br>&gt; new behaviour. I think the much improved error messages from the compiler<br>&gt; helped, e.g.:<br>&gt;<br>&gt;     protocol ViewObserver {<br>&gt;         func append(observer observer: Observer)<br>&gt;         func remove(observer observer: Observer)<br>&gt;         func removeAll()<br>&gt;     }<br>&gt;     struct AViewObserver: ViewObserver {<br>&gt;         func apend(observer observer: Observer) {<br>&gt;             ...<br>&gt;         }<br>&gt;         func remove(observer observer: Observer) {<br>&gt;             ...<br>&gt;         }<br>&gt;         func removeAll() {<br>&gt;             ...<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; The only error you get at present with the above is that `AViewObserver`<br>&gt; does not conform to `ViewObserver`, it doesn&#39;t tell you why. With the<br>&gt; change the compiler would highlight that `apend` doesn&#39;t override `append`<br>&gt; :(.<br>&gt;<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 28 April 2016 at 11:17, Tod Cunningham &lt;tcunningham at vectorform.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I think it would be odd and confusing to always have to use override when<br>&gt;&gt; implementing protocol methods (especially protocol methods without default<br>&gt;&gt; implementations).   To me override is telling me that there is another<br>&gt;&gt; implementation, and I am for lack of a better word overriding that<br>&gt;&gt; implementation.   However, for a protocol w/o a default implementation,<br>&gt;&gt; there is no implementation.  You aren’t overriding anything.  You are just<br>&gt;&gt; conforming to a signature.  Now protocol’s with default implementations<br>&gt;&gt; there could be a case made for using override.  Expect Swift current<br>&gt;&gt; implementation doesn&#39;t really override the default implementation, as shown<br>&gt;&gt; in my example.  The other issues would be if I am overriding  something, I<br>&gt;&gt; would expect to be able to execute the default implementation from within<br>&gt;&gt; my override.<br>&gt;&gt;<br>&gt;&gt; It might be nice to have some syntax that would identify the protocol<br>&gt;&gt; that is being implemented at the point of the implementation. For example<br>&gt;&gt; (although I don&#39;t like this syntax):<br>&gt;&gt;    func (protocolname1, protocolname2) commonmethod() -&gt; Void { .. the<br>&gt;&gt; implementation.. }<br>&gt;&gt;<br>&gt;&gt; - Tod Cunningham<br>&gt;&gt; ________________________________________<br>&gt;&gt; From: swift-evolution-bounces at swift.org &lt;<br>&gt;&gt; swift-evolution-bounces at swift.org&gt; on behalf of Josh Parmenter via<br>&gt;&gt; swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: Wednesday, April 27, 2016 8:27 PM<br>&gt;&gt; To: Howard Lovatt<br>&gt;&gt; Cc: swift-evolution<br>&gt;&gt; Subject: Re: [swift-evolution] [Pitch] Requiring proactive overrides for<br>&gt;&gt; default protocol implementations.<br>&gt;&gt;<br>&gt;&gt; On Apr 27, 2016, at 17:23, Howard Lovatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I think that you should *always* have to write `override` when<br>&gt;&gt; implementing a protocol method, you can think of this as override an<br>&gt;&gt; abstract declaration. In particular I think the following should be<br>&gt;&gt; enforced:<br>&gt;&gt;<br>&gt;&gt;     protocol A { func a() }<br>&gt;&gt;     extension A { override func a() { ... } }<br>&gt;&gt;     struct AnA: A { override func a() { ... } }<br>&gt;&gt;<br>&gt;&gt;     protocol B { func b() }<br>&gt;&gt;     struct AB: B { override func b() { ... } }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m rather new to the list - but I would like to say that I agree with<br>&gt;&gt; this. I think it gives clarity both to code readability, and for learning<br>&gt;&gt; the language.<br>&gt;&gt; Best<br>&gt;&gt; Josh<br>&gt;&gt;<br>&gt;&gt; I think this change will work out well since it mimics what happened in<br>&gt;&gt; Java, originally the Java annotation `@Override` was used much like<br>&gt;&gt; `override` is currently used in Swift. However it was problematic and was<br>&gt;&gt; changed so that you always add the annotation, as shown above (in the Swift<br>&gt;&gt; context). One of the big advantages of this change is that the error<br>&gt;&gt; messages are much better (this was very noticeable in Java).<br>&gt;&gt;<br>&gt;&gt; This proposal has come up before on swift-evolution, so it obviously has<br>&gt;&gt; some support.<br>&gt;&gt;<br>&gt;&gt; On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; From the Swift Programming Language: Methods on a subclass that override<br>&gt;&gt; the superclass&#39;s implementation are marked with override-overriding a<br>&gt;&gt; method by accident, without override, is detected by the compiler as an<br>&gt;&gt; error. The compiler also detects methods with override that don&#39;t actually<br>&gt;&gt; override any method in the superclass.<br>&gt;&gt;<br>&gt;&gt; I would like to extend this cautious approach to protocols, forcing the<br>&gt;&gt; developer to deliberately override an implementation that&#39;s inherited from<br>&gt;&gt; a protocol extension. This would prevent accidental overrides and force the<br>&gt;&gt; user to proactively choose to implement a version of a protocol member that<br>&gt;&gt; already exists in the protocol extension.<br>&gt;&gt;<br>&gt;&gt; I envision this as using the same `override` keyword that&#39;s used in class<br>&gt;&gt; based inheritance but extend it to protocol inheritance:<br>&gt;&gt;<br>&gt;&gt; protocol A {<br>&gt;&gt;     func foo()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension A {<br>&gt;&gt;     func foo() { .. default implementation ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; type B: A {<br>&gt;&gt;<br>&gt;&gt;     override required func foo () { ... overrides implementation ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;d also like to bring up two related topics, although they probably<br>&gt;&gt; should at some point move to their own thread if they have any legs:<br>&gt;&gt;<br>&gt;&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt;&gt; unrelated protocols both require the same member and offer different<br>&gt;&gt; default implementations. Can they specify which implementation to accept or<br>&gt;&gt; somehow run both?<br>&gt;&gt;<br>&gt;&gt; type B: A, C {<br>&gt;&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Related topic 2: How can a consumer &quot;inherit&quot; the behavior of the default<br>&gt;&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt;&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt;&gt; works. I&#39;d like to be able to call A.foo() and then add custom follow-on<br>&gt;&gt; behavior rather than entirely replacing the behavior.<br>&gt;&gt;<br>&gt;&gt; type B: A {<br>&gt;&gt;     override required func foo() { A.foo(); ... my custom behavior ... }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; cc&#39;ing in Jordan who suggested a new thread on this and Doug, who has<br>&gt;&gt; already expressed some objections so I want him to  have the opportunity to<br>&gt;&gt; bring that discussion here.<br>&gt;&gt;<br>&gt;&gt; - E<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org&lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160428/f8ce871a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Pitch] Requiring proactive overrides for default protocol implementations.</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>+1<br></p><p>Main part of proposal: Not sure that you need the required keyword,<br>overload alone has proven sufficient in Java for the same feature.<br></p><p>Related features: For calling default implementations in inherited<br>protocols I think this is a valuable feature but should be a seperate<br>thread.<br></p><p>On Thursday, 28 April 2016, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; From the Swift Programming Language: *Methods on a subclass that override<br>&gt; the superclass’s implementation are marked with override—overriding a<br>&gt; method by accident, without override, is detected by the compiler as an<br>&gt; error. The compiler also detects methods with override that don’t actually<br>&gt; override any method in the superclass.*<br>&gt;<br>&gt; I would like to extend this cautious approach to protocols, forcing the<br>&gt; developer to deliberately override an implementation that’s inherited from<br>&gt; a protocol extension. This would prevent accidental overrides and force the<br>&gt; user to proactively choose to implement a version of a protocol member that<br>&gt; already exists in the protocol extension.<br>&gt;<br>&gt; I envision this as using the same `override` keyword that’s used in class<br>&gt; based inheritance but extend it to protocol inheritance:<br>&gt;<br>&gt; protocol A {<br>&gt;     func foo()<br>&gt; }<br>&gt;<br>&gt; extension A {<br>&gt;     func foo() { .. default implementation … }<br>&gt; }<br>&gt;<br>&gt; type B: A {<br>&gt;<br>&gt;     override required func foo () { … overrides implementation … }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I’d also like to bring up two related topics, although they probably<br>&gt; should at some point move to their own thread if they have any legs:<br>&gt;<br>&gt; Related topic 1: How should a consumer handle a situation where two<br>&gt; unrelated protocols both require the same member and offer different<br>&gt; default implementations. Can they specify which implementation to accept or<br>&gt; somehow run both?<br>&gt;<br>&gt; type B: A, C {<br>&gt;     override required func foo() { A.foo(); C.foo() }<br>&gt; }<br>&gt;<br>&gt; Related topic 2: How can a consumer “inherit” the behavior of the default<br>&gt; implementation (like calling super.foo() in classes) and then extend that<br>&gt; behavior further. This is a bit similar to how the initialization chaining<br>&gt; works. I’d like to be able to call A.foo() and then add custom follow-on<br>&gt; behavior rather than entirely replacing the behavior.<br>&gt;<br>&gt; type B: A {<br>&gt;     override required func foo() { A.foo(); … my custom behavior … }<br>&gt; }<br>&gt;<br>&gt; cc’ing in Jordan who suggested a new thread on this and Doug, who has<br>&gt; already expressed some objections so I want him to  have the opportunity to<br>&gt; bring that discussion here.<br>&gt;<br>&gt; — E<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/4b62bb47/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
