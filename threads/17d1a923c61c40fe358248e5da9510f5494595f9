<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  5, 2016 at 11:00:00am</p></header><div class="content"><p>Dipping my toes in the water, so to speak, with a suggestion that came to<br>mind. Not an expert by any means, so hopefully this isn&#39;t too laughably off<br>the mark. As background, I work in the biomedical sciences; with few<br>exceptions, those of us who write code are non-experts who learn as we go<br>along. What&#39;s been attractive about Swift is that it&#39;s been designed with<br>approachability in mind for beginning coders and those with a rudimentary<br>understanding of languages in the C family. Difficulty in syntax and<br>sophistication of the computer science concepts exposed are hurdles that<br>can be overcome, but what keeps me up at night are potentially subtle<br>things maybe easy for the expert that I or my colleagues just might not<br>know about, which then lead to code that appears correct at first glance,<br>compiles, but executes in subtly unintended ways. Those things in my field<br>are what could lead to retracted papers, ruined careers, etc....<br></p><p>This is something along those lines; also somewhat of a reprise of a theme<br>that&#39;s been raised tangentially in a few threads within the past month<br>(e.g.:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001125.html),<br>but I think the particular solution I&#39;m envisioning hasn&#39;t been put forward.<br></p><p>The issue at hand:<br></p><p>Consider the following (contrived) example (call it version 1)--<br></p><p>class Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;generic sound&quot;<br>    }<br>}<br></p><p>class Cow: Animal {<br>    override func makeNoise() -&gt; String {<br>        return &quot;moo&quot;<br>    }<br>}<br></p><p>class Sheep: Animal {<br>    override func makeNoise() -&gt; String {<br>        return &quot;bah&quot;<br>    }<br>}<br></p><p>let cow = Cow()<br>cow.makeNoise() // &quot;moo&quot;<br>(cow as Animal).makeNoise() // &quot;moo&quot;<br></p><p>let farm: [Animal] = [Cow(), Cow(), Sheep()]<br>let noises: [String] = farm.map { $0.makeNoise() }<br>// [&quot;moo&quot;, &quot;moo&quot;, &quot;bah&quot;]<br></p><p>Now refactor to use a protocol. I&#39;ll give two versions, differing by a<br>single line.<br></p><p>Version 2A--<br></p><p>protocol Animal { }<br></p><p>extension Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;generic sound&quot;<br>    }<br>}<br></p><p>class Cow: Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;moo&quot;<br>    }<br>}<br></p><p>class Sheep: Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;bah&quot;<br>    }<br>}<br></p><p>let cow = Cow()<br>cow.makeNoise() // &quot;moo&quot;<br>(cow as Animal).makeNoise() // &quot;generic sound&quot;<br></p><p>let farm: [Animal] = [Cow(), Cow(), Sheep()]<br>let noises: [String] = farm.map { $0.makeNoise() }<br>// [&quot;generic sound&quot;, &quot;generic sound&quot;, &quot;generic sound&quot;]<br></p><p>Version 2B--<br></p><p>protocol Animal {<br>    func makeNoise() -&gt; String<br>}<br></p><p>extension Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;generic sound&quot;<br>    }<br>}<br></p><p>class Cow: Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;moo&quot;<br>    }<br>}<br></p><p>class Sheep: Animal {<br>    func makeNoise() -&gt; String {<br>        return &quot;bah&quot;<br>    }<br>}<br></p><p>let cow = Cow()<br>cow.makeNoise() // &quot;moo&quot;<br>(cow as Animal).makeNoise() // &quot;moo&quot;<br></p><p>let farm: [Animal] = [Cow(), Cow(), Sheep()]<br>let noises: [String] = farm.map { $0.makeNoise() }<br>// [&quot;moo&quot;, &quot;moo&quot;, &quot;bah&quot;]<br></p><p>To be sure, this difference in behavior can be justified in a variety of<br>ways, but it is nonetheless a surprising result at first glance. Most<br>concerning is that it is possible to imagine a scenario in which the<br>protocol in question is one provided in a third-party library, or even the<br>Swift standard library, while I&#39;m writing a struct or class that implements<br>that protocol.<br></p><p>Suppose that between versions of a third-party library the Animal protocol<br>changes from version 2A to version 2B. My struct or class that implements<br>the protocol would compile without changes, and cow.makeNoise() would even<br>give the same result, yet there would be differences in how my code works<br>that would be difficult to track down. An expert would be able to spot the<br>difference on examination of the protocol declaration, but one would have<br>to be knowledgeable already about this particular issue to know what to<br>look for. This seems like a gotcha that can be avoided.<br></p><p>Proposed solution:<br></p><p>I think others have tried to approach this from a different angle (see, for<br>example:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001933.html).<br>My view is that there are two points potentially to address.<br></p><p>(1) func makeNoise() -&gt; String { ... } within the protocol extension<br>indicates two different things in versions 2A and 2B (since one is<br>dynamically dispatched and the other is not), yet the syntax is<br>indistinguishable.<br></p><p>(2) Within a class or struct implementing a protocol, a method with the<br>same name as that of a method in a protocol extension (potentially in<br>another file, maybe not written by the same person) behaves differently<br>depending on whether that method name is declared in the protocol itself<br>(potentially in a third file, written by a third person), yet the syntax is<br>indistinguishable within the implementing class or struct. If the protocol<br>changes, whether a method is dynamically dispatched or statically<br>dispatched could change too, yet code in a class or struct implementing<br>that protocol that now behaves differently compiles all the same;<br>implementors are not clued into the change and may not even be aware that<br>changes such as this could happen.<br></p><p>What I&#39;m thinking is a light-touch fix that would address (2), which would<br>largely mitigate the consequences of (1). Taking inspiration from syntax<br>used for methods in classes that override methods in superclasses, require<br>methods that override dynamically dispatched default implementations in<br>protocol extensions to use the override keyword. Likewise, forbid the<br>override keyword if the method being implemented instead &#39;masks&#39; (would<br>that be the right word?) a statically dispatched method in a protocol<br>extension which can nonetheless be invoked by upcasting to the protocol.<br></p><p>In other words, I propose that in the contrived example above, version 2B<br>(which behaves just like version 1) requires syntax just like that of<br>version 1 (in class Cow and class Sheep, override func makeNoise() -&gt;<br>String { ... }). Meanwhile, version 2A, which doesn&#39;t quite behave like<br>version 1, forbids the same syntax. That way, anyone confused about what he<br>or she is getting into when implementing the protocol is notified at<br>compile time, and code that compiles in one scenario will not compile if<br>the underlying protocol declaration changes.<br></p><p>I suppose quite a good counterargument would be that protocols exist to be<br>implemented, and implementations of methods required for conformance to a<br>protocol shouldn&#39;t need another keyword. I would be inclined to agree, but<br>in this case I&#39;d point out that what would trigger the requirement for use<br>of the override keyword is the presence of a default implementation being<br>overridden, not the mere fact that a method declared within a protocol is<br>being implemented.<br></p><p>Would this be something that is desirable to other users of the language?<br>Easy to implement?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/17d195f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  6, 2016 at 01:00:00pm</p></header><div class="content"><p>Personally I would like the following rules:<br></p><p>1. If a method implements or overrides any method in a class, struct, or<br>extension, whether declared in a protocol or class, then it must be tagged<br>with override.<br>2. If a method is implemented in an extension and not declared previously<br>in a protocol then in should be tagged final (this is another<br>swift-evolution proposal already)<br></p><p>If both were adopted then it would be clear what was happening.<br></p><p>At present the compiler also struggles, if you make a minor error when<br>overriding a protocol method all the compiler can do is tell you that the<br>struct/class does not conform. It doesn&#39;t tell you where the error is,<br>which might be in an extension in a different file. If the methods were<br>tagged with override the compiler would give a better error message and<br>importantly direct you to the problem.<br></p><p>On Wednesday, 6 January 2016, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org<br>&lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br></p><p>&gt; Dipping my toes in the water, so to speak, with a suggestion that came to<br>&gt; mind. Not an expert by any means, so hopefully this isn&#39;t too laughably off<br>&gt; the mark. As background, I work in the biomedical sciences; with few<br>&gt; exceptions, those of us who write code are non-experts who learn as we go<br>&gt; along. What&#39;s been attractive about Swift is that it&#39;s been designed with<br>&gt; approachability in mind for beginning coders and those with a rudimentary<br>&gt; understanding of languages in the C family. Difficulty in syntax and<br>&gt; sophistication of the computer science concepts exposed are hurdles that<br>&gt; can be overcome, but what keeps me up at night are potentially subtle<br>&gt; things maybe easy for the expert that I or my colleagues just might not<br>&gt; know about, which then lead to code that appears correct at first glance,<br>&gt; compiles, but executes in subtly unintended ways. Those things in my field<br>&gt; are what could lead to retracted papers, ruined careers, etc....<br>&gt;<br>&gt; This is something along those lines; also somewhat of a reprise of a theme<br>&gt; that&#39;s been raised tangentially in a few threads within the past month<br>&gt; (e.g.:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001125.html),<br>&gt; but I think the particular solution I&#39;m envisioning hasn&#39;t been put forward.<br>&gt;<br>&gt; The issue at hand:<br>&gt;<br>&gt; Consider the following (contrived) example (call it version 1)--<br>&gt;<br>&gt; class Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;generic sound&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Cow: Animal {<br>&gt;     override func makeNoise() -&gt; String {<br>&gt;         return &quot;moo&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Sheep: Animal {<br>&gt;     override func makeNoise() -&gt; String {<br>&gt;         return &quot;bah&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let cow = Cow()<br>&gt; cow.makeNoise() // &quot;moo&quot;<br>&gt; (cow as Animal).makeNoise() // &quot;moo&quot;<br>&gt;<br>&gt; let farm: [Animal] = [Cow(), Cow(), Sheep()]<br>&gt; let noises: [String] = farm.map { $0.makeNoise() }<br>&gt; // [&quot;moo&quot;, &quot;moo&quot;, &quot;bah&quot;]<br>&gt;<br>&gt; Now refactor to use a protocol. I&#39;ll give two versions, differing by a<br>&gt; single line.<br>&gt;<br>&gt; Version 2A--<br>&gt;<br>&gt; protocol Animal { }<br>&gt;<br>&gt; extension Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;generic sound&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Cow: Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;moo&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Sheep: Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;bah&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let cow = Cow()<br>&gt; cow.makeNoise() // &quot;moo&quot;<br>&gt; (cow as Animal).makeNoise() // &quot;generic sound&quot;<br>&gt;<br>&gt; let farm: [Animal] = [Cow(), Cow(), Sheep()]<br>&gt; let noises: [String] = farm.map { $0.makeNoise() }<br>&gt; // [&quot;generic sound&quot;, &quot;generic sound&quot;, &quot;generic sound&quot;]<br>&gt;<br>&gt; Version 2B--<br>&gt;<br>&gt; protocol Animal {<br>&gt;     func makeNoise() -&gt; String<br>&gt; }<br>&gt;<br>&gt; extension Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;generic sound&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Cow: Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;moo&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; class Sheep: Animal {<br>&gt;     func makeNoise() -&gt; String {<br>&gt;         return &quot;bah&quot;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; let cow = Cow()<br>&gt; cow.makeNoise() // &quot;moo&quot;<br>&gt; (cow as Animal).makeNoise() // &quot;moo&quot;<br>&gt;<br>&gt; let farm: [Animal] = [Cow(), Cow(), Sheep()]<br>&gt; let noises: [String] = farm.map { $0.makeNoise() }<br>&gt; // [&quot;moo&quot;, &quot;moo&quot;, &quot;bah&quot;]<br>&gt;<br>&gt; To be sure, this difference in behavior can be justified in a variety of<br>&gt; ways, but it is nonetheless a surprising result at first glance. Most<br>&gt; concerning is that it is possible to imagine a scenario in which the<br>&gt; protocol in question is one provided in a third-party library, or even the<br>&gt; Swift standard library, while I&#39;m writing a struct or class that implements<br>&gt; that protocol.<br>&gt;<br>&gt; Suppose that between versions of a third-party library the Animal protocol<br>&gt; changes from version 2A to version 2B. My struct or class that implements<br>&gt; the protocol would compile without changes, and cow.makeNoise() would even<br>&gt; give the same result, yet there would be differences in how my code works<br>&gt; that would be difficult to track down. An expert would be able to spot the<br>&gt; difference on examination of the protocol declaration, but one would have<br>&gt; to be knowledgeable already about this particular issue to know what to<br>&gt; look for. This seems like a gotcha that can be avoided.<br>&gt;<br>&gt; Proposed solution:<br>&gt;<br>&gt; I think others have tried to approach this from a different angle (see,<br>&gt; for example:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001933.html).<br>&gt; My view is that there are two points potentially to address.<br>&gt;<br>&gt; (1) func makeNoise() -&gt; String { ... } within the protocol extension<br>&gt; indicates two different things in versions 2A and 2B (since one is<br>&gt; dynamically dispatched and the other is not), yet the syntax is<br>&gt; indistinguishable.<br>&gt;<br>&gt; (2) Within a class or struct implementing a protocol, a method with the<br>&gt; same name as that of a method in a protocol extension (potentially in<br>&gt; another file, maybe not written by the same person) behaves differently<br>&gt; depending on whether that method name is declared in the protocol itself<br>&gt; (potentially in a third file, written by a third person), yet the syntax is<br>&gt; indistinguishable within the implementing class or struct. If the protocol<br>&gt; changes, whether a method is dynamically dispatched or statically<br>&gt; dispatched could change too, yet code in a class or struct implementing<br>&gt; that protocol that now behaves differently compiles all the same;<br>&gt; implementors are not clued into the change and may not even be aware that<br>&gt; changes such as this could happen.<br>&gt;<br>&gt; What I&#39;m thinking is a light-touch fix that would address (2), which would<br>&gt; largely mitigate the consequences of (1). Taking inspiration from syntax<br>&gt; used for methods in classes that override methods in superclasses, require<br>&gt; methods that override dynamically dispatched default implementations in<br>&gt; protocol extensions to use the override keyword. Likewise, forbid the<br>&gt; override keyword if the method being implemented instead &#39;masks&#39; (would<br>&gt; that be the right word?) a statically dispatched method in a protocol<br>&gt; extension which can nonetheless be invoked by upcasting to the protocol.<br>&gt;<br>&gt; In other words, I propose that in the contrived example above, version 2B<br>&gt; (which behaves just like version 1) requires syntax just like that of<br>&gt; version 1 (in class Cow and class Sheep, override func makeNoise() -&gt;<br>&gt; String { ... }). Meanwhile, version 2A, which doesn&#39;t quite behave like<br>&gt; version 1, forbids the same syntax. That way, anyone confused about what he<br>&gt; or she is getting into when implementing the protocol is notified at<br>&gt; compile time, and code that compiles in one scenario will not compile if<br>&gt; the underlying protocol declaration changes.<br>&gt;<br>&gt; I suppose quite a good counterargument would be that protocols exist to be<br>&gt; implemented, and implementations of methods required for conformance to a<br>&gt; protocol shouldn&#39;t need another keyword. I would be inclined to agree, but<br>&gt; in this case I&#39;d point out that what would trigger the requirement for use<br>&gt; of the override keyword is the presence of a default implementation being<br>&gt; overridden, not the mere fact that a method declared within a protocol is<br>&gt; being implemented.<br>&gt;<br>&gt; Would this be something that is desirable to other users of the language?<br>&gt; Easy to implement?<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/7b350fe2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  5, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Taking inspiration from syntax used for methods in classes that override methods in superclasses, require methods that override dynamically dispatched default implementations in protocol extensions to use the override keyword. Likewise, forbid the override keyword if the method being implemented instead &#39;masks&#39; (would that be the right word?) a statically dispatched method in a protocol extension which can nonetheless be invoked by upcasting to the protocol.<br></p><p>This has been suggested before, usually in the form of a separate `implement` keyword. The main problem is that it makes it impossible to write a protocol after the fact which formalizes some existing pattern in the types.<br></p><p>What do I mean by that? Well, imagine you need generic access to the `min` and `max` static properties of the various integer types. There&#39;s no existing protocol that includes those members. But you can write one and then extend the integer types to conform to your new protocol:<br></p><p>	protocol BoundedIntegerType: IntegerType {<br>		static var min: Self { get }<br>		static var max: Self { get }<br>	}<br>	extension Int: BoundedType {}<br>	extension Int8: BoundedType {}<br>	extension Int16: BoundedType {}<br>	extension Int32: BoundedType {}<br>	extension Int64: BoundedType {}<br></p><p>	func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x: Integer) {<br>		print(Integer.min)<br>	}<br></p><p>This only works because `min` and `max` *don&#39;t* need any special marking to be used to satisfy a requirement. Requiring a keyword like you suggest would remove that feature.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  5, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; This has been suggested before, usually in the form of a separate<br>`implement` keyword. The main problem is that it makes it impossible to<br>write a protocol after the fact which formalizes some existing pattern in<br>the types.<br></p><p>I think this is a great point and would be a con that I hadn&#39;t considered<br>in terms of Howard&#39;s suggestion that everything implementing a protocol<br>should have use a keyword (such as &quot;override&quot; or &quot;implement&quot;).<br></p><p>I fear that I&#39;ve explained my idea a little poorly. My thought was that<br>*only methods overriding something*--namely, a default implementation given<br>in a protocol extension--should be required to use the override keyword<br>when the method is dynamically dispatched.<br></p><p>It would remain very much possible to formalize an existing pattern<br>because, in the case of your example (unless I&#39;m misunderstanding?), you<br>are not also providing a default implementation of the &quot;min&quot; and &quot;max&quot;<br>getters, and the IntXX structs would have nothing to override. Indeed,<br>you&#39;d hardly be formalizing an existing pattern if you had to supply de<br>novo implementations! It&#39;s true that it&#39;s possible to do something in<br>today&#39;s Swift syntax that wouldn&#39;t be possible in my proposal. Namely, in<br>today&#39;s Swift syntax, it&#39;s possible to give a dynamically dispatched<br>default implementation of the min and max getters in an after-the-fact<br>formalization, but I have trouble seeing any circumstance in which that<br>would be necessary--unless I misunderstand, such a default implementation<br>can never be invoked?<br></p><p><br>On Tue, Jan 5, 2016 at 10:50 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Taking inspiration from syntax used for methods in classes that override<br>&gt; methods in superclasses, require methods that override dynamically<br>&gt; dispatched default implementations in protocol extensions to use the<br>&gt; override keyword. Likewise, forbid the override keyword if the method being<br>&gt; implemented instead &#39;masks&#39; (would that be the right word?) a statically<br>&gt; dispatched method in a protocol extension which can nonetheless be invoked<br>&gt; by upcasting to the protocol.<br>&gt;<br>&gt; This has been suggested before, usually in the form of a separate<br>&gt; `implement` keyword. The main problem is that it makes it impossible to<br>&gt; write a protocol after the fact which formalizes some existing pattern in<br>&gt; the types.<br>&gt;<br>&gt; What do I mean by that? Well, imagine you need generic access to the `min`<br>&gt; and `max` static properties of the various integer types. There&#39;s no<br>&gt; existing protocol that includes those members. But you can write one and<br>&gt; then extend the integer types to conform to your new protocol:<br>&gt;<br>&gt;         protocol BoundedIntegerType: IntegerType {<br>&gt;                 static var min: Self { get }<br>&gt;                 static var max: Self { get }<br>&gt;         }<br>&gt;         extension Int: BoundedType {}<br>&gt;         extension Int8: BoundedType {}<br>&gt;         extension Int16: BoundedType {}<br>&gt;         extension Int32: BoundedType {}<br>&gt;         extension Int64: BoundedType {}<br>&gt;<br>&gt;         func printLowestPossibleValueOfValue&lt;Integer:<br>&gt; BoundedIntegerType&gt;(x: Integer) {<br>&gt;                 print(Integer.min)<br>&gt;         }<br>&gt;<br>&gt; This only works because `min` and `max` *don&#39;t* need any special marking<br>&gt; to be used to satisfy a requirement. Requiring a keyword like you suggest<br>&gt; would remove that feature.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160105/f34f9e27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  6, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 06.01.2016 um 06:23 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; It would remain very much possible to formalize an existing pattern because, in the case of your example (unless I&#39;m misunderstanding?), you are not also providing a default implementation of the &quot;min&quot; and &quot;max&quot; getters, and the IntXX structs would have nothing to override. Indeed, you&#39;d hardly be formalizing an existing pattern if you had to supply de novo implementations!<br></p><p>The pattern might exist for some existing classes or structs but it might still be useful for new classes or even for some existing ones to provide a default implementation.<br></p><p>-Thorsten<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  6, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; The pattern might exist for some existing classes or structs but it might still be useful for new classes or even for some existing ones to provide a default implementation.<br></p><p>I agree. It could be very useful in certain circumstances, and I agree<br>that any proposal that made this no longer possible would be a<br>non-starter. I had to think about this point for a bit; I hope I can<br>convince you that it would remain possible if overriding methods had<br>to use a keyword. The way it would be done would be valid code today,<br>and I think after some reflection that it&#39;s a superior way of doing<br>things even in today&#39;s Swift syntax because it&#39;s more explicit about<br>what&#39;s going on.<br></p><p>Example:<br>Given three existing struct types--<br></p><p>struct Foo {<br>    func boo() { print(&quot;foo boo&quot;) }<br>}<br>struct Bar { }<br>struct Baz { }<br></p><p>We wish to formalize after the fact, giving each type a method boo()<br>with a default implementation. Currently, this is valid Swift code--<br></p><p>protocol BooType {<br>    func boo()<br>}<br>extension BooType {<br>    func boo() { print(&quot;default boo&quot;) }<br>}<br>extension Foo: BooType { }<br>extension Bar: BooType { }<br>extension Baz: BooType { }<br></p><p>As you point out rightly, this would be invalid if we had to write<br>&quot;override func boo()&quot; in the body of struct Foo. However, this is<br>valid Swift code both in today&#39;s syntax and if my proposal were to be<br>implemented, and it is only one line longer--<br></p><p>protocol BooType {<br>    func boo()<br>}<br>protocol DefaultBooType: BooType { }<br>extension DefaultBooType {<br>    func boo() { print(&quot;default boo&quot;) }<br>}<br>extension Foo: BooType { }<br>extension Bar: DefaultBooType { }<br>extension Baz: DefaultBooType { }<br></p><p>I&#39;d like to promote the second option as being superior even in<br>today&#39;s syntax. It is immediately clear to the reader that Foo().boo()<br>invokes a different method than Bar().boo(), even if the reader does<br>not have access to the original code for structs Foo, Bar, and Baz.<br>Suppose those structs were supplied in a third-party library that&#39;s<br>not well documented. It&#39;s plausible that a non-expert coder could try<br>to formalize after the fact and write an extension BooType<br>implementing boo() unaware that there is an overriding method in Foo.<br>In today&#39;s Swift syntax, the code would compile and behave subtly<br>differently from the author&#39;s expectations; as proposed, that code<br>would lead to a compile-time error. However, an expert coder who<br>intended to supply a default function but invoke any overriding<br>methods could write code that is almost as succinct but also<br>self-documenting, and in fact could do so today.<br></p><p><br>On Wed, Jan 6, 2016 at 12:45 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; &gt; Am 06.01.2016 um 06:23 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; &gt;<br>&gt; &gt; It would remain very much possible to formalize an existing pattern because, in the case of your example (unless I&#39;m misunderstanding?), you are not also providing a default implementation of the &quot;min&quot; and &quot;max&quot; getters, and the IntXX structs would have nothing to override. Indeed, you&#39;d hardly be formalizing an existing pattern if you had to supply de novo implementations!<br>&gt;<br>&gt; The pattern might exist for some existing classes or structs but it might still be useful for new classes or even for some existing ones to provide a default implementation.<br>&gt;<br>&gt; -Thorsten<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  6, 2016 at 07:00:00am</p></header><div class="content"><p>That is a very important point! Making classes or structs conform to a new protocol by an empty extension is a really important use case.<br></p><p>-Thorsten <br></p><p>Am 06.01.2016 um 05:50 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; Taking inspiration from syntax used for methods in classes that override methods in superclasses, require methods that override dynamically dispatched default implementations in protocol extensions to use the override keyword. Likewise, forbid the override keyword if the method being implemented instead &#39;masks&#39; (would that be the right word?) a statically dispatched method in a protocol extension which can nonetheless be invoked by upcasting to the protocol.<br>&gt; <br>&gt; This has been suggested before, usually in the form of a separate `implement` keyword. The main problem is that it makes it impossible to write a protocol after the fact which formalizes some existing pattern in the types.<br>&gt; <br>&gt; What do I mean by that? Well, imagine you need generic access to the `min` and `max` static properties of the various integer types. There&#39;s no existing protocol that includes those members. But you can write one and then extend the integer types to conform to your new protocol:<br>&gt; <br>&gt;    protocol BoundedIntegerType: IntegerType {<br>&gt;        static var min: Self { get }<br>&gt;        static var max: Self { get }<br>&gt;    }<br>&gt;    extension Int: BoundedType {}<br>&gt;    extension Int8: BoundedType {}<br>&gt;    extension Int16: BoundedType {}<br>&gt;    extension Int32: BoundedType {}<br>&gt;    extension Int64: BoundedType {}<br>&gt; <br>&gt;    func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x: Integer) {<br>&gt;        print(Integer.min)<br>&gt;    }<br>&gt; <br>&gt; This only works because `min` and `max` *don&#39;t* need any special marking to be used to satisfy a requirement. Requiring a keyword like you suggest would remove that feature.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January  6, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Taking inspiration from syntax used for methods in classes that override methods in superclasses, require methods that override dynamically dispatched default implementations in protocol extensions to use the override keyword. Likewise, forbid the override keyword if the method being implemented instead &#39;masks&#39; (would that be the right word?) a statically dispatched method in a protocol extension which can nonetheless be invoked by upcasting to the protocol.<br>&gt; <br>&gt; This has been suggested before, usually in the form of a separate `implement` keyword. The main problem is that it makes it impossible to write a protocol after the fact which formalizes some existing pattern in the types.<br>&gt; <br>&gt; What do I mean by that? Well, imagine you need generic access to the `min` and `max` static properties of the various integer types. There&#39;s no existing protocol that includes those members. But you can write one and then extend the integer types to conform to your new protocol:<br>&gt; <br>&gt; 	protocol BoundedIntegerType: IntegerType {<br>&gt; 		static var min: Self { get }<br>&gt; 		static var max: Self { get }<br>&gt; 	}<br>&gt; 	extension Int: BoundedType {}<br>&gt; 	extension Int8: BoundedType {}<br>&gt; 	extension Int16: BoundedType {}<br>&gt; 	extension Int32: BoundedType {}<br>&gt; 	extension Int64: BoundedType {}<br>&gt; <br>&gt; 	func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x: Integer) {<br>&gt; 		print(Integer.min)<br>&gt; 	}<br>&gt; <br>&gt; This only works because `min` and `max` *don&#39;t* need any special marking to be used to satisfy a requirement. Requiring a keyword like you suggest would remove that feature.<br></p><p>Possible solution: if you want a new protocol adoption to map to some existing method or property then you must explicitly write that. You can&#39;t just adopt the protocol in an empty extension.<br></p><p>    extension Int: BoundedType {<br>        static var min = Int.min<br>        static var max = Int.max<br>    }<br></p><p>but with some other syntax that isn&#39;t ambiguous. Code completion and compiler fix-its could suggest this when the class already implements something suitable.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  6, 2016 at 04:00:00am</p></header><div class="content"><p>&gt;Possible solution: if you want a new protocol adoption to map to some existing method or property then you must explicitly write that. You can&#39;t just adopt the protocol in an empty extension.<br>&gt;<br>&gt;    extension Int: BoundedType {<br>&gt;        static var min = Int.min<br>&gt;        static var max = Int.max<br>&gt;    }<br>&gt;<br>&gt;but with some other syntax that isn&#39;t ambiguous. Code completion and compiler fix-its could suggest this when the class already implements something suitable.<br></p><p>That would be really neat. On my wishlist though would be something<br>along the same lines going in the forward direction, where there&#39;s<br>some sort of distinction between a class or struct overriding a<br>dynamically dispatched default implementation for a method declared in<br>a protocol and a method that doesn&#39;t override anything but happens to<br>&#39;shadow&#39; or &#39;mask&#39; a statically dispatched method in a protocol<br>extension that&#39;s never fully overridden. I guess the objection here is<br>that a change in syntax for that scenario would make new protocol<br>adoptions after the fact difficult; but there must be a way to have it<br>both ways...<br></p><p><br>On Wed, Jan 6, 2016 at 3:48 AM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Taking inspiration from syntax used for methods in classes that override methods in superclasses, require methods that override dynamically dispatched default implementations in protocol extensions to use the override keyword. Likewise, forbid the override keyword if the method being implemented instead &#39;masks&#39; (would that be the right word?) a statically dispatched method in a protocol extension which can nonetheless be invoked by upcasting to the protocol.<br>&gt;&gt;<br>&gt;&gt; This has been suggested before, usually in the form of a separate `implement` keyword. The main problem is that it makes it impossible to write a protocol after the fact which formalizes some existing pattern in the types.<br>&gt;&gt;<br>&gt;&gt; What do I mean by that? Well, imagine you need generic access to the `min` and `max` static properties of the various integer types. There&#39;s no existing protocol that includes those members. But you can write one and then extend the integer types to conform to your new protocol:<br>&gt;&gt;<br>&gt;&gt;       protocol BoundedIntegerType: IntegerType {<br>&gt;&gt;               static var min: Self { get }<br>&gt;&gt;               static var max: Self { get }<br>&gt;&gt;       }<br>&gt;&gt;       extension Int: BoundedType {}<br>&gt;&gt;       extension Int8: BoundedType {}<br>&gt;&gt;       extension Int16: BoundedType {}<br>&gt;&gt;       extension Int32: BoundedType {}<br>&gt;&gt;       extension Int64: BoundedType {}<br>&gt;&gt;<br>&gt;&gt;       func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x: Integer) {<br>&gt;&gt;               print(Integer.min)<br>&gt;&gt;       }<br>&gt;&gt;<br>&gt;&gt; This only works because `min` and `max` *don&#39;t* need any special marking to be used to satisfy a requirement. Requiring a keyword like you suggest would remove that feature.<br>&gt;<br>&gt; Possible solution: if you want a new protocol adoption to map to some existing method or property then you must explicitly write that. You can&#39;t just adopt the protocol in an empty extension.<br>&gt;<br>&gt;     extension Int: BoundedType {<br>&gt;         static var min = Int.min<br>&gt;         static var max = Int.max<br>&gt;     }<br>&gt;<br>&gt; but with some other syntax that isn&#39;t ambiguous. Code completion and compiler fix-its could suggest this when the class already implements something suitable.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  6, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 6, 2016, at 3:48 AM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Taking inspiration from syntax used for methods in classes that override methods in superclasses, require methods that override dynamically dispatched default implementations in protocol extensions to use the override keyword. Likewise, forbid the override keyword if the method being implemented instead &#39;masks&#39; (would that be the right word?) a statically dispatched method in a protocol extension which can nonetheless be invoked by upcasting to the protocol.<br>&gt;&gt; <br>&gt;&gt; This has been suggested before, usually in the form of a separate `implement` keyword. The main problem is that it makes it impossible to write a protocol after the fact which formalizes some existing pattern in the types.<br>&gt;&gt; <br>&gt;&gt; What do I mean by that? Well, imagine you need generic access to the `min` and `max` static properties of the various integer types. There&#39;s no existing protocol that includes those members. But you can write one and then extend the integer types to conform to your new protocol:<br>&gt;&gt; <br>&gt;&gt; 	protocol BoundedIntegerType: IntegerType {<br>&gt;&gt; 		static var min: Self { get }<br>&gt;&gt; 		static var max: Self { get }<br>&gt;&gt; 	}<br>&gt;&gt; 	extension Int: BoundedType {}<br>&gt;&gt; 	extension Int8: BoundedType {}<br>&gt;&gt; 	extension Int16: BoundedType {}<br>&gt;&gt; 	extension Int32: BoundedType {}<br>&gt;&gt; 	extension Int64: BoundedType {}<br>&gt;&gt; <br>&gt;&gt; 	func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x: Integer) {<br>&gt;&gt; 		print(Integer.min)<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; This only works because `min` and `max` *don&#39;t* need any special marking to be used to satisfy a requirement. Requiring a keyword like you suggest would remove that feature.<br>&gt; <br>&gt; Possible solution: if you want a new protocol adoption to map to some existing method or property then you must explicitly write that. You can&#39;t just adopt the protocol in an empty extension.<br>&gt; <br>&gt;    extension Int: BoundedType {<br>&gt;        static var min = Int.min<br>&gt;        static var max = Int.max<br>&gt;    }<br>&gt; <br>&gt; but with some other syntax that isn&#39;t ambiguous. Code completion and compiler fix-its could suggest this when the class already implements something suitable.<br></p><p>Another option might be to allow imported definitions to be used by a conformance without the `override` marking to support retroactive modeling while requiring definitions in the same module as the conformance to explicitly specify the `override`.<br></p><p>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160106/aea2ee1f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Another option might be to allow imported definitions to be used by a<br>&gt; conformance without the `override` marking to support retroactive modeling<br>&gt; while requiring definitions in the same module as the conformance to<br>&gt; explicitly specify the `override`.<br></p><p>That&#39;s an interesting suggestion. I don&#39;t think I&#39;d prefer that<br>solution, though, because I would imagine that it&#39;s during retroactive<br>modeling of someone else&#39;s stuff that ambiguity regarding what&#39;s<br>overridden or not might occur.<br></p><p>I&#39;ve been slow in fully understanding Greg Parker&#39;s feedback, but on<br>reflection it may be the only way to satisfy all use cases. In<br>Thorsten&#39;s scenario where neither the protocol and its extension nor<br>the type is under the control of the user, making the type conform to<br>the protocol would either require no keyword requirements regarding<br>overriding methods (as it is, and as you suggest) or else a syntax to<br>indicate an overriding method must exist *within the extension that<br>conforms a type to a protocol* (as Greg suggests).<br></p><p>Can I propose an amended solution then?<br></p><p>(1) When a protocol requires a method (or property getter/setter,<br>etc.) but doesn&#39;t provide a default implementation, no keyword is used<br>anywhere since all conforming types must provide their own<br>implementation--I suppose a requirement could be made for a keyword,<br>but I don&#39;t know that it adds much in terms of guarding against<br>unintended behavior; I guess that can be a continued point of<br>discussion<br></p><p>(2) When a protocol doesn&#39;t declare a method but an extension to the<br>protocol provides one, types implementing a method with the same<br>signature *must not* declare it to be overriding; such protocol<br>extension methods are not overridden because they can be invoked after<br>upcasting<br></p><p>(3) When a protocol does declare a method, and an extension to the<br>protocol provides a default implementation, then to override that<br>implementation *either* the implementing type *or* an extension must<br>use the keyword `override`<br></p><p>(3a) In the case of an implementing type, `override func` is used<br>instead of `func`, just as in the case of a class overriding a<br>superclass method<br></p><p>(3b) In the case of an extension to a type (this is the syntax I could<br>come up with, but maybe it&#39;ll be objectionable in other ways), a<br>method in an existing class can be retroactively made overriding by<br>declaring `override [method signature]` with no body, similar to the<br>way that a method is declared inside a protocol; by analogy, an<br>overriding getter might use the syntax<br></p><p>extension Int: BoundedType {<br>    static var min { override get }<br>}<br></p><p>I think the syntax proposed in (3b) has the virtue of not requiring<br>additional keywords, being sufficiently similar to (3a) so that it&#39;s<br>not surprising, but still sufficiently unique in that the syntax is<br>not currently valid code and thus isn&#39;t currently used to mean<br>anything else.<br></p><p><br>On Wed, Jan 6, 2016 at 8:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;<br>&gt; On Jan 6, 2016, at 3:48 AM, Greg Parker via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Taking inspiration from syntax used for methods in classes that override<br>&gt; methods in superclasses, require methods that override dynamically<br>&gt; dispatched default implementations in protocol extensions to use the<br>&gt; override keyword. Likewise, forbid the override keyword if the method being<br>&gt; implemented instead &#39;masks&#39; (would that be the right word?) a statically<br>&gt; dispatched method in a protocol extension which can nonetheless be invoked<br>&gt; by upcasting to the protocol.<br>&gt;<br>&gt;<br>&gt; This has been suggested before, usually in the form of a separate<br>&gt; `implement` keyword. The main problem is that it makes it impossible to<br>&gt; write a protocol after the fact which formalizes some existing pattern in<br>&gt; the types.<br>&gt;<br>&gt; What do I mean by that? Well, imagine you need generic access to the `min`<br>&gt; and `max` static properties of the various integer types. There&#39;s no<br>&gt; existing protocol that includes those members. But you can write one and<br>&gt; then extend the integer types to conform to your new protocol:<br>&gt;<br>&gt; protocol BoundedIntegerType: IntegerType {<br>&gt; static var min: Self { get }<br>&gt; static var max: Self { get }<br>&gt; }<br>&gt; extension Int: BoundedType {}<br>&gt; extension Int8: BoundedType {}<br>&gt; extension Int16: BoundedType {}<br>&gt; extension Int32: BoundedType {}<br>&gt; extension Int64: BoundedType {}<br>&gt;<br>&gt; func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x:<br>&gt; Integer) {<br>&gt; print(Integer.min)<br>&gt; }<br>&gt;<br>&gt; This only works because `min` and `max` *don&#39;t* need any special marking to<br>&gt; be used to satisfy a requirement. Requiring a keyword like you suggest would<br>&gt; remove that feature.<br>&gt;<br>&gt;<br>&gt; Possible solution: if you want a new protocol adoption to map to some<br>&gt; existing method or property then you must explicitly write that. You can&#39;t<br>&gt; just adopt the protocol in an empty extension.<br>&gt;<br>&gt;    extension Int: BoundedType {<br>&gt;        static var min = Int.min<br>&gt;        static var max = Int.max<br>&gt;    }<br>&gt;<br>&gt; but with some other syntax that isn&#39;t ambiguous. Code completion and<br>&gt; compiler fix-its could suggest this when the class already implements<br>&gt; something suitable.<br>&gt;<br>&gt;<br>&gt; Another option might be to allow imported definitions to be used by a<br>&gt; conformance without the `override` marking to support retroactive modeling<br>&gt; while requiring definitions in the same module as the conformance to<br>&gt; explicitly specify the `override`.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>Comments in-line below.<br></p><p>On Thursday, 7 January 2016, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; Another option might be to allow imported definitions to be used by a<br>&gt; &gt; conformance without the `override` marking to support retroactive<br>&gt; modeling<br>&gt; &gt; while requiring definitions in the same module as the conformance to<br>&gt; &gt; explicitly specify the `override`.<br>&gt;<br>&gt; That&#39;s an interesting suggestion. I don&#39;t think I&#39;d prefer that<br>&gt; solution, though, because I would imagine that it&#39;s during retroactive<br>&gt; modeling of someone else&#39;s stuff that ambiguity regarding what&#39;s<br>&gt; overridden or not might occur.<br>&gt;<br>&gt; I&#39;ve been slow in fully understanding Greg Parker&#39;s feedback, but on<br>&gt; reflection it may be the only way to satisfy all use cases. In<br>&gt; Thorsten&#39;s scenario where neither the protocol and its extension nor<br>&gt; the type is under the control of the user, making the type conform to<br>&gt; the protocol would either require no keyword requirements regarding<br>&gt; overriding methods (as it is, and as you suggest) or else a syntax to<br>&gt; indicate an overriding method must exist *within the extension that<br>&gt; conforms a type to a protocol* (as Greg suggests).<br>&gt;<br>&gt; Can I propose an amended solution then?<br>&gt;<br>&gt; (1) When a protocol requires a method (or property getter/setter,<br>&gt; etc.) but doesn&#39;t provide a default implementation, no keyword is used<br>&gt; anywhere since all conforming types must provide their own<br>&gt; implementation--I suppose a requirement could be made for a keyword,<br>&gt; but I don&#39;t know that it adds much in terms of guarding against<br>&gt; unintended behavior; I guess that can be a continued point of<br>&gt; discussion<br></p><p><br>&gt; I don&#39;t like this solution because the compiler produces poor error<br>messages. It says that the type that implements the protocol doesn&#39;t<br>conform to the protocol in all three cases described below. Whereas if<br>override were required the compiler would say one of:<br></p><p>1. If the method was completely absent or there was a typo and no<br>override the compiler could identify the missing method as an error on the<br>type.<br>2. If the method had the same signature as a protocol method but no<br>override (or had final) the compiler could say that override is required<br>and importantly identify the method at fault<br>3. If the method had override but a typo the compiler could say that it<br>does not override a method and importantly identify the method at fault.<br>4. If the method had both final and override the compiler could say that<br>both not allowed and importantly identify the method at fault.<br></p><p>Which is much more fine grained and informative.<br>&gt;<br>&gt;<br>&gt; (2) When a protocol doesn&#39;t declare a method but an extension to the<br>&gt; protocol provides one, types implementing a method with the same<br>&gt; signature *must not* declare it to be overriding; such protocol<br>&gt; extension methods are not overridden because they can be invoked after<br>&gt; upcasting<br>&gt;<br>&gt; I would prefer final to be required so that it is clear that this is a<br>static dispatch.<br>&gt;<br>&gt;<br>&gt; (3) When a protocol does declare a method, and an extension to the<br>&gt; protocol provides a default implementation, then to override that<br>&gt; implementation *either* the implementing type *or* an extension must<br>&gt; use the keyword `override`<br>&gt;<br>&gt; (3a) In the case of an implementing type, `override func` is used<br>&gt; instead of `func`, just as in the case of a class overriding a<br>&gt; superclass method<br>&gt;<br>&gt; (3b) In the case of an extension to a type (this is the syntax I could<br>&gt; come up with, but maybe it&#39;ll be objectionable in other ways), a<br>&gt; method in an existing class can be retroactively made overriding by<br>&gt; declaring `override [method signature]` with no body, similar to the<br>&gt; way that a method is declared inside a protocol; by analogy, an<br>&gt; overriding getter might use the syntax<br>&gt;<br>&gt; extension Int: BoundedType {<br>&gt;     static var min { override get }<br>&gt; }<br>&gt;<br>&gt; I think the syntax proposed in (3b) has the virtue of not requiring<br>&gt; additional keywords, being sufficiently similar to (3a) so that it&#39;s<br>&gt; not surprising, but still sufficiently unique in that the syntax is<br>&gt; not currently valid code and thus isn&#39;t currently used to mean<br>&gt; anything else.<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 8:21 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Jan 6, 2016, at 3:48 AM, Greg Parker via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Taking inspiration from syntax used for methods in classes that override<br>&gt; &gt; methods in superclasses, require methods that override dynamically<br>&gt; &gt; dispatched default implementations in protocol extensions to use the<br>&gt; &gt; override keyword. Likewise, forbid the override keyword if the method<br>&gt; being<br>&gt; &gt; implemented instead &#39;masks&#39; (would that be the right word?) a statically<br>&gt; &gt; dispatched method in a protocol extension which can nonetheless be<br>&gt; invoked<br>&gt; &gt; by upcasting to the protocol.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; This has been suggested before, usually in the form of a separate<br>&gt; &gt; `implement` keyword. The main problem is that it makes it impossible to<br>&gt; &gt; write a protocol after the fact which formalizes some existing pattern in<br>&gt; &gt; the types.<br>&gt; &gt;<br>&gt; &gt; What do I mean by that? Well, imagine you need generic access to the<br>&gt; `min`<br>&gt; &gt; and `max` static properties of the various integer types. There&#39;s no<br>&gt; &gt; existing protocol that includes those members. But you can write one and<br>&gt; &gt; then extend the integer types to conform to your new protocol:<br>&gt; &gt;<br>&gt; &gt; protocol BoundedIntegerType: IntegerType {<br>&gt; &gt; static var min: Self { get }<br>&gt; &gt; static var max: Self { get }<br>&gt; &gt; }<br>&gt; &gt; extension Int: BoundedType {}<br>&gt; &gt; extension Int8: BoundedType {}<br>&gt; &gt; extension Int16: BoundedType {}<br>&gt; &gt; extension Int32: BoundedType {}<br>&gt; &gt; extension Int64: BoundedType {}<br>&gt; &gt;<br>&gt; &gt; func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x:<br>&gt; &gt; Integer) {<br>&gt; &gt; print(Integer.min)<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This only works because `min` and `max` *don&#39;t* need any special marking<br>&gt; to<br>&gt; &gt; be used to satisfy a requirement. Requiring a keyword like you suggest<br>&gt; would<br>&gt; &gt; remove that feature.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Possible solution: if you want a new protocol adoption to map to some<br>&gt; &gt; existing method or property then you must explicitly write that. You<br>&gt; can&#39;t<br>&gt; &gt; just adopt the protocol in an empty extension.<br>&gt; &gt;<br>&gt; &gt;    extension Int: BoundedType {<br>&gt; &gt;        static var min = Int.min<br>&gt; &gt;        static var max = Int.max<br>&gt; &gt;    }<br>&gt; &gt;<br>&gt; &gt; but with some other syntax that isn&#39;t ambiguous. Code completion and<br>&gt; &gt; compiler fix-its could suggest this when the class already implements<br>&gt; &gt; something suitable.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Another option might be to allow imported definitions to be used by a<br>&gt; &gt; conformance without the `override` marking to support retroactive<br>&gt; modeling<br>&gt; &gt; while requiring definitions in the same module as the conformance to<br>&gt; &gt; explicitly specify the `override`.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Greg Parker     gparker at apple.com &lt;javascript:;&gt;     Runtime Wrangler<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/1bf550f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>January  6, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; I don&#39;t like this solution because the compiler produces poor error<br>&gt; messages. It says that the type that implements the protocol doesn&#39;t conform<br>&gt; to the protocol in all three cases described below. Whereas if override were<br>&gt; required the compiler would say one of:<br></p><p>I completely agree that the compiler&#39;s error messages are currently<br>vague and unhelpful. I don&#39;t have any experience in terms of how the<br>compiler goes about its job, but it seems to me that it&#39;s an<br>orthogonal issue? Whether `override` is required everywhere or no, if<br>the compiler has enough information to know that the type is<br>nonconforming, surely it could be spruced up to know which methods or<br>properties are missing even while maintaining today&#39;s syntax? Someone<br>who&#39;s expert in this could probably chime in here. I get the sense<br>from this list that the community and core team are not in favor of<br>changing syntax only to make up for deficiencies in tooling, though<br>honestly I don&#39;t think the syntax would be worse off if we do it your<br>way.<br></p><p>&gt; I would prefer final to be required so that it is clear that this is a<br>&gt; static dispatch.<br></p><p>I&#39;ve tried to follow the other thread about this. I&#39;m not clear that I<br>fully grasp the proposal but that&#39;s my fault. Something isn&#39;t clicking<br>about how final (which I understand in the context of class<br>hierarchies) works in the context of protocol extensions. Would this<br>mean that if a protocol extension defines a statically dispatched and<br>therefore mandatory &#39;final&#39; method foo() that I&#39;m no longer allowed to<br>have a method foo() in a conforming class? That seems like it could<br>make a lot of things blow up especially in the context of retroactive<br>modeling as discussed above. Perhaps I&#39;m just not understanding.<br></p><p><br>On Wed, Jan 6, 2016 at 5:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; Comments in-line below.<br>&gt;<br>&gt;<br>&gt; On Thursday, 7 January 2016, Xiaodi Wu via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; Another option might be to allow imported definitions to be used by a<br>&gt;&gt; &gt; conformance without the `override` marking to support retroactive<br>&gt;&gt; &gt; modeling<br>&gt;&gt; &gt; while requiring definitions in the same module as the conformance to<br>&gt;&gt; &gt; explicitly specify the `override`.<br>&gt;&gt;<br>&gt;&gt; That&#39;s an interesting suggestion. I don&#39;t think I&#39;d prefer that<br>&gt;&gt; solution, though, because I would imagine that it&#39;s during retroactive<br>&gt;&gt; modeling of someone else&#39;s stuff that ambiguity regarding what&#39;s<br>&gt;&gt; overridden or not might occur.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve been slow in fully understanding Greg Parker&#39;s feedback, but on<br>&gt;&gt; reflection it may be the only way to satisfy all use cases. In<br>&gt;&gt; Thorsten&#39;s scenario where neither the protocol and its extension nor<br>&gt;&gt; the type is under the control of the user, making the type conform to<br>&gt;&gt; the protocol would either require no keyword requirements regarding<br>&gt;&gt; overriding methods (as it is, and as you suggest) or else a syntax to<br>&gt;&gt; indicate an overriding method must exist *within the extension that<br>&gt;&gt; conforms a type to a protocol* (as Greg suggests).<br>&gt;&gt;<br>&gt;&gt; Can I propose an amended solution then?<br>&gt;&gt;<br>&gt;&gt; (1) When a protocol requires a method (or property getter/setter,<br>&gt;&gt; etc.) but doesn&#39;t provide a default implementation, no keyword is used<br>&gt;&gt; anywhere since all conforming types must provide their own<br>&gt;&gt; implementation--I suppose a requirement could be made for a keyword,<br>&gt;&gt; but I don&#39;t know that it adds much in terms of guarding against<br>&gt;&gt; unintended behavior; I guess that can be a continued point of<br>&gt;&gt; discussion<br>&gt;&gt;<br>&gt;&gt;<br>&gt; I don&#39;t like this solution because the compiler produces poor error<br>&gt; messages. It says that the type that implements the protocol doesn&#39;t conform<br>&gt; to the protocol in all three cases described below. Whereas if override were<br>&gt; required the compiler would say one of:<br>&gt;<br>&gt; 1. If the method was completely absent or there was a typo and no override<br>&gt; the compiler could identify the missing method as an error on the type.<br>&gt; 2. If the method had the same signature as a protocol method but no override<br>&gt; (or had final) the compiler could say that override is required and<br>&gt; importantly identify the method at fault<br>&gt; 3. If the method had override but a typo the compiler could say that it does<br>&gt; not override a method and importantly identify the method at fault.<br>&gt; 4. If the method had both final and override the compiler could say that<br>&gt; both not allowed and importantly identify the method at fault.<br>&gt;<br>&gt; Which is much more fine grained and informative.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; (2) When a protocol doesn&#39;t declare a method but an extension to the<br>&gt;&gt; protocol provides one, types implementing a method with the same<br>&gt;&gt; signature *must not* declare it to be overriding; such protocol<br>&gt;&gt; extension methods are not overridden because they can be invoked after<br>&gt;&gt; upcasting<br>&gt;&gt;<br>&gt; I would prefer final to be required so that it is clear that this is a<br>&gt; static dispatch.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; (3) When a protocol does declare a method, and an extension to the<br>&gt;&gt; protocol provides a default implementation, then to override that<br>&gt;&gt; implementation *either* the implementing type *or* an extension must<br>&gt;&gt; use the keyword `override`<br>&gt;&gt;<br>&gt;&gt; (3a) In the case of an implementing type, `override func` is used<br>&gt;&gt; instead of `func`, just as in the case of a class overriding a<br>&gt;&gt; superclass method<br>&gt;&gt;<br>&gt;&gt; (3b) In the case of an extension to a type (this is the syntax I could<br>&gt;&gt; come up with, but maybe it&#39;ll be objectionable in other ways), a<br>&gt;&gt; method in an existing class can be retroactively made overriding by<br>&gt;&gt; declaring `override [method signature]` with no body, similar to the<br>&gt;&gt; way that a method is declared inside a protocol; by analogy, an<br>&gt;&gt; overriding getter might use the syntax<br>&gt;&gt;<br>&gt;&gt; extension Int: BoundedType {<br>&gt;&gt;     static var min { override get }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I think the syntax proposed in (3b) has the virtue of not requiring<br>&gt;&gt; additional keywords, being sufficiently similar to (3a) so that it&#39;s<br>&gt;&gt; not surprising, but still sufficiently unique in that the syntax is<br>&gt;&gt; not currently valid code and thus isn&#39;t currently used to mean<br>&gt;&gt; anything else.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Jan 6, 2016 at 8:21 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Jan 6, 2016, at 3:48 AM, Greg Parker via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution<br>&gt;&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Taking inspiration from syntax used for methods in classes that override<br>&gt;&gt; &gt; methods in superclasses, require methods that override dynamically<br>&gt;&gt; &gt; dispatched default implementations in protocol extensions to use the<br>&gt;&gt; &gt; override keyword. Likewise, forbid the override keyword if the method<br>&gt;&gt; &gt; being<br>&gt;&gt; &gt; implemented instead &#39;masks&#39; (would that be the right word?) a statically<br>&gt;&gt; &gt; dispatched method in a protocol extension which can nonetheless be<br>&gt;&gt; &gt; invoked<br>&gt;&gt; &gt; by upcasting to the protocol.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This has been suggested before, usually in the form of a separate<br>&gt;&gt; &gt; `implement` keyword. The main problem is that it makes it impossible to<br>&gt;&gt; &gt; write a protocol after the fact which formalizes some existing pattern<br>&gt;&gt; &gt; in<br>&gt;&gt; &gt; the types.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; What do I mean by that? Well, imagine you need generic access to the<br>&gt;&gt; &gt; `min`<br>&gt;&gt; &gt; and `max` static properties of the various integer types. There&#39;s no<br>&gt;&gt; &gt; existing protocol that includes those members. But you can write one and<br>&gt;&gt; &gt; then extend the integer types to conform to your new protocol:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; protocol BoundedIntegerType: IntegerType {<br>&gt;&gt; &gt; static var min: Self { get }<br>&gt;&gt; &gt; static var max: Self { get }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; extension Int: BoundedType {}<br>&gt;&gt; &gt; extension Int8: BoundedType {}<br>&gt;&gt; &gt; extension Int16: BoundedType {}<br>&gt;&gt; &gt; extension Int32: BoundedType {}<br>&gt;&gt; &gt; extension Int64: BoundedType {}<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x:<br>&gt;&gt; &gt; Integer) {<br>&gt;&gt; &gt; print(Integer.min)<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This only works because `min` and `max` *don&#39;t* need any special marking<br>&gt;&gt; &gt; to<br>&gt;&gt; &gt; be used to satisfy a requirement. Requiring a keyword like you suggest<br>&gt;&gt; &gt; would<br>&gt;&gt; &gt; remove that feature.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Possible solution: if you want a new protocol adoption to map to some<br>&gt;&gt; &gt; existing method or property then you must explicitly write that. You<br>&gt;&gt; &gt; can&#39;t<br>&gt;&gt; &gt; just adopt the protocol in an empty extension.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;    extension Int: BoundedType {<br>&gt;&gt; &gt;        static var min = Int.min<br>&gt;&gt; &gt;        static var max = Int.max<br>&gt;&gt; &gt;    }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; but with some other syntax that isn&#39;t ambiguous. Code completion and<br>&gt;&gt; &gt; compiler fix-its could suggest this when the class already implements<br>&gt;&gt; &gt; something suitable.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Another option might be to allow imported definitions to be used by a<br>&gt;&gt; &gt; conformance without the `override` marking to support retroactive<br>&gt;&gt; &gt; modeling<br>&gt;&gt; &gt; while requiring definitions in the same module as the conformance to<br>&gt;&gt; &gt; explicitly specify the `override`.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; --<br>&gt;&gt; &gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  7, 2016 at 12:00:00pm</p></header><div class="content"><p>The point is that without the requirement of both final and override the<br>compiler doesn&#39;t know in detail what the problem is; just that there is a<br>problem, it doesn&#39;t have enough information (it doesn&#39;t know the<br>programmers intention - override and final clarify that intension). That is<br>irrespective of how the compiler is written.<br></p><p>On Thursday, 7 January 2016, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br></p><p>&gt; &gt; I don&#39;t like this solution because the compiler produces poor error<br>&gt; &gt; messages. It says that the type that implements the protocol doesn&#39;t<br>&gt; conform<br>&gt; &gt; to the protocol in all three cases described below. Whereas if override<br>&gt; were<br>&gt; &gt; required the compiler would say one of:<br>&gt;<br>&gt; I completely agree that the compiler&#39;s error messages are currently<br>&gt; vague and unhelpful. I don&#39;t have any experience in terms of how the<br>&gt; compiler goes about its job, but it seems to me that it&#39;s an<br>&gt; orthogonal issue? Whether `override` is required everywhere or no, if<br>&gt; the compiler has enough information to know that the type is<br>&gt; nonconforming, surely it could be spruced up to know which methods or<br>&gt; properties are missing even while maintaining today&#39;s syntax? Someone<br>&gt; who&#39;s expert in this could probably chime in here. I get the sense<br>&gt; from this list that the community and core team are not in favor of<br>&gt; changing syntax only to make up for deficiencies in tooling, though<br>&gt; honestly I don&#39;t think the syntax would be worse off if we do it your<br>&gt; way.<br></p><p><br>&gt; &gt; I would prefer final to be required so that it is clear that this is a<br>&gt; &gt; static dispatch.<br>&gt;<br>&gt; I&#39;ve tried to follow the other thread about this. I&#39;m not clear that I<br>&gt; fully grasp the proposal but that&#39;s my fault. Something isn&#39;t clicking<br>&gt; about how final (which I understand in the context of class<br>&gt; hierarchies) works in the context of protocol extensions. Would this<br>&gt; mean that if a protocol extension defines a statically dispatched and<br>&gt; therefore mandatory &#39;final&#39; method foo() that I&#39;m no longer allowed to<br>&gt; have a method foo() in a conforming class? That seems like it could<br>&gt; make a lot of things blow up especially in the context of retroactive<br>&gt; modeling as discussed above. Perhaps I&#39;m just not understanding.<br>&gt;<br>&gt;<br>&gt; On Wed, Jan 6, 2016 at 5:56 PM, Howard Lovatt &lt;howard.lovatt at gmail.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; Comments in-line below.<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Thursday, 7 January 2016, Xiaodi Wu via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; &gt; Another option might be to allow imported definitions to be used by a<br>&gt; &gt;&gt; &gt; conformance without the `override` marking to support retroactive<br>&gt; &gt;&gt; &gt; modeling<br>&gt; &gt;&gt; &gt; while requiring definitions in the same module as the conformance to<br>&gt; &gt;&gt; &gt; explicitly specify the `override`.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That&#39;s an interesting suggestion. I don&#39;t think I&#39;d prefer that<br>&gt; &gt;&gt; solution, though, because I would imagine that it&#39;s during retroactive<br>&gt; &gt;&gt; modeling of someone else&#39;s stuff that ambiguity regarding what&#39;s<br>&gt; &gt;&gt; overridden or not might occur.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;ve been slow in fully understanding Greg Parker&#39;s feedback, but on<br>&gt; &gt;&gt; reflection it may be the only way to satisfy all use cases. In<br>&gt; &gt;&gt; Thorsten&#39;s scenario where neither the protocol and its extension nor<br>&gt; &gt;&gt; the type is under the control of the user, making the type conform to<br>&gt; &gt;&gt; the protocol would either require no keyword requirements regarding<br>&gt; &gt;&gt; overriding methods (as it is, and as you suggest) or else a syntax to<br>&gt; &gt;&gt; indicate an overriding method must exist *within the extension that<br>&gt; &gt;&gt; conforms a type to a protocol* (as Greg suggests).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Can I propose an amended solution then?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (1) When a protocol requires a method (or property getter/setter,<br>&gt; &gt;&gt; etc.) but doesn&#39;t provide a default implementation, no keyword is used<br>&gt; &gt;&gt; anywhere since all conforming types must provide their own<br>&gt; &gt;&gt; implementation--I suppose a requirement could be made for a keyword,<br>&gt; &gt;&gt; but I don&#39;t know that it adds much in terms of guarding against<br>&gt; &gt;&gt; unintended behavior; I guess that can be a continued point of<br>&gt; &gt;&gt; discussion<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt; I don&#39;t like this solution because the compiler produces poor error<br>&gt; &gt; messages. It says that the type that implements the protocol doesn&#39;t<br>&gt; conform<br>&gt; &gt; to the protocol in all three cases described below. Whereas if override<br>&gt; were<br>&gt; &gt; required the compiler would say one of:<br>&gt; &gt;<br>&gt; &gt; 1. If the method was completely absent or there was a typo and no<br>&gt; override<br>&gt; &gt; the compiler could identify the missing method as an error on the type.<br>&gt; &gt; 2. If the method had the same signature as a protocol method but no<br>&gt; override<br>&gt; &gt; (or had final) the compiler could say that override is required and<br>&gt; &gt; importantly identify the method at fault<br>&gt; &gt; 3. If the method had override but a typo the compiler could say that it<br>&gt; does<br>&gt; &gt; not override a method and importantly identify the method at fault.<br>&gt; &gt; 4. If the method had both final and override the compiler could say that<br>&gt; &gt; both not allowed and importantly identify the method at fault.<br>&gt; &gt;<br>&gt; &gt; Which is much more fine grained and informative.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (2) When a protocol doesn&#39;t declare a method but an extension to the<br>&gt; &gt;&gt; protocol provides one, types implementing a method with the same<br>&gt; &gt;&gt; signature *must not* declare it to be overriding; such protocol<br>&gt; &gt;&gt; extension methods are not overridden because they can be invoked after<br>&gt; &gt;&gt; upcasting<br>&gt; &gt;&gt;<br>&gt; &gt; I would prefer final to be required so that it is clear that this is a<br>&gt; &gt; static dispatch.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (3) When a protocol does declare a method, and an extension to the<br>&gt; &gt;&gt; protocol provides a default implementation, then to override that<br>&gt; &gt;&gt; implementation *either* the implementing type *or* an extension must<br>&gt; &gt;&gt; use the keyword `override`<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (3a) In the case of an implementing type, `override func` is used<br>&gt; &gt;&gt; instead of `func`, just as in the case of a class overriding a<br>&gt; &gt;&gt; superclass method<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (3b) In the case of an extension to a type (this is the syntax I could<br>&gt; &gt;&gt; come up with, but maybe it&#39;ll be objectionable in other ways), a<br>&gt; &gt;&gt; method in an existing class can be retroactively made overriding by<br>&gt; &gt;&gt; declaring `override [method signature]` with no body, similar to the<br>&gt; &gt;&gt; way that a method is declared inside a protocol; by analogy, an<br>&gt; &gt;&gt; overriding getter might use the syntax<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; extension Int: BoundedType {<br>&gt; &gt;&gt;     static var min { override get }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I think the syntax proposed in (3b) has the virtue of not requiring<br>&gt; &gt;&gt; additional keywords, being sufficiently similar to (3a) so that it&#39;s<br>&gt; &gt;&gt; not surprising, but still sufficiently unique in that the syntax is<br>&gt; &gt;&gt; not currently valid code and thus isn&#39;t currently used to mean<br>&gt; &gt;&gt; anything else.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On Wed, Jan 6, 2016 at 8:21 AM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt; &lt;javascript:;&gt;&gt;<br>&gt; &gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Jan 6, 2016, at 3:48 AM, Greg Parker via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution<br>&gt; &gt;&gt; &gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Taking inspiration from syntax used for methods in classes that<br>&gt; override<br>&gt; &gt;&gt; &gt; methods in superclasses, require methods that override dynamically<br>&gt; &gt;&gt; &gt; dispatched default implementations in protocol extensions to use the<br>&gt; &gt;&gt; &gt; override keyword. Likewise, forbid the override keyword if the method<br>&gt; &gt;&gt; &gt; being<br>&gt; &gt;&gt; &gt; implemented instead &#39;masks&#39; (would that be the right word?) a<br>&gt; statically<br>&gt; &gt;&gt; &gt; dispatched method in a protocol extension which can nonetheless be<br>&gt; &gt;&gt; &gt; invoked<br>&gt; &gt;&gt; &gt; by upcasting to the protocol.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; This has been suggested before, usually in the form of a separate<br>&gt; &gt;&gt; &gt; `implement` keyword. The main problem is that it makes it impossible<br>&gt; to<br>&gt; &gt;&gt; &gt; write a protocol after the fact which formalizes some existing pattern<br>&gt; &gt;&gt; &gt; in<br>&gt; &gt;&gt; &gt; the types.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; What do I mean by that? Well, imagine you need generic access to the<br>&gt; &gt;&gt; &gt; `min`<br>&gt; &gt;&gt; &gt; and `max` static properties of the various integer types. There&#39;s no<br>&gt; &gt;&gt; &gt; existing protocol that includes those members. But you can write one<br>&gt; and<br>&gt; &gt;&gt; &gt; then extend the integer types to conform to your new protocol:<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; protocol BoundedIntegerType: IntegerType {<br>&gt; &gt;&gt; &gt; static var min: Self { get }<br>&gt; &gt;&gt; &gt; static var max: Self { get }<br>&gt; &gt;&gt; &gt; }<br>&gt; &gt;&gt; &gt; extension Int: BoundedType {}<br>&gt; &gt;&gt; &gt; extension Int8: BoundedType {}<br>&gt; &gt;&gt; &gt; extension Int16: BoundedType {}<br>&gt; &gt;&gt; &gt; extension Int32: BoundedType {}<br>&gt; &gt;&gt; &gt; extension Int64: BoundedType {}<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x:<br>&gt; &gt;&gt; &gt; Integer) {<br>&gt; &gt;&gt; &gt; print(Integer.min)<br>&gt; &gt;&gt; &gt; }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; This only works because `min` and `max` *don&#39;t* need any special<br>&gt; marking<br>&gt; &gt;&gt; &gt; to<br>&gt; &gt;&gt; &gt; be used to satisfy a requirement. Requiring a keyword like you suggest<br>&gt; &gt;&gt; &gt; would<br>&gt; &gt;&gt; &gt; remove that feature.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Possible solution: if you want a new protocol adoption to map to some<br>&gt; &gt;&gt; &gt; existing method or property then you must explicitly write that. You<br>&gt; &gt;&gt; &gt; can&#39;t<br>&gt; &gt;&gt; &gt; just adopt the protocol in an empty extension.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;    extension Int: BoundedType {<br>&gt; &gt;&gt; &gt;        static var min = Int.min<br>&gt; &gt;&gt; &gt;        static var max = Int.max<br>&gt; &gt;&gt; &gt;    }<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; but with some other syntax that isn&#39;t ambiguous. Code completion and<br>&gt; &gt;&gt; &gt; compiler fix-its could suggest this when the class already implements<br>&gt; &gt;&gt; &gt; something suitable.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; Another option might be to allow imported definitions to be used by a<br>&gt; &gt;&gt; &gt; conformance without the `override` marking to support retroactive<br>&gt; &gt;&gt; &gt; modeling<br>&gt; &gt;&gt; &gt; while requiring definitions in the same module as the conformance to<br>&gt; &gt;&gt; &gt; explicitly specify the `override`.<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; --<br>&gt; &gt;&gt; &gt; Greg Parker     gparker at apple.com &lt;javascript:;&gt;     Runtime Wrangler<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt; _______________________________________________<br>&gt; &gt;&gt; &gt; swift-evolution mailing list<br>&gt; &gt;&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; &gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt;   -- Howard.<br>&gt; &gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/436a2388/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January  6, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Another option might be to allow imported definitions to be used by a conformance without the `override` marking to support retroactive modeling while requiring definitions in the same module as the conformance to explicitly specify the `override`.<br></p><p>But the same problem exists if you want to do this to `internal` types using a `private` protocol. There you *could* make the protocol `internal` and call `override` in all the right places, but if the protocol is an implementation detail of one particular file, why should you?<br></p><p>(Thanks for the term &quot;retroactive modeling&quot;, by the wayI couldn&#39;t remember it.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Require use of override keyword to override dynamically dispatched methods defined in a protocol with a default implementation</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January  7, 2016 at 10:00:00am</p></header><div class="content"><p>I like Greg Parkers suggestion, if the extension is of a type that is not<br>part of the project/library that is being developed then you don&#39;t need<br>override. This would allow after-the-fact extensions to library and<br>third-party structure/classes. It is also not confusing to human or<br>compiler, since this is not source code you are looking at (by definition).<br></p><p>On Thursday, 7 January 2016, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 6, 2016, at 3:48 AM, Greg Parker via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 5, 2016, at 8:50 PM, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Taking inspiration from syntax used for methods in classes that override<br>&gt; methods in superclasses, require methods that override dynamically<br>&gt; dispatched default implementations in protocol extensions to use the<br>&gt; override keyword. Likewise, forbid the override keyword if the method being<br>&gt; implemented instead &#39;masks&#39; (would that be the right word?) a statically<br>&gt; dispatched method in a protocol extension which can nonetheless be invoked<br>&gt; by upcasting to the protocol.<br>&gt;<br>&gt;<br>&gt; This has been suggested before, usually in the form of a separate<br>&gt; `implement` keyword. The main problem is that it makes it impossible to<br>&gt; write a protocol after the fact which formalizes some existing pattern in<br>&gt; the types.<br>&gt;<br>&gt; What do I mean by that? Well, imagine you need generic access to the `min`<br>&gt; and `max` static properties of the various integer types. There&#39;s no<br>&gt; existing protocol that includes those members. But you can write one and<br>&gt; then extend the integer types to conform to your new protocol:<br>&gt;<br>&gt; protocol BoundedIntegerType: IntegerType {<br>&gt; static var min: Self { get }<br>&gt; static var max: Self { get }<br>&gt; }<br>&gt; extension Int: BoundedType {}<br>&gt; extension Int8: BoundedType {}<br>&gt; extension Int16: BoundedType {}<br>&gt; extension Int32: BoundedType {}<br>&gt; extension Int64: BoundedType {}<br>&gt;<br>&gt; func printLowestPossibleValueOfValue&lt;Integer: BoundedIntegerType&gt;(x:<br>&gt; Integer) {<br>&gt; print(Integer.min)<br>&gt; }<br>&gt;<br>&gt; This only works because `min` and `max` *don&#39;t* need any special marking<br>&gt; to be used to satisfy a requirement. Requiring a keyword like you suggest<br>&gt; would remove that feature.<br>&gt;<br>&gt;<br>&gt; Possible solution: if you want a new protocol adoption to map to some<br>&gt; existing method or property then you must explicitly write that. You can&#39;t<br>&gt; just adopt the protocol in an empty extension.<br>&gt;<br>&gt;    extension Int: BoundedType {<br>&gt;        static var min = Int.min<br>&gt;        static var max = Int.max<br>&gt;    }<br>&gt;<br>&gt; but with some other syntax that isn&#39;t ambiguous. Code completion and<br>&gt; compiler fix-its could suggest this when the class already implements<br>&gt; something suitable.<br>&gt;<br>&gt;<br>&gt; Another option might be to allow imported definitions to be used by a<br>&gt; conformance without the `override` marking to support retroactive modeling<br>&gt; while requiring definitions in the same module as the conformance to<br>&gt; explicitly specify the `override`.<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;gparker at apple.com&#39;);&gt;     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/91087125/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
