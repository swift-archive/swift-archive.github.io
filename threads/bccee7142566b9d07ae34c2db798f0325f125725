<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78b45a835031f4ce03a6653b3262b5d3?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Alexander Momchilov</string> &lt;alexandermomchilov at gmail.com&gt;<p>May 11, 2016 at 09:00:00am</p></header><div class="content"><p>I came an interesting SO question<br>&lt;http://stackoverflow.com/a/37161488/3141234&gt; which pointed out a strange<br>quirk: a computed property must always use the &quot;var&quot; keyword, even if it&#39;s<br>read-only, and only referencing other immutable data.<br></p><p>class Test {<br>  let hello = &quot;hello&quot;<br>  let world = &quot;world&quot;<br>  var phrase: String { //why must this be &#39;var&#39;?<br>     return self.hello + self.world<br>  }}<br></p><p>It would be more appropriate for such a read-only, immutable property, to<br>use the &quot;let&quot; syntax, so that its immutability is correctly expressed.<br></p><p>Thoughts?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/bcce5725/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>I kind of agree with the logic of that, but imagine the following:<br></p><p>class Test {<br>  let hello = “hello”<br>  var subject = “world”<br>  var phrase: String { return hello + “, “ + subject }<br>}<br></p><p>In this scenario, “subject” can be changed.. and that changes the result of “phrase”. Things like this are why computed properties are “var”.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On May 11, 2016, at 8:25 AM, Alexander Momchilov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I came an interesting SO question which pointed out a strange quirk: a computed property must always use the &quot;var&quot; keyword, even if it&#39;s read-only, and only referencing other immutable data.<br>&gt; <br>&gt; class Test {<br>&gt; <br>&gt;   <br>&gt; let hello = &quot;hello&quot;<br>&gt; <br>&gt;   <br>&gt; let world = &quot;world&quot;<br>&gt; <br>&gt;   <br>&gt; var phrase: String { //why must this be &#39;var&#39;?<br>&gt; <br>&gt;      <br>&gt; return self.hello + self.<br>&gt; world<br>&gt;   <br>&gt; }<br>&gt; }<br>&gt; It would be more appropriate for such a read-only, immutable property, to use the &quot;let&quot; syntax, so that its immutability is correctly expressed.<br>&gt; <br>&gt; Thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 11, 2016, at 10:26 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I kind of agree with the logic of that, but imagine the following:<br>&gt; <br>&gt; class Test {<br>&gt;  let hello = “hello”<br>&gt;  var subject = “world”<br>&gt;  var phrase: String { return hello + “, “ + subject }<br>&gt; }<br>&gt; <br>&gt; In this scenario, “subject” can be changed.. and that changes the result of “phrase”. Things like this are why computed properties are “var”.<br></p><p>This example would still be required to be var because it accesses a var in its implementation.<br></p><p>I like the idea of allowing this feature, but only in cases where the compiler can verify immutable semantics.  Having it may help drive other features that could expand the cases the compiler can verify.  That would be great as this is a direction I would like to see Swift take in the future.<br></p><p>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 8:25 AM, Alexander Momchilov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I came an interesting SO question which pointed out a strange quirk: a computed property must always use the &quot;var&quot; keyword, even if it&#39;s read-only, and only referencing other immutable data.<br>&gt;&gt; <br>&gt;&gt; class Test {<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let hello = &quot;hello&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; let world = &quot;world&quot;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; var phrase: String { //why must this be &#39;var&#39;?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; return self.hello + self.<br>&gt;&gt; world<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; }<br>&gt;&gt; It would be more appropriate for such a read-only, immutable property, to use the &quot;let&quot; syntax, so that its immutability is correctly expressed.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 8:34 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On May 11, 2016, at 10:26 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I kind of agree with the logic of that, but imagine the following:<br>&gt;&gt; <br>&gt;&gt; class Test {<br>&gt;&gt; let hello = “hello”<br>&gt;&gt; var subject = “world”<br>&gt;&gt; var phrase: String { return hello + “, “ + subject }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In this scenario, “subject” can be changed.. and that changes the result of “phrase”. Things like this are why computed properties are “var”.<br>&gt; <br>&gt; This example would still be required to be var because it accesses a var in its implementation.<br>&gt; <br>&gt; I like the idea of allowing this feature, but only in cases where the compiler can verify immutable semantics.  Having it may help drive other features that could expand the cases the compiler can verify.  That would be great as this is a direction I would like to see Swift take in the future.<br></p><p>Yeah, this is why we don&#39;t currently allow computed &quot;let&quot; properties. We&#39;d only want to do so once we have the language facilities to ensure a computed &#39;let&#39; property is immutable and has no observable side effects.<br></p><p>-Joe<br></p><p>&gt;&gt; <br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 8:25 AM, Alexander Momchilov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I came an interesting SO question which pointed out a strange quirk: a computed property must always use the &quot;var&quot; keyword, even if it&#39;s read-only, and only referencing other immutable data.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Test {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let hello = &quot;hello&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let world = &quot;world&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var phrase: String { //why must this be &#39;var&#39;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; return self.hello + self.<br>&gt;&gt;&gt; world<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; It would be more appropriate for such a read-only, immutable property, to use the &quot;let&quot; syntax, so that its immutability is correctly expressed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/78b45a835031f4ce03a6653b3262b5d3?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Alexander Momchilov</string> &lt;alexandermomchilov at gmail.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Yeah, there will need to be a facility to annotating function purity<br></p><p>On Wed, May 11, 2016 at 1:00 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 11, 2016, at 8:34 AM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt;&gt; On May 11, 2016, at 10:26 AM, Sean Heber via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I kind of agree with the logic of that, but imagine the following:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; class Test {<br>&gt; &gt;&gt; let hello = “hello”<br>&gt; &gt;&gt; var subject = “world”<br>&gt; &gt;&gt; var phrase: String { return hello + “, “ + subject }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In this scenario, “subject” can be changed.. and that changes the<br>&gt; result of “phrase”. Things like this are why computed properties are “var”.<br>&gt; &gt;<br>&gt; &gt; This example would still be required to be var because it accesses a var<br>&gt; in its implementation.<br>&gt; &gt;<br>&gt; &gt; I like the idea of allowing this feature, but only in cases where the<br>&gt; compiler can verify immutable semantics.  Having it may help drive other<br>&gt; features that could expand the cases the compiler can verify.  That would<br>&gt; be great as this is a direction I would like to see Swift take in the<br>&gt; future.<br>&gt;<br>&gt; Yeah, this is why we don&#39;t currently allow computed &quot;let&quot; properties. We&#39;d<br>&gt; only want to do so once we have the language facilities to ensure a<br>&gt; computed &#39;let&#39; property is immutable and has no observable side effects.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; l8r<br>&gt; &gt;&gt; Sean<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On May 11, 2016, at 8:25 AM, Alexander Momchilov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I came an interesting SO question which pointed out a strange quirk: a<br>&gt; computed property must always use the &quot;var&quot; keyword, even if it&#39;s<br>&gt; read-only, and only referencing other immutable data.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; class Test {<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; let hello = &quot;hello&quot;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; let world = &quot;world&quot;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; var phrase: String { //why must this be &#39;var&#39;?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; return self.hello + self.<br>&gt; &gt;&gt;&gt; world<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; }<br>&gt; &gt;&gt;&gt; It would be more appropriate for such a read-only, immutable property,<br>&gt; to use the &quot;let&quot; syntax, so that its immutability is correctly expressed.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Thoughts?<br>&gt; &gt;&gt;&gt; _______________________________________________<br>&gt; &gt;&gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/0e677955/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 11, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 11 May 2016, at 18:00, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; On May 11, 2016, at 8:34 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On May 11, 2016, at 10:26 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I kind of agree with the logic of that, but imagine the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Test {<br>&gt;&gt;&gt; let hello = “hello”<br>&gt;&gt;&gt; var subject = “world”<br>&gt;&gt;&gt; var phrase: String { return hello + “, “ + subject }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In this scenario, “subject” can be changed.. and that changes the result of “phrase”. Things like this are why computed properties are “var”.<br>&gt;&gt; <br>&gt;&gt; This example would still be required to be var because it accesses a var in its implementation.<br>&gt;&gt; <br>&gt;&gt; I like the idea of allowing this feature, but only in cases where the compiler can verify immutable semantics.  Having it may help drive other features that could expand the cases the compiler can verify.  That would be great as this is a direction I would like to see Swift take in the future.<br>&gt; <br>&gt; Yeah, this is why we don&#39;t currently allow computed &quot;let&quot; properties. We&#39;d only want to do so once we have the language facilities to ensure a computed &#39;let&#39; property is immutable and has no observable side effects.<br></p><p><br>Even if a “computed” property were immutable, do we really want to implicitly make it a constant as well? Take for example:<br></p><p>class Test {<br>    let a:[Int64]<br>    let b:[Int64]<br></p><p>    init(_ value:Int64) {<br>        self.a = Array(count: 65536, repeatedValue: Int64(value))<br>        self.b = Array(count: 65536, repeatedValue: Int64(value &amp;+ 1))<br>    }<br></p><p>    var combined:[Int64] { return a + b }<br>}<br></p><p>Each of these arrays is 512kb, so storing a fixed value for the combined property would require another megabyte of space per instance of Test, but if the combined property is only infrequently called on some instances of Test, then it would be a waste of memory to precompute it, especially if you’re dealing with thousands of instances, with only a fraction of them calling the computed property. If you want to accelerate usage of the computed property then that’s what lazy variables are for, as you can delay the expensive combination until you actually need it.<br></p><p>The problem really is that the compiler can only do limited analysis about whether a computer property is used a lot, and in most cases it doesn’t care (it only really cares whether something is unused, as it can try to optimise it away), to make a good decision it would need to run the program with a realistic test-case an analysis memory overhead and performance impact of each method.<br></p><p>So yeah, I’m not really sure of the advantage of this, unless the intention is purely to restrict what can be used within your computed property’s implementation, but I don’t think the compiler can realistically do much in the way of optimising stuff away as precomputed values need to be stored somewhere, which could mean making your type bigger, which begs the question of why you specified a computed value in the first place.<br></p><p>I guess I’m just confused as to what the problem being solved would really be.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/c218efdc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 11, 2016, at 1:02 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On 11 May 2016, at 18:00, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 11, 2016, at 8:34 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 11, 2016, at 10:26 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I kind of agree with the logic of that, but imagine the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Test {<br>&gt;&gt;&gt;&gt; let hello = “hello”<br>&gt;&gt;&gt;&gt; var subject = “world”<br>&gt;&gt;&gt;&gt; var phrase: String { return hello + “, “ + subject }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this scenario, “subject” can be changed.. and that changes the result of “phrase”. Things like this are why computed properties are “var”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example would still be required to be var because it accesses a var in its implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of allowing this feature, but only in cases where the compiler can verify immutable semantics.  Having it may help drive other features that could expand the cases the compiler can verify.  That would be great as this is a direction I would like to see Swift take in the future.<br>&gt;&gt; <br>&gt;&gt; Yeah, this is why we don&#39;t currently allow computed &quot;let&quot; properties. We&#39;d only want to do so once we have the language facilities to ensure a computed &#39;let&#39; property is immutable and has no observable side effects.<br>&gt; <br>&gt; <br>&gt; Even if a “computed” property were immutable, do we really want to implicitly make it a constant as well? Take for example:<br>&gt; <br>&gt; class Test {<br>&gt;     let a:[Int64]<br>&gt;     let b:[Int64]<br>&gt; <br>&gt;     init(_ value:Int64) {<br>&gt;         self.a = Array(count: 65536, repeatedValue: Int64(value))<br>&gt;         self.b = Array(count: 65536, repeatedValue: Int64(value &amp;+ 1))<br>&gt;     }<br>&gt; <br>&gt;     var combined:[Int64] { return a + b }<br>&gt; }<br>&gt; <br>&gt; Each of these arrays is 512kb, so storing a fixed value for the combined property would require another megabyte of space per instance of Test, but if the combined property is only infrequently called on some instances of Test, then it would be a waste of memory to precompute it, especially if you’re dealing with thousands of instances, with only a fraction of them calling the computed property. If you want to accelerate usage of the computed property then that’s what lazy variables are for, as you can delay the expensive combination until you actually need it.<br>&gt; <br>&gt; The problem really is that the compiler can only do limited analysis about whether a computer property is used a lot, and in most cases it doesn’t care (it only really cares whether something is unused, as it can try to optimise it away), to make a good decision it would need to run the program with a realistic test-case an analysis memory overhead and performance impact of each method.<br>&gt; <br>&gt; So yeah, I’m not really sure of the advantage of this, unless the intention is purely to restrict what can be used within your computed property’s implementation, but I don’t think the compiler can realistically do much in the way of optimising stuff away as precomputed values need to be stored somewhere, which could mean making your type bigger, which begs the question of why you specified a computed value in the first place.<br>&gt; <br>&gt; I guess I’m just confused as to what the problem being solved would really be.<br></p><p>It provides semantic clarity in the API contract.  If you look at the property now and then look at it again at some point in the future you will get the same value back.  &#39;var { get }&#39; does not allow for that.  I imagine we would be able to specify &#39;let&#39; protocol requirements as well which could be implement with either stored or computed &#39;let&#39; properties.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/1b960e01/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 11:02 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 11 May 2016, at 18:00, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On May 11, 2016, at 8:34 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On May 11, 2016, at 10:26 AM, Sean Heber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I kind of agree with the logic of that, but imagine the following:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Test {<br>&gt;&gt;&gt;&gt; let hello = “hello”<br>&gt;&gt;&gt;&gt; var subject = “world”<br>&gt;&gt;&gt;&gt; var phrase: String { return hello + “, “ + subject }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In this scenario, “subject” can be changed.. and that changes the result of “phrase”. Things like this are why computed properties are “var”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example would still be required to be var because it accesses a var in its implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like the idea of allowing this feature, but only in cases where the compiler can verify immutable semantics.  Having it may help drive other features that could expand the cases the compiler can verify.  That would be great as this is a direction I would like to see Swift take in the future.<br>&gt;&gt; <br>&gt;&gt; Yeah, this is why we don&#39;t currently allow computed &quot;let&quot; properties. We&#39;d only want to do so once we have the language facilities to ensure a computed &#39;let&#39; property is immutable and has no observable side effects.<br>&gt; <br>&gt; Even if a “computed” property were immutable, do we really want to implicitly make it a constant as well? Take for example:<br>&gt; <br>&gt; class Test {<br>&gt;     let a:[Int64]<br>&gt;     let b:[Int64]<br>&gt; <br>&gt;     init(_ value:Int64) {<br>&gt;         self.a = Array(count: 65536, repeatedValue: Int64(value))<br>&gt;         self.b = Array(count: 65536, repeatedValue: Int64(value &amp;+ 1))<br>&gt;     }<br>&gt; <br>&gt;     var combined:[Int64] { return a + b }<br>&gt; }<br>&gt; <br>&gt; Each of these arrays is 512kb, so storing a fixed value for the combined property would require another megabyte of space per instance of Test, but if the combined property is only infrequently called on some instances of Test, then it would be a waste of memory to precompute it, especially if you’re dealing with thousands of instances, with only a fraction of them calling the computed property. If you want to accelerate usage of the computed property then that’s what lazy variables are for, as you can delay the expensive combination until you actually need it.<br></p><p>Being constant doesn&#39;t need to imply &quot;precomputed&quot;. I would expect a computed &#39;let&#39; to still be computed on-demand. &#39;let&#39; is more important as an API contract; you&#39;re guaranteeing to the user that an API won&#39;t produce different values if called on the same object at different times.<br></p><p>-Joe<br></p><p>&gt; <br>&gt; The problem really is that the compiler can only do limited analysis about whether a computer property is used a lot, and in most cases it doesn’t care (it only really cares whether something is unused, as it can try to optimise it away), to make a good decision it would need to run the program with a realistic test-case an analysis memory overhead and performance impact of each method.<br>&gt; <br>&gt; So yeah, I’m not really sure of the advantage of this, unless the intention is purely to restrict what can be used within your computed property’s implementation, but I don’t think the compiler can realistically do much in the way of optimising stuff away as precomputed values need to be stored somewhere, which could mean making your type bigger, which begs the question of why you specified a computed value in the first place.<br>&gt; <br>&gt; I guess I’m just confused as to what the problem being solved would really be.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>On May 11, 2016, at 11:31 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;    var combined:[Int64] { return a + b }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Each of these arrays is 512kb, so storing a fixed value for the combined property would require another megabyte of space per instance of Test, but if the combined property is only infrequently called on some instances of Test, then it would be a waste of memory to precompute it, especially if you’re dealing with thousands of instances, with only a fraction of them calling the computed property. If you want to accelerate usage of the computed property then that’s what lazy variables are for, as you can delay the expensive combination until you actually need it.<br>&gt; <br>&gt; Being constant doesn&#39;t need to imply &quot;precomputed&quot;. I would expect a computed &#39;let&#39; to still be computed on-demand. &#39;let&#39; is more important as an API contract; you&#39;re guaranteeing to the user that an API won&#39;t produce different values if called on the same object at different times.<br></p><p>Right.  “let” means “always has the same value”, a get-only property means “can not be set” (which is less restrictive).  Computed or not isn’t the issue here.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 11, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 11 May 2016, at 21:04, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On May 11, 2016, at 11:31 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;   var combined:[Int64] { return a + b }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Each of these arrays is 512kb, so storing a fixed value for the combined property would require another megabyte of space per instance of Test, but if the combined property is only infrequently called on some instances of Test, then it would be a waste of memory to precompute it, especially if you’re dealing with thousands of instances, with only a fraction of them calling the computed property. If you want to accelerate usage of the computed property then that’s what lazy variables are for, as you can delay the expensive combination until you actually need it.<br>&gt;&gt; <br>&gt;&gt; Being constant doesn&#39;t need to imply &quot;precomputed&quot;. I would expect a computed &#39;let&#39; to still be computed on-demand. &#39;let&#39; is more important as an API contract; you&#39;re guaranteeing to the user that an API won&#39;t produce different values if called on the same object at different times.<br>&gt; <br>&gt; Right.  “let” means “always has the same value”, a get-only property means “can not be set” (which is less restrictive).  Computed or not isn’t the issue here.<br></p><p>Ah, thanks both of you, I misunderstood then.<br></p><p>Hmm, in that case though, other than the simple case given in the original message, it seems like this might be non-trivial to check, as you’d need to trace every method that could be used within the computed property to ensure that no vars are ever accessed.<br></p><p>I proposed a while ago the idea of having the compiler determine whether a method is mutating automatically, as this could do various useful things like issue a warning if a mutating method that doesn’t change anything and similar cases, but it was dismissed at the time due to the complexity of adding such checking. This seems like it might be similar in principle; it seems very reasonable in a self-contained method that doesn’t rely on any others, but the rest of the time it’s hard to check.<br></p><p>I suppose it could be done for these kinds of self-contained computed properties initially though?<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[proposal] Allow &quot;let&quot; for computed properties which only reference immutable data</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 12, 2016 at 01:00:00am</p></header><div class="content"><p>I believe the reason behind this comes down to the fact that computed values generally won&#39;t be used in this way - thus the &quot;computed&quot;.<br></p><p>var itself isn&#39;t a promise that a value is mutable, so much as &#39;let&#39; is a promise of immutability. If we allowed this, then the compiler must check that each element of the return value is static and will not change, and in that case, why would you not just store the computer value in a true let to begin with, to avoid doing the work over again on each access?<br></p><p>It seems a somewhat rare and complicated case for the compiler, for little if any benefit.<br></p><p>-Rod<br></p><p>&gt; On 11 May 2016, at 11:25 PM, Alexander Momchilov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I came an interesting SO question which pointed out a strange quirk: a computed property must always use the &quot;var&quot; keyword, even if it&#39;s read-only, and only referencing other immutable data.<br>&gt; <br>&gt; class Test {<br>&gt;   let hello = &quot;hello&quot;<br>&gt;   let world = &quot;world&quot;<br>&gt;   var phrase: String { //why must this be &#39;var&#39;?<br>&gt;      return self.hello + self.world<br>&gt;   }<br>&gt; }<br>&gt; It would be more appropriate for such a read-only, immutable property, to use the &quot;let&quot; syntax, so that its immutability is correctly expressed.<br>&gt; <br>&gt; Thoughts?<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/b9f37bd6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
