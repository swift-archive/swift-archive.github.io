<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 04:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 2:52 PM Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 22 2016, Tony Allevato &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; I like a lot of this, but the changes to Equatable are where I get stuck.<br>&gt;&gt; &gt; What are the scenarios where areSame is useful *outside* the context of<br>&gt;&gt; the<br>&gt;&gt; &gt; proposed new Comparable interface?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I ask because changing the requirement for Equatable to areSame instead<br>&gt;&gt; of<br>&gt;&gt; &gt; == seems like a backwards change to me. There are plenty of unorderable<br>&gt;&gt; &gt; types where == is the obvious thing you want to implement, and this makes<br>&gt;&gt; &gt; it less obvious. It also adds a named method to a protocol to serve the<br>&gt;&gt; &gt; purpose of an operator, which I&#39;ve been fighting hard against in SE-0091<br>&gt;&gt; &gt; (even though you keep the global one and delegate to it).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; There are two concepts at play here: comparability and orderability.<br>&gt;&gt; 99.99%<br>&gt;&gt; &gt; of the time, they are identical.<br>&gt;&gt;<br>&gt;&gt; The concepts are “domain-specific semantics” vs “semantics that is<br>&gt;&gt; useful in generic contexts.”  Yes, they are usually identical.<br>&gt;&gt;<br>&gt;&gt; &gt; Your proposal mentions one place where they&#39;re not: IEEE floating<br>&gt;&gt; &gt; point numbers, because there exists an element in that space, NaN,<br>&gt;&gt; &gt; that doesn&#39;t satisfy an equivalence relation at all.<br>&gt;&gt;<br>&gt;&gt; It&#39;s not limited to NaN.  The +0/-0 distinction can be tricky as well.<br>&gt;&gt;<br>&gt;&gt; &gt; But it&#39;s still reasonable to want a stable ordering with those<br>&gt;&gt; &gt; included.<br>&gt;&gt;<br>&gt;&gt; It&#39;s also reasonable to want to search for those in a collection or use<br>&gt;&gt; them as hash keys.  I&#39;m pointing this out because it goes to the<br>&gt;&gt; definition of equality, which sorting in general does not.<br>&gt;&gt;<br>&gt;&gt; &gt; In the proposal as it&#39;s written right now, the individual inequality<br>&gt;&gt; &gt; operators are implemented in terms of &lt;=&gt;. That won&#39;t work for<br>&gt;&gt; &gt; FloatingPoint, because (NaN &lt; x) and (NaN &gt;= x) should both be false but<br>&gt;&gt; &gt; the default implementations provided would make the latter true. So<br>&gt;&gt; &gt; FloatingPoint would still have to provide its own implementations of *all<br>&gt;&gt; &gt; of the (in)equality operators*, not just ==, in order to have the correct<br>&gt;&gt; &gt; definition w.r.t. to IEEE 754. I didn&#39;t see that called out anywhere in<br>&gt;&gt; the<br>&gt;&gt; &gt; write-up.<br>&gt;&gt;<br>&gt;&gt; That&#39;s my error, actually. I wasn&#39;t thinking straight when I proposed a<br>&gt;&gt; change to the proposal that I claimed dropped the need for the other<br>&gt;&gt; operators.<br>&gt;&gt;<br>&gt;&gt; &gt; That being said, don&#39;t get me wrong—there&#39;s still a lot about this<br>&gt;&gt; proposal<br>&gt;&gt; &gt; that I like :)  Here&#39;s what I&#39;m thinking (which is mostly what you have<br>&gt;&gt; &gt; written, with some tweaks):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; 1) Don&#39;t change Equatable. I don&#39;t see a need to distinguish between<br>&gt;&gt; &gt; equivalence and equality on its own (if there is one, please let me<br>&gt;&gt; &gt; know!).<br>&gt;&gt;<br>&gt;&gt; There is, because for algorithms that require Equatable to have any kind<br>&gt;&gt; of meaningful semantics the equivalence relation requirement must be<br>&gt;&gt; fulfilled, and prominent types exist whose `==` operator is not an<br>&gt;&gt; equivalence relation.<br>&gt;&gt;<br>&gt;<br>&gt; Thanks for the detailed reply, Dave—this and some of your earlier replies<br>&gt; to this thread have helped me understand the use cases for this<br>&gt; distinction. So the argument is that something like this:<br>&gt;<br>&gt;     [ 1.0, -2.0, Double.NaN, 4.0 ].contains(Double.NaN)<br>&gt;<br>&gt; should return true because the argument is in the same equivalence class as<br>&gt; the element, even though NaN == NaN currently returns false? <br></p><p>Yes... but much more than that, too.<br></p><p>You should be *allowed* to use algorithms like `contains` on arrays of<br>`Double` with predictable results. Today, `Double` “conforms” to<br>`Equatable` but `==` has the wrong semantics.  So, `Double` lies to the<br>rest of the library, and therefore, technically, any uses of Double with<br>those algorithms has unspecified behavior.  <br></p><p>We can fudge around it a bit and document that NaN isn&#39;t “in the domain<br>of `==`,” similar to the way `0 as Int` isn&#39;t in the domain of<br>divisors. That effectively means that you&#39;re allowed to use `contains`<br>on an array of `Double`, with predictable results, so long as it<br>contains no NaNs... and otherwise, unspecified behavior.  But IMO that&#39;s<br>rather awful.<br></p><p>&gt; That seems totally reasonable, and I think it would be very helpful<br>&gt; for the proposal to specifically call out some of these<br>&gt; scenarios—right now it focuses mostly on ordering, which led to my<br>&gt; confusion.<br>&gt;<br>&gt; To take this further, let&#39;s say I have a data structure where the elements<br>&gt; are a type with multiple fields, and the ordering is determined by a single<br>&gt; one of those fields (the &quot;key&quot;). <br></p><p>If the ordering is a total ordering over keys, this is a strict weak<br>ordering over elements, where all elements with the same key fall into<br>the same equivalence class.  If you consider the other fields to be<br>inessential to the value of your elements (c.f. Array&#39;s capacity), you<br>can call it a total ordering over your elements.<br></p><p>&gt; Would a reasonable definition of equivalence in this model be one<br>&gt; where a is equivalent to b if a.key == b.key, regardless of the values<br>&gt; of the other fields, and equality is implemented by comparing all the<br>&gt; fields? <br></p><p>The proposal as written specifies that `a &lt;=&gt; b` is a total ordering and<br>it is consistent with `areSame(a, b)`.  That means that the definition of<br>`areSame` that only compares keys would be allowed iff you consider the<br>other fields to be inessential to the value of your elements.<br></p><p>Equality via `==` is allowed to have whatever domain-specific semantics<br>you like. Best practice would be for `==` to match `areSame`<br>exactly. Second-best practice would be for it to not match but still be<br>an equivalence relation.  Unfortunately floats follow “worst practice”<br>;-)<br></p><p>&gt; This is similar to how C++ STL&#39;s definition of equivalence for ordered<br>&gt; collections falls out of the expression !(a &lt; b) &amp;&amp; !(b &lt; a), since<br>&gt; you could conceivably implement &lt; and == with the same distinctions<br>&gt; there.<br>&gt;<br>&gt; I would be completely supportive of using `===` for this equivalence<br>&gt; instead of areSame, based on your argument about identity. Would we need an<br>&gt; escape hatch for people who absolutely need to know whether two instances<br>&gt; occupy the same address? <br></p><p>`ObjectIdentifier(a) == ObjectIdentifier(b)` already works.<br></p><p>&gt; If I had to choose equivalence vs. same-address as the one to make<br>&gt; more verbose, same-address seems like the obvious choice to me.<br>&gt;<br>&gt;&gt; &gt; As it stands today, I think the proposal &quot;leaks&quot; ordering concepts into<br>&gt;&gt; &gt; Equatable when it shouldn&#39;t.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t see any evidence for that, and I don&#39;t even believe you&#39;ve said<br>&gt;&gt; anything here to support that point of view.<br>&gt;&gt;<br>&gt;&gt; &gt; 2) Comparable defines &lt;=&gt;, as proposed, but *also* defines &lt;, &gt;, &lt;=, &gt;=.<br>&gt;&gt; A<br>&gt;&gt; &gt; protocol extension provides defaults for &lt;, &gt;, &lt;=, &gt;=, ==, and !=<br>&gt;&gt; &gt; implemented in terms of &lt;=&gt;. This lets most implementors of Comparable<br>&gt;&gt; &gt; implement &lt;=&gt; and get everything else for free, but it also lets types<br>&gt;&gt; &gt; replace individual operators with customized implementations (see #4<br>&gt;&gt; below)<br>&gt;&gt; &gt; easily *within* the type (SE-0091).<br>&gt;&gt;<br>&gt;&gt; Check<br>&gt;&gt;<br>&gt;&gt; &gt; 3) Comparable should be documented to imply that the default behavior is<br>&gt;&gt; to<br>&gt;&gt; &gt; link the behavior of &lt;=&gt; to the individual comparisons, but that it can<br>&gt;&gt; be<br>&gt;&gt; &gt; changed, meaning that only &lt;=&gt; must define a total ordering and the<br>&gt;&gt; &gt; individual comparison operators need not.<br>&gt;&gt;<br>&gt;&gt; Yes, the doc comments are missing from the proposal.<br>&gt;&gt;<br>&gt;&gt; &gt; 4) The very few types, like FloatingPoint, that need to provide<br>&gt;&gt; &gt; domain-specific behavior to do the obvious/intended thing for users can<br>&gt;&gt; and<br>&gt;&gt; &gt; should override &lt;, &gt;, &lt;=, &gt;=, ==, and !=. This should be called out<br>&gt;&gt; &gt; explicitly, and it would *not* affect ordering.<br>&gt;&gt;<br>&gt;&gt; Depends what you mean by “affect ordering.”  Clearly if you sort Floats<br>&gt;&gt; using &lt; explicitly, it will have an effect.<br>&gt;&gt;<br>&gt;&gt; &gt; I think it&#39;s entirely reasonable to have (NaN == NaN) return false and<br>&gt;&gt; &gt; (NaN != NaN) return true but (NaN &lt;=&gt; NaN) return .same without<br>&gt;&gt; &gt; introducing another areSame concept, because the former is demanded by<br>&gt;&gt; &gt; IEEE 754.  5) Algorithms that rely on a total order, like sorts, must<br>&gt;&gt; &gt; be implemented in terms of &lt;=&gt;, not in terms of the individual<br>&gt;&gt; &gt; operators, because of the possibility that the definitions can be<br>&gt;&gt; &gt; severed above.<br>&gt;&gt;<br>&gt;&gt; But you&#39;re forgetting algorithms that require an equivalence relation,<br>&gt;&gt; which is basically everything that&#39;s constrained to Equatable.<br>&gt;&gt;<br>&gt;&gt; &gt; As mentioned below, the one thing that a three-way comparison loses is<br>&gt;&gt; the<br>&gt;&gt; &gt; easy ability to pass &gt; instead of &lt; to reverse the ordering, but it&#39;s<br>&gt;&gt; &gt; trivial to write a function that does this and I think it should be<br>&gt;&gt; &gt; included as part of the proposal. Something like this (may be typos, I&#39;m<br>&gt;&gt; &gt; writing it in Gmail):<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; public func reverse&lt;C: Comparable&gt;(ordering: (C, C) -&gt; Ordering) -&gt; (C,<br>&gt;&gt; C)<br>&gt;&gt; &gt; -&gt; Ordering {<br>&gt;&gt; &gt;   return { lhs, rhs in<br>&gt;&gt; &gt;     switch ordering(lhs, rhs) {<br>&gt;&gt; &gt;     case .ascending: return .descending<br>&gt;&gt; &gt;     case .descending: return .ascending<br>&gt;&gt; &gt;     case .same: return .same<br>&gt;&gt; &gt;   }<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; (Comedy alternative: Add a second operator, &gt;=&lt;. But that might be<br>&gt;&gt; pushing<br>&gt;&gt; &gt; it.)<br>&gt;&gt;<br>&gt;&gt; Agreed, we should do something about this use case.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
