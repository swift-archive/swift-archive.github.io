<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>February 25, 2016 at 11:00:00am</p></header><div class="content"><p>I wanted to float a proposal and see what the community thinks. If there is interest I’m happy to submit an official proposal. This comes from real problems we’re encountering with a large mixed codebase. Every time our nice clean Swift design hits an Objective-C boundary we end up having to go back and dumb-down the Swift API significantly because manually converting at every touch point is just too painful.<br></p><p><br># Introduction<br></p><p>Provide an ObjectiveCBridgeable protocol that allows a type to control how it is represented in Objective-C by converting into and back from an entirely separate type. This frees an API designer to create truly native Swift types like structs, generics, enums with associated values, protocols with associated types, etc without having to compromise to allow interop with Objective-C.<br></p><p><br></p><p># Motivation<br></p><p>When working in a mixed codebase, we find ourselves unable to use generics, enums with associated values, structs, and various other Swift features because there are chunks of Objective-C code that we can’t stop and rewrite. This leads to a catch-22 situation where your new APIs (or refactored APIs) have a compromised design,  which has a cascading effect on new Swift code that uses the compromised API. When the last vestiges of Objective-C have been swept away you’re left with a mountain of Swift code that essentially looks like a direct port of Objective-C code and doesn’t take advantage of any Swift-ish features. <br></p><p><br></p><p># Proposed Solution<br></p><p>Today, you can adopt the private protocol _ObjectiveCBridgeable and if your parameters or return types are inside an Array, Swift will automatically call the appropriate functions to let you control the way the type bridges. This allows you to define a completely different Objective-C compatible API for the type and round-trip it appropriately.<br></p><p>My proposal is simple: expose the existing protocol as a public protocol ObjectiveCBridgeable: _ObjectiveCBridgeable, and have the compiler generate the appropriate Objective-C bridging outside of the existing Array support.<br></p><p><br></p><p># Detailed Design<br></p><p>1. Expose the existing protocol as a public protocol <br>2. When generating an Objective-C interface for a type that is itself bridgeable to Objective-C:<br>  a. When a function contains parameters or return types that are @nonobjc but those types adopt ObjectiveCBridgeable:<br>    i) Create @objc overloads that call the Swift functions but substitute the corresponding ObjectiveCType.<br>    ii) The overloads will automatically call the appropriate protocol functions to perform the conversion.<br>  b. If any @nonobjc types do not adopt ObjectiveCBridgeable, the function itself is not exposed to Objective-C (current behavior).<br>3. It is up to the API designer to decide if they want to allow construction of wholly new values from Objective-C and how to handle convertibility back to the Swift type in that case<br></p><p>An example enum that adopts the protocol and bridges by converting itself into an object representation.<br>Note: The ways you can represent the type in Objective-C are endless; I’d prefer not to bikeshed that particular bit :)<br></p><p>enum Fizzer: ObjectiveCBridgeable {<br>    case Case1(String)<br>    case Case2(Int, Int)<br></p><p>    static func getObjectiveCType() -&gt; Any.Type {<br>        return ObjCFizzer.self<br>    }<br>    static func isBridgedToObjectiveC() -&gt; Bool {<br>        return true<br>    }<br>    func bridgeToObjectiveC() -&gt; ObjCFizzer {<br>        let bridge = ObjCFizzer()<br>        switch self {<br>        case let .Case1(x):<br>            bridge._case1 = x<br>        case let .Case2(x, y):<br>            bridge._case2 = (x, y)<br>        }<br>        return bridge<br>    }<br>    static func conditionallyBridgeFromObjectiveC(source: ObjCFizzer, inout result: Fizzer?) -&gt; Bool {<br>        _forceBridgeFromObjectiveC(source, result: &amp;result)<br>        return true<br>    }<br>    static func forceBridgeFromObjectiveC(source: ObjCFizzer, inout result: Fizzer?) {<br>        if let stringValue = source._case1 {<br>            result = Fizzer.Case1(stringValue)<br>        } else if let tupleValue = source._case2 {<br>            result = Fizzer.Case2(tupleValue)<br>        } else {<br>            fatalError(&quot;Unable to bridge&quot;)<br>        }<br>    }<br>}<br></p><p>class ObjCFizzer: NSObject {<br>    private var _case1: String?<br>    private var _case2: (Int, Int)?<br>}<br></p><p><br></p><p># Impact on existing code<br></p><p>No breaking changes. Adoption would be opt-in.<br></p><p><br></p><p># Alternatives considered<br></p><p>The only alternative, as stated above, is not to adopt Swift features that cannot be expressed in Objective-C.<br></p><p><br># TBD / Questions:<br></p><p>Should the shape of the protocol change? It may not make sense for the public protocol to support both conditional and force bridging; maybe we only provide a throwing equivalent of force bridge and let the implementer throw if the conversion is invalid? <br></p><p><br></p><p><br>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Yes! I’ve had the privilege of being able to write Swift nearly ObjC-free, so I don’t feel the pain personally very often. But I’ve played with _ObjectiveCBridgeable in the past and thought it’s an awesome little hidden gem. Aside from other things, being able to use value types in Swift without compromising ObjC bridgeability is very useful, for library code in particular.<br></p><p>— Radek<br></p><p>&gt; On 25 Feb 2016, at 20:02, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to float a proposal and see what the community thinks. If there is interest I’m happy to submit an official proposal. This comes from real problems we’re encountering with a large mixed codebase. Every time our nice clean Swift design hits an Objective-C boundary we end up having to go back and dumb-down the Swift API significantly because manually converting at every touch point is just too painful.<br>&gt; <br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; Provide an ObjectiveCBridgeable protocol that allows a type to control how it is represented in Objective-C by converting into and back from an entirely separate type. This frees an API designer to create truly native Swift types like structs, generics, enums with associated values, protocols with associated types, etc without having to compromise to allow interop with Objective-C.<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Motivation<br>&gt; <br>&gt; When working in a mixed codebase, we find ourselves unable to use generics, enums with associated values, structs, and various other Swift features because there are chunks of Objective-C code that we can’t stop and rewrite. This leads to a catch-22 situation where your new APIs (or refactored APIs) have a compromised design,  which has a cascading effect on new Swift code that uses the compromised API. When the last vestiges of Objective-C have been swept away you’re left with a mountain of Swift code that essentially looks like a direct port of Objective-C code and doesn’t take advantage of any Swift-ish features. <br>&gt; <br>&gt; <br>&gt; <br>&gt; # Proposed Solution<br>&gt; <br>&gt; Today, you can adopt the private protocol _ObjectiveCBridgeable and if your parameters or return types are inside an Array, Swift will automatically call the appropriate functions to let you control the way the type bridges. This allows you to define a completely different Objective-C compatible API for the type and round-trip it appropriately.<br>&gt; <br>&gt; My proposal is simple: expose the existing protocol as a public protocol ObjectiveCBridgeable: _ObjectiveCBridgeable, and have the compiler generate the appropriate Objective-C bridging outside of the existing Array support.<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Detailed Design<br>&gt; <br>&gt; 1. Expose the existing protocol as a public protocol <br>&gt; 2. When generating an Objective-C interface for a type that is itself bridgeable to Objective-C:<br>&gt;  a. When a function contains parameters or return types that are @nonobjc but those types adopt ObjectiveCBridgeable:<br>&gt;    i) Create @objc overloads that call the Swift functions but substitute the corresponding ObjectiveCType.<br>&gt;    ii) The overloads will automatically call the appropriate protocol functions to perform the conversion.<br>&gt;  b. If any @nonobjc types do not adopt ObjectiveCBridgeable, the function itself is not exposed to Objective-C (current behavior).<br>&gt; 3. It is up to the API designer to decide if they want to allow construction of wholly new values from Objective-C and how to handle convertibility back to the Swift type in that case<br>&gt; <br>&gt; An example enum that adopts the protocol and bridges by converting itself into an object representation.<br>&gt; Note: The ways you can represent the type in Objective-C are endless; I’d prefer not to bikeshed that particular bit :)<br>&gt; <br>&gt; enum Fizzer: ObjectiveCBridgeable {<br>&gt;    case Case1(String)<br>&gt;    case Case2(Int, Int)<br>&gt; <br>&gt;    static func getObjectiveCType() -&gt; Any.Type {<br>&gt;        return ObjCFizzer.self<br>&gt;    }<br>&gt;    static func isBridgedToObjectiveC() -&gt; Bool {<br>&gt;        return true<br>&gt;    }<br>&gt;    func bridgeToObjectiveC() -&gt; ObjCFizzer {<br>&gt;        let bridge = ObjCFizzer()<br>&gt;        switch self {<br>&gt;        case let .Case1(x):<br>&gt;            bridge._case1 = x<br>&gt;        case let .Case2(x, y):<br>&gt;            bridge._case2 = (x, y)<br>&gt;        }<br>&gt;        return bridge<br>&gt;    }<br>&gt;    static func conditionallyBridgeFromObjectiveC(source: ObjCFizzer, inout result: Fizzer?) -&gt; Bool {<br>&gt;        _forceBridgeFromObjectiveC(source, result: &amp;result)<br>&gt;        return true<br>&gt;    }<br>&gt;    static func forceBridgeFromObjectiveC(source: ObjCFizzer, inout result: Fizzer?) {<br>&gt;        if let stringValue = source._case1 {<br>&gt;            result = Fizzer.Case1(stringValue)<br>&gt;        } else if let tupleValue = source._case2 {<br>&gt;            result = Fizzer.Case2(tupleValue)<br>&gt;        } else {<br>&gt;            fatalError(&quot;Unable to bridge&quot;)<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ObjCFizzer: NSObject {<br>&gt;    private var _case1: String?<br>&gt;    private var _case2: (Int, Int)?<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Impact on existing code<br>&gt; <br>&gt; No breaking changes. Adoption would be opt-in.<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Alternatives considered<br>&gt; <br>&gt; The only alternative, as stated above, is not to adopt Swift features that cannot be expressed in Objective-C.<br>&gt; <br>&gt; <br>&gt; # TBD / Questions:<br>&gt; <br>&gt; Should the shape of the protocol change? It may not make sense for the public protocol to support both conditional and force bridging; maybe we only provide a throwing equivalent of force bridge and let the implementer throw if the conversion is invalid? <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March  7, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Russ,<br></p><p>Sorry for the long delay in replying. This is a topic of interest to me.<br></p><p>&gt; On Feb 25, 2016, at 11:02 AM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to float a proposal and see what the community thinks. If there is interest I’m happy to submit an official proposal. This comes from real problems we’re encountering with a large mixed codebase. Every time our nice clean Swift design hits an Objective-C boundary we end up having to go back and dumb-down the Swift API significantly because manually converting at every touch point is just too painful.<br>&gt; <br>&gt; <br>&gt; # Introduction<br>&gt; <br>&gt; Provide an ObjectiveCBridgeable protocol that allows a type to control how it is represented in Objective-C by converting into and back from an entirely separate type. This frees an API designer to create truly native Swift types like structs, generics, enums with associated values, protocols with associated types, etc without having to compromise to allow interop with Objective-C.<br></p><p>There may be some limitations that are inherent to the bridging process, so it’s not clear that we can achieve everything you mention above. As an example, check out my proposal to bridge Objective-C’s lightweight generics into Swift:<br></p><p>	http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886<br></p><p>The content of that proposal isn’t as important as the scope of implementation effort to bridge between two similar-looking but very-differently-implemented features across the languages. It’s likely that other features you’ve mentioned above have similar complexities. That said, I do think it’s possible to extend the bridging mechanism to help alleviate some of the issues you’re describing.<br></p><p>&gt; # Motivation<br>&gt; <br>&gt; When working in a mixed codebase, we find ourselves unable to use generics, enums with associated values, structs, and various other Swift features because there are chunks of Objective-C code that we can’t stop and rewrite. This leads to a catch-22 situation where your new APIs (or refactored APIs) have a compromised design,  which has a cascading effect on new Swift code that uses the compromised API. When the last vestiges of Objective-C have been swept away you’re left with a mountain of Swift code that essentially looks like a direct port of Objective-C code and doesn’t take advantage of any Swift-ish features. <br>&gt; <br>&gt; <br>&gt; <br>&gt; # Proposed Solution<br>&gt; <br>&gt; Today, you can adopt the private protocol _ObjectiveCBridgeable and if your parameters or return types are inside an Array, Swift will automatically call the appropriate functions to let you control the way the type bridges. This allows you to define a completely different Objective-C compatible API for the type and round-trip it appropriately.<br></p><p>The other bridged collection types (Set/Dictionary) also work this way as well.<br></p><p>&gt; My proposal is simple: expose the existing protocol as a public protocol ObjectiveCBridgeable: _ObjectiveCBridgeable, and have the compiler generate the appropriate Objective-C bridging outside of the existing Array support.<br>&gt; <br>&gt; <br>&gt; <br>&gt; # Detailed Design<br>&gt; <br>&gt; 1. Expose the existing protocol as a public protocol <br>&gt; 2. When generating an Objective-C interface for a type that is itself bridgeable to Objective-C:<br>&gt;  a. When a function contains parameters or return types that are @nonobjc but those types adopt ObjectiveCBridgeable:<br>&gt;    i) Create @objc overloads that call the Swift functions but substitute the corresponding ObjectiveCType.<br>&gt;    ii) The overloads will automatically call the appropriate protocol functions to perform the conversion.<br></p><p>This is *roughly* what the compiler does today for the various bridged types (Array/Dictionary/Set/String): the function with the Swift calling convention uses the Swift-native types, and the compiler emits an @objc thunk that translates the Objective-C-visible types into the Swift-native types and back.<br></p><p><br>&gt;  b. If any @nonobjc types do not adopt ObjectiveCBridgeable, the function itself is not exposed to Objective-C (current behavior).<br></p><p>Right.<br></p><p>&gt; 3. It is up to the API designer to decide if they want to allow construction of wholly new values from Objective-C and how to handle convertibility back to the Swift type in that case<br></p><p>I’m not sure what you mean by this?<br></p><p>&gt; An example enum that adopts the protocol and bridges by converting itself into an object representation.<br>&gt; Note: The ways you can represent the type in Objective-C are endless; I’d prefer not to bikeshed that particular bit :)<br>&gt; <br>&gt; enum Fizzer: ObjectiveCBridgeable {<br>&gt;    case Case1(String)<br>&gt;    case Case2(Int, Int)<br>&gt; <br>&gt;    static func getObjectiveCType() -&gt; Any.Type {<br>&gt;        return ObjCFizzer.self<br>&gt;    }<br></p><p>FWIW, this method is an anachronism. You can leave it out, because the runtime can now recover this information directly. However, I do suggest that you show<br></p><p>	typealias ObjectiveCType = ObjCFizzer<br></p><p>in your example, so its clear what the mapping is.<br></p><p>&gt;    static func isBridgedToObjectiveC() -&gt; Bool {<br>&gt;        return true<br>&gt;    }<br></p><p>&gt;    func bridgeToObjectiveC() -&gt; ObjCFizzer {<br>&gt;        let bridge = ObjCFizzer()<br>&gt;        switch self {<br>&gt;        case let .Case1(x):<br>&gt;            bridge._case1 = x<br>&gt;        case let .Case2(x, y):<br>&gt;            bridge._case2 = (x, y)<br>&gt;        }<br>&gt;        return bridge<br>&gt;    }<br></p><p>Okay.<br></p><p>&gt;    static func conditionallyBridgeFromObjectiveC(source: ObjCFizzer, inout result: Fizzer?) -&gt; Bool {<br>&gt;        _forceBridgeFromObjectiveC(source, result: &amp;result)<br>&gt;        return true<br>&gt;    }<br></p><p>The above isn’t a correct implementation, because it will fatalError return than returning “nil” if the source cannot be bridged.<br></p><p>&gt;    static func forceBridgeFromObjectiveC(source: ObjCFizzer, inout result: Fizzer?) {<br>&gt;        if let stringValue = source._case1 {<br>&gt;            result = Fizzer.Case1(stringValue)<br>&gt;        } else if let tupleValue = source._case2 {<br>&gt;            result = Fizzer.Case2(tupleValue)<br>&gt;        } else {<br>&gt;            fatalError(&quot;Unable to bridge&quot;)<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; class ObjCFizzer: NSObject {<br>&gt;    private var _case1: String?<br>&gt;    private var _case2: (Int, Int)?<br>&gt; }<br></p><p>I had expected ObjCFizzer to be defined in Objective-C. If it can also be defined in Swift, that’s a nontrivial expansion of what bridging currently does.<br></p><p>Along these lines, I think we’ll need a Clang-side attribute on the Objective-C type to specify what Swift type it bridges to. That’s important for Swift’s Clang importer, because when it sees the Clang type it needs to know whether it’s importing that type directly or bridging to a different type.<br></p><p><br>&gt; # TBD / Questions:<br>&gt; <br>&gt; Should the shape of the protocol change?<br></p><p>I think the protocol is still basically the right interface, except that getObjectiveCType is no longer necessary. How Objective-C-centric should this protocol be? Should it be possible for (e.g.) the NSInteger-to-Int mapping to be expressible this way? Can a simple C struct be bridged?<br></p><p>&gt; It may not make sense for the public protocol to support both conditional and force bridging; maybe we only provide a throwing equivalent of force bridge and let the implementer throw if the conversion is invalid? <br></p><p>The distinction between forced and conditional bridging is fairly important for performance. Forced bridging is used for “as!” while conditional bridging is used for “as?”; when we know we’re in the former case, we can sometimes delay validation work.<br></p><p>From a proposal perspective, I think it’s important to show the ObjectiveCBridgeable protocol you’re proposing and say what each requirement does. You can grab them directly from the comments, of course, but I suspect that most people haven’t dug into bridging at all.<br></p><p>If it’s not obvious already, I think this is definitely worthy of a proposal.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 10:36 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; There may be some limitations that are inherent to the bridging process, so it’s not clear that we can achieve everything you mention above. As an example, check out my proposal to bridge Objective-C’s lightweight generics into Swift:<br>&gt; <br>&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886&gt;<br>&gt; <br>&gt; The content of that proposal isn’t as important as the scope of implementation effort to bridge between two similar-looking but very-differently-implemented features across the languages. It’s likely that other features you’ve mentioned above have similar complexities. That said, I do think it’s possible to extend the bridging mechanism to help alleviate some of the issues you’re describing.<br></p><p>Well the idea is that real bridging is impossible in many cases, so let the Swift type define an arbitrarily different type to represent itself in the world of Objective-C. In some cases this may behave like an opaque value that Objective-C code can’t touch, merely pass around. In others (eg structs/enums) a simpler less type-safe class interface can be provided. Or perhaps enum cases with associated values can map to a class cluster. <br></p><p>The important part is that the implementer is completely free to design a native Swift API for a feature without actually having to maintain a separate API and test suite.<br></p><p><br>&gt;&gt; 3. It is up to the API designer to decide if they want to allow construction of wholly new values from Objective-C and how to handle convertibility back to the Swift type in that case<br>&gt; <br>&gt; I’m not sure what you mean by this?<br></p><p>If I define a class (ObjCFizzer) I can choose to keep the initializer private meaning no one can create an instance from Objective-C. I only wanted to mention that explicitly because I can imagine a library author’s objections. In reality this rule just falls out naturally from private/internal visibility anyway.<br></p><p><br>&gt; FWIW, this method is an anachronism. You can leave it out, because the runtime can now recover this information directly. However, I do suggest that you show<br>&gt; <br>&gt; 	typealias ObjectiveCType = ObjCFizzer<br>&gt; <br>&gt; in your example, so its clear what the mapping is.<br></p><p>Ah thanks, I’ll update it.<br></p><p><br>&gt; The above isn’t a correct implementation, because it will fatalError return than returning “nil” if the source cannot be bridged.<br></p><p>You’re correct, I meant to do it the other way around. I’ll fix it.<br></p><p><br>&gt; <br>&gt; I had expected ObjCFizzer to be defined in Objective-C. If it can also be defined in Swift, that’s a nontrivial expansion of what bridging currently does.<br>&gt; <br>&gt; Along these lines, I think we’ll need a Clang-side attribute on the Objective-C type to specify what Swift type it bridges to. That’s important for Swift’s Clang importer, because when it sees the Clang type it needs to know whether it’s importing that type directly or bridging to a different type.<br></p><p>First, my assumption is that a type can’t be recursively bridged (the ObjectiveCType cannot itself be bridgeable - the compiler could emit a diagnostic for that).<br></p><p>I guess my second assumption is that the thunk generation happens after the Swift compiler has discovered all the types in the module so whether the ObjectiveCType is defined in Swift or Objective-C doesn’t matter. This may not be true. To be honest I hadn’t considered defining the bridge types in the other direction (an Objective-C API that wants to present a nicer Swift API) but I can see how that would be very useful.<br></p><p>One of the benefits of being able to define the bridge type in Swift is that the bridge type can be a simple @objc type that contains stored properties any arbitrary Swift type. If defining the type in Swift has nontrivial implementation issues we can require the bridged type be defined in Objective-C but it would be nice if we didn’t have to do that.<br></p><p><br>Good point on the Clang attribute.<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; # TBD / Questions:<br>&gt;&gt; <br>&gt;&gt; Should the shape of the protocol change?<br>&gt; <br>&gt; I think the protocol is still basically the right interface, except that getObjectiveCType is no longer necessary. How Objective-C-centric should this protocol be? Should it be possible for (e.g.) the NSInteger-to-Int mapping to be expressible this way? Can a simple C struct be bridged?<br>&gt; <br></p><p>In the case of C structs or NS_ENUM, Swift extensions already provide much of the value IMHO. I haven’t actually looked at how the NSInteger typedef gets mapped to Int; do you see value there?<br></p><p>For me the primary motivation is when I’m doing the actual implementation of a feature in Swift, then providing a less type-safe non-generics interface to Objective-C. I’m also looking to a future where we can export free functions to C. Bi-directional exchange with C++ (assuming the committee adopts something like “extern abi” someday) is an interesting case but far out of scope.<br></p><p><br>&gt; From a proposal perspective, I think it’s important to show the ObjectiveCBridgeable protocol you’re proposing and say what each requirement does. You can grab them directly from the comments, of course, but I suspect that most people haven’t dug into bridging at all.<br>&gt; <br>&gt; If it’s not obvious already, I think this is definitely worthy of a proposal.<br>&gt; <br>&gt; 	- Doug<br></p><p>I’ll write up some of these changes and open a PR.<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/4f935da0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m +1 on this. Like Radek, I have played with _ObjectiveCBridgeable in the past with my own types and I find it very useful, especially in library code.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>&gt; Wiadomość napisana przez Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; w dniu 08.03.2016, o godz. 07:29:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 7, 2016, at 10:36 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There may be some limitations that are inherent to the bridging process, so it’s not clear that we can achieve everything you mention above. As an example, check out my proposal to bridge Objective-C’s lightweight generics into Swift:<br>&gt;&gt; <br>&gt;&gt; 	http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/2886&gt;<br>&gt;&gt; <br>&gt;&gt; The content of that proposal isn’t as important as the scope of implementation effort to bridge between two similar-looking but very-differently-implemented features across the languages. It’s likely that other features you’ve mentioned above have similar complexities. That said, I do think it’s possible to extend the bridging mechanism to help alleviate some of the issues you’re describing.<br>&gt; <br>&gt; Well the idea is that real bridging is impossible in many cases, so let the Swift type define an arbitrarily different type to represent itself in the world of Objective-C. In some cases this may behave like an opaque value that Objective-C code can’t touch, merely pass around. In others (eg structs/enums) a simpler less type-safe class interface can be provided. Or perhaps enum cases with associated values can map to a class cluster. <br>&gt; <br>&gt; The important part is that the implementer is completely free to design a native Swift API for a feature without actually having to maintain a separate API and test suite.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; 3. It is up to the API designer to decide if they want to allow construction of wholly new values from Objective-C and how to handle convertibility back to the Swift type in that case<br>&gt;&gt; <br>&gt;&gt; I’m not sure what you mean by this?<br>&gt; <br>&gt; If I define a class (ObjCFizzer) I can choose to keep the initializer private meaning no one can create an instance from Objective-C. I only wanted to mention that explicitly because I can imagine a library author’s objections. In reality this rule just falls out naturally from private/internal visibility anyway.<br>&gt; <br>&gt; <br>&gt;&gt; FWIW, this method is an anachronism. You can leave it out, because the runtime can now recover this information directly. However, I do suggest that you show<br>&gt;&gt; <br>&gt;&gt; 	typealias ObjectiveCType = ObjCFizzer<br>&gt;&gt; <br>&gt;&gt; in your example, so its clear what the mapping is.<br>&gt; <br>&gt; Ah thanks, I’ll update it.<br>&gt; <br>&gt; <br>&gt;&gt; The above isn’t a correct implementation, because it will fatalError return than returning “nil” if the source cannot be bridged.<br>&gt; <br>&gt; You’re correct, I meant to do it the other way around. I’ll fix it.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I had expected ObjCFizzer to be defined in Objective-C. If it can also be defined in Swift, that’s a nontrivial expansion of what bridging currently does.<br>&gt;&gt; <br>&gt;&gt; Along these lines, I think we’ll need a Clang-side attribute on the Objective-C type to specify what Swift type it bridges to. That’s important for Swift’s Clang importer, because when it sees the Clang type it needs to know whether it’s importing that type directly or bridging to a different type.<br>&gt; <br>&gt; First, my assumption is that a type can’t be recursively bridged (the ObjectiveCType cannot itself be bridgeable - the compiler could emit a diagnostic for that).<br>&gt; <br>&gt; I guess my second assumption is that the thunk generation happens after the Swift compiler has discovered all the types in the module so whether the ObjectiveCType is defined in Swift or Objective-C doesn’t matter. This may not be true. To be honest I hadn’t considered defining the bridge types in the other direction (an Objective-C API that wants to present a nicer Swift API) but I can see how that would be very useful.<br>&gt; <br>&gt; One of the benefits of being able to define the bridge type in Swift is that the bridge type can be a simple @objc type that contains stored properties any arbitrary Swift type. If defining the type in Swift has nontrivial implementation issues we can require the bridged type be defined in Objective-C but it would be nice if we didn’t have to do that.<br>&gt; <br>&gt; <br>&gt; Good point on the Clang attribute.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; # TBD / Questions:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should the shape of the protocol change?<br>&gt;&gt; <br>&gt;&gt; I think the protocol is still basically the right interface, except that getObjectiveCType is no longer necessary. How Objective-C-centric should this protocol be? Should it be possible for (e.g.) the NSInteger-to-Int mapping to be expressible this way? Can a simple C struct be bridged?<br>&gt;&gt; <br>&gt; <br>&gt; In the case of C structs or NS_ENUM, Swift extensions already provide much of the value IMHO. I haven’t actually looked at how the NSInteger typedef gets mapped to Int; do you see value there?<br>&gt; <br>&gt; For me the primary motivation is when I’m doing the actual implementation of a feature in Swift, then providing a less type-safe non-generics interface to Objective-C. I’m also looking to a future where we can export free functions to C. Bi-directional exchange with C++ (assuming the committee adopts something like “extern abi” someday) is an interesting case but far out of scope.<br>&gt; <br>&gt; <br>&gt;&gt; From a proposal perspective, I think it’s important to show the ObjectiveCBridgeable protocol you’re proposing and say what each requirement does. You can grab them directly from the comments, of course, but I suspect that most people haven’t dug into bridging at all.<br>&gt;&gt; <br>&gt;&gt; If it’s not obvious already, I think this is definitely worthy of a proposal.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; I’ll write up some of these changes and open a PR.<br>&gt; <br>&gt; Russ<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/24b1afec/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March  9, 2016 at 12:00:00pm</p></header><div class="content"><p>An official proposal PR has been opened on this: https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br></p><p>It includes clarifications, a few changes, and some better examples.<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160309/f4bf5e1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d30e546d655d1c7ece0464791a9a90d5?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Adrian Kashivskyy</string> &lt;adrian.kashivskyy at me.com&gt;<p>March 17, 2016 at 08:00:00am</p></header><div class="content"><p>I have a couple of ideas regarding the API of ObjectiveCBridgeable. My general thought is to improve upon the existing _ObjectiveCBridgeable protocol, not just make it public. The main idea would be to make it more &quot;Swifty&quot; by:<br></p><p>1. Removing inout arguments which look like implementation artifacts and converting them into return values<br>2. Converting static functions to initializers<br>3. Removing isBridgedToObjectiveC() method since it doesn&#39;t introduce any useful information<br></p><p>Doug, I know that some API design decisions were made due to runtime performance convenience, therefore I&#39;d like your opinion on that before I go on with detailed design.<br></p><p><br>Pozdrawiam – Regards,<br>Adrian Kashivskyy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160317/f99fd09f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 21, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 9, 2016, at 12:26 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; An official proposal PR has been opened on this: https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt; <br>&gt; It includes clarifications, a few changes, and some better examples.<br></p><p>FWIW, I’ve implemented much of this proposal as a series of compiler cleanups. It introduces a few tweaks to the _ObjectiveCBridgeable protocol that were necessary to generalize (and de-special-case) the NSString/NSArray/NSDictionary/NSSet bridging, but it’s still considered an implementation detail. So, some comments on the proposal itself…<br></p><p><br>/// A type adopting `ObjectiveCBridgeable` will be exposed<br>/// to Objective-C as the type `ObjectiveCType`<br>public protocol ObjectiveCBridgeable: _ObjectiveCBridgeable {<br>    associatedtype ObjectiveCType : AnyObject<br>    associatedtype _ObjectiveCType = ObjectiveCType<br>I think we should just say that ObjectiveCBridgeable replaces _ObjectiveCBridgeable, and only have the first associated type. (You actually wanted a typealias anyway, I think).<br></p><p>    /// Returns `true` iff instances of `Self` can be converted to<br>    /// Objective-C.  Even if this method returns `true`, a given<br>    /// instance of `Self._ObjectiveCType` may, or may not, convert<br>    /// successfully to `Self`.<br>    ///<br>    /// A default implementation returns `true`.<br>    @warn_unused_result<br>    static func isBridgedToObjectiveC() -&gt; Bool<br>It’s probably worth saying why someone might override this method: usually, it’s because the Swift type is generic and it only makes sense to bridge for some type arguments. Granted, there is no way to communicate this information to the compiler, which is a bit of a hole in the design. For example, Array&lt;T&gt; only bridges to NSArray when T is itself representable in Objective-C. We really need conditional conformances to for this part of the feature to work properly.<br></p><p>    /// Try to construct a value of the Self type from<br>    /// an Objective-C object of the bridged class type.<br>    ///<br>    /// If the conversion fails this initializer returns `nil`.<br>    init?(bridgedFromObjectiveC: ObjectiveCType)<br>FWIW, implementing this required a new “unconditional” entry point used by the compiler:<br></p><p>  /// Bridge from an Objective-C object of the bridged class type to a<br>  /// value of the Self type.<br>  ///<br>  /// This bridging operation is used for unconditional bridging when<br>  /// interoperating with Objective-C code, either in the body of an<br>  /// Objective-C thunk or when calling Objective-C code, and may<br>  /// defer complete checking until later. For example, when bridging<br>  /// from `NSArray` to `Array&lt;Element&gt;`, we can defer the checking<br>  /// for the individual elements of the array.<br>  ///<br>  /// \param source The Objective-C object from which we are<br>  /// bridging. This optional value will only be `nil` in cases where<br>  /// an Objective-C method has returned a `nil` despite being marked<br>  /// as `_Nonnull`/`nonnull`. In most such cases, bridging will<br>  /// generally force the value immediately. However, this gives<br>  /// bridging the flexibility to substitute a default value to cope<br>  /// with historical decisions, e.g., an existing Objective-C method<br>  /// that returns `nil` to for &quot;empty result&quot; rather than (say) an<br>  /// empty array. In such cases, when `nil` does occur, the<br>  /// implementation of `Swift.Array`&#39;s conformance to<br>  /// `_ObjectiveCBridgeable` will produce an empty array rather than<br>  /// dynamically failing.<br>  static func _unconditionallyBridgeFromObjectiveC(source: _ObjectiveCType?)<br>      -&gt; Self<br></p><p>It can get a default implementation, and should be a non-failable initializer.<br></p><p>    static func _getObjectiveCType() -&gt; Any.Type {<br>        return ObjectiveCType.self<br>    }<br>This was an implementation hack; it’s gone now.<br></p><p>Expose the protocol ObjectiveCBridgeable<br>Any type adopting ObjectiveCBridgeable will gain conformance to _ObjectiveCBridgeable<br>As noted earlier, I think there should just be one protocol here, ObjectiveCBridgeable.<br></p><p>	4. The ObjectiveCType must be defined in Swift. If a -swift.h header is generated, it will include a SWIFT_BRIDGED()macro where the parameter indicates the Swift type with which the ObjectiveCType bridges. The macro will be applied to the ObjectiveCType and any subclasses.<br></p><p>This is unnecessarily restrictive, and eliminates the “make my Objective-C class bridge into a Swift value type” case that (for example) the compiler already does for String/Array/Dictionary/Set. I think there are two cases:<br></p><p>	(a) The ObjectiveCType is defined in Objective-C. It must be an Objective-C class with the attribute swift_bridge(“Bar”), where “Bar” is the name of the bridged Swift type.<br>	(b) The ObjectiveCType is defined in Swift, in which case it must be an @objc class. When emitting the generated header, the appropriate swift_bridge attribute will be added to the @interface declaration.<br></p><p><br></p><p>(This was #5) It is an error for bridging to be ambiguous.<br>A Swift type may bridge to an Objective-C base class, then provide different subclass instances at runtime but no other Swift type may bridge to that base class or any of its subclasses.<br>The compiler must emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType.<br>This is a tricky area. Currently, Int/Float/Double/Bool/CGFloat/UInt all have _ObjectiveCBridgeable conformances, although those conformances only really kick in at runtime (e.g., when dynamically casting an [AnyObject] or [NSNumber] to [Int] or [Double] with as? or matching a switch case). They would run afoul of this rule. However, this rule does generally make sense: if two Swift types have the same ObjectiveCType, we won’t know how to map an Objective-C API back into Swift. Those numeric types only work because they are trivially mapped between Swift and (Objective-)C; they don’t need to go through the _ObjectiveCBridgeable conformance. <br></p><p>On the other hand, the greater ambiguity problem is if there are two conformances to ObjectiveCBridgeable on the same type; that’s already covered by Swift’s rules about multiple conformances.<br></p><p>(This was #6) The Swift type and ObjectiveCType must be defined in the same module<br>Yes, absolutely. If the ObjectiveCType comes from Objective-C, then it must come from the same-named Objective-C module.<br></p><p>Under “Alternatives considered”, there is a typo “fesible”.<br></p><p>I’ve been assuming we’re only allowed to bridge with Objective-C classes (whether they are defined in Swift or Objective-C), but Swift also has @objc enums now… I assume you don’t intend @objc enums to be part of this, so I think it makes sense to be explicit about the limitation to classes.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160321/9ca579ab/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 23, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Mar 21, 2016, at 9:41 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 9, 2016, at 12:26 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; An official proposal PR has been opened on this: https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt;&gt; <br>&gt;&gt; It includes clarifications, a few changes, and some better examples.<br>&gt; <br>&gt; FWIW, I’ve implemented much of this proposal as a series of compiler cleanups. It introduces a few tweaks to the _ObjectiveCBridgeable protocol that were necessary to generalize (and de-special-case) the NSString/NSArray/NSDictionary/NSSet bridging, but it’s still considered an implementation detail. So, some comments on the proposal itself…<br>&gt; <br>&gt; <br>&gt; /// A type adopting `ObjectiveCBridgeable` will be exposed<br>&gt; /// to Objective-C as the type `ObjectiveCType`<br>&gt; public protocol ObjectiveCBridgeable: _ObjectiveCBridgeable {<br>&gt;     associatedtype ObjectiveCType : AnyObject<br>&gt;     associatedtype _ObjectiveCType = ObjectiveCType<br>&gt; I think we should just say that ObjectiveCBridgeable replaces _ObjectiveCBridgeable, and only have the first associated type. (You actually wanted a typealias anyway, I think).<br></p><p>That sounds great to me. <br></p><p><br>&gt; <br>&gt;     /// Returns `true` iff instances of `Self` can be converted to<br>&gt;     /// Objective-C.  Even if this method returns `true`, a given<br>&gt;     /// instance of `Self._ObjectiveCType` may, or may not, convert<br>&gt;     /// successfully to `Self`.<br>&gt;     ///<br>&gt;     /// A default implementation returns `true`.<br>&gt;     @warn_unused_result<br>&gt;     static func isBridgedToObjectiveC() -&gt; Bool<br>&gt; It’s probably worth saying why someone might override this method: usually, it’s because the Swift type is generic and it only makes sense to bridge for some type arguments. Granted, there is no way to communicate this information to the compiler, which is a bit of a hole in the design. For example, Array&lt;T&gt; only bridges to NSArray when T is itself representable in Objective-C. We really need conditional conformances to for this part of the feature to work properly.<br></p><p>I’ve added a section to the proposal to call out that it is intended for conformance to be conditional in some cases (eg Array), and a small explanation of what to do and a code example. It’s a bit unwieldy but workable until we have conditional conformance.<br></p><p><br></p><p>&gt; <br>&gt;     /// Try to construct a value of the Self type from<br>&gt;     /// an Objective-C object of the bridged class type.<br>&gt;     ///<br>&gt;     /// If the conversion fails this initializer returns `nil`.<br>&gt;     init?(bridgedFromObjectiveC: ObjectiveCType)<br>&gt; FWIW, implementing this required a new “unconditional” entry point used by the compiler:<br>&gt; <br>&gt;   static func _unconditionallyBridgeFromObjectiveC(source: _ObjectiveCType?)<br>&gt;       -&gt; Self<br>&gt; <br>&gt; It can get a default implementation, and should be a non-failable initializer.<br></p><p>I’ve updated the proposal to add this. The default implementation of &quot;init(unconditionallyBridgedFromObjectiveC: ObjectiveCType?)&quot; just calls the fallible initializer and aborts if anything goes wrong. Default implementation of “unconditionallyBridgeFromObjectiveC(source: ObjectiveCType?)” calls the initializer. My guess is most types will probably just accept the default behavior.<br></p><p>I assume this is a static function to avoid allocating memory by calling the initializer directly for each element, given the point is to defer the work? I wonder if we can skip the static though and just call the initializer directly? It would simplify the protocol a tiny bit.<br></p><p><br></p><p>&gt; 	4. The ObjectiveCType must be defined in Swift. If a -swift.h header is generated, it will include a SWIFT_BRIDGED()macro where the parameter indicates the Swift type with which the ObjectiveCType bridges. The macro will be applied to the ObjectiveCType and any subclasses.<br>&gt; <br>&gt; This is unnecessarily restrictive, and eliminates the “make my Objective-C class bridge into a Swift value type” case that (for example) the compiler already does for String/Array/Dictionary/Set. I think there are two cases:<br>&gt; <br>&gt; 	(a) The ObjectiveCType is defined in Objective-C. It must be an Objective-C class with the attribute swift_bridge(“Bar”), where “Bar” is the name of the bridged Swift type.<br>&gt; 	(b) The ObjectiveCType is defined in Swift, in which case it must be an @objc class. When emitting the generated header, the appropriate swift_bridge attribute will be added to the @interface declaration.<br>&gt; <br>&gt; <br></p><p>I mostly hadn’t really considered the implications but I see the value and I trust your assessment; I removed the restriction and reworded the whole section.<br></p><p><br></p><p>&gt; <br>&gt; (This was #5) It is an error for bridging to be ambiguous.<br>&gt; A Swift type may bridge to an Objective-C base class, then provide different subclass instances at runtime but no other Swift type may bridge to that base class or any of its subclasses.<br>&gt; The compiler must emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType.<br>&gt; This is a tricky area. Currently, Int/Float/Double/Bool/CGFloat/UInt all have _ObjectiveCBridgeable conformances, although those conformances only really kick in at runtime (e.g., when dynamically casting an [AnyObject] or [NSNumber] to [Int] or [Double] with as? or matching a switch case). They would run afoul of this rule. However, this rule does generally make sense: if two Swift types have the same ObjectiveCType, we won’t know how to map an Objective-C API back into Swift. Those numeric types only work because they are trivially mapped between Swift and (Objective-)C; they don’t need to go through the _ObjectiveCBridgeable conformance. <br></p><p><br>Perhaps the rule should simply be that any Objective-C API imported that has ambiguity is imported as the Objective-C type without automatic bridging support. The compiler can continue to import Int and friends with special magic. Creating an ambiguity just leaves you to resolve the problem manually? The rule would be something like &quot;omitting the SWIFT_BRIDGED() attribute from ObjC //or// multiple Swift types bridging to the same ObjC type&quot; turns off automatic thunk generation but bridged collections will still call the protocol where appropriate.<br></p><p><br></p><p>&gt; <br>&gt; On the other hand, the greater ambiguity problem is if there are two conformances to ObjectiveCBridgeable on the same type; that’s already covered by Swift’s rules about multiple conformances.<br>&gt; <br>&gt; (This was #6) The Swift type and ObjectiveCType must be defined in the same module<br>&gt; Yes, absolutely. If the ObjectiveCType comes from Objective-C, then it must come from the same-named Objective-C module.<br>&gt; <br>&gt; Under “Alternatives considered”, there is a typo “fesible”.<br>&gt; <br>&gt; I’ve been assuming we’re only allowed to bridge with Objective-C classes (whether they are defined in Swift or Objective-C), but Swift also has @objc enums now… I assume you don’t intend @objc enums to be part of this, so I think it makes sense to be explicit about the limitation to classes.<br></p><p>Yes that’s true. I added wording to that effect to the proposal.<br></p><p><br>An update has been posted to https://github.com/russbishop/swift-evolution/blob/master/proposals/0000-objectivecbridgeable.md &lt;https://github.com/russbishop/swift-evolution/blob/master/proposals/0000-objectivecbridgeable.md&gt;<br></p><p><br>Would you prefer if I did / did not add your name to the proposal? I feel guilty taking all the credit.<br></p><p>Russ<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/4161aeb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 23, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 12:21 AM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 21, 2016, at 9:41 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 9, 2016, at 12:26 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An official proposal PR has been opened on this: https://github.com/apple/swift-evolution/pull/198 &lt;https://github.com/apple/swift-evolution/pull/198&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It includes clarifications, a few changes, and some better examples.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;     /// Returns `true` iff instances of `Self` can be converted to<br>&gt;&gt;     /// Objective-C.  Even if this method returns `true`, a given<br>&gt;&gt;     /// instance of `Self._ObjectiveCType` may, or may not, convert<br>&gt;&gt;     /// successfully to `Self`.<br>&gt;&gt;     ///<br>&gt;&gt;     /// A default implementation returns `true`.<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     static func isBridgedToObjectiveC() -&gt; Bool<br>&gt;&gt; It’s probably worth saying why someone might override this method: usually, it’s because the Swift type is generic and it only makes sense to bridge for some type arguments. Granted, there is no way to communicate this information to the compiler, which is a bit of a hole in the design. For example, Array&lt;T&gt; only bridges to NSArray when T is itself representable in Objective-C. We really need conditional conformances to for this part of the feature to work properly.<br>&gt; <br>&gt; I’ve added a section to the proposal to call out that it is intended for conformance to be conditional in some cases (eg Array), and a small explanation of what to do and a code example. It’s a bit unwieldy but workable until we have conditional conformance.<br></p><p>Great. The suggestion to use an extension won’t actually work:<br></p><p>    /// A default implementation returns `true`. If a Swift type is <br>    /// generic and should only be bridged for some type arguments,<br>    /// provide alternate implementations in extensions <br>    /// and return `false` in those cases.<br>    ///<br>    ///     struct Foo&lt;T&gt;: ObjectiveCBridgeable { ... }<br>    ///     extension Foo where T: NonBridgedType {<br>    ///         static func isBridgedToObjectiveC() -&gt; Bool { <br>    ///             return false <br>    ///         }<br>    ///     }<br>because you don’t get dynamic dispatching based on T. Instead, you want one implementation of isBridgedToObjectiveC that does a dynamic check, e.g.,<br></p><p>struct Foo&lt;T&gt;: ObjectiveCBridgeable {<br>  static func isBridgedToObjectiveC() -&gt; Bool {<br>    return !(T is NonBridgedType)<br>  }<br>}<br>  <br></p><p>&gt;&gt; <br>&gt;&gt;     /// Try to construct a value of the Self type from<br>&gt;&gt;     /// an Objective-C object of the bridged class type.<br>&gt;&gt;     ///<br>&gt;&gt;     /// If the conversion fails this initializer returns `nil`.<br>&gt;&gt;     init?(bridgedFromObjectiveC: ObjectiveCType)<br>&gt;&gt; FWIW, implementing this required a new “unconditional” entry point used by the compiler:<br>&gt;&gt; <br>&gt;&gt;   static func _unconditionallyBridgeFromObjectiveC(source: _ObjectiveCType?)<br>&gt;&gt;       -&gt; Self<br>&gt;&gt; <br>&gt;&gt; It can get a default implementation, and should be a non-failable initializer.<br>&gt; <br>&gt; I’ve updated the proposal to add this. The default implementation of &quot;init(unconditionallyBridgedFromObjectiveC: ObjectiveCType?)&quot; just calls the fallible initializer and aborts if anything goes wrong. Default implementation of “unconditionallyBridgeFromObjectiveC(source: ObjectiveCType?)” calls the initializer. My guess is most types will probably just accept the default behavior.<br></p><p>Yes, I suspect you’re right that most types will use the default.<br></p><p>&gt; <br>&gt; I assume this is a static function to avoid allocating memory by calling the initializer directly for each element, given the point is to defer the work? I wonder if we can skip the static though and just call the initializer directly? It would simplify the protocol a tiny bit.<br></p><p>From an implementation perspective, the entry point for an initializer in a protocol handles the allocation itself. It’s a static function because it was easy to implement that way and the actual definitions get a bit more flexibility in how they can come up with the object (since we don’t have factory initializers).<br></p><p>&gt;&gt; 	4. The ObjectiveCType must be defined in Swift. If a -swift.h header is generated, it will include a SWIFT_BRIDGED()macro where the parameter indicates the Swift type with which the ObjectiveCType bridges. The macro will be applied to the ObjectiveCType and any subclasses.<br>&gt;&gt; <br>&gt;&gt; This is unnecessarily restrictive, and eliminates the “make my Objective-C class bridge into a Swift value type” case that (for example) the compiler already does for String/Array/Dictionary/Set. I think there are two cases:<br>&gt;&gt; <br>&gt;&gt; 	(a) The ObjectiveCType is defined in Objective-C. It must be an Objective-C class with the attribute swift_bridge(“Bar”), where “Bar” is the name of the bridged Swift type.<br>&gt;&gt; 	(b) The ObjectiveCType is defined in Swift, in which case it must be an @objc class. When emitting the generated header, the appropriate swift_bridge attribute will be added to the @interface declaration.<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; I mostly hadn’t really considered the implications but I see the value and I trust your assessment; I removed the restriction and reworded the whole section.<br></p><p>Looks good, thanks!<br></p><p>&gt;&gt; <br>&gt;&gt; (This was #5) It is an error for bridging to be ambiguous.<br>&gt;&gt; A Swift type may bridge to an Objective-C base class, then provide different subclass instances at runtime but no other Swift type may bridge to that base class or any of its subclasses.<br>&gt;&gt; The compiler must emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType.<br>&gt;&gt; This is a tricky area. Currently, Int/Float/Double/Bool/CGFloat/UInt all have _ObjectiveCBridgeable conformances, although those conformances only really kick in at runtime (e.g., when dynamically casting an [AnyObject] or [NSNumber] to [Int] or [Double] with as? or matching a switch case). They would run afoul of this rule. However, this rule does generally make sense: if two Swift types have the same ObjectiveCType, we won’t know how to map an Objective-C API back into Swift. Those numeric types only work because they are trivially mapped between Swift and (Objective-)C; they don’t need to go through the _ObjectiveCBridgeable conformance. <br>&gt; <br>&gt; <br>&gt; Perhaps the rule should simply be that any Objective-C API imported that has ambiguity is imported as the Objective-C type without automatic bridging support. The compiler can continue to import Int and friends with special magic. Creating an ambiguity just leaves you to resolve the problem manually? The rule would be something like &quot;omitting the SWIFT_BRIDGED() attribute from ObjC //or// multiple Swift types bridging to the same ObjC type&quot; turns off automatic thunk generation but bridged collections will still call the protocol where appropriate.<br></p><p>Yeah. Thinking about it a bit further, I like your rule basically as you’ve stated it, because having two _ObjectiveCBridgeable conformances mapping to the same type is a problem the user should have to resolve. I guess I’m just looking for something small to indicate that a direct mapping of the representation (e.g., NSInteger -&gt; Int) supersedes the _ObjectiveCBridgeable conformance when mapping APIs between Objective-C and Swift.<br></p><p><br>&gt; An update has been posted to https://github.com/russbishop/swift-evolution/blob/master/proposals/0000-objectivecbridgeable.md &lt;https://github.com/russbishop/swift-evolution/blob/master/proposals/0000-objectivecbridgeable.md&gt;<br>Thanks!<br></p><p>&gt; Would you prefer if I did / did not add your name to the proposal? I feel guilty taking all the credit.<br></p><p>I don’t have a strong preference. Feel free to add my name if you’d like. I really appreciate your work on driving this proposal forward!<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/db6d61cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 23, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 11:49 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt; <br>&gt; Great. The suggestion to use an extension won’t actually work:<br>&gt; <br></p><p>Doh. Thanks for catching that, I pushed a fix.<br></p><p><br></p><p>&gt;   <br>&gt;&gt; I assume this is a static function to avoid allocating memory by calling the initializer directly for each element, given the point is to defer the work? I wonder if we can skip the static though and just call the initializer directly? It would simplify the protocol a tiny bit.<br>&gt; <br>&gt; From an implementation perspective, the entry point for an initializer in a protocol handles the allocation itself. It’s a static function because it was easy to implement that way and the actual definitions get a bit more flexibility in how they can come up with the object (since we don’t have factory initializers).<br> <br>Good point about the factory initializers. I’ve been trying to keep the whole “class cluster” situation in mind. I wonder if there should be an equivalent static function for the conditional bridging for similar reasons?<br></p><p><br></p><p>&gt;&gt;&gt; <br>&gt; <br>&gt;&gt;&gt; (This was #5) It is an error for bridging to be ambiguous.<br>&gt;&gt;&gt; A Swift type may bridge to an Objective-C base class, then provide different subclass instances at runtime but no other Swift type may bridge to that base class or any of its subclasses.<br>&gt;&gt;&gt; The compiler must emit a diagnostic when it detects two Swift types attempting to bridge to the same ObjectiveCType.<br>&gt;&gt;&gt; This is a tricky area. Currently, Int/Float/Double/Bool/CGFloat/UInt all have _ObjectiveCBridgeable conformances, although those conformances only really kick in at runtime (e.g., when dynamically casting an [AnyObject] or [NSNumber] to [Int] or [Double] with as? or matching a switch case). They would run afoul of this rule. However, this rule does generally make sense: if two Swift types have the same ObjectiveCType, we won’t know how to map an Objective-C API back into Swift. Those numeric types only work because they are trivially mapped between Swift and (Objective-)C; they don’t need to go through the _ObjectiveCBridgeable conformance. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Perhaps the rule should simply be that any Objective-C API imported that has ambiguity is imported as the Objective-C type without automatic bridging support. The compiler can continue to import Int and friends with special magic. Creating an ambiguity just leaves you to resolve the problem manually? The rule would be something like &quot;omitting the SWIFT_BRIDGED() attribute from ObjC //or// multiple Swift types bridging to the same ObjC type&quot; turns off automatic thunk generation but bridged collections will still call the protocol where appropriate.<br>&gt; <br>&gt; Yeah. Thinking about it a bit further, I like your rule basically as you’ve stated it, because having two _ObjectiveCBridgeable conformances mapping to the same type is a problem the user should have to resolve. I guess I’m just looking for something small to indicate that a direct mapping of the representation (e.g., NSInteger -&gt; Int) supersedes the _ObjectiveCBridgeable conformance when mapping APIs between Objective-C and Swift.<br>&gt; <br></p><p><br>I added a separate section on Ambiguity and what the behavior is. I think you should be able to resolve ambiguity by casting so I went ahead and put that in. An example:<br></p><p>//Bar and Foo bridge to SomeObjectiveCType<br>struct Bar&lt;T&gt;: ObjectiveCBridgeable { }<br>struct Foo&lt;T&gt;: ObjectiveCBridgeable { }<br></p><p>class API {<br>    let foo: Foo&lt;Int&gt;<br>    func objCVersionOfAFunction(obj: SomeObjectiveCType) -&gt; SomeObjectiveCType {<br>        let x = obj as! Bar&lt;Int&gt;<br>        // We&#39;ve told the compiler which protocol impl to call<br>        return foo as! SomeObjectiveCType<br>    }<br>}<br></p><p>Any problems with this approach? It makes handling the ambiguous or manual bridging case relatively straightforward, though there may be objections to using casting this way. [Be careful, I still mourn the loss of @conversion so I’m biased :)]<br></p><p><br>`NSInteger` is already imported as `Int` from Objective-C right? I assume a Clang attribute is specifying that somewhere but there wouldn’t be any ambiguity on the Swift side during import. I could definitely see having an attribute to declare that this specific parameter or return value should bridge to a specific Swift type (this NSNumber should import as Int) but that’s a lot of work and may be worth a separate proposal.<br></p><p>It seems like the problem is going the other direction: you want to materialize this parameter or whatever as `NSInteger` instead of the default `NSNumber *` but only when directly bridged, not inside collections. There’s no existing Objective-C header to tell us what to do. I’m not sure how we can resolve this without a Swift attribute to tell the compiler because the handling of it would be specific to each declaration. <br></p><p>We could just  say that we aren’t going to let people have that level of granularity. Then just introduce a BuiltInBridgeable protocol that supersedes ObjectiveCBridgeable. A type adopting both will cause the compiler to prefer the built-in protocol when generating a bridging header, but the collection types can ignore that and just use ObjectiveCBridgeable. Presumably the BuiltInBridgeable protocol would just have an associated type to indicate that the bits are directly mapped to BuiltIn.Word or whatever.<br></p><p><br></p><p>&gt;&gt; An update has been posted to https://github.com/russbishop/swift-evolution/blob/master/proposals/0000-objectivecbridgeable.md &lt;https://github.com/russbishop/swift-evolution/blob/master/proposals/0000-objectivecbridgeable.md&gt;<br>&gt; Thanks!<br>&gt; <br>&gt;&gt; Would you prefer if I did / did not add your name to the proposal? I feel guilty taking all the credit.<br>&gt; <br>&gt; I don’t have a strong preference. Feel free to add my name if you’d like. I really appreciate your work on driving this proposal forward!<br>&gt; <br>&gt; 	- Doug<br>&gt; <br></p><p>Happy to do so!<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/ee3c67eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 23, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Mar 23, 2016, at 1:25 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 11:49 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I assume this is a static function to avoid allocating memory by calling the initializer directly for each element, given the point is to defer the work? I wonder if we can skip the static though and just call the initializer directly? It would simplify the protocol a tiny bit.<br>&gt;&gt; <br>&gt;&gt; From an implementation perspective, the entry point for an initializer in a protocol handles the allocation itself. It’s a static function because it was easy to implement that way and the actual definitions get a bit more flexibility in how they can come up with the object (since we don’t have factory initializers).<br>&gt;  <br>&gt; Good point about the factory initializers. I’ve been trying to keep the whole “class cluster” situation in mind. I wonder if there should be an equivalent static function for the conditional bridging for similar reasons?<br></p><p>I realize that my comment about factory initializers was a bit off: these are initializers on the value type, so there are no “class clusters” to be had. Sorry for the noise!<br></p><p>&gt; I added a separate section on Ambiguity and what the behavior is. I think you should be able to resolve ambiguity by casting so I went ahead and put that in. An example:<br>&gt; <br>&gt; //Bar and Foo bridge to SomeObjectiveCType<br>&gt; struct Bar&lt;T&gt;: ObjectiveCBridgeable { }<br>&gt; struct Foo&lt;T&gt;: ObjectiveCBridgeable { }<br>&gt; <br>&gt; class API {<br>&gt;     let foo: Foo&lt;Int&gt;<br>&gt;     func objCVersionOfAFunction(obj: SomeObjectiveCType) -&gt; SomeObjectiveCType {<br>&gt;         let x = obj as! Bar&lt;Int&gt;<br>&gt;         // We&#39;ve told the compiler which protocol impl to call<br>&gt;         return foo as! SomeObjectiveCType<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Any problems with this approach? It makes handling the ambiguous or manual bridging case relatively straightforward, though there may be objections to using casting this way. [Be careful, I still mourn the loss of @conversion so I’m biased :)]<br></p><p><br>The problem I have with allowing the ambiguity is that you can get weird behavior if Bar and Foo are in different modules: import just Bar’s module, and an Objective-C API mentioning SomeObjectiveCType gets bridged as a Bar. Import just Foo’s module, and an Objective-C API mentioning SomeObjectiveCType gets bridged as a Foo. Import both, and SomeObjectiveCType doesn’t get bridged! Now start splitting class hierarchies among those modules and you get some very inconsistent imports… that’s why I think this needs to be an error.<br></p><p>&gt; <br>&gt; <br>&gt; `NSInteger` is already imported as `Int` from Objective-C right? I assume a Clang attribute is specifying that somewhere but there wouldn’t be any ambiguity on the Swift side during import.<br></p><p>It’s hardcoded, but it’s completely reasonable to imagine swift_bridge doing this some day.<br></p><p>&gt; I could definitely see having an attribute to declare that this specific parameter or return value should bridge to a specific Swift type (this NSNumber should import as Int) but that’s a lot of work and may be worth a separate proposal.<br></p><p>It would be hard for me to get motivated for such a proposal; at that point, just wrap up the API.<br></p><p>&gt; It seems like the problem is going the other direction: you want to materialize this parameter or whatever as `NSInteger` instead of the default `NSNumber *` but only when directly bridged, not inside collections. There’s no existing Objective-C header to tell us what to do. I’m not sure how we can resolve this without a Swift attribute to tell the compiler because the handling of it would be specific to each declaration. <br></p><p>I don’t have a good answer here; today, it’s hardcoded.<br></p><p>&gt; We could just  say that we aren’t going to let people have that level of granularity. Then just introduce a BuiltInBridgeable protocol that supersedes ObjectiveCBridgeable. A type adopting both will cause the compiler to prefer the built-in protocol when generating a bridging header, but the collection types can ignore that and just use ObjectiveCBridgeable. Presumably the BuiltInBridgeable protocol would just have an associated type to indicate that the bits are directly mapped to BuiltIn.Word or whatever.<br></p><p>Yes, that’s a reasonable approach. I don’t think it’s important for this proposal.<br></p><p>Two last comments came up, then I’d like to merge and schedule this:<br></p><p>(1) isBridgedToObjectiveC should be a computed property, not a function<br></p><p>(2) Please add something indicating that, while one can “as” cast between a value type and its bridged Objective-C type, there are no implicit conversions. We currently have implicit conversions from String -&gt; NSString, Array&lt;T&gt; -&gt; NSArray, Dictionary&lt;K, V&gt; -&gt; NSDictionary, and Set&lt;T&gt; -&gt; NSSet, but we’re not happy about them and we don’t want to create more implicit conversions [*].<br></p><p>	- Doug<br></p><p>[*] The fact that you mourn the loss of @conversion did not go unnoticed as I was writing this ;)<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/09d7c6a7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>March 24, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;&gt; I added a separate section on Ambiguity and what the behavior is. I think you should be able to resolve ambiguity by casting so I went ahead and put that in. An example:<br>&gt;&gt; <br>&gt;&gt; //Bar and Foo bridge to SomeObjectiveCType<br>&gt;&gt; struct Bar&lt;T&gt;: ObjectiveCBridgeable { }<br>&gt;&gt; struct Foo&lt;T&gt;: ObjectiveCBridgeable { }<br>&gt;&gt; <br>&gt;&gt; class API {<br>&gt;&gt;     let foo: Foo&lt;Int&gt;<br>&gt;&gt;     func objCVersionOfAFunction(obj: SomeObjectiveCType) -&gt; SomeObjectiveCType {<br>&gt;&gt;         let x = obj as! Bar&lt;Int&gt;<br>&gt;&gt;         // We&#39;ve told the compiler which protocol impl to call<br>&gt;&gt;         return foo as! SomeObjectiveCType<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Any problems with this approach? It makes handling the ambiguous or manual bridging case relatively straightforward, though there may be objections to using casting this way. [Be careful, I still mourn the loss of @conversion so I’m biased :)]<br>&gt; <br>&gt; <br>&gt; The problem I have with allowing the ambiguity is that you can get weird behavior if Bar and Foo are in different modules: import just Bar’s module, and an Objective-C API mentioning SomeObjectiveCType gets bridged as a Bar. Import just Foo’s module, and an Objective-C API mentioning SomeObjectiveCType gets bridged as a Foo. Import both, and SomeObjectiveCType doesn’t get bridged! Now start splitting class hierarchies among those modules and you get some very inconsistent imports… that’s why I think this needs to be an error.<br>&gt; <br></p><p>The rule requiring the Swift and @objc types to be in the same module wouldn’t allow the scenario you describe.<br></p><p>I’m fine to say it’s an error as this isn’t a capability I have any use for and it definitely could cause confusion. The rule could always be relaxed in the future if there’s a convincing case for it. I’ll update the proposal to make it an error again.<br></p><p><br>&gt; <br>&gt;&gt; We could just  say that we aren’t going to let people have that level of granularity. Then just introduce a BuiltInBridgeable protocol that supersedes ObjectiveCBridgeable. A type adopting both will cause the compiler to prefer the built-in protocol when generating a bridging header, but the collection types can ignore that and just use ObjectiveCBridgeable. Presumably the BuiltInBridgeable protocol would just have an associated type to indicate that the bits are directly mapped to BuiltIn.Word or whatever.<br>&gt; <br>&gt; Yes, that’s a reasonable approach. I don’t think it’s important for this proposal.<br></p><p>I added some wording about magic built-in types like `Int` and a section at the bottom about the overall issue and an overriding protocol, but indicated we won’t pursue it at this time.<br></p><p><br>&gt; <br>&gt; Two last comments came up, then I’d like to merge and schedule this:<br>&gt; <br>&gt; (1) isBridgedToObjectiveC should be a computed property, not a function<br>&gt; <br>&gt; (2) Please add something indicating that, while one can “as” cast between a value type and its bridged Objective-C type, there are no implicit conversions. We currently have implicit conversions from String -&gt; NSString, Array&lt;T&gt; -&gt; NSArray, Dictionary&lt;K, V&gt; -&gt; NSDictionary, and Set&lt;T&gt; -&gt; NSSet, but we’re not happy about them and we don’t want to create more implicit conversions [*].<br>&gt; <br></p><p>Done!<br></p><p><br></p><p>Russ<br></p><p><br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/2b2b64a0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Idea] ObjectiveCBridgeable</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 24, 2016, at 12:39 AM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; I added a separate section on Ambiguity and what the behavior is. I think you should be able to resolve ambiguity by casting so I went ahead and put that in. An example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; //Bar and Foo bridge to SomeObjectiveCType<br>&gt;&gt;&gt; struct Bar&lt;T&gt;: ObjectiveCBridgeable { }<br>&gt;&gt;&gt; struct Foo&lt;T&gt;: ObjectiveCBridgeable { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class API {<br>&gt;&gt;&gt;     let foo: Foo&lt;Int&gt;<br>&gt;&gt;&gt;     func objCVersionOfAFunction(obj: SomeObjectiveCType) -&gt; SomeObjectiveCType {<br>&gt;&gt;&gt;         let x = obj as! Bar&lt;Int&gt;<br>&gt;&gt;&gt;         // We&#39;ve told the compiler which protocol impl to call<br>&gt;&gt;&gt;         return foo as! SomeObjectiveCType<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Any problems with this approach? It makes handling the ambiguous or manual bridging case relatively straightforward, though there may be objections to using casting this way. [Be careful, I still mourn the loss of @conversion so I’m biased :)]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The problem I have with allowing the ambiguity is that you can get weird behavior if Bar and Foo are in different modules: import just Bar’s module, and an Objective-C API mentioning SomeObjectiveCType gets bridged as a Bar. Import just Foo’s module, and an Objective-C API mentioning SomeObjectiveCType gets bridged as a Foo. Import both, and SomeObjectiveCType doesn’t get bridged! Now start splitting class hierarchies among those modules and you get some very inconsistent imports… that’s why I think this needs to be an error.<br>&gt;&gt; <br>&gt; <br>&gt; The rule requiring the Swift and @objc types to be in the same module wouldn’t allow the scenario you describe.<br></p><p>Ah, yes.<br></p><p>&gt; <br>&gt; I’m fine to say it’s an error as this isn’t a capability I have any use for and it definitely could cause confusion. The rule could always be relaxed in the future if there’s a convincing case for it. I’ll update the proposal to make it an error again.<br></p><p>I’d rather call it an error and consider relaxing the rule if we find it’s very important later on.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/cd95a844/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
