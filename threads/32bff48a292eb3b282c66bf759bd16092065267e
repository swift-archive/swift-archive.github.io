<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>January 31, 2016 at 03:00:00am</p></header><div class="content"><p>Since the first public betas I’d like to know why operator implementation<br>have to be written outside the body of its owner.<br></p><p>Take as example the code:<br></p><p>protocol MyEquatable {<br></p><p>    @warn_unused_result<br></p><p>    func ==(lhs: Self, rhs: Self) -&gt; Bool<br></p><p>}<br></p><p><br>struct MyStruct: MyEquatable {<br></p><p>    let foo: String<br></p><p>    let bar: String<br></p><p>}<br></p><p><br>func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br></p><p>    return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br></p><p>}<br></p><p><br>Why we cannot write:<br></p><p>protocol MyEquatable {<br></p><p>    @warn_unused_result<br></p><p>    func ==(lhs: Self, rhs: Self) -&gt; Bool<br></p><p>}<br></p><p><br>struct MyStruct: MyEquatable {<br></p><p>    let foo: String<br></p><p>    let bar: String<br></p><p><br></p><p>    func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br></p><p>        return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br></p><p>    }<br></p><p><br>}<br></p><p><br>Any thoughts?<br></p><p><br>-Van<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/32bf267e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 9:03 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since the first public betas I’d like to know why operator implementation have to be written outside the body of its owner.<br></p><p>Yep, this is a generally desirable feature (at least for symmetric operators).  This would also be great to get dynamic dispatch of operators within class declarations.  I don’t think we have a firm proposal nailing down how name lookup works with this though.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; Take as example the code:<br>&gt; <br>&gt; protocol MyEquatable {<br>&gt;     @warn_unused_result<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; struct MyStruct: MyEquatable {<br>&gt;     let foo: String<br>&gt;     let bar: String<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;     return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt; }<br>&gt; <br>&gt; Why we cannot write:<br>&gt; <br>&gt; protocol MyEquatable {<br>&gt;     @warn_unused_result<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; struct MyStruct: MyEquatable {<br>&gt;     let foo: String<br>&gt;     let bar: String<br>&gt;     <br>&gt;     func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;         return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; <br>&gt; -Van<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/7f26f5d3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>January 31, 2016 at 01:00:00pm</p></header><div class="content"><p>Definitely a +1 from me for the feature.<br></p><p>What are the name lookup issues? Do you mean cases where an operator for Foo == Foo exists in more than one location? Personally I’d just stick with what we have now, i.e- treat operator implementations within a specific class/struct as being globally defined anyway and throw an error if the same signature is declared more than once.<br></p><p>One minor issue around putting them in class/struct bodies though is that I wonder if perhaps a keyword other than func should be used? While they are functions, they aren’t methods of instances. At the very least they should probably need to be static.<br></p><p>&gt; On 31 Jan 2016, at 05:26, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 30, 2016, at 9:03 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since the first public betas I’d like to know why operator implementation have to be written outside the body of its owner.<br>&gt; <br>&gt; Yep, this is a generally desirable feature (at least for symmetric operators).  This would also be great to get dynamic dispatch of operators within class declarations.  I don’t think we have a firm proposal nailing down how name lookup works with this though.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Take as example the code:<br>&gt;&gt; <br>&gt;&gt; protocol MyEquatable {<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct MyStruct: MyEquatable {<br>&gt;&gt;     let foo: String<br>&gt;&gt;     let bar: String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;&gt;     return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Why we cannot write:<br>&gt;&gt; <br>&gt;&gt; protocol MyEquatable {<br>&gt;&gt;     @warn_unused_result<br>&gt;&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; struct MyStruct: MyEquatable {<br>&gt;&gt;     let foo: String<br>&gt;&gt;     let bar: String<br>&gt;&gt;     <br>&gt;&gt;     func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;&gt;         return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Any thoughts?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Van<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/e22fdb11/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2475 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/e22fdb11/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>January 31, 2016 at 07:00:00pm</p></header><div class="content"><p>Good idea! For the syntax I suggest something like this:<br></p><p>protocol MyEquatable {<br>    @warn_unused_result<br>    operator ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>struct MyStruct: MyEquatable {<br>    let foo: String<br>    let bar: String<br></p><p><br>    operator ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>        return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>    }<br>}<br></p><p><br>`operator` meaning `static func`<br></p><p><br>-Van<br></p><p><br>On Sun, Jan 31, 2016 at 11:14 AM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br></p><p>&gt; Definitely a +1 from me for the feature.<br>&gt;<br>&gt; What are the name lookup issues? Do you mean cases where an operator for<br>&gt; Foo == Foo exists in more than one location? Personally I’d just stick with<br>&gt; what we have now, i.e- treat operator implementations within a specific<br>&gt; class/struct as being globally defined anyway and throw an error if the<br>&gt; same signature is declared more than once.<br>&gt;<br>&gt; One minor issue around putting them in class/struct bodies though is that<br>&gt; I wonder if perhaps a keyword other than func should be used? While they<br>&gt; are functions, they aren’t methods of instances. At the very least they<br>&gt; should probably need to be static.<br>&gt;<br>&gt; On 31 Jan 2016, at 05:26, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 30, 2016, at 9:03 PM, Vanderlei Martinelli via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Since the first public betas I’d like to know why operator implementation<br>&gt; have to be written outside the body of its owner.<br>&gt;<br>&gt;<br>&gt; Yep, this is a generally desirable feature (at least for symmetric<br>&gt; operators).  This would also be great to get dynamic dispatch of operators<br>&gt; within class declarations.  I don’t think we have a firm proposal nailing<br>&gt; down how name lookup works with this though.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Take as example the code:<br>&gt;<br>&gt; protocol MyEquatable {<br>&gt;     @warn_unused_result<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; struct MyStruct: MyEquatable {<br>&gt;     let foo: String<br>&gt;     let bar: String<br>&gt; }<br>&gt;<br>&gt; func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;     return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt; }<br>&gt;<br>&gt; Why we cannot write:<br>&gt;<br>&gt; protocol MyEquatable {<br>&gt;     @warn_unused_result<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; struct MyStruct: MyEquatable {<br>&gt;     let foo: String<br>&gt;     let bar: String<br>&gt;<br>&gt;     func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;         return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Any thoughts?<br>&gt;<br>&gt;<br>&gt; -Van<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/9374f990/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 5:14 AM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br>&gt; <br>&gt; Definitely a +1 from me for the feature.<br>&gt; <br>&gt; What are the name lookup issues? Do you mean cases where an operator for Foo == Foo exists in more than one location?<br></p><p>Yes.  Name lookup has to have a well defined search order, which defines shadowing and invalid multiple definition rules.<br></p><p>&gt; Personally I’d just stick with what we have now, i.e- treat operator implementations within a specific class/struct as being globally defined anyway and throw an error if the same signature is declared more than once.<br></p><p>We need multiple modules to be able to define instances of an operator, we need operators in extensions, and we need retroactive conformance to work, as with any other member.<br></p><p>&gt; One minor issue around putting them in class/struct bodies though is that I wonder if perhaps a keyword other than func should be used? While they are functions, they aren’t methods of instances. At the very least they should probably need to be static.<br></p><p>As we do with protocols, I think we should continue to treat “func &lt;operatoridentifier&gt;” specially.  That said, I’d welcome other people’s thoughts on this.  Would it be more clear to have:<br></p><p>protocol P {<br>  operator ==(a : Self, b : Self) -&gt; Bool<br>}<br></p><p>Does “operator” buy us anything there over func?  If we went this direction, it would require taking operator as a keyword.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>February  1, 2016 at 07:00:00am</p></header><div class="content"><p>Comments inline.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 1 Feb 2016, at 04:55, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 31, 2016, at 5:14 AM, Haravikk &lt;e-mail at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Definitely a +1 from me for the feature.<br>&gt;&gt; <br>&gt;&gt; What are the name lookup issues? Do you mean cases where an operator for Foo == Foo exists in more than one location?<br>&gt; <br>&gt; Yes.  Name lookup has to have a well defined search order, which defines shadowing and invalid multiple definition rules.<br>&gt; <br>&gt;&gt; Personally I’d just stick with what we have now, i.e- treat operator implementations within a specific class/struct as being globally defined anyway and throw an error if the same signature is declared more than once.<br>&gt; <br>&gt; We need multiple modules to be able to define instances of an operator, we need operators in extensions, and we need retroactive conformance to work, as with any other member.<br>&gt; <br>&gt;&gt; One minor issue around putting them in class/struct bodies though is that I wonder if perhaps a keyword other than func should be used? While they are functions, they aren’t methods of instances. At the very least they should probably need to be static.<br>&gt; <br>&gt; As we do with protocols, I think we should continue to treat “func &lt;operatoridentifier&gt;” specially.  That said, I’d welcome other people’s thoughts on this.  Would it be more clear to have:<br>&gt; <br>&gt; protocol P {<br>&gt;  operator ==(a : Self, b : Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; Does “operator” buy us anything there over func?  If we went this direction, it would require taking operator as a keyword.<br>&gt; <br></p><p>If it can help bring the feature in more painlessly then I think it is a worthy sacrifice in terms of reserving it as a keyword. It is not uncommon to see operator overloading taken as a special case anyways.<br></p><p><br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 31, 2016, at 11:38 PM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; As we do with protocols, I think we should continue to treat “func &lt;operatoridentifier&gt;” specially.  That said, I’d welcome other people’s thoughts on this.  Would it be more clear to have:<br>&gt;&gt; <br>&gt;&gt; protocol P {<br>&gt;&gt; operator ==(a : Self, b : Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Does “operator” buy us anything there over func?  If we went this direction, it would require taking operator as a keyword.<br>&gt;&gt; <br>&gt; <br>&gt; If it can help bring the feature in more painlessly then I think it is a worthy sacrifice in terms of reserving it as a keyword. It is not uncommon to see operator overloading taken as a special case anyways.<br></p><p>There is no semantic difference between the two, it is an aesthetic tradeoff.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 1 Feb 2016, at 04:55, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; We need multiple modules to be able to define instances of an operator, we need operators in extensions, and we need retroactive conformance to work, as with any other member.<br></p><p>Why? Like I say, the operator itself is really static, not a method of an instance, as it declares what it operates on in its parameters, just as an operator does now, the only difference is being able to declare it in class/struct for clarity. There’s also no talk of making explicit operator declarations such as Foo.==(a, b), so it seems to me that nothing will actually change functionally from the way operators are now. A class/struct conforms to an operator requirement if an operator with the appropriate signature exists.<br></p><p>We only need to consider shadowing etc. if we want to instead change operators to be instance methods where the operation is applied to self plus any other optional values, e.g-<br></p><p>	class Foo {<br>		func ==(rhs:Foo) {<br>			return self.someProperty == rhs.someProperty<br>		}<br>	}<br></p><p>But that would require operator declarations to be completely redesigned, as opposed to the proposal which simply asks for something like:<br></p><p>	class Foo {<br>		static func ==(lhs: Foo, rhs:Foo) {<br>			return lhs.someProperty == rhs.someProperty<br>		}<br>	}<br></p><p>Which is essentially identical to the things are now, only the declaration happens to be grouped with a type, rather than declared globally like we have now.<br></p><p>That said, this does raise an interesting point, as in the second example there’s nothing stopping you from declaring an operator in type Foo that has no relevance to it whatsoever (e.g- an operator involving IntegerTypes). So redesigning into instance methods may be desirable as that way the implicit parameter (self) is definitely relevant to the type where the operator is implemented. In that case yes, it would probably need to use the same rules for resolving shadowing/overrides, treating the implicit parameter as the target of the operation (so usually the value on the left, except for prefix operators).<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February  1, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 1, 2016, at 1:47 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 1 Feb 2016, at 04:55, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We need multiple modules to be able to define instances of an operator, we need operators in extensions, and we need retroactive conformance to work, as with any other member.<br>&gt; <br>&gt; Why?<br></p><p>I’m not sure which piece you’re asking about.  I’m just saying that name lookup needs to follow an algorithm, and that algorithm needs to be specified.<br></p><p>&gt; Like I say, the operator itself is really static, not a method of an instance, as it declares what it operates on in its parameters, just as an operator does now, the only difference is being able to declare it in class/struct for clarity. There’s also no talk of making explicit operator declarations such as Foo.==(a, b),<br></p><p>I agree.<br></p><p>&gt; so it seems to me that nothing will actually change functionally from the way operators are now.<br></p><p>You need to specify the lookup order, and how to determine whether something is a shadow or redefinitions.  The compiler needs to have an algorithm to decide this, and this is an important part of the behavior of the feature.  As such a proposal should specify how it works.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>February  8, 2016 at 07:00:00pm</p></header><div class="content"><p>The initial proposal mentions static members, because I thought it was only<br>a matter of moving things from one place to other and because I saw<br>something like this in C#.<br></p><p>After reading your messages, however, I have to agree that the second<br>approach, using instances members, is a much better one.<br></p><p>About the name lookup algorithm and shadow/override things, I’m afraid I do<br>not know what to say. What options do we have?<br></p><p><br>Regards,<br></p><p>-Van<br></p><p><br></p><p><br>On Mon, Feb 1, 2016 at 6:41 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Feb 1, 2016, at 1:47 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 1 Feb 2016, at 04:55, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We need multiple modules to be able to define instances of an operator,<br>&gt; we need operators in extensions, and we need retroactive conformance to<br>&gt; work, as with any other member.<br>&gt; &gt;<br>&gt; &gt; Why?<br>&gt;<br>&gt; I’m not sure which piece you’re asking about.  I’m just saying that name<br>&gt; lookup needs to follow an algorithm, and that algorithm needs to be<br>&gt; specified.<br>&gt;<br>&gt; &gt; Like I say, the operator itself is really static, not a method of an<br>&gt; instance, as it declares what it operates on in its parameters, just as an<br>&gt; operator does now, the only difference is being able to declare it in<br>&gt; class/struct for clarity. There’s also no talk of making explicit operator<br>&gt; declarations such as Foo.==(a, b),<br>&gt;<br>&gt; I agree.<br>&gt;<br>&gt; &gt; so it seems to me that nothing will actually change functionally from<br>&gt; the way operators are now.<br>&gt;<br>&gt; You need to specify the lookup order, and how to determine whether<br>&gt; something is a shadow or redefinitions.  The compiler needs to have an<br>&gt; algorithm to decide this, and this is an important part of the behavior of<br>&gt; the feature.  As such a proposal should specify how it works.<br>&gt;<br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/2e4ac39b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>February  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; After reading your messages, however, I have to agree that the second approach, using instances members, is a much better one. <br></p><p>Agreed. I think C# only uses static functions because it doesn’t have module-scope operators like Swift does. <br></p><p>Here’s what instance operators would look like with shorthand argument names:<br></p><p>struct Vector2 {<br>   func * (Self) -&gt; Self {<br>      return Self(x * $0.x, y * $0.y)<br>   }<br>}<br></p><p>While I believe that instance operators would represent the vast majority of operations, operators that use operands of different types don’t make sense to be defined in a type. I love that Swift allows that sort of thing at module scope.<br></p><p>func * (matrix: Matrix2x2, vector: Vector2) -&gt; Vector2 {…<br></p><p>I bet it makes sense to enforce that an operator is only allowed at module scope if its operands aren’t of the same type.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/1c9e0072/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 8 Feb 2016, at 22:02, Jessy Catterwaul via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; While I believe that instance operators would represent the vast majority of operations, operators that use operands of different types don’t make sense to be defined in a type. I love that Swift allows that sort of thing at module scope.<br>&gt; <br>&gt; func * (matrix: Matrix2x2, vector: Vector2) -&gt; Vector2 {…<br>&gt; <br>&gt; I bet it makes sense to enforce that an operator is only allowed at module scope if its operands aren’t of the same type.<br></p><p>Would it even need to be that complex? I would say to just allow global scope operators as well, and leave it to the developer to decide if that’s the best place to put it versus putting it into a type.<br></p><p>That said, I’m finding it hard to think of examples that really need to be in the global scope, as your example seems to me like it still makes the most sense to be placed within the Matrix2x2 type like so:<br></p><p>	func * (vector:Vector2) -&gt; Vector2 { // self is matrix2x2 }<br></p><p>Since the left hand side is still the focal point of this operator. The only case I could think of that might still require a global operator would be one that can handle arguments of type Any.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/6610f4ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/34b9659227ea084bb09a8ba4a450a162?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Jessy Catterwaul</string> &lt;mr.jessy at gmail.com&gt;<p>February  9, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; That said, I’m finding it hard to think of examples that really need to be in the global scope, as your example seems to me like it still makes the most sense to be placed within the Matrix2x2 type like so:<br>&gt; <br>&gt; 	func * (vector:Vector2) -&gt; Vector2 { // self is matrix2x2 }<br>&gt; <br>&gt; Since the left hand side is still the focal point of this operator. The only case I could think of that might still require a global operator would be one that can handle arguments of type Any.<br></p><p>Good point! I haven’t been exposed to that approach or thought of it. That might be the best way to handle things, even when operators are allowed to take more than one operand without resorting to passing them in as a tuple like we must now.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/a7b925de/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Operator implementation inside struct/class body</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>February  8, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 30, 2016, at 11:03 PM, Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since the first public betas I’d like to know why operator implementation have to be written outside the body of its owner.<br>&gt; <br>&gt; Take as example the code:<br>&gt; <br>&gt; protocol MyEquatable {<br>&gt;     @warn_unused_result<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; struct MyStruct: MyEquatable {<br>&gt;     let foo: String<br>&gt;     let bar: String<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;     return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt; }<br>&gt; <br>&gt; Why we cannot write:<br>&gt; <br>&gt; protocol MyEquatable {<br>&gt;     @warn_unused_result<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; struct MyStruct: MyEquatable {<br>&gt;     let foo: String<br>&gt;     let bar: String<br>&gt;     <br>&gt;     func ==(lhs: MyStruct, rhs: MyStruct) -&gt; Bool {<br>&gt;         return lhs.foo == rhs.foo &amp;&amp; lhs.bar == rhs.bar<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; Any thoughts?<br>&gt; <br>&gt; <br>&gt; -Van<br></p><p>+1. I’ve been meaning to write up something about this for some time. The thing I’d change is to include only the right-hand side as an argument, and use ‘self’ to refer to the left-hand side:<br></p><p>struct MyStruct: MyEquatable {<br>    let foo: String<br>    let bar: String<br>    <br>    func ==(other: MyStruct) -&gt; Bool {<br>        return self.foo == other.foo &amp;&amp; self.bar == other.bar<br>    }<br>}<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160208/d457d776/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
