<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 09:00:00pm</p></header><div class="content"><p>We currently accept function type syntax without parentheses, like:<br></p><p>  Int -&gt; Float<br>  String -&gt; ()<br></p><p>etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br></p><p>Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br></p><p>  (Int) -&gt; Float<br>  (String) -&gt; ()<br></p><p>Thoughts?<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>April 14, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br></p><p><br>Didn&#39;t know that T -&gt; U was even legal, which more or less sums up my opinion on this. <br></p><p>Does it meet Swift&#39;s philosophy? Yes<br>Does it enhance the language? I believe it does<br>Is it still required in a post-splatted world? Probably not<br>Eliminating a language inconsistency, especially a meaningless one? Yes.<br></p><p>-- E, unless I&#39;m missing something big here<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>+1<br></p><p>&gt; On Apr 14, 2016, at 11:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d82ae2358637a4680638eb4218c1e64a?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>hitstergtd+swiftevo at gmail.com</string> &lt;hitstergtd+swiftevo at gmail.com&gt;<p>April 15, 2016 at 06:00:00am</p></header><div class="content"><p>Chris,<br></p><p>The proposed syntax looks and reads so much better! +1.<br></p><p>On 15 April 2016 at 05:57, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt;<br>&gt;   Int -&gt; Float<br>&gt;   String -&gt; ()<br>&gt;<br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;<br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;<br>&gt;   (Int) -&gt; Float<br>&gt;   (String) -&gt; ()<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 9:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br></p><p>To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br></p><p>The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  Our grammar generally allows grammatically-unnecessary parentheses to be omitted (except the C-style for loop, until we killed it) — I guess you could count function call syntax, but we had strong reasons there that don&#39;t seem to apply here.  We notably chose to deviate from C statement grammar specifically to allow unnecessary parentheses to be omitted.  This would feel weirdly inconsistent with that.<br></p><p>I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>On Apr 14, 2016, at 10:21 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 9:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br></p><p>&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br></p><p>I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.  In many places in the Swift grammar we aim for consistency, even if it means a bit more punctuation in specific cases.<br></p><p>&gt; Our grammar generally allows grammatically-unnecessary parentheses to be omitted (except the C-style for loop, until we killed it) — I guess you could count function call syntax, but we had strong reasons there that don&#39;t seem to apply here.  We notably chose to deviate from C statement grammar specifically to allow unnecessary parentheses to be omitted.  This would feel weirdly inconsistent with that.<br></p><p>We allow parens to be omitted from control flow expressions, where they are redundant with paren exprs.  I don’t see how that translates to our type grammar.<br></p><p>&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br></p><p>Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change).  Being consistent between func decls and function types is quite important IMO.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Apr 14, 2016, at 10:21 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 14, 2016, at 9:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt; <br>&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.<br></p><p>&quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br></p><p>&gt;  In many places in the Swift grammar we aim for consistency, even if it means a bit more punctuation in specific cases.<br></p><p>This is not greatly in evidence.  We have a lot of special-case syntax.<br></p><p>&gt;&gt; Our grammar generally allows grammatically-unnecessary parentheses to be omitted (except the C-style for loop, until we killed it) — I guess you could count function call syntax, but we had strong reasons there that don&#39;t seem to apply here.  We notably chose to deviate from C statement grammar specifically to allow unnecessary parentheses to be omitted.  This would feel weirdly inconsistent with that.<br>&gt; <br>&gt; We allow parens to be omitted from control flow expressions, where they are redundant with paren exprs.  I don’t see how that translates to our type grammar.<br></p><p>The grammatical and semantic purpose of parentheses is identical in both grammars.<br></p><p>&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt; <br>&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change).  Being consistent between func decls and function types is quite important IMO.<br></p><p>So we should require function argument labels in function types?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt; <br>&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt; <br>&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br></p><p>Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type.  The parameter list allows things that types do not: default arguments and variadics.<br></p><p>As a concrete example, surely you aren’t arguing that we should support:<br></p><p>	let x : Int… -&gt; Int<br></p><p>are you?<br></p><p>&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt;&gt; <br>&gt;&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change).  Being consistent between func decls and function types is quite important IMO.<br>&gt; <br>&gt; So we should require function argument labels in function types?<br></p><p>Uhm, yes, we already do.  In:<br></p><p>	let x : (a : Int) -&gt; Float<br>	let y : (Int) -&gt; Float<br>	let z : Int -&gt; Float<br></p><p>x and y have different (but compatible) types. y and z have identical types (sugared differently).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 14, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt;&gt; <br>&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br>&gt; <br>&gt; Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type.  The parameter list allows things that types do not: default arguments and variadics.<br></p><p>Parameters also support different API vs internal parameter labels as well.<br></p><p>-Chris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt;&gt; <br>&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br>&gt; <br>&gt; Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type.  The parameter list allows things that types do not: default arguments and variadics.<br></p><p>Default arguments are not allowed in the type grammar.  Nor are different internal vs. external labels.<br></p><p>&gt; As a concrete example, surely you aren’t arguing that we should support:<br>&gt; <br>&gt; 	let x : Int… -&gt; Int<br>&gt; <br>&gt; are you?<br></p><p>No, but that&#39;s because the ... is a reference to the rest of the tuple and doesn&#39;t read correctly outside of one.<br></p><p>&gt;&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change).  Being consistent between func decls and function types is quite important IMO.<br>&gt;&gt; <br>&gt;&gt; So we should require function argument labels in function types?<br>&gt; <br>&gt; Uhm, yes, we already do.  In:<br>&gt; <br>&gt; 	let x : (a : Int) -&gt; Float<br>&gt; 	let y : (Int) -&gt; Float<br>&gt; 	let z : Int -&gt; Float<br>&gt; <br>&gt; x and y have different (but compatible) types. y and z have identical types (sugared differently).<br></p><p>When I said &quot;function type&quot;, I was referring to this production in the type grammar, not the type signature component of function declarations.  I&#39;m not sure how I could&#39;ve been clearer on that without actually using the names of grammatical productions.<br></p><p>My point was that allowing a function type to be written as &quot;(Int) -&gt; Float&quot; is already inconsistent with function declarations, because that is not legal function declaration syntax; you would have to write &quot;(_ : Int) -&gt; Float&quot;.<br></p><p>The current language composes naturally here, and your proposal feels like an odd extra rule.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 8:29 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br>&gt;&gt; <br>&gt;&gt; Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type.  The parameter list allows things that types do not: default arguments and variadics.<br>&gt; <br>&gt; Default arguments are not allowed in the type grammar.  Nor are different internal vs. external labels.<br>&gt; <br>&gt;&gt; As a concrete example, surely you aren’t arguing that we should support:<br>&gt;&gt; <br>&gt;&gt; 	let x : Int… -&gt; Int<br>&gt;&gt; <br>&gt;&gt; are you?<br>&gt; <br>&gt; No, but that&#39;s because the ... is a reference to the rest of the tuple and doesn&#39;t read correctly outside of one.<br>&gt; <br>&gt;&gt;&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change). Being consistent between func decls and function types is quite important IMO.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So we should require function argument labels in function types?<br>&gt;&gt; <br>&gt;&gt; Uhm, yes, we already do.  In:<br>&gt;&gt; <br>&gt;&gt; 	let x : (a : Int) -&gt; Float<br>&gt;&gt; 	let y : (Int) -&gt; Float<br>&gt;&gt; 	let z : Int -&gt; Float<br>&gt;&gt; <br>&gt;&gt; x and y have different (but compatible) types. y and z have identical types (sugared differently).<br>&gt; <br>&gt; When I said &quot;function type&quot;, I was referring to this production in the type grammar, not the type signature component of function declarations.  I&#39;m not sure how I could&#39;ve been clearer on that without actually using the names of grammatical productions.<br>&gt; <br>&gt; My point was that allowing a function type to be written as &quot;(Int) -&gt; Float&quot; is already inconsistent with function declarations, because that is not legal function declaration syntax; you would have to write &quot;(_ : Int) -&gt; Float&quot;.<br>&gt; <br>&gt; The current language composes naturally here, and your proposal feels like an odd extra rule.<br></p><p>I feel like the current language no longer represents our reality, though (or at least, our current ideal vision for reality). We&#39;ve pretty thoroughly broken the &quot;functions have one argument&quot; model. Changing the type grammar to reflect this seems good to me. I would think of it as changing the function type grammar to:<br></p><p>	function-type ::= &#39;(&#39; (type (&#39;,&#39; type)*)? &#39;)&#39; &#39;-&gt;&#39; type<br></p><p>which, since the argument list can containing 0, 1, or many individual arguments, makes the parens more grammatically necessary.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Apr 15, 2016, at 8:29 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument.  That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type.  The parameter list allows things that types do not: default arguments and variadics.<br>&gt;&gt; <br>&gt;&gt; Default arguments are not allowed in the type grammar.  Nor are different internal vs. external labels.<br>&gt;&gt; <br>&gt;&gt;&gt; As a concrete example, surely you aren’t arguing that we should support:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x : Int… -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; are you?<br>&gt;&gt; <br>&gt;&gt; No, but that&#39;s because the ... is a reference to the rest of the tuple and doesn&#39;t read correctly outside of one.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change). Being consistent between func decls and function types is quite important IMO.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So we should require function argument labels in function types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Uhm, yes, we already do.  In:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	let x : (a : Int) -&gt; Float<br>&gt;&gt;&gt; 	let y : (Int) -&gt; Float<br>&gt;&gt;&gt; 	let z : Int -&gt; Float<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x and y have different (but compatible) types. y and z have identical types (sugared differently).<br>&gt;&gt; <br>&gt;&gt; When I said &quot;function type&quot;, I was referring to this production in the type grammar, not the type signature component of function declarations.  I&#39;m not sure how I could&#39;ve been clearer on that without actually using the names of grammatical productions.<br>&gt;&gt; <br>&gt;&gt; My point was that allowing a function type to be written as &quot;(Int) -&gt; Float&quot; is already inconsistent with function declarations, because that is not legal function declaration syntax; you would have to write &quot;(_ : Int) -&gt; Float&quot;.<br>&gt;&gt; <br>&gt;&gt; The current language composes naturally here, and your proposal feels like an odd extra rule.<br>&gt; <br>&gt; I feel like the current language no longer represents our reality, though (or at least, our current ideal vision for reality). We&#39;ve pretty thoroughly broken the &quot;functions have one argument&quot; model.<br></p><p>I don&#39;t see this syntax as an offshoot of the &quot;functions always have one argument&quot; model.  I agree that that model is dead.<br></p><p>However, I don&#39;t think users require its death to be underlined and written in bold; it only ever surfaced to them in bugs anyway.  But many functions do, nonetheless, have only one argument; and because of another change to the model, where argument labels are becoming part of the function&#39;s name and not its type, that argument can be written as just a type.<br></p><p>So to me, this question is whether we add a weird special-case rule that mandates the use of parentheses because they&#39;re required in a bunch of more complex but less common situations.<br></p><p>&gt; Changing the type grammar to reflect this seems good to me. I would think of it as changing the function type grammar to:<br>&gt; <br>&gt; 	function-type ::= &#39;(&#39; (type (&#39;,&#39; type)*)? &#39;)&#39; &#39;-&gt;&#39; type<br>&gt; <br>&gt; which, since the argument list can containing 0, 1, or many individual arguments, makes the parens more grammatically necessary.<br></p><p>This is tautological.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 11:43 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 15, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Apr 15, 2016, at 8:29 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument. That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type. The parameter list allows things that types do not: default arguments and variadics.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Default arguments are not allowed in the type grammar.  Nor are different internal vs. external labels.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a concrete example, surely you aren’t arguing that we should support:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let x : Int… -&gt; Int<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; are you?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, but that&#39;s because the ... is a reference to the rest of the tuple and doesn&#39;t read correctly outside of one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change). Being consistent between func decls and function types is quite important IMO.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So we should require function argument labels in function types?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Uhm, yes, we already do.  In:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	let x : (a : Int) -&gt; Float<br>&gt;&gt;&gt;&gt; 	let y : (Int) -&gt; Float<br>&gt;&gt;&gt;&gt; 	let z : Int -&gt; Float<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x and y have different (but compatible) types. y and z have identical types (sugared differently).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When I said &quot;function type&quot;, I was referring to this production in the type grammar, not the type signature component of function declarations.  I&#39;m not sure how I could&#39;ve been clearer on that without actually using the names of grammatical productions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My point was that allowing a function type to be written as &quot;(Int) -&gt; Float&quot; is already inconsistent with function declarations, because that is not legal function declaration syntax; you would have to write &quot;(_ : Int) -&gt; Float&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current language composes naturally here, and your proposal feels like an odd extra rule.<br>&gt;&gt; <br>&gt;&gt; I feel like the current language no longer represents our reality, though (or at least, our current ideal vision for reality). We&#39;ve pretty thoroughly broken the &quot;functions have one argument&quot; model.<br>&gt; <br>&gt; I don&#39;t see this syntax as an offshoot of the &quot;functions always have one argument&quot; model.  I agree that that model is dead.<br>&gt; <br>&gt; However, I don&#39;t think users require its death to be underlined and written in bold; it only ever surfaced to them in bugs anyway.  But many functions do, nonetheless, have only one argument; and because of another change to the model, where argument labels are becoming part of the function&#39;s name and not its type, that argument can be written as just a type.<br>&gt; <br>&gt; So to me, this question is whether we add a weird special-case rule that mandates the use of parentheses because they&#39;re required in a bunch of more complex but less common situations.<br>&gt; <br>&gt;&gt; Changing the type grammar to reflect this seems good to me. I would think of it as changing the function type grammar to:<br>&gt;&gt; <br>&gt;&gt; 	function-type ::= &#39;(&#39; (type (&#39;,&#39; type)*)? &#39;)&#39; &#39;-&gt;&#39; type<br>&gt;&gt; <br>&gt;&gt; which, since the argument list can containing 0, 1, or many individual arguments, makes the parens more grammatically necessary.<br>&gt; <br>&gt; This is tautological.<br></p><p>I don&#39;t think it is just a tautology. Without encoding it in the grammar, there&#39;s an ambiguity between tuples and multiple arguments; () -&gt; T could mean either &quot;takes a single () argument&quot; or &quot;takes no arguments&quot;. We could &quot;obviously&quot; disambiguate in favor of the latter interpretation, but then you&#39;re introducing special cases in the other direction to keep the U -&gt; T syntax working.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>April 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 2:47 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Apr 15, 2016, at 11:43 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Apr 15, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Apr 15, 2016, at 8:29 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and output are peers, which feels more natural for the sort of value-to-value transform/predicate where this most commonly occurs.  Parenthesizing the input feels fussier, which contributes to a sense that the argument is just one component to producing the result.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by frequency of use in higher-use programming, not by feature count).  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with your point that many simple higher order programming examples (e.g. map, filter, etc) take a single argument. That said, I don’t agree that this means that we should syntactically privilege this special case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a parameter if it isn&#39;t a special case as a result?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Because, as I tried to explain in my original post, parameters *are* a special case.  The result type of a function is just a type. The parameter list allows things that types do not: default arguments and variadics.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Default arguments are not allowed in the type grammar.  Nor are different internal vs. external labels.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a concrete example, surely you aren’t arguing that we should support:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let x : Int… -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; are you?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; No, but that&#39;s because the ... is a reference to the rest of the tuple and doesn&#39;t read correctly outside of one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both require parentheses (unless the only argument is a trailing closure), but again, we had strong justifications for that: declarations would always be ambiguous without parens, and calls would have serious problems (and the style-wars factor would be much larger, especially now with mandatory keyword arguments by default).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right, but regardless of *why* we always require parens on Decls and ApplyExprs, we really do (and that isn’t going to change). Being consistent between func decls and function types is quite important IMO.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So we should require function argument labels in function types?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Uhm, yes, we already do.  In:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	let x : (a : Int) -&gt; Float<br>&gt;&gt;&gt;&gt;&gt; 	let y : (Int) -&gt; Float<br>&gt;&gt;&gt;&gt;&gt; 	let z : Int -&gt; Float<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x and y have different (but compatible) types. y and z have identical types (sugared differently).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When I said &quot;function type&quot;, I was referring to this production in the type grammar, not the type signature component of function declarations.  I&#39;m not sure how I could&#39;ve been clearer on that without actually using the names of grammatical productions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My point was that allowing a function type to be written as &quot;(Int) -&gt; Float&quot; is already inconsistent with function declarations, because that is not legal function declaration syntax; you would have to write &quot;(_ : Int) -&gt; Float&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The current language composes naturally here, and your proposal feels like an odd extra rule.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I feel like the current language no longer represents our reality, though (or at least, our current ideal vision for reality). We&#39;ve pretty thoroughly broken the &quot;functions have one argument&quot; model.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t see this syntax as an offshoot of the &quot;functions always have one argument&quot; model.  I agree that that model is dead.<br>&gt;&gt; <br>&gt;&gt; However, I don&#39;t think users require its death to be underlined and written in bold; it only ever surfaced to them in bugs anyway.  But many functions do, nonetheless, have only one argument; and because of another change to the model, where argument labels are becoming part of the function&#39;s name and not its type, that argument can be written as just a type.<br>&gt;&gt; <br>&gt;&gt; So to me, this question is whether we add a weird special-case rule that mandates the use of parentheses because they&#39;re required in a bunch of more complex but less common situations.<br>&gt;&gt; <br>&gt;&gt;&gt; Changing the type grammar to reflect this seems good to me. I would think of it as changing the function type grammar to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	function-type ::= &#39;(&#39; (type (&#39;,&#39; type)*)? &#39;)&#39; &#39;-&gt;&#39; type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which, since the argument list can containing 0, 1, or many individual arguments, makes the parens more grammatically necessary.<br>&gt;&gt; <br>&gt;&gt; This is tautological.<br>&gt; <br>&gt; I don&#39;t think it is just a tautology. Without encoding it in the grammar, there&#39;s an ambiguity between tuples and multiple arguments; () -&gt; T could mean either &quot;takes a single () argument&quot; or &quot;takes no arguments&quot;. We could &quot;obviously&quot; disambiguate in favor of the latter interpretation, but then you&#39;re introducing special cases in the other direction to keep the U -&gt; T syntax working.<br></p><p>This is a fair point, and one which would come up with (Int,Int) -&gt; Float as well — maybe the user really does mean to pass a single value that&#39;s an (Int,Int) pair.  I&#39;m not sure this really works out to being a special case at the user level, though, since in either model the user trying to write a function that takes a single tuple-typed parameter simply has to introduce the extra parens: (()) -&gt; Float or ((Int, Int)) -&gt; Float.  (Assuming that the type system preserves that structure in any way, of course.)<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>April 16, 2016 at 12:00:00pm</p></header><div class="content"><p>Doesn&#39;t really seem worth the trouble to me. It is fine as it is. Other<br>languages like Java and Scala allow this short hand and Swift allows it in<br>closures. Not that I am that fussed since the brackets are no big deal.<br></p><p>On Saturday, 16 April 2016, John McCall via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; On Apr 15, 2016, at 2:47 PM, Joe Groff &lt;jgroff at apple.com &lt;javascript:;&gt;&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; On Apr 15, 2016, at 11:43 AM, John McCall &lt;rjmccall at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt; On Apr 15, 2016, at 10:41 AM, Joe Groff &lt;jgroff at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt; On Apr 15, 2016, at 8:29 AM, John McCall via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; On Apr 14, 2016, at 10:50 PM, Chris Lattner &lt;clattner at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt; On Apr 14, 2016, at 10:40 PM, John McCall &lt;rjmccall at apple.com<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; To me, the unparenthesized style suggests that the input and<br>&gt; output are peers, which feels more natural for the sort of value-to-value<br>&gt; transform/predicate where this most commonly occurs.  Parenthesizing the<br>&gt; input feels fussier, which contributes to a sense that the argument is just<br>&gt; one component to producing the result.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The parentheses are grammatically unnecessary in most cases (by<br>&gt; frequency of use in higher-use programming, not by feature count).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; I agree with your point that many simple higher order programming<br>&gt; examples (e.g. map, filter, etc) take a single argument. That said, I don’t<br>&gt; agree that this means that we should syntactically privilege this special<br>&gt; case.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; &quot;Special case&quot; is a loaded phrase.  Why is it a special case as a<br>&gt; parameter if it isn&#39;t a special case as a result?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Because, as I tried to explain in my original post, parameters *are*<br>&gt; a special case.  The result type of a function is just a type. The<br>&gt; parameter list allows things that types do not: default arguments and<br>&gt; variadics.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Default arguments are not allowed in the type grammar.  Nor are<br>&gt; different internal vs. external labels.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; As a concrete example, surely you aren’t arguing that we should<br>&gt; support:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;   let x : Int… -&gt; Int<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; are you?<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; No, but that&#39;s because the ... is a reference to the rest of the<br>&gt; tuple and doesn&#39;t read correctly outside of one.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I guess the flip side is that call and declaration syntax both<br>&gt; require parentheses (unless the only argument is a trailing closure), but<br>&gt; again, we had strong justifications for that: declarations would always be<br>&gt; ambiguous without parens, and calls would have serious problems (and the<br>&gt; style-wars factor would be much larger, especially now with mandatory<br>&gt; keyword arguments by default).<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt; Right, but regardless of *why* we always require parens on Decls<br>&gt; and ApplyExprs, we really do (and that isn’t going to change). Being<br>&gt; consistent between func decls and function types is quite important IMO.<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;&gt; So we should require function argument labels in function types?<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; Uhm, yes, we already do.  In:<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt;   let x : (a : Int) -&gt; Float<br>&gt; &gt;&gt;&gt;&gt;&gt;   let y : (Int) -&gt; Float<br>&gt; &gt;&gt;&gt;&gt;&gt;   let z : Int -&gt; Float<br>&gt; &gt;&gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt;&gt; x and y have different (but compatible) types. y and z have<br>&gt; identical types (sugared differently).<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; When I said &quot;function type&quot;, I was referring to this production in<br>&gt; the type grammar, not the type signature component of function<br>&gt; declarations.  I&#39;m not sure how I could&#39;ve been clearer on that without<br>&gt; actually using the names of grammatical productions.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; My point was that allowing a function type to be written as &quot;(Int) -&gt;<br>&gt; Float&quot; is already inconsistent with function declarations, because that is<br>&gt; not legal function declaration syntax; you would have to write &quot;(_ : Int)<br>&gt; -&gt; Float&quot;.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; The current language composes naturally here, and your proposal feels<br>&gt; like an odd extra rule.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I feel like the current language no longer represents our reality,<br>&gt; though (or at least, our current ideal vision for reality). We&#39;ve pretty<br>&gt; thoroughly broken the &quot;functions have one argument&quot; model.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I don&#39;t see this syntax as an offshoot of the &quot;functions always have<br>&gt; one argument&quot; model.  I agree that that model is dead.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; However, I don&#39;t think users require its death to be underlined and<br>&gt; written in bold; it only ever surfaced to them in bugs anyway.  But many<br>&gt; functions do, nonetheless, have only one argument; and because of another<br>&gt; change to the model, where argument labels are becoming part of the<br>&gt; function&#39;s name and not its type, that argument can be written as just a<br>&gt; type.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; So to me, this question is whether we add a weird special-case rule<br>&gt; that mandates the use of parentheses because they&#39;re required in a bunch of<br>&gt; more complex but less common situations.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; Changing the type grammar to reflect this seems good to me. I would<br>&gt; think of it as changing the function type grammar to:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;     function-type ::= &#39;(&#39; (type (&#39;,&#39; type)*)? &#39;)&#39; &#39;-&gt;&#39; type<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; which, since the argument list can containing 0, 1, or many individual<br>&gt; arguments, makes the parens more grammatically necessary.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This is tautological.<br>&gt; &gt;<br>&gt; &gt; I don&#39;t think it is just a tautology. Without encoding it in the<br>&gt; grammar, there&#39;s an ambiguity between tuples and multiple arguments; () -&gt;<br>&gt; T could mean either &quot;takes a single () argument&quot; or &quot;takes no arguments&quot;.<br>&gt; We could &quot;obviously&quot; disambiguate in favor of the latter interpretation,<br>&gt; but then you&#39;re introducing special cases in the other direction to keep<br>&gt; the U -&gt; T syntax working.<br>&gt;<br>&gt; This is a fair point, and one which would come up with (Int,Int) -&gt; Float<br>&gt; as well — maybe the user really does mean to pass a single value that&#39;s an<br>&gt; (Int,Int) pair.  I&#39;m not sure this really works out to being a special case<br>&gt; at the user level, though, since in either model the user trying to write a<br>&gt; function that takes a single tuple-typed parameter simply has to introduce<br>&gt; the extra parens: (()) -&gt; Float or ((Int, Int)) -&gt; Float.  (Assuming that<br>&gt; the type system preserves that structure in any way, of course.)<br>&gt;<br>&gt; John.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160416/473aa00d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 15, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 12:40 AM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 10:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In many places in the Swift grammar we aim for consistency, even if it means a bit more punctuation in specific cases.<br>&gt; <br>&gt; This is not greatly in evidence.  We have a lot of special-case syntax.<br></p><p>I could’ve sworn I saw “getting rid of special-case syntax” as a general goal somewhere. Maybe I’m thinking of something else.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>April 15, 2016 at 03:00:00am</p></header><div class="content"><p>+1.  The only times I&#39;ve ever had to use this outside of HoFs were dirty, dirty hacks that probably should have used this anyway.  I can stomach an extra bit of syntax everywhere if it means removing an inconsistency in the wider language.<br></p><p>~Robert Widmann<br></p><p>2016/04/15 0:57、Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April 15, 2016 at 01:00:00pm</p></header><div class="content"><p>Chris,<br></p><p>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br></p><p>I don&#39;t care about this particular question too much, although I still prefer less parenthesis where possible.<br></p><p>But I fear that going this way, we&#39;ll soon arrive at requiring parenthesis for the block arguments:<br></p><p>do_something { foo in <br>  ...<br>}<br></p><p>and that (the parenthesis in blocks) is something I would love to avoid.<br></p><p>Note how all of your arguments would apply to the blocks as well.<br></p><p>A.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/ea43e613/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>On Apr 15, 2016, at 12:47 AM, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; wrote:<br>&gt; Chris,<br>&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt;  (Int) -&gt; Float<br>&gt;&gt;  (String) -&gt; ()<br>&gt; <br>&gt; I don&#39;t care about this particular question too much, although I still prefer less parenthesis where possible.<br>&gt; <br>&gt; But I fear that going this way, we&#39;ll soon arrive at requiring parenthesis for the block arguments:<br>&gt; <br>&gt; do_something { foo in <br>&gt;   ...<br>&gt; }<br>&gt; <br>&gt; and that (the parenthesis in blocks) is something I would love to avoid.<br></p><p>I see your concern, and while someone might propose that, I would be pretty strongly against it.  The closure parameter syntax is already magical in many ways (e.g. you can elide the &quot;-&gt; ReturnType” before in, so I don’t see a reason to mechanically force alignment with type syntax.  Further, closures are written much more often than function types, so terseness is a lot more beneficial.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/97c83036/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>April 15, 2016 at 12:00:00pm</p></header><div class="content"><p>+1 Makes language cleaner and more consistent. <br></p><p>&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>If the original rationale is gone, shouldn’t we also get rid of the empty tuple-type and replace it by a full-blown Void instead of Void being a typealis for the empty tuple?<br></p><p> (Int) -&gt; Float<br> (String) -&gt; Void<br> () -&gt; Void<br> () -&gt; Double<br></p><p>It looks more consistent to me.<br></p><p>&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 to the proposal<br></p><p>&gt; On 15 Apr 2016, at 13:11, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If the original rationale is gone, shouldn’t we also get rid of the empty tuple-type and replace it by a full-blown Void instead of Void being a typealis for the empty tuple?<br>&gt; <br>&gt; (Int) -&gt; Float<br>&gt; (String) -&gt; Void<br>&gt; () -&gt; Void<br>&gt; () -&gt; Double<br>&gt; <br>&gt; It looks more consistent to me.<br></p><p>Not sure about whether I’m a +1 to this; although I use Void everywhere already, I kind of get the rationale behind it being a zero element tuple, as single return types are basically one element tuples, and you can return tuples of any size you like.<br></p><p>Also, as an aside, I kind of liked that all functions took a tuple as their sole argument; I only use variadic parameters where they’re required for literal conformance (and I’ve no idea how else you’d handle that), but I suppose that ship has sailed.<br></p><p>&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt; <br>&gt;&gt; Int -&gt; Float<br>&gt;&gt; String -&gt; ()<br>&gt;&gt; <br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 15, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 5:11 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; If the original rationale is gone, shouldn’t we also get rid of the empty tuple-type and replace it by a full-blown Void instead of Void being a typealis for the empty tuple?<br></p><p>This could be done, but it would make the language larger and less consistent.  It would require introducing a new concept (a first class Void type).  Further, at some point we may have the ability to define algorithms over arbitrary width tuples (e.g. perhaps like C++ variadic templates) and that benefits from having the empty tuple as a base case.<br></p><p>-Chris<br></p><p><br>&gt; (Int) -&gt; Float<br>&gt; (String) -&gt; Void<br>&gt; () -&gt; Void<br>&gt; () -&gt; Double<br>&gt; <br>&gt; It looks more consistent to me.<br>&gt; <br>&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt; <br>&gt;&gt; Int -&gt; Float<br>&gt;&gt; String -&gt; ()<br>&gt;&gt; <br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05e222e6ef4d84013bb3baeb0e25c90b?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Patrick Gili</string> &lt;gili.patrick.r at gili-labs.com&gt;<p>April 16, 2016 at 01:00:00pm</p></header><div class="content"><p>As an alternative, could we require the parens on the return. For example:<br></p><p>(Int) -&gt; (Float)<br>(String) -&gt; ()<br>() -&gt; ()<br>() -&gt; (Double)<br></p><p>This looks cleaner, improves consistency, and simplifies the syntax (i.e., no need to remember when parens are necessary).<br></p><p>-Patrick<br></p><p>&gt; On Apr 15, 2016, at 1:38 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 15, 2016, at 5:11 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If the original rationale is gone, shouldn’t we also get rid of the empty tuple-type and replace it by a full-blown Void instead of Void being a typealis for the empty tuple?<br>&gt; <br>&gt; This could be done, but it would make the language larger and less consistent.  It would require introducing a new concept (a first class Void type).  Further, at some point we may have the ability to define algorithms over arbitrary width tuples (e.g. perhaps like C++ variadic templates) and that benefits from having the empty tuple as a base case.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; Void<br>&gt;&gt; () -&gt; Void<br>&gt;&gt; () -&gt; Double<br>&gt;&gt; <br>&gt;&gt; It looks more consistent to me.<br>&gt;&gt; <br>&gt;&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Int -&gt; Float<br>&gt;&gt;&gt; String -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt; (String) -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Apr 16, 2016, at 12:10 PM, Patrick Gili via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As an alternative, could we require the parens on the return. For example:<br>&gt; <br>&gt; (Int) -&gt; (Float)<br>&gt; (String) -&gt; ()<br>&gt; () -&gt; ()<br>&gt; () -&gt; (Double)<br>&gt; <br>&gt; This looks cleaner, improves consistency, and simplifies the syntax (i.e., no need to remember when parens are necessary).<br>&gt; <br>&gt; -Patrick<br></p><p>I’m not sure it’s “cleaner” per se, but I agree with the rest. My earlier +1 may have been premature…<br></p><p>- Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 16, 2016, at 10:10 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt; <br>&gt; As an alternative, could we require the parens on the return. For example:<br>&gt; <br>&gt; (Int) -&gt; (Float)<br>&gt; (String) -&gt; ()<br>&gt; () -&gt; ()<br>&gt; () -&gt; (Double)<br>&gt; <br>&gt; This looks cleaner, improves consistency, and simplifies the syntax (i.e., no need to remember when parens are necessary).<br></p><p>-1 from me.  And the rationale that I provided for this pitch doesn’t support it: unlike arguments, return types really are just types, they don’t align with other syntactic productions that have magic argument behavior.<br></p><p>I’ll write up a formal proposal for more discussion.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; -Patrick<br>&gt; <br>&gt;&gt; On Apr 15, 2016, at 1:38 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 15, 2016, at 5:11 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If the original rationale is gone, shouldn’t we also get rid of the empty tuple-type and replace it by a full-blown Void instead of Void being a typealis for the empty tuple?<br>&gt;&gt; <br>&gt;&gt; This could be done, but it would make the language larger and less consistent.  It would require introducing a new concept (a first class Void type).  Further, at some point we may have the ability to define algorithms over arbitrary width tuples (e.g. perhaps like C++ variadic templates) and that benefits from having the empty tuple as a base case.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt; (String) -&gt; Void<br>&gt;&gt;&gt; () -&gt; Void<br>&gt;&gt;&gt; () -&gt; Double<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It looks more consistent to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Int -&gt; Float<br>&gt;&gt;&gt;&gt; String -&gt; ()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Int) -&gt; Float<br>&gt;&gt;&gt;&gt; (String) -&gt; ()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Apr 16, 2016, at 8:48 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 16, 2016, at 10:10 AM, Patrick Gili &lt;gili.patrick.r at gili-labs.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As an alternative, could we require the parens on the return. For example:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; (Float)<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; () -&gt; ()<br>&gt;&gt; () -&gt; (Double)<br>&gt;&gt; <br>&gt;&gt; This looks cleaner, improves consistency, and simplifies the syntax (i.e., no need to remember when parens are necessary).<br>&gt; <br>&gt; -1 from me.  And the rationale that I provided for this pitch doesn’t support it: unlike arguments, return types really are just types, they don’t align with other syntactic productions that have magic argument behavior.<br>&gt; <br>&gt; I’ll write up a formal proposal for more discussion.<br></p><p>Here is the proposal:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md<br></p><p>We can discuss this more when it is scheduled for review.<br></p><p>Thanks all,<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72cc28f12d423d7d87c5e20e8de0966c?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Ilya Belenkiy</string> &lt;ilya.belenkiy at gmail.com&gt;<p>April 15, 2016 at 04:00:00pm</p></header><div class="content"><p>I understand the reasoning, but I really like and often use the shorthand<br>notation. I hope that it stays.<br></p><p>On Fri, Apr 15, 2016 at 12:58 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; We currently accept function type syntax without parentheses, like:<br>&gt;<br>&gt;   Int -&gt; Float<br>&gt;   String -&gt; ()<br>&gt;<br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat<br>&gt; all functions as taking a single parameter (which was often of tuple type)<br>&gt; and producing a tuple value (which was sometimes a tuple, in the case of<br>&gt; void and multiple return values).  However, we’ve long since moved on from<br>&gt; that early design point: there are a number of things that you can only do<br>&gt; in a parameter list now (varargs, default args, etc), implicit tuple splat<br>&gt; has been removed, and  the compiler has long ago stopped modeling function<br>&gt; parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;<br>&gt; Given all this, I think it makes sense to go for syntactic uniformity<br>&gt; between parameter list and function types, and just require parenthesis on<br>&gt; the argument list.  The types above can be trivially written as:<br>&gt;<br>&gt;   (Int) -&gt; Float<br>&gt;   (String) -&gt; ()<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/8d699fef/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 15, 2016 at 11:00:00am</p></header><div class="content"><p>Hmm... I don&#39;t think this is clearer:<br></p><p>    let fn: (Int) -&gt; (Int) -&gt; Int<br></p><p>I think it&#39;s much less readable and really, the () are syntactically redundant: the -&gt; is really what distinguishes this as a function.<br></p><p>Also, this would look like a error now:<br></p><p>    let fn: (Int) -&gt; ()<br></p><p>Did the user mean that it returns nothing, or did they forget the rest of the function signature?<br></p><p>I&#39;d like to see more consistency and less redundancy, including special cases, in the language in general, but this change just seems to make it different in another way, but still not consistent throughout the language constructs.<br></p><p>-David<br></p><p><br>&gt; On Apr 14, 2016, at 9:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/c74c6b00/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 11:27 AM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; <br>&gt; Hmm... I don&#39;t think this is clearer:<br>&gt; <br>&gt;     let fn: (Int) -&gt; (Int) -&gt; Int<br>&gt; <br>&gt; I think it&#39;s much less readable and really, the () are syntactically redundant: the -&gt; is really what distinguishes this as a function.<br>&gt; <br>&gt; Also, this would look like a error now:<br>&gt; <br>&gt;     let fn: (Int) -&gt; ()<br>&gt; <br>&gt; Did the user mean that it returns nothing, or did they forget the rest of the function signature?<br></p><p>Hi David,<br></p><p>I’m not sure what you’re saying here.  The two types above are already valid, and this proposal doesn’t affect that.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; I&#39;d like to see more consistency and less redundancy, including special cases, in the language in general, but this change just seems to make it different in another way, but still not consistent throughout the language constructs.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 14, 2016, at 9:57 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt; <br>&gt;&gt;  Int -&gt; Float<br>&gt;&gt;  String -&gt; ()<br>&gt;&gt; <br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt;  (Int) -&gt; Float<br>&gt;&gt;  (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/fa72b834/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 15, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Apr 15, 2016, at 1:07 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 15, 2016, at 11:27 AM, David Owens II &lt;david at owensd.io &lt;mailto:david at owensd.io&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hmm... I don&#39;t think this is clearer:<br>&gt;&gt; <br>&gt;&gt;     let fn: (Int) -&gt; (Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; I think it&#39;s much less readable and really, the () are syntactically redundant: the -&gt; is really what distinguishes this as a function.<br>&gt;&gt; <br>&gt;&gt; Also, this would look like a error now:<br>&gt;&gt; <br>&gt;&gt;     let fn: (Int) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Did the user mean that it returns nothing, or did they forget the rest of the function signature?<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt; I’m not sure what you’re saying here.  The two types above are already valid, and this proposal doesn’t affect that.<br>&gt; <br>&gt; -Chris<br></p><p>At the core, I guess it’s just a dislike of the different behaviors for function declarations in the system in general. Your propose just exposes a weirdness with empty parameter lists and the typealias for void: ().<br></p><p>It’s a bit odd that the () mean different things depending on the side of the “-&gt;” they are on. The left side is an empty parameter list, the right side is a void type.<br></p><p>Now, I get your argument is to get rid of the difference between:<br></p><p>    let f: Int -&gt; ()<br>    let g: (Int, Int) -&gt; ()<br></p><p>I guess I’m more of the opinion of David Hart, this change should also remove the typealias for () being void.<br></p><p>    let f: (Int) -&gt; Void<br>    let g: (Int, Int) -&gt; Void<br></p><p><br>Overall, I think the change is ok, but doesn’t really add any significant clarity to function declarations. I feel like there are already a lot of weirdness in general around them.<br></p><p>See:<br></p><p>typealias Functor = (to: Int, from: Int) -&gt; Int<br>let g: (hi: Int, bye: Int) -&gt; Int = { $0 - $1 }<br></p><p>func sum(x: Int, y: Int) -&gt; Int {<br>    return x + y<br>}<br></p><p>func mult(x: Int, y: Int) -&gt; Int {<br>    return x * y<br>}<br></p><p>func f(n: Int, _ m: Int, _ c: Functor) -&gt; Int {<br>    return c(to: n, from: m)<br>}<br></p><p><br>f(1, 2, sum)    // output: 3<br>f(1, 2, mult)   // output: 2<br>f(1, 2, g)      // output: -1<br></p><p>It’s weird to me that we can essentially erase the parameter names and fallback to just the type signatures, but that can be a talk for another day.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160415/13ad62de/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 16, 2016 at 09:00:00pm</p></header><div class="content"><p>On Apr 15, 2016, at 5:04 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt; It’s weird to me that we can essentially erase the parameter names and fallback to just the type signatures, but that can be a talk for another day.<br></p><p>I agree that that is odd.  In my opinion, it should be accepted to convert from a function type with labels to one without (or visa-versa), but not from a function type with one set of labels to one with another set.  This is a different topic though.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br></p><p>While it&#39;s technically correct, I agree with John&#39;s assessment that this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people and doesn&#39;t confuse the compiler; removing it would require extra punctuation for no particular reason. It would also become inconsistent with the paren-less `{ param in … }` syntax, which I think is very important for keeping usage sites simple and clean.<br></p><p>What I think we *should* eliminate, however, is using `Void` to mean &quot;no arguments&quot; in a closure type. `Void -&gt; Int` should mean that the type takes one argument which happens to be an empty tuple. If you want no arguments, write `() -&gt; Int`. Similarly, a typedef for a 2-tuple (like `Dictionary.Element`) should be recognized as one tuple parameter, not two singleton parameters. With that in place, `T -&gt; U` becomes merely a convenient shorthand for the canonical form, `(T) -&gt; U`.<br></p><p>I mean, it&#39;s not that big a deal; if you remove it, everyone will type extra parentheses and live with it. But recognize that doing so would improve the language, not the end-user experience.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 15, 2016 at 04:00:00pm</p></header><div class="content"><p>So, `Void-&gt;Int` functions would work like this?<br>let foo = bar(()) // returns Int<br></p><p>&gt; On Apr 15, 2016, at 3:23 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What I think we *should* eliminate, however, is using `Void` to mean &quot;no arguments&quot; in a closure type. `Void -&gt; Int` should mean that the type takes one argument which happens to be an empty tuple. If you want no arguments, write `() -&gt; Int`.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 15, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; So, `Void-&gt;Int` functions would work like this?<br>&gt; let foo = bar(()) // returns Int<br></p><p>Yes.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 18, 2016 at 04:00:00pm</p></header><div class="content"><p>+1<br></p><p>I am against introducing more parentheses because the resulting code is much more unreadable IMO (those additional parentheses will typically appear in argument lists, which means that the additional parentheses will be nested in the parentheses of the argument list). As someone else said, the arrow already clearly marks this as a function type and clearly separates argument from result type. Adding parentheses is just adding punctuation noise.<br></p><p>-Thorsten <br></p><p>Am 15.04.2016 um 22:23 schrieb Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt;:<br></p><p>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; While it&#39;s technically correct, I agree with John&#39;s assessment that this is &quot;fussy&quot;. `T -&gt; U` doesn&#39;t confuse people and doesn&#39;t confuse the compiler; removing it would require extra punctuation for no particular reason. It would also become inconsistent with the paren-less `{ param in … }` syntax, which I think is very important for keeping usage sites simple and clean.<br>&gt; <br>&gt; What I think we *should* eliminate, however, is using `Void` to mean &quot;no arguments&quot; in a closure type. `Void -&gt; Int` should mean that the type takes one argument which happens to be an empty tuple. If you want no arguments, write `() -&gt; Int`. Similarly, a typedef for a 2-tuple (like `Dictionary.Element`) should be recognized as one tuple parameter, not two singleton parameters. With that in place, `T -&gt; U` becomes merely a convenient shorthand for the canonical form, `(T) -&gt; U`.<br>&gt; <br>&gt; I mean, it&#39;s not that big a deal; if you remove it, everyone will type extra parentheses and live with it. But recognize that doing so would improve the language, not the end-user experience.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>April 19, 2016 at 09:00:00am</p></header><div class="content"><p>Noooooo :(<br></p><p>I understand and appreciate the rationale, uniformity between declaration and use site being a good thing, but IMHO the proposal just brings unnecessary noise, far outweighing the small benefit of having the symmetry.<br></p><p>1. What I’m worried the most is the “parentheses blindness”. In higher-order functions, or just when I take a simple callback closure, there are just a lot of parentheses (add to that generics, and there’s a lot of angled brackets too). And it just becomes hard to instantly decipher. To me, `func blah(f: Int -&gt; Float) -&gt; String` is easier to read that `func blah(f: (Int) -&gt; Float) -&gt; String`. Or just notice how noisy `(f: () -&gt; ())` is. This is why I like the convention of using `Void` for void-returning functions. There’s less noise in `(f: () -&gt; Void)`, and even better in `(f: Int -&gt; Void)`. I don’t have to mentally match parentheses, because whenever possible, there’s just one set of parens around the main function declaration. When punctuation like parentheses is used sparingly, it carries a lot of weight. Requiring parentheses around T in T -&gt; U doesn’t seem to have a significant reason aside from style/taste.<br></p><p>2. I’m not convinced at all that `(Foo) -&gt; Bar` is immediately more obvious to people. I don’t have data to back it up, but my intuition is that `Foo -&gt; Bar` is simple and understandable. “A function from Foo to Bar”, I’m thinking. I don’t have to mentally parse the vacuous parentheses, just to conclude that there’s, in fact, just one parameter. And when there is more than one parameter, the parentheses in `(Foo, Bar) -&gt; Baz` instantly carry more weight.<br></p><p>3. Swift has been really good at removing unnecessary punctuation. Parentheses in if statements, semicolons, shortcut forms of closures, etc. This is a good thing. As I said before, using punctuation only when it matters makes it stand out, and in places where it doesn’t, by removing it we’re increasing the signal-to-noise ratio. To me, parentheses in `(Foo) -&gt; Bar` don’t matter. I can see why one could argue for them, or prefer them, but it seems like a merely stylistic choice. Let’s keep them where it matters, and leave this to personal preference.<br></p><p>Best,<br>— Radek<br></p><p>&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt; <br>&gt;  Int -&gt; Float<br>&gt;  String -&gt; ()<br>&gt; <br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt; <br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt; <br>&gt;  (Int) -&gt; Float<br>&gt;  (String) -&gt; ()<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 19, 2016 at 10:00:00am</p></header><div class="content"><p>+1 to everything Radek said<br></p><p>-Thorsten <br></p><p>&gt; Am 19.04.2016 um 09:46 schrieb Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Noooooo :(<br>&gt; <br>&gt; I understand and appreciate the rationale, uniformity between declaration and use site being a good thing, but IMHO the proposal just brings unnecessary noise, far outweighing the small benefit of having the symmetry.<br>&gt; <br>&gt; 1. What I’m worried the most is the “parentheses blindness”. In higher-order functions, or just when I take a simple callback closure, there are just a lot of parentheses (add to that generics, and there’s a lot of angled brackets too). And it just becomes hard to instantly decipher. To me, `func blah(f: Int -&gt; Float) -&gt; String` is easier to read that `func blah(f: (Int) -&gt; Float) -&gt; String`. Or just notice how noisy `(f: () -&gt; ())` is. This is why I like the convention of using `Void` for void-returning functions. There’s less noise in `(f: () -&gt; Void)`, and even better in `(f: Int -&gt; Void)`. I don’t have to mentally match parentheses, because whenever possible, there’s just one set of parens around the main function declaration. When punctuation like parentheses is used sparingly, it carries a lot of weight. Requiring parentheses around T in T -&gt; U doesn’t seem to have a significant reason aside from style/taste.<br>&gt; <br>&gt; 2. I’m not convinced at all that `(Foo) -&gt; Bar` is immediately more obvious to people. I don’t have data to back it up, but my intuition is that `Foo -&gt; Bar` is simple and understandable. “A function from Foo to Bar”, I’m thinking. I don’t have to mentally parse the vacuous parentheses, just to conclude that there’s, in fact, just one parameter. And when there is more than one parameter, the parentheses in `(Foo, Bar) -&gt; Baz` instantly carry more weight.<br>&gt; <br>&gt; 3. Swift has been really good at removing unnecessary punctuation. Parentheses in if statements, semicolons, shortcut forms of closures, etc. This is a good thing. As I said before, using punctuation only when it matters makes it stand out, and in places where it doesn’t, by removing it we’re increasing the signal-to-noise ratio. To me, parentheses in `(Foo) -&gt; Bar` don’t matter. I can see why one could argue for them, or prefer them, but it seems like a merely stylistic choice. Let’s keep them where it matters, and leave this to personal preference.<br>&gt; <br>&gt; Best,<br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt; <br>&gt;&gt; Int -&gt; Float<br>&gt;&gt; String -&gt; ()<br>&gt;&gt; <br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 19, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 19, 2016, at 2:46 AM, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Noooooo :(<br>&gt; <br>&gt; I understand and appreciate the rationale, uniformity between declaration and use site being a good thing, but IMHO the proposal just brings unnecessary noise, far outweighing the small benefit of having the symmetry.<br>&gt; <br>&gt; 1. What I’m worried the most is the “parentheses blindness”. In higher-order functions, or just when I take a simple callback closure, there are just a lot of parentheses (add to that generics, and there’s a lot of angled brackets too). And it just becomes hard to instantly decipher. To me, `func blah(f: Int -&gt; Float) -&gt; String` is easier to read that `func blah(f: (Int) -&gt; Float) -&gt; String`. Or just notice how noisy `(f: () -&gt; ())` is. This is why I like the convention of using `Void` for void-returning functions. There’s less noise in `(f: () -&gt; Void)`, and even better in `(f: Int -&gt; Void)`. I don’t have to mentally match parentheses, because whenever possible, there’s just one set of parens around the main function declaration. When punctuation like parentheses is used sparingly, it carries a lot of weight. Requiring parentheses around T in T -&gt; U doesn’t seem to have a significant reason aside from style/taste.<br>&gt; <br>&gt; 2. I’m not convinced at all that `(Foo) -&gt; Bar` is immediately more obvious to people. I don’t have data to back it up, but my intuition is that `Foo -&gt; Bar` is simple and understandable. “A function from Foo to Bar”, I’m thinking. I don’t have to mentally parse the vacuous parentheses, just to conclude that there’s, in fact, just one parameter. And when there is more than one parameter, the parentheses in `(Foo, Bar) -&gt; Baz` instantly carry more weight.<br>&gt; <br>&gt; 3. Swift has been really good at removing unnecessary punctuation. Parentheses in if statements, semicolons, shortcut forms of closures, etc. This is a good thing. As I said before, using punctuation only when it matters makes it stand out, and in places where it doesn’t, by removing it we’re increasing the signal-to-noise ratio. To me, parentheses in `(Foo) -&gt; Bar` don’t matter. I can see why one could argue for them, or prefer them, but it seems like a merely stylistic choice. Let’s keep them where it matters, and leave this to personal preference.<br></p><p>Thanks for posting this Radek.  I agree with everything you said.<br></p><p>&gt; <br>&gt; Best,<br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt; <br>&gt;&gt; Int -&gt; Float<br>&gt;&gt; String -&gt; ()<br>&gt;&gt; <br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April 19, 2016 at 09:00:00am</p></header><div class="content"><p>-1<br></p><p>The parenthesis don&#39;t add anything, in my opinion. I could live with the<br>change, I simply don&#39;t see much benefit.<br></p><p>On Tue, Apr 19, 2016 at 8:45 AM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On Apr 19, 2016, at 2:46 AM, Radosław Pietruszewski via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Noooooo :(<br>&gt; &gt;<br>&gt; &gt; I understand and appreciate the rationale, uniformity between<br>&gt; declaration and use site being a good thing, but IMHO the proposal just<br>&gt; brings unnecessary noise, far outweighing the small benefit of having the<br>&gt; symmetry.<br>&gt; &gt;<br>&gt; &gt; 1. What I’m worried the most is the “parentheses blindness”. In<br>&gt; higher-order functions, or just when I take a simple callback closure,<br>&gt; there are just a lot of parentheses (add to that generics, and there’s a<br>&gt; lot of angled brackets too). And it just becomes hard to instantly<br>&gt; decipher. To me, `func blah(f: Int -&gt; Float) -&gt; String` is easier to read<br>&gt; that `func blah(f: (Int) -&gt; Float) -&gt; String`. Or just notice how noisy<br>&gt; `(f: () -&gt; ())` is. This is why I like the convention of using `Void` for<br>&gt; void-returning functions. There’s less noise in `(f: () -&gt; Void)`, and even<br>&gt; better in `(f: Int -&gt; Void)`. I don’t have to mentally match parentheses,<br>&gt; because whenever possible, there’s just one set of parens around the main<br>&gt; function declaration. When punctuation like parentheses is used sparingly,<br>&gt; it carries a lot of weight. Requiring parentheses around T in T -&gt; U<br>&gt; doesn’t seem to have a significant reason aside from style/taste.<br>&gt; &gt;<br>&gt; &gt; 2. I’m not convinced at all that `(Foo) -&gt; Bar` is immediately more<br>&gt; obvious to people. I don’t have data to back it up, but my intuition is<br>&gt; that `Foo -&gt; Bar` is simple and understandable. “A function from Foo to<br>&gt; Bar”, I’m thinking. I don’t have to mentally parse the vacuous parentheses,<br>&gt; just to conclude that there’s, in fact, just one parameter. And when there<br>&gt; is more than one parameter, the parentheses in `(Foo, Bar) -&gt; Baz`<br>&gt; instantly carry more weight.<br>&gt; &gt;<br>&gt; &gt; 3. Swift has been really good at removing unnecessary punctuation.<br>&gt; Parentheses in if statements, semicolons, shortcut forms of closures, etc.<br>&gt; This is a good thing. As I said before, using punctuation only when it<br>&gt; matters makes it stand out, and in places where it doesn’t, by removing it<br>&gt; we’re increasing the signal-to-noise ratio. To me, parentheses in `(Foo) -&gt;<br>&gt; Bar` don’t matter. I can see why one could argue for them, or prefer them,<br>&gt; but it seems like a merely stylistic choice. Let’s keep them where it<br>&gt; matters, and leave this to personal preference.<br>&gt;<br>&gt; Thanks for posting this Radek.  I agree with everything you said.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; — Radek<br>&gt; &gt;<br>&gt; &gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Int -&gt; Float<br>&gt; &gt;&gt; String -&gt; ()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; etc.  The original rationale aligned with the fact that we wanted to<br>&gt; treat all functions as taking a single parameter (which was often of tuple<br>&gt; type) and producing a tuple value (which was sometimes a tuple, in the case<br>&gt; of void and multiple return values).  However, we’ve long since moved on<br>&gt; from that early design point: there are a number of things that you can<br>&gt; only do in a parameter list now (varargs, default args, etc), implicit<br>&gt; tuple splat has been removed, and  the compiler has long ago stopped<br>&gt; modeling function parameters this way.  Beyond that, it eliminates one<br>&gt; potential style war.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity<br>&gt; between parameter list and function types, and just require parenthesis on<br>&gt; the argument list.  The types above can be trivially written as:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; (Int) -&gt; Float<br>&gt; &gt;&gt; (String) -&gt; ()<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Thoughts?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/355d4641/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 19, 2016 at 04:00:00pm</p></header><div class="content"><p>Although I personally have no strong opinion on this proposal yet,<br>it is clear for me that something is wrong with function type sintax&amp;Void&amp;().<br></p><p>Right now we have such situation, when all the next code is OK, can be <br>compiled and run, but each fX has the same meaning:<br></p><p>typealias f1 = () -&gt; ()<br>typealias f2 = () -&gt; Void<br>typealias f3 = () -&gt; (Void)<br>typealias f4 = () -&gt; (())<br>typealias f5 = () -&gt; ((((((()))))))<br></p><p>typealias f6 = Void -&gt; ()<br>typealias f7 = Void -&gt; Void<br>typealias f8 = Void -&gt; (Void)<br>typealias f9 = Void -&gt; (())<br>typealias f10 = Void -&gt; ((((((()))))))<br></p><p>typealias f11 = (Void) -&gt; ()<br>typealias f12 = ((((((())))))) -&gt; Void<br>typealias f13 = (()) -&gt; ((Void))<br>typealias f14 = ((())) -&gt; (())<br>typealias f15 = ((Void)) -&gt; ((((((()))))))<br></p><p>func f() -&gt; Void {<br></p><p>}<br></p><p>let fv1 : f1 = f<br>let fv2 : f2 = f<br>let fv3 : f3 = f<br>let fv4 : f4 = f<br>let fv5 : f5 = f<br>let fv6 : f6 = f<br>let fv7 : f7 = f<br>let fv8 : f8 = f<br>let fv9 : f9 = f<br>let fv10 : f10 = f<br>let fv11 : f11 = f<br>let fv12 : f12 = f<br>let fv13 : f13 = f<br>let fv14 : f14 = f<br>let fv15 : f15 = f<br></p><p><br>Don&#39;t you think something is wrong with this?<br>Let&#39;s discuss ?<br></p><p>Personally I probably prefer to replace &quot;()&quot; with Void as a result of <br>function, and probably replace Void with &quot;()&quot; as parameters part. And don&#39;t <br>allow empty-tuple-in-tuple at least for function type declaration + don&#39;t <br>allow Void-in-tuple. I.e. in this case we&#39;ll have only this as alowed <br>declaration:<br></p><p>typealias ftype = () -&gt; Void<br></p><p>IMO the only clear, explicit, often used variant.<br></p><p><br>On 19.04.2016 10:46, Radosław Pietruszewski via swift-evolution wrote:<br>&gt; Noooooo :(<br>&gt;<br>&gt; I understand and appreciate the rationale, uniformity between declaration and use site being a good thing, but IMHO the proposal just brings unnecessary noise, far outweighing the small benefit of having the symmetry.<br>&gt;<br>&gt; 1. What I’m worried the most is the “parentheses blindness”. In higher-order functions, or just when I take a simple callback closure, there are just a lot of parentheses (add to that generics, and there’s a lot of angled brackets too). And it just becomes hard to instantly decipher. To me, `func blah(f: Int -&gt; Float) -&gt; String` is easier to read that `func blah(f: (Int) -&gt; Float) -&gt; String`. Or just notice how noisy `(f: () -&gt; ())` is. This is why I like the convention of using `Void` for void-returning functions. There’s less noise in `(f: () -&gt; Void)`, and even better in `(f: Int -&gt; Void)`. I don’t have to mentally match parentheses, because whenever possible, there’s just one set of parens around the main function declaration. When punctuation like parentheses is used sparingly, it carries a lot of weight. Requiring parentheses around T in T -&gt; U doesn’t seem to have a significant reason aside from style/taste.<br>&gt;<br>&gt; 2. I’m not convinced at all that `(Foo) -&gt; Bar` is immediately more obvious to people. I don’t have data to back it up, but my intuition is that `Foo -&gt; Bar` is simple and understandable. “A function from Foo to Bar”, I’m thinking. I don’t have to mentally parse the vacuous parentheses, just to conclude that there’s, in fact, just one parameter. And when there is more than one parameter, the parentheses in `(Foo, Bar) -&gt; Baz` instantly carry more weight.<br>&gt;<br>&gt; 3. Swift has been really good at removing unnecessary punctuation. Parentheses in if statements, semicolons, shortcut forms of closures, etc. This is a good thing. As I said before, using punctuation only when it matters makes it stand out, and in places where it doesn’t, by removing it we’re increasing the signal-to-noise ratio. To me, parentheses in `(Foo) -&gt; Bar` don’t matter. I can see why one could argue for them, or prefer them, but it seems like a merely stylistic choice. Let’s keep them where it matters, and leave this to personal preference.<br>&gt;<br>&gt; Best,<br>&gt; — Radek<br>&gt;<br>&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt;<br>&gt;&gt;  Int -&gt; Float<br>&gt;&gt;  String -&gt; ()<br>&gt;&gt;<br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt;<br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt;<br>&gt;&gt;  (Int) -&gt; Float<br>&gt;&gt;  (String) -&gt; ()<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7411024ff3fb3fdbb0624c41b72a1b92?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Alan Skipp</string> &lt;al_skipp at icloud.com&gt;<p>April 19, 2016 at 03:00:00pm</p></header><div class="content"><p>Completely agree with Radek. I avoid unnecessary punctuation whenever possible, which increases legibility IMHO; so this pernickety proposal makes me sad : (<br></p><p>&gt; On 19 Apr 2016, at 08:46, Radosław Pietruszewski via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Noooooo :(<br>&gt; <br>&gt; I understand and appreciate the rationale, uniformity between declaration and use site being a good thing, but IMHO the proposal just brings unnecessary noise, far outweighing the small benefit of having the symmetry.<br>&gt; <br>&gt; 1. What I’m worried the most is the “parentheses blindness”. In higher-order functions, or just when I take a simple callback closure, there are just a lot of parentheses (add to that generics, and there’s a lot of angled brackets too). And it just becomes hard to instantly decipher. To me, `func blah(f: Int -&gt; Float) -&gt; String` is easier to read that `func blah(f: (Int) -&gt; Float) -&gt; String`. Or just notice how noisy `(f: () -&gt; ())` is. This is why I like the convention of using `Void` for void-returning functions. There’s less noise in `(f: () -&gt; Void)`, and even better in `(f: Int -&gt; Void)`. I don’t have to mentally match parentheses, because whenever possible, there’s just one set of parens around the main function declaration. When punctuation like parentheses is used sparingly, it carries a lot of weight. Requiring parentheses around T in T -&gt; U doesn’t seem to have a significant reason aside from style/taste.<br>&gt; <br>&gt; 2. I’m not convinced at all that `(Foo) -&gt; Bar` is immediately more obvious to people. I don’t have data to back it up, but my intuition is that `Foo -&gt; Bar` is simple and understandable. “A function from Foo to Bar”, I’m thinking. I don’t have to mentally parse the vacuous parentheses, just to conclude that there’s, in fact, just one parameter. And when there is more than one parameter, the parentheses in `(Foo, Bar) -&gt; Baz` instantly carry more weight.<br>&gt; <br>&gt; 3. Swift has been really good at removing unnecessary punctuation. Parentheses in if statements, semicolons, shortcut forms of closures, etc. This is a good thing. As I said before, using punctuation only when it matters makes it stand out, and in places where it doesn’t, by removing it we’re increasing the signal-to-noise ratio. To me, parentheses in `(Foo) -&gt; Bar` don’t matter. I can see why one could argue for them, or prefer them, but it seems like a merely stylistic choice. Let’s keep them where it matters, and leave this to personal preference.<br>&gt; <br>&gt; Best,<br>&gt; — Radek<br>&gt; <br>&gt;&gt; On 15 Apr 2016, at 06:57, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; We currently accept function type syntax without parentheses, like:<br>&gt;&gt; <br>&gt;&gt; Int -&gt; Float<br>&gt;&gt; String -&gt; ()<br>&gt;&gt; <br>&gt;&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;&gt; <br>&gt;&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;&gt; <br>&gt;&gt; (Int) -&gt; Float<br>&gt;&gt; (String) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 23, 2016 at 02:00:00am</p></header><div class="content"><p>After some discussions, I support this proposal and think this will make <br>Swift more consistent and clear about where is parameters and where is <br>result type. Especially this important in code like:<br>Int -&gt; String -&gt; Void -&gt; Float<br>which IMO should be<br>(Int) -&gt; (String) -&gt; (Void) -&gt; Float<br>as Int/String/Void are parameters, Float is result type.<br></p><p>But IMO not just &quot;require parenthesis on the argument list&quot;, but also <br>disallow parenthesis in result type in meaning of tuple of single <br>argument(as we discussed in this thread with @Anton), disallow placing () <br>in (), disallow Void in () in result - to prevent all these ((((())))) <br>(((Void))) etc in parameters and in result type.<br></p><p>@Chris, would you form a proposal for this subject?<br></p><p>On 15.04.2016 7:57, Chris Lattner via swift-evolution wrote:<br>&gt; We currently accept function type syntax without parentheses, like:<br>&gt;<br>&gt;   Int -&gt; Float<br>&gt;   String -&gt; ()<br>&gt;<br>&gt; etc.  The original rationale aligned with the fact that we wanted to treat all functions as taking a single parameter (which was often of tuple type) and producing a tuple value (which was sometimes a tuple, in the case of void and multiple return values).  However, we’ve long since moved on from that early design point: there are a number of things that you can only do in a parameter list now (varargs, default args, etc), implicit tuple splat has been removed, and  the compiler has long ago stopped modeling function parameters this way.  Beyond that, it eliminates one potential style war.<br>&gt;<br>&gt; Given all this, I think it makes sense to go for syntactic uniformity between parameter list and function types, and just require parenthesis on the argument list.  The types above can be trivially written as:<br>&gt;<br>&gt;   (Int) -&gt; Float<br>&gt;   (String) -&gt; ()<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[pitch] Eliminate the &quot;T1 -&gt; T2&quot; syntax, require &quot;(T1) -&gt; T2&quot;</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Apr 22, 2016, at 4:05 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; After some discussions, I support this proposal and think this will make Swift more consistent and clear about where is parameters and where is result type. Especially this important in code like:<br>&gt; Int -&gt; String -&gt; Void -&gt; Float<br>&gt; which IMO should be<br>&gt; (Int) -&gt; (String) -&gt; (Void) -&gt; Float<br>&gt; as Int/String/Void are parameters, Float is result type.<br>&gt; <br>&gt; But IMO not just &quot;require parenthesis on the argument list&quot;, but also disallow parenthesis in result type in meaning of tuple of single argument(as we discussed in this thread with @Anton), disallow placing () in (), disallow Void in () in result - to prevent all these ((((())))) (((Void))) etc in parameters and in result type.<br>&gt; <br>&gt; @Chris, would you form a proposal for this subject?<br></p><p>Yes, I already did:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md<br></p><p>It isn’t currently scheduled, but when it comes up, we can have more discussion about it.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
