<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 24, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi there,<br></p><p>this is a kind of survey for general interest that could lead to several separate proposals — at least one would address a real-world problem with evident fatal consequences (or instead of proposals, we might end up with clever patterns to handle the problems better).<br></p><p>Right now, it&#39;s possible to do type-safe math with Swift, but afaics, it is impractical because the language lacks support for this.<br></p><p>Let&#39;s say I want to express the concepts of temperature and mass.<br>I can declare<br>let t: Float = 100.0<br>let m: Float = 1<br>and work with those — but the values are just plain numbers, and can be used in a way that makes no sense (addition of temperature and mass, for example)<br></p><p>We can&#39;t subclass structs like Float, and typealias has very limited use, because it&#39;s really just what it says: A new name without special features that can be used mutually interchangeable with the &quot;real&quot; type.<br></p><p>A first tiny step towards more safety would be empowering typealias and generate warnings when a function is used with the &quot;wrong&quot; parameter type (&quot;Kelvin&quot; requested, but plain Float given).<br>Additionally, extensions written for a typealias shouldn&#39;t be treated like extensions for the underlying type.<br>An extra benefit of this would be the possibility to have<br>typealias Path = String<br>and make a clean distinction between general String-methods and those that are only relevant for Strings that represent a Path in the file system — it would even be possible to generate failable initializers to document constraints of the &quot;new&quot; type.<br></p><p>I know that issues because of wrong units are something the average iOS-developer seldom cares for, but as I said above:<br>Bugs that only could happen because of missing typesafety in calculations caused disasters that make memory leaks and race conditions look ridiculous trivial.<br></p><p>Originally, I planned to broaden the topic much more than I did, but as community reaction sometimes is quite mysterious to me, focusing on one aspect might be better…<br></p><p>So, any opinions, or even arguments against typesafe math?<br></p><p>Merry christmas!<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 24, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; A first tiny step towards more safety would be empowering typealias and generate warnings when a function is used with the &quot;wrong&quot; parameter type (&quot;Kelvin&quot; requested, but plain Float given).<br>&gt; Additionally, extensions written for a typealias shouldn&#39;t be treated like extensions for the underlying type.<br>&gt; An extra benefit of this would be the possibility to have<br>&gt; typealias Path = String<br>&gt; and make a clean distinction between general String-methods and those that are only relevant for Strings that represent a Path in the file system — it would even be possible to generate failable initializers to document constraints of the &quot;new&quot; type.<br></p><p>There&#39;s been discussion of this before, actually. Search the archives for `newtype`, which is Haskell&#39;s version of this feature.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 24, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; Search the archives for `newtype`, which is Haskell&#39;s version of this feature<br>Thanks for the hint — searching the archives is more complicated as expected ;-), but afaics there haven&#39;t been any opposing statements, and the topic just died away without a formal proposal.<br></p><p>Any interest reviving it over the holydays?<br></p><p>tuuranton at tutanota.de: Small world… have you been to hackover in Hannover last year? ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>December 24, 2015 at 09:00:00am</p></header><div class="content"><p>My college calculator had that, and once I discovered it I never went back. For sure, if I did anything remotely scientific with Swift, I would be in love with the feature.<br></p><p>I&#39;m not very good with functional programming but that sounds like something functional programming folks would have a solution for.<br></p><p>Félix<br></p><p>&gt; Le 24 déc. 2015 à 08:09:23, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Search the archives for `newtype`, which is Haskell&#39;s version of this feature<br>&gt; Thanks for the hint — searching the archives is more complicated as expected ;-), but afaics there haven&#39;t been any opposing statements, and the topic just died away without a formal proposal.<br>&gt; <br>&gt; Any interest reviving it over the holydays?<br>&gt; <br>&gt; tuuranton at tutanota.de: Small world… have you been to hackover in Hannover last year? ;-)<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 24, 2015 at 09:00:00am</p></header><div class="content"><p>First, of all, I’d love to have a “newtype” equivalent in Swift: +1.<br></p><p>But also wanted to mention that my current pattern for this sort of code is to use structs, which has the added advantage (or disadvantage, depending upon your particular use case) of being able to easily specify fewer and more specific valid operators than the “real” underlying type.<br></p><p>For instance, some (real project scheduling) code, where you can add or subtract a Duration from a TimeOfDay, and you can get the difference between two TimeOfDays as a Duration, but to add two TimeOfDays is nonsensical.<br></p><p>struct TimeOfDay : Comparable {<br>    let t: Int // in seconds<br>}<br>struct Duration : Comparable {<br>    let d: Int // in seconds<br>}<br>func +(lhs: TimeOfDay, rhs: Duration) -&gt; TimeOfDay {<br>    return TimeOfDay(lhs.t + rhs.d)<br>}<br>func -(lhs: TimeOfDay, rhs: Duration) -&gt; TimeOfDay {<br>    return TimeOfDay(lhs.t - rhs.d)<br>}<br>func -(lhs: TimeOfDay, rhs: TimeOfDay) -&gt; Duration {<br>    return Duration(lhs.t - rhs.t)<br>}<br></p><p>There’s some unfortunate extra boilerplate here, which could be better handled with newtype support in the language, but when compiled with optimizations the resulting code is nearly identical to using plain Ints. And almost all higher level code ends up using these types naturally without needing to unwrap them to Int, so there are fewer accesses to the underlying real types than you would think.<br></p><p>It would be great if any proposal involving newtype covered specifying allowable operators defined on such types to support this kind of thing.<br></p><p>	- Greg<br></p><p>&gt; On Dec 24, 2015, at 4:28 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there,<br>&gt; <br>&gt; this is a kind of survey for general interest that could lead to several separate proposals — at least one would address a real-world problem with evident fatal consequences (or instead of proposals, we might end up with clever patterns to handle the problems better).<br>&gt; <br>&gt; Right now, it&#39;s possible to do type-safe math with Swift, but afaics, it is impractical because the language lacks support for this.<br>&gt; <br>&gt; Let&#39;s say I want to express the concepts of temperature and mass.<br>&gt; I can declare<br>&gt; let t: Float = 100.0<br>&gt; let m: Float = 1<br>&gt; and work with those — but the values are just plain numbers, and can be used in a way that makes no sense (addition of temperature and mass, for example)<br>&gt; <br>&gt; We can&#39;t subclass structs like Float, and typealias has very limited use, because it&#39;s really just what it says: A new name without special features that can be used mutually interchangeable with the &quot;real&quot; type.<br>&gt; <br>&gt; A first tiny step towards more safety would be empowering typealias and generate warnings when a function is used with the &quot;wrong&quot; parameter type (&quot;Kelvin&quot; requested, but plain Float given).<br>&gt; Additionally, extensions written for a typealias shouldn&#39;t be treated like extensions for the underlying type.<br>&gt; An extra benefit of this would be the possibility to have<br>&gt; typealias Path = String<br>&gt; and make a clean distinction between general String-methods and those that are only relevant for Strings that represent a Path in the file system — it would even be possible to generate failable initializers to document constraints of the &quot;new&quot; type.<br>&gt; <br>&gt; I know that issues because of wrong units are something the average iOS-developer seldom cares for, but as I said above:<br>&gt; Bugs that only could happen because of missing typesafety in calculations caused disasters that make memory leaks and race conditions look ridiculous trivial.<br>&gt; <br>&gt; Originally, I planned to broaden the topic much more than I did, but as community reaction sometimes is quite mysterious to me, focusing on one aspect might be better…<br>&gt; <br>&gt; So, any opinions, or even arguments against typesafe math?<br>&gt; <br>&gt; Merry christmas!<br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 24, 2015, at 11:44 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; First, of all, I’d love to have a “newtype” equivalent in Swift: +1.<br>&gt; <br>&gt; But also wanted to mention that my current pattern for this sort of code is to use structs, which has the added advantage (or disadvantage, depending upon your particular use case) of being able to easily specify fewer and more specific valid operators than the “real” underlying type.<br>&gt; <br>&gt; For instance, some (real project scheduling) code, where you can add or subtract a Duration from a TimeOfDay, and you can get the difference between two TimeOfDays as a Duration, but to add two TimeOfDays is nonsensical.<br>&gt; <br>&gt; struct TimeOfDay : Comparable {<br>&gt;    let t: Int // in seconds<br>&gt; }<br>&gt; struct Duration : Comparable {<br>&gt;    let d: Int // in seconds<br>&gt; }<br>&gt; func +(lhs: TimeOfDay, rhs: Duration) -&gt; TimeOfDay {<br>&gt;    return TimeOfDay(lhs.t + rhs.d)<br>&gt; }<br>&gt; func -(lhs: TimeOfDay, rhs: Duration) -&gt; TimeOfDay {<br>&gt;    return TimeOfDay(lhs.t - rhs.d)<br>&gt; }<br>&gt; func -(lhs: TimeOfDay, rhs: TimeOfDay) -&gt; Duration {<br>&gt;    return Duration(lhs.t - rhs.t)<br>&gt; }<br>&gt; <br>&gt; There’s some unfortunate extra boilerplate here, which could be better handled with newtype support in the language, but when compiled with optimizations the resulting code is nearly identical to using plain Ints. And almost all higher level code ends up using these types naturally without needing to unwrap them to Int, so there are fewer accesses to the underlying real types than you would think.<br>&gt; <br>&gt; It would be great if any proposal involving newtype covered specifying allowable operators defined on such types to support this kind of thing.<br></p><p>I&#39;m planning to write a proposal for automatic forwarding.  My intent is that it will cover many use cases including newtype.  It&#39;s still in the concept phase in my mind but I think you will be very pleased if the details work out as I hope and it is eventually accepted.<br></p><p>&gt; <br>&gt;    - Greg<br>&gt; <br>&gt;&gt; On Dec 24, 2015, at 4:28 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi there,<br>&gt;&gt; <br>&gt;&gt; this is a kind of survey for general interest that could lead to several separate proposals — at least one would address a real-world problem with evident fatal consequences (or instead of proposals, we might end up with clever patterns to handle the problems better).<br>&gt;&gt; <br>&gt;&gt; Right now, it&#39;s possible to do type-safe math with Swift, but afaics, it is impractical because the language lacks support for this.<br>&gt;&gt; <br>&gt;&gt; Let&#39;s say I want to express the concepts of temperature and mass.<br>&gt;&gt; I can declare<br>&gt;&gt; let t: Float = 100.0<br>&gt;&gt; let m: Float = 1<br>&gt;&gt; and work with those — but the values are just plain numbers, and can be used in a way that makes no sense (addition of temperature and mass, for example)<br>&gt;&gt; <br>&gt;&gt; We can&#39;t subclass structs like Float, and typealias has very limited use, because it&#39;s really just what it says: A new name without special features that can be used mutually interchangeable with the &quot;real&quot; type.<br>&gt;&gt; <br>&gt;&gt; A first tiny step towards more safety would be empowering typealias and generate warnings when a function is used with the &quot;wrong&quot; parameter type (&quot;Kelvin&quot; requested, but plain Float given).<br>&gt;&gt; Additionally, extensions written for a typealias shouldn&#39;t be treated like extensions for the underlying type.<br>&gt;&gt; An extra benefit of this would be the possibility to have<br>&gt;&gt; typealias Path = String<br>&gt;&gt; and make a clean distinction between general String-methods and those that are only relevant for Strings that represent a Path in the file system — it would even be possible to generate failable initializers to document constraints of the &quot;new&quot; type.<br>&gt;&gt; <br>&gt;&gt; I know that issues because of wrong units are something the average iOS-developer seldom cares for, but as I said above:<br>&gt;&gt; Bugs that only could happen because of missing typesafety in calculations caused disasters that make memory leaks and race conditions look ridiculous trivial.<br>&gt;&gt; <br>&gt;&gt; Originally, I planned to broaden the topic much more than I did, but as community reaction sometimes is quite mysterious to me, focusing on one aspect might be better…<br>&gt;&gt; <br>&gt;&gt; So, any opinions, or even arguments against typesafe math?<br>&gt;&gt; <br>&gt;&gt; Merry christmas!<br>&gt;&gt; Tino<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 24, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>Something like class delegation in Kotlin?<br>Please hurry, I&#39;ve no work to distract me for the rest of the year, and extending typealias could be a very quick proposal ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 24, 2015 at 01:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt; Something like class delegation in Kotlin?<br>&gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and extending typealias could be a very quick proposal ;-)<br></p><p>Details are still brewing.  I am not familiar with class delegation in Kotlin but will look it up.  Thanks for mentioning it!<br></p><p>I plan to spend a lot of time on Swift proposal work over the next week and a half but can&#39;t make any promises on timing.  I made that mistake with my proposal on flexible memberwise initialization which ended up taking a couple weeks longer than I expected (for several reasons).  What I can say is that this is pretty high on my Swift proposal priority list.<br></p><p>Matthew<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>December 24, 2015 at 10:00:00pm</p></header><div class="content"><p>I have been working for a couple weeks (since the previous [newtype<br>discussion](<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html)<br>) on a related pitch. There seem to me to be multiple ways to solve this<br>problem - a newtype(esque) keyword, struct subtyping, or forwarding as<br>Matthew is suggesting. I’d hoped to have a discussion starter out before<br>the holidays, but it takes a fair amount of work to put together even a<br>decent draft for a proposal. This is top of my list currently for a way to<br>contribute though. Looking forward to the ensuing discussions.<br></p><p>Thanks for the pointer on class delegation. I’ve looked at delegated<br>properties there (which came up in relation to Joe’s recent proposal for<br>behaviors on properties).<br></p><p>- Step Christopher<br></p><p><br></p><p>On Thu, Dec 24, 2015 at 2:40 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt; &gt; Something like class delegation in Kotlin?<br>&gt; &gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and<br>&gt; extending typealias could be a very quick proposal ;-)<br>&gt;<br>&gt; Details are still brewing.  I am not familiar with class delegation in<br>&gt; Kotlin but will look it up.  Thanks for mentioning it!<br>&gt;<br>&gt; I plan to spend a lot of time on Swift proposal work over the next week<br>&gt; and a half but can&#39;t make any promises on timing.  I made that mistake with<br>&gt; my proposal on flexible memberwise initialization which ended up taking a<br>&gt; couple weeks longer than I expected (for several reasons).  What I can say<br>&gt; is that this is pretty high on my Swift proposal priority list.<br>&gt;<br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151224/9b89fccc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9247a8ae6f8e90514ede1df8a837307b?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Nickolas Pohilets</string> &lt;pohilets at gmail.com&gt;<p>December 26, 2015 at 01:00:00am</p></header><div class="content"><p>If Swift would support non-type generic parameters, then I would like to<br>have Boost.Unit library (<br>http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html) available<br>in Swift.<br></p><p>2015-12-25 4:36 GMT+01:00 Stephen Christopher via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; I have been working for a couple weeks (since the previous [newtype<br>&gt; discussion](<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html)<br>&gt; ) on a related pitch. There seem to me to be multiple ways to solve this<br>&gt; problem - a newtype(esque) keyword, struct subtyping, or forwarding as<br>&gt; Matthew is suggesting. I’d hoped to have a discussion starter out before<br>&gt; the holidays, but it takes a fair amount of work to put together even a<br>&gt; decent draft for a proposal. This is top of my list currently for a way to<br>&gt; contribute though. Looking forward to the ensuing discussions.<br>&gt;<br>&gt; Thanks for the pointer on class delegation. I’ve looked at delegated<br>&gt; properties there (which came up in relation to Joe’s recent proposal for<br>&gt; behaviors on properties).<br>&gt;<br>&gt; - Step Christopher<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Dec 24, 2015 at 2:40 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt;&gt; &gt; Something like class delegation in Kotlin?<br>&gt;&gt; &gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and<br>&gt;&gt; extending typealias could be a very quick proposal ;-)<br>&gt;&gt;<br>&gt;&gt; Details are still brewing.  I am not familiar with class delegation in<br>&gt;&gt; Kotlin but will look it up.  Thanks for mentioning it!<br>&gt;&gt;<br>&gt;&gt; I plan to spend a lot of time on Swift proposal work over the next week<br>&gt;&gt; and a half but can&#39;t make any promises on timing.  I made that mistake with<br>&gt;&gt; my proposal on flexible memberwise initialization which ended up taking a<br>&gt;&gt; couple weeks longer than I expected (for several reasons).  What I can say<br>&gt;&gt; is that this is pretty high on my Swift proposal priority list.<br>&gt;&gt;<br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/ae21b005/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 26, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>To be honest, &quot;non-type generic parameters&quot; were plant as the final step in the whole topic — they would not only help with units, but also give us safe vector math. Just avoid the &quot;T&quot;-word and the language boost was written for; those can trigger unwanted reflexes ;-)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151226/2dfe471e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 09:00:00am</p></header><div class="content"><p>&gt; On Dec 25, 2015, at 4:43 PM, Nickolas Pohilets via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br></p><p>Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br></p><p>&gt; <br>&gt; 2015-12-25 4:36 GMT+01:00 Stephen Christopher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; I have been working for a couple weeks (since the previous [newtype discussion](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html&gt;) ) on a related pitch. There seem to me to be multiple ways to solve this problem - a newtype(esque) keyword, struct subtyping, or forwarding as Matthew is suggesting. I’d hoped to have a discussion starter out before the holidays, but it takes a fair amount of work to put together even a decent draft for a proposal. This is top of my list currently for a way to contribute though. Looking forward to the ensuing discussions.<br>&gt; <br>&gt; Thanks for the pointer on class delegation. I’ve looked at delegated properties there (which came up in relation to Joe’s recent proposal for behaviors on properties).<br>&gt; <br>&gt; - Step Christopher<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Thu, Dec 24, 2015 at 2:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; &gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt; &gt; Something like class delegation in Kotlin?<br>&gt; &gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and extending typealias could be a very quick proposal ;-)<br>&gt; <br>&gt; Details are still brewing.  I am not familiar with class delegation in Kotlin but will look it up.  Thanks for mentioning it!<br>&gt; <br>&gt; I plan to spend a lot of time on Swift proposal work over the next week and a half but can&#39;t make any promises on timing.  I made that mistake with my proposal on flexible memberwise initialization which ended up taking a couple weeks longer than I expected (for several reasons).  What I can say is that this is pretty high on my Swift proposal priority list.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/efd3d568/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 09:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 25, 2015, at 4:43 PM, Nickolas Pohilets via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>&gt; <br>&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br></p><p><br>I will do cartwheels when we can write stuff like Vector&lt;3&gt; or Tensor&lt;4,4,4&gt;.  Glad to hear it’s on your mind, including the readability aspect.<br></p><p>Matt<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/68ea8ec3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 2:18 PM, Matt Whiteside &lt;mwhiteside.dev at gmail.com&gt; wrote:<br>&gt; <br>&gt; I will do cartwheels when we can write stuff like Vector&lt;3&gt; or Tensor&lt;4,4,4&gt;<br></p><p><br>When the time comes, please post a video.<br></p><p>;-)<br></p><p>-Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/e24e6e43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>December 31, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 31, 2015, at 14:23, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 2:18 PM, Matt Whiteside &lt;mwhiteside.dev at gmail.com &lt;mailto:mwhiteside.dev at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I will do cartwheels when we can write stuff like Vector&lt;3&gt; or Tensor&lt;4,4,4&gt;<br>&gt; <br>&gt; <br>&gt; When the time comes, please post a video.<br>&gt; <br>&gt; ;-)<br>&gt; <br>&gt; -Dave<br>&gt; <br></p><p>Deal.<br></p><p>Matt<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/9083a4c2/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>December 31, 2015 at 11:00:00pm</p></header><div class="content"><p>Same here. I can fake a bit of it now by creating the relevant types (&quot;struct _1 {...}&quot;, etc), but it&#39;s *very* fragile.<br></p><p>&gt; On Dec 31, 2015, at 14:18, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 09:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 25, 2015, at 4:43 PM, Nickolas Pohilets via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html) available in Swift.<br>&gt;&gt; <br>&gt;&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br>&gt; <br>&gt; <br>&gt; I will do cartwheels when we can write stuff like Vector&lt;3&gt; or Tensor&lt;4,4,4&gt;.  Glad to hear it’s on your mind, including the readability aspect.<br>&gt; <br>&gt; Matt<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151231/95a5b607/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Really great to hear that you are planning for Swift to be able to do these kinds of things!<br></p><p>I tried to see how far I could get (working from memory of a Haskell library; Boost.Units seems quite similar at first glance), but failed of course because of the missing parameterized recursive typealiases:<br></p><p>import Foundation<br></p><p>public protocol Peano {}<br>public struct Zero : Peano {}<br>public struct Succ&lt;P : Peano&gt; : Peano {}<br>public struct Pred&lt;S : Peano&gt; : Peano {}<br>public typealias One = Succ&lt;Zero&gt;<br>public typealias Two = Succ&lt;One&gt;<br>public typealias MinusOne = Pred&lt;Zero&gt;<br>public typealias MinusTwo = Pred&lt;One&gt;<br></p><p>// Quantity with SI Units<br></p><p>// TODO: extend by more type parameters for the remaining SI units<br>public struct Quantity&lt;Length: Peano, Time: Peano, Mass: Peano&gt; : Equatable, Comparable {<br>    <br>    let value: Double<br>    <br>    init(_ value: Double) {<br>        self.value = value<br>    }<br>}<br></p><p>public func ==&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>    return lhs.value == rhs.value<br>}<br></p><p>public func &lt;&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>    return lhs.value &lt; rhs.value<br>}<br></p><p>public func +&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Quantity&lt;L,T,M&gt; {<br>    return Quantity&lt;L,T,M&gt;(lhs.value + rhs.value)<br>}<br></p><p>// Missing language feature: parameterized recursive typealias<br>// i.e. the following typealiases are currently not possible<br>typealias Add&lt;Zero, P: Peano&gt; = P<br>typealias Add&lt;P: Peano, Zero&gt; = P<br>typealias Add&lt;Succ&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Add&lt;Succ&lt;Succ&lt;P1&gt;&gt;,P2&gt;<br>typealias Add&lt;Succ&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Add&lt;P1,P2&gt;<br>typealias Add&lt;Pred&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Add&lt;P1,P2&gt;<br>typealias Add&lt;Pred&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Add&lt;P1,Pred&lt;Pred&lt;P2&gt;&gt;&gt;<br></p><p>typealias Sub&lt;Zero, P: Peano&gt; = P<br>typealias Sub&lt;P: Peano, Zero&gt; = P<br>typealias Sub&lt;Succ&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Sub&lt;P1,P2&gt;<br>typealias Sub&lt;Succ&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Sub&lt;P1,Pred&lt;Pred&lt;P2&gt;&gt;<br>typealias Sub&lt;Pred&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Sub&lt;Pred&lt;Pred&lt;P1&gt;&gt;,P2&gt;<br>typealias Sub&lt;Pred&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Sub&lt;P1,P2&gt;<br></p><p>public func *<br>    &lt;L1,T1,M1,L2,T2,M2,L,T,M where<br>    L == Add&lt;L1,L2&gt;, T == Add&lt;T1,T2&gt;, M == Add&lt;M1,M2&gt;&gt;<br>    (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>{<br>    return Quantity&lt;L,T,M&gt;(lhs.value * rhs.value)<br>}<br></p><p>public func /<br>    &lt;L1,T1,M1,L2,T2,M2,L,T,M where<br>    L == Sub&lt;L1,L2&gt;, T == Sub&lt;T1,T2&gt;, M == Sub&lt;M1,M2&gt;&gt;<br>    (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>{<br>    return Quantity&lt;L,T,M&gt;(lhs.value / rhs.value)<br>}<br></p><p><br>// Defining some nice typealiases with which to work<br></p><p>public typealias Scalar   = Quantity&lt;Zero, Zero, Zero&gt; // dimensionless<br>public typealias Length   = Quantity&lt;One, Zero, Zero&gt; // meter<br>public typealias Time     = Quantity&lt;Zero, One, Zero&gt; // seconds<br>public typealias Mass     = Quantity&lt;Zero, Zero, One&gt; // kilogram<br>public typealias Velocity = Quantity&lt;One, MinusOne, Zero&gt; // m/s<br>public typealias Newton   = Quantity&lt;One, MinusTwo, One&gt; // m*kg/s^2<br></p><p><br>public extension Double {<br>    <br>    public var m: Length {<br>        return Length(self)<br>    }<br>    public var s: Time {<br>        return Time(self)<br>    }<br>    public var kg: Mass {<br>        return Mass(self)<br>    }<br>}<br></p><p>let dist = 10.m + 5.m<br>let time = 20.s<br>let mass = 5.kg<br>let velocity: Velocity = dist / time<br>let force: Newton = mass * dist / (time * time)<br></p><p><br>-Thorsten<br></p><p><br>&gt; Am 31.12.2015 um 18:25 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 25, 2015, at 4:43 PM, Nickolas Pohilets via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>&gt; <br>&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 2015-12-25 4:36 GMT+01:00 Stephen Christopher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; I have been working for a couple weeks (since the previous [newtype discussion](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html&gt;) ) on a related pitch. There seem to me to be multiple ways to solve this problem - a newtype(esque) keyword, struct subtyping, or forwarding as Matthew is suggesting. I’d hoped to have a discussion starter out before the holidays, but it takes a fair amount of work to put together even a decent draft for a proposal. This is top of my list currently for a way to contribute though. Looking forward to the ensuing discussions.<br>&gt;&gt; <br>&gt;&gt; Thanks for the pointer on class delegation. I’ve looked at delegated properties there (which came up in relation to Joe’s recent proposal for behaviors on properties).<br>&gt;&gt; <br>&gt;&gt; - Step Christopher<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Dec 24, 2015 at 2:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt;&gt; &gt; Something like class delegation in Kotlin?<br>&gt;&gt; &gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and extending typealias could be a very quick proposal ;-)<br>&gt;&gt; <br>&gt;&gt; Details are still brewing.  I am not familiar with class delegation in Kotlin but will look it up.  Thanks for mentioning it!<br>&gt;&gt; <br>&gt;&gt; I plan to spend a lot of time on Swift proposal work over the next week and a half but can&#39;t make any promises on timing.  I made that mistake with my proposal on flexible memberwise initialization which ended up taking a couple weeks longer than I expected (for several reasons).  What I can say is that this is pretty high on my Swift proposal priority list.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; -Dave<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/c1aa50a6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 02:00:00pm</p></header><div class="content"><p>I was thinking of a C++ design using variadic templates. I&#39;m pretty sure you (as in &quot;someone else&quot;) could do it. I don&#39;t have anything to show at the moment because I&#39;d probably pull my hair for hours given my know-how level. However, I think that each individual step outlined would be feasible and I don&#39;t think that I&#39;m missing any.<br></p><p>You have unit integral constants (Meters = 1, Seconds = 2, Kilograms = 3, etc), a UnitProduct integer sequence (UnitProduct&lt;Meters, Meters, Seconds&gt; being m^2 * s), and a UnitQuotient template that has two UnitProduct template arguments (UnitQuotient&lt;UnitProduct&lt;Meter&gt;, UnitProduct&lt;Second, Second&gt;&gt; being m/s^2, or m * s^-2). Finally, you have a Quantity type that has a numeric type for the quantity and a UnitQuotient for the unit.<br></p><p>The Quantity type has operator overloads for additions and subtractions to the same type. It also has multiplication and division operators for numeric types and any Quantity.<br></p><p>When you multiply two quantities, you merge the UnitProduct integer sequences of the two UnitQuotients. You order them (to give units a canonical order) and you &quot;cancel out&quot; (omit) template arguments that are in both the denominator and numerator. When you divide them, you just merge one UnitQuotient&#39;s denominator with the other&#39;s numerator and vice-versa.<br></p><p>Complex units can be typedef&#39;d. For intermediate results, type inference would be enough.<br></p><p>Given that it relies on variadic templates and non-type template arguments, this wouldn&#39;t be feasible in Swift at the moment.<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 13:46:09, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Really great to hear that you are planning for Swift to be able to do these kinds of things!<br>&gt; <br>&gt; I tried to see how far I could get (working from memory of a Haskell library; Boost.Units seems quite similar at first glance), but failed of course because of the missing parameterized recursive typealiases:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; public protocol Peano {}<br>&gt; public struct Zero : Peano {}<br>&gt; public struct Succ&lt;P : Peano&gt; : Peano {}<br>&gt; public struct Pred&lt;S : Peano&gt; : Peano {}<br>&gt; public typealias One = Succ&lt;Zero&gt;<br>&gt; public typealias Two = Succ&lt;One&gt;<br>&gt; public typealias MinusOne = Pred&lt;Zero&gt;<br>&gt; public typealias MinusTwo = Pred&lt;One&gt;<br>&gt; <br>&gt; // Quantity with SI Units<br>&gt; <br>&gt; // TODO: extend by more type parameters for the remaining SI units<br>&gt; public struct Quantity&lt;Length: Peano, Time: Peano, Mass: Peano&gt; : Equatable, Comparable {<br>&gt;     <br>&gt;     let value: Double<br>&gt;     <br>&gt;     init(_ value: Double) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public func ==&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>&gt;     return lhs.value == rhs.value<br>&gt; }<br>&gt; <br>&gt; public func &lt;&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>&gt;     return lhs.value &lt; rhs.value<br>&gt; }<br>&gt; <br>&gt; public func +&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Quantity&lt;L,T,M&gt; {<br>&gt;     return Quantity&lt;L,T,M&gt;(lhs.value + rhs.value)<br>&gt; }<br>&gt; <br>&gt; // Missing language feature: parameterized recursive typealias<br>&gt; // i.e. the following typealiases are currently not possible<br>&gt; typealias Add&lt;Zero, P: Peano&gt; = P<br>&gt; typealias Add&lt;P: Peano, Zero&gt; = P<br>&gt; typealias Add&lt;Succ&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Add&lt;Succ&lt;Succ&lt;P1&gt;&gt;,P2&gt;<br>&gt; typealias Add&lt;Succ&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Add&lt;P1,P2&gt;<br>&gt; typealias Add&lt;Pred&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Add&lt;P1,P2&gt;<br>&gt; typealias Add&lt;Pred&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Add&lt;P1,Pred&lt;Pred&lt;P2&gt;&gt;&gt;<br>&gt; <br>&gt; typealias Sub&lt;Zero, P: Peano&gt; = P<br>&gt; typealias Sub&lt;P: Peano, Zero&gt; = P<br>&gt; typealias Sub&lt;Succ&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Sub&lt;P1,P2&gt;<br>&gt; typealias Sub&lt;Succ&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Sub&lt;P1,Pred&lt;Pred&lt;P2&gt;&gt;<br>&gt; typealias Sub&lt;Pred&lt;P1&gt;, Succ&lt;P2&gt;&gt; = Sub&lt;Pred&lt;Pred&lt;P1&gt;&gt;,P2&gt;<br>&gt; typealias Sub&lt;Pred&lt;P1&gt;, Pred&lt;P2&gt;&gt; = Sub&lt;P1,P2&gt;<br>&gt; <br>&gt; public func *<br>&gt;     &lt;L1,T1,M1,L2,T2,M2,L,T,M where<br>&gt;     L == Add&lt;L1,L2&gt;, T == Add&lt;T1,T2&gt;, M == Add&lt;M1,M2&gt;&gt;<br>&gt;     (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>&gt; {<br>&gt;     return Quantity&lt;L,T,M&gt;(lhs.value * rhs.value)<br>&gt; }<br>&gt; <br>&gt; public func /<br>&gt;     &lt;L1,T1,M1,L2,T2,M2,L,T,M where<br>&gt;     L == Sub&lt;L1,L2&gt;, T == Sub&lt;T1,T2&gt;, M == Sub&lt;M1,M2&gt;&gt;<br>&gt;     (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>&gt; {<br>&gt;     return Quantity&lt;L,T,M&gt;(lhs.value / rhs.value)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; // Defining some nice typealiases with which to work<br>&gt; <br>&gt; public typealias Scalar   = Quantity&lt;Zero, Zero, Zero&gt; // dimensionless<br>&gt; public typealias Length   = Quantity&lt;One, Zero, Zero&gt; // meter<br>&gt; public typealias Time     = Quantity&lt;Zero, One, Zero&gt; // seconds<br>&gt; public typealias Mass     = Quantity&lt;Zero, Zero, One&gt; // kilogram<br>&gt; public typealias Velocity = Quantity&lt;One, MinusOne, Zero&gt; // m/s<br>&gt; public typealias Newton   = Quantity&lt;One, MinusTwo, One&gt; // m*kg/s^2<br>&gt; <br>&gt; <br>&gt; public extension Double {<br>&gt;     <br>&gt;     public var m: Length {<br>&gt;         return Length(self)<br>&gt;     }<br>&gt;     public var s: Time {<br>&gt;         return Time(self)<br>&gt;     }<br>&gt;     public var kg: Mass {<br>&gt;         return Mass(self)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let dist = 10.m + 5.m<br>&gt; let time = 20.s<br>&gt; let mass = 5.kg<br>&gt; let velocity: Velocity = dist / time<br>&gt; let force: Newton = mass * dist / (time * time)<br>&gt; <br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 31.12.2015 um 18:25 schrieb Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 25, 2015, at 4:43 PM, Nickolas Pohilets via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>&gt;&gt; <br>&gt;&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2015-12-25 4:36 GMT+01:00 Stephen Christopher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; I have been working for a couple weeks (since the previous [newtype discussion](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html&gt;) ) on a related pitch. There seem to me to be multiple ways to solve this problem - a newtype(esque) keyword, struct subtyping, or forwarding as Matthew is suggesting. I’d hoped to have a discussion starter out before the holidays, but it takes a fair amount of work to put together even a decent draft for a proposal. This is top of my list currently for a way to contribute though. Looking forward to the ensuing discussions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the pointer on class delegation. I’ve looked at delegated properties there (which came up in relation to Joe’s recent proposal for behaviors on properties).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Step Christopher<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Dec 24, 2015 at 2:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt;&gt;&gt; &gt; Something like class delegation in Kotlin?<br>&gt;&gt;&gt; &gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and extending typealias could be a very quick proposal ;-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Details are still brewing.  I am not familiar with class delegation in Kotlin but will look it up.  Thanks for mentioning it!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I plan to spend a lot of time on Swift proposal work over the next week and a half but can&#39;t make any promises on timing.  I made that mistake with my proposal on flexible memberwise initialization which ended up taking a couple weeks longer than I expected (for several reasons).  What I can say is that this is pretty high on my Swift proposal priority list.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/bd52a850/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Those are both on the todo list, though, aren’t they?<br>&gt; On Jan 7, 2016, at 11:26, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; […]<br>&gt; Given that it relies on variadic templates and non-type template arguments, this wouldn&#39;t be feasible in Swift at the moment.<br>&gt; <br>&gt; Félix<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/cc47cf45/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Those are both on the todo list, though, aren’t they?<br>I can&#39;t prove you wrong, but do you have evidence?<br>(that would be great - non-type template arguments are definitely on my to-propose list ;-)<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/46e211b1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 02:42, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; Those are both on the todo list, though, aren’t they?<br>&gt; I can&#39;t prove you wrong, but do you have evidence?<br>&gt; (that would be great - non-type template arguments are definitely on my to-propose list ;-)<br></p><p>Depends on what you mean by “evidence”. I’ve been trying to remember what I was thinking of when I wrote that, and I *think* it was the word “when” (as opposed to “if”) in one of Dave Abrahams’s earlier posts in this thread:<br></p><p><br>&gt; On Dec 31, 2015, at 09:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br></p><p><br>So… do you have any thoughts on the matter, Dave? :-)<br></p><p>- Dave<br></p><p>(Is there a way to change my name on the mailing list to “The Other Dave”?)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/41996f38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 12, 2016, at 1:49 PM, davesweeris at mac.com wrote:<br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 02:42, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt; Those are both on the todo list, though, aren’t they?<br>&gt;&gt; I can&#39;t prove you wrong, but do you have evidence?<br>&gt;&gt; (that would be great - non-type template arguments are definitely on my to-propose list ;-)<br>&gt; <br>&gt; Depends on what you mean by “evidence”. I’ve been trying to remember what I was thinking of when I wrote that, and I *think* it was the word “when” (as opposed to “if”) in one of Dave Abrahams’s earlier posts in this thread:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 31, 2015, at 09:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>&gt;&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br>&gt; <br>&gt; <br>&gt; So… do you have any thoughts on the matter, Dave? :-)<br></p><p>We don’t comment on future plans, sorry.  I was expressing an overly confident view of the future.<br></p><p>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/424c7a4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>Nuts, I was hoping you knew something I didn’t.<br></p><p>Oh well, thanks for clearing that up.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Jan 12, 2016, at 15:08, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 12, 2016, at 1:49 PM, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 8, 2016, at 02:42, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Those are both on the todo list, though, aren’t they?<br>&gt;&gt;&gt; I can&#39;t prove you wrong, but do you have evidence?<br>&gt;&gt;&gt; (that would be great - non-type template arguments are definitely on my to-propose list ;-)<br>&gt;&gt; <br>&gt;&gt; Depends on what you mean by “evidence”. I’ve been trying to remember what I was thinking of when I wrote that, and I *think* it was the word “when” (as opposed to “if”) in one of Dave Abrahams’s earlier posts in this thread:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 31, 2015, at 09:25, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; If Swift would support non-type generic parameters, then I would like to have Boost.Unit library (http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html &lt;http://www.boost.org/doc/libs/1_60_0/doc/html/boost_units.html&gt;) available in Swift.<br>&gt;&gt;&gt; Yes, that’s an excellent design.  We really want to do this when we get the necessary language features (I hope we might also come up with some that improve readability a bit over what you can do in C++).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; So… do you have any thoughts on the matter, Dave? :-)<br>&gt; <br>&gt; We don’t comment on future plans, sorry.  I was expressing an overly confident view of the future.<br>&gt; <br>&gt; -Dave<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/c8c5b46c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January  8, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Am 07.01.2016 um 20:26 schrieb Félix Cloutier &lt;felixcca at yahoo.ca&gt;:<br>&gt; <br>&gt; Given that it relies on variadic templates and non-type template arguments, this wouldn&#39;t be feasible in Swift at the moment<br></p><p>Having non-type template arguments (and the ability to operate on them at compile time) would make it possible to drop all that stuff modeling this in the type system with peano numbers like I tried. Much more simple! <br></p><p>This would reduce my example to the following (no need for variadic templates because I give each SI unit it fixed place in the parameter list — your idea of using variadic templates would probably allow to extend the system by new base units, though, and allow to cut down the long template parameter lists in the arithmetic functions which will grow longer with each base unit added in my example...):<br></p><p>// TODO: extend by more type parameters for the remaining SI units<br>// missing language feature: non-type generic arguments, here: Int<br>public struct Quantity&lt;Length = Int, Time = Int, Mass = Int&gt; : Equatable, Comparable {<br>    <br>    let value: Double<br>    <br>    init(_ value: Double) {<br>        self.value = value<br>    }<br>}<br></p><p>public func ==&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>    return lhs.value == rhs.value<br>}<br></p><p>public func &lt;&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>    return lhs.value &lt; rhs.value<br>}<br></p><p>public func +&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Quantity&lt;L,T,M&gt; {<br>    return Quantity&lt;L,T,M&gt;(lhs.value + rhs.value)<br>}<br></p><p>public func *<br>    &lt;L1,T1,M1,L2,T2,M2,L,T,M where L == L1+L2, T == T1+T2, M == M1+M2&gt;<br>    (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>{<br>    return Quantity&lt;L,T,M&gt;(lhs.value * rhs.value)<br>}<br></p><p>public func /<br>    &lt;L1,T1,M1,L2,T2,M2,L,T,M where L == L1-L2, T == T1-T2, M == M1-M2&gt;<br>    (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>{<br>    return Quantity&lt;L,T,M&gt;(lhs.value / rhs.value)<br>}<br></p><p><br>// Defining some nice typealiases with which to work<br></p><p>public typealias Scalar   = Quantity&lt;0, 0, 0&gt; // dimensionless<br>public typealias Length   = Quantity&lt;1, 0, 0&gt; // meter<br>public typealias Time     = Quantity&lt;0, 1, 0&gt; // seconds<br>public typealias Mass     = Quantity&lt;0, 0, 1&gt; // kilogram<br>public typealias Velocity = Quantity&lt;1, -1, 0&gt; // m/s<br>public typealias Newton   = Quantity&lt;1, -2, 1&gt; // m*kg/s^2<br></p><p><br>public extension Double {<br>    <br>    public var m: Length {<br>        return Length(self)<br>    }<br>    public var s: Time {<br>        return Time(self)<br>    }<br>    public var kg: Mass {<br>        return Mass(self)<br>    }<br>}<br></p><p>let dist = 10.m + 5.m<br>let time = 20.s<br>let mass = 5.kg<br>let velocity: Velocity = dist / time<br>let force: Newton = mass * dist / (time * time)<br></p><p><br>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/accc17b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>I said earlier (maybe in a different thread?) that I didn&#39;t want to implement units in C++ even though I was pretty sure you could do it because I&#39;d just pull my hair for hours. Well, there&#39;s no better way to learn than to pull your hair for hours, so I did it anyway.<br></p><p>http://coliru.stacked-crooked.com/a/b1dde8e8320b55b7 &lt;http://coliru.stacked-crooked.com/a/b1dde8e8320b55b7&gt;<br></p><p>The bottom part is the interesting part and shows how to use units with that system:<br></p><p>&gt; #pragma mark - (actually using units)<br>&gt; enum class Units<br>&gt; {<br>&gt; 	Meter,<br>&gt; 	Second,<br>&gt; 	Kilogram,<br>&gt; };<br>&gt; <br>&gt; template&lt;Units U&gt;<br>&gt; using SimpleUnit = Quantity&lt;double, UnitQuotient&lt;UnitProduct&lt;Units, U&gt;, UnitProduct&lt;Units&gt;&gt;&gt;;<br>&gt; <br>&gt; SimpleUnit&lt;Units::Meter&gt; _m(1);<br>&gt; SimpleUnit&lt;Units::Meter&gt; _ft(0.3048);<br>&gt; SimpleUnit&lt;Units::Second&gt; _s(1);<br>&gt; SimpleUnit&lt;Units::Kilogram&gt; _Kg(1);<br>&gt; auto _N = (_Kg * _m) / (_s * _s);<br>&gt; <br>&gt; int main()<br>&gt; {<br>&gt; 	decltype(_m) distance = 12.5 * _m;<br>&gt; 	decltype(_m * _m) area = 2 * _ft * distance;<br>&gt; 	decltype(_Kg) mass = 18 * _Kg;<br>&gt; 	decltype(_N) force = mass * distance / (1.2 * _s * 1.8 * _s);<br>&gt; 	<br>&gt; 	// uncomment for an error<br>&gt; 	// decltype(_N) notForce = mass / distance;<br>&gt; }<br></p><p>Of course, `auto` would work too, but it doesn&#39;t convey type/unit safety as well.<br></p><p>I&#39;d like to be able to write that in Swift one day (with less incomprehensible template boilerplate) :-) I personally really like that you can &quot;create&quot; units just by declaring a variable, that you can get their type by using `decltype(unit)` and that they are very easy to compose.<br></p><p>Félix<br></p><p>&gt; Le 8 janv. 2016 à 08:54:52, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; Am 07.01.2016 um 20:26 schrieb Félix Cloutier &lt;felixcca at yahoo.ca &lt;mailto:felixcca at yahoo.ca&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; Given that it relies on variadic templates and non-type template arguments, this wouldn&#39;t be feasible in Swift at the moment<br>&gt; <br>&gt; Having non-type template arguments (and the ability to operate on them at compile time) would make it possible to drop all that stuff modeling this in the type system with peano numbers like I tried. Much more simple! <br>&gt; <br>&gt; This would reduce my example to the following (no need for variadic templates because I give each SI unit it fixed place in the parameter list — your idea of using variadic templates would probably allow to extend the system by new base units, though, and allow to cut down the long template parameter lists in the arithmetic functions which will grow longer with each base unit added in my example...):<br>&gt; <br>&gt; // TODO: extend by more type parameters for the remaining SI units<br>&gt; // missing language feature: non-type generic arguments, here: Int<br>&gt; public struct Quantity&lt;Length = Int, Time = Int, Mass = Int&gt; : Equatable, Comparable {<br>&gt;     <br>&gt;     let value: Double<br>&gt;     <br>&gt;     init(_ value: Double) {<br>&gt;         self.value = value<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public func ==&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>&gt;     return lhs.value == rhs.value<br>&gt; }<br>&gt; <br>&gt; public func &lt;&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Bool {<br>&gt;     return lhs.value &lt; rhs.value<br>&gt; }<br>&gt; <br>&gt; public func +&lt;L,T,M&gt;(lhs: Quantity&lt;L,T,M&gt;, rhs: Quantity&lt;L,T,M&gt;) -&gt; Quantity&lt;L,T,M&gt; {<br>&gt;     return Quantity&lt;L,T,M&gt;(lhs.value + rhs.value)<br>&gt; }<br>&gt; <br>&gt; public func *<br>&gt;     &lt;L1,T1,M1,L2,T2,M2,L,T,M where L == L1+L2, T == T1+T2, M == M1+M2&gt;<br>&gt;     (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>&gt; {<br>&gt;     return Quantity&lt;L,T,M&gt;(lhs.value * rhs.value)<br>&gt; }<br>&gt; <br>&gt; public func /<br>&gt;     &lt;L1,T1,M1,L2,T2,M2,L,T,M where L == L1-L2, T == T1-T2, M == M1-M2&gt;<br>&gt;     (lhs: Quantity&lt;L1,T1,M1&gt;, rhs: Quantity&lt;L2,T2,M2&gt;) -&gt; Quantity&lt;L,T,M&gt;<br>&gt; {<br>&gt;     return Quantity&lt;L,T,M&gt;(lhs.value / rhs.value)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; // Defining some nice typealiases with which to work<br>&gt; <br>&gt; public typealias Scalar   = Quantity&lt;0, 0, 0&gt; // dimensionless<br>&gt; public typealias Length   = Quantity&lt;1, 0, 0&gt; // meter<br>&gt; public typealias Time     = Quantity&lt;0, 1, 0&gt; // seconds<br>&gt; public typealias Mass     = Quantity&lt;0, 0, 1&gt; // kilogram<br>&gt; public typealias Velocity = Quantity&lt;1, -1, 0&gt; // m/s<br>&gt; public typealias Newton   = Quantity&lt;1, -2, 1&gt; // m*kg/s^2<br>&gt; <br>&gt; <br>&gt; public extension Double {<br>&gt;     <br>&gt;     public var m: Length {<br>&gt;         return Length(self)<br>&gt;     }<br>&gt;     public var s: Time {<br>&gt;         return Time(self)<br>&gt;     }<br>&gt;     public var kg: Mass {<br>&gt;         return Mass(self)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let dist = 10.m + 5.m<br>&gt; let time = 20.s<br>&gt; let mass = 5.kg<br>&gt; let velocity: Velocity = dist / time<br>&gt; let force: Newton = mass * dist / (time * time)<br>&gt; <br>&gt; <br>&gt; -Thorsten<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/04fbce99/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 10:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Really great to hear that you are planning for Swift to be able to do these kinds of things!<br>&gt; <br>&gt; I tried to see how far I could get (working from memory of a Haskell library; Boost.Units seems quite similar at first glance), but failed of course because of the missing parameterized recursive typealiases:<br></p><p>Sadly, the lack of the ability to define a pretty shorthand for quantities is not what stands in the way, fundamentally.<br></p><p><br>-Dave<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/10ddf0cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 13.01.2016 um 00:06 schrieb Dave Abrahams &lt;dabrahams at apple.com&gt;:<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 10:46 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Really great to hear that you are planning for Swift to be able to do these kinds of things!<br>&gt;&gt; <br>&gt;&gt; I tried to see how far I could get (working from memory of a Haskell library; Boost.Units seems quite similar at first glance), but failed of course because of the missing parameterized recursive typealiases:<br>&gt; <br>&gt; Sadly, the lack of the ability to define a pretty shorthand for quantities is not what stands in the way, fundamentally.<br></p><p>I&#39;m afraid I don&#39;t get your meaning here. Would you mind to explain a bit more?<br>Thanks!<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/afe400af/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 27, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; There seem to me to be multiple ways to solve this problem - a newtype(esque) keyword, struct subtyping, or forwarding as Matthew is suggesting<br></p><p>Imho it would make sense to start a topic about inheritance for structs — of cause there a good theories why this isn&#39;t possible, but subtyping on its own isn&#39;t problematic:<br>You just have to disallow polymorphism (at least for subtypes with own properties).<br>I wonder if there has been a decision to just disable inheritance for structs completely to avoid confusion with the lesser strict rules of reference types…<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151227/1bb0c162/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>December 29, 2015 at 10:00:00am</p></header><div class="content"><p>FWIW I began a draft for a newtype/wrapper-synthesis proposal but abandoned it due to:<br></p><p>- (a) perceived lack of community interest <br>- (b) running into *serious* complications around associated types<br></p><p>…note that this *didn’t* directly-address any sort of units system, but would be somewhat complementary (and a good first step in that direction). <br></p><p>The short version of the issue in (b) is that whereas the desired behavior-and-semantics for “direct&quot; newtype/wrapper-style constructs — where `Foo` is a newtype of `Bar` — seem pretty straightforward to specify, that’s not enough; you also have to deal with the “indirect” scenario, e.g. with situations in which `Foo` is a newtype of `Bar`, but `Bar` is also a `CollectionType`, and you want `Foo` to also be a `CollectionType` (or any other similar case).<br></p><p>In that specific case, you *probably* want this:<br></p><p>- `Foo.Element` == `Bar.Element`<br>- `Foo.Index` == a *newtype* of `Bar.Index` (e.g., not just a bare `Bar.Index`)<br>- `Foo.Generator` == `Bar.Generator` (I assume)<br>- `Foo.SubSequence` == <br>  - `Foo`, when `Bar.SubSequence` == `Bar`<br>  - `Slice&lt;Foo&gt;`, when `Bar.SubSequence` == `Slice&lt;Bar&gt;`<br>  - a *newtype* of `Bar.SubSequence`, when `Bar.SubSequence` is some other type<br></p><p>…and although you can quibble with the exact choices here, the general issue is that it’s seemingly quite hard to really achieve the type-safety goals for some newtype/wrapper proposal without also addressing how to potentially “re-wrap” the wrapped type’s associated types.<br></p><p>It can be done I’m sure, but it’s seemingly rather involved; it definitely feels like a “Swift 4 (or later)” feature. If there’s enough community interest I could pick it up and flesh it out a bit more.<br></p><p>&gt; On Dec 24, 2015, at 9:36 PM, Stephen Christopher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have been working for a couple weeks (since the previous [newtype discussion](https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001821.html&gt;) ) on a related pitch. There seem to me to be multiple ways to solve this problem - a newtype(esque) keyword, struct subtyping, or forwarding as Matthew is suggesting. I’d hoped to have a discussion starter out before the holidays, but it takes a fair amount of work to put together even a decent draft for a proposal. This is top of my list currently for a way to contribute though. Looking forward to the ensuing discussions.<br>&gt; <br>&gt; Thanks for the pointer on class delegation. I’ve looked at delegated properties there (which came up in relation to Joe’s recent proposal for behaviors on properties).<br>&gt; <br>&gt; - Step Christopher<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Thu, Dec 24, 2015 at 2:40 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; &gt; On Dec 24, 2015, at 1:07 PM, Tino Heth &lt;2th at gmx.de &lt;mailto:2th at gmx.de&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; I&#39;m planning to write a proposal for automatic forwarding.<br>&gt; &gt; Something like class delegation in Kotlin?<br>&gt; &gt; Please hurry, I&#39;ve no work to distract me for the rest of the year, and extending typealias could be a very quick proposal ;-)<br>&gt; <br>&gt; Details are still brewing.  I am not familiar with class delegation in Kotlin but will look it up.  Thanks for mentioning it!<br>&gt; <br>&gt; I plan to spend a lot of time on Swift proposal work over the next week and a half but can&#39;t make any promises on timing.  I made that mistake with my proposal on flexible memberwise initialization which ended up taking a couple weeks longer than I expected (for several reasons).  What I can say is that this is pretty high on my Swift proposal priority list.<br>&gt; <br>&gt; Matthew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/ecc2e2ef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 27, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; There’s some unfortunate extra boilerplate here, which could be better handled with newtype support in the language, but when compiled with optimizations the resulting code is nearly identical to using plain Ints.<br></p><p>Cool — have you checked the generated assembler for this conclusion? But I guess there is some knowledge on how to build an optimizing compiler in the core team ;-), so I&#39;d expect little to no penalty (I guess the memory footprint of plain Ints is still better).<br>I have been playing with something similar, but using enums instead of structs (I thought it&#39;s nice to model different units for the same quantity).<br>With generics and protocols, it is already possible to do simple calculations without to much overhead, and maybe I&#39;ll create a library for the most important physical quantities with this toolset.<br></p><p>I&#39;m still trying to figure out if there is a clever trick to model compound units (velocity as m/s, for example) in a general way:<br>It is simple to express that UnitA * UnitB is equal to UnitB * UnitA, but it gets tedious when there are many units and factors…<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>December 27, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 27, 2015, at 2:56 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; There’s some unfortunate extra boilerplate here, which could be better handled with newtype support in the language, but when compiled with optimizations the resulting code is nearly identical to using plain Ints.<br>&gt; <br>&gt; Cool — have you checked the generated assembler for this conclusion? But I guess there is some knowledge on how to build an optimizing compiler in the core team ;-), so I&#39;d expect little to no penalty (I guess the memory footprint of plain Ints is still better).<br></p><p>Yes, I have, and actually, the memory footprint is no different! These are value-types that are exactly word-sized, and so get passed around in registers and stored inline in larger structs. <br></p><p>	- Greg<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 29, 2015 at 07:00:00pm</p></header><div class="content"><p>+1 for the ability to unit check expressions. It is harder to do than it sounds because there are many equivalent units, for example force N = mass kg * acceleration m/s^2. Therefore N, kg m/s^2, m/s^2 kg, etc. are all equal.<br></p><p>Sent from my iPad<br></p><p>&gt; On 28 Dec 2015, at 9:33 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 27, 2015, at 2:56 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; There’s some unfortunate extra boilerplate here, which could be better handled with newtype support in the language, but when compiled with optimizations the resulting code is nearly identical to using plain Ints.<br>&gt;&gt; <br>&gt;&gt; Cool — have you checked the generated assembler for this conclusion? But I guess there is some knowledge on how to build an optimizing compiler in the core team ;-), so I&#39;d expect little to no penalty (I guess the memory footprint of plain Ints is still better).<br>&gt; <br>&gt; Yes, I have, and actually, the memory footprint is no different! These are value-types that are exactly word-sized, and so get passed around in registers and stored inline in larger structs. <br>&gt; <br>&gt;    - Greg<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>December 29, 2015 at 12:00:00am</p></header><div class="content"><p>+1; first-class affordances to make dimensional analysis possible would be incredibly useful.<br></p><p>Austin<br></p><p>&gt; On Dec 29, 2015, at 12:11 AM, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 for the ability to unit check expressions. It is harder to do than it sounds because there are many equivalent units, for example force N = mass kg * acceleration m/s^2. Therefore N, kg m/s^2, m/s^2 kg, etc. are all equal.<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On 28 Dec 2015, at 9:33 AM, Greg Titus via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 27, 2015, at 2:56 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There’s some unfortunate extra boilerplate here, which could be better handled with newtype support in the language, but when compiled with optimizations the resulting code is nearly identical to using plain Ints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cool — have you checked the generated assembler for this conclusion? But I guess there is some knowledge on how to build an optimizing compiler in the core team ;-), so I&#39;d expect little to no penalty (I guess the memory footprint of plain Ints is still better).<br>&gt;&gt; <br>&gt;&gt; Yes, I have, and actually, the memory footprint is no different! These are value-types that are exactly word-sized, and so get passed around in registers and stored inline in larger structs. <br>&gt;&gt; <br>&gt;&gt;   - Greg<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e5b8fa5e4f9e527ea335031bf2ec9a03?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Árpád Goretity</string> &lt;arpad.goretity at gmail.com&gt;<p>December 29, 2015 at 09:00:00am</p></header><div class="content"><p>@Howard: While we are at implementation details: I think this is the<br>typical case of what type theorists call &quot;structural equivalence&quot;. You can<br>think of Newton as a typedef (alias) for kg * m / s^2. Hence, if the<br>compiler can look this info up, it can most definitely determine that they<br>are the same and so is m * kg / s / s.<br></p><p>Yes, care needs to be taken about the associativity and commutativity of<br>multiplication of units, but that&#39;s not too hard either, it basically<br>amounts to some pattern matching along with symbolic computations<br>respecting algebraic identities (think of it as a compile-time &quot;unit<br>interpreter&quot;) and maybe some post-normalization.<br></p><p><br></p><p>On Tue, Dec 29, 2015 at 9:12 AM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1; first-class affordances to make dimensional analysis possible would be<br>&gt; incredibly useful.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; &gt; On Dec 29, 2015, at 12:11 AM, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; +1 for the ability to unit check expressions. It is harder to do than it<br>&gt; sounds because there are many equivalent units, for example force N = mass<br>&gt; kg * acceleration m/s^2. Therefore N, kg m/s^2, m/s^2 kg, etc. are all<br>&gt; equal.<br>&gt; &gt;<br>&gt; &gt; Sent from my iPad<br>&gt; &gt;<br>&gt; &gt;&gt; On 28 Dec 2015, at 9:33 AM, Greg Titus via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Dec 27, 2015, at 2:56 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; There’s some unfortunate extra boilerplate here, which could be<br>&gt; better handled with newtype support in the language, but when compiled with<br>&gt; optimizations the resulting code is nearly identical to using plain Ints.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Cool — have you checked the generated assembler for this conclusion?<br>&gt; But I guess there is some knowledge on how to build an optimizing compiler<br>&gt; in the core team ;-), so I&#39;d expect little to no penalty (I guess the<br>&gt; memory footprint of plain Ints is still better).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Yes, I have, and actually, the memory footprint is no different! These<br>&gt; are value-types that are exactly word-sized, and so get passed around in<br>&gt; registers and stored inline in larger structs.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;   - Greg<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>Author of the Sparkling language<br>http://h2co3.org/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/7c59d8c7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>December 29, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; Yes, care needs to be taken about the associativity and commutativity of multiplication of units, but that&#39;s not too hard either, it basically amounts to some pattern matching along with symbolic computations respecting algebraic identities (think of it as a compile-time &quot;unit interpreter&quot;) and maybe some post-normalization.<br>I agree: &quot;doing it right&quot; is no rocket science (pun intended ;-) — but I&#39;m quite sure it won&#39;t be possible unless the macro-system that might be introduced with Swift 4 is ready.<br>But there are possible workarounds for the lack metaprogramming the type system, so products with three or four factors should be possible without even changing the compiler (it will be ugly, though):<br>It is easy to define +/- for composed units, but it is a huge amount of code that has to be generated for all permutations.<br></p><p>@Tim Hawkins:<br>Thanks for posting the link — although it reminds me on feeling bad for not being in Hamburg right now ;-)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/b367d7c7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c965d88fab90b7e85514d0e3011c3caf?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tim Hawkins</string> &lt;tim.thawkins at gmail.com&gt;<p>December 29, 2015 at 02:00:00pm</p></header><div class="content"><p>This just popped up on HN and may be relevant to this discussion.<br></p><p><br>http://www.home.hs-karlsruhe.de/~fado0001/2015-32C3/paper-onecolumn-colour.pdf<br></p><p><br>On Tue, Dec 29, 2015, 16:11 Howard Lovatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 for the ability to unit check expressions. It is harder to do than it<br>&gt; sounds because there are many equivalent units, for example force N = mass<br>&gt; kg * acceleration m/s^2. Therefore N, kg m/s^2, m/s^2 kg, etc. are all<br>&gt; equal.<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; &gt; On 28 Dec 2015, at 9:33 AM, Greg Titus via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 27, 2015, at 2:56 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; There’s some unfortunate extra boilerplate here, which could be better<br>&gt; handled with newtype support in the language, but when compiled with<br>&gt; optimizations the resulting code is nearly identical to using plain Ints.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Cool — have you checked the generated assembler for this conclusion?<br>&gt; But I guess there is some knowledge on how to build an optimizing compiler<br>&gt; in the core team ;-), so I&#39;d expect little to no penalty (I guess the<br>&gt; memory footprint of plain Ints is still better).<br>&gt; &gt;<br>&gt; &gt; Yes, I have, and actually, the memory footprint is no different! These<br>&gt; are value-types that are exactly word-sized, and so get passed around in<br>&gt; registers and stored inline in larger structs.<br>&gt; &gt;<br>&gt; &gt;    - Greg<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151229/bf111dbc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi there!<br></p><p>I have to agree to Matthew that this list isn&#39;t the ideal place for everything:<br>It is easy to loose track, and good ideas might get lost.<br></p><p>Besides publishing my own experiments on what is possible already, I took a look on the tools offered by github — and imho it is an option to be considered.<br>So, if anyone wants to store his thoughts in a wiki, or publish playgrounds ands normal projects, please take a look at<br>https://github.com/orgs/SwiftTypesafeCalculations/teams/staff<br></p><p>I&#39;ve never used github for serious collaboration before, but I&#39;d expect that you can just join and start using the resources.<br></p><p>If someone has an alternative or an idea for a better structure at github, please write about it or ask for a takeover of the organization (or create one on your own if you come up with a better name)<br></p><p>Best regards,<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>January  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks Tino, I&#39;ll upload mine to that Repo shortly :)<br></p><p>On Thu, Jan 7, 2016 at 4:39 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br></p><p>&gt; Hi there!<br>&gt;<br>&gt; I have to agree to Matthew that this list isn&#39;t the ideal place for<br>&gt; everything:<br>&gt; It is easy to loose track, and good ideas might get lost.<br>&gt;<br>&gt; Besides publishing my own experiments on what is possible already, I took<br>&gt; a look on the tools offered by github — and imho it is an option to be<br>&gt; considered.<br>&gt; So, if anyone wants to store his thoughts in a wiki, or publish<br>&gt; playgrounds ands normal projects, please take a look at<br>&gt; https://github.com/orgs/SwiftTypesafeCalculations/teams/staff<br>&gt;<br>&gt; I&#39;ve never used github for serious collaboration before, but I&#39;d expect<br>&gt; that you can just join and start using the resources.<br>&gt;<br>&gt; If someone has an alternative or an idea for a better structure at github,<br>&gt; please write about it or ask for a takeover of the organization (or create<br>&gt; one on your own if you come up with a better name)<br>&gt;<br>&gt; Best regards,<br>&gt; Tino<br></p><p><br></p><p><br>-- <br> Wizard<br>james at supmenow.com<br>+44 7523 279 698<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/d20945e0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/069f7ef2d8a91cd35caa5bfc99a35773?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Mark Glossop</string> &lt;lists at cueballcentral.com&gt;<p>January  8, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 8 Jan 2016, at 00:39, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; I have to agree to Matthew that this list isn&#39;t the ideal place for everything:<br>&gt; It is easy to loose track, and good ideas might get lost.<br>&gt; <br>&gt; Besides publishing my own experiments on what is possible already, I took a look on the tools offered by github — and imho it is an option to be considered.<br>&gt; So, if anyone wants to store his thoughts in a wiki, or publish playgrounds ands normal projects, please take a look at<br>&gt; https://github.com/orgs/SwiftTypesafeCalculations/teams/staff<br></p><p>Heads-up: that URL gives a 404 (at least for me...)<br></p><p>Cheers,<br>M.<br>-- <br>Mark Glossop<br>E: lists at cueballcentral.com<br>TW: http://twitter.com/Cueball_AU<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Heads-up: that URL gives a 404 (at least for me...)<br>Odd… you aren&#39;t in China, are you? ;-)<br></p><p>Thank you for telling about the issue — although I have no idea about the reason and what to do about it<br>Maybe<br>https://github.com/SwiftTypesafeCalculations<br>works better... and if all fails, I can send invites to everyone whose email is registered at github.<br></p><p>Best regards,<br>Tino<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 12, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi there!<br></p><p>I hope there&#39;s still some interest in the topic (or in the cartwheels-video Matt promised ;-) and just finished the draft for a first proposal.<br>Instead of trying to turn typealias into some sort of newtype, which leaves a lot more questions open as I thought originally, I started with &quot;compile-time parameters&quot;:<br>The name of the feature can be discussed (as well as its details), but it would not only add typesafety to matrix, vector, tensor and other entities, but also offer a simple way to handle computations with physical quantities (three of those should be sufficient in most cases, so the idea mentioned by Thorsten should work fine).<br></p><p>I still haven&#39;t taken the time to take a detailed look at boost units, but I would be glad if someone with practical experience could contribute to the proposal — the same is true for all other parts, as I&#39;d happily turn the document into a joint paper (I&#39;m not sure, but maybe it could even become the first multi-author submission :)<br></p><p>To make this easier, I created a wiki-page; this should be editable without forking a repository (I haven&#39;t figured out if a can give write permissions to everyone, so it might be necessary to click somewhere to request permissions).<br>The URL is<br>https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters<br></p><p>Happy collaboration!<br>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 12, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi Tino,<br></p><p>the real advantage is missing from the proposal :-)<br></p><p>With the proposal it should be possible to write<br></p><p>func&lt;T, rows1, cols1, rows2, cols2 where cols1 == rows2&gt;(lhs: Matrix&lt;T, rows1, cols1&gt;, rhs: Matrix&lt;T, rows2, cols2&gt;) -&gt; Matrix&lt;T, rows1, cols2&gt;<br>{ … }<br></p><p><br>The example in the proposal just uses the static parameters for runtime checks which is no advantage over using init parameters.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 12.01.2016 um 15:22 schrieb Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; I hope there&#39;s still some interest in the topic (or in the cartwheels-video Matt promised ;-) and just finished the draft for a first proposal.<br>&gt; Instead of trying to turn typealias into some sort of newtype, which leaves a lot more questions open as I thought originally, I started with &quot;compile-time parameters&quot;:<br>&gt; The name of the feature can be discussed (as well as its details), but it would not only add typesafety to matrix, vector, tensor and other entities, but also offer a simple way to handle computations with physical quantities (three of those should be sufficient in most cases, so the idea mentioned by Thorsten should work fine).<br>&gt; <br>&gt; I still haven&#39;t taken the time to take a detailed look at boost units, but I would be glad if someone with practical experience could contribute to the proposal — the same is true for all other parts, as I&#39;d happily turn the document into a joint paper (I&#39;m not sure, but maybe it could even become the first multi-author submission :)<br>&gt; <br>&gt; To make this easier, I created a wiki-page; this should be editable without forking a repository (I haven&#39;t figured out if a can give write permissions to everyone, so it might be necessary to click somewhere to request permissions).<br>&gt; The URL is<br>&gt; https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters<br>&gt; <br>&gt; Happy collaboration!<br>&gt; Tino<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; With the proposal it should be possible to write<br>&gt; <br>&gt; func&lt;T, rows1, cols1, rows2, cols2 where cols1 == rows2&gt;(lhs: Matrix&lt;T, rows1, cols1&gt;, rhs: Matrix&lt;T, rows2, cols2&gt;) -&gt; Matrix&lt;T, rows1, cols2&gt;<br>Wait, I miss a &quot;*&quot; in the signature ;-) — but yes, this is one major goal.<br>I&#39;m just not sure if it&#39;s clever to actually write down the whole example (vector math looks scary to some people — maybe it&#39;s better to simply say &quot;you can do it&quot; ;-)<br></p><p>The tiny example should only illustrate how the parameters can be used inside the type. It might be a good idea to show how it&#39;s possible to do solve some real world problems like applying a force vector to an object with a given impulse… (if I remember right, there&#39;s a thread started by a teacher who uses playgrounds in class — I guess I&#39;ll ask him for support).<br></p><p>Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 12, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 12.01.2016 um 22:29 schrieb Tino Heth &lt;2th at gmx.de&gt;:<br>&gt; <br>&gt;&gt; With the proposal it should be possible to write<br>&gt;&gt; <br>&gt;&gt; func&lt;T, rows1, cols1, rows2, cols2 where cols1 == rows2&gt;(lhs: Matrix&lt;T, rows1, cols1&gt;, rhs: Matrix&lt;T, rows2, cols2&gt;) -&gt; Matrix&lt;T, rows1, cols2&gt;<br>&gt; Wait, I miss a &quot;*&quot; in the signature ;-) — but yes, this is one major goal.<br></p><p>Oh, indeed, I forgot the &quot;*“ :-)<br>But it’s proof of the usefulness of the strong typing proposed that you could deduce what operator I meant, isn’t it? ;-)<br></p><p>&gt; I&#39;m just not sure if it&#39;s clever to actually write down the whole example (vector math looks scary to some people — maybe it&#39;s better to simply say &quot;you can do it&quot; ;-)<br></p><p>Writing down stuff explicitly is important because only then one can see whether something really works out as desired.<br>So, yeah, we should have lots of concrete examples in the proposal.<br></p><p>&gt; The tiny example should only illustrate how the parameters can be used inside the type. It might be a good idea to show how it&#39;s possible to do solve some real world<br></p><p>Yeah, but that same code would have been possible without the proposal (except that the parameters would have been let properties of the instance).<br></p><p>&gt; problems like applying a force vector to an object with a given impulse… (if I remember right, there&#39;s a thread started by a teacher who uses playgrounds in class — I guess I&#39;ll ask him for support).<br></p><p>Good idea!<br></p><p>-Thorsten<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 12, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Tino, Thanks for making your proposal.<br></p><p>One of the points from your ‘alternatives considered’ section,<br>&gt; Marked parameters<br>&gt; <br>&gt; It would be possible to keep the parameters in the initializer (or function) and mark them with a keyword: init(static dimensions: Int) {...<br>&gt; <br>got me thinking.  What if parameters marked with static, or constexpr, or some such, could complement template parameters, rather than being an alternative to them.  Basically, stuff between the angle brackets is relevant for determining storage needed, and other constexpr parameters enable arbitrary compile time checks.  I hope the mailing list doesn’t mind a little brainstorming about these further off features.  Probably easiest to explain myself in terms of the matrix example:<br></p><p>struct Matrix&lt;T:ScalarType, NRows:UInt, NCols:UInt&gt;{<br>  let entries: [ScalarType]<br></p><p>  //note the initializer parameter marked as a constexpr,  <br>  //which enables further compile time checks with a `where` clause<br>  init(entries: constexpr [ScalarType] where entries.count == NRows * NCols) {<br>    self.entries = entries<br>  }<br>	<br>  subscript(i:Int, j:Int) -&gt; ScalarType{<br>    …<br>  }	<br>}<br></p><p>typealias SquareMatrix = Matrix where NRows == NCols<br></p><p>extension SquareMatrix{<br>  static alias Dim = NRows//no additional storage<br>  func determinant() -&gt; ScalarType{<br>    ...<br>  }<br>}<br></p><p>struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br>//                       ^~~ &#39;restriction’ clause, i.e., not inheritance;<br>//                       determinant() is executed at compile time,<br>//                       since `entries` is a constexpr<br></p><p><br>struct AntisymmetricMatrix: InvertibleMatrix where {<br>  //more complicated restriction clause, something like a<br>  //compile time predicate/closure, which operates on member variables that are constexprs<br>  for i in 0..&lt;Dim{<br>    for j in 0..&lt;Dim{<br>      static_assert(entries[i][j] == -entries[j][i], “invalid entries”);<br>    }<br>  }<br>  <br>}<br></p><p>struct ComplexNumber: AntisymmetricMatrix&lt;Dim: 2&gt; <br>		      where entries[0,0] == entries[1,1] <br>			    &amp;&amp; entries[0,1] == -entries[1,0]<br></p><p>struct Rotor: ComplexNumber where magnitude() == 1.0<br></p><p>func *(lhs:ComplexNumber, rhs:ComplexNumber) -&gt; ComplexNumber{<br>  return ComplexNumber( entries: [lhs.entries[0,0]* …)<br>}<br></p><p>//another syntax option this feature:<br>typerestriction InvertibleMatrix = SquareMatrix where determinant() != 0 <br></p><p>//and another:<br>typespecialization InvertibleMatrix = SquareMatrix where determinant() != 0 <br>Some obvious drawbacks here are long compile times (eg, computing a 10x10 determinant), and of course many situations where you can’t know things at compile time so this doesn’t help you.  But I think it’s an interesting direction to look at.  A type system with such capabilities, + playgrounds/REPLs, and you’ve got something akin to Mathematica, but without the mind-bending syntax.<br></p><p>Matt<br></p><p><br>&gt; On Jan 12, 2016, at 06:22, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Hi there!<br>&gt; <br>&gt; I hope there&#39;s still some interest in the topic (or in the cartwheels-video Matt promised ;-) and just finished the draft for a first proposal.<br>&gt; Instead of trying to turn typealias into some sort of newtype, which leaves a lot more questions open as I thought originally, I started with &quot;compile-time parameters&quot;:<br>&gt; The name of the feature can be discussed (as well as its details), but it would not only add typesafety to matrix, vector, tensor and other entities, but also offer a simple way to handle computations with physical quantities (three of those should be sufficient in most cases, so the idea mentioned by Thorsten should work fine).<br>&gt; <br>&gt; I still haven&#39;t taken the time to take a detailed look at boost units, but I would be glad if someone with practical experience could contribute to the proposal — the same is true for all other parts, as I&#39;d happily turn the document into a joint paper (I&#39;m not sure, but maybe it could even become the first multi-author submission :)<br>&gt; <br>&gt; To make this easier, I created a wiki-page; this should be editable without forking a repository (I haven&#39;t figured out if a can give write permissions to everyone, so it might be necessary to click somewhere to request permissions).<br>&gt; The URL is<br>&gt; https://github.com/SwiftTypesafeCalculations/Home/wiki/Compile-time-parameters<br>&gt; <br>&gt; Happy collaboration!<br>&gt; Tino<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160112/fe07317a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 13, 2016 at 12:00:00pm</p></header><div class="content"><p>Hello Matt!<br></p><p>&gt; Hi Tino, Thanks for making your proposal.<br>well, it has to be decided yet if that document turns into a real proposal (but I hope so ;-)  <br></p><p>&gt; got me thinking.  What if parameters marked with static, or constexpr, or some such, could complement template parameters, rather than being an alternative to them.  Basically, stuff between the angle brackets is relevant for determining storage needed, and other constexpr parameters enable arbitrary compile time checks.  I hope the mailing list doesn’t mind a little brainstorming about these further off features.<br>imho the list is quite good at simply ignoring stuff it doesn&#39;t care for :-) — but I would expect some feedback if you open a thread for the topic:<br>I&#39;m still waiting for someone asking for compile-time execution with a reference to <br>https://www.youtube.com/watch?v=UTqZNujQOlA &lt;https://www.youtube.com/watch?v=UTqZNujQOlA&gt;<br>(it&#39;s such a cool concept — we really should have a use case for it :), and your idea is a variant of this feature.<br></p><p>I have read several times that Swift 3 won&#39;t have macros, but have the impression that this is a huge topic, so even if proposals heading in this direction won&#39;t (most likely) be accepted now, they might become important next year.<br>As far as I know, some compilers are already clever enough to replace simple calculations (like secondsPerDay = 60*60*24; f = pi * 2.0;…), so it is not that strange to extend that concept.<br>In theory, this could work without new keywords (when all input is known at compile time, just evaluate), but as speed at runtime isn&#39;t always the most important aspect, some sort of hint might be better.<br></p><p>I&#39;m sure that checks at compile-time would not only be useful for calculations:<br>NSURL, for example, can be initialized with a string that simply does not represent an URL (therefore, init can return nil). But if the parameter is a string literal, you&#39;ll always have the same result at runtime…<br></p><p>Best regards,<br>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/7fdf5c1b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 13, 2016 at 09:00:00am</p></header><div class="content"><p>Hey Tino, <br></p><p>&gt; On Jan 13, 2016, at 03:50, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; I&#39;m still waiting for someone asking for compile-time execution with a reference to <br>&gt; https://www.youtube.com/watch?v=UTqZNujQOlA &lt;https://www.youtube.com/watch?v=UTqZNujQOlA&gt;<br>&gt; (it&#39;s such a cool concept — we really should have a use case for it :), and your idea is a variant of this feature.<br></p><p>Yes, what I was suggesting yesterday was at least half inspired by that video, which came up in an earlier thread.<br></p><p><br>&gt; In theory, this could work without new keywords (when all input is known at compile time, just evaluate),<br></p><p>True, I think you could get a lot of benefit here without new keywords, perhaps with a compiler plugin &lt;https://doc.rust-lang.org/stable/book/compiler-plugins.html&gt; as Sean suggested.  But there is one interesting part that seems like it will require a new bit of syntax, which is being able to define new types based on restrictions of some other type&#39;s member values.  I don’t know if others find that as interesting as I do though :)<br></p><p><br>&gt; I&#39;m sure that checks at compile-time would not only be useful for calculations:<br>&gt; NSURL, for example, can be initialized with a string that simply does not represent an URL (therefore, init can return nil). But if the parameter is a string literal, you&#39;ll always have the same result at runtime…<br></p><p>Yep, that’s another good example.  Here’s to hoping it finds its way into Swift 4 :)<br></p><p>Matt  <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/2c23a2e3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 13, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 12.01.2016 um 23:49 schrieb Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br>&gt; //                       ^~~ &#39;restriction’ clause, i.e., not inheritance;<br>&gt; //                       determinant() is executed at compile time,<br>&gt; //                       since `entries` is a constexpr<br></p><p>Wouldn&#39;t that only work for literal matrices?<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/40ee4e0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 13, 2016 at 10:00:00am</p></header><div class="content"><p>That was my thinking when I wrote it, but I’m not sure exactly what the limits would be.  For example, the product of 2 invertible matrices is an invertible matrix, giving you another way to construct one.<br></p><p>Matt<br></p><p><br>&gt; On Jan 13, 2016, at 09:56, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 12.01.2016 um 23:49 schrieb Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br>&gt;&gt; //                       ^~~ &#39;restriction’ clause, i.e., not inheritance;<br>&gt;&gt; //                       determinant() is executed at compile time,<br>&gt;&gt; //                       since `entries` is a constexpr<br>&gt; <br>&gt; Wouldn&#39;t that only work for literal matrices?<br>&gt; <br>&gt; -Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/967fe437/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>January 13, 2016 at 02:00:00pm</p></header><div class="content"><p>… in exact arithmetic, not in floating-point, which is what people tend to actually use for matrices.  For that matter, the entire notion of “invertible” as a binary attribute is problematic when dealing with approximate arithmetic; a matrix may be formally invertible but so ill-conditioned that the result is effectively meaningless.<br></p><p>Not really trying to shoot you down, just observing that this is an extremely subtle example with lots of hidden sharp edges.<br></p><p>– Steve<br></p><p>&gt; On Jan 13, 2016, at 1:19 PM, Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That was my thinking when I wrote it, but I’m not sure exactly what the limits would be.  For example, the product of 2 invertible matrices is an invertible matrix, giving you another way to construct one.<br>&gt; <br>&gt; Matt<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 09:56, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 12.01.2016 um 23:49 schrieb Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br>&gt;&gt;&gt; //                       ^~~ &#39;restriction’ clause, i.e., not inheritance;<br>&gt;&gt;&gt; //                       determinant() is executed at compile time,<br>&gt;&gt;&gt; //                       since `entries` is a constexpr<br>&gt;&gt; <br>&gt;&gt; Wouldn&#39;t that only work for literal matrices?<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/8ec93789/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 13, 2016, at 11:16, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; … in exact arithmetic, not in floating-point, which is what people tend to actually use for matrices.  For that matter, the entire notion of “invertible” as a binary attribute is problematic when dealing with approximate arithmetic; a matrix may be formally invertible but so ill-conditioned that the result is effectively meaningless.<br>&gt; <br>&gt; Not really trying to shoot you down, just observing that this is an extremely subtle example with lots of hidden sharp edges.<br>&gt; <br>&gt; – Steve<br></p><p>That’s a good point.  So then I wonder if exact arithmetic wouldn’t be good enough for a lot of entry level math &amp; science applications, especially the ones where this type of approach would come to mind in the first place.<br></p><p>Something like,<br></p><p>struct Rational:CustomDebugStringConvertible{<br>	let numerator, denominator: Int<br>	var debugDescription:String{<br>	  get{<br>	   return &quot;\(Double(numerator)/Double(denominator))&quot;<br>	    }<br>	}<br>}<br></p><p>func *(lhs:Rational,rhs:Rational) -&gt; Rational{<br>  return Rational(numerator: lhs.numerator*rhs.numerator, <br>                denominator: lhs.denominator * rhs.denominator)<br>}<br></p><p>func *(lhs:Int,rhs:Rational) -&gt; Rational{<br>  return Rational(numerator: lhs*rhs.numerator, <br>                denominator: rhs.denominator)<br>}<br></p><p>let π = Rational(numerator: 355, denominator: 113)<br>let two_π = 2 * π<br></p><p><br>might get you pretty far with 64 bits.<br></p><p>Matt<br> <br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/7700bdfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>January 14, 2016 at 10:00:00am</p></header><div class="content"><p>Even with cancellation, the number of bits required to represent the exact terms involved in computing the inverse grow like O(n log n) in the typical case, IIRC.  So exact arithmetic rapidly becomes unfeasible for even modestly large matrices.<br></p><p>Aside from purely symbolic matrices that come up in theoretical physics and matrices over finite fields, the entries of a matrix are rarely known exactly, so the rich set of approximate-rank-revealing and numerically stable methods that we have for floating-point turn out to be much more useful anyway.<br></p><p>That’s not to say that it isn’t fun to play around with these concepts, of course =)<br></p><p>– Steve<br></p><p>&gt; On Jan 13, 2016, at 11:27 PM, Matt Whiteside &lt;mwhiteside.dev at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 11:16, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; … in exact arithmetic, not in floating-point, which is what people tend to actually use for matrices.  For that matter, the entire notion of “invertible” as a binary attribute is problematic when dealing with approximate arithmetic; a matrix may be formally invertible but so ill-conditioned that the result is effectively meaningless.<br>&gt;&gt; <br>&gt;&gt; Not really trying to shoot you down, just observing that this is an extremely subtle example with lots of hidden sharp edges.<br>&gt;&gt; <br>&gt;&gt; – Steve<br>&gt; <br>&gt; That’s a good point.  So then I wonder if exact arithmetic wouldn’t be good enough for a lot of entry level math &amp; science applications, especially the ones where this type of approach would come to mind in the first place.<br>&gt; <br>&gt; Something like,<br>&gt; <br>&gt; struct Rational:CustomDebugStringConvertible{<br>&gt; 	let numerator, denominator: Int<br>&gt; 	var debugDescription:String{<br>&gt; 	  get{<br>&gt; 	   return &quot;\(Double(numerator)/Double(denominator))&quot;<br>&gt; 	    }<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; func *(lhs:Rational,rhs:Rational) -&gt; Rational{<br>&gt;   return Rational(numerator: lhs.numerator*rhs.numerator, <br>&gt;                 denominator: lhs.denominator * rhs.denominator)<br>&gt; }<br>&gt; <br>&gt; func *(lhs:Int,rhs:Rational) -&gt; Rational{<br>&gt;   return Rational(numerator: lhs*rhs.numerator, <br>&gt;                 denominator: rhs.denominator)<br>&gt; }<br>&gt; <br>&gt; let π = Rational(numerator: 355, denominator: 113)<br>&gt; let two_π = 2 * π<br>&gt; <br>&gt; <br>&gt; might get you pretty far with 64 bits.<br>&gt; <br>&gt; Matt<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/530c5c10/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 13, 2016 at 11:00:00am</p></header><div class="content"><p>Matt, funny you should use that example… We might be trying to work on the same sorts of problem :-)<br></p><p>Thorsten, I don’t see why it wouldn’t work for any immutable matrix (literal or otherwise), or even mutable matrices if assignment operations were allowed to fail*, or Swift supported class clusters (such as NSNumber, appropriately enough) it could just change its “private” type behind the scenes if needs be (at least I think I remember reading that NSNumber does that).<br></p><p>[At this point I remembered that Matt was thinking the “where determinant() != 0” part was specifically going to be a compile-time check, and pretty much everything I’d written was coming from the run-time point of view…] Ok, so… what if “where” clauses in the “inheritance&quot; section forced all the initializers to be failable, and there was an implicit “if !(where clause) { return nil }” inserted at the end of every initializer? It’d cut down on boilerplate code, and it’d tell whomever was looking at the public interface two things: 1) That all the initializers had “universal precondition”, and 2) exactly what that universal precondition is. I mean if you were using a matrix library and only had what they exposed to go on, which would be more useful to you, having an API note that says, “blah blah square matrix blah nonzero determinant blah blah”, or being able to examine the actual bit of code that will determine if your data can pass the “universal” validation check?<br></p><p>*Yes, I know you can use will/didSet to roll back the changes if the new value fails some validation check. I can’t figure out a way to get those to throw errors, though, nor is there currently a way to have subscript() throw an error (somebody’s already filed a radar about that). Since there’s no way to alert the programmer that the assignment they just performed might not stick, this seems like a colossally bad idea (for general code, anyway… obviously if it works in your specific situation, then go for it).<br></p><p>- Dave Sweeris<br></p><p>(At what point does something need to get split off into its own thread? Because after typing this all up, I’m not sure it’s particularly related to what we’ve been talking about here.)<br></p><p>&gt; On Jan 13, 2016, at 09:56, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 12.01.2016 um 23:49 schrieb Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br>&gt;&gt; //                       ^~~ &#39;restriction’ clause, i.e., not inheritance;<br>&gt;&gt; //                       determinant() is executed at compile time,<br>&gt;&gt; //                       since `entries` is a constexpr<br>&gt; <br>&gt; Wouldn&#39;t that only work for literal matrices?<br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/a69c5723/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2b19ddab2d7de4523412c875c258e278?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Matt Whiteside</string> &lt;mwhiteside.dev at gmail.com&gt;<p>January 13, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Dave,<br></p><p>&gt; On Jan 13, 2016, at 11:37, davesweeris at mac.com wrote:<br>&gt; <br>&gt;  Ok, so… what if “where” clauses in the “inheritance&quot; section forced all the initializers to be failable, and there was an implicit “if !(where clause) { return nil }” inserted at the end of every initializer? It’d cut down on boilerplate code, and it’d tell whomever was looking at the public interface two things: 1) That all the initializers had “universal precondition”, and 2) exactly what that universal precondition is. <br></p><p>Interesting.  Yes, I had been thinking strictly from the compile time point of view, but something like this on runtime side could provide a lot of benefit too.<br></p><p>&gt; <br>&gt; *Yes, I know you can use will/didSet to roll back the changes if the new value fails some validation check. I can’t figure out a way to get those to throw errors, though, nor is there currently a way to have subscript() throw an error (somebody’s already filed a radar about that). Since there’s no way to alert the programmer that the assignment they just performed might not stick, this seems like a colossally bad idea (for general code, anyway… obviously if it works in your specific situation, then go for it).<br></p><p>Without having thought about it too much, I wonder if the new behaviors proposal &lt;https://gist.github.com/jckarter/50b838e7f036fe85eaa3&gt; could be helpful here somehow.  Perhaps this type of validation check could be implemented as a behavior.<br></p><p>Matt<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/05cd5df6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Epic: Typesafe calculations</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 14, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; Am 13.01.2016 um 20:37 schrieb davesweeris at mac.com:<br>&gt; <br>&gt; Matt, funny you should use that example… We might be trying to work on the same sorts of problem :-)<br>&gt; <br>&gt; Thorsten, I don’t see why it wouldn’t work for any immutable matrix (literal or otherwise), or even mutable matrices if assignment operations were allowed to fail*, or Swift supported class clusters (such as NSNumber, appropriately enough) it could just change its “private” type behind the scenes if needs be (at least I think I remember reading that NSNumber does that).<br></p><p>Ah, ok, I see what you mean. The question is when should determinant() be calculated? If Matrix is immutable it can be done just after initialization and be memoized. Or lazy at the first time the dynamic type is needed (and then memoized). This would add a lot of complication, though.<br></p><p>A very nice research language called Cecil (by Craig Chambers from the University of Washington, later replaced by the similar language Diesel) once had a feature like that. They called it &quot;Predicate Objects“ (see http://www.cs.washington.edu/research/projects/cecil/www/research.html#cecil). <br>Cecil had many very nice features like multimethods with multiple dispatch implemented in a quite nice way.<br></p><p>-Thorsten<br>	<br>&gt; <br>&gt; [At this point I remembered that Matt was thinking the “where determinant() != 0” part was specifically going to be a compile-time check, and pretty much everything I’d written was coming from the run-time point of view…] Ok, so… what if “where” clauses in the “inheritance&quot; section forced all the initializers to be failable, and there was an implicit “if !(where clause) { return nil }” inserted at the end of every initializer? It’d cut down on boilerplate code, and it’d tell whomever was looking at the public interface two things: 1) That all the initializers had “universal precondition”, and 2) exactly what that universal precondition is. I mean if you were using a matrix library and only had what they exposed to go on, which would be more useful to you, having an API note that says, “blah blah square matrix blah nonzero determinant blah blah”, or being able to examine the actual bit of code that will determine if your data can pass the “universal” validation check?<br>&gt; <br>&gt; *Yes, I know you can use will/didSet to roll back the changes if the new value fails some validation check. I can’t figure out a way to get those to throw errors, though, nor is there currently a way to have subscript() throw an error (somebody’s already filed a radar about that). Since there’s no way to alert the programmer that the assignment they just performed might not stick, this seems like a colossally bad idea (for general code, anyway… obviously if it works in your specific situation, then go for it).<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; (At what point does something need to get split off into its own thread? Because after typing this all up, I’m not sure it’s particularly related to what we’ve been talking about here.)<br>&gt; <br>&gt;&gt; On Jan 13, 2016, at 09:56, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 12.01.2016 um 23:49 schrieb Matt Whiteside via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; struct InvertibleMatrix: SquareMatrix where determinant() != 0 <br>&gt;&gt;&gt; //                       ^~~ &#39;restriction’ clause, i.e., not inheritance;<br>&gt;&gt;&gt; //                       determinant() is executed at compile time,<br>&gt;&gt;&gt; //                       since `entries` is a constexpr<br>&gt;&gt; <br>&gt;&gt; Wouldn&#39;t that only work for literal matrices?<br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160114/7ecea7b1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
