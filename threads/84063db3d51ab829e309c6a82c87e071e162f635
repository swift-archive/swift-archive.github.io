<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Proposal: Deprecate optionals in string	interpolation</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 24, 2016 at 09:00:00am</p></header><div class="content"><p>Charlie Monroe via swift-evolution &lt;swift-evolution at ...&gt; writes:<br></p><p>&gt; <br>&gt; I&#39;ve jotted up a proposal here:<br>&gt; https://gist.github.com/charlieMonroe/82e1519dd2b57029f69bc7abe99d7385<br>&gt; <br>&gt; Please let me know if there are any comments to it.<br></p><p>Hi, sorry for arriving late but I had missed this thread.<br></p><p>I happen to have submitted a couple PRs related to this problem just last week:<br>https://github.com/apple/swift/pull/2551<br>https://github.com/apple/swift-corelibs-xctest/pull/110<br></p><p>In this case, the issue is not just with Optional&#39;s string interpolation,<br>but with Swift&#39;s implicit promotion. XCTAssertEqual()&#39;s signature is:<br></p><p>public func XCTAssertEqual&lt;T : Equatable&gt;(_ expression1: @autoclosure ()<br>throws -&gt; T?, _ expression2: @autoclosure () throws -&gt; T?, _ message:<br>@autoclosure () -&gt; String = &quot;&quot;, file: StaticString = #file, line: UInt =<br>#line) -&gt; Void<br></p><p>so in a test you would call it like<br></p><p>XCTAssertEqual(1, 2, &quot;message&quot;)<br></p><p>but then the values are implicitly promoted to Optional&lt;Int&gt;, and when the<br>test fails you get the confusing message<br></p><p>XCTAssertEqual failed: (&quot;Optional(1)&quot;) is not equal to (&quot;Optional(2)&quot;) - message<br></p><p>which is clearly unexpected, since the parameters weren&#39;t optionals at all.<br></p><p>My proposed solution to this was to add an overload to XCTAssertEqual()<br>where the parameters aren&#39;t optionals, to prevent implicit promotion and<br>produce the expected output. It hadn&#39;t occurred to me that it might have<br>been desirable to change the Optional string interpolation altogether.<br></p><p>Regarding the proposal:<br></p><p>&gt; This proposal suggests deprecating string interpolation of Optional in<br>order to prevent unexpected results at compile time.<br></p><p>I assume you mean &quot;at runtime&quot; here?<br></p><p>I think the detailed design needs  some more thought. The &quot;Uninterpolable&quot;<br>protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br></p><p>I&#39;m not even sure if the general direction of a compile time warning is the<br>right one, and if the problem wouldn&#39;t be better solved by simply not making<br>Optional put &quot;Optional()&quot; around the value in its .description.<br></p><p>Arguably, if you do this:<br></p><p>print([1, 2, 3])<br></p><p>you get &quot;[1, 2, 3]&quot;, not &quot;Array([1, 2, 3])&quot;. So why should Optional behave<br>differently?<br></p><p>It would seem to me that the most obvious solution would be to make Optional<br>conform to CustomStringConvertible, like this:<br></p><p>extension Optional: CustomStringConvertible {<br>    public var description: String {<br>        switch self {<br>        case .some(let x): return &quot;\(x)&quot;<br>        case .none: return &quot;nil&quot;<br>        }<br>    }<br>}<br></p><p>interestingly, this doesn&#39;t quite seem to work at the moment:<br></p><p>let o = Optional(1)<br></p><p>print(o.description)        // &quot;1&quot;, ok<br>print(o.debugDescription)   // &quot;Optional(1)&quot;, ok<br>print(o)                    // &quot;1&quot;, ok<br>debugPrint(o)               // &quot;Optional(1)&quot;, ok<br>print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br></p><p><br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Nicola, thanks for the feedback.<br></p><p>&gt; I assume you mean &quot;at runtime&quot; here?<br></p><p>That&#39;s probably my wrong wording. :) The unexpected result is at runtime, but we&#39;d like to catch this at compile time. I&#39;ve updated it to say<br></p><p>&quot;in order to prevent unexpected results already at compile time&quot; - hopefully that&#39;s a clearer wording.<br></p><p>&gt; I think the detailed design needs  some more thought. The &quot;Uninterpolable&quot;<br>&gt; protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br></p><p>Originally, the proposal was simply to emit a warning for interpolation of Optionals, but several people made good points:<br></p><p>- there may be other types you may not want to use for interpolation - as mentioned in the proposal, e.g. private data structures that would expose something you want to keep private, various enum values, etc. Which is why I&#39;ve started thinking about making a protocol that would indicate the type is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to make a more robust and customizable solution.<br></p><p>An alternative to this would be to use annotations or just drop this customizability completely. But I think with Swift and its protocol-driven development, marking the type with this protocol is the most robust way to go.<br></p><p>- both .description and .debugDescription are mentioned in alternatives for the Fix-It. <br></p><p>&quot;as Any&quot; seemed, however, the cleanest and most robust solution to me, since then the Uninterpolable protocol can be applied to any type without forcing the type to conform to CustomStringConvertible as well. I agree that it&#39;s kind of a hack, though.<br></p><p>&gt; I&#39;m not even sure if the general direction of a compile time warning is the<br>&gt; right one, and if the problem wouldn&#39;t be better solved by simply not making<br>&gt; Optional put &quot;Optional()&quot; around the value in its .description.<br></p><p>There are many people oposing this and expecting the Optional() wrap around the value, indicating the actual type. Actually, including me - I agree it can be useful for some types of debugging since in what you wrote further, there&#39;d be no difference between description of [1, 2, 3] (i.e. [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br></p><p>There are legitimate usecases where the current behavior is correct, but in most of cases, having an optional in string interpolation will lead either to unnecessary clutter in the log/console or bugs - in which case even &quot;nil&quot; is not correct to be used for the interpolation. Which is the basis for this proposal.<br></p><p>&gt; print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br></p><p>String has several overloads for the init(stringInterpolationSegment:) initiailizer. Optional falls into the generic &lt;T&gt; category, which will call String(optional) - which most likely uses debugDescription.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, May 24, 2016 at 12:01 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>wrote:<br></p><p>&gt; Hi Nicola, thanks for the feedback.<br>&gt;<br>&gt; &gt; I assume you mean &quot;at runtime&quot; here?<br>&gt;<br>&gt; That&#39;s probably my wrong wording. :) The unexpected result is at runtime,<br>&gt; but we&#39;d like to catch this at compile time. I&#39;ve updated it to say<br>&gt;<br>&gt; &quot;in order to prevent unexpected results already at compile time&quot; -<br>&gt; hopefully that&#39;s a clearer wording.<br>&gt;<br></p><p>Aha, now I understand :-)<br></p><p>Perhaps &quot;in order to detect potentially undesired behavior at compile time&quot;<br>would be even clearer?<br></p><p><br>&gt;<br>&gt; &gt; I think the detailed design needs  some more thought. The<br>&gt; &quot;Uninterpolable&quot;<br>&gt; &gt; protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br>&gt;<br>&gt; Originally, the proposal was simply to emit a warning for interpolation of<br>&gt; Optionals, but several people made good points:<br>&gt;<br>&gt; - there may be other types you may not want to use for interpolation - as<br>&gt; mentioned in the proposal, e.g. private data structures that would expose<br>&gt; something you want to keep private, various enum values, etc. Which is why<br>&gt; I&#39;ve started thinking about making a protocol that would indicate the type<br>&gt; is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to<br>&gt; make a more robust and customizable solution.<br>&gt;<br></p><p>I&#39;m not sure if this is a strong enough motivation.<br>The customization point already provided by the language is<br>CustomStringConvertible. That&#39;s the place where one can provide a readable<br>description, hiding implementation details.<br></p><p><br>&gt;<br>&gt; An alternative to this would be to use annotations or just drop this<br>&gt; customizability completely. But I think with Swift and its protocol-driven<br>&gt; development, marking the type with this protocol is the most robust way to<br>&gt; go.<br>&gt;<br>&gt; - both .description and .debugDescription are mentioned in alternatives<br>&gt; for the Fix-It.<br>&gt;<br></p><p>The direct use of .description and .debugDescription is discouraged in the<br>API docs, so I don&#39;t think this is a viable option.<br></p><p><br>&gt;<br>&gt; &quot;as Any&quot; seemed, however, the cleanest and most robust solution to me,<br>&gt; since then the Uninterpolable protocol can be applied to any type without<br>&gt; forcing the type to conform to CustomStringConvertible as well. I agree<br>&gt; that it&#39;s kind of a hack, though.<br>&gt;<br>&gt; &gt; I&#39;m not even sure if the general direction of a compile time warning is<br>&gt; the<br>&gt; &gt; right one, and if the problem wouldn&#39;t be better solved by simply not<br>&gt; making<br>&gt; &gt; Optional put &quot;Optional()&quot; around the value in its .description.<br>&gt;<br>&gt; There are many people oposing this and expecting the Optional() wrap<br>&gt; around the value, indicating the actual type. Actually, including me - I<br>&gt; agree it can be useful for some types of debugging since in what you wrote<br>&gt; further, there&#39;d be no difference between description of [1, 2, 3] (i.e.<br>&gt; [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br>&gt;<br></p><p>There&#39;s also no difference between print(Int(1)) and print(UInt(1)): they<br>both output just &quot;1&quot;.<br></p><p>I think &quot;debugging&quot; is the key word here. If the distinction between<br>CustomStringConvertible and CustomDebugStringConvertible is supposed to be<br>between providing a user-friendly description and a description useful for<br>debugging, I think it makes sense to make the former as terse as possible<br>and the latter as informative as possible.<br></p><p><br>&gt; There are legitimate usecases where the current behavior is correct, but<br>&gt; in most of cases, having an optional in string interpolation will lead<br>&gt; either to unnecessary clutter in the log/console or bugs - in which case<br>&gt; even &quot;nil&quot; is not correct to be used for the interpolation. Which is the<br>&gt; basis for this proposal.<br>&gt;<br>&gt; &gt; print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br>&gt;<br>&gt; String has several overloads for the init(stringInterpolationSegment:)<br>&gt; initiailizer. Optional falls into the generic &lt;T&gt; category, which will call<br>&gt; String(optional) - which most likely uses debugDescription.<br>&gt;<br>&gt;<br>This is the relevant code:<br>https://github.com/apple/swift/blob/cf73dd9177c231a15429b08ae889e94f20e53f50/stdlib/public/core/OutputStream.swift#L322-L331<br></p><p>I presume that it shouldn&#39;t be a problem to change it to use<br>CustomStringConvertible instead.<br></p><p>The above code also hints that there&#39;s another odd behavior in the current<br>implementation:<br></p><p>struct Foo: CustomStringConvertible, CustomDebugStringConvertible {<br>    var description: String { return &quot;normal&quot; }<br>    var debugDescription: String { return &quot;debug&quot; }<br>}<br></p><p>let f = Foo()<br>let of = Optional(f)<br></p><p>print(f)        // &quot;normal&quot;: ok<br>debugPrint(f)   // &quot;debug&quot;: ok<br>print(of)       // &quot;Optional(debug)&quot;: unexpected<br>debugPrint(of)  // &quot;Optional(debug)&quot;: ok<br></p><p>--<br>Nicola<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/243c1dcf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Aha, now I understand :-)<br>&gt; <br>&gt; Perhaps &quot;in order to detect potentially undesired behavior at compile time&quot; would be even clearer?<br></p><p>Sounds much better, thanks!<br></p><p>&gt; - there may be other types you may not want to use for interpolation - as mentioned in the proposal, e.g. private data structures that would expose something you want to keep private, various enum values, etc. Which is why I&#39;ve started thinking about making a protocol that would indicate the type is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to make a more robust and customizable solution.<br>&gt; <br>&gt; I&#39;m not sure if this is a strong enough motivation.<br>&gt; The customization point already provided by the language is CustomStringConvertible. That&#39;s the place where one can provide a readable description, hiding implementation details.<br></p><p>Yes, but this is the other way around. Since it is allowed to interpole types that are neither CustomStringConvertible or CustomDebugStringConvertible, it might be a good idea to take an approach from the other side as well and disallow some of them from being interpoled.<br></p><p>&gt;  - both .description and .debugDescription are mentioned in alternatives for the Fix-It.<br>&gt; <br>&gt; The direct use of .description and .debugDescription is discouraged in the API docs, so I don&#39;t think this is a viable option.<br></p><p>Two options then:<br></p><p>a) introduce a new variable on Optional, e.g. .optionalDescription which would stringify the Optional into what&#39;s the current behavior. Also, .valueDescription could be introduced, which would either print &quot;nil&quot; or description of the value it&#39;s wrapping (by invoking .description on values that are CustomStringConvertible, or using printDebug).<br></p><p>b) within the declaration of these variables on Optional, specify that this is the designated way to stringify the Optional. There is IMHO no reason other than both values being used internally for various tasks and providing a user unfriendly representation of the object. Both .description and .debugDescription should have no side-effects.<br></p><p>&gt;  There are many people oposing this and expecting the Optional() wrap around the value, indicating the actual type. Actually, including me - I agree it can be useful for some types of debugging since in what you wrote further, there&#39;d be no difference between description of [1, 2, 3] (i.e. [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br>&gt; <br>&gt; There&#39;s also no difference between print(Int(1)) and print(UInt(1)): they both output just &quot;1&quot;.<br></p><p>Good point.<br></p><p>&gt; I presume that it shouldn&#39;t be a problem to change it to use CustomStringConvertible instead.<br></p><p>That&#39;s true, but you rarely use print directly on the object (at least I don&#39;t), since you usually need a bit more context for it, so you use string interpolation to add the context - and sometimes you might want the optional with its current behavior.<br></p><p>There are several approaches this propsal can take:<br></p><p>1) The stdlib will use .description on Optionals which would either return &quot;nil&quot;, or would stringify the value - where .description would be used if the value is CustomStringConvertible, otherwise, debugPrint would be used as until now. <br></p><p>This would produce no warnings. print(optional) would still print Optional(value), but print(&quot;\(optional)&quot;) would print just value.<br></p><p>Pros: Nothing to be done by the user to migrate current code.<br>Cons: Still can result in unexpected results since it may return &quot;nil&quot;. The user may be unaware that the value being interpoled is optional. (e.g. myURL.path, which when nonnil, always starts with &quot;/&quot;). Also, it breaks any code depending on the current behavior.<br></p><p><br>2) Deprecate interpolation of Optionals (and nothing else), issue a warning and offer a fix via either cast to as Any, or by using .description, .debugDescription or .optionalDescription (or whatever it would be called so that .description or .debugDescription aren&#39;t invoked directly).<br></p><p>Optionally, there could be .valueDescription on Optional which would print either &quot;nil&quot; or the value as proposed in (1).<br></p><p>Pros: The user has full control over what&#39;s printed out.<br>Cons: Requires some action from the user to migrate current code.<br></p><p><br>3) Make the solution more robust and introduce the Uninterpolable protocol, which would generate a warning for interpolation of Optionals and other custom types.<br></p><p>The Fix-It would offer the same for Optionals as (2). For your custom types, no Fix-It will be offered - it&#39;s up to you.<br></p><p>Pros: You can make custom types generate a warning when interpoled + the Pros from (2).<br>Cons: Same as (2).<br></p><p>&gt; <br>&gt; The above code also hints that there&#39;s another odd behavior in the current implementation:<br>&gt; <br>&gt; struct Foo: CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;     var description: String { return &quot;normal&quot; }<br>&gt;     var debugDescription: String { return &quot;debug&quot; }<br>&gt; }<br>&gt; <br>&gt; let f = Foo()<br>&gt; let of = Optional(f)<br>&gt; <br>&gt; print(f)        // &quot;normal&quot;: ok<br>&gt; debugPrint(f)   // &quot;debug&quot;: ok<br>&gt; print(of)       // &quot;Optional(debug)&quot;: unexpected<br>&gt; debugPrint(of)  // &quot;Optional(debug)&quot;: ok<br>&gt; <br>&gt; --<br>&gt; Nicola<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/a353cc6f/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 09:00:00am</p></header><div class="content"><p>Just caught another issue with string interpolation:<br></p><p>&quot;File \&quot;\(url.lowercased)\&quot; not found.&quot;<br></p><p>I mistyped the `lowercased` without `()` and got:<br>File &quot;(Function)&quot; not found.<br></p><p>I believe we need a protection for such situations<br></p><p>On 24.05.2016 13:01, Charlie Monroe via swift-evolution wrote:<br>&gt; Hi Nicola, thanks for the feedback.<br>&gt;<br>&gt;&gt; I assume you mean &quot;at runtime&quot; here?<br>&gt;<br>&gt; That&#39;s probably my wrong wording. :) The unexpected result is at runtime, but we&#39;d like to catch this at compile time. I&#39;ve updated it to say<br>&gt;<br>&gt; &quot;in order to prevent unexpected results already at compile time&quot; - hopefully that&#39;s a clearer wording.<br>&gt;<br>&gt;&gt; I think the detailed design needs  some more thought. The &quot;Uninterpolable&quot;<br>&gt;&gt; protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br>&gt;<br>&gt; Originally, the proposal was simply to emit a warning for interpolation of Optionals, but several people made good points:<br>&gt;<br>&gt; - there may be other types you may not want to use for interpolation - as mentioned in the proposal, e.g. private data structures that would expose something you want to keep private, various enum values, etc. Which is why I&#39;ve started thinking about making a protocol that would indicate the type is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to make a more robust and customizable solution.<br>&gt;<br>&gt; An alternative to this would be to use annotations or just drop this customizability completely. But I think with Swift and its protocol-driven development, marking the type with this protocol is the most robust way to go.<br>&gt;<br>&gt; - both .description and .debugDescription are mentioned in alternatives for the Fix-It.<br>&gt;<br>&gt; &quot;as Any&quot; seemed, however, the cleanest and most robust solution to me, since then the Uninterpolable protocol can be applied to any type without forcing the type to conform to CustomStringConvertible as well. I agree that it&#39;s kind of a hack, though.<br>&gt;<br>&gt;&gt; I&#39;m not even sure if the general direction of a compile time warning is the<br>&gt;&gt; right one, and if the problem wouldn&#39;t be better solved by simply not making<br>&gt;&gt; Optional put &quot;Optional()&quot; around the value in its .description.<br>&gt;<br>&gt; There are many people oposing this and expecting the Optional() wrap around the value, indicating the actual type. Actually, including me - I agree it can be useful for some types of debugging since in what you wrote further, there&#39;d be no difference between description of [1, 2, 3] (i.e. [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br>&gt;<br>&gt; There are legitimate usecases where the current behavior is correct, but in most of cases, having an optional in string interpolation will lead either to unnecessary clutter in the log/console or bugs - in which case even &quot;nil&quot; is not correct to be used for the interpolation. Which is the basis for this proposal.<br>&gt;<br>&gt;&gt; print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br>&gt;<br>&gt; String has several overloads for the init(stringInterpolationSegment:) initiailizer. Optional falls into the generic &lt;T&gt; category, which will call String(optional) - which most likely uses debugDescription.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 27, 2016 at 10:00:00am</p></header><div class="content"><p>That&#39;s a good point.<br></p><p>I still recommend having &quot;Uninterpolable&quot; protocol which could be then applied on any type. Unfortunately, this would require to introduce some kind of a reflection API on the function type :-/<br></p><p>I&#39;ll think about it further today and will try to submit a final version of the proposal.<br></p><p>&gt; On May 27, 2016, at 8:56 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just caught another issue with string interpolation:<br>&gt; <br>&gt; &quot;File \&quot;\(url.lowercased)\&quot; not found.&quot;<br>&gt; <br>&gt; I mistyped the `lowercased` without `()` and got:<br>&gt; File &quot;(Function)&quot; not found.<br>&gt; <br>&gt; I believe we need a protection for such situations<br>&gt; <br>&gt; On 24.05.2016 13:01, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt; Hi Nicola, thanks for the feedback.<br>&gt;&gt; <br>&gt;&gt;&gt; I assume you mean &quot;at runtime&quot; here?<br>&gt;&gt; <br>&gt;&gt; That&#39;s probably my wrong wording. :) The unexpected result is at runtime, but we&#39;d like to catch this at compile time. I&#39;ve updated it to say<br>&gt;&gt; <br>&gt;&gt; &quot;in order to prevent unexpected results already at compile time&quot; - hopefully that&#39;s a clearer wording.<br>&gt;&gt; <br>&gt;&gt;&gt; I think the detailed design needs  some more thought. The &quot;Uninterpolable&quot;<br>&gt;&gt;&gt; protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br>&gt;&gt; <br>&gt;&gt; Originally, the proposal was simply to emit a warning for interpolation of Optionals, but several people made good points:<br>&gt;&gt; <br>&gt;&gt; - there may be other types you may not want to use for interpolation - as mentioned in the proposal, e.g. private data structures that would expose something you want to keep private, various enum values, etc. Which is why I&#39;ve started thinking about making a protocol that would indicate the type is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to make a more robust and customizable solution.<br>&gt;&gt; <br>&gt;&gt; An alternative to this would be to use annotations or just drop this customizability completely. But I think with Swift and its protocol-driven development, marking the type with this protocol is the most robust way to go.<br>&gt;&gt; <br>&gt;&gt; - both .description and .debugDescription are mentioned in alternatives for the Fix-It.<br>&gt;&gt; <br>&gt;&gt; &quot;as Any&quot; seemed, however, the cleanest and most robust solution to me, since then the Uninterpolable protocol can be applied to any type without forcing the type to conform to CustomStringConvertible as well. I agree that it&#39;s kind of a hack, though.<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not even sure if the general direction of a compile time warning is the<br>&gt;&gt;&gt; right one, and if the problem wouldn&#39;t be better solved by simply not making<br>&gt;&gt;&gt; Optional put &quot;Optional()&quot; around the value in its .description.<br>&gt;&gt; <br>&gt;&gt; There are many people oposing this and expecting the Optional() wrap around the value, indicating the actual type. Actually, including me - I agree it can be useful for some types of debugging since in what you wrote further, there&#39;d be no difference between description of [1, 2, 3] (i.e. [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br>&gt;&gt; <br>&gt;&gt; There are legitimate usecases where the current behavior is correct, but in most of cases, having an optional in string interpolation will lead either to unnecessary clutter in the log/console or bugs - in which case even &quot;nil&quot; is not correct to be used for the interpolation. Which is the basis for this proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br>&gt;&gt; <br>&gt;&gt; String has several overloads for the init(stringInterpolationSegment:) initiailizer. Optional falls into the generic &lt;T&gt; category, which will call String(optional) - which most likely uses debugDescription.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>May 27, 2016 at 03:00:00pm</p></header><div class="content"><p>I believe the only &#39;fix&#39; here is to prevent string interpolation for <br>anything that is not base types like String, Integer, Double, Boolean or <br>that is explicitly provides textual(not for debugging) representation.<br></p><p>For all others like function, Optional etc leave only debug string <br>interpolation, when we should explicitly ask &quot;get debgug info text for this <br>item&quot;.<br></p><p>I.e. in my opinion we shouldn&#39;t be able to do &quot;\(url.lowercased)&quot; or <br>&quot;\(op)&quot; (if `op` is optional).<br></p><p>But, *at least* we need warnings if optional, function or something like <br>this is in string interpolation.<br></p><p>On 27.05.2016 11:17, Charlie Monroe wrote:<br>&gt; That&#39;s a good point.<br>&gt;<br>&gt; I still recommend having &quot;Uninterpolable&quot; protocol which could be then applied on any type. Unfortunately, this would require to introduce some kind of a reflection API on the function type :-/<br>&gt;<br>&gt; I&#39;ll think about it further today and will try to submit a final version of the proposal.<br>&gt;<br>&gt;&gt; On May 27, 2016, at 8:56 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Just caught another issue with string interpolation:<br>&gt;&gt;<br>&gt;&gt; &quot;File \&quot;\(url.lowercased)\&quot; not found.&quot;<br>&gt;&gt;<br>&gt;&gt; I mistyped the `lowercased` without `()` and got:<br>&gt;&gt; File &quot;(Function)&quot; not found.<br>&gt;&gt;<br>&gt;&gt; I believe we need a protection for such situations<br>&gt;&gt;<br>&gt;&gt; On 24.05.2016 13:01, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt; Hi Nicola, thanks for the feedback.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I assume you mean &quot;at runtime&quot; here?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That&#39;s probably my wrong wording. :) The unexpected result is at runtime, but we&#39;d like to catch this at compile time. I&#39;ve updated it to say<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;in order to prevent unexpected results already at compile time&quot; - hopefully that&#39;s a clearer wording.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think the detailed design needs  some more thought. The &quot;Uninterpolable&quot;<br>&gt;&gt;&gt;&gt; protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Originally, the proposal was simply to emit a warning for interpolation of Optionals, but several people made good points:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - there may be other types you may not want to use for interpolation - as mentioned in the proposal, e.g. private data structures that would expose something you want to keep private, various enum values, etc. Which is why I&#39;ve started thinking about making a protocol that would indicate the type is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to make a more robust and customizable solution.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; An alternative to this would be to use annotations or just drop this customizability completely. But I think with Swift and its protocol-driven development, marking the type with this protocol is the most robust way to go.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - both .description and .debugDescription are mentioned in alternatives for the Fix-It.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &quot;as Any&quot; seemed, however, the cleanest and most robust solution to me, since then the Uninterpolable protocol can be applied to any type without forcing the type to conform to CustomStringConvertible as well. I agree that it&#39;s kind of a hack, though.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m not even sure if the general direction of a compile time warning is the<br>&gt;&gt;&gt;&gt; right one, and if the problem wouldn&#39;t be better solved by simply not making<br>&gt;&gt;&gt;&gt; Optional put &quot;Optional()&quot; around the value in its .description.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are many people oposing this and expecting the Optional() wrap around the value, indicating the actual type. Actually, including me - I agree it can be useful for some types of debugging since in what you wrote further, there&#39;d be no difference between description of [1, 2, 3] (i.e. [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There are legitimate usecases where the current behavior is correct, but in most of cases, having an optional in string interpolation will lead either to unnecessary clutter in the log/console or bugs - in which case even &quot;nil&quot; is not correct to be used for the interpolation. Which is the basis for this proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; String has several overloads for the init(stringInterpolationSegment:) initiailizer. Optional falls into the generic &lt;T&gt; category, which will call String(optional) - which most likely uses debugDescription.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 16, 2016 at 09:00:00pm</p></header><div class="content"><p>Sorry, didn&#39;t have time to actually submit the proposal, but it at least gave me some time to think it through a few more times.<br></p><p>After reconsiderations, I suggest the following:<br></p><p>- deprecation of interpolation of optionals.<br>- extending the Optional type by:<br>	- var detailedDescription: String - which will return the same value as until now: &quot;nil&quot; for nil and &quot;Optional(value)&quot; for .some(_). This is due to .description and .debugDescription&#39;s documentation discouraging direct invocation.<br></p><p>	- func descriptionWithDefaultValue(_ defaultValue: String = &quot;nil&quot;) -&gt; String - which would return either the description of the value, or `defaultValue`.<br></p><p>So, when the compiler runs into interpolation of an Optional, it issues a warning with a fix-it, that by default calls .descriptionWithDefaultValue() on the optional.<br></p><p>Person who wants the original behavior can still get it using `.detailedDescription`.<br></p><p>I&#39;ll put it into a proper proposal tomorrow.<br></p><p>&gt; On May 27, 2016, at 2:23 PM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt; <br>&gt; I believe the only &#39;fix&#39; here is to prevent string interpolation for anything that is not base types like String, Integer, Double, Boolean or that is explicitly provides textual(not for debugging) representation.<br>&gt; <br>&gt; For all others like function, Optional etc leave only debug string interpolation, when we should explicitly ask &quot;get debgug info text for this item&quot;.<br>&gt; <br>&gt; I.e. in my opinion we shouldn&#39;t be able to do &quot;\(url.lowercased)&quot; or &quot;\(op)&quot; (if `op` is optional).<br>&gt; <br>&gt; But, *at least* we need warnings if optional, function or something like this is in string interpolation.<br>&gt; <br>&gt; On 27.05.2016 11:17, Charlie Monroe wrote:<br>&gt;&gt; That&#39;s a good point.<br>&gt;&gt; <br>&gt;&gt; I still recommend having &quot;Uninterpolable&quot; protocol which could be then applied on any type. Unfortunately, this would require to introduce some kind of a reflection API on the function type :-/<br>&gt;&gt; <br>&gt;&gt; I&#39;ll think about it further today and will try to submit a final version of the proposal.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 27, 2016, at 8:56 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just caught another issue with string interpolation:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &quot;File \&quot;\(url.lowercased)\&quot; not found.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I mistyped the `lowercased` without `()` and got:<br>&gt;&gt;&gt; File &quot;(Function)&quot; not found.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe we need a protection for such situations<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 24.05.2016 13:01, Charlie Monroe via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; Hi Nicola, thanks for the feedback.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I assume you mean &quot;at runtime&quot; here?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s probably my wrong wording. :) The unexpected result is at runtime, but we&#39;d like to catch this at compile time. I&#39;ve updated it to say<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;in order to prevent unexpected results already at compile time&quot; - hopefully that&#39;s a clearer wording.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the detailed design needs  some more thought. The &quot;Uninterpolable&quot;<br>&gt;&gt;&gt;&gt;&gt; protocol, and suggesting to cast &quot;as Any&quot; in a Fix-it both seem hacks.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Originally, the proposal was simply to emit a warning for interpolation of Optionals, but several people made good points:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - there may be other types you may not want to use for interpolation - as mentioned in the proposal, e.g. private data structures that would expose something you want to keep private, various enum values, etc. Which is why I&#39;ve started thinking about making a protocol that would indicate the type is discouraged being &quot;interpoled&quot;. I&#39;ve thought about this and decided to make a more robust and customizable solution.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; An alternative to this would be to use annotations or just drop this customizability completely. But I think with Swift and its protocol-driven development, marking the type with this protocol is the most robust way to go.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - both .description and .debugDescription are mentioned in alternatives for the Fix-It.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &quot;as Any&quot; seemed, however, the cleanest and most robust solution to me, since then the Uninterpolable protocol can be applied to any type without forcing the type to conform to CustomStringConvertible as well. I agree that it&#39;s kind of a hack, though.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not even sure if the general direction of a compile time warning is the<br>&gt;&gt;&gt;&gt;&gt; right one, and if the problem wouldn&#39;t be better solved by simply not making<br>&gt;&gt;&gt;&gt;&gt; Optional put &quot;Optional()&quot; around the value in its .description.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are many people oposing this and expecting the Optional() wrap around the value, indicating the actual type. Actually, including me - I agree it can be useful for some types of debugging since in what you wrote further, there&#39;d be no difference between description of [1, 2, 3] (i.e. [Int]) and Optional([1, 2, 3]) (i.e. [Int]?).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are legitimate usecases where the current behavior is correct, but in most of cases, having an optional in string interpolation will lead either to unnecessary clutter in the log/console or bugs - in which case even &quot;nil&quot; is not correct to be used for the interpolation. Which is the basis for this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; print(&quot;\(o)&quot;)               // &quot;Optional(1)&quot;, why??<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; String has several overloads for the init(stringInterpolationSegment:) initiailizer. Optional falls into the generic &lt;T&gt; category, which will call String(optional) - which most likely uses debugDescription.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160616/01fdb83e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; 	- func descriptionWithDefaultValue(_ defaultValue: String = &quot;nil&quot;) -&gt; String - which would return either the description of the value, or `defaultValue`.<br></p><p>This is the same as myOptional?.description ?? defaultValue, isn&#39;t it? So do we need it?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 17, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 17, 2016, at 1:12 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; 	- func descriptionWithDefaultValue(_ defaultValue: String = &quot;nil&quot;) -&gt; String - which would return either the description of the value, or `defaultValue`.<br>&gt; <br>&gt; This is the same as myOptional?.description ?? defaultValue, isn&#39;t it? So do we need it?<br></p><p>We need it because:<br></p><p>- myOptional doesn&#39;t necessarily need to contain a CustomStringConvertible, hence .description might not be defined on it (enums, structs, pure Swift classes, ...).<br></p><p>- I have originally suggested making Optional CustomStringConvertible so that .description would return the same value as descriptionWithDefaultValue() (and hence just myOptional.description would be sufficient) and .debugDescription would keep its current behavior. But it was pointed out to me that invoking debugDescription and description is explicitly discouraged from in the documentation and that it&#39;s not a correct solution.<br></p><p>See updated proposal on <br></p><p>https://gist.github.com/charlieMonroe/82e1519dd2b57029f69bc7abe99d7385<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 16, 2016, at 12:44 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Sorry, didn&#39;t have time to actually submit the proposal, but it at least gave me some time to think it through a few more times.<br>&gt; <br>&gt; After reconsiderations, I suggest the following:<br>&gt; <br>&gt; - deprecation of interpolation of optionals.<br>&gt; - extending the Optional type by:<br>&gt; 	- var detailedDescription: String - which will return the same value as until now: &quot;nil&quot; for nil and &quot;Optional(value)&quot; for .some(_). This is due to .description and .debugDescription&#39;s documentation discouraging direct invocation.<br>&gt; <br>&gt; 	- func descriptionWithDefaultValue(_ defaultValue: String = &quot;nil&quot;) -&gt; String - which would return either the description of the value, or `defaultValue`.<br>&gt; <br>&gt; So, when the compiler runs into interpolation of an Optional, it issues a warning with a fix-it, that by default calls .descriptionWithDefaultValue() on the optional.<br></p><p>I think that this is overcomplicating the issue.  I’d suggest that someone just implement a simple compiler patch (which doesn’t need an evolution proposal):<br></p><p>1. Produce a warning when a string interpolation includes a non-redundantly-parenthesized optional, saying that this is probably a bug.<br>2. Attach two notes (with fixits) to the warning:<br>2a. a note that adds redundant parens around the parameter, silencing the warning.<br>2b. a note that fixits the issue with a “!” or &quot;?? &lt;#placeholder#&gt;&quot;<br></p><p>I agree that this should be fixed.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160618/1f541bf7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Proposal: Deprecate optionals in string interpolation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 19, 2016, at 6:59 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 16, 2016, at 12:44 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, didn&#39;t have time to actually submit the proposal, but it at least gave me some time to think it through a few more times.<br>&gt;&gt; <br>&gt;&gt; After reconsiderations, I suggest the following:<br>&gt;&gt; <br>&gt;&gt; - deprecation of interpolation of optionals.<br>&gt;&gt; - extending the Optional type by:<br>&gt;&gt; 	- var detailedDescription: String - which will return the same value as until now: &quot;nil&quot; for nil and &quot;Optional(value)&quot; for .some(_). This is due to .description and .debugDescription&#39;s documentation discouraging direct invocation.<br>&gt;&gt; <br>&gt;&gt; 	- func descriptionWithDefaultValue(_ defaultValue: String = &quot;nil&quot;) -&gt; String - which would return either the description of the value, or `defaultValue`.<br>&gt;&gt; <br>&gt;&gt; So, when the compiler runs into interpolation of an Optional, it issues a warning with a fix-it, that by default calls .descriptionWithDefaultValue() on the optional.<br>&gt; <br>&gt; I think that this is overcomplicating the issue.  I’d suggest that someone just implement a simple compiler patch (which doesn’t need an evolution proposal):<br>&gt; <br>&gt; 1. Produce a warning when a string interpolation includes a non-redundantly-parenthesized optional, saying that this is probably a bug.<br>&gt; 2. Attach two notes (with fixits) to the warning:<br>&gt; 2a. a note that adds redundant parens around the parameter, silencing the warning.<br>&gt; 2b. a note that fixits the issue with a “!” or &quot;?? &lt;#placeholder#&gt;&quot;<br></p><p>The &quot;?? &lt;#placeholder#&gt;&quot; fix-it suffers from a slight drawback:<br></p><p>enum MyEnum {<br>    case value1<br>    case value2<br>}<br></p><p>let someObj: MyEnum? = nil<br>let obj = someObj ?? &quot;Hello&quot; // Error: Binary operator &#39;??&#39; cannot be applied to operands of type &#39;MyEnum?&#39; and &#39;String&#39;<br></p><p>(tested in Xcode 8)<br></p><p>I&#39;m not sure whether to consider this a bug in the compiler - what should be the correct behavior? Should &quot;obj&quot; be of kind &quot;Any&quot; with the compiler finding the lowest common type in all cases? Won&#39;t this introduce a new kind of confusing bugs where the inferred types would be wrong?<br></p><p>I&#39;ve deprecated the interpolation of Optionals in my projects (~200KLOC) using an extension on String and the only way to satisfy the compiler in all cases is to use something like <br></p><p>&quot;someObj is \((someObj as Any?) ?? &quot;Hello&quot;)&quot;<br></p><p>And it can get a bit nastier, which is why I&#39;ve proposed a more universal and better readable fix:<br></p><p>&quot;someObj is \(someObj.descriptionWithDefaultValue(&quot;Hello&quot;))&quot;<br></p><p>and<br></p><p>&quot;\(item.valueForPrintableField(.DocumentType, withContext: nil).optionaDescription) \(item.year) - \(item.itemID).pdf&quot;<br></p><p>I&#39;m personally not a big fan of the extra parentheses around the optional for silencing the warning either, mostly since it will look like this:<br></p><p>&quot;\((item.valueForPrintableField(.DocumentType, withContext: nil))) \(item.year) - \(item.itemID).pdf&quot;<br></p><p>which is IMHO hard to read and understand why there are so many parentheses.<br></p><p>But if you insist on this being the way to go, I&#39;ll try to take a look at the compiler, though it&#39;s been a while since I&#39;ve done anything in Clang.<br></p><p>&gt; <br>&gt; I agree that this should be fixed.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160619/9da29d43/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
