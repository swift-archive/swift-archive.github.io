<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 18, 2016 at 02:00:00pm</p></header><div class="content"><p>Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br></p><p>I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br></p><p>Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br></p><p>With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals, but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br></p><p>So what do you think? Can we break C compatibility a bit for better Swift types?<br></p><p>- Guoye<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>October 18, 2016 at 02:00:00pm</p></header><div class="content"><p>If we went that route, could arithmetic operations still be implemented<br>efficiently?<br></p><p>Nevin<br></p><p>On Tuesday, October 18, 2016, Guoye Zhang via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Currently, Swift Int family and UInt family have compact representations<br>&gt; that utilize all available values, which is inherited from C. However, it<br>&gt; is horribly inefficient to implement optional integers. It takes double the<br>&gt; space to store [Int?] than to store [Int] because of alignment.<br>&gt;<br>&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int<br>&gt; family would lose its smallest value, and UInt family would lose its<br>&gt; largest value. Top value is reserved for nil in optionals. An additional<br>&gt; benefit is that negating an Int would never crash.<br>&gt;<br>&gt; Interacting with C/Obj-C is a major concern, but since we are already<br>&gt; importing some of the unsigned integers as Int which loses half the values,<br>&gt; one value is not such big a drawback. Alternatively, we could leave current<br>&gt; behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t<br>&gt; generate any instructions since the invalid value already represents nil.<br>&gt;<br>&gt; With optional integers improved, we could implement safe arithmetic<br>&gt; efficiently, or even revisit lenient subscript proposals, but they are not<br>&gt; in the scope of this pitch. Float/Double optionals could also be improved<br>&gt; with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested<br>&gt; optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are<br>&gt; widely used.<br>&gt;<br>&gt; So what do you think? Can we break C compatibility a bit for better Swift<br>&gt; types?<br>&gt;<br>&gt; - Guoye<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161018/32279dbf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 18, 2016 at 03:00:00pm</p></header><div class="content"><p>Perhaps not considering the current instruction set. Safe arithmetics that produce optionals would be simpler though.<br></p><p>- Guoye<br></p><p>&gt; 在 2016年10月18日，14:43，Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; 写道：<br>&gt; <br>&gt; If we went that route, could arithmetic operations still be implemented efficiently?<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; On Tuesday, October 18, 2016, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt; <br>&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt; <br>&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt; <br>&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals, but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt; <br>&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt; <br>&gt; - Guoye<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 18, 2016 at 11:00:00am</p></header><div class="content"><p>Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>- I strongly dislike the idea of special-casing optionals just to save a Byte. <br>- Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>- There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>- If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br></p><p>(more below)<br></p><p>&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt; <br>&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt; <br>&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br></p><p>I’d argue those imports are bugs and should be fixed to the correct signedness.<br></p><p>&gt; one value is not such big a drawback.<br></p><p>Unless you happen to need all $width bits.<br></p><p>&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br></p><p>Trying to convert an invalid value like that crashes in most of Swift.<br></p><p>&gt; <br>&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br></p><p>I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br></p><p>&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt; <br>&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br></p><p>We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br></p><p>&gt; <br>&gt; - Guoye<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 18, 2016 at 09:00:00pm</p></header><div class="content"><p>Talking about bridging - my guess is that it would mess with NSNotFound which still has legit use cases even in Swift (when dealing with ObjC APIs) and is defined as NSIntegerMax at this moment, though its usage is slowly on the decline...<br></p><p>But there are still many many APIs (mostly C-based) that define some &quot;magic&quot; constants as (unsigned)(-1), which I believe this would mess with.<br></p><p>Given this, it would IMHO have huge consequences for backward compatiblity.<br></p><p>&gt; On Oct 18, 2016, at 8:54 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>&gt; - Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>&gt; - There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>&gt; - If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br>&gt; <br>&gt; (more below)<br>&gt; <br>&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt; <br>&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt; <br>&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br>&gt; <br>&gt; I’d argue those imports are bugs and should be fixed to the correct signedness.<br>&gt; <br>&gt;&gt; one value is not such big a drawback.<br>&gt; <br>&gt; Unless you happen to need all $width bits.<br>&gt; <br>&gt;&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt; <br>&gt; Trying to convert an invalid value like that crashes in most of Swift.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br>&gt; <br>&gt; I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br>&gt; <br>&gt;&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt; <br>&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt; <br>&gt; We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Guoye<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 18, 2016 at 03:00:00pm</p></header><div class="content"><p>In that case, NSNotFound can be seamlessly converted to nil. Those magic might also be better represented in optionals. It is indeed bad for compatibility otherwise.<br></p><p>- Guoye<br></p><p>&gt; 在 2016年10月18日，15:09，Charlie Monroe &lt;charlie at charliemonroe.net&gt; 写道：<br>&gt; <br>&gt; Talking about bridging - my guess is that it would mess with NSNotFound which still has legit use cases even in Swift (when dealing with ObjC APIs) and is defined as NSIntegerMax at this moment, though its usage is slowly on the decline...<br>&gt; <br>&gt; But there are still many many APIs (mostly C-based) that define some &quot;magic&quot; constants as (unsigned)(-1), which I believe this would mess with.<br>&gt; <br>&gt; Given this, it would IMHO have huge consequences for backward compatiblity.<br>&gt; <br>&gt;&gt; On Oct 18, 2016, at 8:54 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>&gt;&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>&gt;&gt; - Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>&gt;&gt; - There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>&gt;&gt; - If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br>&gt;&gt; <br>&gt;&gt; (more below)<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br>&gt;&gt; <br>&gt;&gt; I’d argue those imports are bugs and should be fixed to the correct signedness.<br>&gt;&gt; <br>&gt;&gt;&gt; one value is not such big a drawback.<br>&gt;&gt; <br>&gt;&gt; Unless you happen to need all $width bits.<br>&gt;&gt; <br>&gt;&gt;&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt; <br>&gt;&gt; Trying to convert an invalid value like that crashes in most of Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br>&gt;&gt; <br>&gt;&gt; I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br>&gt;&gt; <br>&gt;&gt;&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt;&gt; <br>&gt;&gt; We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Guoye<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>October 18, 2016 at 09:00:00pm</p></header><div class="content"><p>Which would required all developers to update all APIs to annotate, where some magic value may be used - because otherwise all non-Swift APIs would return optional Ints or run into risk of crashing during runtime (since once entering Swift code, the value would become nil)...<br></p><p>I agree that it would be the ideal case, but reastically, given how many APIs out there are still with no nullability annotations (and it&#39;s been what - 3-4 years now?), I don&#39;t see this practical...<br></p><p>&gt; On Oct 18, 2016, at 9:16 PM, Guoye Zhang &lt;cc941201 at me.com&gt; wrote:<br>&gt; <br>&gt; In that case, NSNotFound can be seamlessly converted to nil. Those magic might also be better represented in optionals. It is indeed bad for compatibility otherwise.<br>&gt; <br>&gt; - Guoye<br>&gt; <br>&gt;&gt; 在 2016年10月18日，15:09，Charlie Monroe &lt;charlie at charliemonroe.net&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; Talking about bridging - my guess is that it would mess with NSNotFound which still has legit use cases even in Swift (when dealing with ObjC APIs) and is defined as NSIntegerMax at this moment, though its usage is slowly on the decline...<br>&gt;&gt; <br>&gt;&gt; But there are still many many APIs (mostly C-based) that define some &quot;magic&quot; constants as (unsigned)(-1), which I believe this would mess with.<br>&gt;&gt; <br>&gt;&gt; Given this, it would IMHO have huge consequences for backward compatiblity.<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 18, 2016, at 8:54 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>&gt;&gt;&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>&gt;&gt;&gt; - Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>&gt;&gt;&gt; - There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>&gt;&gt;&gt; - If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (more below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d argue those imports are bugs and should be fixed to the correct signedness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one value is not such big a drawback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless you happen to need all $width bits.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Trying to convert an invalid value like that crashes in most of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Guoye<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>October 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 18 oct. 2016 à 21:09, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Talking about bridging - my guess is that it would mess with NSNotFound which still has legit use cases even in Swift (when dealing with ObjC APIs) and is defined as NSIntegerMax at this moment, though its usage is slowly on the decline…<br></p><p>Bridge the API that may return NSNotFound to return optional. It would work perfectly well as the nil optional and NSNotFound would have the same binary representation.<br></p><p><br>&gt; But there are still many many APIs (mostly C-based) that define some &quot;magic&quot; constants as (unsigned)(-1), which I believe this would mess with.<br>&gt; <br>&gt; Given this, it would IMHO have huge consequences for backward compatiblity.<br>&gt; <br>&gt;&gt; On Oct 18, 2016, at 8:54 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>&gt;&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>&gt;&gt; - Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>&gt;&gt; - There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>&gt;&gt; - If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br>&gt;&gt; <br>&gt;&gt; (more below)<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br>&gt;&gt; <br>&gt;&gt; I’d argue those imports are bugs and should be fixed to the correct signedness.<br>&gt;&gt; <br>&gt;&gt;&gt; one value is not such big a drawback.<br>&gt;&gt; <br>&gt;&gt; Unless you happen to need all $width bits.<br>&gt;&gt; <br>&gt;&gt;&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt; <br>&gt;&gt; Trying to convert an invalid value like that crashes in most of Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br>&gt;&gt; <br>&gt;&gt; I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br>&gt;&gt; <br>&gt;&gt;&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt;&gt; <br>&gt;&gt; We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Guoye<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Personally I prefer the way Optionals currently work (add one bit), but I think a better compromise would be the ability to specify arbitrary width integers.<br></p><p>For example, I have a type that stores an optional (so 1-bit overhead) and I want to store less than a byte of extra data; if I could specify a 7-bit integer then I could limit overhead to a single byte, but currently cannot (at least, not without using single Bools which I don&#39;t want to do.<br></p><p><br>For collections there may be other options; for example, storing the optionality of values in a separate bitmap, which would reduce memory overhead, perhaps types could be added that can do this? For storing lots of optionals this would be more efficient on memory, with a slight overhead for double optionality checking. Here&#39;s a quick example of what I mean:<br></p><p>struct OptionalArray&lt;T&gt; : Collection {<br>    var values:[T] = [], bitmap:[Bool] = [], defaultValue:T<br></p><p>    init(defaultValue:T) { self.defaultValue = defaultValue }<br>    init&lt;S:Sequence&gt;(_ theElements:S, defaultValue:T) where S.Iterator.Element == T? {<br>        self.defaultValue = defaultValue<br></p><p>        self.values.reserveCapacity(theElements.underestimatedCount)<br>        self.bitmap.reserveCapacity(theElements.underestimatedCount)<br></p><p>        for eachElement in theElements {<br>            self.values.append(eachElement ?? defaultValue)<br>            self.bitmap.append(eachElement != nil)<br>        }<br>    }<br></p><p>    var count:Int { return self.values.count }<br></p><p>    var startIndex:Int { return self.values.startIndex }<br>    var endIndex:Int { return self.values.endIndex }<br></p><p>    func formIndex(after i:inout Int) { self.values.formIndex(after: &amp;i) }<br>    func index(after i:Int) -&gt; Int { return self.values.index(after: i) }<br></p><p>    subscript(index:Int) -&gt; T? {<br>        get { return self.bitmap[index] ? self.values[index] : nil }<br>        set { self.values[index] = newValue ?? self.defaultValue }<br>    }<br>}<br></p><p>You could easily adapt this to store optionality using a default value that&#39;s unlikely to occur, like so:<br></p><p>struct OptionalArrayAlt&lt;T:Equatable&gt; : Collection {<br>    var values:[T] = [], defaultValue:T<br></p><p>    init(defaultValue:T) { self.defaultValue = defaultValue }<br>    init&lt;S:Sequence&gt;(_ theElements:S, defaultValue:T) where S.Iterator.Element == T? {<br>        self.defaultValue = defaultValue<br>        values.reserveCapacity(theElements.underestimatedCount)<br>        self.values = theElements.map { return $0 ?? defaultValue }<br>    }<br></p><p>    var count:Int { return self.values.count }<br></p><p>    var startIndex:Int { return self.values.startIndex }<br>    var endIndex:Int { return self.values.endIndex }<br></p><p>    func formIndex(after i:inout Int) { self.values.formIndex(after: &amp;i) }<br>    func index(after i:Int) -&gt; Int { return self.values.index(after: i) }<br></p><p>    subscript(index:Int) -&gt; T? {<br>        get { let value = self.values[index]; return value == self.defaultValue ? value : nil }<br>        set { self.values[index] = newValue ?? self.defaultValue }<br>    }<br>}<br></p><p>With the caveat that you either can&#39;t store values equal to defaultValue (they become nil) or add an assertion/error if that value is stored.<br></p><p>But yeah, I don&#39;t think that rolling out the idea to all optionals is a good idea; the biggest gains will be had in collections, so any efforts should be focused there IMO, and on making custom types align better if possible.<br>&gt; On 18 Oct 2016, at 21:32, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 18 oct. 2016 à 21:09, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Talking about bridging - my guess is that it would mess with NSNotFound which still has legit use cases even in Swift (when dealing with ObjC APIs) and is defined as NSIntegerMax at this moment, though its usage is slowly on the decline…<br>&gt; <br>&gt; Bridge the API that may return NSNotFound to return optional. It would work perfectly well as the nil optional and NSNotFound would have the same binary representation.<br>&gt; <br>&gt; <br>&gt;&gt; But there are still many many APIs (mostly C-based) that define some &quot;magic&quot; constants as (unsigned)(-1), which I believe this would mess with.<br>&gt;&gt; <br>&gt;&gt; Given this, it would IMHO have huge consequences for backward compatiblity.<br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 18, 2016, at 8:54 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>&gt;&gt;&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>&gt;&gt;&gt; - Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>&gt;&gt;&gt; - There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>&gt;&gt;&gt; - If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (more below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d argue those imports are bugs and should be fixed to the correct signedness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; one value is not such big a drawback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless you happen to need all $width bits.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Trying to convert an invalid value like that crashes in most of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Guoye<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161018/b5e0e5a7/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; 在 2016年10月18日，14:54，Kevin Nattinger &lt;swift at nattinger.net&gt; 写道：<br>&gt; <br>&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals besides a bit of syntactic sugar (`T?` -&gt; `Optional&lt;T&gt;`, `if let x` -&gt; `if let case .some(x)`, auto-boxing when necessary, etc.). <br>Swift compiler is already using magic for optional pointers. Invalid address are used for optional pointers. `MemoryLayout&lt;ManagedBuffer&lt;Int, String&gt;???&gt;.size` is still 8.<br></p><p>&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>Not just a byte, it saves half the space in arrays. [Int?] is double the size of [Int].<br></p><p>&gt; - Optionals were presented as explicitly removing the need for such a sentinel value in the first place.<br>&gt; - There are reasonable cases where such a bit pattern is reasonably necessary to the data (e.g. bit fields, RSSI, IP addresses, etc.) and removing that value would force ugly workarounds and/or moving to a larger int size because of an ill-advised implementation detail.<br>I agree. Perhaps we just special case Int, and keep UInt intact for bitwise operations?<br></p><p>&gt; - If performance or memory is so critical to your specific use case, use a non-optional and your own sentinel value. It’s likely no less efficient than having the compiler do it that way.<br>&gt; <br>&gt; (more below)<br>&gt; <br>&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt; <br>&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt; <br>&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values,<br>&gt; <br>&gt; I’d argue those imports are bugs and should be fixed to the correct signedness.<br></p><p>It is for indexing Swift array easier.<br>&gt; <br>&gt;&gt; one value is not such big a drawback.<br>&gt; <br>&gt; Unless you happen to need all $width bits.<br>&gt; <br>&gt;&gt; Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt; <br>&gt; Trying to convert an invalid value like that crashes in most of Swift.<br></p><p>CInt to Optional&lt;Int&gt; would not crash because invalid value becomes nil.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals,<br>&gt; <br>&gt; I don’t see how losing a particular value has any effect on either of those, but it’s possible there’s some theory or implementation detail I’m not aware of.<br></p><p>Unaligned memory access would be a huge performance hit.<br>&gt; <br>&gt;&gt; but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt; <br>&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt; <br>&gt; We can, and do. C.f. structs, non- at objc classes, and enums not RawRepresentable with a C-compatible entity. If anything, this breaks compatibility with the rest of Swift.<br></p><p>I don&#39;t want that, either.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Guoye<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c198ffcf0853e6011f58fdcdd32a111?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Benjamin Spratling</string> &lt;bspratling at mac.com&gt;<p>October 18, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Oct 18, 2016, at 1:54 PM, Kevin Nattinger via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Part of the beauty of how optionals are implemented in Swift is that the compiler doesn’t have to do any magic w.r.t. optionals <br>&gt; - I strongly dislike the idea of special-casing optionals just to save a Byte. <br>It is nice that enums are generic, but enums do know about extra bits laying around and compact themselves if possible.<br></p><p>As I understand it, It would actually save 7.875 bytes of storage.  When the next stored value is Int-alignment, 7 extra bytes beyond the optional marking are used up.  For code which uses several Int? in a row, it doubles the required memory - as I understand it.<br></p><p>&gt;  If anything, this breaks compatibility with the rest of Swift.<br>Yep.  So if it’s gonna be done, now&#39;s the time to do it.<br></p><p>An alternative is to introduce 63-bit and 31-bit integer types just to play nice with optionals.  Or to play nice with more than 2 enum cases, why not introduce 56- and 24-bit Int/UInt? and leave space for many cases.  Of course, there’s an added performance penalty when working with the mask, right?  Maybe opting in to these odd byte sizes lets the developer know that.<br></p><p>When working with Int / UInt the developer is not usually specifying “Int64”, but instead saying &quot;big integer, oh, 64-bits, that should handle it.”  When they say “it might be 32-bits, uh oh”, then they explicitly specify Int64.  So maybe &quot;typealias Int = Int56&quot; solves this problem.<br></p><p>There was talk of adding a variable-byte-sized Integers to the built-ins in the future.  Maybe these changes could work together with that?<br></p><p>-Ben<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 18, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt; <br>&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt; <br>&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt; <br>&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals, but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt; <br>&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br></p><p>I don&#39;t think we&#39;d ever be able to do this for unsigned values, since their use as bitmasks is pervasive and requires all inhabitants. There&#39;s some appeal to taking the least negative value away from signed int types, since as you noted, it would define away the potential for negation and division to overflow. There would be several tradeoffs:<br></p><p>- It makes overflow checking more expensive. Most CPUs have hardware support for detecting two&#39;s complement signed overflow, but checking for INT_MIN would require additional code after every potentially-overflowing operation, greatly increasing the code size and performance hit we&#39;d pay for safe arithmetic.<br>- It would make Swift integer values not &quot;toll-free bridge&quot; with C integers, complicating the interface between Swift and C APIs. We could import C APIs to use Int? or Int!, but that would inflict pain on the client-side code that has to check those optionals.<br></p><p>If someone was bringing up a CPU from the silicon up to run Swift code, to run a software environment with little or no C interop, reserving INT_MIN would definitely be an interesting design point to consider, but we decided that it wasn&#39;t practical for Swift&#39;s target platforms today. There are other things we can do to mitigate the size cost of Int? compared to Int. Although we don&#39;t take full advantage of it today, Swift understands the layout of types at the *bit* level, and we plan to optimize things so that structs containing many bit-sized components, such as Bools or the out-of-line tags for multiple Optionals, can be automatically packed into bitfields by default. Note that `Int??` already has the same size as `Int?`, since Swift knows it&#39;s already burned a tag bit to represent &#39;nil&#39; and can just store different numeric values in the payload with the tag bit set to distinguish &#39;.some(.none)&#39; from &#39;.none&#39;. (It&#39;s true that the `Array` type is constrained by presenting its elements as contiguous in memory and well-aligned, so `[Int?]` will likely never be very efficiently represented, but you could fairly easily represent a collection of optional Ints more efficiently SoA-style by passing around a pair of [Int] and a bit vector, or else reserving an Int value you know to be unused in your own domain and passing around [Int].lazy.map { $0 == Int.min ? nil : $0 } or something similar.)<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; 在 2016年10月18日，15:15，Joe Groff &lt;jgroff at apple.com&gt; 写道：<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 18, 2016, at 11:17 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt; <br>&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt; <br>&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt; <br>&gt;&gt; With optional integers improved, we could implement safe arithmetic efficiently, or even revisit lenient subscript proposals, but they are not in the scope of this pitch. Float/Double optionals could also be improved with the similar idea. (Isn&#39;t signaling nan the same as nil) Nested optionals such as &quot;Int??&quot; are still bloated, but I don&#39;t think they are widely used.<br>&gt;&gt; <br>&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt; <br>&gt; I don&#39;t think we&#39;d ever be able to do this for unsigned values, since their use as bitmasks is pervasive and requires all inhabitants. There&#39;s some appeal to taking the least negative value away from signed int types, since as you noted, it would define away the potential for negation and division to overflow. There would be several tradeoffs:<br>&gt; <br>&gt; - It makes overflow checking more expensive. Most CPUs have hardware support for detecting two&#39;s complement signed overflow, but checking for INT_MIN would require additional code after every potentially-overflowing operation, greatly increasing the code size and performance hit we&#39;d pay for safe arithmetic.<br>&gt; - It would make Swift integer values not &quot;toll-free bridge&quot; with C integers, complicating the interface between Swift and C APIs. We could import C APIs to use Int? or Int!, but that would inflict pain on the client-side code that has to check those optionals.<br>&gt; <br>&gt; If someone was bringing up a CPU from the silicon up to run Swift code, to run a software environment with little or no C interop, reserving INT_MIN would definitely be an interesting design point to consider, but we decided that it wasn&#39;t practical for Swift&#39;s target platforms today. There are other things we can do to mitigate the size cost of Int? compared to Int. Although we don&#39;t take full advantage of it today, Swift understands the layout of types at the *bit* level, and we plan to optimize things so that structs containing many bit-sized components, such as Bools or the out-of-line tags for multiple Optionals, can be automatically packed into bitfields by default. Note that `Int??` already has the same size as `Int?`, since Swift knows it&#39;s already burned a tag bit to represent &#39;nil&#39; and can just store different numeric values in the payload with the tag bit set to distinguish &#39;.some(.none)&#39; from &#39;.none&#39;. (It&#39;s true that the `Array` type is constrained by presenting its elements as contiguous in memory and well-aligned, so `[Int?]` will likely never be very efficiently represented, but you could fairly easily represent a collection of optional Ints more efficiently SoA-style by passing around a pair of [Int] and a bit vector, or else reserving an Int value you know to be unused in your own domain and passing around [Int].lazy.map { $0 == Int.min ? nil : $0 } or something similar.)<br>&gt; <br>&gt; -Joe<br></p><p>Thanks for your response. I&#39;m glad to know that it is discussed.<br></p><p>- Guoye<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161018/f6df22f7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>October 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Oct 18, 2016, at 12:17 PM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br></p><p>There are two ways to do this (using Int8 for example)<br>1. 0xFF reserved to mean nil. As this normally means -1, all negative numbers now use complements rather than two’s complement form. This breaks a lot of binary math.<br></p><p>2. 0x80 reserved to mean nil. This is normally -128. Overflow would have to be modified in order to support this (otherwise, 127 + 1 == nil). bit padding no longer works (0x80 would expand to 0xFF80 for a Int16 with bit padding, not 0x8000)<br></p><p>&gt; <br>&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt; <br></p><p>As the appropriate integer minimum value may already be in use in C or Objective C code, I believe you would need to define a new integer types to support this sort of constrained type. <br></p><p>Where I would see something like this be most appropriate would be for supporting a “BigNumber” type in the language, preferably as the default integer type. Ruby does this for example with Fixnum/Bignum - all values in Ruby are actually tagged pointers (where the lower bits are set to cause invalid alignment of a pointer in order to indicate it is a special case immediate value). So if the lowest bit is set, the value is a FixNum integer with a lower max/higher min than a traditional integer. On overflow, the value is promoted to be a BigNum, which is a reference to an arbitrary sized integer on the heap.<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 18, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; 在 2016年10月18日，15:30，David Waite &lt;david at alkaline-solutions.com&gt; 写道：<br>&gt; <br>&gt; <br>&gt;&gt; On Oct 18, 2016, at 12:17 PM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt; <br>&gt; There are two ways to do this (using Int8 for example)<br>&gt; 1. 0xFF reserved to mean nil. As this normally means -1, all negative numbers now use complements rather than two’s complement form. This breaks a lot of binary math.<br>&gt; <br>&gt; 2. 0x80 reserved to mean nil. This is normally -128. Overflow would have to be modified in order to support this (otherwise, 127 + 1 == nil). bit padding no longer works (0x80 would expand to 0xFF80 for a Int16 with bit padding, not 0x8000)<br></p><p>Yes, 0x80 is better for arithmetic, checking for nil might be slower.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt; <br>&gt; <br>&gt; As the appropriate integer minimum value may already be in use in C or Objective C code, I believe you would need to define a new integer types to support this sort of constrained type. <br>&gt; <br>&gt; Where I would see something like this be most appropriate would be for supporting a “BigNumber” type in the language, preferably as the default integer type. Ruby does this for example with Fixnum/Bignum - all values in Ruby are actually tagged pointers (where the lower bits are set to cause invalid alignment of a pointer in order to indicate it is a special case immediate value). So if the lowest bit is set, the value is a FixNum integer with a lower max/higher min than a traditional integer. On overflow, the value is promoted to be a BigNum, which is a reference to an arbitrary sized integer on the heap.<br>&gt; <br>&gt; -DW<br></p><p>I would also like to see big number some day.<br></p><p>- Guoye<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4c60436f08b7b107f0bb0848c31297fa?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Alex Blewitt</string> &lt;alblue at apple.com&gt;<p>October 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 18 Oct 2016, at 20:46, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 在 2016年10月18日，15:30，David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Oct 18, 2016, at 12:17 PM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt; <br>&gt;&gt; There are two ways to do this (using Int8 for example)<br>&gt;&gt; 1. 0xFF reserved to mean nil. As this normally means -1, all negative numbers now use complements rather than two’s complement form. This breaks a lot of binary math.<br>&gt;&gt; <br>&gt;&gt; 2. 0x80 reserved to mean nil. This is normally -128. Overflow would have to be modified in order to support this (otherwise, 127 + 1 == nil). bit padding no longer works (0x80 would expand to 0xFF80 for a Int16 with bit padding, not 0x8000)<br>&gt; <br>&gt; Yes, 0x80 is better for arithmetic, checking for nil might be slower.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Interacting with C/Obj-C is a major concern, but since we are already importing some of the unsigned integers as Int which loses half the values, one value is not such big a drawback. Alternatively, we could leave current behavior as CInt/CUInt. Converting them to the new Int?/UInt? doesn&#39;t generate any instructions since the invalid value already represents nil.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As the appropriate integer minimum value may already be in use in C or Objective C code, I believe you would need to define a new integer types to support this sort of constrained type. <br>&gt;&gt; <br>&gt;&gt; Where I would see something like this be most appropriate would be for supporting a “BigNumber” type in the language, preferably as the default integer type. Ruby does this for example with Fixnum/Bignum - all values in Ruby are actually tagged pointers (where the lower bits are set to cause invalid alignment of a pointer in order to indicate it is a special case immediate value). So if the lowest bit is set, the value is a FixNum integer with a lower max/higher min than a traditional integer. On overflow, the value is promoted to be a BigNum, which is a reference to an arbitrary sized integer on the heap.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt; <br>&gt; I would also like to see big number some day.<br></p><p>I&#39;ve just finished the implementation of Decimal in Foundation on Linux, which provides for a greater (though not unlimited) space of numbers.<br></p><p>https://github.com/apple/swift-corelibs-foundation/pull/687<br></p><p>Alex<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161019/41e38d44/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br></p><p>Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br></p><p><br>&gt; <br>&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br></p><p>Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br></p><p>Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br></p><p>&gt; <br>&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br></p><p><br>Well it’s not just C compatibility, it’s underlying processor compatibility. And actually, yes, I think C compatibility is vastly more important than being able to make your [Int?] arrays smaller considering that full 2’s complement numbers is what the OS calls and libc calls are expecting.<br></p><p>&gt; <br>&gt; - Guoye<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt; <br>&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt; <br>It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt; <br>&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt; <br>&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt; <br>I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br></p><p>Int performance would surely suffer because of current instruction sets, but Int? would improve.<br></p><p>&gt;&gt; <br>&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt; <br>&gt; <br>&gt; Well it’s not just C compatibility, it’s underlying processor compatibility. And actually, yes, I think C compatibility is vastly more important than being able to make your [Int?] arrays smaller considering that full 2’s complement numbers is what the OS calls and libc calls are expecting.<br>&gt; <br>Yes, that is also the result Joe said of their previous internal discussion. Anyway, I know this is improbable, and I&#39;m just glad that this possibility is considered.<br></p><p>- Guoye<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a6729e3608691552bd1c61373d0e5b08?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Kevin Nattinger</string> &lt;swift at nattinger.net&gt;<p>October 19, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 8:13 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt; <br>&gt;&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt;&gt; <br>&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br></p><p>I’ve only needed an array of optionals once, maybe twice. I don’t think arrays of optionals are widely used to begin with, and the reason there are few optional integers in the stdlib is because the interface is from objc, which doesn’t have optionals. I doubt any thought at all was given in designing the standard library to the extra space for an optional.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt; <br>&gt;&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt;&gt; <br>&gt;&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt;&gt; <br>&gt; I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br>&gt; <br>&gt; Int performance would surely suffer because of current instruction sets, but Int? would improve.<br></p><p>In my experience, ints are used orders of magnitude more often than optional int?s. Why optimize for the rare case?<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Well it’s not just C compatibility, it’s underlying processor compatibility. And actually, yes, I think C compatibility is vastly more important than being able to make your [Int?] arrays smaller considering that full 2’s complement numbers is what the OS calls and libc calls are expecting.<br>&gt;&gt; <br>&gt; Yes, that is also the result Joe said of their previous internal discussion. Anyway, I know this is improbable, and I&#39;m just glad that this possibility is considered.<br>&gt; <br>&gt; - Guoye<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; 在 2016年10月19日，11:43，Kevin Nattinger &lt;swift at nattinger.net&gt; 写道：<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 8:13 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt;&gt;&gt; <br>&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt; <br>&gt; I’ve only needed an array of optionals once, maybe twice. I don’t think arrays of optionals are widely used to begin with, and the reason there are few optional integers in the stdlib is because the interface is from objc, which doesn’t have optionals. I doubt any thought at all was given in designing the standard library to the extra space for an optional.<br>&gt; <br>Swift stdlib is independent from objc. Currently, &quot;Int?&quot; storage has a tradeoff between less space (n + 1 bytes) and unaligned access, and more space (n * 2 bytes) and fast access. Neither of them is optimal.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt;&gt;&gt; <br>&gt;&gt; I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br>&gt;&gt; <br>&gt;&gt; Int performance would surely suffer because of current instruction sets, but Int? would improve.<br>&gt; <br>&gt; In my experience, ints are used orders of magnitude more often than optional int?s. Why optimize for the rare case?<br>&gt; <br>If we were to have safe arithmetic that produces optionals, or lenient subscript, it is important to have efficient optional integers. I do agree that Int slowing down is unacceptable.<br></p><p>- Guoye<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 19, 2016, at 9:16 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; 在 2016年10月19日，11:43，Kevin Nattinger &lt;swift at nattinger.net&gt; 写道：<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Oct 19, 2016, at 8:13 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt;&gt; <br>&gt;&gt; I’ve only needed an array of optionals once, maybe twice. I don’t think arrays of optionals are widely used to begin with, and the reason there are few optional integers in the stdlib is because the interface is from objc, which doesn’t have optionals. I doubt any thought at all was given in designing the standard library to the extra space for an optional.<br>&gt;&gt; <br>&gt; Swift stdlib is independent from objc. Currently, &quot;Int?&quot; storage has a tradeoff between less space (n + 1 bytes) and unaligned access, and more space (n * 2 bytes) and fast access. Neither of them is optimal.<br></p><p>Something worth considering at a higher level is whether Array ought to align storage at all. Modern Intel and Apple CPUs pay much less of a penalty for unaligned access than older microarchitectures, and the memory savings of packing arrays of Int? and similar types would be significant. (There are C compatibility issues here too, since C&#39;s semantic model requires pointers to be well-aligned for their type, and we want Swift.Arrays of C types to be cheaply interoperable with pointer-based C APIs. This could perhaps be dealt with by guaranteeing that C basic types and structs always have sizeof(T) % alignof(T) == 0, and well-aligning the beginning of arrays.)<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Int performance would surely suffer because of current instruction sets, but Int? would improve.<br>&gt;&gt; <br>&gt;&gt; In my experience, ints are used orders of magnitude more often than optional int?s. Why optimize for the rare case?<br>&gt;&gt; <br>&gt; If we were to have safe arithmetic that produces optionals, or lenient subscript, it is important to have efficient optional integers. I do agree that Int slowing down is unacceptable.<br>&gt; <br>&gt; - Guoye<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; 在 2016年10月19日，12:21，Joe Groff &lt;jgroff at apple.com&gt; 写道：<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Oct 19, 2016, at 9:16 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 在 2016年10月19日，11:43，Kevin Nattinger &lt;swift at nattinger.net&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Oct 19, 2016, at 8:13 AM, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ve only needed an array of optionals once, maybe twice. I don’t think arrays of optionals are widely used to begin with, and the reason there are few optional integers in the stdlib is because the interface is from objc, which doesn’t have optionals. I doubt any thought at all was given in designing the standard library to the extra space for an optional.<br>&gt;&gt;&gt; <br>&gt;&gt; Swift stdlib is independent from objc. Currently, &quot;Int?&quot; storage has a tradeoff between less space (n + 1 bytes) and unaligned access, and more space (n * 2 bytes) and fast access. Neither of them is optimal.<br>&gt; <br>&gt; Something worth considering at a higher level is whether Array ought to align storage at all. Modern Intel and Apple CPUs pay much less of a penalty for unaligned access than older microarchitectures, and the memory savings of packing arrays of Int? and similar types would be significant. (There are C compatibility issues here too, since C&#39;s semantic model requires pointers to be well-aligned for their type, and we want Swift.Arrays of C types to be cheaply interoperable with pointer-based C APIs. This could perhaps be dealt with by guaranteeing that C basic types and structs always have sizeof(T) % alignof(T) == 0, and well-aligning the beginning of arrays.)<br>&gt; <br>&gt; -Joe<br>&gt; <br>That would be great, and certainly needs exploring before locking ABI.<br></p><p>- Guoye<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Int performance would surely suffer because of current instruction sets, but Int? would improve.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my experience, ints are used orders of magnitude more often than optional int?s. Why optimize for the rare case?<br>&gt;&gt;&gt; <br>&gt;&gt; If we were to have safe arithmetic that produces optionals, or lenient subscript, it is important to have efficient optional integers. I do agree that Int slowing down is unacceptable.<br>&gt;&gt; <br>&gt;&gt; - Guoye<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>October 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 19 Oct 2016, at 16:13, Guoye Zhang &lt;cc941201 at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt; <br>&gt;&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt;&gt; <br>&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br></p><p>Int? is an enum wrapping an integer, why wouldn’t you expect it to be bigger than an Int? I honestly don’t get why this is suddenly a huge problem. If you are working in a situation where you need an in memory array of ~billion Ints, I agree it becomes an issue but there’s nothing stopping you from implementing the convention manually for that one application. <br></p><p><br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt; <br>&gt;&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt;&gt; <br>&gt;&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt;&gt; <br>&gt; I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br>&gt; <br>&gt; Int performance would surely suffer because of current instruction sets, but Int? would improve.<br></p><p>I wouldn’t want to trade Int performance off against Int? performance. I think the former is much more common. <br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So what do you think? Can we break C compatibility a bit for better Swift types?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Well it’s not just C compatibility, it’s underlying processor compatibility. And actually, yes, I think C compatibility is vastly more important than being able to make your [Int?] arrays smaller considering that full 2’s complement numbers is what the OS calls and libc calls are expecting.<br>&gt;&gt; <br>&gt; Yes, that is also the result Joe said of their previous internal discussion. Anyway, I know this is improbable, and I&#39;m just glad that this possibility is considered.<br></p><p>I agree that it’s important to discuss these ideas. When you proposed this, my first reaction was “this is crazy” but reading the rationale and other posts, made me realise that my reaction was almost just a reflexive reaction along the lines of “it’s always been this way, why change?”. Your post forced me to sit down and think about why it should or shouldn’t be implemented in Swift. As you can see, my final position didn’t change, but you made me think and whichever way the discussion eventually goes, that’s a good thing.<br></p><p><br>&gt; <br>&gt; - Guoye<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eb0d0358af1f99d8dc5970844e5b8180?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt / use smaller Integer</strong> from <string>Martin Waitz</string> &lt;tali at admingilde.org&gt;<p>October 20, 2016 at 04:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>&gt; It&#39;s just that a common data type wasting almost half the space seems <br>&gt; inefficient. I guess this is also the reason why they didn&#39;t adopt <br>&gt; optional integers widely in stdlib.<br></p><p>When someone is really interested in fitting an optional integer into <br>one machine word,<br>then the best way would be to use a smaller integer type (e.g. Int32 <br>instead of Int64).<br>These also can be mapped well into Enums (a single reserved value does <br>not help at all here).<br></p><p>There are some almost 64-bit integers (Builtin.Int60 .. Builtin.Int63).<br>Maybe something like this could also be provided for normal use?<br></p><p>-- <br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt / use smaller Integer</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>October 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 20 Oct 2016, at 15:51, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello,<br>&gt; <br>&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt; <br>&gt; When someone is really interested in fitting an optional integer into one machine word,<br>&gt; then the best way would be to use a smaller integer type (e.g. Int32 instead of Int64).<br>&gt; These also can be mapped well into Enums (a single reserved value does not help at all here).<br>&gt; <br>&gt; There are some almost 64-bit integers (Builtin.Int60 .. Builtin.Int63).<br>&gt; Maybe something like this could also be provided for normal use?<br></p><p>I mentioned earlier, but it&#39;d be nice to see the ability to specify arbitrary width integers up to the word size. I myself have a type where I could more efficiently use a 7-bit integer, to offset the extra bit for an optional, but currently have to just use a byte (or else use some kind of awkward trickery). Presumably all of the weird builtin sizes are implemented somehow to as 64-bit operations, it&#39;s just the size that differs.<br></p><p>I&#39;m not very knowledgeable on the subject though, so I&#39;m not sure if I&#39;d be the best person to write up a proposal, though I could always keep it high level.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt / use smaller Integer</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 20, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Oct 20, 2016, at 8:25 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 20 Oct 2016, at 15:51, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt;&gt; <br>&gt;&gt; When someone is really interested in fitting an optional integer into one machine word,<br>&gt;&gt; then the best way would be to use a smaller integer type (e.g. Int32 instead of Int64).<br>&gt;&gt; These also can be mapped well into Enums (a single reserved value does not help at all here).<br>&gt;&gt; <br>&gt;&gt; There are some almost 64-bit integers (Builtin.Int60 .. Builtin.Int63).<br>&gt;&gt; Maybe something like this could also be provided for normal use?<br>&gt; <br>&gt; I mentioned earlier, but it&#39;d be nice to see the ability to specify arbitrary width integers up to the word size. I myself have a type where I could more efficiently use a 7-bit integer, to offset the extra bit for an optional, but currently have to just use a byte (or else use some kind of awkward trickery). Presumably all of the weird builtin sizes are implemented somehow to as 64-bit operations, it&#39;s just the size that differs.<br>&gt; <br>&gt; I&#39;m not very knowledgeable on the subject though, so I&#39;m not sure if I&#39;d be the best person to write up a proposal, though I could always keep it high level.<br></p><p>This is supported by LLVM and exposed through the low-level &#39;Builtin&#39; module in Swift, though the standard library doesn&#39;t expose it to user code. If you define an enum { case Foo(Builtin.Int63), Bar }, Swift already knows how to use the spare bits in an Int63 to avoid spilling extra tag bits.<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt / use smaller Integer</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 20, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Oct 20, 2016, at 10:25, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 20 Oct 2016, at 15:51, Martin Waitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello,<br>&gt;&gt; <br>&gt;&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt;&gt; <br>&gt;&gt; When someone is really interested in fitting an optional integer into one machine word,<br>&gt;&gt; then the best way would be to use a smaller integer type (e.g. Int32 instead of Int64).<br>&gt;&gt; These also can be mapped well into Enums (a single reserved value does not help at all here).<br>&gt;&gt; <br>&gt;&gt; There are some almost 64-bit integers (Builtin.Int60 .. Builtin.Int63).<br>&gt;&gt; Maybe something like this could also be provided for normal use?<br>&gt; <br>&gt; I mentioned earlier, but it&#39;d be nice to see the ability to specify arbitrary width integers up to the word size. I myself have a type where I could more efficiently use a 7-bit integer, to offset the extra bit for an optional, but currently have to just use a byte (or else use some kind of awkward trickery). Presumably all of the weird builtin sizes are implemented somehow to as 64-bit operations, it&#39;s just the size that differs.<br>&gt; <br>&gt; I&#39;m not very knowledgeable on the subject though, so I&#39;m not sure if I&#39;d be the best person to write up a proposal, though I could always keep it high level.<br></p><p>Conceptually, if we ever get around to allowing literals as generic parameters and default values for generic parameters, I don&#39;t think it would be too hard to write something like<br>    struct Int&lt;Width: IntegerLiteral = 64&gt; {...}<br>and have it generally perform as well as `Int` does now, just by sign-extending the bits to the next available CPU-native size when the value is loaded from memory. The exception is that if `Width` isn&#39;t a power of two (and &gt;= 8) we&#39;d have to do our own overflow checking, since CPUs only handle 8/16/32/64-bit ints. I *think* this only has to be done when the value is stored back into system memory... If the value stays overflown, it&#39;d be caught when stored back to RAM, if it comes back down it&#39;ll have the correct answer despite temporarily needing a extra few bits (kinda like 80-bit floats), and if it overflows the native CPU type we haven&#39;t lost anything over the current approach. I haven&#39;t given it more thought than it took to write that out, though... I could easily be missing something (the location of the overflow exception, for example, could be relatively distant from where the &quot;fauxverflow&quot; happened... annoying for debuggers, but I don&#39;t think it matters once the code is working).<br></p><p>Personally, I&#39;d be in favor of a note in the docs indicating that there&#39;s a slight speed hit from using non-&quot;powers of two&quot; widths, and letting develop decide if it&#39;s more important for them to prioritize memory use over absolute performance. Especially since one of the big hurdles of performance-critical is waiting on RAM anyway.<br></p><p>On a purely speculative note, the overflow-checking penalty would go away if CPUs get hardware support for oddly sized ints. Some of Intels newer CPUs (starting with Sky Lake&#39;s predecessor, IIRC) have instructions specifically to speed up BigNums, so I don&#39;t think it&#39;s so &quot;out there&quot; to think they might start including instructions for &quot;LittleNums&quot;<br></p><p>- Dave Sweeris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/54da6eaeec6b83e06a5661ce8c62980d?s=50"></div><header><strong>[Pitch] Ban the top value in Int/UInt</strong> from <string>Guoye Zhang</string> &lt;cc941201 at me.com&gt;<p>October 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; 在 2016年10月20日，05:45，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 19 Oct 2016, at 16:13, Guoye Zhang &lt;cc941201 at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; 在 2016年10月19日，07:10，Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; 写道：<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 18 Oct 2016, at 19:17, Guoye Zhang via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, Swift Int family and UInt family have compact representations that utilize all available values, which is inherited from C. However, it is horribly inefficient to implement optional integers. It takes double the space to store [Int?] than to store [Int] because of alignment.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this a general problem with Swift? Are lots of people complaining that they are running out of space for their Optional&lt;Int&gt; arrays?<br>&gt;&gt;&gt; <br>&gt;&gt; It&#39;s just that a common data type wasting almost half the space seems inefficient. I guess this is also the reason why they didn&#39;t adopt optional integers widely in stdlib.<br>&gt; <br>&gt; Int? is an enum wrapping an integer, why wouldn’t you expect it to be bigger than an Int? I honestly don’t get why this is suddenly a huge problem. If you are working in a situation where you need an in memory array of ~billion Ints, I agree it becomes an issue but there’s nothing stopping you from implementing the convention manually for that one application. <br>&gt; <br>MemoryLayout&lt;AnyObject????&gt;.size is the same as MemoryLayout&lt;AnyObject&gt;.size because there are invalid addresses in pointers that Swift compiler can use to represent nil.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I propose to ban the top value in Int/UInt which is 0xFFFF... in hex. Int family would lose its smallest value, and UInt family would lose its largest value. Top value is reserved for nil in optionals. An additional benefit is that negating an Int would never crash.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well the “top value” for signed ints would have to be 0x8000... not 0xffff... which is the representation of -1. The top value for unsigned ints cannot be banned because unsigned integers are often used as bit fields either directly or in OptionSets.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Furthermore, how would the semantics of &amp;+ and &amp;- be affected? What about the performance of those two operators?<br>&gt;&gt;&gt; <br>&gt;&gt; I was originally going for the symmetry between Int and UInt as in compatible bit patterns. Now that I think of it, UInt is commonly used for bitwise operations, and it doesn&#39;t make sense to optimize for &quot;UInt?&quot; which is uncommon. So I agree that 0x80... is better.<br>&gt;&gt; <br>&gt;&gt; Int performance would surely suffer because of current instruction sets, but Int? would improve.<br>&gt; <br>&gt; I wouldn’t want to trade Int performance off against Int? performance. I think the former is much more common. <br></p><p>Slowing down Int is never my intent. I hope to have Int? that gives on par performance with Int, and the possibility to have safe arithmetics that doesn&#39;t impose overhead.<br></p><p>- Guoye<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
