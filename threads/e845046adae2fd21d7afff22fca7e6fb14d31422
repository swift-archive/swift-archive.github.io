<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 14, 2016 at 10:00:00am</p></header><div class="content"><p>on Wed Apr 13 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On Apr 13, 2016, at 5:36 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Apr 13 2016, plx &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;    On Apr 12, 2016, at 5:25 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    on Tue Apr 12 2016, plx<br>&gt;&gt;&gt;    &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Aside: `indices` being irregular can be a benefit in the context of<br>&gt;&gt;&gt;        auto-complete.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        +1, very much.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        As a change from the current model, it’s an across-the-board improvement<br>&gt;&gt;&gt;        for me,<br>&gt;&gt;&gt;        at least.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        In a bigger-picture sense I think Swift would be better off by going<br>&gt;&gt;&gt;        *further*<br>&gt;&gt;&gt;        on certain aspects, but have said all that before.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        * Is the problem being addressed significant enough to warrant a change<br>&gt;&gt;&gt;        to<br>&gt;&gt;&gt;        Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        It is, again very much so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Depends on the framing of the question.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Compared to the previous model, it’s an unqualified YES.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        As a general proposition, I think this design is a local optimum for<br>&gt;&gt;&gt;        overall<br>&gt;&gt;&gt;        Swift-ness, but even so it’s creating a little un-Swifty pocket. It’s<br>&gt;&gt;&gt;        “un-Swifty” in at least two ways:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        # 1: Relatively Unsafe, Pointer-Like Semantics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Indices—unsurprisingly!—behave quite a bit like pointers, and similarly<br>&gt;&gt;&gt;        expose<br>&gt;&gt;&gt;        *numerous* crashing combinations of `(value,operation)`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        - self[endIndex]<br>&gt;&gt;&gt;        - self[startIndex] // &lt;- when empty<br>&gt;&gt;&gt;        - successor(of: endIndex)<br>&gt;&gt;&gt;        - predecessor(of: startIndex)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        …etc., which is *very much* reminiscent of the hazards of pointers.<br>&gt;&gt;&gt;        (Technically<br>&gt;&gt;&gt;        “undefined” not “crashing”, but being realistic “crashing&quot; is usually<br>&gt;&gt;&gt;        accurate).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    No, these are unspecified in the general case, not undefined. Unless<br>&gt;&gt;&gt;    you&#39;re working with, e.g. `UnsafeMutableBufferPointer` (or you have a<br>&gt;&gt;&gt;    data race), there&#39;s no undefined behavior. The big problem with<br>&gt;&gt;&gt;    pointers isn&#39;t what happens when they crash; it&#39;s what happens when they<br>&gt;&gt;&gt;    *don&#39;t*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        Although Swift uses `Optional` to mitigate the hazards of `nil` pointers<br>&gt;&gt;&gt;        (etc.),<br>&gt;&gt;&gt;        you’re still left to your own devices for handling indices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    `Optional` is not “mitigating hazards;” it&#39;s encoding the possibility of<br>&gt;&gt;&gt;    null in the type system. It&#39;s non-optional things that mitigate hazards.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        This isn’t news to anyone here, I’m sure, and may even be unavoidable;<br>&gt;&gt;&gt;        I’m just<br>&gt;&gt;&gt;        pointing it out as an uncharacteristically-unsafe area in Swift’s<br>&gt;&gt;&gt;        standard APIs,<br>&gt;&gt;&gt;        and closer to how `!` and IOUs behave than otherwise typical.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Any time there&#39;s a required relationship between two things, e.g. a<br>&gt;&gt;&gt;    receiver and an argument, you have a precondition. The existence of a<br>&gt;&gt;&gt;    precondition does not make something unsafe at all in the sense that<br>&gt;&gt;&gt;    Swift uses the term. Safety in swift is about type and memory safety in<br>&gt;&gt;&gt;    the absence of data races, not about having APIs that respond sensibly<br>&gt;&gt;&gt;    to every possible combination of arguments. Int.max + 1 will trap, but<br>&gt;&gt;&gt;    that doesn&#39;t make addition unsafe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    Saying that it&#39;s close to how `!` behaves is not at all far from the<br>&gt;&gt;&gt;    truth, because `!` has a precondition that its argument is non-nil.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I meant it as a much more exact analogy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In a collections-move-indices world, you *could* handle indices as pointers have<br>&gt;&gt;&gt; been handled, bringing in support from the type-system:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum SaferIndex&lt;T:Comparable&gt; {<br>&gt;&gt;&gt; case Position(T)<br>&gt;&gt;&gt; case End<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; …(yes, this is more-or-less `Optional` by another name).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The assumption above is `T` would be today’s “Index” types, w/o the value used<br>&gt;&gt;&gt; for `endIndex` (e.g. 0..&lt;self.count for an array, the non-`endIndex` values of<br>&gt;&gt;&gt; `DictionaryIndex` and `SetIndex`, and so on).<br>&gt;&gt; <br>&gt;&gt; No, you can&#39;t, at least not usefully.  An Index that&#39;s at the end of one<br>&gt;&gt; collection is in the middle of another, or with a suitably-modified version<br>&gt;&gt; of the same collection.  <br>&gt;<br>&gt; Sure, in certain concrete scenarios it’s possible for one collection’s<br>&gt; indices to have such relationships to some other collection.<br>&gt;<br>&gt; But, what of it? <br>&gt;<br>&gt; In a generic context you can’t assume this; <br></p><p>That&#39;s incorrect.  A slice&#39;s indices are *documented* as having a<br>particular relationship to those of the thing it was sliced from.  This<br>applies everywhere.  A dictionary&#39;s keys and values use the same indices<br>as the dictionary itself, and have a correspondence.<br></p><p>&gt; in a concrete context you naturally have more information.<br>&gt;<br>&gt; Slices would become problematic, I’ll grant.<br>&gt;<br>&gt;&gt;  var x = [1, 2]<br>&gt;&gt;  let i = x.index(1, stepsFrom: x.startIndex)<br>&gt;&gt;  x.removeLast()<br>&gt;&gt;  x[i]           // fatal error: Index out of range<br>&gt;<br>&gt; Indices can become invalid; this imposes preconditions. I don’t get<br>&gt; it.<br></p><p>My point is that whether i is at the end or not cannot be encoded in i.<br></p><p>&gt;&gt; The converse is also true: subscripting on a collection&#39;s endIndex is<br>&gt;&gt; sometimes just fine, even with no mutation in sight.<br>&gt;&gt; <br>&gt;&gt;  let a = (0..&lt;10).reversed()<br>&gt;&gt;  print(Array(a))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]”<br>&gt;&gt; <br>&gt;&gt;  let b = a.prefix(9)<br>&gt;&gt;  print(Array(b))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1]”<br>&gt;&gt; <br>&gt;&gt;  print(a[b.endIndex]) // “0” (correct, supported behavior)<br>&gt;<br>&gt; I believe we are back to “subscripting one collection with *another*<br>&gt; collection&#39;s `endIndex`, no?<br></p><p>Totally legit, as mentioned above.  a.prefix(9) returns a slice of a.<br></p><p>&gt; Are there any circumstances where a collection *can* be<br>&gt; usefully-subscripted with its *own* `endIndex`?<br></p><p>var a = [1]<br>let i = a.endIndex<br>a.append(2)<br>print(a[i]) // “2”<br></p><p>&gt;&gt; <br>&gt;&gt; Of course,<br>&gt;&gt; <br>&gt;&gt;  b[b.endIndex]        // As a matter of QOI: fatal error: out of bounds: index &gt;= endIndex<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would’ve been awkward to do this under the previous status quo—e.g. even for<br>&gt;&gt;&gt; arrays your indices would have to have a back-reference to get the count, and<br>&gt;&gt;&gt; thus couldn’t be plain integers—but the collection will now always be present to<br>&gt;&gt;&gt; provide such info.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cons:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - more overhead than “bare” indices<br>&gt;&gt;&gt; - doesn’t address invalidation (but what does, really?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Pros:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - easier in some ways to handle things like e.g 0…Int.max<br>&gt;&gt;&gt; - the endIndex equivalent *never* invalidates <br>&gt;&gt;&gt; - compile-time help for end-index checking<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Overall this *would* bring the treatment of indices closer to that for `?`—e.g.,<br>&gt;&gt;&gt; redefine the core type to omit the `nil`-like value, <br>&gt;&gt; <br>&gt;&gt; Sorry, but that&#39;s the opposite of what `?` is doing: it *adds* a nil<br>&gt;&gt; value.  <br>&gt;<br>&gt; …I must have been unclear.<br>&gt;<br>&gt; Step 1: Define T* = { &quot;all memory addresses” (nil included) }<br>&gt; Step 2: Define T = T* \ { nil } (e.g. &quot;non-null pointers&quot;)<br>&gt;<br>&gt; …is what I was trying to summarize via “redefine the core type to omit<br>&gt; the `nil`-like value” (which is the important part here).<br></p><p>Sorry, that&#39;s still unclear to me.  I just don&#39;t see what you&#39;re getting<br>at.<br></p><p>&gt; Anyways, having `endIndex` directly inhabit the same type as the<br>&gt; “good” indices has some pros and some cons; it’s not an IMHO one-sided<br>&gt; situation as with `nil`.<br></p><p>Maybe, but my point is that many things in the current model are<br>incompatible with the other arrangement.  If you wanted to change the<br>arrangement, you&#39;d need to re-think the current model from the ground<br>up, including index invalidation, how algorithms interact, the<br>relationship of slices to the thing they&#39;re sliced from, etc...<br></p><p>So what you&#39;re suggesting is an interesting hypothesis, but to me it&#39;s<br>not by any means obviously workable.<br></p><p>&gt; On the one hand, in my own experience so far, it’s definitely been the<br>&gt; case that most custom collections I’d done have had indices that’re<br>&gt; effectively the `SaferIndex` above; it’s been rather rare that there’s<br>&gt; been a natural “1 past the rest” value to use of the same type as is<br>&gt; used to describe the position of a “good” index.<br>&gt;<br>&gt;&gt; Seriously, just because Swift has Optionals and they&#39;re useful for<br>&gt;&gt; safety in some scenarios (compared with allowing everything to be<br>&gt;&gt; nullable) does not mean that it&#39;s going to be “Swiftier” to apply a<br>&gt;&gt; similar pattern everywhere.<br>&gt;&gt; <br>&gt;&gt;&gt; use an enum to reintroduce that value when necessary—than to `!`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think the above is an *improvement* over the proposal, but it’s a route<br>&gt;&gt;&gt; that could have been taken.<br>&gt;&gt; <br>&gt;&gt; I believe it would be hard to make such a design work at all, and if you<br>&gt;&gt; could make it work I think you&#39;d end up with exactly the problem this<br>&gt;&gt; proposal aims to solve: references inside indices.  So, I don&#39;t think<br>&gt;&gt; it&#39;s even a possibility, really.<br>&gt;<br>&gt; I can’t say I see the impossibility. I definitely have experienced the<br>&gt; clunkiness.<br>&gt;<br>&gt; This is getting too involved for a hypothetical I was explaining, but<br>&gt; not advocating.<br></p><p>I will happily agree to drop this topic :-)<br></p><p>&gt; This proposal and the new design is a good design!<br></p><p>Thanks!<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        To help illustrate the claim, here’s a strawman “safe” API—for<br>&gt;&gt;&gt;        illustration<br>&gt;&gt;&gt;        only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt;&gt;&gt;    single out this post or this poster) about what “safe” means in Swift<br>&gt;&gt;&gt;    and what the features of a Swifty API are and should be. This<br>&gt;&gt;&gt;    is a big topic worthy of much more time than I can devote here, but<br>&gt;&gt;&gt;    here&#39;s a thought to start with:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    A Swifty API helps you reason effectively about the correctness of your<br>&gt;&gt;&gt;    code, and in part that means we provide enough preconditions on<br>&gt;&gt;&gt;    arguments to avoid complicating result types, and code to handle<br>&gt;&gt;&gt;    results, with optional-ness.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    -- <br>&gt;&gt;&gt;    Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    _______________________________________________<br>&gt;&gt;&gt;    swift-evolution mailing list<br>&gt;&gt;&gt;    swift-evolution at swift.org<br>&gt;&gt;&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0065 A New Model for Collections and Indices</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>April 14, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Apr 14, 2016, at 12:12 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; No, you can&#39;t, at least not usefully.  An Index that&#39;s at the end of one<br>&gt;&gt;&gt; collection is in the middle of another, or with a suitably-modified version<br>&gt;&gt;&gt; of the same collection.  <br>&gt;&gt; <br>&gt;&gt; Sure, in certain concrete scenarios it’s possible for one collection’s<br>&gt;&gt; indices to have such relationships to some other collection.<br>&gt;&gt; <br>&gt;&gt; But, what of it? <br>&gt;&gt; <br>&gt;&gt; In a generic context you can’t assume this; <br>&gt; <br>&gt; That&#39;s incorrect.  A slice&#39;s indices are *documented* as having a<br>&gt; particular relationship to those of the thing it was sliced from.  This<br>&gt; applies everywhere.  A dictionary&#39;s keys and values use the same indices<br>&gt; as the dictionary itself, and have a correspondence.<br></p><p>You’re right, of course; I rarely use slices and completely overlooked them.<br></p><p>I also phrased it badly, b/c what I was trying to express is that code like the below is (I think?) unlikely to work generically:<br></p><p>  extension Collection where Element:Equatable {<br></p><p>     // plz don’t do this<br>     func hasValueMismatch(with other: Self, at index: Index) -&gt; Bool {<br>       return self[index] != other[index]<br>     }<br></p><p>     // plz don’t do this either<br>    func hasValueMismatch&lt;K:Collection where K.Index == Index, K.Element == Self.Element&gt;(with other: K, at index: Index) -&gt; Bool { <br>      return self[index] != other[index]<br>    }<br></p><p>  }<br></p><p>…(you would’t write the above anyway, but it illustrates the kind of &quot;generic context&quot; I had in mind when I wrote it).<br></p><p>&gt; <br>&gt;&gt; in a concrete context you naturally have more information.<br>&gt;&gt; <br>&gt;&gt; Slices would become problematic, I’ll grant.<br>&gt;&gt; <br>&gt;&gt;&gt; var x = [1, 2]<br>&gt;&gt;&gt; let i = x.index(1, stepsFrom: x.startIndex)<br>&gt;&gt;&gt; x.removeLast()<br>&gt;&gt;&gt; x[i]           // fatal error: Index out of range<br>&gt;&gt; <br>&gt;&gt; Indices can become invalid; this imposes preconditions. I don’t get<br>&gt;&gt; it.<br>&gt; <br>&gt; My point is that whether i is at the end or not cannot be encoded in i.<br></p><p>I see the miscommunication, now. Of course you can’t encode that.<br></p><p>I’ve put a couple examples down below as a last effort at communicating what I’m getting at it. <br></p><p>&gt;&gt;&gt; The converse is also true: subscripting on a collection&#39;s endIndex is<br>&gt;&gt;&gt; sometimes just fine, even with no mutation in sight.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let a = (0..&lt;10).reversed()<br>&gt;&gt;&gt; print(Array(a))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let b = a.prefix(9)<br>&gt;&gt;&gt; print(Array(b))      // “[9, 8, 7, 6, 5, 4, 3, 2, 1]”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; print(a[b.endIndex]) // “0” (correct, supported behavior)<br>&gt;&gt; <br>&gt;&gt; I believe we are back to “subscripting one collection with *another*<br>&gt;&gt; collection&#39;s `endIndex`, no?<br>&gt; <br>&gt; Totally legit, as mentioned above.  a.prefix(9) returns a slice of a.<br>&gt; <br>&gt;&gt; Are there any circumstances where a collection *can* be<br>&gt;&gt; usefully-subscripted with its *own* `endIndex`?<br>&gt; <br>&gt; var a = [1]<br>&gt; let i = a.endIndex<br>&gt; a.append(2)<br>&gt; print(a[i]) // “2”<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b[b.endIndex]        // As a matter of QOI: fatal error: out of bounds: index &gt;= endIndex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It would’ve been awkward to do this under the previous status quo—e.g. even for<br>&gt;&gt;&gt;&gt; arrays your indices would have to have a back-reference to get the count, and<br>&gt;&gt;&gt;&gt; thus couldn’t be plain integers—but the collection will now always be present to<br>&gt;&gt;&gt;&gt; provide such info.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cons:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - more overhead than “bare” indices<br>&gt;&gt;&gt;&gt; - doesn’t address invalidation (but what does, really?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Pros:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - easier in some ways to handle things like e.g 0…Int.max<br>&gt;&gt;&gt;&gt; - the endIndex equivalent *never* invalidates <br>&gt;&gt;&gt;&gt; - compile-time help for end-index checking<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Overall this *would* bring the treatment of indices closer to that for `?`—e.g.,<br>&gt;&gt;&gt;&gt; redefine the core type to omit the `nil`-like value, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, but that&#39;s the opposite of what `?` is doing: it *adds* a nil<br>&gt;&gt;&gt; value.  <br>&gt;&gt; <br>&gt;&gt; …I must have been unclear.<br>&gt;&gt; <br>&gt;&gt; Step 1: Define T* = { &quot;all memory addresses” (nil included) }<br>&gt;&gt; Step 2: Define T = T* \ { nil } (e.g. &quot;non-null pointers&quot;)<br>&gt;&gt; <br>&gt;&gt; …is what I was trying to summarize via “redefine the core type to omit<br>&gt;&gt; the `nil`-like value” (which is the important part here).<br>&gt; <br>&gt; Sorry, that&#39;s still unclear to me.  I just don&#39;t see what you&#39;re getting<br>&gt; at.<br>&gt; <br>&gt;&gt; Anyways, having `endIndex` directly inhabit the same type as the<br>&gt;&gt; “good” indices has some pros and some cons; it’s not an IMHO one-sided<br>&gt;&gt; situation as with `nil`.<br>&gt; <br>&gt; Maybe, but my point is that many things in the current model are<br>&gt; incompatible with the other arrangement.  If you wanted to change the<br>&gt; arrangement, you&#39;d need to re-think the current model from the ground<br>&gt; up, including index invalidation, how algorithms interact, the<br>&gt; relationship of slices to the thing they&#39;re sliced from, etc...<br>&gt; <br>&gt; So what you&#39;re suggesting is an interesting hypothesis, but to me it&#39;s<br>&gt; not by any means obviously workable.<br></p><p>You’re completely right about slices. I’ll provide a couple concrete examples before addressing the rest.<br></p><p>Here are three collection-combinators (or adapters I think you’d call them):<br></p><p>  // Collection with elements of A, then elements of B.<br>  struct ChainCollection&lt;A:Collection,B:Collection&gt; : Collection {<br>    let a: A; let b: B;<br>  }<br></p><p>  // Collection with elements `(a,b)` for each pair in the cartesian product of `A` and `B`.<br>  struct ProductCollection&lt;A:Collection,B:Collection&gt; : Collection {<br>    let a: A; let b: B;<br>  }<br></p><p>  // Collection with adjacent elements from A<br>  struct AdjacentElementCollection&lt;A:Collection&gt; : Collection { <br>    let a: A<br>  }<br></p><p>…each of which I’ve declared `: Collection` but each which will still need some suitable `Index` implementation.<br></p><p>Here’s one way to write these indices (henceforth, the V1 indices):<br></p><p>  // `endIndex` will be .InB(b.endIndex)<br>  enum ChainCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>    // Precondition: the index isn’t `a.endIndex`.<br>    case InA(A.Index)<br>    case InB(B.Index) <br>  }<br></p><p>  // `endIndex` will have both `.aIndex` and `.bIndex` equal to their “source”&#39;s `endIndex`<br>  struct ProductCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>    let aIndex: A.Index<br>    let bIndex: B.Index<br>  }<br></p><p>  // `endIndex` will be both of these set to `a.endIndex`<br>  // - all other situations expect `upper` is `lower`’s successor, and both != `endIndex`<br>  struct AdjacentElementCollectionIndex&lt;A:Collection&gt; {<br>    let lower: A.Index<br>    let upper: A.Index<br>  }<br></p><p>…(I trust the index-manipulation boilerplate is easy to fill-in).<br></p><p>There’s absolutely nothing wrong with the above! Each of these types has the capability to represent the “good” indices, and also has a reasonable way to represent `endIndex` values.<br></p><p>But, they could also be written like so (henceforth, the V2 indices):<br></p><p>  enum ChainCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>    // Precondition: the index isn’t `a.endIndex`.<br>    case InA(A.Index)<br>    // Precondition: the index isn’t `b.endIndex`.<br>    case InB(B.Index)<br>    // `endIndex` sentinel<br>    case End<br>  }<br></p><p>  enum ProductCollectionIndex&lt;A:Collection,B:Collection&gt; {<br>    // Precondition: neither index is the source collection’s `endIndex`<br>    case Item(A.Index, B.Index)<br>    // `endIndex` sentinel<br>    case End<br>  }<br></p><p>  enum AdjacentElementCollectionIndex&lt;A:Collection&gt; {<br>    // Precondition: `upper` is `lower`’s successor, *both* are != `a.endIndex`<br>    case Adjacency(lower: A.Index, upper: A.Index)<br>    // `endIndex` sentinel<br>    case End<br>  }<br></p><p>…each of which is essentially the V1 version, except now with a dedicated `endIndex` value tacked-on. <br></p><p>Tacking on the dedicated `endIndex` isn’t necessary, but at least for me taking V2-style approaches has been very advantageous. <br></p><p>Most of the advantage has been from being able to enforce stricter invariants on the non-endIndex indices, which generally makes the code simpler and also easier to reason about; I’m also fortunate in that I’m not working on the standard library, and thus can choose how heavily to weight “time to correct implementation” vis-a-vis “proximity to maximum possible efficiency”.<br></p><p>The above indices are drawn from what are admittedly simple combinators/adaptors, but they feel like representative examples for me; even for fancier, actually-custom things it’s almost always been much more natural to go with a V2-style index (and sometimes no natural V1-style approach even exists).<br></p><p>I’ve done a fair amount of experimenting with the model implied above—moving `endIndex` into a dedicated sentinel, etc.—and although it’s pretty easy overall to translate back and forth between the two models, the “alternative” approach *at best* comes out a wash...at best. <br></p><p>For the most part, invalidation is about the same between the two models for all non-end-index—for such indices, the same mutations invalidate the same indices under either approach.<br></p><p>What *is* different between the two is that a cached `endIndex` will never become valid due to mutation, e.g. this won’t happen:<br></p><p>  // status quo:<br>  var items = [“a”, “b”]<br>  let cachedEndIndex = items.endIndex // this is just `2`<br>  items.append[“c”]<br>  items[cachedEndIndex] // returns “c&quot;<br></p><p>  // dedicated `endIndex`:<br>  var items = [“a”, “b”]<br>  let cachedEndIndex = items.endIndex<br>  items.append[“c”]<br>  items[cachedEndIndex] // goes boom, b/c `cachedEndIndex` is still the `endIndex`<br></p><p>…and things like this wouldn&#39;t work the same way:<br></p><p>  // status quo:<br>  var items = [“a”, “b”]<br>  let cachedEndIndex = items.endIndex // this is just `2`<br>  items.insert(“c”, at:  cachedEndIndex) // [“a”, “b”, “c”]<br>  items.insert(“d”, at:  cachedEndIndex) // [“a”, “b”, “d”, “c”]<br></p><p>  // dedicated `endIndex`<br>  var items = [“a”, “b”]<br>  let cachedEndIndex = items.endIndex // this is `.End`<br>  items.insert(“c”, at:  cachedEndIndex) // [“a”, “b”, “c”]<br>  items.insert(“d”, at:  cachedEndIndex) // [“a”, “b”, “c&quot;, “d”]<br></p><p>…because the end-index sentinel would *always* refer to the logical end of the collection.<br></p><p>Slices would truly be problematic here. For the rest, it’s hard to see insurmountable difficulties—especially given the ease of converting between the two approaches, given access to the collection—but I’d expect it to be far clunkier and a tad slower.<br></p><p>&gt;&gt; On the one hand, in my own experience so far, it’s definitely been the<br>&gt;&gt; case that most custom collections I’d done have had indices that’re<br>&gt;&gt; effectively the `SaferIndex` above; it’s been rather rare that there’s<br>&gt;&gt; been a natural “1 past the rest” value to use of the same type as is<br>&gt;&gt; used to describe the position of a “good” index.<br>&gt;&gt; <br>&gt;&gt;&gt; Seriously, just because Swift has Optionals and they&#39;re useful for<br>&gt;&gt;&gt; safety in some scenarios (compared with allowing everything to be<br>&gt;&gt;&gt; nullable) does not mean that it&#39;s going to be “Swiftier” to apply a<br>&gt;&gt;&gt; similar pattern everywhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; use an enum to reintroduce that value when necessary—than to `!`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t think the above is an *improvement* over the proposal, but it’s a route<br>&gt;&gt;&gt;&gt; that could have been taken.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe it would be hard to make such a design work at all, and if you<br>&gt;&gt;&gt; could make it work I think you&#39;d end up with exactly the problem this<br>&gt;&gt;&gt; proposal aims to solve: references inside indices.  So, I don&#39;t think<br>&gt;&gt;&gt; it&#39;s even a possibility, really.<br>&gt;&gt; <br>&gt;&gt; I can’t say I see the impossibility. I definitely have experienced the<br>&gt;&gt; clunkiness.<br>&gt;&gt; <br>&gt;&gt; This is getting too involved for a hypothetical I was explaining, but<br>&gt;&gt; not advocating.<br>&gt; <br>&gt; I will happily agree to drop this topic :-)<br></p><p>It’s dropped, now; I only felt the need to reply one more time b/c I could tell I’d previously failed to communicate clearly-enough. <br></p><p>&gt; <br>&gt;&gt; This proposal and the new design is a good design!<br>&gt; <br>&gt; Thanks!<br></p><p>I really do mean it! Just look at those examples and think of how many redundant back-references they used to need...<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;       To help illustrate the claim, here’s a strawman “safe” API—for<br>&gt;&gt;&gt;&gt;       illustration<br>&gt;&gt;&gt;&gt;       only, not advocacy!—that would be safer and thus perhaps more “Swift-y”:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   I think there&#39;s a prevalent misunderstanding (IOW, I don&#39;t mean to<br>&gt;&gt;&gt;&gt;   single out this post or this poster) about what “safe” means in Swift<br>&gt;&gt;&gt;&gt;   and what the features of a Swifty API are and should be. This<br>&gt;&gt;&gt;&gt;   is a big topic worthy of much more time than I can devote here, but<br>&gt;&gt;&gt;&gt;   here&#39;s a thought to start with:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   A Swifty API helps you reason effectively about the correctness of your<br>&gt;&gt;&gt;&gt;   code, and in part that means we provide enough preconditions on<br>&gt;&gt;&gt;&gt;   arguments to avoid complicating result types, and code to handle<br>&gt;&gt;&gt;&gt;   results, with optional-ness.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   -- <br>&gt;&gt;&gt;&gt;   Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   _______________________________________________<br>&gt;&gt;&gt;&gt;   swift-evolution mailing list<br>&gt;&gt;&gt;&gt;   swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
