<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>January 30, 2016 at 08:00:00pm</p></header><div class="content"><p>on Sat Jan 30 2016, Howard Lovatt &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I disagree that a property should imply O(1), this is an implementation<br>&gt; detail that might change. <br></p><p>Not that I really want to argue this, as I am resigned to the fact that<br>we will not tie performance to property-ness, but...<br></p><p>Efficiency characteristics are no mere implementation detail, at least<br>not in the standard library.  <br></p><p>&gt; For example an array based collection will almost always have a count<br>&gt; property that is O(1), <br></p><p>You can strike &quot;almost&quot; :-)<br></p><p>&gt; but a liked-list based collection will almost always be O(N).<br></p><p>It really depends on whether you allow O(1) splicing.  Without<br>supporting O(1) splicing, it&#39;s really easy for a linked list<br>to have an O(1) count.  And with cacheing, you can even arguably have an<br>amortized O(1) count.<br></p><p>But even if a linked list has O(N) count, I don&#39;t see that what you&#39;re<br>describing indicates anything, by itself, about whether something being<br>a property should have performance implications.  There has to be an<br>underlying assumption that an Array&#39;s count must be a property, or<br>something else of that sort, in the background.<br></p><p>&gt; On Friday, 29 January 2016, Michael Wells &lt;michael at michaelwells.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; &gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt;&gt;&gt; &gt;&gt; &gt; | I originally wanted to uphold the principle that, “if it isn&#39;t<br>&gt;&gt;&gt; O(1),<br>&gt;&gt;&gt; &gt;&gt; you<br>&gt;&gt;&gt; &gt;&gt; &gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt;&gt;&gt; &gt;&gt; &gt; | “count” would be a method.  That would include Array, for which<br>&gt;&gt;&gt; &gt;&gt; counting<br>&gt;&gt;&gt; &gt;&gt; &gt; | the elements *is* O(1).  Some people argued that:<br>&gt;&gt;&gt; &gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt;&gt; &gt; | 1. The idea of writing “a.count()” instead of “a.count” to count<br>&gt;&gt;&gt; the<br>&gt;&gt;&gt; &gt;&gt; &gt; |    elements of an Array was absurd.<br>&gt;&gt;&gt; &gt;&gt; &gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on<br>&gt;&gt;&gt; whether<br>&gt;&gt;&gt; &gt;&gt; &gt; |    something is a property.<br>&gt;&gt;&gt; &gt;&gt; &gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt;&gt;&gt; &gt;&gt; have<br>&gt;&gt;&gt; &gt;&gt; &gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt;&gt;&gt; &gt;&gt; &gt; |    undermines any communicative power that you might get from using<br>&gt;&gt;&gt; &gt;&gt; this<br>&gt;&gt;&gt; &gt;&gt; &gt; |    distinction to choose properties.<br>&gt;&gt;&gt; &gt;&gt; &gt; |<br>&gt;&gt;&gt; &gt;&gt; &gt; | I did not win that argument :-)<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I strongly agree that properties imply O(1) and most programmers I’ve ever<br>&gt;&gt; worked with make the same assumptions. Even if the documentation says<br>&gt;&gt; otherwise, code like<br>&gt;&gt;<br>&gt;&gt; fibonacciNumbers.count<br>&gt;&gt;<br>&gt;&gt; looks as if you’re accessing a c-style field ‘count’ and that implies (at<br>&gt;&gt; least to me) that it is a near-costless operation. Some of the biggest<br>&gt;&gt; design mistakes I’ve ever seen use properties that trigger time-consuming<br>&gt;&gt; operations like database or network access.<br>&gt;&gt;<br>&gt;&gt; And I don’t think having to use a.count() is absurd. :-)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>February  1, 2016 at 12:00:00am</p></header><div class="content"><p>I can&#39;t believe I let it get this far before I began to post regarding these language proposals.<br></p><p>&gt; What is your evaluation of the proposal?<br>I like the proposal, and the direction it shows for Swift. I&#39;m particularly fond of the concise nature of the language.<br></p><p>I wonder specifically whether cases of ivars should be lower or upper case. I tend to think lower case makes more sense in the context of Swift, but I am personally fond of the upper camel case. Perhaps my eyes have just grown accustomed?<br></p><p>I am particularly in favour of the sort() vs sorted() verb vs noun. I definitely see the points raised and acknowledge that the subtleties of language mean there will always be exceptions to rules where it doesn&#39;t make sense, and I think the &quot;inPlace&quot; wording makes sense to fill this gap.<br></p><p>I&#39;m personally not a fan of the strong guidance to eliminate initial argument labels. I find this somewhat of a holdover from the awkward translation of Obj-C APIs, and I think there are cases where the initial parameter makes sense to be named. The login example, while it has its flaws, makes some sense here.<br></p><p>loginWithUsername(&quot;Rod&quot;, password: &quot;Password&quot;)<br>vs<br>login(username:&quot;Rod&quot;, password: &quot;Password&quot;)<br></p><p>Placing the WithUsername prior to the bracket implies that the username has more importance, at least to my eye. As has been discussed, it probably does have more importance, but I think it makes a fair point that there are cases where both arguments are simply peers that should be labeled without emphasis on the leading item. I think that naming each parameter for clarity makes sense in those cases, and this should be noted in documentation. <br></p><p>For all other elements, I am definitely in favour.<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>I definitely think the language benefits from guidance like this. I wonder whether we may need to come back and review this in a few years as we see where Swift goes, but my hope is it keeps the same basic feel.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift? <br>These language directions seem very consistent with Swift&#39;s direction.<br></p><p><br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I find languages with clear guidelines tend to be somewhat more ordered. I&#39;m definitely in favour of the a reference document that outlines standard practice, as it is beneficial both when teaching, and when reading people&#39;s code. Consistency breeds clarity, and these<br></p><p><br></p><p><br></p><p><br></p><p>&gt; On 31 Jan 2016, at 3:09 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; on Sat Jan 30 2016, Howard Lovatt &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I disagree that a property should imply O(1), this is an implementation<br>&gt;&gt; detail that might change.<br>&gt; <br>&gt; Not that I really want to argue this, as I am resigned to the fact that<br>&gt; we will not tie performance to property-ness, but...<br>&gt; <br>&gt; Efficiency characteristics are no mere implementation detail, at least<br>&gt; not in the standard library.  <br>&gt; <br>&gt;&gt; For example an array based collection will almost always have a count<br>&gt;&gt; property that is O(1),<br>&gt; <br>&gt; You can strike &quot;almost&quot; :-)<br>&gt; <br>&gt;&gt; but a liked-list based collection will almost always be O(N).<br>&gt; <br>&gt; It really depends on whether you allow O(1) splicing.  Without<br>&gt; supporting O(1) splicing, it&#39;s really easy for a linked list<br>&gt; to have an O(1) count.  And with cacheing, you can even arguably have an<br>&gt; amortized O(1) count.<br>&gt; <br>&gt; But even if a linked list has O(N) count, I don&#39;t see that what you&#39;re<br>&gt; describing indicates anything, by itself, about whether something being<br>&gt; a property should have performance implications.  There has to be an<br>&gt; underlying assumption that an Array&#39;s count must be a property, or<br>&gt; something else of that sort, in the background.<br>&gt; <br>&gt;&gt;&gt;&gt; On Friday, 29 January 2016, Michael Wells &lt;michael at michaelwells.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ,----[ Side Note, since you mentioned efficiency ]<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | I originally wanted to uphold the principle that, “if it isn&#39;t<br>&gt;&gt;&gt;&gt; O(1),<br>&gt;&gt;&gt;&gt;&gt;&gt; you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | don&#39;t make it a property.”  The implication is that on collections,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | “count” would be a method.  That would include Array, for which<br>&gt;&gt;&gt;&gt;&gt;&gt; counting<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | the elements *is* O(1).  Some people argued that:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | 1. The idea of writing “a.count()” instead of “a.count” to count<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |    elements of an Array was absurd.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | 2. Programmers don&#39;t draw conclusions about efficiency based on<br>&gt;&gt;&gt;&gt; whether<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |    something is a property.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | 3. The fact that Array would have an O(1) non-property that *could*<br>&gt;&gt;&gt;&gt;&gt;&gt; have<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |    been a property (if it weren&#39;t for CollectionType conformance)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |    undermines any communicative power that you might get from using<br>&gt;&gt;&gt;&gt;&gt;&gt; this<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |    distinction to choose properties.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; |<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; | I did not win that argument :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I strongly agree that properties imply O(1) and most programmers I’ve ever<br>&gt;&gt;&gt; worked with make the same assumptions. Even if the documentation says<br>&gt;&gt;&gt; otherwise, code like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; fibonacciNumbers.count<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; looks as if you’re accessing a c-style field ‘count’ and that implies (at<br>&gt;&gt;&gt; least to me) that it is a near-costless operation. Some of the biggest<br>&gt;&gt;&gt; design mistakes I’ve ever seen use properties that trigger time-consuming<br>&gt;&gt;&gt; operations like database or network access.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And I don’t think having to use a.count() is absurd. :-)<br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/f31becc7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>February  1, 2016 at 12:00:00am</p></header><div class="content"><p>My apologies. Mail failed and sent my review off early!<br></p><p>I can&#39;t believe I let it get this far before I began to post regarding these language proposals.<br></p><p>&gt; What is your evaluation of the proposal?<br>I like the proposal, and the direction it shows for Swift. I&#39;m particularly fond of the concise nature of the language.<br></p><p>I wonder specifically whether cases of ivars should be lower or upper case. I tend to think lower case makes more sense in the context of Swift, but I am personally fond of the upper camel case. Perhaps my eyes have just grown accustomed?<br></p><p>I am particularly in favour of the sort() vs sorted() verb vs noun. I definitely see the points raised and acknowledge that the subtleties of language mean there will always be exceptions to rules where it doesn&#39;t make sense, and I think the &quot;inPlace&quot; wording makes sense to fill this gap.<br></p><p>I&#39;m personally not a fan of the strong guidance to eliminate initial argument labels. I find this somewhat of a holdover from the awkward translation of Obj-C APIs, and I think there are cases where the initial parameter makes sense to be named. The login example, while it has its flaws, makes some sense here.<br></p><p>loginWithUsername(&quot;Rod&quot;, password: &quot;Password&quot;)<br>vs<br>login(username:&quot;Rod&quot;, password: &quot;Password&quot;)<br></p><p>Placing the WithUsername prior to the bracket implies that the username has more importance, at least to my eye. As has been discussed, it probably does have more importance, but I think it makes a fair point that there are cases where both arguments are simply peers that should be labeled without emphasis on the leading item. I think that naming each parameter for clarity makes sense in those cases, and this should be noted in documentation. <br></p><p>For all other elements, I am definitely in favour.<br></p><p><br>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>I definitely think the language benefits from guidance like this. I wonder whether we may need to come back and review this in a few years as we see where Swift goes, but my hope is it keeps the same basic feel.<br></p><p><br>&gt; Does this proposal fit well with the feel and direction of Swift? <br>These language directions seem very consistent with Swift&#39;s direction.<br></p><p><br>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I find languages with clear guidelines tend to be somewhat more ordered. I&#39;m definitely in favour of the a reference document that outlines standard practice, as it is beneficial both when teaching, and when reading people&#39;s code. Consistency breeds clarity, and these types of guides help consistency between developers.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/19748cf2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>February  1, 2016 at 01:00:00am</p></header><div class="content"><p>Just to clarify:<br></p><p>&quot;I wonder specifically whether cases of ivars should be lower or upper case.&quot;<br></p><p>Should have read:<br></p><p>&quot;I wonder specifically whether cases of enums should be lower or upper case.&quot;<br></p><p>Thanks autocorrect!<br></p><p><br>&gt; On 1 Feb 2016, at 12:56 AM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My apologies. Mail failed and sent my review off early!<br>&gt; <br>&gt; I can&#39;t believe I let it get this far before I began to post regarding these language proposals.<br>&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; I like the proposal, and the direction it shows for Swift. I&#39;m particularly fond of the concise nature of the language.<br>&gt; <br>&gt; I wonder specifically whether cases of ivars should be lower or upper case. I tend to think lower case makes more sense in the context of Swift, but I am personally fond of the upper camel case. Perhaps my eyes have just grown accustomed?<br>&gt; <br>&gt; I am particularly in favour of the sort() vs sorted() verb vs noun. I definitely see the points raised and acknowledge that the subtleties of language mean there will always be exceptions to rules where it doesn&#39;t make sense, and I think the &quot;inPlace&quot; wording makes sense to fill this gap.<br>&gt; <br>&gt; I&#39;m personally not a fan of the strong guidance to eliminate initial argument labels. I find this somewhat of a holdover from the awkward translation of Obj-C APIs, and I think there are cases where the initial parameter makes sense to be named. The login example, while it has its flaws, makes some sense here.<br>&gt; <br>&gt; loginWithUsername(&quot;Rod&quot;, password: &quot;Password&quot;)<br>&gt; vs<br>&gt; login(username:&quot;Rod&quot;, password: &quot;Password&quot;)<br>&gt; <br>&gt; Placing the WithUsername prior to the bracket implies that the username has more importance, at least to my eye. As has been discussed, it probably does have more importance, but I think it makes a fair point that there are cases where both arguments are simply peers that should be labeled without emphasis on the leading item. I think that naming each parameter for clarity makes sense in those cases, and this should be noted in documentation. <br>&gt; <br>&gt; For all other elements, I am definitely in favour.<br>&gt; <br>&gt; <br>&gt;&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; I definitely think the language benefits from guidance like this. I wonder whether we may need to come back and review this in a few years as we see where Swift goes, but my hope is it keeps the same basic feel.<br>&gt; <br>&gt; <br>&gt;&gt; Does this proposal fit well with the feel and direction of Swift? <br>&gt; These language directions seem very consistent with Swift&#39;s direction.<br>&gt; <br>&gt; <br>&gt;&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I find languages with clear guidelines tend to be somewhat more ordered. I&#39;m definitely in favour of the a reference document that outlines standard practice, as it is beneficial both when teaching, and when reading people&#39;s code. Consistency breeds clarity, and these types of guides help consistency between developers.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/bc908503/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 31, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; There has to be an<br>&gt; underlying assumption that an Array&#39;s count must be a property, or<br>&gt; something else of that sort, in the background.<br></p><p>You know, this would be a language change, but it occurs to me that, if a property could satisfy a protocol requirement for a parameterless method with no overloads, you *could* have an O(1) rule for properties. `Collection` would require a count() method, and `Array` would have a `count` property, and that would satisfy the requirement.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Review] SE-0023 API Design Guidelines (when to use properties)</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  1, 2016 at 03:00:00pm</p></header><div class="content"><p>On Sun, Jan 31, 2016 at 7:37 PM, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; There has to be an<br>&gt; &gt; underlying assumption that an Array&#39;s count must be a property, or<br>&gt; &gt; something else of that sort, in the background.<br>&gt;<br>&gt; You know, this would be a language change, but it occurs to me that, if a<br>&gt; property could satisfy a protocol requirement for a parameterless method<br>&gt; with no overloads, you *could* have an O(1) rule for properties.<br>&gt; `Collection` would require a count() method, and `Array` would have a<br>&gt; `count` property, and that would satisfy the requirement.<br>&gt;<br>&gt;<br>It seems like the unintended consequences of this could be really<br>confusing.  I think that most of us expect that replacing a concrete class<br>with a protocol that it conforms to will lead to the same semantics, at<br>least as long as we&#39;re only using the subset of functionality contained in<br>the protocol.  If properties and parameterless methods were<br>interchangeable, then you would have to refactor a lot of code from .count<br>to .count() when you changed an Array to a Collection.  And what happens if<br>&#39;count&#39; were, for the sake of argument, a function type?  Then .count() is<br>a perfectly legal expression that *calls* the property on an Array, but<br>*retrieves* the property on a Collection.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/c9e683e5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
