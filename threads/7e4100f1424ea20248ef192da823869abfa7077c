<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 22, 2016 at 06:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>Here is a partial list of the open topics that the core team would like to get resolved in Swift 3.  The list is partial both because I’m way behind on swift-evolution traffic, but also because new things may come up.  There are also a number of accepted proposals that are not yet implemented.  Some topics have proposals done, and therefore have an SE number, but the review discussion hasn’t finalized.  Some of these topics have an “owner” that is driving or planning to start a discussion on them them, which I’ve listed in square brackets. <br></p><p>If you’d like to discuss these topics in particular, please start a new thread specific to them, or contribute to an already-existing thread discussing it.  Several of these don’t have an owner yet, so if you’d like to pick them up and run with them, that would be great.  Thanks!<br></p><p>-Chris<br></p><p><br>Language:<br>- SE-0091: Improving operator requirements in protocols [Core team discussed this, will email about it shortly]<br>- SE-0077: Improve operator declaration syntax [Core team discussed this, Joe Groff will follow up on this soon]<br>- SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>- SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>- SE-0103: Invert @noescape<br>- Remove T -&gt; T? implicit promotion for operands to operators<br>- Removing argument labels from the type system (so they are declaration-only constructs)<br>- Some reshuffling with requiring @objc/@nonobjc for things that shouldn’t/can’t be expressed via the Objective-C runtime<br>- Eliminating inference of associated type witnesses (as is mentioned in the generics manifesto)<br>- Should public classes be non-publicly-subclassable by default? [John McCall]<br>- Revising access modifiers on extensions [Adrian Zubarev]<br></p><p><br>Standard library:<br> - SE-0101: Rename sizeof and related functions to comply with API Guidelines<br> - Ongoing API naming adjustments for stdlib:<br>    - Closure arguments [Dave Abrahams]<br>    - Others are being discussed on swift-evolution.<br> - Remove Boolean protocol.<br> - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br></p><p>SDK / Cocoa / ObjC interop:<br> - [SE-0086] Finalize NS removal plan. [Tony Parker]<br> - Importing “id” as Any [Joe Groff]<br> - Revise NSError/Error model for better interoperability and usability. [Doug Gregor]<br> - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 22, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, Jun 22, 2016 at 8:07 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; Here is a partial list of the open topics that the core team would like to<br>&gt; get resolved in Swift 3.  The list is partial both because I’m way behind<br>&gt; on swift-evolution traffic, but also because new things may come up.  There<br>&gt; are also a number of accepted proposals that are not yet implemented.  Some<br>&gt; topics have proposals done, and therefore have an SE number, but the review<br>&gt; discussion hasn’t finalized.  Some of these topics have an “owner” that is<br>&gt; driving or planning to start a discussion on them them, which I’ve listed<br>&gt; in square brackets.<br>&gt;<br>&gt; If you’d like to discuss these topics in particular, please start a new<br>&gt; thread specific to them, or contribute to an already-existing thread<br>&gt; discussing it.  Several of these don’t have an owner yet, so if you’d like<br>&gt; to pick them up and run with them, that would be great.  Thanks!<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Language:<br>&gt; - SE-0091: Improving operator requirements in protocols [Core team<br>&gt; discussed this, will email about it shortly]<br>&gt; - SE-0077: Improve operator declaration syntax [Core team discussed this,<br>&gt; Joe Groff will follow up on this soon]<br>&gt; - SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>&gt; - SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>&gt; - SE-0103: Invert @noescape<br>&gt; - Remove T -&gt; T? implicit promotion for operands to operators<br>&gt; - Removing argument labels from the type system (so they are<br>&gt; declaration-only constructs)<br>&gt; - Some reshuffling with requiring @objc/@nonobjc for things that<br>&gt; shouldn’t/can’t be expressed via the Objective-C runtime<br>&gt; - Eliminating inference of associated type witnesses (as is mentioned in<br>&gt; the generics manifesto)<br>&gt; - Should public classes be non-publicly-subclassable by default? [John<br>&gt; McCall]<br>&gt; - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt;<br>&gt;<br>&gt; Standard library:<br>&gt;  - SE-0101: Rename sizeof and related functions to comply with API<br>&gt; Guidelines<br>&gt;  - Ongoing API naming adjustments for stdlib:<br>&gt;     - Closure arguments [Dave Abrahams]<br>&gt;     - Others are being discussed on swift-evolution.<br>&gt;  - Remove Boolean protocol.<br>&gt;<br>^^^<br>What&#39;s the thinking behind this particular item?<br></p><p><br>&gt;  - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt;<br>&gt; SDK / Cocoa / ObjC interop:<br>&gt;  - [SE-0086] Finalize NS removal plan. [Tony Parker]<br>&gt;  - Importing “id” as Any [Joe Groff]<br>&gt;  - Revise NSError/Error model for better interoperability and usability.<br>&gt; [Doug Gregor]<br>&gt;  - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/d63f568a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 22, 2016 at 06:00:00pm</p></header><div class="content"><p>I&#39;d be happy to put together proposals for associated type inference<br>removal and removing type system significance from argument labels, if<br>nobody else wants them.<br></p><p>Austin<br></p><p>On Wed, Jun 22, 2016 at 6:16 PM, Xiaodi Wu via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; On Wed, Jun 22, 2016 at 8:07 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi everyone,<br>&gt;&gt;<br>&gt;&gt; Here is a partial list of the open topics that the core team would like<br>&gt;&gt; to get resolved in Swift 3.  The list is partial both because I’m way<br>&gt;&gt; behind on swift-evolution traffic, but also because new things may come<br>&gt;&gt; up.  There are also a number of accepted proposals that are not yet<br>&gt;&gt; implemented.  Some topics have proposals done, and therefore have an SE<br>&gt;&gt; number, but the review discussion hasn’t finalized.  Some of these topics<br>&gt;&gt; have an “owner” that is driving or planning to start a discussion on them<br>&gt;&gt; them, which I’ve listed in square brackets.<br>&gt;&gt;<br>&gt;&gt; If you’d like to discuss these topics in particular, please start a new<br>&gt;&gt; thread specific to them, or contribute to an already-existing thread<br>&gt;&gt; discussing it.  Several of these don’t have an owner yet, so if you’d like<br>&gt;&gt; to pick them up and run with them, that would be great.  Thanks!<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Language:<br>&gt;&gt; - SE-0091: Improving operator requirements in protocols [Core team<br>&gt;&gt; discussed this, will email about it shortly]<br>&gt;&gt; - SE-0077: Improve operator declaration syntax [Core team discussed this,<br>&gt;&gt; Joe Groff will follow up on this soon]<br>&gt;&gt; - SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>&gt;&gt; - SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>&gt;&gt; - SE-0103: Invert @noescape<br>&gt;&gt; - Remove T -&gt; T? implicit promotion for operands to operators<br>&gt;&gt; - Removing argument labels from the type system (so they are<br>&gt;&gt; declaration-only constructs)<br>&gt;&gt; - Some reshuffling with requiring @objc/@nonobjc for things that<br>&gt;&gt; shouldn’t/can’t be expressed via the Objective-C runtime<br>&gt;&gt; - Eliminating inference of associated type witnesses (as is mentioned in<br>&gt;&gt; the generics manifesto)<br>&gt;&gt; - Should public classes be non-publicly-subclassable by default? [John<br>&gt;&gt; McCall]<br>&gt;&gt; - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Standard library:<br>&gt;&gt;  - SE-0101: Rename sizeof and related functions to comply with API<br>&gt;&gt; Guidelines<br>&gt;&gt;  - Ongoing API naming adjustments for stdlib:<br>&gt;&gt;     - Closure arguments [Dave Abrahams]<br>&gt;&gt;     - Others are being discussed on swift-evolution.<br>&gt;&gt;  - Remove Boolean protocol.<br>&gt;&gt;<br>&gt; ^^^<br>&gt; What&#39;s the thinking behind this particular item?<br>&gt;<br>&gt;<br>&gt;&gt;  - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt;&gt;<br>&gt;&gt; SDK / Cocoa / ObjC interop:<br>&gt;&gt;  - [SE-0086] Finalize NS removal plan. [Tony Parker]<br>&gt;&gt;  - Importing “id” as Any [Joe Groff]<br>&gt;&gt;  - Revise NSError/Error model for better interoperability and usability.<br>&gt;&gt; [Doug Gregor]<br>&gt;&gt;  - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160622/bec840e4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 22, 2016 at 07:00:00pm</p></header><div class="content"><p>On Jun 22, 2016, at 6:16 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;  - Remove Boolean protocol.<br>&gt; ^^^<br>&gt; What&#39;s the thinking behind this particular item?<br>&gt;  <br></p><p>“Boolean” isn’t pulling its weight:<br>- It only abstracts over Bool and ObjCBool.<br>- It only enables a few operations on ObjCBool, which are not very important.<br>- ObjCBool is a bridging problem, and we don’t handle bridging by introducing common protocols (e.g. in the case of String vs NSString, we don’t introduce a common “Stringable” protocol.<br></p><p>Further, it complicates the model:<br> - People are confused by it and the similar but very different Bool type.<br> - Bool is a simple enough concept to not need a family of protocols.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 23, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; - Bool is a simple enough concept to not need a family of protocols.<br></p><p>Literally, the most fundamental concept.<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 23, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br></p><p>I don’t think I can handle writing a proposal for this one, but I’d die for it.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 22, 2016, at 11:48 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt; <br>&gt; I don’t think I can handle writing a proposal for this one, but I’d die for it.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>Will this work the way people expect, especially given how NSString handles unicode vs Swift String and the various views? My suspicion is at least a chunk of the things people imagine doing with the bridged NSRange won’t actually work and they’ll be sad.<br></p><p>Russ<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 00:57, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 11:48 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt; <br>&gt;&gt; I don’t think I can handle writing a proposal for this one, but I’d die for it.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Will this work the way people expect, especially given how NSString handles unicode vs Swift String and the various views? My suspicion is at least a chunk of the things people imagine doing with the bridged NSRange won’t actually work and they’ll be sad.<br>&gt; <br>&gt; Russ<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>This is a good point. I asked @CC Tony Parker recently about doing the conversion inside Foundation and just exposing Range&lt;String.Index&gt; directly. <br></p><p>Basically everybody who uses those Foundation methods which return an NSRange for strings needs to write their own conversion functions anyway, and less-experienced developers might not get the UTF-16 thing correct. That’s something we should be handling for them; it’s an implementation detail of the underlying CoreFoundation APIs.<br></p><p>Karl<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 3:57 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 11:48 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt; <br>&gt;&gt; I don’t think I can handle writing a proposal for this one, but I’d die for it.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; Will this work the way people expect, especially given how NSString handles unicode vs Swift String and the various views? My suspicion is at least a chunk of the things people imagine doing with the bridged NSRange won’t actually work and they’ll be sad.<br></p><p><br>I’ll try to elaborate on the issues:<br></p><p>1) NSRange could be mapped to Range&lt;Int&gt;. This would involve executing bridging code (much like we do for String &lt;-&gt; NSString or Bool &lt;-&gt; BOOL), because NSRange’s location + length representation is different from Range’s lowerBound/upperBound.<br>2) Some NSRanges use location == NSNotFound to indicate “no value”. We would want to bridge these NSRanges to a Range&lt;Int&gt;?, where we location == NSNotFound maps to nil. We cannot guess whether the range treats NSNotFound as special from the API: we’ll need some kind of annotation (e.g., via some kind of Objective-C attribute) that indicates that we should be mapping to an optional value as well as how to identify the nil value. That attribute would then have to be applied to popular APIs.<br>3) When the NSRange is describing indices into a String, we’d need some kind of Objective-C attribute to say that these are indices and (possibly?) point to which NSString* they reference (although the latter is not strictly necessary in the new collection indexing model), so that NSRange can be mapped to Range&lt;String.Index&gt; or Range&lt;String.Index&gt;? (so it needs to compose with #2). That attribute would then have to be applied to popular APIs.<br>4) Similar to #3, we should do the same thing for NSIntegers that represent locations in a String, so those NSIntegers can get mapped to String.Index. There are likely conventions that would map to String.Index? as well, so this also calls for a generalization of #2. That attribute would then have to be applied to popular APIs..<br></p><p>Although this is on my personal list of things that would be great to clean up for Cocoa, it doesn’t seem feasible for Swift 3 to get it designed, implemented, and rolled out to enough APIs .<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 30, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 28 Jun 2016, at 18:29, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 26, 2016, at 3:57 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 22, 2016, at 11:48 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think I can handle writing a proposal for this one, but I’d die for it.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; Will this work the way people expect, especially given how NSString handles unicode vs Swift String and the various views? My suspicion is at least a chunk of the things people imagine doing with the bridged NSRange won’t actually work and they’ll be sad.<br>&gt; <br>&gt; <br>&gt; I’ll try to elaborate on the issues:<br>&gt; <br>&gt; 1) NSRange could be mapped to Range&lt;Int&gt;. This would involve executing bridging code (much like we do for String &lt;-&gt; NSString or Bool &lt;-&gt; BOOL), because NSRange’s location + length representation is different from Range’s lowerBound/upperBound.<br>&gt; 2) Some NSRanges use location == NSNotFound to indicate “no value”. We would want to bridge these NSRanges to a Range&lt;Int&gt;?, where we location == NSNotFound maps to nil. We cannot guess whether the range treats NSNotFound as special from the API: we’ll need some kind of annotation (e.g., via some kind of Objective-C attribute) that indicates that we should be mapping to an optional value as well as how to identify the nil value. That attribute would then have to be applied to popular APIs.<br>&gt; 3) When the NSRange is describing indices into a String, we’d need some kind of Objective-C attribute to say that these are indices and (possibly?) point to which NSString* they reference (although the latter is not strictly necessary in the new collection indexing model), so that NSRange can be mapped to Range&lt;String.Index&gt; or Range&lt;String.Index&gt;? (so it needs to compose with #2). That attribute would then have to be applied to popular APIs.<br>&gt; 4) Similar to #3, we should do the same thing for NSIntegers that represent locations in a String, so those NSIntegers can get mapped to String.Index. There are likely conventions that would map to String.Index? as well, so this also calls for a generalization of #2. That attribute would then have to be applied to popular APIs..<br>&gt; <br>&gt; Although this is on my personal list of things that would be great to clean up for Cocoa, it doesn’t seem feasible for Swift 3 to get it designed, implemented, and rolled out to enough APIs .<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>Would it not be possible to replace NSRange with Range&lt;String.Index&gt; on the API surface area we control right now (I.e Foundation)? Foundation could also an extension on String which converts Range&lt;String.Index&gt; &lt;-&gt; NSRange so you can do explicit “bridging&quot;, since NSRange is a Foundation type. That’s what it currently does for NSRange&lt;Int&gt;?.<br></p><p>It would make life much easier for people only in Swift, and at the boundary with Obj-C — okay, it’s not really bridging as such, but is it really any more or less convenient to call a method than to perform an “as” cast? You might argue that it’s even more convenient to call a method, since you get code-completion telling you which Obj-C types you can bridge to (and possibly explaining why it’s unexpectedly an optional).<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/a07b644f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>June 24, 2016 at 11:00:00am</p></header><div class="content"><p>Way back when, there was an unresolved discussion was about whether it’s a bug or a feature that $0 sometimes captures a single arg and sometimes captures all args as a tuple:<br></p><p>    http://thread.gmane.org/gmane.comp.lang.swift.evolution/3915/<br>    https://bugs.swift.org/browse/SR-586<br></p><p>I mention this because it would be a breaking change to make $0 consistently capture the first arg, and I wonder whether that should be in the Swift 3?<br></p><p>(If anybody wants to comment on the question, I recommend catching up on the discussion in the links above first.)<br></p><p>Cheers, P<br></p><p><br>&gt; On Jun 22, 2016, at 8:07 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; Here is a partial list of the open topics that the core team would like to get resolved in Swift 3.  The list is partial both because I’m way behind on swift-evolution traffic, but also because new things may come up.  There are also a number of accepted proposals that are not yet implemented.  Some topics have proposals done, and therefore have an SE number, but the review discussion hasn’t finalized.  Some of these topics have an “owner” that is driving or planning to start a discussion on them them, which I’ve listed in square brackets. <br>&gt; <br>&gt; If you’d like to discuss these topics in particular, please start a new thread specific to them, or contribute to an already-existing thread discussing it.  Several of these don’t have an owner yet, so if you’d like to pick them up and run with them, that would be great.  Thanks!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Language:<br>&gt; - SE-0091: Improving operator requirements in protocols [Core team discussed this, will email about it shortly]<br>&gt; - SE-0077: Improve operator declaration syntax [Core team discussed this, Joe Groff will follow up on this soon]<br>&gt; - SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>&gt; - SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>&gt; - SE-0103: Invert @noescape<br>&gt; - Remove T -&gt; T? implicit promotion for operands to operators<br>&gt; - Removing argument labels from the type system (so they are declaration-only constructs)<br>&gt; - Some reshuffling with requiring @objc/@nonobjc for things that shouldn’t/can’t be expressed via the Objective-C runtime<br>&gt; - Eliminating inference of associated type witnesses (as is mentioned in the generics manifesto)<br>&gt; - Should public classes be non-publicly-subclassable by default? [John McCall]<br>&gt; - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt; <br>&gt; <br>&gt; Standard library:<br>&gt; - SE-0101: Rename sizeof and related functions to comply with API Guidelines<br>&gt; - Ongoing API naming adjustments for stdlib:<br>&gt;    - Closure arguments [Dave Abrahams]<br>&gt;    - Others are being discussed on swift-evolution.<br>&gt; - Remove Boolean protocol.<br>&gt; - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt; <br>&gt; SDK / Cocoa / ObjC interop:<br>&gt; - [SE-0086] Finalize NS removal plan. [Tony Parker]<br>&gt; - Importing “id” as Any [Joe Groff]<br>&gt; - Revise NSError/Error model for better interoperability and usability. [Doug Gregor]<br>&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 24, 2016 at 07:00:00pm</p></header><div class="content"><p>On 24.06.2016 19:22, Paul Cantrell via swift-evolution wrote:<br>&gt; Way back when, there was an unresolved discussion was about whether it’s<br>&gt; a bug or a feature that $0 sometimes captures a single arg and sometimes<br>&gt; captures all args as a tuple:<br></p><p>Just recently I started a new thread for that subject : &quot;[Discussion] <br>func/closure parameters and tuples&quot; but no replies for it yet. Was planing <br>to start the proposal thread.<br></p><p>I believe we should add consistency in Swift regarding allowed arguments of <br>closure/func.<br>Dropped questions regarding this here:<br>https://bugs.swift.org/browse/SR-1334<br>https://bugs.swift.org/browse/SR-1854<br></p><p>So I&#39;ll repeat questions/issues here in one place:<br></p><p>1. I was not expecting this will compile :<br></p><p>let ft1 : (Int,Int) -&gt; Void = { x in print(x.0, x.1)}<br></p><p>ft1(1, 2)<br></p><p>the type of ft1 is definitely not the same as closure<br></p><p><br>2. The same. But this crashes compiler at compile time(bug is reported) :<br></p><p>let ft2 : (Int,Int) -&gt; Void = { x in print(x) }<br></p><p>ft2(1, 2)<br></p><p>3. Was expecting closure will require a single argument, which is tuple; <br>but it accepts even just x, y<br></p><p>typealias IntInt = (Int,Int)<br></p><p>func foo(block: (IntInt) -&gt; Void) {<br>     let z : IntInt = (1,2)<br>     block(z)<br>}<br></p><p>foo { x in print(x)} // ok<br>foo { x, y in print(x,y)}<br>foo { (x, y) in print(x, y)}<br></p><p>I&#39;m not sending two values to closure, I send one instance which is tuple.<br></p><p><br>4.<br></p><p>typealias BinaryIntOp_v1 = (Int, Int) -&gt; Int<br>typealias BinaryIntOp_v2 = ((Int, Int)) -&gt; Int<br></p><p>print(BinaryIntOp_v2.self) // Prints ((Int, Int)) -&gt; Int  why?<br>print(BinaryIntOp_v2.self) // Prints ((Int, Int)) -&gt; Int<br></p><p>let areRepresentingTheSameType = BinaryIntOp_v1.self == BinaryIntOp_v2.self <br>// (alt-click the &quot;==&quot; and read doc.)<br>print(areRepresentingTheSameType) // Prints true<br></p><p>let add_v1: BinaryIntOp_v1 = (+)<br>let add_v2: BinaryIntOp_v2 = (+) // Or both could have been eg: { return $0 <br>+ $1 }<br></p><p>let ra = add_v1(1, 2)<br>let rb = add_v2((1, 2)) // NOTE: Needs these extra parens (otherwise error: <br>&quot;Extra argument in call&quot;)<br></p><p>let rc = (add_v1 as BinaryIntOp_v2)((1, 2)) // NOTE: I am type casting <br>these to an identical type ...<br>let rd = (add_v2 as BinaryIntOp_v1)(1, 2)   // ... in order to swap which <br>one of them need extra parens ...<br></p><p>&gt;<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/3915/<br>&gt; https://bugs.swift.org/browse/SR-586<br>&gt;<br>&gt; I mention this because it would be a breaking change to make $0<br>&gt; consistently capture the first arg, and I wonder whether that should be<br>&gt; in the Swift 3?<br>&gt;<br>&gt; (If anybody wants to comment on the question, I recommend catching up on<br>&gt; the discussion in the links above first.)<br>&gt;<br>&gt; Cheers, P<br>&gt;<br>&gt;<br>&gt;&gt; On Jun 22, 2016, at 8:07 PM, Chris Lattner via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Hi everyone,<br>&gt;&gt;<br>&gt;&gt; Here is a partial list of the open topics that the core team would<br>&gt;&gt; like to get resolved in Swift 3.  The list is partial both because I’m<br>&gt;&gt; way behind on swift-evolution traffic, but also because new things may<br>&gt;&gt; come up.  There are also a number of accepted proposals that are not<br>&gt;&gt; yet implemented.  Some topics have proposals done, and therefore have<br>&gt;&gt; an SE number, but the review discussion hasn’t finalized.  Some of<br>&gt;&gt; these topics have an “owner” that is driving or planning to start a<br>&gt;&gt; discussion on them them, which I’ve listed in square brackets.<br>&gt;&gt;<br>&gt;&gt; If you’d like to discuss these topics in particular, please start a<br>&gt;&gt; new thread specific to them, or contribute to an already-existing<br>&gt;&gt; thread discussing it.  Several of these don’t have an owner yet, so if<br>&gt;&gt; you’d like to pick them up and run with them, that would be great.<br>&gt;&gt; Thanks!<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Language: - SE-0091: Improving operator requirements in protocols<br>&gt;&gt; [Core team discussed this, will email about it shortly] - SE-0077:<br>&gt;&gt; Improve operator declaration syntax [Core team discussed this, Joe<br>&gt;&gt; Groff will follow up on this soon] - SE-0095: Replace protocol&lt;P1,P2&gt;<br>&gt;&gt; syntax with P1 &amp; P2 syntax - SE-0102: Remove @noreturn attribute and<br>&gt;&gt; introduce an empty NoReturn type - SE-0103: Invert @noescape - Remove<br>&gt;&gt; T -&gt; T? implicit promotion for operands to operators - Removing<br>&gt;&gt; argument labels from the type system (so they are declaration-only<br>&gt;&gt; constructs) - Some reshuffling with requiring @objc/@nonobjc for<br>&gt;&gt; things that shouldn’t/can’t be expressed via the Objective-C runtime -<br>&gt;&gt; Eliminating inference of associated type witnesses (as is mentioned in<br>&gt;&gt; the generics manifesto) - Should public classes be<br>&gt;&gt; non-publicly-subclassable by default? [John McCall] - Revising access<br>&gt;&gt; modifiers on extensions [Adrian Zubarev]<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Standard library: - SE-0101: Rename sizeof and related functions to<br>&gt;&gt; comply with API Guidelines - Ongoing API naming adjustments for<br>&gt;&gt; stdlib: - Closure arguments [Dave Abrahams] - Others are being<br>&gt;&gt; discussed on swift-evolution. - Remove Boolean protocol. - SE-0104:<br>&gt;&gt; Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt;&gt;<br>&gt;&gt; SDK / Cocoa / ObjC interop: - [SE-0086] Finalize NS removal plan.<br>&gt;&gt; [Tony Parker] - Importing “id” as Any [Joe Groff] - Revise<br>&gt;&gt; NSError/Error model for better interoperability and usability. [Doug<br>&gt;&gt; Gregor] - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 9:22 AM, Paul Cantrell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Way back when, there was an unresolved discussion was about whether it’s a bug or a feature that $0 sometimes captures a single arg and sometimes captures all args as a tuple:<br>&gt; <br>&gt;    http://thread.gmane.org/gmane.comp.lang.swift.evolution/3915/<br>&gt;    https://bugs.swift.org/browse/SR-586<br>&gt; <br>&gt; I mention this because it would be a breaking change to make $0 consistently capture the first arg, and I wonder whether that should be in the Swift 3?<br>&gt; <br>&gt; (If anybody wants to comment on the question, I recommend catching up on the discussion in the links above first.)<br></p><p>I consider this a bug. The removal of implicit tuple splats should, IMO, encompass making $0 consistently capture the first argument. I’d love for this to happen in Swift 3.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Cheers, P<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 22, 2016, at 8:07 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone,<br>&gt;&gt; <br>&gt;&gt; Here is a partial list of the open topics that the core team would like to get resolved in Swift 3.  The list is partial both because I’m way behind on swift-evolution traffic, but also because new things may come up.  There are also a number of accepted proposals that are not yet implemented.  Some topics have proposals done, and therefore have an SE number, but the review discussion hasn’t finalized.  Some of these topics have an “owner” that is driving or planning to start a discussion on them them, which I’ve listed in square brackets. <br>&gt;&gt; <br>&gt;&gt; If you’d like to discuss these topics in particular, please start a new thread specific to them, or contribute to an already-existing thread discussing it.  Several of these don’t have an owner yet, so if you’d like to pick them up and run with them, that would be great.  Thanks!<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Language:<br>&gt;&gt; - SE-0091: Improving operator requirements in protocols [Core team discussed this, will email about it shortly]<br>&gt;&gt; - SE-0077: Improve operator declaration syntax [Core team discussed this, Joe Groff will follow up on this soon]<br>&gt;&gt; - SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>&gt;&gt; - SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>&gt;&gt; - SE-0103: Invert @noescape<br>&gt;&gt; - Remove T -&gt; T? implicit promotion for operands to operators<br>&gt;&gt; - Removing argument labels from the type system (so they are declaration-only constructs)<br>&gt;&gt; - Some reshuffling with requiring @objc/@nonobjc for things that shouldn’t/can’t be expressed via the Objective-C runtime<br>&gt;&gt; - Eliminating inference of associated type witnesses (as is mentioned in the generics manifesto)<br>&gt;&gt; - Should public classes be non-publicly-subclassable by default? [John McCall]<br>&gt;&gt; - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Standard library:<br>&gt;&gt; - SE-0101: Rename sizeof and related functions to comply with API Guidelines<br>&gt;&gt; - Ongoing API naming adjustments for stdlib:<br>&gt;&gt;   - Closure arguments [Dave Abrahams]<br>&gt;&gt;   - Others are being discussed on swift-evolution.<br>&gt;&gt; - Remove Boolean protocol.<br>&gt;&gt; - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt;&gt; <br>&gt;&gt; SDK / Cocoa / ObjC interop:<br>&gt;&gt; - [SE-0086] Finalize NS removal plan. [Tony Parker]<br>&gt;&gt; - Importing “id” as Any [Joe Groff]<br>&gt;&gt; - Revise NSError/Error model for better interoperability and usability. [Doug Gregor]<br>&gt;&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 28, 2016 at 07:00:00pm</p></header><div class="content"><p>On 28.06.2016 18:55, Douglas Gregor via swift-evolution wrote:<br>&gt;<br>&gt;&gt; On Jun 24, 2016, at 9:22 AM, Paul Cantrell via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Way back when, there was an unresolved discussion was about whether<br>&gt;&gt; it’s a bug or a feature that $0 sometimes captures a single arg and<br>&gt;&gt; sometimes captures all args as a tuple:<br>&gt;&gt;<br>&gt;&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/3915/<br>&gt;&gt; https://bugs.swift.org/browse/SR-586<br>&gt;&gt;<br>&gt;&gt; I mention this because it would be a breaking change to make $0<br>&gt;&gt; consistently capture the first arg, and I wonder whether that should<br>&gt;&gt; be in the Swift 3?<br>&gt;&gt;<br>&gt;&gt; (If anybody wants to comment on the question, I recommend catching up<br>&gt;&gt; on the discussion in the links above first.)<br>&gt;<br>&gt; I consider this a bug. The removal of implicit tuple splats should, IMO,<br>&gt; encompass making $0 consistently capture the first argument. I’d love<br>&gt; for this to happen in Swift 3.<br></p><p>Doug, could you please comment this related thread in mailing list: <br>&quot;[Proposal] Disallow<br>implicit conversion between function/closure with a list of parameters and<br>with tuple parameter. Remove function type inconsistency.&quot;<br></p><p>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;&gt;<br>&gt;&gt; Cheers, P<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 22, 2016, at 8:07 PM, Chris Lattner via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi everyone,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is a partial list of the open topics that the core team would<br>&gt;&gt;&gt; like to get resolved in Swift 3.  The list is partial both because<br>&gt;&gt;&gt; I’m way behind on swift-evolution traffic, but also because new<br>&gt;&gt;&gt; things may come up.  There are also a number of accepted proposals<br>&gt;&gt;&gt; that are not yet implemented.  Some topics have proposals done, and<br>&gt;&gt;&gt; therefore have an SE number, but the review discussion hasn’t<br>&gt;&gt;&gt; finalized.  Some of these topics have an “owner” that is driving or<br>&gt;&gt;&gt; planning to start a discussion on them them, which I’ve listed in<br>&gt;&gt;&gt; square brackets.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If you’d like to discuss these topics in particular, please start a<br>&gt;&gt;&gt; new thread specific to them, or contribute to an already-existing<br>&gt;&gt;&gt; thread discussing it.  Several of these don’t have an owner yet, so<br>&gt;&gt;&gt; if you’d like to pick them up and run with them, that would be<br>&gt;&gt;&gt; great.  Thanks!<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Language: - SE-0091: Improving operator requirements in protocols<br>&gt;&gt;&gt; [Core team discussed this, will email about it shortly] - SE-0077:<br>&gt;&gt;&gt; Improve operator declaration syntax [Core team discussed this, Joe<br>&gt;&gt;&gt; Groff will follow up on this soon] - SE-0095: Replace<br>&gt;&gt;&gt; protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax - SE-0102: Remove<br>&gt;&gt;&gt; @noreturn attribute and introduce an empty NoReturn type - SE-0103:<br>&gt;&gt;&gt; Invert @noescape - Remove T -&gt; T? implicit promotion for operands to<br>&gt;&gt;&gt; operators - Removing argument labels from the type system (so they<br>&gt;&gt;&gt; are declaration-only constructs) - Some reshuffling with requiring<br>&gt;&gt;&gt; @objc/@nonobjc for things that shouldn’t/can’t be expressed via the<br>&gt;&gt;&gt; Objective-C runtime - Eliminating inference of associated type<br>&gt;&gt;&gt; witnesses (as is mentioned in the generics manifesto) - Should<br>&gt;&gt;&gt; public classes be non-publicly-subclassable by default? [John<br>&gt;&gt;&gt; McCall] - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Standard library: - SE-0101: Rename sizeof and related functions to<br>&gt;&gt;&gt; comply with API Guidelines - Ongoing API naming adjustments for<br>&gt;&gt;&gt; stdlib: - Closure arguments [Dave Abrahams] - Others are being<br>&gt;&gt;&gt; discussed on swift-evolution. - Remove Boolean protocol. - SE-0104:<br>&gt;&gt;&gt; Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; SDK / Cocoa / ObjC interop: - [SE-0086] Finalize NS removal plan.<br>&gt;&gt;&gt; [Tony Parker] - Importing “id” as Any [Joe Groff] - Revise<br>&gt;&gt;&gt; NSError/Error model for better interoperability and usability. [Doug<br>&gt;&gt;&gt; Gregor] - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________ swift-evolution<br>&gt;&gt; mailing list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 24, 2016 at 11:00:00pm</p></header><div class="content"><p>Would you be willing to elaborate a bit on &quot;Removing argument labels from the type system&quot;? The bulk of this went away when tuple splatting was removed, and values of function type already seem to ignore the labels of the functions they are assigned.<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 22, 2016, at 6:07 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; Here is a partial list of the open topics that the core team would like to get resolved in Swift 3.  The list is partial both because I’m way behind on swift-evolution traffic, but also because new things may come up.  There are also a number of accepted proposals that are not yet implemented.  Some topics have proposals done, and therefore have an SE number, but the review discussion hasn’t finalized.  Some of these topics have an “owner” that is driving or planning to start a discussion on them them, which I’ve listed in square brackets. <br>&gt; <br>&gt; If you’d like to discuss these topics in particular, please start a new thread specific to them, or contribute to an already-existing thread discussing it.  Several of these don’t have an owner yet, so if you’d like to pick them up and run with them, that would be great.  Thanks!<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; Language:<br>&gt; - SE-0091: Improving operator requirements in protocols [Core team discussed this, will email about it shortly]<br>&gt; - SE-0077: Improve operator declaration syntax [Core team discussed this, Joe Groff will follow up on this soon]<br>&gt; - SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>&gt; - SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>&gt; - SE-0103: Invert @noescape<br>&gt; - Remove T -&gt; T? implicit promotion for operands to operators<br>&gt; - Removing argument labels from the type system (so they are declaration-only constructs)<br>&gt; - Some reshuffling with requiring @objc/@nonobjc for things that shouldn’t/can’t be expressed via the Objective-C runtime<br>&gt; - Eliminating inference of associated type witnesses (as is mentioned in the generics manifesto)<br>&gt; - Should public classes be non-publicly-subclassable by default? [John McCall]<br>&gt; - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt; <br>&gt; <br>&gt; Standard library:<br>&gt; - SE-0101: Rename sizeof and related functions to comply with API Guidelines<br>&gt; - Ongoing API naming adjustments for stdlib:<br>&gt;    - Closure arguments [Dave Abrahams]<br>&gt;    - Others are being discussed on swift-evolution.<br>&gt; - Remove Boolean protocol.<br>&gt; - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt; <br>&gt; SDK / Cocoa / ObjC interop:<br>&gt; - [SE-0086] Finalize NS removal plan. [Tony Parker]<br>&gt; - Importing “id” as Any [Joe Groff]<br>&gt; - Revise NSError/Error model for better interoperability and usability. [Doug Gregor]<br>&gt; - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 24, 2016, at 11:30 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Would you be willing to elaborate a bit on &quot;Removing argument labels from the type system&quot;? The bulk of this went away when tuple splatting was removed, and values of function type already seem to ignore the labels of the functions they are assigned.<br></p><p>This came from a short list of topics Doug provided me, but the basic issue is that:<br></p><p>func f(a : Int, b : Int) {<br>  let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>}<br></p><p>I’m not exactly sure what the counterproposal is.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; This came from a short list of topics Doug provided me, but the basic issue is that:<br>&gt; <br>&gt; func f(a : Int, b : Int) {<br>&gt;  let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>&gt; }<br>&gt; <br>&gt; I’m not exactly sure what the counterproposal is.<br></p><p>My guess is to require let x = f(a:,b:) (specifying arguments)?<br></p><p>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>I think the point is to get rid of the argument labels. &#39;x&#39; should be typed simply (Int, Int) -&gt; ().<br></p><p>That being said, right now the argument labels in the type don&#39;t seem to actually affect anything, so like Chris I&#39;m not sure what the counter-proposal is.<br></p><p>(cc. Doug)<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt;&gt; This came from a short list of topics Doug provided me, but the basic issue is that:<br>&gt;&gt; <br>&gt;&gt; func f(a : Int, b : Int) {<br>&gt;&gt; let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt; <br>&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>Oh, I see. The issue is then the following:<br></p><p>let x = f<br>x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br></p><p>let y: (Int, Int) -&gt; () = f<br>f(1, 2) // OK<br></p><p>Which requires you to write x(a: 1, b: 2). I must admit, however, that I always liked this behavior...<br></p><p>&gt; On Jun 28, 2016, at 7:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think the point is to get rid of the argument labels. &#39;x&#39; should be typed simply (Int, Int) -&gt; ().<br>&gt; <br>&gt; That being said, right now the argument labels in the type don&#39;t seem to actually affect anything, so like Chris I&#39;m not sure what the counter-proposal is.<br>&gt; <br>&gt; (cc. Doug)<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This came from a short list of topics Doug provided me, but the basic issue is that:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func f(a : Int, b : Int) {<br>&gt;&gt;&gt; let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt;&gt; <br>&gt;&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 10:40 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Oh, I see. The issue is then the following:<br>&gt; <br>&gt; let x = f<br>&gt; x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br>&gt; <br>&gt; let y: (Int, Int) -&gt; () = f<br>&gt; f(1, 2) // OK<br>&gt; <br>&gt; Which requires you to write x(a: 1, b: 2). I must admit, however, that I always liked this behavior…<br></p><p>Right, that’s the issue. The idea behind this is that it’s a simplification to the type system to eliminate argument labels from types, so we can eliminate some extra subtyping relationships (e.g., between function types with labels and ones without labels). Essentially, argument labels become part of the names of declarations (only!), which is consistent with our view that the names of functions/methods/initializers include all of the argument names.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt;&gt; On Jun 28, 2016, at 7:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think the point is to get rid of the argument labels. &#39;x&#39; should be typed simply (Int, Int) -&gt; ().<br>&gt;&gt; <br>&gt;&gt; That being said, right now the argument labels in the type don&#39;t seem to actually affect anything, so like Chris I&#39;m not sure what the counter-proposal is.<br>&gt;&gt; <br>&gt;&gt; (cc. Doug)<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This came from a short list of topics Doug provided me, but the basic issue is that:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func f(a : Int, b : Int) {<br>&gt;&gt;&gt;&gt; let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 28, 2016 at 09:00:00am</p></header><div class="content"><p>This makes sense. If nobody objects I&#39;ll prepare a proposal today. <br></p><p>By the way, on the topic of design topics: is there any core team support for removing associated type inference? I have a proposal there that I would like to move into the formal review stage at some point. <br></p><p>Best,<br>Austin<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jun 28, 2016, at 9:33 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 10:40 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oh, I see. The issue is then the following:<br>&gt;&gt; <br>&gt;&gt; let x = f<br>&gt;&gt; x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br>&gt;&gt; <br>&gt;&gt; let y: (Int, Int) -&gt; () = f<br>&gt;&gt; f(1, 2) // OK<br>&gt;&gt; <br>&gt;&gt; Which requires you to write x(a: 1, b: 2). I must admit, however, that I always liked this behavior…<br>&gt; <br>&gt; Right, that’s the issue. The idea behind this is that it’s a simplification to the type system to eliminate argument labels from types, so we can eliminate some extra subtyping relationships (e.g., between function types with labels and ones without labels). Essentially, argument labels become part of the names of declarations (only!), which is consistent with our view that the names of functions/methods/initializers include all of the argument names.<br>&gt; <br>&gt;    - Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 28, 2016, at 7:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the point is to get rid of the argument labels. &#39;x&#39; should be typed simply (Int, Int) -&gt; ().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That being said, right now the argument labels in the type don&#39;t seem to actually affect anything, so like Chris I&#39;m not sure what the counter-proposal is.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (cc. Doug)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This came from a short list of topics Doug provided me, but the basic issue is that:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func f(a : Int, b : Int) {<br>&gt;&gt;&gt;&gt;&gt; let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>On 28.06.2016 19:49, Austin Zheng via swift-evolution wrote:<br>&gt; This makes sense. If nobody objects I&#39;ll prepare a proposal today.<br></p><p>Austin, I&#39;d ask to review this related(about function/closure type) thread<br>in mailing list before preparing the proposal: &quot;[Proposal] Disallow<br>implicit conversion between function/closure with a list of parameters and<br>with tuple parameter. Remove function type inconsistency.&quot;<br></p><p>I mean probably you&#39;ll want to form a more generic proposal to improve/make <br>less surprising Swift&#39;s function types and add consistency in this area. <br>I&#39;d be happy if you&#39;ll add ideas from the thread mentioned above to your <br>proposal.<br></p><p>&gt;<br>&gt; By the way, on the topic of design topics: is there any core team<br>&gt; support for removing associated type inference? I have a proposal there<br>&gt; that I would like to move into the formal review stage at some point.<br>&gt;<br>&gt; Best, Austin<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt;&gt; On Jun 28, 2016, at 9:33 AM, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On Jun 27, 2016, at 10:40 PM, Charlie Monroe<br>&gt;&gt;&gt; &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Oh, I see. The issue is then the following:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = f x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let y: (Int, Int) -&gt; () = f f(1, 2) // OK<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Which requires you to write x(a: 1, b: 2). I must admit, however,<br>&gt;&gt;&gt; that I always liked this behavior…<br>&gt;&gt;<br>&gt;&gt; Right, that’s the issue. The idea behind this is that it’s a<br>&gt;&gt; simplification to the type system to eliminate argument labels from<br>&gt;&gt; types, so we can eliminate some extra subtyping relationships (e.g.,<br>&gt;&gt; between function types with labels and ones without labels).<br>&gt;&gt; Essentially, argument labels become part of the names of declarations<br>&gt;&gt; (only!), which is consistent with our view that the names of<br>&gt;&gt; functions/methods/initializers include all of the argument names.<br>&gt;&gt;<br>&gt;&gt; - Doug<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 7:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think the point is to get rid of the argument labels. &#39;x&#39; should<br>&gt;&gt;&gt;&gt; be typed simply (Int, Int) -&gt; ().<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; That being said, right now the argument labels in the type don&#39;t<br>&gt;&gt;&gt;&gt; seem to actually affect anything, so like Chris I&#39;m not sure what<br>&gt;&gt;&gt;&gt; the counter-proposal is.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (cc. Doug)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; This came from a short list of topics Doug provided me, but<br>&gt;&gt;&gt;&gt;&gt;&gt; the basic issue is that:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func f(a : Int, b : Int) { let x = f   // x has type (a: Int,<br>&gt;&gt;&gt;&gt;&gt;&gt; b: Int) -&gt; () }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>Hi Vladmir,<br></p><p>I read your thread earlier and thought you raised some really good points.<br>Are you planning on preparing a proposal? If not, I&#39;d be happy to fold your<br>ideas in to make one big proposal. If you are already preparing one, you<br>should just fold Doug&#39;s point into your proposal.<br></p><p>Best,<br>Austin<br></p><p>On Tue, Jun 28, 2016 at 10:30 AM, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; On 28.06.2016 19:49, Austin Zheng via swift-evolution wrote:<br>&gt;<br>&gt;&gt; This makes sense. If nobody objects I&#39;ll prepare a proposal today.<br>&gt;&gt;<br>&gt;<br>&gt; Austin, I&#39;d ask to review this related(about function/closure type) thread<br>&gt; in mailing list before preparing the proposal: &quot;[Proposal] Disallow<br>&gt; implicit conversion between function/closure with a list of parameters and<br>&gt; with tuple parameter. Remove function type inconsistency.&quot;<br>&gt;<br>&gt; I mean probably you&#39;ll want to form a more generic proposal to<br>&gt; improve/make less surprising Swift&#39;s function types and add consistency in<br>&gt; this area. I&#39;d be happy if you&#39;ll add ideas from the thread mentioned above<br>&gt; to your proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; By the way, on the topic of design topics: is there any core team<br>&gt;&gt; support for removing associated type inference? I have a proposal there<br>&gt;&gt; that I would like to move into the formal review stage at some point.<br>&gt;&gt;<br>&gt;&gt; Best, Austin<br>&gt;&gt;<br>&gt;&gt; Sent from my iPhone<br>&gt;&gt;<br>&gt;&gt; On Jun 28, 2016, at 9:33 AM, Douglas Gregor &lt;dgregor at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 27, 2016, at 10:40 PM, Charlie Monroe<br>&gt;&gt;&gt;&gt; &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Oh, I see. The issue is then the following:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let x = f x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let y: (Int, Int) -&gt; () = f f(1, 2) // OK<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Which requires you to write x(a: 1, b: 2). I must admit, however,<br>&gt;&gt;&gt;&gt; that I always liked this behavior…<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right, that’s the issue. The idea behind this is that it’s a<br>&gt;&gt;&gt; simplification to the type system to eliminate argument labels from<br>&gt;&gt;&gt; types, so we can eliminate some extra subtyping relationships (e.g.,<br>&gt;&gt;&gt; between function types with labels and ones without labels).<br>&gt;&gt;&gt; Essentially, argument labels become part of the names of declarations<br>&gt;&gt;&gt; (only!), which is consistent with our view that the names of<br>&gt;&gt;&gt; functions/methods/initializers include all of the argument names.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Doug<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 7:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think the point is to get rid of the argument labels. &#39;x&#39; should<br>&gt;&gt;&gt;&gt;&gt; be typed simply (Int, Int) -&gt; ().<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; That being said, right now the argument labels in the type don&#39;t<br>&gt;&gt;&gt;&gt;&gt; seem to actually affect anything, so like Chris I&#39;m not sure what<br>&gt;&gt;&gt;&gt;&gt; the counter-proposal is.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; (cc. Doug)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This came from a short list of topics Doug provided me, but<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the basic issue is that:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func f(a : Int, b : Int) { let x = f   // x has type (a: Int,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; b: Int) -&gt; () }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt; list swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/498e3c85/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 9:49 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; This makes sense. If nobody objects I&#39;ll prepare a proposal today. <br>&gt; <br>&gt; By the way, on the topic of design topics: is there any core team support for removing associated type inference? I have a proposal there that I would like to move into the formal review stage at some point. <br></p><p>Well, *I* want to remove associated type inference because I feel that we shouldn’t have global inference like this in Swift. I am, however, concerned about the standard library’s ability to make conformances to the Collection protocols provide meaningful defaults for, e.g., the SubSequence associated type.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 9:33 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 10:40 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I see. The issue is then the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x = f<br>&gt;&gt;&gt; x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let y: (Int, Int) -&gt; () = f<br>&gt;&gt;&gt; f(1, 2) // OK<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which requires you to write x(a: 1, b: 2). I must admit, however, that I always liked this behavior…<br>&gt;&gt; <br>&gt;&gt; Right, that’s the issue. The idea behind this is that it’s a simplification to the type system to eliminate argument labels from types, so we can eliminate some extra subtyping relationships (e.g., between function types with labels and ones without labels). Essentially, argument labels become part of the names of declarations (only!), which is consistent with our view that the names of functions/methods/initializers include all of the argument names.<br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 28, 2016, at 7:06 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the point is to get rid of the argument labels. &#39;x&#39; should be typed simply (Int, Int) -&gt; ().<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That being said, right now the argument labels in the type don&#39;t seem to actually affect anything, so like Chris I&#39;m not sure what the counter-proposal is.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (cc. Doug)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 10:04 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This came from a short list of topics Doug provided me, but the basic issue is that:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func f(a : Int, b : Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt; let x = f   // x has type (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’m not exactly sure what the counterproposal is.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My guess is to require let x = f(a:,b:) (specifying arguments)?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 29, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On 28 Jun 2016, at 20:00, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, *I* want to remove associated type inference because I feel that we shouldn’t have global inference like this in Swift. I am, however, concerned about the standard library’s ability to make conformances to the Collection protocols provide meaningful defaults for, e.g., the SubSequence associated type.<br>&gt; <br>&gt; 	- Doug<br></p><p>I am also for removing associated type inference, and I guess if it needs to be done, its now. Concerning SubSequence, isn’t that supposed to be away post Swift-3 once we have some of the more powerful generics?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160629/e27b281c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 3:49 PM, David Hart via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On 28 Jun 2016, at 20:00, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Well, *I* want to remove associated type inference because I feel that we<br>&gt; shouldn’t have global inference like this in Swift. I am, however, concerned<br>&gt; about the standard library’s ability to make conformances to the Collection<br>&gt; protocols provide meaningful defaults for, e.g., the SubSequence associated<br>&gt; type.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; I am also for removing associated type inference, and I guess if it needs to<br>&gt; be done, its now. Concerning SubSequence, isn’t that supposed to be away<br>&gt; post Swift-3 once we have some of the more powerful generics?<br></p><p>I&#39;m not aware of any generics features that will allow us to remove SubSequence.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>June 28, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 10:15 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Jun 28, 2016 at 3:49 PM, David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I am also for removing associated type inference, and I guess if it needs to<br>&gt;&gt; be done, its now. Concerning SubSequence, isn’t that supposed to be away<br>&gt;&gt; post Swift-3 once we have some of the more powerful generics?<br>&gt; <br>&gt; I&#39;m not aware of any generics features that will allow us to remove SubSequence.<br></p><p>Generalized existentials provide an intelligent default value on Sequence for SubSequence and Iterator, if Element was an associated type. There would still be efficiencies possible if you were able to specify these associated types as concrete types.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/a854f5f5/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 496 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/a854f5f5/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>June 28, 2016 at 10:00:00pm</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 10:03 PM, David Waite<br>&lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;<br>&gt; On Jun 28, 2016, at 10:15 PM, Dmitri Gribenko via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Tue, Jun 28, 2016 at 3:49 PM, David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; I am also for removing associated type inference, and I guess if it needs to<br>&gt; be done, its now. Concerning SubSequence, isn’t that supposed to be away<br>&gt; post Swift-3 once we have some of the more powerful generics?<br>&gt;<br>&gt;<br>&gt; I&#39;m not aware of any generics features that will allow us to remove<br>&gt; SubSequence.<br>&gt;<br>&gt;<br>&gt; Generalized existentials provide an intelligent default value on Sequence<br>&gt; for SubSequence and Iterator, if Element was an associated type. There would<br>&gt; still be efficiencies possible if you were able to specify these associated<br>&gt; types as concrete types.<br></p><p>I would be very concerned about performance regressions because of<br>SubSequence being defined as an existential.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 11:00 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 9:49 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This makes sense. If nobody objects I&#39;ll prepare a proposal today. <br>&gt;&gt; <br>&gt;&gt; By the way, on the topic of design topics: is there any core team support for removing associated type inference? I have a proposal there that I would like to move into the formal review stage at some point. <br>&gt; <br>&gt; Well, *I* want to remove associated type inference because I feel that we shouldn’t have global inference like this in Swift. I am, however, concerned about the standard library’s ability to make conformances to the Collection protocols provide meaningful defaults for, e.g., the SubSequence associated type.<br></p><p>I am also +1 on the concept, but haven’t had a chance to fully consider the ramifications.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 10:33 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 10:40 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oh, I see. The issue is then the following:<br>&gt;&gt; <br>&gt;&gt; let x = f<br>&gt;&gt; x(1, 2) // Error: Missing argument labels &#39;a:b:&#39; in call<br>&gt;&gt; <br>&gt;&gt; let y: (Int, Int) -&gt; () = f<br>&gt;&gt; f(1, 2) // OK<br>&gt;&gt; <br>&gt;&gt; Which requires you to write x(a: 1, b: 2). I must admit, however, that I always liked this behavior…<br>&gt; <br>&gt; Right, that’s the issue. The idea behind this is that it’s a simplification to the type system to eliminate argument labels from types, so we can eliminate some extra subtyping relationships (e.g., between function types with labels and ones without labels). Essentially, argument labels become part of the names of declarations (only!), which is consistent with our view that the names of functions/methods/initializers include all of the argument names.<br>&gt; <br>&gt; 	- Doug<br></p><p>I&#39;d really love if there were a simple way to bind labels to any tuple, where they can then be referred to by those labels in the current scope as well as by .0, .1, and by any other existing labels, so long as there&#39;s no syntactic confusion between labels. Labels would inherently simplify to positions with argument names as semantic sugar. Default values (now in fixed order) maintain position numbers even when excluded.<br></p><p>For example: myArray.enumerate.tupleBind(index:, value:).map({ do stuff with $0.index, $0.value })<br></p><p>Too impossible? Against Swift philosophy?<br></p><p>-- E<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2969f67fc010e956c71442148f3f6fc0?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Wallacy</string> &lt;wallacyf at gmail.com&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>And something about Property Behaviors? It&#39;s a very good proposal, and can<br>solve many problems cited in other proposals in this list.<br></p><p><br>Em qua, 22 de jun de 2016 às 22:08, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; escreveu:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; Here is a partial list of the open topics that the core team would like to<br>&gt; get resolved in Swift 3.  The list is partial both because I’m way behind<br>&gt; on swift-evolution traffic, but also because new things may come up.  There<br>&gt; are also a number of accepted proposals that are not yet implemented.  Some<br>&gt; topics have proposals done, and therefore have an SE number, but the review<br>&gt; discussion hasn’t finalized.  Some of these topics have an “owner” that is<br>&gt; driving or planning to start a discussion on them them, which I’ve listed<br>&gt; in square brackets.<br>&gt;<br>&gt; If you’d like to discuss these topics in particular, please start a new<br>&gt; thread specific to them, or contribute to an already-existing thread<br>&gt; discussing it.  Several of these don’t have an owner yet, so if you’d like<br>&gt; to pick them up and run with them, that would be great.  Thanks!<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Language:<br>&gt; - SE-0091: Improving operator requirements in protocols [Core team<br>&gt; discussed this, will email about it shortly]<br>&gt; - SE-0077: Improve operator declaration syntax [Core team discussed this,<br>&gt; Joe Groff will follow up on this soon]<br>&gt; - SE-0095: Replace protocol&lt;P1,P2&gt; syntax with P1 &amp; P2 syntax<br>&gt; - SE-0102: Remove @noreturn attribute and introduce an empty NoReturn type<br>&gt; - SE-0103: Invert @noescape<br>&gt; - Remove T -&gt; T? implicit promotion for operands to operators<br>&gt; - Removing argument labels from the type system (so they are<br>&gt; declaration-only constructs)<br>&gt; - Some reshuffling with requiring @objc/@nonobjc for things that<br>&gt; shouldn’t/can’t be expressed via the Objective-C runtime<br>&gt; - Eliminating inference of associated type witnesses (as is mentioned in<br>&gt; the generics manifesto)<br>&gt; - Should public classes be non-publicly-subclassable by default? [John<br>&gt; McCall]<br>&gt; - Revising access modifiers on extensions [Adrian Zubarev]<br>&gt;<br>&gt;<br>&gt; Standard library:<br>&gt;  - SE-0101: Rename sizeof and related functions to comply with API<br>&gt; Guidelines<br>&gt;  - Ongoing API naming adjustments for stdlib:<br>&gt;     - Closure arguments [Dave Abrahams]<br>&gt;     - Others are being discussed on swift-evolution.<br>&gt;  - Remove Boolean protocol.<br>&gt;  - SE-0104: Revise Integer protocols to match FP ones. [Max Moiseev]<br>&gt;<br>&gt; SDK / Cocoa / ObjC interop:<br>&gt;  - [SE-0086] Finalize NS removal plan. [Tony Parker]<br>&gt;  - Importing “id” as Any [Joe Groff]<br>&gt;  - Revise NSError/Error model for better interoperability and usability.<br>&gt; [Doug Gregor]<br>&gt;  - &lt;rdar://15821981&gt; Bridge NSRange to “Range&lt;Int&gt;?”<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/9d73eb26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Partial list of open Swift 3 design topics</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 7:36 AM, Wallacy &lt;wallacyf at gmail.com&gt; wrote:<br>&gt; <br>&gt; And something about Property Behaviors? It&#39;s a very good proposal, and can solve many problems cited in other proposals in this list.<br></p><p>I’m also looking forward to property behaviors, but there is a ton of open design work left to be done.  They are clearly post-swift-3.0 at this point.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
