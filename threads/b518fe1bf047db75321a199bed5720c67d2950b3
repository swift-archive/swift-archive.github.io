<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March 15, 2016 at 11:00:00pm</p></header><div class="content"><p>I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br></p><p>Today, each object stores 64-bits of refcounts and flags after the isa field.<br></p><p>In this new system, each object would store a pointer-size field after the isa field. This field would have two cases: it could store refcounts and flags, or it could store a pointer to a side allocation that would store refcounts and flags and additional per-object data.<br></p><p>Advantages:<br>* Saves 4 bytes per object on 32-bit for most objects.<br>* Improves refcount overflow and underflow detection.<br>* Might allow an inlineable retain/release fast path in the future.<br>* Allows a new weak reference implementation that doesn&#39;t need to keep entire dead objects alive.<br>* Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br></p><p>Disadvantages:<br>* Basic RR operations might be slower on x86_64. This needs to be measured. ARM architectures are probably unchanged.<br></p><p>----<br></p><p>The MSB bit would distinguish between the fastest-path in-object retain/release and everything else. Objects that use some other RR path would have that bit set. This would include objects whose refcount is stored in the side allocation and objects whose refcount does not change because they are allocated on the stack or in read-only memory.<br></p><p>The MSB bit also becomes set if you increment or decrement a retain count too far. That means we can implement the RR fast path with a single conditional branch after the increment or decrement:<br></p><p>retain:<br>    intptr_t oldRC = obj-&gt;rc<br>    newRC = oldRC + RC_ONE    // sets MSB on overflow; MSB already set for other special cases<br>    if (newRC &gt;= 0) {<br>        CAS(obj-&gt;rc = oldRC =&gt; newRC)<br>    } else {<br>        call slow path<br>        // out-of-object refcount     (MSB bits 0b10x)<br>        // or refcount has overflowed (MSB bits 0b111)<br>        // or refcount is constant    (MSB bits 0b110)<br>    }<br></p><p>release:<br>    intptr_t oldRC = obj-&gt;rc<br>    newRC = oldRC - RC_ONE    // sets MSB on overflow; MSB already set for other special cases<br>    if (newRC &gt;= 0) {<br>        CAS(obj-&gt;rc = oldRC =&gt; newRC)<br>    } else {<br>        call slow path<br>        // dealloc                     (MSB bits 0b111)<br>        // or out-of-object refcount   (MSB bits 0b10x)<br>        // or refcount has underflowed (MSB bits 0b111 and deallocating bit already set)<br>        // or refcount is constant     (MSB bits 0b110)<br>    }<br></p><p>There are some fussy bit representation details here to make sure that a pre-existing MSB=1 does not become 0 after an increment or decrement. <br></p><p>(In the more distant future this fast path could be inlineable while preserving ABI flexibility: if worse comes to worse we can set the MSB all the time and force inliners to fall back to the slow path runtime function. We don&#39;t want to do this yet though.)<br></p><p>The side allocation could be used for:<br>* New weak reference implementation that doesn&#39;t need to keep entire dead objects alive.<br>* Associated references or class extensions with instance variables<br>* Full-size strong refcount and unowned refcount on 32-bit architectures<br>* Future concurrency data or debugging instrumentation data<br></p><p>The Objective-C runtime uses a side table for similar purposes. It has the disadvantage that retrieving an object&#39;s side allocation requires use of a global hash table, which is slow and requires locking. This scheme would be faster and contention-free.<br></p><p>Installing a side allocation on an object would be a one-way operation for thread-safety reasons. For example, an object might be given a side allocation when it is first weakly referenced, but the object would not go back to in-object refcounts if the weak reference went away. Most objects would not need a side allocation.<br></p><p>----<br></p><p>Weak references could be implemented using the side allocation. A weak variable would point to the object&#39;s side allocation. The side allocation would store a pointer to the object and a strong refcount and a weak refcount. (This weak refcount would be distinct from the unowned refcount.)  The weak refcount would be incremented once for every weak variable holding this object. <br></p><p>The advantage of using a side allocation for weak references is that the storage for a weakly-referenced object could be freed synchronously when deinit completes. Only the small side allocation would remain, backing the weak variables until they are cleared on their next access. This is a memory improvement over today&#39;s scheme, which keeps the object&#39;s entire storage alive for a potentially long time.<br></p><p>The hierarchy:<br>  Strong refcount goes to zero: deinit<br>  Unowned refcount goes to zero: free the object<br>  Weak refcount goes to zero: free the side allocation<br></p><p>When a weakly-referenced object is destroyed, it would free its own storage but leave the side allocation alive until all of the weak references go away. <br></p><p>When a weak variable is read, it would go to the side table first and atomically increment the strong refcount if the deallocating bit were not set. Then it would return the object pointer stored in the side allocation. If the deallocating bit was set, it would atomically decrement the weak refcount and free the side allocation if it reaches zero. (There is another race here that probably requires separate side bits for object-is-deallocating and object-is-deallocated.)<br></p><p>When an old value is erased from a weak variable, it would atomically decrement the weak refcount in the side allocation and free the side allocation if it reaches zero.<br></p><p>When a new value is stored to a weak variable is written, it would install a side allocation if necessary, then check the deallocating bit in the side allocation. If the object is not deallocating it would atomically increment the weak refcount.<br></p><p>----<br></p><p>RR fast paths in untested x86_64 assembly (AT&amp;T syntax, destination on the right):<br></p><p>retain_fast:<br>   // object in %rdi<br>   mov   8(%rdi), %rax<br>1: mov   %rax, %rdx<br>   add   $0x200000000, %rdx<br>   bmi   retain_slow<br>   lock,cmpxchg %rdx, 8(%rdi)<br>   bne   1b<br></p><p>release_fast:<br>   // object in %rdi<br>   mov   8(%rdi), %rax<br>1: mov   %rax, %rdx<br>   sub   $0x200000000, %rdx<br>   bmi   release_slow<br>   lock,cmpxchg %rdx, 8(%rdi)<br>   bne   1b<br></p><p><br>RR fast paths in untested arm64 assembly<br></p><p>retain_fast:<br>   // object in x0<br>   add   x1, x0, #8<br>1: ldxr  x2, [x1]<br>   mov   x3, #0x200000000<br>   adds  x2, x2, x3<br>   b.mi  retain_slow<br>   stxr  w4, x2, [x1]<br>   cbz   w4, 1b<br></p><p>release_fast:<br>   // object in x0<br>   add   x1, x0, #8<br>1: ldxr  x2, [x1]<br>   mov   x3, #0x200000000<br>   subs  x2, x2, x3<br>   b.mi  release_slow<br>   stlxr w4, x2, [x1]<br>   cbz   w4, 1b<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 16, 2016 at 09:00:00am</p></header><div class="content"><p>This sounds awesome. Should we still consider using a non-pointer isa representation on 64 bit platforms? 16 bytes per object header is still kinda big. If we laid out the np-isa bits so that the &quot;side allocation&quot; bit were the MSB, and the strong refcount immediately below it, we could pull the same trick letting the strong refcount overflow into the side allocation bit. Drawbacks would be that we&#39;d need to go back to a global sidetable to reference the overflow allocation, and that on Apple platforms, we&#39;d need to follow whatever non-pointer-isa layout the Objective-C runtime uses, and the exact layout of the bits would have to remain runtime-private and thus not inlineable. If we&#39;re running on the assumption that side allocations are rarely needed, then paying for the lock in the rare case might be worth a potentially substantial memory savings. On platforms where we don&#39;t need ObjC interop, maybe we could avoid the need for the sidetable with non-pointer-isa by cloning the heap object&#39;s vtable into the side allocation and changing the masked isa pointer to refer to the side allocation. That would make the side allocation larger, and would make operations that extract the type metadata from a class for generics a bit more expensive, but would let vtable lookups remain fast.<br></p><p>-Joe<br></p><p>&gt; On Mar 15, 2016, at 11:59 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br>&gt; <br>&gt; Today, each object stores 64-bits of refcounts and flags after the isa field.<br>&gt; <br>&gt; In this new system, each object would store a pointer-size field after the isa field. This field would have two cases: it could store refcounts and flags, or it could store a pointer to a side allocation that would store refcounts and flags and additional per-object data.<br>&gt; <br>&gt; Advantages:<br>&gt; * Saves 4 bytes per object on 32-bit for most objects.<br>&gt; * Improves refcount overflow and underflow detection.<br>&gt; * Might allow an inlineable retain/release fast path in the future.<br>&gt; * Allows a new weak reference implementation that doesn&#39;t need to keep entire dead objects alive.<br>&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br>&gt; <br>&gt; Disadvantages:<br>&gt; * Basic RR operations might be slower on x86_64. This needs to be measured. ARM architectures are probably unchanged.<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; The MSB bit would distinguish between the fastest-path in-object retain/release and everything else. Objects that use some other RR path would have that bit set. This would include objects whose refcount is stored in the side allocation and objects whose refcount does not change because they are allocated on the stack or in read-only memory.<br>&gt; <br>&gt; The MSB bit also becomes set if you increment or decrement a retain count too far. That means we can implement the RR fast path with a single conditional branch after the increment or decrement:<br>&gt; <br>&gt; retain:<br>&gt;    intptr_t oldRC = obj-&gt;rc<br>&gt;    newRC = oldRC + RC_ONE    // sets MSB on overflow; MSB already set for other special cases<br>&gt;    if (newRC &gt;= 0) {<br>&gt;        CAS(obj-&gt;rc = oldRC =&gt; newRC)<br>&gt;    } else {<br>&gt;        call slow path<br>&gt;        // out-of-object refcount     (MSB bits 0b10x)<br>&gt;        // or refcount has overflowed (MSB bits 0b111)<br>&gt;        // or refcount is constant    (MSB bits 0b110)<br>&gt;    }<br>&gt; <br>&gt; release:<br>&gt;    intptr_t oldRC = obj-&gt;rc<br>&gt;    newRC = oldRC - RC_ONE    // sets MSB on overflow; MSB already set for other special cases<br>&gt;    if (newRC &gt;= 0) {<br>&gt;        CAS(obj-&gt;rc = oldRC =&gt; newRC)<br>&gt;    } else {<br>&gt;        call slow path<br>&gt;        // dealloc                     (MSB bits 0b111)<br>&gt;        // or out-of-object refcount   (MSB bits 0b10x)<br>&gt;        // or refcount has underflowed (MSB bits 0b111 and deallocating bit already set)<br>&gt;        // or refcount is constant     (MSB bits 0b110)<br>&gt;    }<br>&gt; <br>&gt; There are some fussy bit representation details here to make sure that a pre-existing MSB=1 does not become 0 after an increment or decrement. <br>&gt; <br>&gt; (In the more distant future this fast path could be inlineable while preserving ABI flexibility: if worse comes to worse we can set the MSB all the time and force inliners to fall back to the slow path runtime function. We don&#39;t want to do this yet though.)<br>&gt; <br>&gt; The side allocation could be used for:<br>&gt; * New weak reference implementation that doesn&#39;t need to keep entire dead objects alive.<br>&gt; * Associated references or class extensions with instance variables<br>&gt; * Full-size strong refcount and unowned refcount on 32-bit architectures<br>&gt; * Future concurrency data or debugging instrumentation data<br>&gt; <br>&gt; The Objective-C runtime uses a side table for similar purposes. It has the disadvantage that retrieving an object&#39;s side allocation requires use of a global hash table, which is slow and requires locking. This scheme would be faster and contention-free.<br>&gt; <br>&gt; Installing a side allocation on an object would be a one-way operation for thread-safety reasons. For example, an object might be given a side allocation when it is first weakly referenced, but the object would not go back to in-object refcounts if the weak reference went away. Most objects would not need a side allocation.<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; Weak references could be implemented using the side allocation. A weak variable would point to the object&#39;s side allocation. The side allocation would store a pointer to the object and a strong refcount and a weak refcount. (This weak refcount would be distinct from the unowned refcount.)  The weak refcount would be incremented once for every weak variable holding this object. <br>&gt; <br>&gt; The advantage of using a side allocation for weak references is that the storage for a weakly-referenced object could be freed synchronously when deinit completes. Only the small side allocation would remain, backing the weak variables until they are cleared on their next access. This is a memory improvement over today&#39;s scheme, which keeps the object&#39;s entire storage alive for a potentially long time.<br>&gt; <br>&gt; The hierarchy:<br>&gt;  Strong refcount goes to zero: deinit<br>&gt;  Unowned refcount goes to zero: free the object<br>&gt;  Weak refcount goes to zero: free the side allocation<br>&gt; <br>&gt; When a weakly-referenced object is destroyed, it would free its own storage but leave the side allocation alive until all of the weak references go away. <br>&gt; <br>&gt; When a weak variable is read, it would go to the side table first and atomically increment the strong refcount if the deallocating bit were not set. Then it would return the object pointer stored in the side allocation. If the deallocating bit was set, it would atomically decrement the weak refcount and free the side allocation if it reaches zero. (There is another race here that probably requires separate side bits for object-is-deallocating and object-is-deallocated.)<br>&gt; <br>&gt; When an old value is erased from a weak variable, it would atomically decrement the weak refcount in the side allocation and free the side allocation if it reaches zero.<br>&gt; <br>&gt; When a new value is stored to a weak variable is written, it would install a side allocation if necessary, then check the deallocating bit in the side allocation. If the object is not deallocating it would atomically increment the weak refcount.<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; RR fast paths in untested x86_64 assembly (AT&amp;T syntax, destination on the right):<br>&gt; <br>&gt; retain_fast:<br>&gt;   // object in %rdi<br>&gt;   mov   8(%rdi), %rax<br>&gt; 1: mov   %rax, %rdx<br>&gt;   add   $0x200000000, %rdx<br>&gt;   bmi   retain_slow<br>&gt;   lock,cmpxchg %rdx, 8(%rdi)<br>&gt;   bne   1b<br>&gt; <br>&gt; release_fast:<br>&gt;   // object in %rdi<br>&gt;   mov   8(%rdi), %rax<br>&gt; 1: mov   %rax, %rdx<br>&gt;   sub   $0x200000000, %rdx<br>&gt;   bmi   release_slow<br>&gt;   lock,cmpxchg %rdx, 8(%rdi)<br>&gt;   bne   1b<br>&gt; <br>&gt; <br>&gt; RR fast paths in untested arm64 assembly<br>&gt; <br>&gt; retain_fast:<br>&gt;   // object in x0<br>&gt;   add   x1, x0, #8<br>&gt; 1: ldxr  x2, [x1]<br>&gt;   mov   x3, #0x200000000<br>&gt;   adds  x2, x2, x3<br>&gt;   b.mi  retain_slow<br>&gt;   stxr  w4, x2, [x1]<br>&gt;   cbz   w4, 1b<br>&gt; <br>&gt; release_fast:<br>&gt;   // object in x0<br>&gt;   add   x1, x0, #8<br>&gt; 1: ldxr  x2, [x1]<br>&gt;   mov   x3, #0x200000000<br>&gt;   subs  x2, x2, x3<br>&gt;   b.mi  release_slow<br>&gt;   stlxr w4, x2, [x1]<br>&gt;   cbz   w4, 1b<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March 16, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 9:25 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; This sounds awesome. Should we still consider using a non-pointer isa representation on 64 bit platforms? 16 bytes per object header is still kinda big. If we laid out the np-isa bits so that the &quot;side allocation&quot; bit were the MSB, and the strong refcount immediately below it, we could pull the same trick letting the strong refcount overflow into the side allocation bit. Drawbacks would be that we&#39;d need to go back to a global sidetable to reference the overflow allocation, and that on Apple platforms, we&#39;d need to follow whatever non-pointer-isa layout the Objective-C runtime uses, and the exact layout of the bits would have to remain runtime-private and thus not inlineable. If we&#39;re running on the assumption that side allocations are rarely needed, then paying for the lock in the rare case might be worth a potentially substantial memory savings.<br></p><p>Packing everything into a single 64-bit field is tricky but might work.<br></p><p>I think OS X and Linux x86_64 is the worst case currently, with 3 low bits and 17 high bits available. Here&#39;s what libobjc stores in its isa field on x86_64:<br></p><p> 1 bit   is nonpointer<br> 1 bit   has associated references<br> 1 bit   has destructor<br>44 bits  class pointer<br> 6 bits  magic for tools<br> 1 bit   is weakly referenced<br> 1 bit   is deallocating<br> 1 bit   has additional refcount in side allocation<br> 8 bits  refcount<br></p><p>Some of those bits can be combined or reduced:<br></p><p>is-nonpointer is unnecessary as long as at least one of the bits outside the class pointer is set. There may be binary compatibility problems here, though. (Do existing Swift apps check that bit directly?)<br></p><p>has-associated-references and is-weakly-referenced and has-additional-refcount could be folded into a single has-sidetable bit. <br></p><p>magic is needed for tools like `leaks` to distinguish real objects from non-object allocations. If the isa field is not a simple pointer then there are otherwise too many false objects for `leaks` to be usable. 6 bits is pushing the bare minimum here, but we might be able to trim this by making the tools smarter and more invasive. (For example: if the has-sidetable bit is set then look for a side allocation pointing back to the object. If you don&#39;t find one then it&#39;s not a real object.)  Being able to run `leaks` and `heap` on an unprepared process is an important capability, and I don&#39;t think we can afford to cripple it.<br></p><p>refcount can always be trimmed. I don&#39;t know what the shape of the &quot;objects whose refcount is ever greater than X&quot; curve looks like.<br></p><p><br>Given the above, we can claw back enough bits for things like a small unowned refcount and is-pinned or is-nonstructurally-mutating bits. <br></p><p>My biggest concern is future Swift concurrency support. I suspect we will want storage for a thread ID or a lock. Maybe those would be uncommon enough that they can live in a side allocation. Will we want a thread ID in every thread-local object in production code so we can assert that it has not incorrectly escaped, or can we leave things like that for debug builds only?<br></p><p><br>One scheme that I want to investigate for ObjC&#39;s use is to allocate a flat array of side allocations, and store an index into that array in the isa field&#39;s extra bits. Depending on architecture that allows between 256K and 64M objects with side allocations before falling back to a global table. If that works well enough then packing everything into a single pointer-size field becomes more plausible.<br></p><p><br>Joe, did you measure the cost of a mask operation at every Swift virtual call? I can&#39;t remember.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9c72f152ed52fbbdb5f174ad2e1e7b0a?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>John Calsbeek</string> &lt;john.calsbeek+lists at gmail.com&gt;<p>March 16, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; One scheme that I want to investigate for ObjC&#39;s use is to allocate a flat array of side allocations, and store an index into that array in the isa field&#39;s extra bits. Depending on architecture that allows between 256K and 64M objects with side allocations before falling back to a global table. If that works well enough then packing everything into a single pointer-size field becomes more plausible.<br>&gt; <br>&gt; <br>&gt; Joe, did you measure the cost of a mask operation at every Swift virtual call? I can&#39;t remember.<br></p><p>This is a totally harebrained idea, but: if a mask at every call site is acceptable and you admit restrictions about where in the virtual address space vtables can be allocated, *and* you do the flat array of side allocations, you can get back a lot of bits.<br></p><p>Example (for 64-bit):<br></p><p>  (MSB)<br>     1 bit   is deallocating<br>     1 bit   is pinned<br>    18 bits  side allocation index<br>    20 bits  vtable pointer high<br>     2 bits  00 (ordinary) or 11 (strong refcount is constant)<br>    10 bits  strong refcount<br>     4 bits  vtable pointer low<br>     8 bits  unowned refcount<br>  (LSB)<br></p><p>Mask this with 0x00000fffff000f00 and you get a pointer with 256-byte alignment that can range over a 44-bit address space with a stride of 16 MB—hopefully enough flexibility to find some unused virtual address space. Unfortunately with this layout you can only fit 16 vtables in one 4k page, so it’s not particularly TLB-friendly.<br></p><p>I can think of several dozen ways this might fall over, plus it’s starting to be a pretty complicated layout to inline and make ABI-stable, but it’s an idea.<br></p><p>&gt; My biggest concern is future Swift concurrency support. I suspect we will want storage for a thread ID or a lock. Maybe those would be uncommon enough that they can live in a side allocation. Will we want a thread ID in every thread-local object in production code so we can assert that it has not incorrectly escaped, or can we leave things like that for debug builds only?<br></p><p>I don’t know anything about the possible future concurrency use cases, but I certainly hope we won’t need a lock in every object in the fast path.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 17, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 4:08 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 16, 2016, at 9:25 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This sounds awesome. Should we still consider using a non-pointer isa representation on 64 bit platforms? 16 bytes per object header is still kinda big. If we laid out the np-isa bits so that the &quot;side allocation&quot; bit were the MSB, and the strong refcount immediately below it, we could pull the same trick letting the strong refcount overflow into the side allocation bit. Drawbacks would be that we&#39;d need to go back to a global sidetable to reference the overflow allocation, and that on Apple platforms, we&#39;d need to follow whatever non-pointer-isa layout the Objective-C runtime uses, and the exact layout of the bits would have to remain runtime-private and thus not inlineable. If we&#39;re running on the assumption that side allocations are rarely needed, then paying for the lock in the rare case might be worth a potentially substantial memory savings.<br>&gt; <br>&gt; Packing everything into a single 64-bit field is tricky but might work.<br>&gt; <br>&gt; I think OS X and Linux x86_64 is the worst case currently, with 3 low bits and 17 high bits available. Here&#39;s what libobjc stores in its isa field on x86_64:<br>&gt; <br>&gt; 1 bit   is nonpointer<br>&gt; 1 bit   has associated references<br>&gt; 1 bit   has destructor<br>&gt; 44 bits  class pointer<br>&gt; 6 bits  magic for tools<br>&gt; 1 bit   is weakly referenced<br>&gt; 1 bit   is deallocating<br>&gt; 1 bit   has additional refcount in side allocation<br>&gt; 8 bits  refcount<br>&gt; <br>&gt; Some of those bits can be combined or reduced:<br>&gt; <br>&gt; is-nonpointer is unnecessary as long as at least one of the bits outside the class pointer is set. There may be binary compatibility problems here, though. (Do existing Swift apps check that bit directly?)<br>&gt; <br>&gt; has-associated-references and is-weakly-referenced and has-additional-refcount could be folded into a single has-sidetable bit. <br>&gt; <br>&gt; magic is needed for tools like `leaks` to distinguish real objects from non-object allocations. If the isa field is not a simple pointer then there are otherwise too many false objects for `leaks` to be usable. 6 bits is pushing the bare minimum here, but we might be able to trim this by making the tools smarter and more invasive. (For example: if the has-sidetable bit is set then look for a side allocation pointing back to the object. If you don&#39;t find one then it&#39;s not a real object.)  Being able to run `leaks` and `heap` on an unprepared process is an important capability, and I don&#39;t think we can afford to cripple it.<br>&gt; <br>&gt; refcount can always be trimmed. I don&#39;t know what the shape of the &quot;objects whose refcount is ever greater than X&quot; curve looks like.<br>&gt; <br>&gt; <br>&gt; Given the above, we can claw back enough bits for things like a small unowned refcount and is-pinned or is-nonstructurally-mutating bits. <br>&gt; <br>&gt; My biggest concern is future Swift concurrency support. I suspect we will want storage for a thread ID or a lock. Maybe those would be uncommon enough that they can live in a side allocation. Will we want a thread ID in every thread-local object in production code so we can assert that it has not incorrectly escaped, or can we leave things like that for debug builds only?<br>&gt; <br>&gt; <br>&gt; One scheme that I want to investigate for ObjC&#39;s use is to allocate a flat array of side allocations, and store an index into that array in the isa field&#39;s extra bits. Depending on architecture that allows between 256K and 64M objects with side allocations before falling back to a global table. If that works well enough then packing everything into a single pointer-size field becomes more plausible.<br>&gt; <br>&gt; <br>&gt; Joe, did you measure the cost of a mask operation at every Swift virtual call? I can&#39;t remember.<br></p><p>Yeah. The effect of the mask operation was unmeasurable on the Macbook Pro and iPhone 5s I was testing on. Masking using a resilient mask value loaded from a dylib did have a noticeable impact on an Apple Watch, though.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 01:00:00pm</p></header><div class="content"><p>This is damned clever.<br></p><p>&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br></p><p>It sounds like you wouldn&#39;t be able to resize an out-of-band refcount allocation once it&#39;s been created, though, right? There are pointers to it all over memory; you can&#39;t track them all unless you save back references to all of them. So if you added, say, a refcount allocation-based feature for extension ivars, every refcount allocation would need to have the extra pointers to accommodate them in case you dynamically loaded code later that added an ivar in an extension. You couldn&#39;t go &quot;whoops, need space for ivars, let&#39;s replace this recount allocation with one that has room for another pointer&quot;.<br></p><p>&gt; The MSB bit also becomes set if you increment or decrement a retain count too far. That means we can implement the RR fast path with a single conditional branch after the increment or decrement:<br></p><p><br>You don&#39;t talk much about it, but I think you&#39;re suggesting that the strong and unowned refcounts would still be packed into the same fields. It&#39;s worth noting that your clever high-bit-indicates-slow-path trick would *not* work on the unowned refcount, though that matters less since it doesn&#39;t get checked as often.<br></p><p>&gt;        // out-of-object refcount     (MSB bits 0b10x)<br>&gt;        // or refcount has overflowed (MSB bits 0b111)<br>&gt;        // or refcount is constant    (MSB bits 0b110)<br></p><p>Is this going to work on 32-bit? Even if we assume that valid pointers don&#39;t start with 0b1, can we assume that they don&#39;t start with 1b01?<br></p><p>&gt; The side allocation would store a pointer to the object and a strong refcount and a weak refcount. (This weak refcount would be distinct from the unowned refcount.)  The weak refcount would be incremented once for every weak variable holding this object. <br>&gt; <br>&gt; The advantage of using a side allocation for weak references is that the storage for a weakly-referenced object could be freed synchronously when deinit completes. Only the small side allocation would remain, backing the weak variables until they are cleared on their next access. This is a memory improvement over today&#39;s scheme, which keeps the object&#39;s entire storage alive for a potentially long time.<br>&gt; <br>&gt; The hierarchy:<br>&gt;  Strong refcount goes to zero: deinit<br>&gt;  Unowned refcount goes to zero: free the object<br>&gt;  Weak refcount goes to zero: free the side allocation<br></p><p>I take it the refcount field&#39;s pointer is itself considered a weak reference, so the weak refcount starts +1 like the unowned refcount does?<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/caa7226ca750e974668243476ffbafd5?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Greg Titus</string> &lt;greg at omnigroup.com&gt;<p>March 16, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 1:42 PM, Brent Royal-Gordon via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; This is damned clever.<br></p><p>Yes, I agree!<br></p><p>&gt;&gt; The MSB bit also becomes set if you increment or decrement a retain count too far. That means we can implement the RR fast path with a single conditional branch after the increment or decrement:<br>&gt; <br>&gt; You don&#39;t talk much about it, but I think you&#39;re suggesting that the strong and unowned refcounts would still be packed into the same fields. It&#39;s worth noting that your clever high-bit-indicates-slow-path trick would *not* work on the unowned refcount, though that matters less since it doesn&#39;t get checked as often.<br></p><p>My understanding is that there would not be an unowned refcount here (inline in the object). The first time you make a weak reference to the object it gets converted to have the out-of-band refcount structure, and the strong and unowned refcounts both get stored there (in an undefined-by-this-proposal way).<br></p><p>&gt;&gt;       // out-of-object refcount     (MSB bits 0b10x)<br>&gt;&gt;       // or refcount has overflowed (MSB bits 0b111)<br>&gt;&gt;       // or refcount is constant    (MSB bits 0b110)<br>&gt; <br>&gt; Is this going to work on 32-bit? Even if we assume that valid pointers don&#39;t start with 0b1, can we assume that they don&#39;t start with 1b01?<br></p><p>The out-of-object refcount flag here is only 2 bits (0b10 in the high bits), so presumably you store the other 2 bits of the pointer in the low bits which would always be zero, assuming word-aligned pointers. So in 32-bit you can just left shift by 2 and still have the whole normal pointer length available.<br></p><p>	- Greg<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; You don&#39;t talk much about it, but I think you&#39;re suggesting that the strong and unowned refcounts would still be packed into the same fields. It&#39;s worth noting that your clever high-bit-indicates-slow-path trick would *not* work on the unowned refcount, though that matters less since it doesn&#39;t get checked as often.<br>&gt; <br>&gt; My understanding is that there would not be an unowned refcount here (inline in the object). The first time you make a weak reference to the object it gets converted to have the out-of-band refcount structure, and the strong and unowned refcounts both get stored there (in an undefined-by-this-proposal way).<br></p><p>Note this line in the proposal:<br></p><p>&gt;&gt;&gt; (This weak refcount would be distinct from the unowned refcount.)<br></p><p>My understanding is that there are three refcounts:<br></p><p>* The (new) weak refcount represents claims on the refcount allocation. It (perhaps) starts +1 because the object&#39;s refcount field is a claim on the refcount allocation. When it goes to 0, the refcount allocation is freed.<br>* The unowned refcount represents claims on the object&#39;s allocation. It starts +1 because the strong refcount is a claim on the object&#39;s allocation. When it goes to 0, the refcount allocation&#39;s backreference is nulled (if there is one), the weak refcount is decremented (if it exists), and the object is freed.<br>* The strong refcount represents ownership of the object. It starts +1 because the initializer owns the object. When it goes to 0, the object is marked as deinitializing, `deinit`s are run, and the unowned refcount is decremented.<br></p><p>(The backreference might be cut when the strong refcount goes to zero; it doesn&#39;t make much difference either way.)<br></p><p>It sounds to me like this proposal is saying:<br></p><p>* There is a pointer-sized refcount field in each object.<br>* If the high bit is clear, ~half of its bytes are used for the strong refcount and the rest are used for the unowned refcount, with a few bits somewhere used for various flags.<br>* If the high bit is set, the remaining bits are a pointer to an allocation containing strong, unowned, and weak refcounts, plus any other stuff we might add later.<br>* We switch from inline refcount to pointer to refcount when one of the refcounts overflow, a weak reference is formed, or one of the future features we might add later are used. We switch from pointer to refcount to inline refcount never.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 1:42 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt; This is damned clever.<br>&gt; <br>&gt;&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br>&gt; <br>&gt; It sounds like you wouldn&#39;t be able to resize an out-of-band refcount allocation once it&#39;s been created, though, right? There are pointers to it all over memory; you can&#39;t track them all unless you save back references to all of them. So if you added, say, a refcount allocation-based feature for extension ivars, every refcount allocation would need to have the extra pointers to accommodate them in case you dynamically loaded code later that added an ivar in an extension. You couldn&#39;t go &quot;whoops, need space for ivars, let&#39;s replace this recount allocation with one that has room for another pointer&quot;.<br></p><p>Yes, every side allocation would need to include all of the storage needed for any side allocation feature. That size is sufficiently small, I think; perhaps something like this:<br></p><p>struct {<br>    void* object;<br>    uint32_t strongRefCount;<br>    uint32_t unownedRefCount;<br>    uint32_t weakRefCount;<br>    void* associatedReferenceDictionary;<br>    void* extensionIvarDictionary;<br>}<br></p><p><br>&gt;&gt; The MSB bit also becomes set if you increment or decrement a retain count too far. That means we can implement the RR fast path with a single conditional branch after the increment or decrement:<br>&gt; <br>&gt; You don&#39;t talk much about it, but I think you&#39;re suggesting that the strong and unowned refcounts would still be packed into the same fields. It&#39;s worth noting that your clever high-bit-indicates-slow-path trick would *not* work on the unowned refcount, though that matters less since it doesn&#39;t get checked as often.<br></p><p>Right. Unowned refcount would be slower than strong refcount. Strong refcount is by far the most common, so we&#39;re willing to tilt pretty much any scale in its favor. Unowned refcount would still be in the object, though, so it&#39;s still faster than a weak reference. <br></p><p>Alternatively we could reduce the implementation distinction between unowned references and weak references. Only the strong refcount would be in the object. (That in turn would help Joe&#39;s dream of a pointer-size object header.) That might make sense if (1) unowned references are sufficiently rare that they don&#39;t provoke too many side allocations, and (2) side table weak references are sufficiently fast that they can be used for unowned references too. My fear is that #1 is not true enough.<br></p><p>Anyone want to hack up a custom runtime that counts some object statistics, and run some non-trivial non-benchmark app with it? Something like these:<br>1. count of objects allocated<br>2. count of objects that were ever referenced unowned, but never referenced weakly<br>3. count of objects that were ever referenced weakly<br></p><p><br>&gt;&gt;       // out-of-object refcount     (MSB bits 0b10x)<br>&gt;&gt;       // or refcount has overflowed (MSB bits 0b111)<br>&gt;&gt;       // or refcount is constant    (MSB bits 0b110)<br>&gt; <br>&gt; Is this going to work on 32-bit? Even if we assume that valid pointers don&#39;t start with 0b1, can we assume that they don&#39;t start with 1b01?<br></p><p>The *low* two bits of the side allocation address are clear (assuming that the side allocation is 4-byte aligned). We can store 0b10 in the high two bits and (side allocation &gt;&gt; 2) in the low 30 bits. <br></p><p>(Bonus: using a shift instead of a mask to recover the pointer is one instruction shorter on armv7, I think.)<br></p><p>(And no, we cannot assume that the MSB of all 32-bit pointers is clear. On 32-bit we can only cheat with the low bits.)<br></p><p><br>&gt;&gt; The side allocation would store a pointer to the object and a strong refcount and a weak refcount. (This weak refcount would be distinct from the unowned refcount.)  The weak refcount would be incremented once for every weak variable holding this object. <br>&gt;&gt; <br>&gt;&gt; The advantage of using a side allocation for weak references is that the storage for a weakly-referenced object could be freed synchronously when deinit completes. Only the small side allocation would remain, backing the weak variables until they are cleared on their next access. This is a memory improvement over today&#39;s scheme, which keeps the object&#39;s entire storage alive for a potentially long time.<br>&gt;&gt; <br>&gt;&gt; The hierarchy:<br>&gt;&gt; Strong refcount goes to zero: deinit<br>&gt;&gt; Unowned refcount goes to zero: free the object<br>&gt;&gt; Weak refcount goes to zero: free the side allocation<br>&gt; <br>&gt; I take it the refcount field&#39;s pointer is itself considered a weak reference, so the weak refcount starts +1 like the unowned refcount does?<br></p><p>You need to do something to make sure the side allocation is not freed if the object is live with no weak references to it. Biasing the weak refcount might work. <br></p><p>It might be more robust to do something else, though. Ideally an incorrect weak reference decrement would deliberately log an underflow error and halt, instead of quietly freeing the side allocation out from under a live object.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; I take it the refcount field&#39;s pointer is itself considered a weak reference, so the weak refcount starts +1 like the unowned refcount does?<br>&gt; <br>&gt; You need to do something to make sure the side allocation is not freed if the object is live with no weak references to it. Biasing the weak refcount might work. <br>&gt; <br>&gt; It might be more robust to do something else, though. Ideally an incorrect weak reference decrement would deliberately log an underflow error and halt, instead of quietly freeing the side allocation out from under a live object.<br></p><p>The backreference from the side allocation could be used to indicate the object&#39;s liveness. Require the object to null that pointer before it performs its weak release; then if the weak refcount goes to zero before the backreference is null, you&#39;ve had an unbalanced release.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>March 16, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 11:59 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br></p><p>There are a lot of really good ideas.  I would like to see some quasi-specifics about the proposed bit layout of the inline reference count, however.  You said that there would still be an inline unowned reference count; is that now tracked independently of the weak reference count?  And do we still have an efficient fast path for testing uniquely-reference-or-pinned?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March 16, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Mar 16, 2016, at 2:23 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 15, 2016, at 11:59 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br>&gt; <br>&gt; There are a lot of really good ideas.  I would like to see some quasi-specifics about the proposed bit layout of the inline reference count, however.  You said that there would still be an inline unowned reference count; is that now tracked independently of the weak reference count?  And do we still have an efficient fast path for testing uniquely-reference-or-pinned?<br></p><p>I have been imagining something like this:<br></p><p>32-bit object without side allocation:<br>   (MSB)<br>       2 bits  00 (ordinary) or 11 (strong refcount is constant)<br>      20 bits  strong refcount<br>       1 bit   is deallocating<br>       1 bit   is pinned<br>       8 bits  unowned refcount and any other flags<br>   (LSB)<br></p><p>64-bit object without side allocation:<br>   (MSB)<br>       2 bits  00 (ordinary) or 11 (strong refcount is constant)<br>      28 bits  strong refcount<br>       1 bit   is deallocating<br>       1 bit   is pinned<br>      32 bits  unowned refcount and any other flags<br>   (LSB)<br></p><p>Object with side allocation:<br>   (MSB)<br>       2 bits  10<br>   ptr-2 bits  side allocation &gt;&gt; 2<br>   (LSB)<br></p><p>Side allocation:<br>     ptr bits  object<br>      30 bits  strong refcount<br>       1 bit   is deallocating<br>       1 bit   is pinned<br>      32 bits  unowned refcount<br>      32 bits  weak refcount<br>     ptr bits  associated reference table<br>     ptr bits  extension ivars<br>               ...etc<br></p><p>The uniquely-referenced-or-pinned check can use the same 1-bit rotate trick on 64-bit. On 32-bit it needs an extra shift first to throw away the unowned refcount and other flags. (We might be able to eliminate that shift if there are no other flags, by rearranging the fields and assuming that the unowned refcount will be zero for a uniquely-referenced object.)<br></p><p>On both architectures a constant-refcount object will appear to be multiply referenced. That sounds like the correct behavior for read-only objects (you wouldn&#39;t want to modify them in place anyway) but perhaps not the correct behavior for stack-allocated objects. <br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>March 16, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Mar 15, 2016, at 11:59 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br>&gt; <br>&gt; Today, each object stores 64-bits of refcounts and flags after the isa field.<br>&gt; <br>&gt; In this new system, each object would store a pointer-size field after the isa field. This field would have two cases: it could store refcounts and flags, or it could store a pointer to a side allocation that would store refcounts and flags and additional per-object data.<br>&gt; <br>&gt; Advantages:<br>&gt; * Saves 4 bytes per object on 32-bit for most objects.<br>&gt; * Improves refcount overflow and underflow detection.<br>&gt; * Might allow an inlineable retain/release fast path in the future.<br>&gt; * Allows a new weak reference implementation that doesn&#39;t need to keep entire dead objects alive.<br>&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br>&gt; <br>&gt; Disadvantages:<br>&gt; * Basic RR operations might be slower on x86_64. This needs to be measured. ARM architectures are probably unchanged.<br></p><p>I wrote a performance mockup of the fast path. It simply checks the MSB in the appropriate places in RefCount.h but does not actually implement any side allocation. I ran it on some RR-heavy benchmarks (QuickSort, InsertionSort, HeapSort, Array2D) on x86_64 and arm64.<br></p><p>arm64 is in fact approximately unchanged. Any difference either way is much less than 1%.<br></p><p>x86_64 is measurably slower:<br>   1% QuickSort<br>   2% InsertionSort<br>   4% Array2D<br>   5% HeapSort<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fbb2eb7db6aecac77ec563869540a874?s=50"></div><header><strong>[Discussion] New refcount representation</strong> from <string>Arnold</string> &lt;aschwaighofer at apple.com&gt;<p>March 17, 2016 at 09:00:00am</p></header><div class="content"><p>I think maybe we also want to measure how a cmpxchg vs lck;add solution performs under contention.<br></p><p>Objects in read only state (be it cow’ed value types or not) might be shared between threads with the expectation that they are fast, i.e. the argument if retain/release are contented something else is wrong does not apply.<br></p><p>A load/cmpxchg might sent two memory coherence messages (one for shared/exclusive for the load/ one for modified for the cmpxchg) and mispredicted branches (pipeline flush) on state change under contention might exhibit worse performance than a lck;add (one coherence message M, no misprediced branch) depending on how things are implemented under the hood. There is always an opportunity for another level of coherence speculation ….<br></p><p>Other benefits we get might outweigh any such cost though.<br></p><p><br>&gt; On Mar 16, 2016, at 11:29 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Mar 15, 2016, at 11:59 PM, Greg Parker via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am considering a new representation for Swift refcounts and other per-object data. This is an outline of the scheme. Comments and suggestions welcome.<br>&gt;&gt; <br>&gt;&gt; Today, each object stores 64-bits of refcounts and flags after the isa field.<br>&gt;&gt; <br>&gt;&gt; In this new system, each object would store a pointer-size field after the isa field. This field would have two cases: it could store refcounts and flags, or it could store a pointer to a side allocation that would store refcounts and flags and additional per-object data.<br>&gt;&gt; <br>&gt;&gt; Advantages:<br>&gt;&gt; * Saves 4 bytes per object on 32-bit for most objects.<br>&gt;&gt; * Improves refcount overflow and underflow detection.<br>&gt;&gt; * Might allow an inlineable retain/release fast path in the future.<br>&gt;&gt; * Allows a new weak reference implementation that doesn&#39;t need to keep entire dead objects alive.<br>&gt;&gt; * Allows inexpensive per-object storage for future features like associated references or class extensions with instance variables.<br>&gt;&gt; <br>&gt;&gt; Disadvantages:<br>&gt;&gt; * Basic RR operations might be slower on x86_64. This needs to be measured. ARM architectures are probably unchanged.<br>&gt; <br>&gt; I wrote a performance mockup of the fast path. It simply checks the MSB in the appropriate places in RefCount.h but does not actually implement any side allocation. I ran it on some RR-heavy benchmarks (QuickSort, InsertionSort, HeapSort, Array2D) on x86_64 and arm64.<br>&gt; <br>&gt; arm64 is in fact approximately unchanged. Any difference either way is much less than 1%.<br>&gt; <br>&gt; x86_64 is measurably slower:<br>&gt;   1% QuickSort<br>&gt;   2% InsertionSort<br>&gt;   4% Array2D<br>&gt;   5% HeapSort<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
