<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Idea: Let Generic Parameters Have Labels &amp; Default Values</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 23, 2016 at 12:00:00pm</p></header><div class="content"><p>The title seems fairly self-explanatory. Does anyone else think this could be useful?<br>struct True : BooleanType {…} // Just part of the example… not in the proposal (although I do like it)<br>struct False : BooleanType {…}  // Same<br>// This is where the actual idea starts<br>struct BigInt &lt;BaseType: T = Int, CanEqualZero: U = Yes where T: IntegerArithmeticType, U: BooleanType&gt; {…}<br></p><p>The first parameter label could be skipped (or not), depending on whatever the rules for functions parameter labels ends up being (either way, they should be the same IMHO). Then variables could be declared like this:<br>let foo =   BigInt()	    // BigInt&lt;Int, No&gt;()<br>let bar =   BigInt&lt;Int32&gt;() // For when your data will be processed on a 32-bit platform or something<br>let divisor = BigInt&lt;CanEqualZero: False&gt;()<br></p><p>(The obvious follow-up suggestion is to then allow a generic type’s definition to change based on the results of logical operations performed purely on the types that are passed in, but I think that’s getting into “macro system” territory, and should probably be its own thing.)<br></p><p>Anyway, thoughts?<br></p><p>- Dave Sweeris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160123/c176370b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Idea: Let Generic Parameters Have Labels &amp; Default Values</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>January 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi David,<br></p><p>&gt; struct BigInt &lt;BaseType: T = Int, CanEqualZero: U = Yes where T: IntegerArithmeticType, U: BooleanType&gt; {…}<br>Is the &quot;Yes&quot; an error and it should be &quot;True&quot; instead?<br></p><p>&gt; The first parameter label could be skipped (or not), depending on whatever the rules for functions parameter labels ends up being (either way, they should be the same IMHO).<br>I don&#39;t think the rules have to be identical:<br>Methods are often verbs, so often, there is a natural &quot;target&quot; whose meaning can be inferred from the method name.<br>Generics are different — they &quot;don&#39;t tell a story&quot;, and although there are situations where it seems one parameter is more relevant than the others (&quot;BaseType&quot; in you example), it would be odd to declare &quot;BigIntWithBaseType&lt;…&quot;.<br></p><p>I guess when there is a single parameter, its meaning is clear in most cases, but when you have more parameters, you cannot assume that the first should be treated different from the second (neither would it make sense to always treat them in the same way.<br></p><p>Every label useful:<br>let vector: Map&lt;Index = UInt, Content = Double&gt;<br></p><p>No label useful:<br>class Comparer&lt;L: BooleanType, R: BooleanType&gt;<br></p><p>It&#39;s to hard for the compiler to decide what should be done, and in such situations, my lazy solution is always &quot;leave the decision to the user&quot;.<br></p><p>I guess I&#39;m to slow building my stupid litte proposal — but even if I haven&#39;t written an example for instantiation yet, I came to the same conclusion that labels can be useful for generics  (https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters &lt;https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters&gt;).<br>Your use case might benefit from it as well: afaics, &quot;True&quot; and &quot;False&quot; are only there to &quot;lift&quot; true and false into type-space, qualifying them as parameters.<br></p><p>Please feel free to comment or even co-author on &quot;compile-time parameters&quot; — I&#39;m not sure I&#39;ll be bold enough to turn it into a real pull-request without external pressure ;-)<br>(afair, you already posted in the thread [&quot;typesafe calculations&quot;])<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/02cdeba7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Idea: Let Generic Parameters Have Labels &amp; Default Values</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 24, 2016 at 01:00:00pm</p></header><div class="content"><p>Response inlined...<br>&gt; On Jan 24, 2016, at 03:08, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; Hi David,<br>&gt; <br>&gt;&gt; struct BigInt &lt;BaseType: T = Int, CanEqualZero: U = Yes where T: IntegerArithmeticType, U: BooleanType&gt; {…}<br>&gt; Is the &quot;Yes&quot; an error and it should be &quot;True&quot; instead?<br>Yep. I guess that’s what I get for changing my mind half-way through writing something :-)<br></p><p>&gt;&gt; The first parameter label could be skipped (or not), depending on whatever the rules for functions parameter labels ends up being (either way, they should be the same IMHO).<br>&gt; I don&#39;t think the rules have to be identical:<br>&gt; Methods are often verbs, so often, there is a natural &quot;target&quot; whose meaning can be inferred from the method name.<br>&gt; Generics are different — they &quot;don&#39;t tell a story&quot;, and although there are situations where it seems one parameter is more relevant than the others (&quot;BaseType&quot; in you example), it would be odd to declare &quot;BigIntWithBaseType&lt;…&quot;.<br>&gt; <br>&gt; I guess when there is a single parameter, its meaning is clear in most cases, but when you have more parameters, you cannot assume that the first should be treated different from the second (neither would it make sense to always treat them in the same way.<br>&gt; <br>&gt; Every label useful:<br>&gt; let vector: Map&lt;Index = UInt, Content = Double&gt;<br>&gt; <br>&gt; No label useful:<br>&gt; class Comparer&lt;L: BooleanType, R: BooleanType&gt;<br>&gt; <br>&gt; It&#39;s to hard for the compiler to decide what should be done, and in such situations, my lazy solution is always &quot;leave the decision to the user&quot;.<br>I guess I hadn&#39;t enough thought to the formal syntax. What I&#39;d originally posted had a lot of colons by the time it was all typed out. Should we just copy the syntax from function arguments? So the external label would default to being the same as the parameter name, unless you put a &quot;_&quot; in front of it or provided a different one? Seems like a waste to come up with two different syntaxes for two concepts that are so similar (plus, I think of generics as &quot;compile-time arguments&quot; anyway).<br></p><p>Either way, I think parameters with default types would need to also have an external label, for the same reason that function arguments with default values can&#39;t externally be &quot;_&quot;.<br></p><p>And, as Andrew suggested, anything with an explicit external label gets implicitly typealiased.<br></p><p>&gt; I guess I&#39;m to slow building my stupid litte proposal — but even if I haven&#39;t written an example for instantiation yet, I came to the same conclusion that labels can be useful for generics  (https://github.com/SwiftTypesafeCalculations/Home/wiki/compile-time%20parameters).<br>&gt; Your use case might benefit from it as well: affairs, &quot;True&quot; and &quot;False&quot; are only there to &quot;lift&quot; true and false into type-space, qualifying them as parameters.<br>&gt; Please feel free to comment or even co-author on &quot;compile-time parameters&quot; — I&#39;m not sure I&#39;ll be bold enough to turn it into a real pull-request without external pressure ;-)<br>&gt; (afair, you already posted in the thread [&quot;typesafe calculations&quot;])<br>&gt; <br>&gt; Tino<br></p><p>Yeah, if that goes through (I really hope it does), those True/False types wouldn&#39;t be needed.<br></p><p>I&#39;ll take a closer look at your formal proposal as soon as I get a chance and let you know if I think I can contribute to it :-)<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160124/8c82ac6b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
