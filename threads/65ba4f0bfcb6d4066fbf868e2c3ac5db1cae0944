<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 17, 2016 at 05:00:00pm</p></header><div class="content"><p>I believe this affects the ABI (especially the second part), but if not, let me know and we can talk about it in phase 2...<br></p><p>There are times where you would like to call a specific implementation of a method.  One of the most common is calling super from a subclass, but you may want to do similar things when overriding a default implementation of a protocol.  I also have definitely had times where I wanted to call the implementation of an ancestor other than super.  It also solves some of the issues that came up during the non-subclassable by default discussion, because it allows you to statically dispatch to a known implementation in cases where you need that assurance, but don’t want to mark a method final.  (essentially it gives you the benefits of final for a single call)<br></p><p>Here are a couple of potential ideas on how to represent this (P represents a protocol or class ancestor type):<br></p><p>	varName.P::methodName<br></p><p>	varName.methodName using P<br></p><p><br>This is mainly to start a discussion, so feel free to counter-propose a better syntax, etc…<br></p><p>It seems fairly straightforward to me. The only objection that I remember coming up when this was discussed before was that the compiler had to keep some information around between modules that it wasn’t keeping around at the time (which is what makes me think it affects the ABI). <br></p><p>One complication which could come up is what happens when P is a variable holding a type instead of a constant type.  There are a few options:<br></p><p>1) Don’t allow such shenanigans (compiler error)<br></p><p>2) Dynamically dispatch based on a runtime check (trap at runtime if P is not an ancestor/conformed-to protocol)<br></p><p>3) Same as 2, except that the protocol conformance uses duck-typing<br></p><p>4) Same as 2/3, except the command is not executed instead of trapping<br></p><p>Of those options, 1 is the simplest, but 3 is my favorite, as it is the most powerful (but also has the largest impact on the ABI). 4 could co-exist with 2/3 by adding a ‘?’ variant of the syntax (e.g. varName.P?::methodName)<br></p><p>Thoughts?<br></p><p>Thanks,<br>Jon<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 17, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 5:46 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I believe this affects the ABI (especially the second part), but if not, let me know and we can talk about it in phase 2...<br>&gt; <br>&gt; There are times where you would like to call a specific implementation of a method.  One of the most common is calling super from a subclass, but you may want to do similar things when overriding a default implementation of a protocol.  I also have definitely had times where I wanted to call the implementation of an ancestor other than super.  It also solves some of the issues that came up during the non-subclassable by default discussion, because it allows you to statically dispatch to a known implementation in cases where you need that assurance, but don’t want to mark a method final.  (essentially it gives you the benefits of final for a single call)<br>&gt; <br>&gt; Here are a couple of potential ideas on how to represent this (P represents a protocol or class ancestor type):<br>&gt; <br>&gt; 	varName.P::methodName<br>&gt; <br>&gt; 	varName.methodName using P<br>&gt; <br>&gt; <br>&gt; This is mainly to start a discussion, so feel free to counter-propose a better syntax, etc…<br>&gt; <br>&gt; It seems fairly straightforward to me. The only objection that I remember coming up when this was discussed before was that the compiler had to keep some information around between modules that it wasn’t keeping around at the time (which is what makes me think it affects the ABI). <br>&gt; <br>&gt; One complication which could come up is what happens when P is a variable holding a type instead of a constant type.  There are a few options:<br>&gt; <br>&gt; 1) Don’t allow such shenanigans (compiler error)<br>&gt; <br>&gt; 2) Dynamically dispatch based on a runtime check (trap at runtime if P is not an ancestor/conformed-to protocol)<br>&gt; <br>&gt; 3) Same as 2, except that the protocol conformance uses duck-typing<br>&gt; <br>&gt; 4) Same as 2/3, except the command is not executed instead of trapping<br>&gt; <br>&gt; Of those options, 1 is the simplest, but 3 is my favorite, as it is the most powerful (but also has the largest impact on the ABI). 4 could co-exist with 2/3 by adding a ‘?’ variant of the syntax (e.g. varName.P?::methodName)<br>&gt; <br>&gt; Thoughts?<br></p><p>I think being able to name and call a specific protocol-extension method would be an interesting enhancement.<br></p><p>Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.  In every other language I know of, super dispatch is always restricted to the self object and only bypasses the overrides of the current class and its subclasses.  Of course there are runtime tricks you can play to get this in, say, ObjC, but I&#39;m not aware of them being frequently used.  I would really to see concrete evidence of this being useful and necessary before considering it any further.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>August 18, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On 18 Aug 2016, at 02:57, John McCall wrote:<br>&gt; <br>&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.  In every other language I know of, super dispatch is always restricted to the self object and only bypasses the overrides of the current class and its subclasses. Of course there are runtime tricks you can play to get this in, say, ObjC, but I&#39;m not aware of them being frequently used.  I would really to see concrete evidence of this being useful and necessary before considering it any further.<br></p><p>Doesn&#39;t this already exist as &quot;unapplied method references&quot; in Swift?<br></p><p>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md&gt;<br></p><p>SE-0042 isn&#39;t implemented yet, so maybe the curried version should be deprecated?<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 18, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 7:24 PM, Ben Rimmington &lt;me at benrimmington.com&gt; wrote:<br>&gt;&gt; On 18 Aug 2016, at 02:57, John McCall wrote:<br>&gt;&gt; <br>&gt;&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.  In every other language I know of, super dispatch is always restricted to the self object and only bypasses the overrides of the current class and its subclasses. Of course there are runtime tricks you can play to get this in, say, ObjC, but I&#39;m not aware of them being frequently used.  I would really to see concrete evidence of this being useful and necessary before considering it any further.<br>&gt; <br>&gt; Doesn&#39;t this already exist as &quot;unapplied method references&quot; in Swift?<br></p><p>Unapplied method references still dispatch down.  It&#39;s a pretty simple experiment to run for yourself.<br></p><p>John.<br></p><p>&gt; <br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md&gt;<br>&gt; <br>&gt; SE-0042 isn&#39;t implemented yet, so maybe the curried version should be deprecated?<br>&gt; <br>&gt; -- Ben<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bdd257c9369fb68e1d06923d10ff789e?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Ben Rimmington</string> &lt;me at benrimmington.com&gt;<p>August 19, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 18 Aug 2016, at 16:32, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; Unapplied method references still dispatch down.  It&#39;s a pretty simple experiment to run for yourself.<br></p><p>When I tried calling a specific superclass implementation, there was a stack overflow due to the infinite recursion.<br></p><p>	class Once {<br>	    func value() -&gt; Int {<br>	        return 1<br>	    }<br>	}<br></p><p>	class Twice: Once {<br>	    override func value() -&gt; Int {<br>	        return 2<br>	    }<br>	}<br></p><p>	class Thrice: Twice {<br>	    override func value() -&gt; Int {<br>	        return 3<br></p><p>	        // EXC_BAD_ACCESS:<br>	        // return Once.value(self)()<br>	    }<br>	}<br></p><p>	let once = Once()<br>	once.value()            //-&gt; 1<br>	Once.value(once)()      //-&gt; 1<br></p><p>	let twice = Twice()<br>	twice.value()           //-&gt; 2<br>	Once.value(twice)()     //-&gt; 2<br>	Twice.value(twice)()    //-&gt; 2<br></p><p>	let thrice = Thrice()<br>	thrice.value()          //-&gt; 3<br>	Once.value(thrice)()    //-&gt; 3<br>	Twice.value(thrice)()   //-&gt; 3<br>	Thrice.value(thrice)()  //-&gt; 3<br></p><p>-- Ben<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 18, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 8:21 PM, Ben Rimmington via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 18 Aug 2016, at 16:32, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unapplied method references still dispatch down.  It&#39;s a pretty simple experiment to run for yourself.<br>&gt; <br>&gt; When I tried calling a specific superclass implementation, there was a stack overflow due to the infinite recursion.<br></p><p>This is because calling Once.value() with an instance of Twice still dispatches to Twice::value().<br></p><p>&gt; <br>&gt; 	class Once {<br>&gt; 	    func value() -&gt; Int {<br>&gt; 	        return 1<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; 	class Twice: Once {<br>&gt; 	    override func value() -&gt; Int {<br>&gt; 	        return 2<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; 	class Thrice: Twice {<br>&gt; 	    override func value() -&gt; Int {<br>&gt; 	        return 3<br>&gt; <br>&gt; 	        // EXC_BAD_ACCESS:<br>&gt; 	        // return Once.value(self)()<br>&gt; 	    }<br>&gt; 	}<br>&gt; <br>&gt; 	let once = Once()<br>&gt; 	once.value()            //-&gt; 1<br>&gt; 	Once.value(once)()      //-&gt; 1<br>&gt; <br>&gt; 	let twice = Twice()<br>&gt; 	twice.value()           //-&gt; 2<br>&gt; 	Once.value(twice)()     //-&gt; 2<br>&gt; 	Twice.value(twice)()    //-&gt; 2<br>&gt; <br>&gt; 	let thrice = Thrice()<br>&gt; 	thrice.value()          //-&gt; 3<br>&gt; 	Once.value(thrice)()    //-&gt; 3<br>&gt; 	Twice.value(thrice)()   //-&gt; 3<br>&gt; 	Thrice.value(thrice)()  //-&gt; 3<br>&gt; <br>&gt; -- Ben<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>August 19, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Aug 17, 2016, at 6:57 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.<br></p><p>Perl 5 does, although of course its object system is a little bit...different.<br></p><p>What these languages have in common is multiple inheritance. Calling a specific superclass&#39;s implementation is necessary when you have more than one superclass. Swift doesn&#39;t have that problem with superclasses, but it *does* have it with protocol extension members.<br></p><p>My suggestion would be to allow you to call a particular protocol extension&#39;s implementation with:<br></p><p>	super(ProtocolName).method()<br></p><p>`super(Foo)` would always use the appropriate member on `Foo`, which must be a protocol (not a class name), and must be conformed to by this type (not by a superclass).  Unqualified `super` would only be valid in classes and would only permit calls to members of the superclass (including protocols it conforms to). That would permit access to default implementations without permitting encapsulation-breaking shenanigans, while leaving plain `super`&#39;s meaning unambiguous.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5942ce89a1d09816517080730cf5a10?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Félix Cloutier</string> &lt;felixcca at gmail.com&gt;<p>August 19, 2016 at 08:00:00am</p></header><div class="content"><p>What if two modules declare the same extension method?<br></p><p>Félix<br></p><p>&gt; Le 19 août 2016 à 03:06:23, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 6:57 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.<br>&gt; <br>&gt; Perl 5 does, although of course its object system is a little bit...different.<br>&gt; <br>&gt; What these languages have in common is multiple inheritance. Calling a specific superclass&#39;s implementation is necessary when you have more than one superclass. Swift doesn&#39;t have that problem with superclasses, but it *does* have it with protocol extension members.<br>&gt; <br>&gt; My suggestion would be to allow you to call a particular protocol extension&#39;s implementation with:<br>&gt; <br>&gt; 	super(ProtocolName).method()<br>&gt; <br>&gt; `super(Foo)` would always use the appropriate member on `Foo`, which must be a protocol (not a class name), and must be conformed to by this type (not by a superclass).  Unqualified `super` would only be valid in classes and would only permit calls to members of the superclass (including protocols it conforms to). That would permit access to default implementations without permitting encapsulation-breaking shenanigans, while leaving plain `super`&#39;s meaning unambiguous.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 19, 2016 at 10:00:00pm</p></header><div class="content"><p>A agree with John. Imagine <br></p><p>class A {<br>    func foo() -&gt; Int {<br>        return bar()<br>    }<br>    func bar() -&gt; Int {<br>        return 0<br>    }<br>}<br></p><p>class B {<br>    override foo() -&gt; Int {<br>	return bar() + 1<br>    }   <br>    overr func bar() -&gt; Int {<br>        return 32<br>    }<br>}<br></p><p>What would A(foo) return? Some would say that 0, some that 32...<br></p><p><br>&gt; On Aug 19, 2016, at 5:14 PM, Félix Cloutier via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; What if two modules declare the same extension method?<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 19 août 2016 à 03:06:23, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 17, 2016, at 6:57 PM, John McCall via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.<br>&gt;&gt; <br>&gt;&gt; Perl 5 does, although of course its object system is a little bit...different.<br>&gt;&gt; <br>&gt;&gt; What these languages have in common is multiple inheritance. Calling a specific superclass&#39;s implementation is necessary when you have more than one superclass. Swift doesn&#39;t have that problem with superclasses, but it *does* have it with protocol extension members.<br>&gt;&gt; <br>&gt;&gt; My suggestion would be to allow you to call a particular protocol extension&#39;s implementation with:<br>&gt;&gt; <br>&gt;&gt; 	super(ProtocolName).method()<br>&gt;&gt; <br>&gt;&gt; `super(Foo)` would always use the appropriate member on `Foo`, which must be a protocol (not a class name), and must be conformed to by this type (not by a superclass).  Unqualified `super` would only be valid in classes and would only permit calls to members of the superclass (including protocols it conforms to). That would permit access to default implementations without permitting encapsulation-breaking shenanigans, while leaving plain `super`&#39;s meaning unambiguous.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>August 19, 2016 at 12:00:00pm</p></header><div class="content"><p>For my own education, how is does it break the encapsulation in a way which subclassing does not?  I may not have mentioned it, but in my mind, this construct would be limited by the compiler to being called from within a conforming type (in the same way super is).  Given that, it seems to me that the considerations by both the ancestor class and the subclass would be exactly the same as in a super-subclass relationship.  I agree that it wouldn’t be a frequent use case, but I have definitely had times where it would have greatly simplified my class structure if allowed.  I don’t see any reason to limit it (beyond the needs of the type), but I could easily be missing something fairly obvious...<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Aug 17, 2016, at 6:57 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 5:46 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I believe this affects the ABI (especially the second part), but if not, let me know and we can talk about it in phase 2...<br>&gt;&gt; <br>&gt;&gt; There are times where you would like to call a specific implementation of a method.  One of the most common is calling super from a subclass, but you may want to do similar things when overriding a default implementation of a protocol.  I also have definitely had times where I wanted to call the implementation of an ancestor other than super.  It also solves some of the issues that came up during the non-subclassable by default discussion, because it allows you to statically dispatch to a known implementation in cases where you need that assurance, but don’t want to mark a method final.  (essentially it gives you the benefits of final for a single call)<br>&gt;&gt; <br>&gt;&gt; Here are a couple of potential ideas on how to represent this (P represents a protocol or class ancestor type):<br>&gt;&gt; <br>&gt;&gt; 	varName.P::methodName<br>&gt;&gt; <br>&gt;&gt; 	varName.methodName using P<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This is mainly to start a discussion, so feel free to counter-propose a better syntax, etc…<br>&gt;&gt; <br>&gt;&gt; It seems fairly straightforward to me. The only objection that I remember coming up when this was discussed before was that the compiler had to keep some information around between modules that it wasn’t keeping around at the time (which is what makes me think it affects the ABI). <br>&gt;&gt; <br>&gt;&gt; One complication which could come up is what happens when P is a variable holding a type instead of a constant type.  There are a few options:<br>&gt;&gt; <br>&gt;&gt; 1) Don’t allow such shenanigans (compiler error)<br>&gt;&gt; <br>&gt;&gt; 2) Dynamically dispatch based on a runtime check (trap at runtime if P is not an ancestor/conformed-to protocol)<br>&gt;&gt; <br>&gt;&gt; 3) Same as 2, except that the protocol conformance uses duck-typing<br>&gt;&gt; <br>&gt;&gt; 4) Same as 2/3, except the command is not executed instead of trapping<br>&gt;&gt; <br>&gt;&gt; Of those options, 1 is the simplest, but 3 is my favorite, as it is the most powerful (but also has the largest impact on the ABI). 4 could co-exist with 2/3 by adding a ‘?’ variant of the syntax (e.g. varName.P?::methodName)<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; I think being able to name and call a specific protocol-extension method would be an interesting enhancement.<br>&gt; <br>&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.  In every other language I know of, super dispatch is always restricted to the self object and only bypasses the overrides of the current class and its subclasses.  Of course there are runtime tricks you can play to get this in, say, ObjC, but I&#39;m not aware of them being frequently used.  I would really to see concrete evidence of this being useful and necessary before considering it any further.<br>&gt; <br>&gt; John.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/b7070adc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 12:56 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; For my own education, how is does it break the encapsulation in a way which subclassing does not?  I may not have mentioned it, but in my mind, this construct would be limited by the compiler to being called from within a conforming type (in the same way super is).  Given that, <br></p><p>You did not, in fact, mention that. :)  Like &quot;super&quot;, you would still want to restrict this to &quot;self&quot;, or at the very least to only objects of your own class type, so that you can&#39;t just make a subclass and then apply it to an arbitrary object.<br></p><p>In that case, it&#39;s basically just super dispatch, except that you can go to an arbitrary protocol-extension implementation.  (Unless you really want to be able to skip your superclass&#39;s implementation, which is encapsulation-breaking again.)<br></p><p>John. <br></p><p>&gt; it seems to me that the considerations by both the ancestor class and the subclass would be exactly the same as in a super-subclass relationship.  I agree that it wouldn’t be a frequent use case, but I have definitely had times where it would have greatly simplified my class structure if allowed.  I don’t see any reason to limit it (beyond the needs of the type), but I could easily be missing something fairly obvious...<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; On Aug 17, 2016, at 6:57 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 17, 2016, at 5:46 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe this affects the ABI (especially the second part), but if not, let me know and we can talk about it in phase 2...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are times where you would like to call a specific implementation of a method.  One of the most common is calling super from a subclass, but you may want to do similar things when overriding a default implementation of a protocol.  I also have definitely had times where I wanted to call the implementation of an ancestor other than super.  It also solves some of the issues that came up during the non-subclassable by default discussion, because it allows you to statically dispatch to a known implementation in cases where you need that assurance, but don’t want to mark a method final.  (essentially it gives you the benefits of final for a single call)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are a couple of potential ideas on how to represent this (P represents a protocol or class ancestor type):<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	varName.P::methodName<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	varName.methodName using P<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is mainly to start a discussion, so feel free to counter-propose a better syntax, etc…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems fairly straightforward to me. The only objection that I remember coming up when this was discussed before was that the compiler had to keep some information around between modules that it wasn’t keeping around at the time (which is what makes me think it affects the ABI). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One complication which could come up is what happens when P is a variable holding a type instead of a constant type.  There are a few options:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Don’t allow such shenanigans (compiler error)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2) Dynamically dispatch based on a runtime check (trap at runtime if P is not an ancestor/conformed-to protocol)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3) Same as 2, except that the protocol conformance uses duck-typing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 4) Same as 2/3, except the command is not executed instead of trapping<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of those options, 1 is the simplest, but 3 is my favorite, as it is the most powerful (but also has the largest impact on the ABI). 4 could co-exist with 2/3 by adding a ‘?’ variant of the syntax (e.g. varName.P?::methodName)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; I think being able to name and call a specific protocol-extension method would be an interesting enhancement.<br>&gt;&gt; <br>&gt;&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.  In every other language I know of, super dispatch is always restricted to the self object and only bypasses the overrides of the current class and its subclasses.  Of course there are runtime tricks you can play to get this in, say, ObjC, but I&#39;m not aware of them being frequently used.  I would really to see concrete evidence of this being useful and necessary before considering it any further.<br>&gt;&gt; <br>&gt;&gt; John.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/487e56d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Calling a Specific Implementation</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>August 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 1:10 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; On Aug 19, 2016, at 12:56 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; For my own education, how is does it break the encapsulation in a way which subclassing does not?  I may not have mentioned it, but in my mind, this construct would be limited by the compiler to being called from within a conforming type (in the same way super is).  Given that, <br>&gt; <br>&gt; You did not, in fact, mention that. :)  Like &quot;super&quot;, you would still want to restrict this to &quot;self&quot;, or at the very least to only objects of your own class type, so that you can&#39;t just make a subclass and then apply it to an arbitrary object.<br>&gt; <br>&gt; In that case, it&#39;s basically just super dispatch, except that you can go to an arbitrary protocol-extension implementation.  (Unless you really want to be able to skip your superclass&#39;s implementation, which is encapsulation-breaking again.)<br></p><p>Although I suppose we could allow this kind of explicit encapsulation-break when you&#39;re in the right access-control scope, assuming it&#39;s really useful.<br></p><p>John.<br></p><p>&gt; <br>&gt; John. <br>&gt; <br>&gt;&gt; it seems to me that the considerations by both the ancestor class and the subclass would be exactly the same as in a super-subclass relationship.  I agree that it wouldn’t be a frequent use case, but I have definitely had times where it would have greatly simplified my class structure if allowed.  I don’t see any reason to limit it (beyond the needs of the type), but I could easily be missing something fairly obvious...<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 17, 2016, at 6:57 PM, John McCall &lt;rjmccall at apple.com &lt;mailto:rjmccall at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 17, 2016, at 5:46 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe this affects the ABI (especially the second part), but if not, let me know and we can talk about it in phase 2...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are times where you would like to call a specific implementation of a method.  One of the most common is calling super from a subclass, but you may want to do similar things when overriding a default implementation of a protocol.  I also have definitely had times where I wanted to call the implementation of an ancestor other than super.  It also solves some of the issues that came up during the non-subclassable by default discussion, because it allows you to statically dispatch to a known implementation in cases where you need that assurance, but don’t want to mark a method final.  (essentially it gives you the benefits of final for a single call)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are a couple of potential ideas on how to represent this (P represents a protocol or class ancestor type):<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	varName.P::methodName<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	varName.methodName using P<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is mainly to start a discussion, so feel free to counter-propose a better syntax, etc…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems fairly straightforward to me. The only objection that I remember coming up when this was discussed before was that the compiler had to keep some information around between modules that it wasn’t keeping around at the time (which is what makes me think it affects the ABI). <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One complication which could come up is what happens when P is a variable holding a type instead of a constant type.  There are a few options:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Don’t allow such shenanigans (compiler error)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2) Dynamically dispatch based on a runtime check (trap at runtime if P is not an ancestor/conformed-to protocol)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3) Same as 2, except that the protocol conformance uses duck-typing<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 4) Same as 2/3, except the command is not executed instead of trapping<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of those options, 1 is the simplest, but 3 is my favorite, as it is the most powerful (but also has the largest impact on the ABI). 4 could co-exist with 2/3 by adding a ‘?’ variant of the syntax (e.g. varName.P?::methodName)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thoughts?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think being able to name and call a specific protocol-extension method would be an interesting enhancement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Being able to bypass another class&#39;s overrides and jump to a specific superclass implementation on an arbitrary method call is badly encapsulation-breaking, and I can&#39;t think of any OO language with first-class support for it besides C++.  In every other language I know of, super dispatch is always restricted to the self object and only bypasses the overrides of the current class and its subclasses.  Of course there are runtime tricks you can play to get this in, say, ObjC, but I&#39;m not aware of them being frequently used.  I would really to see concrete evidence of this being useful and necessary before considering it any further.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John.<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160819/e5c9b52d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
