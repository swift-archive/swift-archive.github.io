<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Manifesto] Completing Generics</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>March  3, 2016 at 04:00:00pm</p></header><div class="content"><p>on Wed Mar 02 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This message expands upon the notion of “completing generics”. It is<br>&gt; not a plan for Swift 3, nor an official core team communication, but<br>&gt; it collects the results of numerous discussions among the core team<br>&gt; and Swift developers, both of the compiler and the standard library. I<br>&gt; hope to achieve several things:<br>&gt;<br>&gt;   * Communicate a vision for Swift generics, building on the original<br>&gt;     generics design document, so we have something concrete and<br>&gt;     comprehensive to discuss.<br></p><p>One thing I&#39;d like to see in here, that I don&#39;t, is something about<br>where generics are supposed to fit into the performance model.  In<br>particular, with the advent of resilience and the coming end of<br>pervasive automatic inlining and specialization, I worry that generics<br>will not continue to be a viable way to write highly generalized code<br>that is also high-performance.  I think I know some ways we can avoid<br>this fate, but as far as I know we have no plans in place to do so.<br></p><p>&gt;   * Establish some terminology that the Swift developers have been<br>&gt;     using for these features, so our discussions can be more productive<br>&gt;     (“oh, you’re proposing what we refer to as ‘conditional<br>&gt;     conformances’; go look over at this thread”).<br>&gt;<br>&gt;   * Engage more of the community in discussions of specific generics<br>&gt;     features, so we can coalesce around designs for public review. And<br>&gt;     maybe even get some of them implemented.<br>&gt;<br>&gt; A message like this can easily turn into a centithread. To separate<br>&gt; concerns in our discussion, I ask that replies to this specific thread<br>&gt; be limited to discussions of the vision as a whole: how the pieces fit<br>&gt; together, what pieces are missing, whether this is the right long-term<br>&gt; vision for Swift, and so on. For discussions of specific language<br>&gt; features, e.g., to work out the syntax and semantics of conditional<br>&gt; conformances or discuss the implementation in compiler or use in the<br>&gt; standard library, please start a new thread based on the feature names<br>&gt; I’m using.<br>&gt;<br>&gt; This message covers a lot of ground; I’ve attempted a rough<br>&gt; categorization of the various features, and kept the descriptions<br>&gt; brief to limit the overall length. Most of these aren’t my ideas, and<br>&gt; any syntax I’m providing is simply a way to express these ideas in<br>&gt; code and is subject to change. Not all of these features will happen,<br>&gt; either soon or ever, but they are intended to be a fairly complete<br>&gt; whole that should mesh together. I’ve put a * next to features that I<br>&gt; think are important in the nearer term vs. being interesting “some<br>&gt; day”. Mostly, the *’s reflect features that will have a significant<br>&gt; impact on the Swift standard library’s design and implementation.<br>&gt;<br>&gt; Enough with the disclaimers; it’s time to talk features.<br>&gt;<br>&gt; Removing unnecessary restrictions<br>&gt;<br>&gt; There are a number of restrictions to the use of generics that fall<br>&gt; out of the implementation in the Swift compiler.  Removal of these<br>&gt; restrictions is a matter of implementation only; one need not<br>&gt; introduce new syntax or semantics to realize them. I’m listing them<br>&gt; for two reasons: first, it’s an acknowledgment that these features are<br>&gt; intended to exist in the model we have today, and, second, we’d love<br>&gt; help with the implementation of these features.<br>&gt;<br>&gt; *Recursive protocol constraints<br>&gt;<br>&gt; Currently, an associated type cannot be required to conform to its<br>&gt; enclosing protocol (or any protocol that inherits that protocol). For<br>&gt; example, in the standard library SubSequence type of a Sequence should<br>&gt; itself be a Sequence:<br>&gt;<br>&gt;     protocol Sequence {<br>&gt;       associatedtype Iterator : IteratorProtocol<br>&gt;       …<br>&gt;       associatedtype SubSequence : Sequence   // currently ill-formed, but should be possible<br>&gt;     }<br>&gt;<br>&gt; The compiler currently rejects this protocol, which is unfortunate: it<br>&gt; effectively pushes the SubSequence-must-be-a-Sequence requirement into<br>&gt; every consumer of SubSequence, and does not communicate the intent of<br>&gt; this abstraction well.<br>&gt;<br>&gt; Nested generics<br>&gt;<br>&gt; Currently, a generic type cannot be nested within another generic type, e.g.<br>&gt;<br>&gt;     struct X&lt;T&gt; {<br>&gt;       struct Y&lt;U&gt; { }  // currently ill-formed, but should be possible<br>&gt;     }<br>&gt;<br>&gt; There isn’t much to say about this: the compiler simply needs to be<br>&gt; improved to handle nested generics throughout.<br>&gt;<br>&gt; Concrete same-type requirements<br>&gt;<br>&gt; Currently, a constrained extension cannot use a same-type constraint<br>&gt; to make a type parameter equivalent to a concrete type. For example:<br>&gt;<br>&gt;     extension Array where Element == String {<br>&gt;       func makeSentence() -&gt; String {<br>&gt;         // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; This is a highly-requested feature that fits into the existing syntax<br>&gt; and semantics. Note that one could imagine introducing new syntax,<br>&gt; e.g., extending “Array&lt;String&gt;”, which gets into new-feature<br>&gt; territory: see the section on “Parameterized extensions”.<br>&gt;<br>&gt; Parameterizing other declarations<br>&gt;<br>&gt; There are a number of Swift declarations that currently cannot have<br>&gt; generic parameters; some of those have fairly natural extensions to<br>&gt; generic forms that maintain their current syntax and semantics, but<br>&gt; become more powerful when made generic.<br>&gt;<br>&gt; Generic typealiases<br>&gt;<br>&gt; Typealiases could be allowed to carry generic parameters. They would<br>&gt; still be aliases (i.e., they would not introduce new types). For<br>&gt; example:<br>&gt;<br>&gt;     typealias StringDictionary&lt;Value&gt; = Dictionary&lt;String, Value&gt;<br>&gt;    <br>&gt;     var d1 = StringDictionary&lt;Int&gt;()<br>&gt;     var d2: Dictionary&lt;String, Int&gt; = d1 // okay: d1 and d2 have the same type, Dictionary&lt;String, Int&gt;<br>&gt;<br>&gt; Generic subscripts<br>&gt;<br>&gt; Subscripts could be allowed to have generic parameters. For example,<br>&gt; we could introduce a generic subscript on a Collection that allows us<br>&gt; to pull out the values at an arbitrary set of indices:<br>&gt;<br>&gt;     extension Collection {<br>&gt;       subscript&lt;Indices: Sequence where Indices.Iterator.Element == Index&gt;(indices: Indices) -&gt; [Iterator.Element] {<br>&gt;         get {<br>&gt;           var result = [Iterator.Element]()<br>&gt;           for index in indices {<br>&gt;             result.append(self[index])<br>&gt;           }<br>&gt;    <br>&gt;           return result<br>&gt;         }<br>&gt;    <br>&gt;         set {<br>&gt;           for (index, value) in zip(indices, newValue) {<br>&gt;             self[index] = value<br>&gt;           }<br>&gt;         }<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; Generic constants<br>&gt;<br>&gt; let constants could be allowed to have generic parameters, such that<br>&gt; they produce differently-typed values depending on how they are<br>&gt; used. For example, this is particularly useful for named literal<br>&gt; values, e.g.,<br>&gt;<br>&gt;     let π&lt;T : FloatLiteralConvertible&gt;: T = 3.141592653589793238462643383279502884197169399<br>&gt;<br>&gt; The Clang importer could make particularly good use of this when<br>&gt; importing macros.<br>&gt;<br>&gt; Parameterized extensions<br></p><p>Aren&#39;t you missing a &#39;*&#39; on this one?<br></p><p>&gt; Extensions themselves could be parameterized, which would allow some<br>&gt; structural pattern matching on types. For example, this would permit<br>&gt; one to extend an array of optional values, e.g.,<br>&gt;<br>&gt;     extension&lt;T&gt; Array where Element == T? {<br>&gt;       var someValues: [T] {<br>&gt;         var result = [T]()<br>&gt;         for opt in self {<br>&gt;           if let value = opt { result.append(value) }<br>&gt;         }<br>&gt;        return result<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; We can generalize this to a protocol extensions:<br>&gt;<br>&gt;     extension&lt;T&gt; Sequence where Element == T? {<br>&gt;       var someValues: [T] {<br>&gt;         var result = [T]()<br>&gt;         for opt in self {<br>&gt;           if let value = opt { result.append(value) }<br>&gt;         }<br>&gt;        return result<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; Note that when one is extending nominal types, we could simplify the<br>&gt; syntax somewhat to make the same-type constraint implicit in the<br>&gt; syntax:<br>&gt;<br>&gt;     extension&lt;T&gt; Array&lt;T?&gt; {<br>&gt;       var someValues: [T] {<br>&gt;         var result = [T]()<br>&gt;         for opt in self {<br>&gt;           if let value = opt { result.append(value) }<br>&gt;         }<br>&gt;        return result<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; When we’re working with concrete types, we can use that syntax to<br>&gt; improve the extension of concrete versions of generic types (per<br>&gt; “Concrete same-type requirements”, above), e.g.,<br>&gt;<br>&gt;     extension Array&lt;String&gt; {<br>&gt;       func makeSentence() -&gt; String {<br>&gt;         // uppercase first string, concatenate with spaces, add a period, whatever<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; Minor extensions<br>&gt;<br>&gt; There are a number of minor extensions we can make to the generics<br>&gt; system that don’t fundamentally change what one can express in Swift,<br>&gt; but which can improve its expressivity.<br>&gt;<br>&gt; *Arbitrary requirements in protocols<br></p><p>I guess I don&#39;t see how this can be both something that doesn&#39;t<br>fundamentally change expressivity and something that will have a big<br>impact on the face of the standard library.<br></p><p>&gt; Currently, a new protocol can inherit from other protocols, introduce<br>&gt; new associated types, and add new conformance constraints to<br>&gt; associated types (by redeclaring an associated type from an inherited<br>&gt; protocol). However, one cannot express more general<br>&gt; constraints. Building on the example from “Recursive protocol<br>&gt; constraints”, we really want the element type of a Sequence’s<br>&gt; SubSequence to be the same as the element type of the Sequence, e.g.,<br>&gt;<br>&gt;     protocol Sequence {<br>&gt;       associatedtype Iterator : IteratorProtocol<br>&gt;       …<br>&gt;       associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     }<br>&gt;<br>&gt; Hanging the where clause off the associated type is protocol not<br>&gt; ideal, but that’s a discussion for another thread.<br>&gt;<br>&gt; *Typealiases in protocols and protocol extensions<br>&gt;<br>&gt; Now that associated types have their own keyword (thanks!), it’s<br>&gt; reasonable to bring back “typealias”. Again with the Sequence<br>&gt; protocol:<br>&gt;<br>&gt;     protocol Sequence {<br>&gt;       associatedtype Iterator : IteratorProtocol<br>&gt;       typealias Element = Iterator.Element   // rejoice! now we can refer to SomeSequence.Element rather than<br>&gt;     SomeSequence.Iterator.Element<br>&gt;     }<br></p><p>Is this something you expect to be customizable for a particular<br>conformance?  If not, I&#39;m not sure it belongs in the protocol body (as<br>opposed to an extension)... or we need to draw a clearer distinction<br>between implementable requirements and things that are currently in<br>extensions.<br></p><p>&gt; Default generic arguments <br>&gt;<br>&gt; Generic parameters could be given the ability to provide default<br>&gt; arguments, which would be used in cases where the type argument is not<br>&gt; specified and type inference could not determine the type<br>&gt; argument. For example:<br>&gt;<br>&gt;     public final class Promise&lt;Value, Reason=Error&gt; { … }<br>&gt;    <br>&gt;     func getRandomPromise() -&gt; Promise&lt;Int, ErrorProtocol&gt; { … }<br>&gt;    <br>&gt;     var p1: Promise&lt;Int&gt; = …<br>&gt;     var p2: Promise&lt;Int, Error&gt; = p1     // okay: p1 and p2 have the same type Promise&lt;Int, Error&gt;<br>&gt;     var p3: Promise = getRandomPromise() // p3 has type Promise&lt;Int, ErrorProtocol&gt; due to type inference<br>&gt;<br>&gt; Generalized “class” constraints<br>&gt;<br>&gt; The “class” constraint can currently only be used for defining<br>&gt; protocols. We could generalize it to associated type and type<br>&gt; parameter declarations, e.g.,<br>&gt;<br>&gt;     protocol P {<br>&gt;       associatedtype A : class<br>&gt;     }<br>&gt;    <br>&gt;     func foo&lt;T : class&gt;(t: T) { }<br>&gt;<br>&gt; As part of this, the magical AnyObject protocol could be replaced with<br>&gt; an existential with a class bound, so that it becomes a typealias:<br>&gt;<br>&gt;     typealias AnyObject = protocol&lt;class&gt;<br>&gt;<br>&gt; See the “Existentials” section, particularly “Generalized<br>&gt; existentials”, for more information.<br></p><p>I don&#39;t see the “value” constraint mentioned.  I realize this has some<br>larger implications in the language but it seems like the obvious dual<br>of this one.<br></p><p>&gt; *Allowing subclasses to override requirements satisfied by defaults<br>&gt;<br>&gt; When a superclass conforms to a protocol and has one of the protocol’s<br>&gt; requirements satisfied by a member of a protocol extension, that<br>&gt; member currently cannot be overridden by a subclass. For example:<br>&gt;<br>&gt;     protocol P {<br>&gt;       func foo()<br>&gt;     }<br>&gt;    <br>&gt;     extension P {<br>&gt;       func foo() { print(“P”) }<br>&gt;     }<br>&gt;    <br>&gt;     class C : P {<br>&gt;       // gets the protocol extension’s <br>&gt;     }<br>&gt;    <br>&gt;     class D : C {<br>&gt;       /*override not allowed!*/ func foo() { print(“D”) }<br>&gt;     }<br>&gt;    <br>&gt;     let p: P = D()<br>&gt;     p.foo() // gotcha: prints “P” rather than “D”!<br>&gt;<br>&gt; D.foo should be required to specify “override” and should be called<br>&gt; dynamically.<br>&gt;<br>&gt; Major extensions to the generics model<br>&gt;<br>&gt; Unlike the minor extensions, major extensions to the generics model<br>&gt; provide more expressivity in the Swift generics system and, generally,<br>&gt; have a much more significant design and implementation cost.<br>&gt;<br>&gt; *Conditional conformances<br>&gt;<br>&gt; Conditional conformances express the notion that a generic type will<br>&gt; conform to a particular protocol only under certain circumstances. For<br>&gt; example, Array is Equatable only when its elements are Equatable:<br>&gt;<br>&gt;     extension Array : Equatable where Element : Equatable { }<br>&gt;    <br>&gt;     func ==&lt;T : Equatable&gt;(lhs: Array&lt;T&gt;, rhs: Array&lt;T&gt;) -&gt; Bool { … }<br>&gt;<br>&gt; Conditional conformances are a potentially very powerful feature. One<br>&gt; important aspect of this feature is how deal with or avoid overlapping<br>&gt; conformances. For example, imagine an adaptor over a Sequence that has<br>&gt; conditional conformances to Collection and MutableCollection:<br>&gt;<br>&gt;     struct SequenceAdaptor&lt;S: Sequence&gt; : Sequence { }<br>&gt;     extension SequenceAdaptor : Collection where S: Collection { … }<br>&gt;     extension SequenceAdaptor : MutableCollection where S: MutableCollection { }<br>&gt;<br>&gt; This should almost certainly be permitted, but we need to cope with or<br>&gt; reject “overlapping” conformances:<br>&gt;<br>&gt;     extension SequenceAdaptor : Collection where S: SomeOtherProtocolSimilarToCollection { } // trouble: two ways<br></p><p>Missing generic parameter list here?<br></p><p>&gt;     for SequenceAdaptor to conform to Collection<br>&gt;<br>&gt; See the section on “Private conformances” for more about the issues<br>&gt; with having the same type conform to the same protocol multiple times.<br>&gt;<br>&gt; Variadic generics<br>&gt;<br>&gt; Currently, a generic parameter list contains a fixed number of generic<br>&gt; parameters. If one has a type that could generalize to any number of<br>&gt; generic parameters, the only real way to deal with it today involves<br>&gt; creating a set of types. For example, consider the standard library’s<br>&gt; “zip” function. It returns one of these when provided with two<br>&gt; arguments to zip together:<br>&gt;<br>&gt;     public struct Zip2Sequence&lt;Sequence1 : Sequence,<br>&gt;                                Sequence2 : Sequence&gt; : Sequence { … }<br>&gt;    <br>&gt;     public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence&gt;(<br>&gt;                   sequence1: Sequence1, _ sequence2: Sequence2)<br>&gt;                 -&gt; Zip2Sequence&lt;Sequence1, Sequence2&gt; { … }<br>&gt;<br>&gt; Supporting three arguments would require copy-paste of those of those:<br>&gt;<br>&gt;     public struct Zip3Sequence&lt;Sequence1 : Sequence,<br>&gt;                                Sequence2 : Sequence,<br>&gt;                                Sequence3 : Sequence&gt; : Sequence { … }<br>&gt;    <br>&gt;     public func zip&lt;Sequence1 : Sequence, Sequence2 : Sequence, Sequence3 : Sequence&gt;(<br>&gt;                   sequence1: Sequence1, _ sequence2: Sequence2, _ sequence3: sequence3)<br>&gt;                 -&gt; Zip3Sequence&lt;Sequence1, Sequence2, Sequence3&gt; { … }<br>&gt;<br>&gt; Variadic generics would allow us to abstract over a set of generic<br>&gt; parameters. The syntax below is hopelessly influenced by C++11<br>&gt; variadic templates (sorry), where putting an ellipsis (“…”) to the<br>&gt; left of a declaration makes it a “parameter pack” containing zero or<br>&gt; more parameters and putting an ellipsis to the right of a<br>&gt; type/expression/ etc. expands the parameter packs within that<br>&gt; type/expression into separate arguments. The important part is that we<br>&gt; be able to meaningfully abstract over zero or more generic parameters,<br>&gt; e.g.:<br>&gt;<br>&gt;     public struct ZipIterator&lt;... Iterators : IteratorProtocol&gt; : Iterator {  // zero or more type parameters, each<br>&gt;     of which conforms to IteratorProtocol<br>&gt;       public typealias Element = (Iterators.Element...)                       // a tuple containing the element<br>&gt;     types of each iterator in Iterators<br>&gt;    <br>&gt;       var (...iterators): (Iterators...)    // zero or more stored properties, one for each type in Iterators <br>&gt;       var reachedEnd: Bool = false<br>&gt;<br>&gt;       public mutating func next() -&gt; Element? {<br>&gt;<br>&gt;         if reachedEnd { return nil }<br>&gt;<br>&gt;         guard let values = (iterators.next()...) {   // call “next” on each of the iterators, put the results into a<br>&gt;     tuple named “values&quot;<br>&gt;<br>&gt;           reachedEnd = true<br>&gt;<br>&gt;           return nil<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         return values<br>&gt;<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt;     public struct ZipSequence&lt;...Sequences : Sequence&gt; : Sequence {<br>&gt;       public typealias Iterator = ZipIterator&lt;Sequences.Iterator...&gt;   // get the zip iterator with the iterator<br>&gt;     types of our Sequences<br>&gt;    <br>&gt;       var (...sequences): (Sequences...)    // zero or more stored properties, one for each type in Sequences <br>&gt;    <br>&gt;       // details ...<br>&gt;     }<br>&gt;<br>&gt; Such a design could also work for function parameters, so we can pack<br>&gt; together multiple function arguments with different types, e.g.,<br>&gt;<br>&gt;     public func zip&lt;... Sequences : SequenceType&gt;(... sequences: Sequences...) <br>&gt;                 -&gt; ZipSequence&lt;Sequences...&gt; {<br>&gt;       return ZipSequence(sequences...)<br>&gt;     }<br>&gt;<br>&gt; Finally, this could tie into the discussions about a tuple “splat”<br>&gt; operator. For example:<br>&gt;<br>&gt;     func apply&lt;... Args, Result&gt;(fn: (Args...) -&gt; Result,    // function taking some number of arguments and<br>&gt;     producing Result<br>&gt;                                args: (Args...)) -&gt; Result {  // tuple of arguments<br>&gt;       return fn(args...)                                     // expand the arguments in the tuple “args” into<br>&gt;     separate arguments<br>&gt;     }<br>&gt;<br>&gt; Extensions of structural types<br>&gt;<br>&gt; Currently, only nominal types (classes, structs, enums, protocols) can<br>&gt; be extended. One could imagine extending structural types—particularly<br>&gt; tuple types—to allow them to, e.g., conform to protocols. For example,<br>&gt; pulling together variadic generics, parameterized extensions, and<br>&gt; conditional conformances, one could express “a tuple type is Equatable<br>&gt; if all of its element types are Equatable”:<br>&gt;<br>&gt;     extension&lt;...Elements : Equatable&gt; (Elements...) : Equatable {   // extending the tuple type “(Elements…)” to be<br>&gt;     Equatable<br>&gt;     }<br>&gt;<br>&gt; There are some natural bounds here: one would need to have actual<br>&gt; structural types. One would not be able to extend every type:<br>&gt;<br>&gt;     extension&lt;T&gt; T { // error: neither a structural nor a nominal type<br>&gt;     }<br>&gt;<br>&gt; And before you think you’re cleverly making it possible to have a<br>&gt; conditional conformance that makes every type T that conforms to<br>&gt; protocol P also conform to protocol Q, see the section &quot;Conditional<br>&gt; conformances via protocol extensions”, below:<br>&gt;<br>&gt;     extension&lt;T : P&gt; T : Q { // error: neither a structural nor a nominal type<br>&gt;     }<br>&gt;<br>&gt; Syntactic improvements<br>&gt;<br>&gt; There are a number of potential improvements we could make to the<br>&gt; generics syntax. Such a list could go on for a very long time, so I’ll<br>&gt; only highlight some obvious ones that have been discussed by the Swift<br>&gt; developers.<br>&gt;<br>&gt; *Default implementations in protocols<br>&gt;<br>&gt; Currently, protocol members can never have implementations. We could<br>&gt; allow one to provide such implementations to be used as the default if<br>&gt; a conforming type does not supply an implementation, e.g.,<br>&gt;<br>&gt;     protocol Bag {<br>&gt;       associatedtype Element : Equatable<br>&gt;       func contains(element: Element) -&gt; Bool<br>&gt;    <br>&gt;       func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;         for x in elements {<br>&gt;           if contains(x) { return true }<br>&gt;         }<br>&gt;         return false<br>&gt;       }<br>&gt;     }<br>&gt;    <br>&gt;     struct IntBag : Bag {<br>&gt;       typealias Element = Int<br>&gt;       func contains(element: Int) -&gt; Bool { ... }<br>&gt;    <br>&gt;       // okay: containsAll requirement is satisfied by Bag’s default implementation<br>&gt;     }<br>&gt;<br>&gt; One can get this effect with protocol extensions today, hence the<br>&gt; classification of this feature as a (mostly) syntactic improvement:<br>&gt;<br>&gt;     protocol Bag {<br>&gt;       associatedtype Element : Equatable<br>&gt;       func contains(element: Element) -&gt; Bool<br>&gt;    <br>&gt;       func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;     }<br>&gt;    <br>&gt;     extension Bag {<br>&gt;       func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool {<br>&gt;         for x in elements {<br>&gt;           if contains(x) { return true }<br>&gt;         }<br>&gt;         return false<br>&gt;       }<br>&gt;     }<br>&gt;<br>&gt; *Moving the where clause outside of the angle brackets<br>&gt;<br>&gt; The “where” clause of generic functions comes very early in the<br>&gt; declaration, although it is generally of much less concern to the<br>&gt; client than the function parameters and result type that follow<br>&gt; it. This is one of the things that contributes to “angle bracket<br>&gt; blindness”. For example, consider the containsAll signature above:<br>&gt;<br>&gt;     func containsAll&lt;S: Sequence where Sequence.Iterator.Element == Element&gt;(elements: S) -&gt; Bool<br>&gt;<br>&gt; One could move the “where” clause to the end of the signature, so that<br>&gt; the most important parts—name, generic parameter, parameters, result<br>&gt; type—precede it:<br>&gt;<br>&gt;     func containsAll&lt;S: Sequence&gt;(elements: S) -&gt; Bool <br>&gt;<br>&gt;            where Sequence.Iterator.Element == Element<br>&gt;<br>&gt; *Renaming “protocol&lt;…&gt;” to “Any&lt;…&gt;”.<br>&gt;<br>&gt; The “protocol&lt;…&gt;” syntax is a bit of an oddity in Swift. It is used to<br>&gt; compose protocols together, mostly to create values of existential<br>&gt; type, e.g.,<br>&gt;<br>&gt;     var x: protocol&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt; It’s weird that it’s a type name that starts with a lowercase letter,<br>&gt; and most Swift developers probably never deal with this feature unless<br>&gt; they happen to look at the definition of Any:<br>&gt;<br>&gt;     typealias Any = protocol&lt;&gt;<br>&gt;<br>&gt; “Any” might be a better name for this functionality. “Any” without<br>&gt; brackets could be a keyword for “any type”, and “Any” followed by<br>&gt; brackets could take the role of “protocol&lt;&gt;” today:<br>&gt;<br>&gt;     var x: Any&lt;NSCoding, NSCopying&gt;<br>&gt;<br>&gt; That reads much better: “Any type that conforms to NSCoding and<br>&gt; NSCopying”. See the section &quot;Generalized existentials” for additional<br>&gt; features in this space.<br>&gt;<br>&gt; Maybe<br>&gt;<br>&gt; There are a number of features that get discussed from time-to-time,<br>&gt; while they could fit into Swift’s generics system, it’s not clear that<br>&gt; they belong in Swift at all. The important question for any feature in<br>&gt; this category is not “can it be done” or “are there cool things we can<br>&gt; express”, but “how can everyday Swift developers benefit from the<br>&gt; addition of such a feature?”. Without strong motivating examples, none<br>&gt; of these “maybes” will move further along.<br>&gt;<br>&gt; Dynamic dispatch for members of protocol extensions<br>&gt;<br>&gt; Only the requirements of protocols currently use dynamic dispatch,<br>&gt; which can lead to surprises:<br>&gt;<br>&gt;     protocol P {<br>&gt;       func foo()<br>&gt;     }<br>&gt;    <br>&gt;     extension P {<br>&gt;       func foo() { print(“P.foo()”)<br>&gt;       func bar() { print(“P.bar()”)<br>&gt;     }<br>&gt;    <br>&gt;     struct X : P {<br>&gt;       func foo() { print(“X.foo()”)<br>&gt;       func bar() { print(“X.bar()”)<br>&gt;     }<br>&gt;    <br>&gt;     let x = X()<br>&gt;     x.foo() // X.foo()<br>&gt;     x.bar() // X.bar()<br>&gt;    <br>&gt;     let p: P = X()<br>&gt;     p.foo() // X.foo()<br>&gt;     p.bar() // P.bar()<br>&gt;<br>&gt; Swift could adopt a model where members of protocol extensions are<br>&gt; dynamically dispatched.<br>&gt;<br>&gt; Named generic parameters<br>&gt;<br>&gt; When specifying generic arguments for a generic type, the arguments<br>&gt; are always positional: Dictionary&lt;String, Int&gt; is a Dictionary whose<br>&gt; Key type is String and whose Value type is Int, by convention. One<br>&gt; could permit the arguments to be labeled, e.g.,<br>&gt;<br>&gt;     var d: Dictionary&lt;Key: String, Value: Int&gt;<br>&gt;<br>&gt; Such a feature makes more sense if Swift gains default generic<br>&gt; arguments, because generic argument labels would allow one to skip<br>&gt; defaulted arguments.<br>&gt;<br>&gt; Generic value parameters<br>&gt;<br>&gt; Currently, Swift’s generic parameters are always types. One could<br>&gt; imagine allowing generic parameters that are values, e.g.,<br>&gt;<br>&gt;     struct MultiArray&lt;T, let Dimensions: Int&gt; { // specify the number of dimensions to the array<br>&gt;       subscript (indices: Int...) -&gt; T {<br>&gt;         get {<br>&gt;           require(indices.count == Dimensions)<br>&gt;           // ...<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt; A suitably general feature might allow us to express fixed-length<br>&gt; array or vector types as a standard library component, and perhaps<br>&gt; also allow one to implement a useful dimensional analysis<br>&gt; library. Tackling this feature potentially means determining what it<br>&gt; is for an expression to be a “constant expression” and diving into<br>&gt; dependent-typing, hence the “maybe”.<br>&gt;<br>&gt; Higher-kinded types<br>&gt;<br>&gt; Higher-kinded types allow one to express the relationship between two<br>&gt; different specializations of the same nominal type within a<br>&gt; protocol. For example, if we think of the Self type in a protocol as<br>&gt; really being “Self&lt;T&gt;”, it allows us to talk about the relationship<br>&gt; between “Self&lt;T&gt;” and “Self&lt;U&gt;” for some other type U. For example, it<br>&gt; could allow the “map” operation on a collection to return a collection<br>&gt; of the same kind but with a different operation, e.g.,<br>&gt;<br>&gt;     let intArray: Array&lt;Int&gt; = …<br>&gt;     intArray.map { String($0) } // produces Array&lt;String&gt;<br>&gt;     let intSet: Set&lt;Int&gt; = …<br>&gt;     intSet.map { String($0) }   // produces Set&lt;String&gt;<br>&gt;<br>&gt; Potential syntax borrowed from one thread on higher-kinded types uses<br>&gt; ~= as a “similarity” constraint to describe a Functor protocol:<br>&gt;<br>&gt;     protocol Functor {<br>&gt;       associatedtype A<br>&gt;       func fmap&lt;FB where FB ~= Self&gt;(f: A -&gt; FB.A) -&gt; FB<br>&gt;     }<br>&gt;<br>&gt; Specifying type arguments for uses of generic functions<br>&gt;<br>&gt; The type arguments of a generic function are always determined via<br>&gt; type inference. For example, given:<br>&gt;<br>&gt;     func f&lt;T&gt;(t: T)<br>&gt;<br>&gt; one cannot directly specify T: either one calls “f” (and T is<br>&gt; determined via the argument’s type) or one uses “f” in a context where<br>&gt; it is given a particular function type (e.g., “let x: (Int) -&gt; Void =<br>&gt; f” would infer T = Int). We could permit explicit specialization here,<br>&gt; e.g.,<br>&gt;<br>&gt;     let x = f&lt;Int&gt; // x has type (Int) -&gt; Void<br>&gt;<br>&gt; Unlikely<br>&gt;<br>&gt; Features in this category have been requested at various times, but<br>&gt; they don’t fit well with Swift’s generics system because they cause<br>&gt; some part of the model to become overly complicated, have unacceptable<br>&gt; implementation limitations, or overlap significantly with existing<br>&gt; features.<br>&gt;<br>&gt; Generic protocols<br>&gt;<br>&gt; One of the most commonly requested features is the ability to<br>&gt; parameterize protocols themselves. For example, a protocol that<br>&gt; indicates that the Self type can be constructed from some specified<br>&gt; type T:<br>&gt;<br>&gt;     protocol ConstructibleFromValue&lt;T&gt; {<br>&gt;       init(_ value: T)<br>&gt;     }<br>&gt;<br>&gt; Implicit in this feature is the ability for a given type to conform to<br>&gt; the protocol in two different ways. A “Real” type might be<br>&gt; constructible from both Float and Double, e.g.,<br>&gt;<br>&gt;     struct Real { … }<br>&gt;     extension Real : ConstructibleFrom&lt;Float&gt; {<br>&gt;       init(_ value: Float) { … }<br>&gt;     }<br>&gt;     extension Real : ConstructibleFrom&lt;Double&gt; {<br>&gt;       init(_ value: Double) { … }<br>&gt;     }<br>&gt;<br>&gt; Most of the requests for this feature actually want a different<br>&gt; feature. They tend to use a parameterized Sequence as an example,<br>&gt; e.g.,<br>&gt;<br>&gt;     protocol Sequence&lt;Element&gt; { … }<br>&gt;    <br>&gt;     func foo(strings: Sequence&lt;String&gt;) {  /// works on any sequence containing Strings<br>&gt;       // ...<br>&gt;     }<br>&gt;<br>&gt; The actual requested feature here is the ability to say “Any type that<br>&gt; conforms to Sequence whose Element type is String”, which is covered<br>&gt; by the section on “Generalized existentials”, below.<br>&gt;<br>&gt; More importantly, modeling Sequence with generic parameters rather<br>&gt; than associated types is tantalizing but wrong: you don’t want a type<br>&gt; conforming to Sequence in multiple ways, or (among other things) your<br>&gt; for..in loops stop working, and you lose the ability to dynamically<br>&gt; cast down to an existential “Sequence” without binding the Element<br>&gt; type (again, see “Generalized existentials”). Use cases similar to the<br>&gt; ConstructibleFromValue protocol above seem too few to justify the<br>&gt; potential for confusion between associated types and generic<br>&gt; parameters of protocols; we’re better off not having the latter.<br>&gt;<br>&gt; Private conformances <br>&gt;<br>&gt; Right now, a protocol conformance can be no less visible than the<br>&gt; minimum of the conforming type’s access and the protocol’s<br>&gt; access. Therefore, a public type conforming to a public protocol must<br>&gt; provide the conformance publicly.  One could imagine removing that<br>&gt; restriction, so that one could introduce a private conformance:<br>&gt;<br>&gt;     public protocol P { }<br>&gt;     public struct X { }<br>&gt;     extension X : internal P { … } // X conforms to P, but only within this module<br>&gt;<br>&gt; The main problem with private conformances is the interaction with dynamic casting. If I have this code:<br>&gt;<br>&gt;     func foo(value: Any) {<br>&gt;       if let x = value as? P { print(“P”) }<br>&gt;     }<br>&gt;    <br>&gt;     foo(X())<br>&gt;<br>&gt; Under what circumstances should it print “P”? If foo() is defined<br>&gt; within the same module as the conformance of X to P? If the call is<br>&gt; defined within the same module as the conformance of X to P? Never?<br>&gt; Either of the first two answers requires significant complications in<br>&gt; the dynamic casting infrastructure to take into account the module in<br>&gt; which a particular dynamic cast occurred (the first option) or where<br>&gt; an existential was formed (the second option), while the third answer<br>&gt; breaks the link between the static and dynamic type systems—none of<br>&gt; which is an acceptable result.<br>&gt;<br>&gt; Conditional conformances via protocol extensions<br>&gt;<br>&gt; We often get requests to make a protocol conform to another<br>&gt; protocol. This is, effectively, the expansion of the notion of<br>&gt; “Conditional conformances” to protocol extensions. For example:<br>&gt;<br>&gt;     protocol P {<br>&gt;       func foo()<br>&gt;     }<br>&gt;    <br>&gt;     protocol Q {<br>&gt;       func bar()<br>&gt;     }<br>&gt;    <br>&gt;     extension Q : P { // every type that conforms to Q also conforms to P<br>&gt;       func foo() {    // implement “foo” requirement in terms of “bar&quot;<br>&gt;         bar()<br>&gt;       }<br>&gt;     }<br>&gt;    <br>&gt;     func f&lt;T: P&gt;(t: T) { … }<br>&gt;    <br>&gt;     struct X : Q {<br>&gt;       func bar() { … }<br>&gt;     }<br>&gt;    <br>&gt;     f(X()) // okay: X conforms to P through the conformance of Q to P<br>&gt;<br>&gt; This is an extremely powerful feature: is allows one to map the<br>&gt; abstractions of one domain into another domain (e.g., every Matrix is<br>&gt; a Graph). However, similar to private conformances, it puts a major<br>&gt; burden on the dynamic-casting runtime to chase down arbitrarily long<br>&gt; and potentially cyclic chains of conformances, which makes efficient<br>&gt; implementation nearly impossible.<br>&gt;<br>&gt; Potential removals<br>&gt;<br>&gt; The generics system doesn’t seem like a good candidate for a reduction<br>&gt; in scope; most of its features do get used fairly pervasively in the<br>&gt; standard library, and few feel overly anachronistic. However...<br>&gt;<br>&gt; Associated type inference<br>&gt;<br>&gt; Associated type inference is the process by which we infer the type<br>&gt; bindings for associated types from other requirements. For example:<br>&gt;<br>&gt;     protocol IteratorProtocol {<br>&gt;       associatedtype Element<br>&gt;       mutating func next() -&gt; Element?<br>&gt;     }<br>&gt;    <br>&gt;     struct IntIterator : IteratorProtocol {<br>&gt;       mutating func next() -&gt; Int? { … }  // use this to infer Element = Int<br>&gt;     }<br>&gt;<br>&gt; Associated type inference is a useful feature. It’s used throughout<br>&gt; the standard library, and it helps keep associated types less visible<br>&gt; to types that simply want to conform to a protocol. On the other hand,<br>&gt; associated type inference is the only place in Swift where we have a<br>&gt; global type inference problem: it has historically been a major source<br>&gt; of bugs, and implementing it fully and correctly requires a<br>&gt; drastically different architecture to the type checker. Is the value<br>&gt; of this feature worth keeping global type inference in the Swift<br>&gt; language, when we have deliberatively avoided global type inference<br>&gt; elsewhere in the language?<br>&gt;<br>&gt; Existentials<br>&gt;<br>&gt; Existentials aren’t really generics per se, but the two systems are<br>&gt; closely intertwined due to their mutable dependence on protocols.<br>&gt;<br>&gt; *Generalized existentials<br>&gt;<br>&gt; The restrictions on existential types came from an implementation<br>&gt; limitation, but it is reasonable to allow a value of protocol type<br>&gt; even when the protocol has Self constraints or associated types. For<br>&gt; example, consider IteratorProtocol again and how it could be used as<br>&gt; an existential:<br>&gt;<br>&gt;     protocol IteratorProtocol {<br>&gt;       associatedtype Element<br>&gt;       mutating func next() -&gt; Element?<br>&gt;     }<br>&gt;    <br>&gt;     let it: IteratorProtocol = …<br>&gt;     it.next()   // if this is permitted, it could return an “Any?”, i.e., the existential that wraps the actual<br>&gt;     element<br>&gt;<br>&gt; Additionally, it is reasonable to want to constrain the associated<br>&gt; types of an existential, e.g., “a Sequence whose element type is<br>&gt; String” could be expressed by putting a where clause into<br>&gt; “protocol&lt;…&gt;” or “Any&lt;…&gt;” (per “Renaming protocol&lt;…&gt; to Any&lt;…&gt;”):<br>&gt;<br>&gt;     let strings: Any&lt;Sequence where .Iterator.Element == String&gt; = [“a”, “b”, “c”]<br>&gt;<br>&gt; The leading “.” indicates that we’re talking about the dynamic type,<br>&gt; i.e., the “Self” type that’s conforming to the Sequence<br>&gt; protocol. There’s no reason why we cannot support arbitrary “where”<br>&gt; clauses within the “Any&lt;…&gt;”. This very-general syntax is a bit<br>&gt; unwieldy, but common cases can easily be wrapped up in a generic<br>&gt; typealias (see the section “Generic typealiases” above):<br>&gt;<br>&gt;     typealias AnySequence&lt;Element&gt; = Any&lt;Sequence where .Iterator.Element == Element&gt;<br>&gt;     let strings: AnySequence&lt;String&gt; = [“a”, “b”, “c”]<br>&gt;<br>&gt; Opening existentials<br>&gt;<br>&gt; Generalized existentials as described above will still have trouble<br>&gt; with protocol requirements that involve Self or associated types in<br>&gt; function parameters. For example, let’s try to use Equatable as an<br>&gt; existential:<br>&gt;<br>&gt;     protocol Equatable {<br>&gt;       func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;       func !=(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;     }<br>&gt;    <br>&gt;     let e1: Equatable = …<br>&gt;     let e2: Equatable = …<br>&gt;     if e1 == e2 { … } // error: e1 and e2 don’t necessarily have the same dynamic type<br>&gt;<br>&gt; One explicit way to allow such operations in a type-safe manner is to<br>&gt; introduce an “open existential” operation of some sort, which extracts<br>&gt; and gives a name to the dynamic type stored inside an existential. For<br>&gt; example:<br>&gt;<br>&gt;     if let storedInE1 = e1 openas T {     // T is a the type of storedInE1, a copy of the value stored in e1<br>&gt;<br>&gt;       if let storedInE2 = e2 as? T {      // is e2 also a T?<br>&gt;<br>&gt;         if storedInE1 == storedInE2 { … } // okay: storedInT1 and storedInE2 are both of type T, which we know is<br>&gt;     Equatable<br>&gt;<br>&gt;       }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; Thoughts?<br></p><p>This is certainly... a lot.  I&#39;ve wanted so much from the generics<br>system over the years that it&#39;s hard to remember whether everything<br>important is in this list.  I&#39;ll have to give that some more thought.<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
