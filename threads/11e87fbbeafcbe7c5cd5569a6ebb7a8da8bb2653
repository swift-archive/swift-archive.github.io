<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac88c9479d558ec508bc7f2ef10561e7?s=50"></div><header><strong>Swift Reflection</strong> from <string>Robert Goodman</string> &lt;goodmanr at us.ibm.com&gt;<p>October 18, 2016 at 01:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161018/11e82653/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Swift Reflection</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>October 22, 2016 at 10:00:00pm</p></header><div class="content"><p>If you’re going to build on top of something like Spark it seems you’d have better luck wrapping the JNI and using Swift protocols to try to automate away as much of the boilerplate of creating JNI classes dynamically.  <br></p><p>~Robert Widmann<br></p><p>&gt; On Oct 18, 2016, at 9:40 AM, Robert Goodman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;  <br>&gt; I know that there has been some discussion around improving reflection in Swift and I wanted to add to the discussion with some of the work I have been trying to do using the Swift Language. I have been investigating using Swift to create a framework that provides a programming API to process data and execute functions in parallel on a cluster. The framework needs to be able instantiate these functions on the cluster workers and have the data processed by the functions. The plans are to use one of the existing cluster managers, such as Spark or Storm. As of today, I have been looking at using Spark. There would be a predefined set of functions supported such as map, fliter, join, etc. as defined by the cluster manager.<br>&gt; In my experimenting, I have run into a number of issues which I haven&#39;t been able to solve due to the limited support for reflection in Swift. In my description of the issues, I&#39;m going to use APIs based on Spark since that is the cluster manager I have been playing with.<br>&gt;  <br>&gt; Parameter and Return types<br>&gt;  <br>&gt; The following is an example of a Swift class that maps to the RDD class in Spark.<br>&gt;  <br>&gt; public class RDD &lt;T&gt; {<br>&gt;    public func collect() throws -&gt; [T] {<br>&gt;    ....<br>&gt;    }<br>&gt; }<br>&gt;  <br>&gt; The value of T could be any basic type to a class. Even if the types are limited to basic types and known Spark types, the list of possibilities is large. From one of the Spark examples, T would be<br>&gt;  <br>&gt;   Tuple2&lt;Int32, Tuple3&lt;Int32, Int32, Double&gt;&gt;<br>&gt;  <br>&gt; The possible combinations of types is too large to be hard coded given Spark supports Tuples with 22 different types. I can get the type of T in a string, but haven&#39;t found a way to instantiate the type using the string. Is there some way around this problem?<br>&gt; <br>&gt; User-Defined Functions<br>&gt;  <br>&gt; A programmer would define functions that will be executed on a cluster to process data. The programmer doesn&#39;t need to do special packaging of functions that run on a cluster. The programmer would code a filter function against the cluster the same way as the filter function for a Swift array. For instance, for a filter method such as the following:<br>&gt;  <br>&gt; let result = RDD.filter({ (value) -&gt; Bool in<br>&gt;     return value &gt; 15<br>&gt; })<br>&gt;  <br>&gt; The framework would need to be able to do reflection on the function to get the information needed to instantiate and call the function on the cluster workers. Following is some of the information needed:<br>&gt;                              <br>&gt;   Module name<br>&gt;   Class/Struct name<br>&gt;   Function name<br>&gt;   Parameter names and type information<br>&gt;             <br>&gt; Once on the cluster the framework would need to do the following:<br>&gt;  <br>&gt;   1. Instantiate the parameters. Again, a parameter could be a basic type to a class.<br>&gt;   2. Dynamically load/import the module containing the function.<br>&gt;   3. Find the function in the module that matches the signature.<br>&gt;   4. Call the function.<br>&gt;   5. Handle the return type.<br>&gt;  <br>&gt; With the existing Swift support for reflection, I couldn&#39;t get all of the information that is needed and what information I could get wasn&#39;t in a very convenient form. In some cases, I needed to parse a string to get the different parameter types. Even if I had the information, I didn&#39;t see a way to use the information to load the module and execute the function. My plans are to require the programmer to pass the location of modules and dependencies that need to be deployed to the cluster workers on application startup. Given the limitations of reflections in Swift, I don&#39;t see how this framework could be implemented. Since this needs to run on Linux, I want to avoid any solution that uses Objective C.<br>&gt;  <br>&gt;     Thanks<br>&gt;       Bob<br>&gt; <br>&gt; Robert Goodman<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161022/a64a975a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ac88c9479d558ec508bc7f2ef10561e7?s=50"></div><header><strong>Swift Reflection</strong> from <string>Robert Goodman</string> &lt;goodmanr at us.ibm.com&gt;<p>October 24, 2016 at 02:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161024/8db707e3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
