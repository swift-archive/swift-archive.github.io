<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30ea8887f16ee8e189bc651adfcb8896?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>Frank Ecsedy</string> &lt;fecsedy at gmail.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I posted this on Erica Sadun&#39;s website and she suggested I post it here:<br></p><p>So what about protocols requiring ‘var … { get }’ syntax for read only<br>properties? Is there some sort of underlying reason for this confusing<br>syntax instead of ‘let …’? Now that Swift allows deferred initialization of<br>lets does this requirement make sense?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/575f3d3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>January 29, 2016 at 04:00:00pm</p></header><div class="content"><p>On Fri, Jan 29, 2016 at 4:16 PM, Frank Ecsedy via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I posted this on Erica Sadun&#39;s website and she suggested I post it here:<br>&gt;<br>&gt; So what about protocols requiring ‘var … { get }’ syntax for read only<br>&gt; properties? Is there some sort of underlying reason for this confusing<br>&gt; syntax instead of ‘let …’? Now that Swift allows deferred initialization of<br>&gt; lets does this requirement make sense?<br></p><p>Computed properties, even get-only ones, can return different values<br>every time.  &#39;let&#39;s can&#39;t.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>January 29, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; So what about protocols requiring ‘var … { get }’ syntax for read only properties? Is there some sort of underlying reason for this confusing syntax instead of ‘let …’? Now that Swift allows deferred initialization of lets does this requirement make sense?<br></p><p>`let` doesn&#39;t mean &quot;no setter&quot;, it means &quot;constant&quot;. For instance, you can&#39;t make a `weak let`, because the `weak` implies the variable can be nilled. There&#39;s no way to require a constant in a protocol, but if there were one, that&#39;s what `let ...` would mean.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 30, 2016 at 05:00:00pm</p></header><div class="content"><p>Scala uses their equivalent of let ... instead of var ... { get }. In Scala<br>let ... Always means var ... { get }. Not a problem in Scala only having<br>one concept. I think it is a possibility for Swift.<br></p><p>On Saturday, 30 January 2016, Brent Royal-Gordon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; So what about protocols requiring ‘var … { get }’ syntax for read only<br>&gt; properties? Is there some sort of underlying reason for this confusing<br>&gt; syntax instead of ‘let …’? Now that Swift allows deferred initialization of<br>&gt; lets does this requirement make sense?<br>&gt;<br>&gt; `let` doesn&#39;t mean &quot;no setter&quot;, it means &quot;constant&quot;. For instance, you<br>&gt; can&#39;t make a `weak let`, because the `weak` implies the variable can be<br>&gt; nilled. There&#39;s no way to require a constant in a protocol, but if there<br>&gt; were one, that&#39;s what `let ...` would mean.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/f20faaaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 11:00:00pm</p></header><div class="content"><p>Not really… There’s a pretty big difference between “no setter” and “const&quot;. Plus, since we’re talking about protocols, “var … {get}” doesn’t even mean “no setter”, it means “no setter required”. A regular var property (which is obviously not constant) can satisfy a {get} requirement.<br></p><p>- Dave Sweeris (Non-Canonical Dave)<br></p><p>&gt; On Jan 29, 2016, at 22:49, Howard Lovatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Scala uses their equivalent of let ... instead of var ... { get }. In Scala let ... Always means var ... { get }. Not a problem in Scala only having one concept. I think it is a possibility for Swift.<br>&gt; <br>&gt; On Saturday, 30 January 2016, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; So what about protocols requiring ‘var … { get }’ syntax for read only properties? Is there some sort of underlying reason for this confusing syntax instead of ‘let …’? Now that Swift allows deferred initialization of lets does this requirement make sense?<br>&gt; <br>&gt; `let` doesn&#39;t mean &quot;no setter&quot;, it means &quot;constant&quot;. For instance, you can&#39;t make a `weak let`, because the `weak` implies the variable can be nilled. There&#39;s no way to require a constant in a protocol, but if there were one, that&#39;s what `let ...` would mean.<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; -- <br>&gt;   -- Howard.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/0b547d0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 31, 2016 at 01:00:00pm</p></header><div class="content"><p>If we assume that Swift was changed to be like Scala then:<br></p><p>    protocol Stored {<br>        let x = 42<br>    }<br></p><p>Would be equivalent to:<br></p><p>    protocol Stored {<br>        var x: Int { get }<br>        static func initX() -&gt; Int<br>    }<br></p><p>    extension Stored {<br>        static func initX() -&gt; Int { return 42 }<br>    }<br></p><p>If you then implemented the protocol:<br></p><p>    struct S: Stored {<br>        var x = 69 // Could be `let` instead of `var`<br>    }<br></p><p>Would be equivalent to:<br></p><p>    struct S: Stored {<br>        var x = S.initX()<br>        static func initX() -&gt; Int { return 69 }<br>    }<br></p><p>Therefore it is possible to unify the two concepts.<br></p><p>On Saturday, 30 January 2016, &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; Not really… There’s a pretty big difference between “no setter” and<br>&gt; “const&quot;. Plus, since we’re talking about protocols, “var … {get}” doesn’t<br>&gt; even mean “no setter”, it means “no setter *required*”. A regular var<br>&gt; property (which is obviously not constant) can satisfy a {get} requirement.<br>&gt;<br>&gt; - Dave Sweeris (Non-Canonical Dave)<br>&gt;<br>&gt; On Jan 29, 2016, at 22:49, Howard Lovatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt; Scala uses their equivalent of let ... instead of var ... { get }. In<br>&gt; Scala let ... Always means var ... { get }. Not a problem in Scala only<br>&gt; having one concept. I think it is a possibility for Swift.<br>&gt;<br>&gt; On Saturday, 30 January 2016, Brent Royal-Gordon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; So what about protocols requiring ‘var … { get }’ syntax for read only<br>&gt;&gt; properties? Is there some sort of underlying reason for this confusing<br>&gt;&gt; syntax instead of ‘let …’? Now that Swift allows deferred initialization of<br>&gt;&gt; lets does this requirement make sense?<br>&gt;&gt;<br>&gt;&gt; `let` doesn&#39;t mean &quot;no setter&quot;, it means &quot;constant&quot;. For instance, you<br>&gt;&gt; can&#39;t make a `weak let`, because the `weak` implies the variable can be<br>&gt;&gt; nilled. There&#39;s no way to require a constant in a protocol, but if there<br>&gt;&gt; were one, that&#39;s what `let ...` would mean.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt;   -- Howard.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; &lt;javascript:_e(%7B%7D,&#39;cvml&#39;,&#39;swift-evolution at swift.org&#39;);&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br></p><p>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/3c305929/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/30ea8887f16ee8e189bc651adfcb8896?s=50"></div><header><strong>Protocols and var { get }</strong> from <string>Frank Ecsedy</string> &lt;fecsedy at gmail.com&gt;<p>January 29, 2016 at 11:00:00pm</p></header><div class="content"><p>Right. You could have a protocol X that hypothetically had something like<br>&#39;let x&#39; in it. If struct S implemented X and let x = 17 and class C<br>implemented X and let x = 42 you now have a let variable that could take on<br>multiple values depending on the implementing type which defeats the whole<br>point of the let in the first place. Not to mention what Dmitri said about<br>protocol implementers calculating the value of the let which would really<br>defeat the purpose. The syntax &#39;var ... { get }&#39; is much more in line with<br>reality than &#39;let ...&#39;.<br></p><p>On Friday, January 29, 2016, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; So what about protocols requiring ‘var … { get }’ syntax for read only<br>&gt; properties? Is there some sort of underlying reason for this confusing<br>&gt; syntax instead of ‘let …’? Now that Swift allows deferred initialization of<br>&gt; lets does this requirement make sense?<br>&gt;<br>&gt; `let` doesn&#39;t mean &quot;no setter&quot;, it means &quot;constant&quot;. For instance, you<br>&gt; can&#39;t make a `weak let`, because the `weak` implies the variable can be<br>&gt; nilled. There&#39;s no way to require a constant in a protocol, but if there<br>&gt; were one, that&#39;s what `let ...` would mean.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/67eac7fd/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
