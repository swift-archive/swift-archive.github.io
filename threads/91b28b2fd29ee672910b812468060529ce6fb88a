<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  5, 2016 at 04:00:00am</p></header><div class="content"><p>MOTIVATION:<br></p><p>As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br></p><p>func doSomething() -&gt; SomeEnum {<br>	if aCondition {<br>		if bCondition {<br>			return .Foo<br>		} else {<br>			return .Bar<br>		}<br>	} else {<br>		if cCondition {<br>			return .Baz<br>		}<br>	}<br>}<br></p><p>The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br></p><p>However, consider the equivalent async API:<br></p><p>func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>	dispatch_async(someQueue) {<br>		if aCondition {<br>			if bCondition {<br>				completionHandler(.Foo)<br>			} else {<br>				completionHandler(.Bar)<br>			}<br>		} else {<br>			if cCondition {<br>				completionHandler(.Baz)<br>			}<br>		}<br>	}<br>}<br></p><p>Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br></p><p>PROPOSED SOLUTION:<br></p><p>Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br></p><p>DETAILED DESIGN:<br></p><p>- The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br></p><p>- Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br></p><p>- When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br></p><p>- If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br></p><p>IMPACT ON EXISTING CODE:<br></p><p>None. This is purely additive.<br></p><p>ALTERNATIVES CONSIDERED:<br></p><p>I got nothin’.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bce64da43e291f2ce30987a83780502c?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Patrick Pijnappel</string> &lt;patrickpijnappel at gmail.com&gt;<p>June  5, 2016 at 12:00:00pm</p></header><div class="content"><p>This has actually been proposed before, see SE-0073:<br>https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br></p><p><br>On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; MOTIVATION:<br>&gt;<br>&gt; As per the current situation, there is a pitfall when writing asynchronous<br>&gt; APIs that does not occur when writing synchronous APIs. Consider the<br>&gt; following synchronous API:<br>&gt;<br>&gt; func doSomething() -&gt; SomeEnum {<br>&gt;         if aCondition {<br>&gt;                 if bCondition {<br>&gt;                         return .Foo<br>&gt;                 } else {<br>&gt;                         return .Bar<br>&gt;                 }<br>&gt;         } else {<br>&gt;                 if cCondition {<br>&gt;                         return .Baz<br>&gt;                 }<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; The compiler will give an error here, since if both aCondition and<br>&gt; cCondition are false, the function will not return anything.<br>&gt;<br>&gt; However, consider the equivalent async API:<br>&gt;<br>&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;         dispatch_async(someQueue) {<br>&gt;                 if aCondition {<br>&gt;                         if bCondition {<br>&gt;                                 completionHandler(.Foo)<br>&gt;                         } else {<br>&gt;                                 completionHandler(.Bar)<br>&gt;                         }<br>&gt;                 } else {<br>&gt;                         if cCondition {<br>&gt;                                 completionHandler(.Baz)<br>&gt;                         }<br>&gt;                 }<br>&gt;         }<br>&gt; }<br>&gt;<br>&gt; Whoops, now the function can return without ever firing its completion<br>&gt; handler, and the problem might not be discovered until runtime (and,<br>&gt; depending on the complexity of the function, may be hard to find).<br>&gt;<br>&gt; PROPOSED SOLUTION:<br>&gt;<br>&gt; Add a @required attribute that can be applied to closure arguments. This<br>&gt; attribute simply states that the given closure will always be eventually<br>&gt; called, and the compiler can enforce this.<br>&gt;<br>&gt; DETAILED DESIGN:<br>&gt;<br>&gt; - The @required attribute states in our API contract that a given closure<br>&gt; *must* be called at some point after the function is called.<br>&gt;<br>&gt; - Standard API calls like dispatch_async that contractually promise to<br>&gt; execute a closure or block get @required added to their signatures.<br>&gt;<br>&gt; - When the compiler sees a @required closure in a function declaration, it<br>&gt; checks to make sure that every execution path either calls the closure at<br>&gt; some point, or sends a @required closure to another API that eventually<br>&gt; ends up calling the closure.<br>&gt;<br>&gt; - If there’s a way for a @required closure not to be called, the compiler<br>&gt; emits an error letting the developer know about the bug in his/her code.<br>&gt;<br>&gt; IMPACT ON EXISTING CODE:<br>&gt;<br>&gt; None. This is purely additive.<br>&gt;<br>&gt; ALTERNATIVES CONSIDERED:<br>&gt;<br>&gt; I got nothin’.<br>&gt;<br>&gt; Charles<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/11e6e266/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This has actually been proposed before, see SE-0073: https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br></p><p>Actually that proposal was for noescape closures and this suggestion is for escaping closures.  I don&#39;t think the compiler can verify this for noescape closures.  If it is possible it would be far more complicated.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; MOTIVATION:<br>&gt;&gt; <br>&gt;&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt;&gt; <br>&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;         if aCondition {<br>&gt;&gt;                 if bCondition {<br>&gt;&gt;                         return .Foo<br>&gt;&gt;                 } else {<br>&gt;&gt;                         return .Bar<br>&gt;&gt;                 }<br>&gt;&gt;         } else {<br>&gt;&gt;                 if cCondition {<br>&gt;&gt;                         return .Baz<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt;&gt; <br>&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt; <br>&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;                 if aCondition {<br>&gt;&gt;                         if bCondition {<br>&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;                         } else {<br>&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;                         }<br>&gt;&gt;                 } else {<br>&gt;&gt;                         if cCondition {<br>&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;                         }<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt; <br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt; <br>&gt;&gt; Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br>&gt;&gt; <br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt; <br>&gt;&gt; - The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br>&gt;&gt; <br>&gt;&gt; - Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br>&gt;&gt; <br>&gt;&gt; - When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br>&gt;&gt; <br>&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt; <br>&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt; <br>&gt;&gt; None. This is purely additive.<br>&gt;&gt; <br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt; <br>&gt;&gt; I got nothin’.<br>&gt;&gt; <br>&gt;&gt; Charles<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/290c3a35/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>I like this.<br></p><p>One of the suggestions on @noescape(once) was that it just becomes @once<br>and works with escaping closures too. It might be possible if compile time<br>checks verified that the closure isn&#39;t copied, and that it is called before<br>being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in<br>the cases the compiler can&#39;t check.<br></p><p>It would be great if @required took into the account the feedback from that<br>proposal and considered the synchronous case too.<br></p><p>As an aside, you can get some of the guarantees you want like this:<br></p><p>func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br></p><p>  dispatch_async(someQueue) {<br></p><p>    let result: SomeEnum<br></p><p>    // the compiler ensures &#39;result&#39; is set<br></p><p>    defer { completionHandler(result) }<br></p><p><br>    if aCondition {<br></p><p>      if bCondition {<br></p><p>        result = .Foo<br></p><p>      } else {<br></p><p>        result = .Bar<br></p><p>      }<br></p><p>      // the compiler ensures you do this, because it is &#39;let&#39;<br></p><p>      return<br>    }<br></p><p><br>    if cCondition {<br></p><p>      result = .Baz<br></p><p>    }<br></p><p>  }<br></p><p>}<br></p><p>On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This has actually been proposed before, see SE-0073:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;<br>&gt;<br>&gt; Actually that proposal was for noescape closures and this suggestion is<br>&gt; for escaping closures.  I don&#39;t think the compiler can verify this for<br>&gt; noescape closures.  If it is possible it would be far more complicated.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; MOTIVATION:<br>&gt;&gt;<br>&gt;&gt; As per the current situation, there is a pitfall when writing<br>&gt;&gt; asynchronous APIs that does not occur when writing synchronous APIs.<br>&gt;&gt; Consider the following synchronous API:<br>&gt;&gt;<br>&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;         if aCondition {<br>&gt;&gt;                 if bCondition {<br>&gt;&gt;                         return .Foo<br>&gt;&gt;                 } else {<br>&gt;&gt;                         return .Bar<br>&gt;&gt;                 }<br>&gt;&gt;         } else {<br>&gt;&gt;                 if cCondition {<br>&gt;&gt;                         return .Baz<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The compiler will give an error here, since if both aCondition and<br>&gt;&gt; cCondition are false, the function will not return anything.<br>&gt;&gt;<br>&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;<br>&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;                 if aCondition {<br>&gt;&gt;                         if bCondition {<br>&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;                         } else {<br>&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;                         }<br>&gt;&gt;                 } else {<br>&gt;&gt;                         if cCondition {<br>&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;                         }<br>&gt;&gt;                 }<br>&gt;&gt;         }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Whoops, now the function can return without ever firing its completion<br>&gt;&gt; handler, and the problem might not be discovered until runtime (and,<br>&gt;&gt; depending on the complexity of the function, may be hard to find).<br>&gt;&gt;<br>&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;<br>&gt;&gt; Add a @required attribute that can be applied to closure arguments. This<br>&gt;&gt; attribute simply states that the given closure will always be eventually<br>&gt;&gt; called, and the compiler can enforce this.<br>&gt;&gt;<br>&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;<br>&gt;&gt; - The @required attribute states in our API contract that a given closure<br>&gt;&gt; *must* be called at some point after the function is called.<br>&gt;&gt;<br>&gt;&gt; - Standard API calls like dispatch_async that contractually promise to<br>&gt;&gt; execute a closure or block get @required added to their signatures.<br>&gt;&gt;<br>&gt;&gt; - When the compiler sees a @required closure in a function declaration,<br>&gt;&gt; it checks to make sure that every execution path either calls the closure<br>&gt;&gt; at some point, or sends a @required closure to another API that eventually<br>&gt;&gt; ends up calling the closure.<br>&gt;&gt;<br>&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler<br>&gt;&gt; emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt;<br>&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;<br>&gt;&gt; None. This is purely additive.<br>&gt;&gt;<br>&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;<br>&gt;&gt; I got nothin’.<br>&gt;&gt;<br>&gt;&gt; Charles<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/bab6c026/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&quot;runtime circumstance&quot; -&gt; &quot;runtime assertion&quot;, weird typo.<br></p><p>On Sun, Jun 5, 2016 at 9:56 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br></p><p>&gt; I like this.<br>&gt;<br>&gt; One of the suggestions on @noescape(once) was that it just becomes @once<br>&gt; and works with escaping closures too. It might be possible if compile time<br>&gt; checks verified that the closure isn&#39;t copied, and that it is called before<br>&gt; being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in<br>&gt; the cases the compiler can&#39;t check.<br>&gt;<br>&gt; It would be great if @required took into the account the feedback from<br>&gt; that proposal and considered the synchronous case too.<br>&gt;<br>&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;<br>&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;<br>&gt;   dispatch_async(someQueue) {<br>&gt;<br>&gt;     let result: SomeEnum<br>&gt;<br>&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;<br>&gt;     defer { completionHandler(result) }<br>&gt;<br>&gt;<br>&gt;     if aCondition {<br>&gt;<br>&gt;       if bCondition {<br>&gt;<br>&gt;         result = .Foo<br>&gt;<br>&gt;       } else {<br>&gt;<br>&gt;         result = .Bar<br>&gt;<br>&gt;       }<br>&gt;<br>&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;<br>&gt;       return<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     if cCondition {<br>&gt;<br>&gt;       result = .Baz<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This has actually been proposed before, see SE-0073:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually that proposal was for noescape closures and this suggestion is<br>&gt;&gt; for escaping closures.  I don&#39;t think the compiler can verify this for<br>&gt;&gt; noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As per the current situation, there is a pitfall when writing<br>&gt;&gt;&gt; asynchronous APIs that does not occur when writing synchronous APIs.<br>&gt;&gt;&gt; Consider the following synchronous API:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and<br>&gt;&gt;&gt; cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion<br>&gt;&gt;&gt; handler, and the problem might not be discovered until runtime (and,<br>&gt;&gt;&gt; depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This<br>&gt;&gt;&gt; attribute simply states that the given closure will always be eventually<br>&gt;&gt;&gt; called, and the compiler can enforce this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - The @required attribute states in our API contract that a given<br>&gt;&gt;&gt; closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to<br>&gt;&gt;&gt; execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration,<br>&gt;&gt;&gt; it checks to make sure that every execution path either calls the closure<br>&gt;&gt;&gt; at some point, or sends a @required closure to another API that eventually<br>&gt;&gt;&gt; ends up calling the closure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the<br>&gt;&gt;&gt; compiler emits an error letting the developer know about the bug in his/her<br>&gt;&gt;&gt; code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/00ef7d6d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like this.<br>&gt; <br>&gt; One of the suggestions on @noescape(once) was that it just becomes @once and works with escaping closures too. It might be possible if compile time checks verified that the closure isn&#39;t copied, and that it is called before being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in the cases the compiler can&#39;t check.<br></p><p>Yeah, maybe if it is only used asynchronously and never stored in a member or global it could be verified and that is a pretty common case.  That would certainly be easier than the general case.<br></p><p>I prefer @once over @required if the guarantee is single execution.  If the guarantee is *at least once* obviously @once is not the right attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br></p><p>&gt; <br>&gt; It would be great if @required took into the account the feedback from that proposal and considered the synchronous case too.<br>&gt; <br>&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt; <br>&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;   dispatch_async(someQueue) {<br>&gt;     let result: SomeEnum<br>&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;     defer { completionHandler(result) }<br>&gt; <br>&gt;     if aCondition {<br>&gt;       if bCondition {<br>&gt;         result = .Foo<br>&gt;       } else {<br>&gt;         result = .Bar<br>&gt;       }<br>&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;       return<br>&gt;     }<br>&gt; <br>&gt;     if cCondition {<br>&gt;       result = .Baz<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This has actually been proposed before, see SE-0073: https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt; <br>&gt;&gt; Actually that proposal was for noescape closures and this suggestion is for escaping closures.  I don&#39;t think the compiler can verify this for noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/204052f9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June  5, 2016 at 11:00:00pm</p></header><div class="content"><p>Storing into a member would be fine, as long as it must keep @once as a<br>type annotation and the compiler makes sure you maintain:<br>    sum(callCount, storeCount, passCount) == 1<br></p><p>For example:<br>  class Example {<br>    private var closure: (@once (T) -&gt; Void)?<br></p><p>    func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br></p><p>      // the compiler should error if it detects the closure:<br></p><p>      //  * escaping more than once, while still being stored,<br></p><p>      //  * or being called while still being stored or escaping,<br></p><p>      //  * or being overwritten without being called<br></p><p>      if let closure = self.closure {<br></p><p>        self.closure = replace<br></p><p>        closure(value)<br></p><p>      }<br></p><p>    }<br></p><p><br>    deinit {<br></p><p>      // compiler warning: that closure is potentially un-called<br></p><p>      // runtime fatalError if it&#39;s .Some(Closure) after deinit<br></p><p>    }<br></p><p>  }<br></p><p>There could be a standard library type with those guarantees built in.<br></p><p><br>On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; I like this.<br>&gt;<br>&gt; One of the suggestions on @noescape(once) was that it just becomes @once<br>&gt; and works with escaping closures too. It might be possible if compile time<br>&gt; checks verified that the closure isn&#39;t copied, and that it is called before<br>&gt; being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in<br>&gt; the cases the compiler can&#39;t check.<br>&gt;<br>&gt;<br>&gt; Yeah, maybe if it is only used asynchronously and never stored in a member<br>&gt; or global it could be verified and that is a pretty common case.  That<br>&gt; would certainly be easier than the general case.<br>&gt;<br>&gt; I prefer @once over @required if the guarantee is single execution.  If<br>&gt; the guarantee is *at least once* obviously @once is not the right<br>&gt; attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;<br>&gt;<br>&gt; It would be great if @required took into the account the feedback from<br>&gt; that proposal and considered the synchronous case too.<br>&gt;<br>&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;<br>&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;<br>&gt;   dispatch_async(someQueue) {<br>&gt;<br>&gt;     let result: SomeEnum<br>&gt;<br>&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;<br>&gt;     defer { completionHandler(result) }<br>&gt;<br>&gt;<br>&gt;     if aCondition {<br>&gt;<br>&gt;       if bCondition {<br>&gt;<br>&gt;         result = .Foo<br>&gt;<br>&gt;       } else {<br>&gt;<br>&gt;         result = .Bar<br>&gt;<br>&gt;       }<br>&gt;<br>&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;<br>&gt;       return<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     if cCondition {<br>&gt;<br>&gt;       result = .Baz<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This has actually been proposed before, see SE-0073:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Actually that proposal was for noescape closures and this suggestion is<br>&gt;&gt; for escaping closures.  I don&#39;t think the compiler can verify this for<br>&gt;&gt; noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As per the current situation, there is a pitfall when writing<br>&gt;&gt;&gt; asynchronous APIs that does not occur when writing synchronous APIs.<br>&gt;&gt;&gt; Consider the following synchronous API:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and<br>&gt;&gt;&gt; cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion<br>&gt;&gt;&gt; handler, and the problem might not be discovered until runtime (and,<br>&gt;&gt;&gt; depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This<br>&gt;&gt;&gt; attribute simply states that the given closure will always be eventually<br>&gt;&gt;&gt; called, and the compiler can enforce this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - The @required attribute states in our API contract that a given<br>&gt;&gt;&gt; closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to<br>&gt;&gt;&gt; execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration,<br>&gt;&gt;&gt; it checks to make sure that every execution path either calls the closure<br>&gt;&gt;&gt; at some point, or sends a @required closure to another API that eventually<br>&gt;&gt;&gt; ends up calling the closure.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the<br>&gt;&gt;&gt; compiler emits an error letting the developer know about the bug in his/her<br>&gt;&gt;&gt; code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/39de521d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Storing into a member would be fine, as long as it must keep @once as a type annotation and the compiler makes sure you maintain:<br>&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt; <br>&gt; For example:<br>&gt;   class Example {<br>&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt; <br>&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;       // the compiler should error if it detects the closure:<br>&gt;       //  * escaping more than once, while still being stored,<br>&gt;       //  * or being called while still being stored or escaping,<br>&gt;       //  * or being overwritten without being called<br>&gt;       if let closure = self.closure {<br>&gt;         self.closure = replace<br>&gt;         closure(value)<br>&gt;       }<br>&gt;     }<br>&gt; <br>&gt;     deinit {<br>&gt;       // compiler warning: that closure is potentially un-called<br>&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;     }<br>&gt;   }<br>&gt; <br>&gt; There could be a standard library type with those guarantees built in.<br></p><p>I don&#39;t consider this compiler verification.  It is runtime verification.  The best the compiler can do is enforce constraints that allow for guaranteed runtime verification.  You can argue that is better than nothing but it is not a static guarantee of correct behavior.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes @once and works with escaping closures too. It might be possible if compile time checks verified that the closure isn&#39;t copied, and that it is called before being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in the cases the compiler can&#39;t check.<br>&gt;&gt; <br>&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a member or global it could be verified and that is a pretty common case.  That would certainly be easier than the general case.<br>&gt;&gt; <br>&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If the guarantee is *at least once* obviously @once is not the right attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It would be great if @required took into the account the feedback from that proposal and considered the synchronous case too.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;&gt;     let result: SomeEnum<br>&gt;&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     if aCondition {<br>&gt;&gt;&gt;       if bCondition {<br>&gt;&gt;&gt;         result = .Foo<br>&gt;&gt;&gt;       } else {<br>&gt;&gt;&gt;         result = .Bar<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;&gt;       return<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     if cCondition {<br>&gt;&gt;&gt;       result = .Baz<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This has actually been proposed before, see SE-0073: https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion is for escaping closures.  I don&#39;t think the compiler can verify this for noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/d1e13e24/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June  6, 2016 at 09:00:00am</p></header><div class="content"><p>Perhaps I was unclear, in my explanation. The guarantee I&#39;m enforcing is<br>that the closure is called exactly once before being released.<br></p><p>Everything I suggested is a compile-time check.<br></p><p>The compile-time warning and runtime `fatalError` I suggested could be<br>replaced with a compile-time error, however even in this case it is still<br>statically checked for the warning.<br></p><p>The compiler can statically guarantee *exactly one* of these things happens<br>in methods using the closure:<br></p><p>   - the closure is *called*<br>   - the closure is *stored*<br>   - the closure is *passed* to another method<br>   - the program *aborts* with something like a fatalError<br></p><p>If the closure is stored then there must be a *deinit*, and those checks<br>apply there as well.<br></p><p>I believe this is sufficient to ensure the closure is called once. Please<br>let me know if there are any cases these checks miss.<br></p><p>On Sun, Jun 5, 2016 at 11:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; Storing into a member would be fine, as long as it must keep @once as a<br>&gt; type annotation and the compiler makes sure you maintain:<br>&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt;<br>&gt; For example:<br>&gt;   class Example {<br>&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt;<br>&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;<br>&gt;       // the compiler should error if it detects the closure:<br>&gt;<br>&gt;       //  * escaping more than once, while still being stored,<br>&gt;<br>&gt;       //  * or being called while still being stored or escaping,<br>&gt;<br>&gt;       //  * or being overwritten without being called<br>&gt;<br>&gt;       if let closure = self.closure {<br>&gt;<br>&gt;         self.closure = replace<br>&gt;<br>&gt;         closure(value)<br>&gt;<br>&gt;       }<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     deinit {<br>&gt;<br>&gt;       // compiler warning: that closure is potentially un-called<br>&gt;<br>&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;   }<br>&gt;<br>&gt; There could be a standard library type with those guarantees built in.<br>&gt;<br>&gt;<br>&gt; I don&#39;t consider this compiler verification.  It is runtime verification.<br>&gt; The best the compiler can do is enforce constraints that allow for<br>&gt; guaranteed runtime verification.  You can argue that is better than nothing<br>&gt; but it is not a static guarantee of correct behavior.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like this.<br>&gt;&gt;<br>&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes @once<br>&gt;&gt; and works with escaping closures too. It might be possible if compile time<br>&gt;&gt; checks verified that the closure isn&#39;t copied, and that it is called before<br>&gt;&gt; being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in<br>&gt;&gt; the cases the compiler can&#39;t check.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a<br>&gt;&gt; member or global it could be verified and that is a pretty common case.<br>&gt;&gt; That would certainly be easier than the general case.<br>&gt;&gt;<br>&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If<br>&gt;&gt; the guarantee is *at least once* obviously @once is not the right<br>&gt;&gt; attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It would be great if @required took into the account the feedback from<br>&gt;&gt; that proposal and considered the synchronous case too.<br>&gt;&gt;<br>&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;<br>&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;<br>&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;<br>&gt;&gt;     let result: SomeEnum<br>&gt;&gt;<br>&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;<br>&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     if aCondition {<br>&gt;&gt;<br>&gt;&gt;       if bCondition {<br>&gt;&gt;<br>&gt;&gt;         result = .Foo<br>&gt;&gt;<br>&gt;&gt;       } else {<br>&gt;&gt;<br>&gt;&gt;         result = .Bar<br>&gt;&gt;<br>&gt;&gt;       }<br>&gt;&gt;<br>&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;<br>&gt;&gt;       return<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     if cCondition {<br>&gt;&gt;<br>&gt;&gt;       result = .Baz<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This has actually been proposed before, see SE-0073:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion is<br>&gt;&gt;&gt; for escaping closures.  I don&#39;t think the compiler can verify this for<br>&gt;&gt;&gt; noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing<br>&gt;&gt;&gt;&gt; asynchronous APIs that does not occur when writing synchronous APIs.<br>&gt;&gt;&gt;&gt; Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and<br>&gt;&gt;&gt;&gt; cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion<br>&gt;&gt;&gt;&gt; handler, and the problem might not be discovered until runtime (and,<br>&gt;&gt;&gt;&gt; depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments.<br>&gt;&gt;&gt;&gt; This attribute simply states that the given closure will always be<br>&gt;&gt;&gt;&gt; eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given<br>&gt;&gt;&gt;&gt; closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to<br>&gt;&gt;&gt;&gt; execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration,<br>&gt;&gt;&gt;&gt; it checks to make sure that every execution path either calls the closure<br>&gt;&gt;&gt;&gt; at some point, or sends a @required closure to another API that eventually<br>&gt;&gt;&gt;&gt; ends up calling the closure.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the<br>&gt;&gt;&gt;&gt; compiler emits an error letting the developer know about the bug in his/her<br>&gt;&gt;&gt;&gt; code.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/937aaea7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 07:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 5, 2016, at 6:50 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Perhaps I was unclear, in my explanation. The guarantee I&#39;m enforcing is that the closure is called exactly once before being released.<br>&gt; <br>&gt; Everything I suggested is a compile-time check.<br>&gt; <br>&gt; The compile-time warning and runtime `fatalError` I suggested could be replaced with a compile-time error, however even in this case it is still statically checked for the warning.<br>&gt; <br>&gt; The compiler can statically guarantee exactly one of these things happens in methods using the closure:<br>&gt; the closure is called<br>&gt; the closure is stored<br>&gt; the closure is passed to another method<br>&gt; the program aborts with something like a fatalError<br>&gt; If the closure is stored then there must be a deinit, and those checks apply there as well.<br>&gt; <br>&gt; I believe this is sufficient to ensure the closure is called once. Please let me know if there are any cases these checks miss.<br></p><p>If the closure is stored in a member it could be called in the implementation of any other member.  Calls to other members could come from arbitrary locations in the surrounding program at arbitrary points in time (unless you have static analysis that can prove a narrower set of possibilities).  And if you have a model that relies on behavior in a deinit then storing the closure won&#39;t be possible for structs.  You have also missed the case that the closure is captured by another closure (maybe it is a completion block and you call it in a completion block of a method your method calls).<br></p><p>&gt; <br>&gt;&gt; On Sun, Jun 5, 2016 at 11:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Storing into a member would be fine, as long as it must keep @once as a type annotation and the compiler makes sure you maintain:<br>&gt;&gt;&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;   class Example {<br>&gt;&gt;&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;&gt;&gt;       // the compiler should error if it detects the closure:<br>&gt;&gt;&gt;       //  * escaping more than once, while still being stored,<br>&gt;&gt;&gt;       //  * or being called while still being stored or escaping,<br>&gt;&gt;&gt;       //  * or being overwritten without being called<br>&gt;&gt;&gt;       if let closure = self.closure {<br>&gt;&gt;&gt;         self.closure = replace<br>&gt;&gt;&gt;         closure(value)<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;       // compiler warning: that closure is potentially un-called<br>&gt;&gt;&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There could be a standard library type with those guarantees built in.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t consider this compiler verification.  It is runtime verification.  The best the compiler can do is enforce constraints that allow for guaranteed runtime verification.  You can argue that is better than nothing but it is not a static guarantee of correct behavior.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes @once and works with escaping closures too. It might be possible if compile time checks verified that the closure isn&#39;t copied, and that it is called before being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in the cases the compiler can&#39;t check.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a member or global it could be verified and that is a pretty common case.  That would certainly be easier than the general case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If the guarantee is *at least once* obviously @once is not the right attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be great if @required took into the account the feedback from that proposal and considered the synchronous case too.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;     let result: SomeEnum<br>&gt;&gt;&gt;&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;&gt;&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     if aCondition {<br>&gt;&gt;&gt;&gt;&gt;       if bCondition {<br>&gt;&gt;&gt;&gt;&gt;         result = .Foo<br>&gt;&gt;&gt;&gt;&gt;       } else {<br>&gt;&gt;&gt;&gt;&gt;         result = .Bar<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;&gt;&gt;&gt;       return<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     if cCondition {<br>&gt;&gt;&gt;&gt;&gt;       result = .Baz<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This has actually been proposed before, see SE-0073: https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion is for escaping closures.  I don&#39;t think the compiler can verify this for noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/8d30493c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June  6, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks Matthew, my responses are inline:<br></p><p>On Mon, Jun 6, 2016 at 10:32 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 5, 2016, at 6:50 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; Perhaps I was unclear, in my explanation. The guarantee I&#39;m enforcing is<br>&gt; that the closure is called exactly once before being released.<br>&gt;<br>&gt; Everything I suggested is a compile-time check.<br>&gt;<br>&gt; The compile-time warning and runtime `fatalError` I suggested could be<br>&gt; replaced with a compile-time error, however even in this case it is still<br>&gt; statically checked for the warning.<br>&gt;<br>&gt; The compiler can statically guarantee *exactly one* of these things<br>&gt; happens in methods using the closure:<br>&gt;<br>&gt;    - the closure is *called*<br>&gt;    - the closure is *stored*<br>&gt;    - the closure is *passed* to another method<br>&gt;    - the program *aborts* with something like a fatalError<br>&gt;<br>&gt; If the closure is stored then there must be a *deinit*, and those checks<br>&gt; apply there as well.<br>&gt;<br>&gt; I believe this is sufficient to ensure the closure is called once. Please<br>&gt; let me know if there are any cases these checks miss.<br>&gt;<br>&gt;<br>&gt; If the closure is stored in a member it could be called in the<br>&gt; implementation of any other member.  Calls to other members could come from<br>&gt; arbitrary locations in the surrounding program at arbitrary points in time<br>&gt; (unless you have static analysis that can prove a narrower set of<br>&gt; possibilities).<br>&gt;<br></p><p>This isn&#39;t a problem if the member has to have the type annotation, all<br>uses of the member, whether from elsewhere in the program, or other<br>methods, would have to pass the checks.<br></p><p>If you call the closure you must nil/replace the member.<br></p><p>And if you have a model that relies on behavior in a deinit then storing<br>&gt; the closure won&#39;t be possible for structs.<br>&gt;<br></p><p>This is true, considering you don&#39;t want to copy a @once closure you<br>probably don&#39;t want value-type semantics anyway.<br></p><p>You have also missed the case that the closure is captured by another<br>&gt; closure (maybe it is a completion block and you call it in a completion<br>&gt; block of a method your method calls).<br>&gt;<br></p><p>This is correct. I forgot to mention that I&#39;m sorry, thanks for pointing it<br>out!<br></p><p>I was thinking that a @once closure can only be captured by another @once<br>closure. We can add that as another dot-point:<br></p><p><br>   - the closure is captured by another @once closure, this is the only<br>   time it can be captured.<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt; On Sun, Jun 5, 2016 at 11:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Storing into a member would be fine, as long as it must keep @once as a<br>&gt;&gt; type annotation and the compiler makes sure you maintain:<br>&gt;&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;   class Example {<br>&gt;&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt;&gt;<br>&gt;&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;&gt;<br>&gt;&gt;       // the compiler should error if it detects the closure:<br>&gt;&gt;<br>&gt;&gt;       //  * escaping more than once, while still being stored,<br>&gt;&gt;<br>&gt;&gt;       //  * or being called while still being stored or escaping,<br>&gt;&gt;<br>&gt;&gt;       //  * or being overwritten without being called<br>&gt;&gt;<br>&gt;&gt;       if let closure = self.closure {<br>&gt;&gt;<br>&gt;&gt;         self.closure = replace<br>&gt;&gt;<br>&gt;&gt;         closure(value)<br>&gt;&gt;<br>&gt;&gt;       }<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     deinit {<br>&gt;&gt;<br>&gt;&gt;       // compiler warning: that closure is potentially un-called<br>&gt;&gt;<br>&gt;&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;&gt;<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt; There could be a standard library type with those guarantees built in.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t consider this compiler verification.  It is runtime<br>&gt;&gt; verification.  The best the compiler can do is enforce constraints that<br>&gt;&gt; allow for guaranteed runtime verification.  You can argue that is better<br>&gt;&gt; than nothing but it is not a static guarantee of correct behavior.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like this.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes @once<br>&gt;&gt;&gt; and works with escaping closures too. It might be possible if compile time<br>&gt;&gt;&gt; checks verified that the closure isn&#39;t copied, and that it is called before<br>&gt;&gt;&gt; being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in<br>&gt;&gt;&gt; the cases the compiler can&#39;t check.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a<br>&gt;&gt;&gt; member or global it could be verified and that is a pretty common case.<br>&gt;&gt;&gt; That would certainly be easier than the general case.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If<br>&gt;&gt;&gt; the guarantee is *at least once* obviously @once is not the right<br>&gt;&gt;&gt; attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be great if @required took into the account the feedback from<br>&gt;&gt;&gt; that proposal and considered the synchronous case too.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let result: SomeEnum<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     if aCondition {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       if bCondition {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         result = .Foo<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       } else {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         result = .Bar<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       return<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     if cCondition {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       result = .Baz<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This has actually been proposed before, see SE-0073:<br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion is<br>&gt;&gt;&gt;&gt; for escaping closures.  I don&#39;t think the compiler can verify this for<br>&gt;&gt;&gt;&gt; noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing<br>&gt;&gt;&gt;&gt;&gt; asynchronous APIs that does not occur when writing synchronous APIs.<br>&gt;&gt;&gt;&gt;&gt; Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and<br>&gt;&gt;&gt;&gt;&gt; cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion<br>&gt;&gt;&gt;&gt;&gt; handler, and the problem might not be discovered until runtime (and,<br>&gt;&gt;&gt;&gt;&gt; depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments.<br>&gt;&gt;&gt;&gt;&gt; This attribute simply states that the given closure will always be<br>&gt;&gt;&gt;&gt;&gt; eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given<br>&gt;&gt;&gt;&gt;&gt; closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to<br>&gt;&gt;&gt;&gt;&gt; execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function<br>&gt;&gt;&gt;&gt;&gt; declaration, it checks to make sure that every execution path either calls<br>&gt;&gt;&gt;&gt;&gt; the closure at some point, or sends a @required closure to another API that<br>&gt;&gt;&gt;&gt;&gt; eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the<br>&gt;&gt;&gt;&gt;&gt; compiler emits an error letting the developer know about the bug in his/her<br>&gt;&gt;&gt;&gt;&gt; code.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/fa0f19b6/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 5, 2016, at 8:43 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Thanks Matthew, my responses are inline:<br>&gt; <br>&gt;&gt; On Mon, Jun 6, 2016 at 10:32 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 6:50 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps I was unclear, in my explanation. The guarantee I&#39;m enforcing is that the closure is called exactly once before being released.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything I suggested is a compile-time check.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compile-time warning and runtime `fatalError` I suggested could be replaced with a compile-time error, however even in this case it is still statically checked for the warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler can statically guarantee exactly one of these things happens in methods using the closure:<br>&gt;&gt;&gt; the closure is called<br>&gt;&gt;&gt; the closure is stored<br>&gt;&gt;&gt; the closure is passed to another method<br>&gt;&gt;&gt; the program aborts with something like a fatalError<br>&gt;&gt;&gt; If the closure is stored then there must be a deinit, and those checks apply there as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe this is sufficient to ensure the closure is called once. Please let me know if there are any cases these checks miss.<br>&gt;&gt; <br>&gt;&gt; If the closure is stored in a member it could be called in the implementation of any other member.  Calls to other members could come from arbitrary locations in the surrounding program at arbitrary points in time (unless you have static analysis that can prove a narrower set of possibilities).<br>&gt;  <br>&gt; This isn&#39;t a problem if the member has to have the type annotation, all uses of the member, whether from elsewhere in the program, or other methods, would have to pass the checks.<br>&gt; <br>&gt; If you call the closure you must nil/replace the member.<br></p><p>Ok, so the member must be an optional?  If that is the idea I would suggest considering something similar to &#39;weak&#39; where it automatically gets set to nil after it is called (which could maybe become a property behavior in the future).<br></p><p>I don&#39;t think you mentioned the case of reassigning the member when it is non-nil.  You would have to require users to verify it is nil before setting it or if it is not nil, calling it before assigning to it.<br></p><p>&gt; <br>&gt;&gt; And if you have a model that relies on behavior in a deinit then storing the closure won&#39;t be possible for structs.<br>&gt;  <br>&gt; This is true, considering you don&#39;t want to copy a @once closure you probably don&#39;t want value-type semantics anyway.<br></p><p>That&#39;s a good point.  Since we don&#39;t have control over copy behavior in Swift it wouldn&#39;t make sense at all unless / until we can make structs that have move semantics (maybe if / when we get a Rust-like ownership system?).<br></p><p>&gt; <br>&gt;&gt; You have also missed the case that the closure is captured by another closure (maybe it is a completion block and you call it in a completion block of a method your method calls).<br>&gt;  <br>&gt; This is correct. I forgot to mention that I&#39;m sorry, thanks for pointing it out!<br>&gt; <br>&gt; I was thinking that a @once closure can only be captured by another @once closure. We can add that as another dot-point:<br>&gt; <br>&gt; the closure is captured by another @once closure, this is the only time it can be captured.<br>I like the idea behind this proposal in theory.  However, it really seems to cry out for linear types.  I have a feeling we would end up with a better (and more general) solution if Swift goes down that path in the future.  At minimum, I would like to hear input from those who work on the type system.  If a more robust, less ad-hoc solution will be possible in the future it might be best to wait.<br></p><p>On the other hand, completion callbacks that require this guarantee are pretty common.  The semantic is part of the contract whether we have language support for it or not.  Maybe we can do something now that could be subsumed by a more general feature in the future...<br></p><p>&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Storing into a member would be fine, as long as it must keep @once as a type annotation and the compiler makes sure you maintain:<br>&gt;&gt;&gt;&gt;&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;&gt;   class Example {<br>&gt;&gt;&gt;&gt;&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;&gt;&gt;&gt;&gt;       // the compiler should error if it detects the closure:<br>&gt;&gt;&gt;&gt;&gt;       //  * escaping more than once, while still being stored,<br>&gt;&gt;&gt;&gt;&gt;       //  * or being called while still being stored or escaping,<br>&gt;&gt;&gt;&gt;&gt;       //  * or being overwritten without being called<br>&gt;&gt;&gt;&gt;&gt;       if let closure = self.closure {<br>&gt;&gt;&gt;&gt;&gt;         self.closure = replace<br>&gt;&gt;&gt;&gt;&gt;         closure(value)<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;&gt;       // compiler warning: that closure is potentially un-called<br>&gt;&gt;&gt;&gt;&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There could be a standard library type with those guarantees built in.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t consider this compiler verification.  It is runtime verification.  The best the compiler can do is enforce constraints that allow for guaranteed runtime verification.  You can argue that is better than nothing but it is not a static guarantee of correct behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I like this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes @once and works with escaping closures too. It might be possible if compile time checks verified that the closure isn&#39;t copied, and that it is called before being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in the cases the compiler can&#39;t check.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a member or global it could be verified and that is a pretty common case.  That would certainly be easier than the general case.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If the guarantee is *at least once* obviously @once is not the right attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It would be great if @required took into the account the feedback from that proposal and considered the synchronous case too.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     let result: SomeEnum<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         result = .Foo<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;         result = .Bar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       result = .Baz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This has actually been proposed before, see SE-0073: https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion is for escaping closures.  I don&#39;t think the compiler can verify this for noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/f469ecb5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>June  6, 2016 at 12:00:00pm</p></header><div class="content"><p>Responses inline<br></p><p>On Mon, Jun 6, 2016 at 12:23 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Jun 5, 2016, at 8:43 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;<br>&gt; Thanks Matthew, my responses are inline:<br>&gt;<br>&gt; On Mon, Jun 6, 2016 at 10:32 AM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sent from my iPad<br>&gt;&gt;<br>&gt;&gt; On Jun 5, 2016, at 6:50 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Perhaps I was unclear, in my explanation. The guarantee I&#39;m enforcing is<br>&gt;&gt; that the closure is called exactly once before being released.<br>&gt;&gt;<br>&gt;&gt; Everything I suggested is a compile-time check.<br>&gt;&gt;<br>&gt;&gt; The compile-time warning and runtime `fatalError` I suggested could be<br>&gt;&gt; replaced with a compile-time error, however even in this case it is still<br>&gt;&gt; statically checked for the warning.<br>&gt;&gt;<br>&gt;&gt; The compiler can statically guarantee *exactly one* of these things<br>&gt;&gt; happens in methods using the closure:<br>&gt;&gt;<br>&gt;&gt;    - the closure is *called*<br>&gt;&gt;    - the closure is *stored*<br>&gt;&gt;    - the closure is *passed* to another method<br>&gt;&gt;    - the program *aborts* with something like a fatalError<br>&gt;&gt;<br>&gt;&gt; If the closure is stored then there must be a *deinit*, and those checks<br>&gt;&gt; apply there as well.<br>&gt;&gt;<br>&gt;&gt; I believe this is sufficient to ensure the closure is called once. Please<br>&gt;&gt; let me know if there are any cases these checks miss.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; If the closure is stored in a member it could be called in the<br>&gt;&gt; implementation of any other member.  Calls to other members could come from<br>&gt;&gt; arbitrary locations in the surrounding program at arbitrary points in time<br>&gt;&gt; (unless you have static analysis that can prove a narrower set of<br>&gt;&gt; possibilities).<br>&gt;&gt;<br>&gt;<br>&gt; This isn&#39;t a problem if the member has to have the type annotation, all<br>&gt; uses of the member, whether from elsewhere in the program, or other<br>&gt; methods, would have to pass the checks.<br>&gt;<br>&gt; If you call the closure you must nil/replace the member.<br>&gt;<br>&gt;<br>&gt; Ok, so the member must be an optional?  If that is the idea I would<br>&gt; suggest considering something similar to &#39;weak&#39; where it automatically gets<br>&gt; set to nil after it is called (which could maybe become a property behavior<br>&gt; in the future).<br>&gt;<br></p><p>That&#39;s a great idea, auto-nilling would work well. I was also thinking it<br>should be possible to replace an existing non-optional stored closure if<br>you call the old one in the old scope (see the callClosure method in my<br>previous post). However auto-nilling could simplify the concept.<br></p><p><br>&gt; I don&#39;t think you mentioned the case of reassigning the member when it is<br>&gt; non-nil.  You would have to require users to verify it is nil before<br>&gt; setting it or if it is not nil, calling it before assigning to it.<br>&gt;<br>&gt;<br>&gt; And if you have a model that relies on behavior in a deinit then storing<br>&gt;&gt; the closure won&#39;t be possible for structs.<br>&gt;&gt;<br>&gt;<br>&gt; This is true, considering you don&#39;t want to copy a @once closure you<br>&gt; probably don&#39;t want value-type semantics anyway.<br>&gt;<br>&gt;<br>&gt; That&#39;s a good point.  Since we don&#39;t have control over copy behavior in<br>&gt; Swift it wouldn&#39;t make sense at all unless / until we can make structs that<br>&gt; have move semantics (maybe if / when we get a Rust-like ownership system?).<br>&gt;<br>Interesting, thanks, I wasn&#39;t aware of Rust&#39;s ownership concept - I&#39;ve been<br>working on a related proposal for Swift.<br></p><p><br>&gt;<br>&gt; You have also missed the case that the closure is captured by another<br>&gt;&gt; closure (maybe it is a completion block and you call it in a completion<br>&gt;&gt; block of a method your method calls).<br>&gt;&gt;<br>&gt;<br>&gt; This is correct. I forgot to mention that I&#39;m sorry, thanks for pointing<br>&gt; it out!<br>&gt;<br>&gt; I was thinking that a @once closure can only be captured by another @once<br>&gt; closure. We can add that as another dot-point:<br>&gt;<br>&gt;<br>&gt;    - the closure is captured by another @once closure, this is the only<br>&gt;    time it can be captured.<br>&gt;<br>&gt; I like the idea behind this proposal in theory.  However, it really seems<br>&gt; to cry out for linear types.  I have a feeling we would end up with a<br>&gt; better (and more general) solution if Swift goes down that path in the<br>&gt; future.  At minimum, I would like to hear input from those who work on the<br>&gt; type system.  If a more robust, less ad-hoc solution will be possible in<br>&gt; the future it might be best to wait.<br>&gt;<br>&gt; On the other hand, completion callbacks that require this guarantee are<br>&gt; pretty common.  The semantic is part of the contract whether we have<br>&gt; language support for it or not.  Maybe we can do something now that could<br>&gt; be subsumed by a more general feature in the future...<br>&gt;<br>&gt; I have the same thinking, I&#39;d like the semantics now, and as as strongly<br>as the language can allow. If the language gets better type support then we<br>get better or less restrictive assurances.<br></p><p><br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Jun 5, 2016 at 11:59 PM, Matthew Johnson &lt;matthew at anandabits.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Storing into a member would be fine, as long as it must keep @once as a<br>&gt;&gt;&gt; type annotation and the compiler makes sure you maintain:<br>&gt;&gt;&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;   class Example {<br>&gt;&gt;&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       // the compiler should error if it detects the closure:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       //  * escaping more than once, while still being stored,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       //  * or being called while still being stored or escaping,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       //  * or being overwritten without being called<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       if let closure = self.closure {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         self.closure = replace<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         closure(value)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       // compiler warning: that closure is potentially un-called<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There could be a standard library type with those guarantees built in.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t consider this compiler verification.  It is runtime<br>&gt;&gt;&gt; verification.  The best the compiler can do is enforce constraints that<br>&gt;&gt;&gt; allow for guaranteed runtime verification.  You can argue that is better<br>&gt;&gt;&gt; than nothing but it is not a static guarantee of correct behavior.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com<br>&gt;&gt;&gt; &gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I like this.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes<br>&gt;&gt;&gt;&gt; @once and works with escaping closures too. It might be possible if compile<br>&gt;&gt;&gt;&gt; time checks verified that the closure isn&#39;t copied, and that it is called<br>&gt;&gt;&gt;&gt; before being deinit-ialized. Failing that I&#39;m happy with a runtime<br>&gt;&gt;&gt;&gt; circumstance in the cases the compiler can&#39;t check.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a<br>&gt;&gt;&gt;&gt; member or global it could be verified and that is a pretty common case.<br>&gt;&gt;&gt;&gt; That would certainly be easier than the general case.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If<br>&gt;&gt;&gt;&gt; the guarantee is *at least once* obviously @once is not the right<br>&gt;&gt;&gt;&gt; attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; It would be great if @required took into the account the feedback from<br>&gt;&gt;&gt;&gt; that proposal and considered the synchronous case too.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let result: SomeEnum<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     if aCondition {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       if bCondition {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         result = .Foo<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       } else {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         result = .Bar<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       return<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     if cCondition {<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;       result = .Baz<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; This has actually been proposed before, see SE-0073:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion<br>&gt;&gt;&gt;&gt;&gt; is for escaping closures.  I don&#39;t think the compiler can verify this for<br>&gt;&gt;&gt;&gt;&gt; noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing<br>&gt;&gt;&gt;&gt;&gt;&gt; asynchronous APIs that does not occur when writing synchronous APIs.<br>&gt;&gt;&gt;&gt;&gt;&gt; Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and<br>&gt;&gt;&gt;&gt;&gt;&gt; cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its<br>&gt;&gt;&gt;&gt;&gt;&gt; completion handler, and the problem might not be discovered until runtime<br>&gt;&gt;&gt;&gt;&gt;&gt; (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments.<br>&gt;&gt;&gt;&gt;&gt;&gt; This attribute simply states that the given closure will always be<br>&gt;&gt;&gt;&gt;&gt;&gt; eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given<br>&gt;&gt;&gt;&gt;&gt;&gt; closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise<br>&gt;&gt;&gt;&gt;&gt;&gt; to execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function<br>&gt;&gt;&gt;&gt;&gt;&gt; declaration, it checks to make sure that every execution path either calls<br>&gt;&gt;&gt;&gt;&gt;&gt; the closure at some point, or sends a @required closure to another API that<br>&gt;&gt;&gt;&gt;&gt;&gt; eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the<br>&gt;&gt;&gt;&gt;&gt;&gt; compiler emits an error letting the developer know about the bug in his/her<br>&gt;&gt;&gt;&gt;&gt;&gt; code.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/cefe5f77/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  5, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 9:40 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br>&gt; <br>&gt; Responses inline<br>&gt; <br>&gt; On Mon, Jun 6, 2016 at 12:23 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Jun 5, 2016, at 8:43 PM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Thanks Matthew, my responses are inline:<br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 6, 2016 at 10:32 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt; On Jun 5, 2016, at 6:50 PM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Perhaps I was unclear, in my explanation. The guarantee I&#39;m enforcing is that the closure is called exactly once before being released.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything I suggested is a compile-time check.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compile-time warning and runtime `fatalError` I suggested could be replaced with a compile-time error, however even in this case it is still statically checked for the warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The compiler can statically guarantee exactly one of these things happens in methods using the closure:<br>&gt;&gt;&gt; the closure is called<br>&gt;&gt;&gt; the closure is stored<br>&gt;&gt;&gt; the closure is passed to another method<br>&gt;&gt;&gt; the program aborts with something like a fatalError<br>&gt;&gt;&gt; If the closure is stored then there must be a deinit, and those checks apply there as well.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe this is sufficient to ensure the closure is called once. Please let me know if there are any cases these checks miss.<br>&gt;&gt; <br>&gt;&gt; If the closure is stored in a member it could be called in the implementation of any other member.  Calls to other members could come from arbitrary locations in the surrounding program at arbitrary points in time (unless you have static analysis that can prove a narrower set of possibilities).<br>&gt;&gt;  <br>&gt;&gt; This isn&#39;t a problem if the member has to have the type annotation, all uses of the member, whether from elsewhere in the program, or other methods, would have to pass the checks.<br>&gt;&gt; <br>&gt;&gt; If you call the closure you must nil/replace the member.<br>&gt; <br>&gt; Ok, so the member must be an optional?  If that is the idea I would suggest considering something similar to &#39;weak&#39; where it automatically gets set to nil after it is called (which could maybe become a property behavior in the future).<br>&gt;  <br>&gt; That&#39;s a great idea, auto-nilling would work well. I was also thinking it should be possible to replace an existing non-optional stored closure if you call the old one in the old scope (see the callClosure method in my previous post). However auto-nilling could simplify the concept.<br>&gt; <br>&gt; <br>&gt; I don&#39;t think you mentioned the case of reassigning the member when it is non-nil.  You would have to require users to verify it is nil before setting it or if it is not nil, calling it before assigning to it.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; And if you have a model that relies on behavior in a deinit then storing the closure won&#39;t be possible for structs.<br>&gt;&gt;  <br>&gt;&gt; This is true, considering you don&#39;t want to copy a @once closure you probably don&#39;t want value-type semantics anyway.<br>&gt; <br>&gt; That&#39;s a good point.  Since we don&#39;t have control over copy behavior in Swift it wouldn&#39;t make sense at all unless / until we can make structs that have move semantics (maybe if / when we get a Rust-like ownership system?).<br>&gt; Interesting, thanks, I wasn&#39;t aware of Rust&#39;s ownership concept - I&#39;ve been working on a related proposal for Swift.<br></p><p>Rust is really leading the way here in bringing linear types into a mainstream language.  Getting it right isn’t easy.  Rust’s system has evolved quite a bit over the years since they began.  It will be good to learn as much as possible from Rust (both what it gets right and also areas that could maybe be improved). <br></p><p>If you have a draft of anything and would like feedback feel free to send me a link (on or off list).  I have a lot of interest in this area as well.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; You have also missed the case that the closure is captured by another closure (maybe it is a completion block and you call it in a completion block of a method your method calls).<br>&gt;&gt;  <br>&gt;&gt; This is correct. I forgot to mention that I&#39;m sorry, thanks for pointing it out!<br>&gt;&gt; <br>&gt;&gt; I was thinking that a @once closure can only be captured by another @once closure. We can add that as another dot-point:<br>&gt;&gt; <br>&gt;&gt; the closure is captured by another @once closure, this is the only time it can be captured.<br>&gt; <br>&gt; I like the idea behind this proposal in theory.  However, it really seems to cry out for linear types.  I have a feeling we would end up with a better (and more general) solution if Swift goes down that path in the future.  At minimum, I would like to hear input from those who work on the type system.  If a more robust, less ad-hoc solution will be possible in the future it might be best to wait.<br>&gt; <br>&gt; On the other hand, completion callbacks that require this guarantee are pretty common.  The semantic is part of the contract whether we have language support for it or not.  Maybe we can do something now that could be subsumed by a more general feature in the future...<br>&gt; <br>&gt; I have the same thinking, I&#39;d like the semantics now, and as as strongly as the language can allow. If the language gets better type support then we get better or less restrictive assurances.<br>&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:59 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 5, 2016, at 8:52 AM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Storing into a member would be fine, as long as it must keep @once as a type annotation and the compiler makes sure you maintain:<br>&gt;&gt;&gt;&gt;     sum(callCount, storeCount, passCount) == 1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For example:<br>&gt;&gt;&gt;&gt;   class Example {<br>&gt;&gt;&gt;&gt;     private var closure: (@once (T) -&gt; Void)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func callClosure(value: T, replace: (@once (T) -&gt; Void)? = nil) {<br>&gt;&gt;&gt;&gt;       // the compiler should error if it detects the closure:<br>&gt;&gt;&gt;&gt;       //  * escaping more than once, while still being stored,<br>&gt;&gt;&gt;&gt;       //  * or being called while still being stored or escaping,<br>&gt;&gt;&gt;&gt;       //  * or being overwritten without being called<br>&gt;&gt;&gt;&gt;       if let closure = self.closure {<br>&gt;&gt;&gt;&gt;         self.closure = replace<br>&gt;&gt;&gt;&gt;         closure(value)<br>&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     deinit {<br>&gt;&gt;&gt;&gt;       // compiler warning: that closure is potentially un-called<br>&gt;&gt;&gt;&gt;       // runtime fatalError if it&#39;s .Some(Closure) after deinit<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There could be a standard library type with those guarantees built in.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t consider this compiler verification.  It is runtime verification.  The best the compiler can do is enforce constraints that allow for guaranteed runtime verification.  You can argue that is better than nothing but it is not a static guarantee of correct behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 10:12 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 5, 2016, at 6:56 AM, Andrew Bennett &lt;cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I like this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One of the suggestions on @noescape(once) was that it just becomes @once and works with escaping closures too. It might be possible if compile time checks verified that the closure isn&#39;t copied, and that it is called before being deinit-ialized. Failing that I&#39;m happy with a runtime circumstance in the cases the compiler can&#39;t check.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, maybe if it is only used asynchronously and never stored in a member or global it could be verified and that is a pretty common case.  That would certainly be easier than the general case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I prefer @once over @required if the guarantee is single execution.  If the guarantee is *at least once* obviously @once is not the right attribute, but I&#39;m not convinced @required is either.  Maybe @invoked.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It would be great if @required took into the account the feedback from that proposal and considered the synchronous case too.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As an aside, you can get some of the guarantees you want like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;   dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;     let result: SomeEnum<br>&gt;&gt;&gt;&gt;&gt;     // the compiler ensures &#39;result&#39; is set<br>&gt;&gt;&gt;&gt;&gt;     defer { completionHandler(result) }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     if aCondition {<br>&gt;&gt;&gt;&gt;&gt;       if bCondition {<br>&gt;&gt;&gt;&gt;&gt;         result = .Foo<br>&gt;&gt;&gt;&gt;&gt;       } else {<br>&gt;&gt;&gt;&gt;&gt;         result = .Bar<br>&gt;&gt;&gt;&gt;&gt;       }<br>&gt;&gt;&gt;&gt;&gt;       // the compiler ensures you do this, because it is &#39;let&#39;<br>&gt;&gt;&gt;&gt;&gt;       return<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     if cCondition {<br>&gt;&gt;&gt;&gt;&gt;       result = .Baz<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 9:42 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 5, 2016, at 5:02 AM, Patrick Pijnappel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This has actually been proposed before, see SE-0073: https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md&gt;<br>&gt;&gt;&gt;&gt;&gt; Actually that proposal was for noescape closures and this suggestion is for escaping closures.  I don&#39;t think the compiler can verify this for noescape closures.  If it is possible it would be far more complicated.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jun 5, 2016 at 11:37 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; MOTIVATION:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;&gt;&gt;&gt;&gt;         if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Foo<br>&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Bar<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         return .Baz<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; However, consider the equivalent async API:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         dispatch_async(someQueue) {<br>&gt;&gt;&gt;&gt;&gt;&gt;                 if aCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         if bCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Foo)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Bar)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;                 } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;                         if cCondition {<br>&gt;&gt;&gt;&gt;&gt;&gt;                                 completionHandler(.Baz)<br>&gt;&gt;&gt;&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;&gt;&gt;&gt;                 }<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Whoops, now the function can return without ever firing its completion handler, and the problem might not be discovered until runtime (and, depending on the complexity of the function, may be hard to find).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; PROPOSED SOLUTION:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Add a @required attribute that can be applied to closure arguments. This attribute simply states that the given closure will always be eventually called, and the compiler can enforce this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; DETAILED DESIGN:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - The @required attribute states in our API contract that a given closure *must* be called at some point after the function is called.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Standard API calls like dispatch_async that contractually promise to execute a closure or block get @required added to their signatures.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - When the compiler sees a @required closure in a function declaration, it checks to make sure that every execution path either calls the closure at some point, or sends a @required closure to another API that eventually ends up calling the closure.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - If there’s a way for a @required closure not to be called, the compiler emits an error letting the developer know about the bug in his/her code.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMPACT ON EXISTING CODE:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; None. This is purely additive.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ALTERNATIVES CONSIDERED:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I got nothin’.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charles<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/a5cad4cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 05.06.2016 um 11:37 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; As per the current situation, there is a pitfall when writing asynchronous APIs that does not occur when writing synchronous APIs. Consider the following synchronous API:<br>&gt; <br>&gt; func doSomething() -&gt; SomeEnum {<br>&gt; 	if aCondition {<br>&gt; 		if bCondition {<br>&gt; 			return .Foo<br>&gt; 		} else {<br>&gt; 			return .Bar<br>&gt; 		}<br>&gt; 	} else {<br>&gt; 		if cCondition {<br>&gt; 			return .Baz<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br></p><p>That&#39;s a good design...<br></p><p>&gt; The compiler will give an error here, since if both aCondition and cCondition are false, the function will not return anything.<br>&gt; <br>&gt; However, consider the equivalent async API:<br>&gt; <br>&gt; func doSomething(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt; 	dispatch_async(someQueue) {<br>&gt; 		if aCondition {<br>&gt; 			if bCondition {<br>&gt; 				completionHandler(.Foo)<br>&gt; 			} else {<br>&gt; 				completionHandler(.Bar)<br>&gt; 			}<br>&gt; 		} else {<br>&gt; 			if cCondition {<br>&gt; 				completionHandler(.Baz)<br>&gt; 			}<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br></p><p>This is not a good design. If you want the completion handler to be called, you can rewrite the function to make this intent obvious:<br></p><p>func doSomethingAsync(completionHandler: (SomeEnum) -&gt; ()) {<br>    dispatch_async(someQueue) {<br>        let result = doSomething()<br>        completionBlock(result)<br>    }<br>}<br></p><p>func doSomething() -&gt; SomeEnum {<br>    if aCondition {<br>        if bCondition {<br>            return .Foo<br>        } else {<br>            return .Bar<br>        }<br>    } else {<br>        if cCondition {<br>            return .Baz<br>        }<br>    }<br>}<br></p><p>and this begs the question why the doSomethingAsync() function is needed at all.. Calling dispatch_async directly is probably more convenient and the abstraction of doSomething() probably not that useful.. (I know the example is overly simplistic, but I can apply the same reasoning to more complex scenarios just as easily too.)<br></p><p>IMHO, asynchronous programming is only a good thing when used in moderation. In most cases that I see, it just makes everything harder to reason about. For most applications, it&#39;s best to have one UI thread and one worker thread. This leads to code that is debuggable, testable and inspectable. For example, it wouldn&#39;t help a C compiler if it can use multiple threads to compile a file; usually you have much more files to compile than cores, so you can let `make` do the scheduling. Concurrency-management code and application code should never be mixed, as much as possible and practical. Asynchronous code violates this principle regularly.<br></p><p>assert(async programming == Goto 2.0)<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 10:28 AM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; This is not a good design. If you want the completion handler to be called, you can rewrite the function to make this intent obvious:<br>&gt; <br>&gt; func doSomethingAsync(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;    dispatch_async(someQueue) {<br>&gt;        let result = doSomething()<br>&gt;        completionBlock(result)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; func doSomething() -&gt; SomeEnum {<br>&gt;    if aCondition {<br>&gt;        if bCondition {<br>&gt;            return .Foo<br>&gt;        } else {<br>&gt;            return .Bar<br>&gt;        }<br>&gt;    } else {<br>&gt;        if cCondition {<br>&gt;            return .Baz<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; and this begs the question why the doSomethingAsync() function is needed at all.. Calling dispatch_async directly is probably more convenient and the abstraction of doSomething() probably not that useful.. (I know the example is overly simplistic, but I can apply the same reasoning to more complex scenarios just as easily too.)<br>&gt; <br>&gt; IMHO, asynchronous programming is only a good thing when used in moderation. In most cases that I see, it just makes everything harder to reason about. For most applications, it&#39;s best to have one UI thread and one worker thread. This leads to code that is debuggable, testable and inspectable. For example, it wouldn&#39;t help a C compiler if it can use multiple threads to compile a file; usually you have much more files to compile than cores, so you can let `make` do the scheduling. Concurrency-management code and application code should never be mixed, as much as possible and practical. Asynchronous code violates this principle regularly.<br>&gt; <br>&gt; assert(async programming == Goto 2.0)<br></p><p>Well, the example I gave *was* deliberately simplistic; there are many cases where the code needs to call APIs which themselves are asynchronous. If the purpose of doSomething() is to grab something from the network, and then do something with it, then it’s going to be using async APIs under the hood if you’re doing it the recommended way. Similarly, if the method grabs something from another task using XPC, that’s asynchronous. Pop up a sheet to ask the user for feedback before continuing? Asynchronous. NSUserScriptTask? Asynchronous. Yeah, you can use a dispatch semaphore to hack these async APIs into synchronous ones, but then you’re violating Apple’s recommendation about never blocking dispatch queues.<br></p><p>Anyway, I don’t think asynchronous APIs are going away any time soon, and it would be nice if it were easier to safely write them.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/3bc8d1f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June  5, 2016 at 08:00:00pm</p></header><div class="content"><p>While I agree with Michael that nowadays, a lot of stuff that doesn&#39;t need to be, is done async, which leads to a giant thread pool per app and developers nowadays do not think of the cost of inter-thread communication (i.e. each dispatch_(a)sync has its cost, even though it&#39;s a light-weight thread), I agree with Charles that something like suggested does indeed help debugging issues with multi-thread apps.<br></p><p><br>&gt; On Jun 5, 2016, at 7:59 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 10:28 AM, Michael Peternell &lt;michael.peternell at gmx.at &lt;mailto:michael.peternell at gmx.at&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is not a good design. If you want the completion handler to be called, you can rewrite the function to make this intent obvious:<br>&gt;&gt; <br>&gt;&gt; func doSomethingAsync(completionHandler: (SomeEnum) -&gt; ()) {<br>&gt;&gt;    dispatch_async(someQueue) {<br>&gt;&gt;        let result = doSomething()<br>&gt;&gt;        completionBlock(result)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func doSomething() -&gt; SomeEnum {<br>&gt;&gt;    if aCondition {<br>&gt;&gt;        if bCondition {<br>&gt;&gt;            return .Foo<br>&gt;&gt;        } else {<br>&gt;&gt;            return .Bar<br>&gt;&gt;        }<br>&gt;&gt;    } else {<br>&gt;&gt;        if cCondition {<br>&gt;&gt;            return .Baz<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; and this begs the question why the doSomethingAsync() function is needed at all.. Calling dispatch_async directly is probably more convenient and the abstraction of doSomething() probably not that useful.. (I know the example is overly simplistic, but I can apply the same reasoning to more complex scenarios just as easily too.)<br>&gt;&gt; <br>&gt;&gt; IMHO, asynchronous programming is only a good thing when used in moderation. In most cases that I see, it just makes everything harder to reason about. For most applications, it&#39;s best to have one UI thread and one worker thread. This leads to code that is debuggable, testable and inspectable. For example, it wouldn&#39;t help a C compiler if it can use multiple threads to compile a file; usually you have much more files to compile than cores, so you can let `make` do the scheduling. Concurrency-management code and application code should never be mixed, as much as possible and practical. Asynchronous code violates this principle regularly.<br>&gt;&gt; <br>&gt;&gt; assert(async programming == Goto 2.0)<br>&gt; <br>&gt; Well, the example I gave *was* deliberately simplistic; there are many cases where the code needs to call APIs which themselves are asynchronous. If the purpose of doSomething() is to grab something from the network, and then do something with it, then it’s going to be using async APIs under the hood if you’re doing it the recommended way. Similarly, if the method grabs something from another task using XPC, that’s asynchronous. Pop up a sheet to ask the user for feedback before continuing? Asynchronous. NSUserScriptTask? Asynchronous. Yeah, you can use a dispatch semaphore to hack these async APIs into synchronous ones, but then you’re violating Apple’s recommendation about never blocking dispatch queues.<br>&gt; <br>&gt; Anyway, I don’t think asynchronous APIs are going away any time soon, and it would be nice if it were easier to safely write them.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/b4b5f41e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; Am 05.06.2016 um 20:31 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; While I agree with Michael that nowadays, a lot of stuff that doesn&#39;t need to be, is done async, which leads to a giant thread pool per app and developers nowadays do not think of the cost of inter-thread communication (i.e. each dispatch_(a)sync has its cost, even though it&#39;s a light-weight thread), I agree with Charles that something like suggested does indeed help debugging issues with multi-thread apps.<br>&gt; <br></p><p>I agree that it may help in a few cases. But I think the change is &quot;not significant enough to warrant a change in Swift&quot;. It adds yet another keyword to the language that every new dev has to learn about, and the problem it solves can more elegantly be solved by writing more elegant code.<br></p><p>-Michael<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  5, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jun 5, 2016, at 5:46 PM, michael.peternell at gmx.at wrote:<br>&gt; <br>&gt;&gt; Am 05.06.2016 um 20:31 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; While I agree with Michael that nowadays, a lot of stuff that doesn&#39;t need to be, is done async, which leads to a giant thread pool per app and developers nowadays do not think of the cost of inter-thread communication (i.e. each dispatch_(a)sync has its cost, even though it&#39;s a light-weight thread), I agree with Charles that something like suggested does indeed help debugging issues with multi-thread apps.<br>&gt;&gt; <br>&gt; <br>&gt; I agree that it may help in a few cases. But I think the change is &quot;not significant enough to warrant a change in Swift&quot;. It adds yet another keyword to the language that every new dev has to learn about, and the problem it solves can more elegantly be solved by writing more elegant code.<br></p><p>Okay, what’s the “more elegant” way to write a function that uses networking or XPC, or that requires user feedback from a sheet?<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/79389f4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 06.06.2016 um 00:59 schrieb Charles Srstka &lt;cocoadev at charlessoft.com&gt;:<br>&gt; <br>&gt;&gt; On Jun 5, 2016, at 5:46 PM, michael.peternell at gmx.at wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 05.06.2016 um 20:31 schrieb Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I agree with Michael that nowadays, a lot of stuff that doesn&#39;t need to be, is done async, which leads to a giant thread pool per app and developers nowadays do not think of the cost of inter-thread communication (i.e. each dispatch_(a)sync has its cost, even though it&#39;s a light-weight thread), I agree with Charles that something like suggested does indeed help debugging issues with multi-thread apps.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I agree that it may help in a few cases. But I think the change is &quot;not significant enough to warrant a change in Swift&quot;. It adds yet another keyword to the language that every new dev has to learn about, and the problem it solves can more elegantly be solved by writing more elegant code.<br>&gt; <br>&gt; Okay, what’s the “more elegant” way to write a function that uses networking or XPC, or that requires user feedback from a sheet?<br></p><p>That&#39;s really hard to answer in the general case. I think real proposals should contain concrete, realistic examples that show the benefit of the proposal. It&#39;s really hard to argue against a proposal if there is no such example. User feedback from a sheet is one of the few examples where asynchronous programming makes sense: But I cannot see how a `@required` annotation would be useful in that setting.<br></p><p>-Michael<br></p><p>&gt; <br>&gt; Charles<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  6, 2016 at 03:00:00pm</p></header><div class="content"><p>On Jun 6, 2016, at 2:49 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt; <br>&gt; That&#39;s really hard to answer in the general case. I think real proposals should contain concrete, realistic examples that show the benefit of the proposal. It&#39;s really hard to argue against a proposal if there is no such example. User feedback from a sheet is one of the few examples where asynchronous programming makes sense: But I cannot see how a `@required` annotation would be useful in that setting.<br></p><p>Quick-n-dirty example, written in Mail. How would you make this synchronous?<br></p><p>import Foundation<br></p><p>enum Result&lt;T&gt; {<br>	case success(T)<br>	case error(ErrorType)<br>}<br></p><p>enum MyError: ErrorType {<br>	case unknownError<br>	case corruptData<br>	case badStatusCode(Int)<br>}<br></p><p>struct SomeThing {<br>	init?(data: NSData) {<br>		...<br>	}<br>}<br></p><p>func getSomethingFromTheNetwork(url: NSURL, completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) {	<br>	let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>		if let error = error {<br>			completionHandler(.error(error))<br>			return<br>		}<br></p><p>		if let httpResponse = response as? NSHTTPURLResponse {<br>			let statusCode = httpResponse.statusCode<br>			<br>			if statusCode &lt; 200 || statusCode &gt;= 300 {<br>				completionHandler(.error(MyError.badStatusCode(statusCode)))<br>				return<br>			}<br>		}<br>	<br>		guard let data = data else {<br>			completionHandler(.error(MyError.unknownError))<br>			return<br>		}<br></p><p>		guard let something = SomeThing(data: data) else {<br>			completionHandler(.error(MyError.corruptData))<br>			return<br>		}<br></p><p>		completionHandler(.success(something))<br>	}<br>	<br>	task.resume()<br>}<br></p><p>(disclaimer: yes, we’d probably have to improve the API for NSURLSession a bit here for @required to be useful.)<br></p><p>How would you make this synchronous:<br></p><p>func getSomethingFromAnotherTask(completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) {<br>	let message = ...<br></p><p>	xpc_send_message_with_reply(self.connection, message, self.dispatchQueue) { reply in<br>		do {<br>			let something = try self.turnReplyIntoSomethingSomehow(reply)<br>		<br>			completionHandler(.success(something))<br>		} catch {<br>			completionHandler(.error(error))<br>		}<br>	}<br>}<br></p><p>Or this:<br></p><p>func doSomethingThatNeedsUserInput(completionHandler: (Bool) -&gt; ()) {<br>	let alert = NSAlert()<br></p><p>	alert.messageText = “Should we continue?”<br>	alert.addButtonWithTitle(“Continue”)<br>	alert.addButtonWithTitle(“Cancel”)<br></p><p>	alert.beginSheetModalForWindow(someWindow) { response in<br>		if response == NSAlertFirstButtonReturn {<br>			completionHandler(true)<br>		}<br></p><p>		// uh oh, I forgot to test for other conditions, and now the completion handler won’t be called if the user clicked “Cancel”.<br>		// Too bad the compiler couldn’t warn me about it.<br>	}<br>}<br></p><p>There are some tasks which synchronous programming is simply not well-suited for.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/ab4fa220/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7559ac465b184ec777f29d37c0e4b374?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Michael Peternell</string> &lt;michael.peternell at gmx.at&gt;<p>June  6, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Am 06.06.2016 um 22:30 schrieb Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Jun 6, 2016, at 2:49 PM, Michael Peternell &lt;michael.peternell at gmx.at&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That&#39;s really hard to answer in the general case. I think real proposals should contain concrete, realistic examples that show the benefit of the proposal. It&#39;s really hard to argue against a proposal if there is no such example. User feedback from a sheet is one of the few examples where asynchronous programming makes sense: But I cannot see how a `@required` annotation would be useful in that setting.<br>&gt; <br>&gt; Quick-n-dirty example, written in Mail. How would you make this synchronous?<br></p><p>Yes, ok...<br></p><p>Well, I cannot easily make everything synchronous. I just can change it in a way that makes a `@required` attribute &quot;optional&quot; ;)<br></p><p>import Foundation<br></p><p>enum Result&lt;T&gt; {<br>    case success(T)<br>    case error(ErrorType)<br>}<br></p><p>enum MyError: ErrorType {<br>    case unknownError<br>    case corruptData<br>    case badStatusCode(Int)<br>}<br></p><p>struct SomeThing {<br>    init?(data: NSData) {<br>        ...<br>    }<br>}<br></p><p>func getSomethingFromTheNetwork(url: NSURL, completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) { <br>    func toSomeThing(data: NSData?, response: NSURLResponse?, error: NSError?) -&gt; Result&lt;SomeThing&gt; {<br>        if let error = error {<br>            return .error(error)<br>        }<br></p><p>        if let httpResponse = response as? NSHTTPURLResponse {<br>            let statusCode = httpResponse.statusCode<br>            <br>            if statusCode &lt; 200 || statusCode &gt;= 300 {<br>                return .error(MyError.badStatusCode(statusCode))<br>            }<br>        }<br>    <br>        guard let data = data else {<br>            return .error(MyError.unknownError)<br>        }<br></p><p>        guard let something = SomeThing(data: data) else {<br>            return .error(MyError.corruptData)<br>        }<br></p><p>        return .success(something)<br>    }<br>    let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>        completionHandler(toSomething(data, response, error))<br>    }<br>    <br>    task.resume()<br>}<br></p><p>With a semaphore, I can also make it synchronous. Not sure if this is a good idea though... If the API is already asynchronous, it&#39;s probably better to use it that way.<br></p><p>/// Should not be called from the main thread<br>func getSomethingFromTheNetworkSync(url: NSURL) -&gt; Result&lt;SomeThing&gt; { <br>    func toSomeThing(data: NSData?, response: NSURLResponse?, error: NSError?) -&gt; Result&lt;SomeThing&gt; {<br>        if let error = error {<br>            return .error(error)<br>        }<br></p><p>        if let httpResponse = response as? NSHTTPURLResponse {<br>            let statusCode = httpResponse.statusCode<br>            <br>            if statusCode &lt; 200 || statusCode &gt;= 300 {<br>                return .error(MyError.badStatusCode(statusCode))<br>            }<br>        }<br>    <br>        guard let data = data else {<br>            return .error(MyError.unknownError)<br>        }<br></p><p>        guard let something = SomeThing(data: data) else {<br>            return .error(MyError.corruptData)<br>        }<br></p><p>        return .success(something)<br>    }<br>    let sema = dispatch_semaphore_create(0)<br>    var result = Result&lt;Something&gt;?<br>    let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>        result = toSomething(data, response, error)<br>        dispatch_semaphore_signal(sema)<br>    }<br>    <br>    task.resume()<br>    dispatch_semaphore_wait(sema)<br>    return result!<br>}<br></p><p>The other example can be transformed in the same way..<br></p><p>-Michael<br></p><p>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; enum Result&lt;T&gt; {<br>&gt; 	case success(T)<br>&gt; 	case error(ErrorType)<br>&gt; }<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt; 	case unknownError<br>&gt; 	case corruptData<br>&gt; 	case badStatusCode(Int)<br>&gt; }<br>&gt; <br>&gt; struct SomeThing {<br>&gt; 	init?(data: NSData) {<br>&gt; 		...<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; func getSomethingFromTheNetwork(url: NSURL, completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) {	<br>&gt; 	let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>&gt; 		if let error = error {<br>&gt; 			completionHandler(.error(error))<br>&gt; 			return<br>&gt; 		}<br>&gt; <br>&gt; 		if let httpResponse = response as? NSHTTPURLResponse {<br>&gt; 			let statusCode = httpResponse.statusCode<br>&gt; 			<br>&gt; 			if statusCode &lt; 200 || statusCode &gt;= 300 {<br>&gt; 				completionHandler(.error(MyError.badStatusCode(statusCode)))<br>&gt; 				return<br>&gt; 			}<br>&gt; 		}<br>&gt; 	<br>&gt; 		guard let data = data else {<br>&gt; 			completionHandler(.error(MyError.unknownError))<br>&gt; 			return<br>&gt; 		}<br>&gt; <br>&gt; 		guard let something = SomeThing(data: data) else {<br>&gt; 			completionHandler(.error(MyError.corruptData))<br>&gt; 			return<br>&gt; 		}<br>&gt; <br>&gt; 		completionHandler(.success(something))<br>&gt; 	}<br>&gt; 	<br>&gt; 	task.resume()<br>&gt; }<br>&gt; <br>&gt; (disclaimer: yes, we’d probably have to improve the API for NSURLSession a bit here for @required to be useful.)<br>&gt; <br>&gt; How would you make this synchronous:<br>&gt; <br>&gt; func getSomethingFromAnotherTask(completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) {<br>&gt; 	let message = ...<br>&gt; <br>&gt; 	xpc_send_message_with_reply(self.connection, message, self.dispatchQueue) { reply in<br>&gt; 		do {<br>&gt; 			let something = try self.turnReplyIntoSomethingSomehow(reply)<br>&gt; 		<br>&gt; 			completionHandler(.success(something))<br>&gt; 		} catch {<br>&gt; 			completionHandler(.error(error))<br>&gt; 		}<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Or this:<br>&gt; <br>&gt; func doSomethingThatNeedsUserInput(completionHandler: (Bool) -&gt; ()) {<br>&gt; 	let alert = NSAlert()<br>&gt; <br>&gt; 	alert.messageText = “Should we continue?”<br>&gt; 	alert.addButtonWithTitle(“Continue”)<br>&gt; 	alert.addButtonWithTitle(“Cancel”)<br>&gt; <br>&gt; 	alert.beginSheetModalForWindow(someWindow) { response in<br>&gt; 		if response == NSAlertFirstButtonReturn {<br>&gt; 			completionHandler(true)<br>&gt; 		}<br>&gt; <br>&gt; 		// uh oh, I forgot to test for other conditions, and now the completion handler won’t be called if the user clicked “Cancel”.<br>&gt; 		// Too bad the compiler couldn’t warn me about it.<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; There are some tasks which synchronous programming is simply not well-suited for.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Pitch: @required attribute for closures</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 6, 2016, at 3:48 PM, michael.peternell at gmx.at wrote:<br>&gt; <br>&gt; Yes, ok...<br>&gt; <br>&gt; Well, I cannot easily make everything synchronous. I just can change it in a way that makes a `@required` attribute &quot;optional&quot; ;)<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; enum Result&lt;T&gt; {<br>&gt;    case success(T)<br>&gt;    case error(ErrorType)<br>&gt; }<br>&gt; <br>&gt; enum MyError: ErrorType {<br>&gt;    case unknownError<br>&gt;    case corruptData<br>&gt;    case badStatusCode(Int)<br>&gt; }<br>&gt; <br>&gt; struct SomeThing {<br>&gt;    init?(data: NSData) {<br>&gt;        ...<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; func getSomethingFromTheNetwork(url: NSURL, completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) { <br>&gt;    func toSomeThing(data: NSData?, response: NSURLResponse?, error: NSError?) -&gt; Result&lt;SomeThing&gt; {<br>&gt;        if let error = error {<br>&gt;            return .error(error)<br>&gt;        }<br>&gt; <br>&gt;        if let httpResponse = response as? NSHTTPURLResponse {<br>&gt;            let statusCode = httpResponse.statusCode<br>&gt; <br>&gt;            if statusCode &lt; 200 || statusCode &gt;= 300 {<br>&gt;                return .error(MyError.badStatusCode(statusCode))<br>&gt;            }<br>&gt;        }<br>&gt; <br>&gt;        guard let data = data else {<br>&gt;            return .error(MyError.unknownError)<br>&gt;        }<br>&gt; <br>&gt;        guard let something = SomeThing(data: data) else {<br>&gt;            return .error(MyError.corruptData)<br>&gt;        }<br>&gt; <br>&gt;        return .success(something)<br>&gt;    }<br>&gt;    let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>&gt;        completionHandler(toSomething(data, response, error))<br>&gt;    }<br>&gt; <br>&gt;    task.resume()<br>&gt; }<br></p><p>I’ve written code like that; however, it falls down as soon as you have to nest two or more asynchronous APIs. Consider the following, and assume we don’t have control of SomeThing’s API (or, maybe, SomeThing relies on some other API we don’t control that has to be asynchronous):<br></p><p>import Foundation<br></p><p>enum Result&lt;T&gt; {<br>   case success(T)<br>   case error(ErrorType)<br>}<br></p><p>enum MyError: ErrorType {<br>   case unknownError<br>   case corruptData<br>   case badStatusCode(Int)<br>}<br></p><p>struct SomeThing {<br>   make(data: NSData, completionHandler: (SomeThing?) -&gt; ())<br>}<br></p><p>func getSomethingFromTheNetwork(url: NSURL, completionHandler: (Result&lt;SomeThing&gt;) -&gt; ()) {	<br>	let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, response, error in<br>		if let error = error {<br>			completionHandler(.error(error))<br>			return<br>		}<br></p><p>		if let httpResponse = response as? NSHTTPURLResponse {<br>			let statusCode = httpResponse.statusCode<br>			<br>			if statusCode &lt; 200 || statusCode &gt;= 300 {<br>				completionHandler(.error(MyError.badStatusCode(statusCode)))<br>				return<br>			}<br>		}<br>	<br>		guard let data = data else {<br>			completionHandler(.error(MyError.unknownError))<br>			return<br>		}<br></p><p>		SomeThing.make(data) { something in<br>			if let something = something {<br>				completionHandler(.success(something))<br>			} else {<br>				completionHandler(.error(MyError.corruptData))<br>			}<br>		}<br>	}<br>	<br>	task.resume()<br>}<br></p><p>Yeah, you can wrap it in yet another function, but if things get complex enough, and you forget to do that somewhere, it’s bad news.<br></p><p>&gt; With a semaphore, I can also make it synchronous. Not sure if this is a good idea though... If the API is already asynchronous, it&#39;s probably better to use it that way.<br></p><p>It’s not a good idea. As I mentioned before, Apple recommends against blocking on dispatch queues. It’s not considered good practice. That includes the main queue, by the way;  both Cocoa-Dev and Stack Overflow are filled with questions from people who tried using dispatch_sync or dispatch_async to the main queue to run -[NSOpenPanel runModal], and then got confused when nothing in the panel displayed properly. Using the async methods on NSOpenPanel and returning via a completion handler would have caused this to work properly.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160606/63dd6caa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
