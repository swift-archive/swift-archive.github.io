<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Make optional protocol methods	first class citizens</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 06:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/6a63f844/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>March 31, 2016 at 10:00:00am</p></header><div class="content"><p>Some ideas I was thinking about for optional protocol functions was you’d declare it like this:<br></p><p>protocol UIGestureRecognizerDelegate {<br>  optional func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer) -&gt; Bool = true<br>}<br></p><p>If you put “optional” there, the compiler would auto-generate an empty function in a protocol extension in your module as if you had specified one yourself. If the function has a return value, you would be required to specify the default return value in the protocol which provides automatic documentation of the default, too. (It would be an error to have an optional function with a return value that doesn’t have a default value specified in the protocol.) (I am not currently in favor of supplying a default implementation body inside of a protocol as has been discussed some previously.)<br></p><p>If you provide a default implementation of an optional protocol function in a protocol extension in the same module as the protocol itself is declared in, it would be an error and you’d have to make the function non-optional or get rid of your conflicting protocol extension implementation. If the protocol was declared in a different module, then that restriction would be lifted since presumably you’re providing a default implementation via protocol extension on purpose.<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On Mar 31, 2016, at 1:34 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Just a thought: optional methods could be modeled by methods in a protocol that return optional closures.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; Am 31. März 2016 um 04:42 schrieb Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; I&#39;m missing those optional methods too, but protocol extensions sound like a better solution for this.<br>&gt;&gt; <br>&gt;&gt; (For those suggesting a separate protocol, consider UITableView. How many protocols would it take to model all the optional delegate methods as separate protocols? Certainly more than 10, perhaps a few dozen.)<br>&gt;&gt; <br>&gt;&gt; I would welcome a standardized way to document the methods as optional-to-implement, though, beyond just requiring a protocol extension. My ideal option would be to allow the optional keyword and change it to simply require a default implementation in a protocol extension.<br>&gt;&gt; <br>&gt;&gt; If we don&#39;t want a language change, then perhaps a conventional doc tag?<br>&gt;&gt; <br>&gt;&gt; A.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 30, 2016, at 8:08 PM, Yuval Tal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I find that optional protocol methods to be very useful. However, there is a caveat -- it needs to be mapped to @objc. This puts a set of limitations, such as: structures cannot be used as parameters as it does not map to objective-c. What do you think about removing the requirement of using @objc and allow to create optional methods without these limitations?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Yuval<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 31, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 31.03.2016 um 17:18 schrieb Sean Heber &lt;sean at fifthace.com&gt;:<br>&gt; <br>&gt; Some ideas I was thinking about for optional protocol functions was you’d declare it like this:<br>&gt; <br>&gt; protocol UIGestureRecognizerDelegate {<br>&gt;  optional func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer) -&gt; Bool = true<br>&gt; }<br></p><p><br>Why not just the following<br></p><p>import Foundation<br></p><p>// optional delegate method<br></p><p>protocol UIGestureRecognizerDelegate {<br>    var gestureRecognizerShouldBegin: ((gestureRecognizer: UIGestureRecognizer) -&gt; Bool)? { get }<br>}<br></p><p>extension UIGestureRecognizerDelegate {<br>    var gestureRecognizerShouldBegin: ((gestureRecognizer: UIGestureRecognizer) -&gt; Bool)? {<br>        return nil<br>    }<br>}<br></p><p><br>class UIGestureRecognizer {<br>    <br>    var delegate: UIGestureRecognizerDelegate?<br>    <br>    func callDelegate() {<br>        if let gestureRecognizerShouldBegin = delegate?.gestureRecognizerShouldBegin {<br>            gestureRecognizerShouldBegin(gestureRecognizer: self)<br>        }<br>    }<br>}<br></p><p><br>// implementing a delegate:<br></p><p>struct MyDelegate : UIGestureRecognizerDelegate {<br>    var gestureRecognizerShouldBegin: ((gestureRecognizer: UIGestureRecognizer) -&gt; Bool)? {<br>        return { (gestureRecognizer: UIGestureRecognizer) -&gt; Bool in<br>            return true<br>        }<br>    }<br>}<br></p><p>struct MyOtherDelegate : UIGestureRecognizerDelegate { }<br></p><p>This captures the idea of optional methods as used in Objective-C quite nicely IMO. And it already works without needing a new language feature.<br>If/when Swift gains the ability to declare default implementations within a protocol instead of needing an extension the boilerplate of having to repeat everything in the extension would drop away.<br></p><p><br>&gt; If you put “optional” there, the compiler would auto-generate an empty function in a protocol extension in your module as if you had specified one yourself. If the function has a return value, you would be required to specify the default return value in the protocol which provides automatic documentation of the default, too. (It would be an error to have an optional function with a return value that doesn’t have a default value specified in the protocol.) (I am not currently in favor of supplying a default implementation body inside of a protocol as has been discussed some previously.)<br></p><p>I do not understand why an optional method should require a default value. That’s not how optional methods work in Objective-C where the caller will ask whether the method is implemented and calls it or does something else. With a default value it would be much more difficult to do something different if the method is not implemented.<br>Actually with a default value the method would just be a normal method which has not been overridden, there would be nothing optional about it anymore.<br></p><p>-Thorsten<br></p><p><br>&gt; <br>&gt; If you provide a default implementation of an optional protocol function in a protocol extension in the same module as the protocol itself is declared in, it would be an error and you’d have to make the function non-optional or get rid of your conflicting protocol extension implementation. If the protocol was declared in a different module, then that restriction would be lifted since presumably you’re providing a default implementation via protocol extension on purpose.<br>&gt; <br>&gt; l8r<br>&gt; Sean<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 1:34 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just a thought: optional methods could be modeled by methods in a protocol that return optional closures.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 31. März 2016 um 04:42 schrieb Andrey Tarantsov via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; I&#39;m missing those optional methods too, but protocol extensions sound like a better solution for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (For those suggesting a separate protocol, consider UITableView. How many protocols would it take to model all the optional delegate methods as separate protocols? Certainly more than 10, perhaps a few dozen.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would welcome a standardized way to document the methods as optional-to-implement, though, beyond just requiring a protocol extension. My ideal option would be to allow the optional keyword and change it to simply require a default implementation in a protocol extension.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we don&#39;t want a language change, then perhaps a conventional doc tag?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 30, 2016, at 8:08 PM, Yuval Tal via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I find that optional protocol methods to be very useful. However, there is a caveat -- it needs to be mapped to @objc. This puts a set of limitations, such as: structures cannot be used as parameters as it does not map to objective-c. What do you think about removing the requirement of using @objc and allow to create optional methods without these limitations?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Yuval<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/826c1656/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5a72880ffed1a30cb9b8e3f372507145?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Rob Mayoff</string> &lt;mayoff at dqd.com&gt;<p>March 31, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Mar 31, 2016 at 10:56 AM, Thorsten Seitz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; protocol UIGestureRecognizerDelegate {<br>&gt;     var gestureRecognizerShouldBegin: ((gestureRecognizer:<br>&gt; UIGestureRecognizer) -&gt; Bool)? { get }<br>&gt; }<br>&gt;<br></p><p>UIGestureRecognizerDelegate has five methods that are &quot;named&quot;<br>gestureRecognizer:<br></p><p><br>   - gestureRecognizer(_:shouldRecognizeSimultaneouslyWithGestureRecognizer:<br>   )<br>   - gestureRecognizer(_:shouldRequireFailureOfGestureRecognizer:)<br>   - gestureRecognizer(_:shouldBeRequiredToFailByGestureRecognizer:)<br>   - gestureRecognizer(_:shouldReceiveTouch:)<br>   - gestureRecognizer(_:shouldReceivePress:)<br></p><p>You can only have a single property named &quot;gestureRecognizer&quot;, so you<br>either have to come up with other names for these, or change the language<br>to allow closure-typed properties to have multipart names.<br></p><p>This problem has been noted before, for example here:<br>http://article.gmane.org/gmane.comp.lang.swift.evolution/8707/<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/9e3a1be1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Good point. That would obviously restrict the choice for naming the methods in such a protocol, but since we are talking about new protocols that would not be an impediment. It might result in non-optimal method names, of course.<br></p><p>-Thorsten <br></p><p>&gt; Am 31.03.2016 um 18:37 schrieb Rob Mayoff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Thu, Mar 31, 2016 at 10:56 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; protocol UIGestureRecognizerDelegate {<br>&gt;&gt;     var gestureRecognizerShouldBegin: ((gestureRecognizer: UIGestureRecognizer) -&gt; Bool)? { get }<br>&gt;&gt; }<br>&gt; <br>&gt; UIGestureRecognizerDelegate has five methods that are &quot;named&quot; gestureRecognizer:<br>&gt; <br>&gt; gestureRecognizer(_:shouldRecognizeSimultaneouslyWithGestureRecognizer:)<br>&gt; gestureRecognizer(_:shouldRequireFailureOfGestureRecognizer:)<br>&gt; gestureRecognizer(_:shouldBeRequiredToFailByGestureRecognizer:)<br>&gt; gestureRecognizer(_:shouldReceiveTouch:)<br>&gt; gestureRecognizer(_:shouldReceivePress:)<br>&gt; You can only have a single property named &quot;gestureRecognizer&quot;, so you either have to come up with other names for these, or change the language to allow closure-typed properties to have multipart names.<br>&gt; <br>&gt; This problem has been noted before, for example here: http://article.gmane.org/gmane.comp.lang.swift.evolution/8707/<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/3e831d38/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc2018ce0c170425a51033a54850a538?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Lukas Stabe</string> &lt;ahti333 at gmail.com&gt;<p>April  2, 2016 at 02:00:00pm</p></header><div class="content"><p>All use-cases I had for optional methods in protocols in Objective-C are covered nicely by providing a default implementation in a protocol extension, so I don&#39;t think optional protocol methods should be a thing in pure Swift.<br></p><p>&gt; I do not understand why an optional method should require a default value. That’s not how optional methods work in Objective-C where the caller will ask whether the method is implemented and calls it or does something else. With a default value it would be much more difficult to do something different if the method is not implemented.<br>&gt; Actually with a default value the method would just be a normal method which has not been overridden, there would be nothing optional about it anymore.<br></p><p>I&#39;ve actually had multiple cases in Objective-C code where this feature (some object behaving differently depending on wether or not a delegate method has been implemented) has prevented me from implementing features the easy and obvious way. In those cases I resorted to implementing &#39;respondsToSelector:&#39;. So I&#39;d argue that optional protocol methods encourage this type of behavior, which imho is bad API design. If you need to behave differently for some types of delegates (or whatever else your protocol represents), a separate method to call to determine how to behave is much simpler and better to use.<br></p><p>– Lukas<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April  2, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 2, 2016, at 7:04 AM, Lukas Stabe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; All use-cases I had for optional methods in protocols in Objective-C are covered nicely by providing a default implementation in a protocol extension, so I don&#39;t think optional protocol methods should be a thing in pure Swift.<br>&gt; <br>&gt;&gt; I do not understand why an optional method should require a default value. That’s not how optional methods work in Objective-C where the caller will ask whether the method is implemented and calls it or does something else. With a default value it would be much more difficult to do something different if the method is not implemented.<br>&gt;&gt; Actually with a default value the method would just be a normal method which has not been overridden, there would be nothing optional about it anymore.<br>&gt; <br>&gt; I&#39;ve actually had multiple cases in Objective-C code where this feature (some object behaving differently depending on wether or not a delegate method has been implemented) has prevented me from implementing features the easy and obvious way. In those cases I resorted to implementing &#39;respondsToSelector:&#39;. So I&#39;d argue that optional protocol methods encourage this type of behavior, which imho is bad API design. If you need to behave differently for some types of delegates (or whatever else your protocol represents), a separate method to call to determine how to behave is much simpler and better to use.<br></p><p>+1.  This is exactly the same thing I mentioned regarding the fast path for row height in UITableView.  The fact that it depends on whether or not the delegate implements heightForRowAtIndexPath is a bad design decision.<br></p><p>&gt; <br>&gt; – Lukas<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; I&#39;ve actually had multiple cases in Objective-C code where this feature (some object behaving differently depending on wether or not a delegate method has been implemented) has prevented me from implementing features the easy and obvious way. In those cases I resorted to implementing &#39;respondsToSelector:&#39;. So I&#39;d argue that optional protocol methods encourage this type of behavior, which imho is bad API design. If you need to behave differently for some types of delegates (or whatever else your protocol represents), a separate method to call to determine how to behave is much simpler and better to use.<br>&gt; <br>&gt; +1.  This is exactly the same thing I mentioned regarding the fast path for row height in UITableView.  The fact that it depends on whether or not the delegate implements heightForRowAtIndexPath is a bad design decision.<br></p><p>Yes, but please observe that the form of optional methods that we&#39;re discussing here is limited to avoid the case you mention (I hate that problem as well, very very much).<br></p><p>A.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/428bfb12/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; I do not understand why an optional method should require a default value. That’s not how optional methods work in Objective-C where the caller will ask whether the method is implemented and calls it or does something else. With a default value it would be much more difficult to do something different if the method is not implemented.<br></p><p>Yes, and that&#39;s the best part. The way Obj-C optional methods currently work, they are very hard to wrap/proxy/etc. Swift has a lot more expressive power, so I&#39;m sure that you can adjust the return value to express the “I don&#39;t care” case without making the absence of the method magical.<br></p><p>A.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>[Proposal] Make optional protocol methods first class citizens</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Some ideas I was thinking about for optional protocol functions was you’d declare it like this:<br>&gt; <br>&gt; protocol UIGestureRecognizerDelegate {<br>&gt;  optional func gestureRecognizerShouldBegin(gestureRecognizer: UIGestureRecognizer) -&gt; Bool = true<br>&gt; }<br>&gt; <br>&gt; If you put “optional” there, the compiler would auto-generate an empty function in a protocol extension in your module as if you had specified one yourself. If the function has a return value, you would be required to specify the default return value in the protocol which provides automatic documentation of the default, too.<br></p><p>REALLY digging this. Strong +1.<br></p><p>A.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
