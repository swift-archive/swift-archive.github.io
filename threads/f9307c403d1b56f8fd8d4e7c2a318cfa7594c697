<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>Earlier on Swift Evolution:<br></p><p>Me: &quot;Is there a technical reason that Swift cannot be expanded to allow arbitrary mixes of conditional binding and boolean assertions within a single compound guard statement?&quot;<br></p><p>Joe Groff: &quot;No. You already can, we just have the somewhat strange rule that to separate `guard` conditions uses `,` before optional or pattern conditions, but `where` before Boolean conditions. There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;<br></p><p>	guard x == 0,<br>	  let y = optional where<br>	  z == 2 {<br>	}<br></p><p>Pitch: <br></p><p>I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently accept `where` or `,` to separate guard conditions. This would allow a more consistent approach that supports intermingling conditional binding and boolean assertions. Here&#39;s a real-world bit of code I was helping someone with a few evenings ago. It&#39;s attempting to navigate through some JSON, using optional conditions with where clauses.<br></p><p>guard<br>    let fileContents = fileContents,<br>    let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>    let featuresArray = jsonDict[&quot;features&quot;] as? NSArray where featuresArray.count &gt; 0,<br>    let featuresDict = featuresArray[0] as? NSDictionary,<br>    let coordinatesArray = featuresDict[&quot;geometry&quot;] where coordinatesArray.count &gt; 0,<br>    let coordinateArray = coordinatesArray[0] as? NSArray where coordinateArray.count &gt; 3<br>    else { fatalError(&quot;Reason&quot;) }<br></p><p>Each `where` test is a separate test. While there are semantic ties between the conditional binding and the count tests, there doesn&#39;t have to be. Under Swift&#39;s current rules,  you must use the `where` keyword to introduce a Boolean test after a binding or pattern, regardless of whether or not there&#39;s an underlying semantic link between the two.<br></p><p>By removing this requirement and allowing interchangeability between `where` and `,`, you&#39;re given the option of tying the boolean to the binding/pattern match or introducing a boolean statement with no connection to previous steps. Here&#39;s what this example looks like after excluding `where`:<br></p><p>guard<br>    let fileContents = fileContents,<br>    let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>    let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>    featuresArray.count &gt; 0,<br>    let featuresDict = featuresArray.firstObject as? NSDictionary,<br>    let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>    coordinatesArray.count &gt; 0,<br>    let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>    coordinateArray.count &gt; 3<br>    else { fatalError(&quot;Reason&quot;) }<br></p><p>The motivation for this approach becomes more compelling when the Boolean tests are disjoint from binding or pattern matches.<br></p><p>guard<br>    minimumShapeCount &gt; 4,<br>    let shapes = decompose(map, minimum: minimumShapeCount),<br>    availableArea &gt; minimumArea,<br>    let map = placeShapes(shapes, availableArea) else {<br>        fatalError()<br>}<br></p><p>would be allowed compared to current Swift which mandates where between the second and third tests:<br></p><p>    let shapes = decompose(map, minimum: minimumShapeCount) where availableArea &gt; minimumArea,<br></p><p>In my vision, Swift would continue to allow where clauses and expand to allow disjoint Boolean entries.<br></p><p>Thoughts?<br></p><p>-- E <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/f930c697/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 7:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Earlier on Swift Evolution:<br>&gt; <br>&gt; Me: &quot;Is there a technical reason that Swift cannot be expanded to allow arbitrary mixes of conditional binding and boolean assertions within a single compound guard statement?&quot;<br>&gt; <br>&gt; Joe Groff: &quot;No. You already can, we just have the somewhat strange rule that to separate `guard` conditions uses `,` before optional or pattern conditions, but `where` before Boolean conditions. There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;<br>&gt; <br>&gt; 	guard x == 0,<br>&gt; 	  let y = optional where<br>&gt; 	  z == 2 {<br>&gt; 	}<br>&gt; <br>&gt; Pitch: <br>&gt; <br>&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently accept `where` or `,` to separate guard conditions. This would allow a more consistent approach that supports intermingling conditional binding and boolean assertions. Here&#39;s a real-world bit of code I was helping someone with a few evenings ago. It&#39;s attempting to navigate through some JSON, using optional conditions with where clauses.<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray where featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] where coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray[0] as? NSArray where coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; Each `where` test is a separate test. While there are semantic ties between the conditional binding and the count tests, there doesn&#39;t have to be. Under Swift&#39;s current rules,  you must use the `where` keyword to introduce a Boolean test after a binding or pattern, regardless of whether or not there&#39;s an underlying semantic link between the two.<br>&gt; <br>&gt; By removing this requirement and allowing interchangeability between `where` and `,`, you&#39;re given the option of tying the boolean to the binding/pattern match or introducing a boolean statement with no connection to previous steps. Here&#39;s what this example looks like after excluding `where`:<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt;     featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt;     coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;     coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br></p><p>I have mixed thoughts about it. The former perl swchartzian-transform fan loves it, and the more responsible high speed trading systems developer finds it the kind of look-it-works-without-the-hands code i am not typically eager to see people do in my teams. <br>The apache spark project is a great example of a widely popular scala project that succeeded because it banned the kind of back-breaking areobatics that compilers can make sense of and normal (i.e not overly expensive and reasonably productive) developers typically get tangled in.<br></p><p>&gt; The motivation for this approach becomes more compelling when the Boolean tests are disjoint from binding or pattern matches.<br>&gt; <br>&gt; guard<br>&gt;     minimumShapeCount &gt; 4,<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;     availableArea &gt; minimumArea,<br>&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;         fatalError()<br>&gt; }<br>&gt; <br>&gt; would be allowed compared to current Swift which mandates where between the second and third tests:<br>&gt; <br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea &gt; minimumArea,<br>&gt; <br>&gt; In my vision, Swift would continue to allow where clauses and expand to allow disjoint Boolean entries.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- E <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/d2fa0fcf/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3dad7bea24aa580cabe5c16e8e64183e?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Krystof Vasa</string> &lt;kvasa at icloud.com&gt;<p>May 20, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 for me. Been longing for something like this myself this actually.<br></p><p><br>&gt; On May 20, 2016, at 7:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Earlier on Swift Evolution:<br>&gt; <br>&gt; Me: &quot;Is there a technical reason that Swift cannot be expanded to allow arbitrary mixes of conditional binding and boolean assertions within a single compound guard statement?&quot;<br>&gt; <br>&gt; Joe Groff: &quot;No. You already can, we just have the somewhat strange rule that to separate `guard` conditions uses `,` before optional or pattern conditions, but `where` before Boolean conditions. There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;<br>&gt; <br>&gt; 	guard x == 0,<br>&gt; 	  let y = optional where<br>&gt; 	  z == 2 {<br>&gt; 	}<br>&gt; <br>&gt; Pitch: <br>&gt; <br>&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently accept `where` or `,` to separate guard conditions. This would allow a more consistent approach that supports intermingling conditional binding and boolean assertions. Here&#39;s a real-world bit of code I was helping someone with a few evenings ago. It&#39;s attempting to navigate through some JSON, using optional conditions with where clauses.<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray where featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] where coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray[0] as? NSArray where coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; Each `where` test is a separate test. While there are semantic ties between the conditional binding and the count tests, there doesn&#39;t have to be. Under Swift&#39;s current rules,  you must use the `where` keyword to introduce a Boolean test after a binding or pattern, regardless of whether or not there&#39;s an underlying semantic link between the two.<br>&gt; <br>&gt; By removing this requirement and allowing interchangeability between `where` and `,`, you&#39;re given the option of tying the boolean to the binding/pattern match or introducing a boolean statement with no connection to previous steps. Here&#39;s what this example looks like after excluding `where`:<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt;     featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt;     coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;     coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; The motivation for this approach becomes more compelling when the Boolean tests are disjoint from binding or pattern matches.<br>&gt; <br>&gt; guard<br>&gt;     minimumShapeCount &gt; 4,<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;     availableArea &gt; minimumArea,<br>&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;         fatalError()<br>&gt; }<br>&gt; <br>&gt; would be allowed compared to current Swift which mandates where between the second and third tests:<br>&gt; <br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea &gt; minimumArea,<br>&gt; <br>&gt; In my vision, Swift would continue to allow where clauses and expand to allow disjoint Boolean entries.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- E <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/9de0ffee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>I agree `guard let y = optional where z == 2` reads quite strangely.<br></p><p>To me, though, it could make sense if variables bound in a guard statement<br>are restricted to a boolean assertion only after a `where`, but unrelated<br>boolean assertions should definitely not require it (i.e. `guard let y =<br>optional where y == 2` does seem more sensible than `guard let y =<br>optional, y == 2`, but `guard let y = optional where z == 2` is unpleasant.)<br></p><p><br>On Fri, May 20, 2016 at 12:07 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; *Earlier on Swift Evolution:*<br>&gt;<br>&gt; Me: &quot;*Is there a technical reason that Swift cannot be expanded to allow<br>&gt; arbitrary mixes of conditional binding and boolean assertions within a<br>&gt; single compound guard statement?*&quot;<br>&gt;<br>&gt; Joe Groff: &quot;*No. You already can, we just have the somewhat strange rule<br>&gt; that to separate `guard` conditions uses `,` before optional or pattern<br>&gt; conditions, but `where` before Boolean conditions. **There&#39;s no technical<br>&gt; reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;*<br>&gt;<br>&gt; guard x == 0,<br>&gt;  let y = optional where<br>&gt;  z == 2 {<br>&gt; }<br>&gt;<br>&gt; *Pitch: *<br>&gt;<br>&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently<br>&gt; accept `where` or `,` to separate guard conditions. This would allow a more<br>&gt; consistent approach that supports intermingling conditional binding and<br>&gt; boolean assertions. Here&#39;s a real-world bit of code I was helping someone<br>&gt; with a few evenings ago. It&#39;s attempting to navigate through some JSON,<br>&gt; using optional conditions with where clauses.<br>&gt;<br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try<br>&gt; NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as?<br>&gt; NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray *where **featuresArray.count<br>&gt; &gt; 0,*<br>&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] *where **coordinatesArray.count<br>&gt; &gt; 0,*<br>&gt;     let coordinateArray = coordinatesArray[0] as? NSArray *where **coordinateArray.count<br>&gt; &gt; 3*<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;<br>&gt; Each `where` test is a separate test. While there *are* semantic ties<br>&gt; between the conditional binding and the count tests, there *doesn&#39;t have<br>&gt; to be*. Under Swift&#39;s current rules,  you must use the `where` keyword to<br>&gt; introduce a Boolean test after a binding or pattern, regardless of whether<br>&gt; or not there&#39;s an underlying semantic link between the two.<br>&gt;<br>&gt; By removing this requirement and allowing interchangeability between<br>&gt; `where` and `,`, you&#39;re given the option of tying the boolean to the<br>&gt; binding/pattern match or introducing a boolean statement with no connection<br>&gt; to previous steps. Here&#39;s what this example looks like after excluding<br>&gt; `where`:<br>&gt;<br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try<br>&gt; NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as?<br>&gt; NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt; *    featuresArray.count &gt; 0,*<br>&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt; *    coordinatesArray.count &gt; 0,*<br>&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;     *coordinateArray.count &gt; 3*<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;<br>&gt; The motivation for this approach becomes more compelling when the Boolean<br>&gt; tests are disjoint from binding or pattern matches.<br>&gt;<br>&gt; guard<br>&gt;     minimumShapeCount &gt; 4,<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;     availableArea &gt; minimumArea,<br>&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;         fatalError()<br>&gt; }<br>&gt;<br>&gt; would be allowed compared to current Swift which mandates where between<br>&gt; the second and third tests:<br>&gt;<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea<br>&gt; &gt; minimumArea,<br>&gt;<br>&gt; In my vision, Swift would continue to allow where clauses and expand to<br>&gt; allow disjoint Boolean entries.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/a734048e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 12:07 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Earlier on Swift Evolution:<br>&gt; <br>&gt; Me: &quot;Is there a technical reason that Swift cannot be expanded to allow arbitrary mixes of conditional binding and boolean assertions within a single compound guard statement?&quot;<br>&gt; <br>&gt; Joe Groff: &quot;No. You already can, we just have the somewhat strange rule that to separate `guard` conditions uses `,` before optional or pattern conditions, but `where` before Boolean conditions. There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;<br>&gt; <br>&gt; 	guard x == 0,<br>&gt; 	  let y = optional where<br>&gt; 	  z == 2 {<br>&gt; 	}<br>&gt; <br>&gt; Pitch: <br>&gt; <br>&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently accept `where` or `,` to separate guard conditions. This would allow a more consistent approach that supports intermingling conditional binding and boolean assertions. Here&#39;s a real-world bit of code I was helping someone with a few evenings ago. It&#39;s attempting to navigate through some JSON, using optional conditions with where clauses.<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray where featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] where coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray[0] as? NSArray where coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; Each `where` test is a separate test. While there are semantic ties between the conditional binding and the count tests, there doesn&#39;t have to be. Under Swift&#39;s current rules,  you must use the `where` keyword to introduce a Boolean test after a binding or pattern, regardless of whether or not there&#39;s an underlying semantic link between the two.<br>&gt; <br>&gt; By removing this requirement and allowing interchangeability between `where` and `,`, you&#39;re given the option of tying the boolean to the binding/pattern match or introducing a boolean statement with no connection to previous steps. Here&#39;s what this example looks like after excluding `where`:<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt;     featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt;     coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;     coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; The motivation for this approach becomes more compelling when the Boolean tests are disjoint from binding or pattern matches.<br></p><p>You can already format the code in a pretty similar way although it is slightly awkward because some lines are required to have commas and others must *not* have commas:<br></p><p>guard<br>    let fileContents = fileContents,<br>    let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>    let featuresArray = jsonDict[&quot;features&quot;] as? NSArray <br>    where featuresArray.count &gt; 0,<br>    let featuresDict = featuresArray[0] as? NSDictionary,<br>    let coordinatesArray = featuresDict[&quot;geometry”] <br>    where coordinatesArray.count &gt; 0,<br>    let coordinateArray = coordinatesArray[0] as? NSArray <br>    where coordinateArray.count &gt; 3<br>    else { fatalError(&quot;Reason&quot;) }<br></p><p>I agree that it would be good to allow boolean expressions to be stand alone clauses in order to support formatting like this without the inconsistency with regards to commas.  <br></p><p>I am less certain about allowing simple boolean expressions that are not introduced by the `where` keyword (excepting the first one which is introduced with the `guard` keyword).  I think this is a separate question that should receive independent consideration.  I think a reasonable argument can be made both ways.  <br></p><p>Also, looking at these examples I can’t help but notice a another case of a comma separated list that would benefit from allowing newline to be used in place of the commas as well.<br></p><p><br>&gt; <br>&gt; guard<br>&gt;     minimumShapeCount &gt; 4,<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;     availableArea &gt; minimumArea,<br>&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;         fatalError()<br>&gt; }<br>&gt; <br>&gt; would be allowed compared to current Swift which mandates where between the second and third tests:<br>&gt; <br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea &gt; minimumArea,<br>&gt; <br>&gt; In my vision, Swift would continue to allow where clauses and expand to allow disjoint Boolean entries.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- E <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/de5ffa6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 20, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 11:53 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; I am less certain about allowing simple boolean expressions that are not introduced by the `where` keyword (excepting the first one which is introduced with the `guard` keyword).  I think this is a separate question that should receive independent consideration.  I think a reasonable argument can be made both ways.  <br></p><p>That&#39;s kind of the heart of the matter.<br></p><p>There&#39;s an assumption that guard statements are:<br></p><p>`guard` (conjoined boolean tests) | (conjoined boolean tests,)? (pattern | binding (where boolean)?, )+ else {...}<br></p><p>Right? (Except I couldn&#39;t figure out how to grammar out the final comma,) I&#39;m suggesting:<br></p><p>`guard` ((boolean | (pattern | binding (where boolean)?)),)+ else {...}<br></p><p>instead. (And ditto about final comma) This promotes boolean statements to the same standing, so they&#39;re not limited to the start of the guard statement or syntactically tied to a pattern/binding where there may be no semantic basis.<br></p><p>-- E<br></p><p><br></p><p><br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/4ee5ef0c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 1:01 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:53 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; I am less certain about allowing simple boolean expressions that are not introduced by the `where` keyword (excepting the first one which is introduced with the `guard` keyword).  I think this is a separate question that should receive independent consideration.  I think a reasonable argument can be made both ways.  <br>&gt; <br>&gt; That&#39;s kind of the heart of the matter.<br>&gt; <br>&gt; There&#39;s an assumption that guard statements are:<br>&gt; <br>&gt; `guard` (conjoined boolean tests) | (conjoined boolean tests,)? (pattern | binding (where boolean)?, )+ else {...}<br>&gt; <br>&gt; Right? (Except I couldn&#39;t figure out how to grammar out the final comma,) I&#39;m suggesting:<br>&gt; <br>&gt; `guard` ((boolean | (pattern | binding (where boolean)?)),)+ else {...}<br>&gt; <br>&gt; instead. (And ditto about final comma) This promotes boolean statements to the same standing, so they&#39;re not limited to the start of the guard statement or syntactically tied to a pattern/binding where there may be no semantic basis.<br></p><p>Yep, I know.  I’m agreeing with breaking the syntactic tie to pattern binding, just questioning whether we should drop the need to introduce subsequent ones with `where`.  I am on the fence as to which is more readable and interested in hearing discussion about that.<br></p><p>This is what it would look like if drop the requirement that they be tied to a pattern binding but we require `where` on subsequent boolean expressions (meaning each clause is introduced with a keyword.<br></p><p>`guard` (boolean,)? (((where boolean) | (pattern | binding (where boolean)?)),)+ else {…}<br></p><p>We could also do this if we wanted to allow all boolean expressions, even the first, to be introduced with `where` to support consistent formatting of all clauses in a multi-line construct like the ones in your example.<br></p><p>`guard` (where? boolean,)? (((where boolean) | (pattern | binding (where boolean)?)),)+ else {...}<br></p><p>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/c74bcb02/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 20, 2016, at 8:01 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 11:53 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; I am less certain about allowing simple boolean expressions that are not introduced by the `where` keyword (excepting the first one which is introduced with the `guard` keyword).  I think this is a separate question that should receive independent consideration.  I think a reasonable argument can be made both ways.  <br>&gt; <br>&gt; That&#39;s kind of the heart of the matter.<br>&gt; <br>&gt; There&#39;s an assumption that guard statements are:<br>&gt; <br>&gt; `guard` (conjoined boolean tests) | (conjoined boolean tests,)? (pattern | binding (where boolean)?, )+ else {...}<br>&gt; <br>&gt; Right? (Except I couldn&#39;t figure out how to grammar out the final comma,) I&#39;m suggesting:<br>&gt; <br>&gt; `guard` ((boolean | (pattern | binding (where boolean)?)),)+ else {...}<br>&gt; <br>&gt; instead. (And ditto about final comma) This promotes boolean statements to the same standing, so they&#39;re not limited to the start of the guard statement or syntactically tied to a pattern/binding where there may be no semantic basis.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt; <br></p><p>GRAMMAR OF A GUARD STATEMENT<br></p><p> &lt;&gt;guard-statement → guard­condition-clause &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-clause&gt;­else­code-block &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block&gt;­<br> &lt;&gt;condition-clause → expression &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression&gt;­<br> &lt;&gt;condition-clause → expression &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression&gt;­,­condition-list &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list&gt;­<br> &lt;&gt;condition-clause → condition-list &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list&gt;­<br> &lt;&gt;condition-clause → availability-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/availability-condition&gt;­,­expression &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression&gt;­<br> &lt;&gt;condition-list → condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition&gt;­  condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition&gt;­,­condition-list &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list&gt;­<br> &lt;&gt;condition → availability-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/availability-condition&gt;­  case-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/case-condition&gt;­  optional-binding-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-condition&gt;­<br> &lt;&gt;case-condition → case­pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern&gt;­initializer &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer&gt;­where-clause &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause&gt;­opt­<br></p><p>it is all shared at the moment. <br></p><p>///   stmt-guard:<br>///     &#39;guard&#39; condition &#39;else&#39; stmt-brace<br>///<br>ParserResult&lt;Stmt&gt; Parser::parseStmtGuard() {<br>  SourceLoc GuardLoc = consumeToken(tok::kw_guard);<br>  <br>...<br></p><p><br>I guess it means that stepping out of what it currently does is straightforward to isolate from side effects, but likely a significant piece of work if it is not make a superset (meaning that bits and parts or the way the current grammar is structured can be reused in the manner they are today) of what it is today.<br></p><p><br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160520/218e82dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; <br>&gt; GRAMMAR OF A GUARD STATEMENT<br>&gt; <br>&gt;  &lt;&gt;guard-statement → guard­condition-clause &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-clause&gt;­else­code-block &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/code-block&gt;­<br>&gt;  &lt;&gt;condition-clause → expression &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression&gt;­<br>&gt;  &lt;&gt;condition-clause → expression &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression&gt;­,­condition-list &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list&gt;­<br>&gt;  &lt;&gt;condition-clause → condition-list &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list&gt;­<br>&gt;  &lt;&gt;condition-clause → availability-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/availability-condition&gt;­,­expression &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Expressions.html#//apple_ref/swift/grammar/expression&gt;­<br>&gt;  &lt;&gt;condition-list → condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition&gt;­  condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition&gt;­,­condition-list &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/condition-list&gt;­<br>&gt;  &lt;&gt;condition → availability-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/availability-condition&gt;­  case-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/case-condition&gt;­  optional-binding-condition &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/optional-binding-condition&gt;­<br>&gt;  &lt;&gt;case-condition → case­pattern &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Patterns.html#//apple_ref/swift/grammar/pattern&gt;­initializer &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Declarations.html#//apple_ref/swift/grammar/initializer&gt;­where-clause &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Statements.html#//apple_ref/swift/grammar/where-clause&gt;­opt­<br></p><p>While the easiest solution allows commas interchangeably with `where`, it would allow construction of statements like this and<br>it wouldn&#39;t introduce the ability to mix and match Boolean expressions, availability conditions, case conditions, and optional binding conditions.<br></p><p>// where-clause → (where | ,) where-expression<br>for i in 0...10, i % 2 == 0 { print(i) }<br></p><p>To get that you need:<br></p><p>‌condition-list → condition | expression | condition , condition-list | expression, condition-list<br></p><p>Which means that `guard` would be redefined to:<br></p><p>guard condition-list else code-block<br></p><p>This would affect `while`, `repeat-while`, `if`, and `guard`.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/a5ccc11f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 09:00:00am</p></header><div class="content"><p>Draft: https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160 &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160&gt;<br></p><p>Simplifying condition clauses and intermingling expressions with other conditions<br></p><p>Proposal: TBD<br>Author: Erica Sadun &lt;https://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#introduction&gt;Introduction<br></p><p>This proposal adjust Swift grammar to enable the arbitrary mix of expressions among conditions rather than constraining them before other conditions. Under this proposal, expressions are no longer limited to where clauses after the initial list of Boolean conditions.<br></p><p>Swift-evolution thread: [Pitch] making where and , interchangeable in guard conditions &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17926&gt;<br> &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#motivation&gt;Motivation<br></p><p>There is no technical reason to disallow arbitrary mixes of binding, patterns, availability tests, and Boolean assertions within a single compound condition clause. Swift currently enforces a grammar that limits expressions to where clauses after the first non-Boolean condition clause has been mentioned. This rule means that all standalone Boolean tests must precede binding and pattern conditions and allows for code such as:<br></p><p>guard <br>    x == 0,<br>    let y = optional where z == 2 <br>    else { ... }<br>In this example, the Boolean z == 2 clause has no semantic relationship to the optional condition to which it&#39;s syntactically bound. Ideally, where clauses should be restricted to a Boolean assertion tied to variables connected to the binding or pattern condition. Unrelated Boolean assertions should be allowed to stand on their own<br></p><p>If accepted, the following code would be legal, as would similar usage in while and if statements.<br></p><p>guard<br>    x == 0,<br>    let y = optional,<br>    z == 2<br>    else { ... }<br> &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#detailed-design&gt;Detailed Design<br></p><p>Under this proposal, condition lists are updated to accept a grammar along the following lines:<br></p><p>‌condition-list → condition | expression | condition , condition-list | expression, condition-list<br>This enables guard, while, repeat-while, and if to adopt grammars like:<br></p><p>guard condition-list else code-block<br>while condition-list code-block<br>if condition-list code-block (else-clause)?<br>Note: A repeat-while statement does not use a condition list. Its grammar is repeat code-block while expression<br></p><p>This approach simplifies the current Swift grammar, which constructs condition clauses separately from condition lists and conditions. This extra work is needed to introduce an expression before condition lists and to allow an expression after availability checks:<br></p><p>condition-clause → expression<br>condition-clause → expression , condition-list<br>condition-clause → condition-list<br>condition-clause → availability-condition , expression<br>condition-list → condition | condition,condition-list<br>condition → availability-condition | case-condition | optional-binding-condition<br>Beyond this high level change, all three conditions (availability conditions, case conditions, and optional binding conditions) remain unaffected as do their associated where clause grammar. This solution changes list construction not whereclauses.<br></p><p> &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>This proposal does not affect existing code.<br></p><p> &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#alternatives-considered&gt;Alternatives Considered<br></p><p>The &quot;easiest&quot; solution that free interchange of commas with where, permits construction of statements like the following:<br></p><p>// where-clause → (where | ,) where-expression<br>for i in 0...10, i % 2 == 0 { print(i) }<br>Adjusting the where clause in this way wouldn&#39;t introduce the ability to mix and match Boolean expressions, availability conditions, case conditions, and optional binding conditions in condition clauses, and is therefore discarded from consideration.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/51c3e674/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 24, 2016 at 03:00:00pm</p></header><div class="content"><p>Does this proposal distinguish between &quot;where clauses [...] restricted to a<br>Boolean assertion tied to variables connected to the binding or pattern<br>condition&quot; and &quot;unrelated Boolean assertions [that] should be allowed to<br>stand on their own&quot;?<br></p><p>Or are both types of boolean assertions now permitted either following a<br>comma or following a where clause?<br></p><p>On Tue, May 24, 2016 at 10:10 Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Draft: https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160<br>&gt;<br>&gt; Simplifying condition clauses and intermingling expressions with other<br>&gt; conditions<br>&gt;<br>&gt;    - Proposal: TBD<br>&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal adjust Swift grammar to enable the arbitrary mix of<br>&gt; expressions among conditions rather than constraining them before other<br>&gt; conditions. Under this proposal, expressions are no longer limited to where<br>&gt; clauses after the initial list of Boolean conditions.<br>&gt;<br>&gt; Swift-evolution thread: [Pitch] making where and , interchangeable in<br>&gt; guard conditions<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17926&gt;<br>&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; There is no technical reason to disallow arbitrary mixes of binding,<br>&gt; patterns, availability tests, and Boolean assertions within a single<br>&gt; compound condition clause. Swift currently enforces a grammar that limits<br>&gt; expressions to where clauses after the first non-Boolean condition clause<br>&gt; has been mentioned. This rule means that all standalone Boolean tests must<br>&gt; precede binding and pattern conditions and allows for code such as:<br>&gt;<br>&gt; guard<br>&gt;     x == 0,<br>&gt;     let y = optional where z == 2<br>&gt;<br>&gt;<br>&gt;     else { ... }<br>&gt;<br>&gt; In this example, the Boolean z == 2 clause has no semantic relationship<br>&gt; to the optional condition to which it&#39;s syntactically bound. Ideally,<br>&gt; where clauses should be restricted to a Boolean assertion tied to<br>&gt; variables connected to the binding or pattern condition. Unrelated Boolean<br>&gt; assertions should be allowed to stand on their own<br>&gt;<br>&gt; If accepted, the following code would be legal, as would similar usage in<br>&gt; while and if statements.<br>&gt;<br>&gt; guard<br>&gt;     x == 0,<br>&gt;     let y = optional,<br>&gt;     z == 2<br>&gt;     else { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#detailed-design&gt;Detailed<br>&gt; Design<br>&gt;<br>&gt; Under this proposal, condition lists are updated to accept a grammar along<br>&gt; the following lines:<br>&gt;<br>&gt; ‌condition-list → condition | expression | condition , condition-list | expression, condition-list<br>&gt;<br>&gt; This enables guard, while, repeat-while, and if to adopt grammars like:<br>&gt;<br>&gt; guard condition-list else code-block<br>&gt; while condition-list code-block<br>&gt; if condition-list code-block (else-clause)?<br>&gt;<br>&gt; *Note: A repeat-while statement does not use a condition list. Its grammar<br>&gt; is repeat code-block while expression*<br>&gt;<br>&gt; This approach simplifies the current Swift grammar, which constructs<br>&gt; condition clauses separately from condition lists and conditions. This<br>&gt; extra work is needed to introduce an expression before condition lists and<br>&gt; to allow an expression after availability checks:<br>&gt;<br>&gt; condition-clause → expression<br>&gt; condition-clause → expression , condition-list<br>&gt; condition-clause → condition-list<br>&gt; condition-clause → availability-condition , expression<br>&gt; condition-list → condition | condition,condition-list<br>&gt; condition → availability-condition | case-condition | optional-binding-condition<br>&gt;<br>&gt; Beyond this high level change, all three conditions (availability<br>&gt; conditions, case conditions, and optional binding conditions) remain<br>&gt; unaffected as do their associated where clause grammar. This solution<br>&gt; changes list construction not whereclauses.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; This proposal does not affect existing code.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt; The &quot;easiest&quot; solution that free interchange of commas with where,<br>&gt; permits construction of statements like the following:<br>&gt;<br>&gt; // where-clause → (where | ,) where-expressionfor i in 0...10, i % 2 == 0 { print(i) }<br>&gt;<br>&gt; Adjusting the where clause in this way wouldn&#39;t introduce the ability to<br>&gt; mix and match Boolean expressions, availability conditions, case<br>&gt; conditions, and optional binding conditions in condition clauses, and is<br>&gt; therefore discarded from consideration.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/4922a677/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 10:00:00am</p></header><div class="content"><p>There is no way I could figure out how to restrict Boolean assertions to mentioned variables therefore I left where clauses entirely untouched.<br>I&#39;d recommend people adopt in-house standards where Boolean assertions in where clauses should be semantically tied to the condition<br>clause that introduces them.<br></p><p>I will add this as a note.<br></p><p>-- E<br></p><p><br>&gt; On May 24, 2016, at 9:29 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; Does this proposal distinguish between &quot;where clauses [...] restricted to a Boolean assertion tied to variables connected to the binding or pattern condition&quot; and &quot;unrelated Boolean assertions [that] should be allowed to stand on their own&quot;?<br>&gt; <br>&gt; Or are both types of boolean assertions now permitted either following a comma or following a where clause?<br>&gt; <br>&gt; On Tue, May 24, 2016 at 10:10 Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Draft: https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160 &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160&gt;<br>&gt; <br>&gt; Simplifying condition clauses and intermingling expressions with other conditions<br>&gt; <br>&gt; Proposal: TBD<br>&gt; Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal adjust Swift grammar to enable the arbitrary mix of expressions among conditions rather than constraining them before other conditions. Under this proposal, expressions are no longer limited to where clauses after the initial list of Boolean conditions.<br>&gt; <br>&gt; Swift-evolution thread: [Pitch] making where and , interchangeable in guard conditions &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17926&gt;<br>&gt;  &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#motivation&gt;Motivation<br>&gt; <br>&gt; There is no technical reason to disallow arbitrary mixes of binding, patterns, availability tests, and Boolean assertions within a single compound condition clause. Swift currently enforces a grammar that limits expressions to where clauses after the first non-Boolean condition clause has been mentioned. This rule means that all standalone Boolean tests must precede binding and pattern conditions and allows for code such as:<br>&gt; <br>&gt; guard <br>&gt;     x == 0,<br>&gt;     let y = optional where z == 2<br>&gt;  <br>&gt;     else { ... }<br>&gt; In this example, the Boolean z == 2 clause has no semantic relationship to the optional condition to which it&#39;s syntactically bound. Ideally, where clauses should be restricted to a Boolean assertion tied to variables connected to the binding or pattern condition. Unrelated Boolean assertions should be allowed to stand on their own<br>&gt; <br>&gt; If accepted, the following code would be legal, as would similar usage in while and if statements.<br>&gt; <br>&gt; guard<br>&gt;     x == 0,<br>&gt;     let y = optional,<br>&gt;     z == 2<br>&gt;     else { ... }<br>&gt;  &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#detailed-design&gt;Detailed Design<br>&gt; <br>&gt; Under this proposal, condition lists are updated to accept a grammar along the following lines:<br>&gt; <br>&gt; ‌condition-list → condition | expression | condition , condition-list | expression, condition-list<br>&gt; This enables guard, while, repeat-while, and if to adopt grammars like:<br>&gt; <br>&gt; guard condition-list else code-block<br>&gt; while condition-list code-block<br>&gt; if condition-list code-block (else-clause)?<br>&gt; Note: A repeat-while statement does not use a condition list. Its grammar is repeat code-block while expression<br>&gt; <br>&gt; This approach simplifies the current Swift grammar, which constructs condition clauses separately from condition lists and conditions. This extra work is needed to introduce an expression before condition lists and to allow an expression after availability checks:<br>&gt; <br>&gt; condition-clause → expression<br>&gt; condition-clause → expression , condition-list<br>&gt; condition-clause → condition-list<br>&gt; condition-clause → availability-condition , expression<br>&gt; condition-list → condition | condition,condition-list<br>&gt; condition → availability-condition | case-condition | optional-binding-condition<br>&gt; Beyond this high level change, all three conditions (availability conditions, case conditions, and optional binding conditions) remain unaffected as do their associated where clause grammar. This solution changes list construction not whereclauses.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; This proposal does not affect existing code.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; The &quot;easiest&quot; solution that free interchange of commas with where, permits construction of statements like the following:<br>&gt; <br>&gt; // where-clause → (where | ,) where-expression<br>&gt; for i in 0...10, i % 2 == 0 { print(i) }<br>&gt; Adjusting the where clause in this way wouldn&#39;t introduce the ability to mix and match Boolean expressions, availability conditions, case conditions, and optional binding conditions in condition clauses, and is therefore discarded from consideration.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/79df1d2f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 24, 2016 at 05:00:00pm</p></header><div class="content"><p>With the implementation of your proposal, will there be anything that can<br>be written in where clauses that cannot be written after a comma (in the<br>context of guard statements specifically)? If not, does the where clause<br>become entirely a stylistic flourish?<br>On Tue, May 24, 2016 at 11:57 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; There is no way I could figure out how to restrict Boolean assertions to<br>&gt; mentioned variables therefore I left where clauses entirely untouched.<br>&gt; I&#39;d recommend people adopt in-house standards where Boolean assertions in<br>&gt; where clauses should be semantically tied to the condition<br>&gt; clause that introduces them.<br>&gt;<br>&gt; I will add this as a note.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On May 24, 2016, at 9:29 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; Does this proposal distinguish between &quot;where clauses [...] restricted to<br>&gt; a Boolean assertion tied to variables connected to the binding or pattern<br>&gt; condition&quot; and &quot;unrelated Boolean assertions [that] should be allowed to<br>&gt; stand on their own&quot;?<br>&gt;<br>&gt; Or are both types of boolean assertions now permitted either following a<br>&gt; comma or following a where clause?<br>&gt;<br>&gt; On Tue, May 24, 2016 at 10:10 Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Draft: https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160<br>&gt;&gt;<br>&gt;&gt; Simplifying condition clauses and intermingling expressions with other<br>&gt;&gt; conditions<br>&gt;&gt;<br>&gt;&gt;    - Proposal: TBD<br>&gt;&gt;    - Author: Erica Sadun &lt;https://github.com/erica&gt;<br>&gt;&gt;    - Status: TBD<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal adjust Swift grammar to enable the arbitrary mix of<br>&gt;&gt; expressions among conditions rather than constraining them before other<br>&gt;&gt; conditions. Under this proposal, expressions are no longer limited to where<br>&gt;&gt; clauses after the initial list of Boolean conditions.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: [Pitch] making where and , interchangeable in<br>&gt;&gt; guard conditions<br>&gt;&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/17926&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; There is no technical reason to disallow arbitrary mixes of binding,<br>&gt;&gt; patterns, availability tests, and Boolean assertions within a single<br>&gt;&gt; compound condition clause. Swift currently enforces a grammar that limits<br>&gt;&gt; expressions to where clauses after the first non-Boolean condition<br>&gt;&gt; clause has been mentioned. This rule means that all standalone Boolean<br>&gt;&gt; tests must precede binding and pattern conditions and allows for code such<br>&gt;&gt; as:<br>&gt;&gt;<br>&gt;&gt; guard<br>&gt;&gt;     x == 0,<br>&gt;&gt;     let y = optional where z == 2<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     else { ... }<br>&gt;&gt;<br>&gt;&gt; In this example, the Boolean z == 2 clause has no semantic relationship<br>&gt;&gt; to the optional condition to which it&#39;s syntactically bound. Ideally,<br>&gt;&gt; where clauses should be restricted to a Boolean assertion tied to<br>&gt;&gt; variables connected to the binding or pattern condition. Unrelated Boolean<br>&gt;&gt; assertions should be allowed to stand on their own<br>&gt;&gt;<br>&gt;&gt; If accepted, the following code would be legal, as would similar usage in<br>&gt;&gt; while and if statements.<br>&gt;&gt;<br>&gt;&gt; guard<br>&gt;&gt;     x == 0,<br>&gt;&gt;     let y = optional,<br>&gt;&gt;     z == 2<br>&gt;&gt;     else { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#detailed-design&gt;Detailed<br>&gt;&gt; Design<br>&gt;&gt;<br>&gt;&gt; Under this proposal, condition lists are updated to accept a grammar<br>&gt;&gt; along the following lines:<br>&gt;&gt;<br>&gt;&gt; ‌condition-list → condition | expression | condition , condition-list | expression, condition-list<br>&gt;&gt;<br>&gt;&gt; This enables guard, while, repeat-while, and if to adopt grammars like:<br>&gt;&gt;<br>&gt;&gt; guard condition-list else code-block<br>&gt;&gt; while condition-list code-block<br>&gt;&gt; if condition-list code-block (else-clause)?<br>&gt;&gt;<br>&gt;&gt; *Note: A repeat-while statement does not use a condition list. Its<br>&gt;&gt; grammar is repeat code-block while expression*<br>&gt;&gt;<br>&gt;&gt; This approach simplifies the current Swift grammar, which constructs<br>&gt;&gt; condition clauses separately from condition lists and conditions. This<br>&gt;&gt; extra work is needed to introduce an expression before condition lists and<br>&gt;&gt; to allow an expression after availability checks:<br>&gt;&gt;<br>&gt;&gt; condition-clause → expression<br>&gt;&gt; condition-clause → expression , condition-list<br>&gt;&gt; condition-clause → condition-list<br>&gt;&gt; condition-clause → availability-condition , expression<br>&gt;&gt; condition-list → condition | condition,condition-list<br>&gt;&gt; condition → availability-condition | case-condition | optional-binding-condition<br>&gt;&gt;<br>&gt;&gt; Beyond this high level change, all three conditions (availability<br>&gt;&gt; conditions, case conditions, and optional binding conditions) remain<br>&gt;&gt; unaffected as do their associated where clause grammar. This solution<br>&gt;&gt; changes list construction not whereclauses.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#impact-on-existing-code&gt;Impact<br>&gt;&gt; on Existing Code<br>&gt;&gt;<br>&gt;&gt; This proposal does not affect existing code.<br>&gt;&gt;<br>&gt;&gt; &lt;https://gist.github.com/erica/74cfee56a597c0e0026a90ee4e49f160#alternatives-considered&gt;Alternatives<br>&gt;&gt; Considered<br>&gt;&gt;<br>&gt;&gt; The &quot;easiest&quot; solution that free interchange of commas with where,<br>&gt;&gt; permits construction of statements like the following:<br>&gt;&gt;<br>&gt;&gt; // where-clause → (where | ,) where-expressionfor i in 0...10, i % 2 == 0 { print(i) }<br>&gt;&gt;<br>&gt;&gt; Adjusting the where clause in this way wouldn&#39;t introduce the ability to<br>&gt;&gt; mix and match Boolean expressions, availability conditions, case<br>&gt;&gt; conditions, and optional binding conditions in condition clauses, and is<br>&gt;&gt; therefore discarded from consideration.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/ac525ec8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 11:00:00am</p></header><div class="content"><p>The where clause is not a stylistic flourish because it is still best used to constrain conditions that are semantically<br>related to conditions. Upon acceptance as now, there are no compiler checks that mandate any relationship. <br></p><p>The difference is that (1) coders will be allowed to move Boolean assertions out of where clauses when there is no<br>relationship, and (2) they will be allowed to order the statements as desired. Under the current system, all boolean<br>clauses must be conjoined and expressed as the first item of the list (except after availability clauses, as the one exception)<br></p><p>-- E<br></p><p>&gt; On May 24, 2016, at 11:01 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; With the implementation of your proposal, will there be anything that can be written in where clauses that cannot be written after a comma (in the context of guard statements specifically)? If not, does the where clause become entirely a stylistic flourish?<br>&gt; On Tue, May 24, 2016 at 11:57 Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt; There is no way I could figure out how to restrict Boolean assertions to mentioned variables therefore I left where clauses entirely untouched.<br>&gt; I&#39;d recommend people adopt in-house standards where Boolean assertions in where clauses should be semantically tied to the condition<br>&gt; clause that introduces them.<br>&gt; <br>&gt; I will add this as a note.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 9:29 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Does this proposal distinguish between &quot;where clauses [...] restricted to a Boolean assertion tied to variables connected to the binding or pattern condition&quot; and &quot;unrelated Boolean assertions [that] should be allowed to stand on their own&quot;?<br>&gt;&gt; <br>&gt;&gt; Or are both types of boolean assertions now permitted either following a comma or following a where clause?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/9a030718/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>May 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 24, 2016, at 10:07 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; The where clause is not a stylistic flourish because it is still best used to constrain conditions that are semantically<br>&gt; related to conditions. Upon acceptance as now, there are no compiler checks that mandate any relationship. <br></p><p>From a semantic perspective, at least, &#39;where&#39; and &#39;,&#39; don&#39;t really matter to the compiler. Either one is an &quot;and&quot; composition of the list conditions.<br></p><p>-Joe<br></p><p>&gt; The difference is that (1) coders will be allowed to move Boolean assertions out of where clauses when there is no<br>&gt; relationship, and (2) they will be allowed to order the statements as desired. Under the current system, all boolean<br>&gt; clauses must be conjoined and expressed as the first item of the list (except after availability clauses, as the one exception)<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt;&gt; On May 24, 2016, at 11:01 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; With the implementation of your proposal, will there be anything that can be written in where clauses that cannot be written after a comma (in the context of guard statements specifically)? If not, does the where clause become entirely a stylistic flourish?<br>&gt;&gt; On Tue, May 24, 2016 at 11:57 Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; There is no way I could figure out how to restrict Boolean assertions to mentioned variables therefore I left where clauses entirely untouched.<br>&gt;&gt; I&#39;d recommend people adopt in-house standards where Boolean assertions in where clauses should be semantically tied to the condition<br>&gt;&gt; clause that introduces them.<br>&gt;&gt; <br>&gt;&gt; I will add this as a note.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 24, 2016, at 9:29 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does this proposal distinguish between &quot;where clauses [...] restricted to a Boolean assertion tied to variables connected to the binding or pattern condition&quot; and &quot;unrelated Boolean assertions [that] should be allowed to stand on their own&quot;?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or are both types of boolean assertions now permitted either following a comma or following a where clause?<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 24, 2016 at 10:00:00am</p></header><div class="content"><p>I like the idea in principle.<br></p><p>However, right now you can write something like:<br></p><p>if let a = optionalA, frob = fooBarBaz() { ... }<br></p><p>It&#39;s clear that both clauses are optional binding clauses.<br></p><p>With this change, it&#39;s not clear anymore whether the second clause is an<br>optional binding clause, or a logic test erroneously using &#39;=&#39; instead of<br>&#39;==&#39;.<br></p><p>To be fair, though, since assignment in Swift doesn&#39;t return the new value<br>as it does in C, there is far less room for disastrous bugs caused by this<br>sort of mistake.<br></p><p>Austin<br></p><p><br></p><p>On Fri, May 20, 2016 at 10:07 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; *Earlier on Swift Evolution:*<br>&gt;<br>&gt; Me: &quot;*Is there a technical reason that Swift cannot be expanded to allow<br>&gt; arbitrary mixes of conditional binding and boolean assertions within a<br>&gt; single compound guard statement?*&quot;<br>&gt;<br>&gt; Joe Groff: &quot;*No. You already can, we just have the somewhat strange rule<br>&gt; that to separate `guard` conditions uses `,` before optional or pattern<br>&gt; conditions, but `where` before Boolean conditions. **There&#39;s no technical<br>&gt; reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;*<br>&gt;<br>&gt; guard x == 0,<br>&gt;  let y = optional where<br>&gt;  z == 2 {<br>&gt; }<br>&gt;<br>&gt; *Pitch: *<br>&gt;<br>&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently<br>&gt; accept `where` or `,` to separate guard conditions. This would allow a more<br>&gt; consistent approach that supports intermingling conditional binding and<br>&gt; boolean assertions. Here&#39;s a real-world bit of code I was helping someone<br>&gt; with a few evenings ago. It&#39;s attempting to navigate through some JSON,<br>&gt; using optional conditions with where clauses.<br>&gt;<br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try<br>&gt; NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as?<br>&gt; NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray *where **featuresArray.count<br>&gt; &gt; 0,*<br>&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] *where **coordinatesArray.count<br>&gt; &gt; 0,*<br>&gt;     let coordinateArray = coordinatesArray[0] as? NSArray *where **coordinateArray.count<br>&gt; &gt; 3*<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;<br>&gt; Each `where` test is a separate test. While there *are* semantic ties<br>&gt; between the conditional binding and the count tests, there *doesn&#39;t have<br>&gt; to be*. Under Swift&#39;s current rules,  you must use the `where` keyword to<br>&gt; introduce a Boolean test after a binding or pattern, regardless of whether<br>&gt; or not there&#39;s an underlying semantic link between the two.<br>&gt;<br>&gt; By removing this requirement and allowing interchangeability between<br>&gt; `where` and `,`, you&#39;re given the option of tying the boolean to the<br>&gt; binding/pattern match or introducing a boolean statement with no connection<br>&gt; to previous steps. Here&#39;s what this example looks like after excluding<br>&gt; `where`:<br>&gt;<br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try<br>&gt; NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as?<br>&gt; NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt; *    featuresArray.count &gt; 0,*<br>&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt; *    coordinatesArray.count &gt; 0,*<br>&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;     *coordinateArray.count &gt; 3*<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;<br>&gt; The motivation for this approach becomes more compelling when the Boolean<br>&gt; tests are disjoint from binding or pattern matches.<br>&gt;<br>&gt; guard<br>&gt;     minimumShapeCount &gt; 4,<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;     availableArea &gt; minimumArea,<br>&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;         fatalError()<br>&gt; }<br>&gt;<br>&gt; would be allowed compared to current Swift which mandates where between<br>&gt; the second and third tests:<br>&gt;<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea<br>&gt; &gt; minimumArea,<br>&gt;<br>&gt; In my vision, Swift would continue to allow where clauses and expand to<br>&gt; allow disjoint Boolean entries.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/9cdc5e4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Right now, if you look at the grammar, it&#39;s pretty hard to follow and special cased. <br>I think if people follow an intentional pattern of a condition per line (including where clauses)<br>they won&#39;t get in trouble. (Also Swift is a lot smarter about inadvertent = vs ==)<br></p><p>-- E<br></p><p><br>&gt; On May 24, 2016, at 11:59 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like the idea in principle.<br>&gt; <br>&gt; However, right now you can write something like:<br>&gt; <br>&gt; if let a = optionalA, frob = fooBarBaz() { ... }<br>&gt; <br>&gt; It&#39;s clear that both clauses are optional binding clauses.<br>&gt; <br>&gt; With this change, it&#39;s not clear anymore whether the second clause is an optional binding clause, or a logic test erroneously using &#39;=&#39; instead of &#39;==&#39;.<br>&gt; <br>&gt; To be fair, though, since assignment in Swift doesn&#39;t return the new value as it does in C, there is far less room for disastrous bugs caused by this sort of mistake.<br>&gt; <br>&gt; Austin<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Okay, and here is where the problem is (thanks Chris L)<br></p><p>`z = q` is an expression. It returns Void.<br></p><p>For example:<br></p><p>let q = 5<br>var z = 0<br>let foo = z = q // foo inferred to have type `()` which may be unexpected<br></p><p>So if you have the following statement:<br></p><p>guard let x = optional, z = q else {...}<br></p><p>where q is non-optional, there&#39;s issues in that `q` is not an optional and `z = q` is an expression.<br></p><p>-- E<br></p><p><br>&gt; On May 24, 2016, at 11:59 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; I like the idea in principle.<br>&gt; <br>&gt; However, right now you can write something like:<br>&gt; <br>&gt; if let a = optionalA, frob = fooBarBaz() { ... }<br>&gt; <br>&gt; It&#39;s clear that both clauses are optional binding clauses.<br>&gt; <br>&gt; With this change, it&#39;s not clear anymore whether the second clause is an optional binding clause, or a logic test erroneously using &#39;=&#39; instead of &#39;==&#39;.<br>&gt; <br>&gt; To be fair, though, since assignment in Swift doesn&#39;t return the new value as it does in C, there is far less room for disastrous bugs caused by this sort of mistake.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, May 20, 2016 at 10:07 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Earlier on Swift Evolution:<br>&gt; <br>&gt; Me: &quot;Is there a technical reason that Swift cannot be expanded to allow arbitrary mixes of conditional binding and boolean assertions within a single compound guard statement?&quot;<br>&gt; <br>&gt; Joe Groff: &quot;No. You already can, we just have the somewhat strange rule that to separate `guard` conditions uses `,` before optional or pattern conditions, but `where` before Boolean conditions. There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;<br>&gt; <br>&gt; 	guard x == 0,<br>&gt; 	  let y = optional where<br>&gt; 	  z == 2 {<br>&gt; 	}<br>&gt; <br>&gt; Pitch: <br>&gt; <br>&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently accept `where` or `,` to separate guard conditions. This would allow a more consistent approach that supports intermingling conditional binding and boolean assertions. Here&#39;s a real-world bit of code I was helping someone with a few evenings ago. It&#39;s attempting to navigate through some JSON, using optional conditions with where clauses.<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray where featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] where coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray[0] as? NSArray where coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; Each `where` test is a separate test. While there are semantic ties between the conditional binding and the count tests, there doesn&#39;t have to be. Under Swift&#39;s current rules,  you must use the `where` keyword to introduce a Boolean test after a binding or pattern, regardless of whether or not there&#39;s an underlying semantic link between the two.<br>&gt; <br>&gt; By removing this requirement and allowing interchangeability between `where` and `,`, you&#39;re given the option of tying the boolean to the binding/pattern match or introducing a boolean statement with no connection to previous steps. Here&#39;s what this example looks like after excluding `where`:<br>&gt; <br>&gt; guard<br>&gt;     let fileContents = fileContents,<br>&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt;     featuresArray.count &gt; 0,<br>&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt;     coordinatesArray.count &gt; 0,<br>&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;     coordinateArray.count &gt; 3<br>&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt; <br>&gt; The motivation for this approach becomes more compelling when the Boolean tests are disjoint from binding or pattern matches.<br>&gt; <br>&gt; guard<br>&gt;     minimumShapeCount &gt; 4,<br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;     availableArea &gt; minimumArea,<br>&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;         fatalError()<br>&gt; }<br>&gt; <br>&gt; would be allowed compared to current Swift which mandates where between the second and third tests:<br>&gt; <br>&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea &gt; minimumArea,<br>&gt; <br>&gt; In my vision, Swift would continue to allow where clauses and expand to allow disjoint Boolean entries.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; -- E <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/b75b04dc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 24, 2016 at 11:00:00am</p></header><div class="content"><p>Could we just require &quot;let&quot; (or var) to introduce every binding, rather<br>than allowing the combination &quot;if let x = y, z = q, ...&quot;? I always use<br>&quot;let&quot; anyway; I think it&#39;s easier to read.<br></p><p>On Tue, May 24, 2016 at 11:42 AM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Okay, and here is where the problem is (thanks Chris L)<br>&gt;<br>&gt; `z = q` is an expression. It returns Void.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; let q = 5<br>&gt; var z = 0<br>&gt; let foo = z = q // foo inferred to have type `()` which may be unexpected<br>&gt;<br>&gt; So if you have the following statement:<br>&gt;<br>&gt; guard let x = optional, z = q else {...}<br>&gt;<br>&gt; where q is non-optional, there&#39;s issues in that `q` is not an optional and<br>&gt; `z = q` is an expression.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt;<br>&gt; On May 24, 2016, at 11:59 AM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt; I like the idea in principle.<br>&gt;<br>&gt; However, right now you can write something like:<br>&gt;<br>&gt; if let a = optionalA, frob = fooBarBaz() { ... }<br>&gt;<br>&gt; It&#39;s clear that both clauses are optional binding clauses.<br>&gt;<br>&gt; With this change, it&#39;s not clear anymore whether the second clause is an<br>&gt; optional binding clause, or a logic test erroneously using &#39;=&#39; instead of<br>&gt; &#39;==&#39;.<br>&gt;<br>&gt; To be fair, though, since assignment in Swift doesn&#39;t return the new value<br>&gt; as it does in C, there is far less room for disastrous bugs caused by this<br>&gt; sort of mistake.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, May 20, 2016 at 10:07 AM, Erica Sadun via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; *Earlier on Swift Evolution:*<br>&gt;&gt;<br>&gt;&gt; Me: &quot;*Is there a technical reason that Swift cannot be expanded to allow<br>&gt;&gt; arbitrary mixes of conditional binding and boolean assertions within a<br>&gt;&gt; single compound guard statement?*&quot;<br>&gt;&gt;<br>&gt;&gt; Joe Groff: &quot;*No. You already can, we just have the somewhat strange rule<br>&gt;&gt; that to separate `guard` conditions uses `,` before optional or pattern<br>&gt;&gt; conditions, but `where` before Boolean conditions. **There&#39;s no<br>&gt;&gt; technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;*<br>&gt;&gt;<br>&gt;&gt; guard x == 0,<br>&gt;&gt;  let y = optional where<br>&gt;&gt;  z == 2 {<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; *Pitch: *<br>&gt;&gt;<br>&gt;&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently<br>&gt;&gt; accept `where` or `,` to separate guard conditions. This would allow a more<br>&gt;&gt; consistent approach that supports intermingling conditional binding and<br>&gt;&gt; boolean assertions. Here&#39;s a real-world bit of code I was helping someone<br>&gt;&gt; with a few evenings ago. It&#39;s attempting to navigate through some JSON,<br>&gt;&gt; using optional conditions with where clauses.<br>&gt;&gt;<br>&gt;&gt; guard<br>&gt;&gt;     let fileContents = fileContents,<br>&gt;&gt;     let jsonDict = try<br>&gt;&gt; NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as?<br>&gt;&gt; NSDictionary,<br>&gt;&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray *where **featuresArray.count<br>&gt;&gt; &gt; 0,*<br>&gt;&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] *where **coordinatesArray.count<br>&gt;&gt; &gt; 0,*<br>&gt;&gt;     let coordinateArray = coordinatesArray[0] as? NSArray *where **coordinateArray.count<br>&gt;&gt; &gt; 3*<br>&gt;&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;&gt;<br>&gt;&gt; Each `where` test is a separate test. While there *are* semantic ties<br>&gt;&gt; between the conditional binding and the count tests, there *doesn&#39;t have<br>&gt;&gt; to be*. Under Swift&#39;s current rules,  you must use the `where` keyword<br>&gt;&gt; to introduce a Boolean test after a binding or pattern, regardless of<br>&gt;&gt; whether or not there&#39;s an underlying semantic link between the two.<br>&gt;&gt;<br>&gt;&gt; By removing this requirement and allowing interchangeability between<br>&gt;&gt; `where` and `,`, you&#39;re given the option of tying the boolean to the<br>&gt;&gt; binding/pattern match or introducing a boolean statement with no connection<br>&gt;&gt; to previous steps. Here&#39;s what this example looks like after excluding<br>&gt;&gt; `where`:<br>&gt;&gt;<br>&gt;&gt; guard<br>&gt;&gt;     let fileContents = fileContents,<br>&gt;&gt;     let jsonDict = try<br>&gt;&gt; NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as?<br>&gt;&gt; NSDictionary,<br>&gt;&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt;&gt; *    featuresArray.count &gt; 0,*<br>&gt;&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt;&gt; *    coordinatesArray.count &gt; 0,*<br>&gt;&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;&gt;     *coordinateArray.count &gt; 3*<br>&gt;&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;&gt;<br>&gt;&gt; The motivation for this approach becomes more compelling when the Boolean<br>&gt;&gt; tests are disjoint from binding or pattern matches.<br>&gt;&gt;<br>&gt;&gt; guard<br>&gt;&gt;     minimumShapeCount &gt; 4,<br>&gt;&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;&gt;     availableArea &gt; minimumArea,<br>&gt;&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;&gt;         fatalError()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; would be allowed compared to current Swift which mandates where between<br>&gt;&gt; the second and third tests:<br>&gt;&gt;<br>&gt;&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea<br>&gt;&gt; &gt; minimumArea,<br>&gt;&gt;<br>&gt;&gt; In my vision, Swift would continue to allow where clauses and expand to<br>&gt;&gt; allow disjoint Boolean entries.<br>&gt;&gt;<br>&gt;&gt; Thoughts?<br>&gt;&gt;<br>&gt;&gt; -- E<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/9ccf18c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Pitch] making where and , interchangeable in guard conditions.</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>Or you can make sure every expression is boolean, which would take care of this as well...<br></p><p>-- E<br></p><p><br>&gt; On May 24, 2016, at 12:47 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Could we just require &quot;let&quot; (or var) to introduce every binding, rather than allowing the combination &quot;if let x = y, z = q, ...&quot;? I always use &quot;let&quot; anyway; I think it&#39;s easier to read.<br>&gt; <br>&gt; On Tue, May 24, 2016 at 11:42 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Okay, and here is where the problem is (thanks Chris L)<br>&gt; <br>&gt; `z = q` is an expression. It returns Void.<br>&gt; <br>&gt; For example:<br>&gt; <br>&gt; let q = 5<br>&gt; var z = 0<br>&gt; let foo = z = q // foo inferred to have type `()` which may be unexpected<br>&gt; <br>&gt; So if you have the following statement:<br>&gt; <br>&gt; guard let x = optional, z = q else {...}<br>&gt; <br>&gt; where q is non-optional, there&#39;s issues in that `q` is not an optional and `z = q` is an expression.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 11:59 AM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the idea in principle.<br>&gt;&gt; <br>&gt;&gt; However, right now you can write something like:<br>&gt;&gt; <br>&gt;&gt; if let a = optionalA, frob = fooBarBaz() { ... }<br>&gt;&gt; <br>&gt;&gt; It&#39;s clear that both clauses are optional binding clauses.<br>&gt;&gt; <br>&gt;&gt; With this change, it&#39;s not clear anymore whether the second clause is an optional binding clause, or a logic test erroneously using &#39;=&#39; instead of &#39;==&#39;.<br>&gt;&gt; <br>&gt;&gt; To be fair, though, since assignment in Swift doesn&#39;t return the new value as it does in C, there is far less room for disastrous bugs caused by this sort of mistake.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Fri, May 20, 2016 at 10:07 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Earlier on Swift Evolution:<br>&gt;&gt; <br>&gt;&gt; Me: &quot;Is there a technical reason that Swift cannot be expanded to allow arbitrary mixes of conditional binding and boolean assertions within a single compound guard statement?&quot;<br>&gt;&gt; <br>&gt;&gt; Joe Groff: &quot;No. You already can, we just have the somewhat strange rule that to separate `guard` conditions uses `,` before optional or pattern conditions, but `where` before Boolean conditions. There&#39;s no technical reason we couldn&#39;t accept either &#39;where&#39; or &#39;,&#39; consistently.&quot;<br>&gt;&gt; <br>&gt;&gt; 	guard x == 0,<br>&gt;&gt; 	  let y = optional where<br>&gt;&gt; 	  z == 2 {<br>&gt;&gt; 	}<br>&gt;&gt; <br>&gt;&gt; Pitch: <br>&gt;&gt; <br>&gt;&gt; I&#39;d like to update Swift&#39;s grammar to interchangeably and consistently accept `where` or `,` to separate guard conditions. This would allow a more consistent approach that supports intermingling conditional binding and boolean assertions. Here&#39;s a real-world bit of code I was helping someone with a few evenings ago. It&#39;s attempting to navigate through some JSON, using optional conditions with where clauses.<br>&gt;&gt; <br>&gt;&gt; guard<br>&gt;&gt;     let fileContents = fileContents,<br>&gt;&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray where featuresArray.count &gt; 0,<br>&gt;&gt;     let featuresDict = featuresArray[0] as? NSDictionary,<br>&gt;&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;] where coordinatesArray.count &gt; 0,<br>&gt;&gt;     let coordinateArray = coordinatesArray[0] as? NSArray where coordinateArray.count &gt; 3<br>&gt;&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;&gt; <br>&gt;&gt; Each `where` test is a separate test. While there are semantic ties between the conditional binding and the count tests, there doesn&#39;t have to be. Under Swift&#39;s current rules,  you must use the `where` keyword to introduce a Boolean test after a binding or pattern, regardless of whether or not there&#39;s an underlying semantic link between the two.<br>&gt;&gt; <br>&gt;&gt; By removing this requirement and allowing interchangeability between `where` and `,`, you&#39;re given the option of tying the boolean to the binding/pattern match or introducing a boolean statement with no connection to previous steps. Here&#39;s what this example looks like after excluding `where`:<br>&gt;&gt; <br>&gt;&gt; guard<br>&gt;&gt;     let fileContents = fileContents,<br>&gt;&gt;     let jsonDict = try NSJSONSerialization.JSONObjectWithData(fileContents, options: []) as? NSDictionary,<br>&gt;&gt;     let featuresArray = jsonDict[&quot;features&quot;] as? NSArray,<br>&gt;&gt;     featuresArray.count &gt; 0,<br>&gt;&gt;     let featuresDict = featuresArray.firstObject as? NSDictionary,<br>&gt;&gt;     let coordinatesArray = featuresDict[&quot;geometry&quot;],<br>&gt;&gt;     coordinatesArray.count &gt; 0,<br>&gt;&gt;     let coordinateArray = coordinatesArray.firstObject as? NSArray,<br>&gt;&gt;     coordinateArray.count &gt; 3<br>&gt;&gt;     else { fatalError(&quot;Reason&quot;) }<br>&gt;&gt; <br>&gt;&gt; The motivation for this approach becomes more compelling when the Boolean tests are disjoint from binding or pattern matches.<br>&gt;&gt; <br>&gt;&gt; guard<br>&gt;&gt;     minimumShapeCount &gt; 4,<br>&gt;&gt;     let shapes = decompose(map, minimum: minimumShapeCount),<br>&gt;&gt;     availableArea &gt; minimumArea,<br>&gt;&gt;     let map = placeShapes(shapes, availableArea) else {<br>&gt;&gt;         fatalError()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; would be allowed compared to current Swift which mandates where between the second and third tests:<br>&gt;&gt; <br>&gt;&gt;     let shapes = decompose(map, minimum: minimumShapeCount) where availableArea &gt; minimumArea,<br>&gt;&gt; <br>&gt;&gt; In my vision, Swift would continue to allow where clauses and expand to allow disjoint Boolean entries.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt;&gt; <br>&gt;&gt; -- E <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/4a59b652/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
