<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 23, 2016 at 11:00:00am</p></header><div class="content"><p>SwiftPM System Module Search Paths<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>Author: Max Howell &lt;https://github.com/mxcl&gt;<br>Status: Awaiting review<br>Review manager: Anders Bertelrud<br> &lt;&gt;Introduction<br>Swift is able to import C libraries in the same manner as Swift libraries.<br></p><p>For this to occur the library must be represented by a clang module-map file.<br></p><p>The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed.<br></p><p> &lt;&gt;Motivation<br>The current implementation of system module packages have a number of problems:<br></p><p>Install locations vary across platforms and modulemap files require absolute paths<br>/usr/lib:/usr/local/lib is not always a sufficient -L search path<br>/usr/include:/usr/local/include is not always a sufficient -I C compiler search path<br>Installing the system library is left up to the end-user to figure out<br>For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK.<br></p><p>For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this system package is libgtk-3-0-dev which is not entirely intuitive.<br></p><p>For example, Homebrew and MacPorts on OS X install to prefixes other than /usr..modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br></p><p> &lt;&gt;Proposed Solution<br>We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool so that it can query pkg-config for the missing path and flag arguments.<br></p><p>We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool to identify when the system package is not installed to a /usr and in such a case preprocess the modulemap changing the prefix it uses.<br></p><p>We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms.<br></p><p> &lt;&gt;Detailed Design<br> &lt;&gt;Solving Path/Flags Issues<br>Some of our problems can be solved by using the cross platform tool: pkg-config.<br></p><p>A C package can provide a pkg-config file (.pc) which describes:<br></p><p>Its install location<br>Supplementary C-flags that should be used when building against this library<br>If SwiftPM used the .pc file that comes with packages, this solves problems 1 through 3.<br></p><p>Of the tickets we currently have open describing issues using Swift-system-module-packages, reading the .pc file would fix all of them.<br></p><p>It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-config for by parsing the .modulemap file in the Swift package.<br></p><p> &lt;&gt;Providing Package Install Names<br>Package.swift would be supplemented like so:<br></p><p>let package = Package(<br>    name: &quot;CFoo&quot;,<br>    providers: .Brew(installName: &quot;foo&quot;),<br>                .Apt(installName: &quot;libfoo-dev&quot;),<br>)<br>Thus, in the event of build failure for modules that depend on this package we provide additional help to the user:<br></p><p>error: failed to build module `bar&#39;<br>note: you may need to install `foo&#39; using your system-packager:<br></p><p>    apt-get install libfoo-dev<br>Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific packager requires additional parameters, they can be added on a per enum basis.<br></p><p> &lt;&gt;Impact on Existing Code<br>There will be no impact on existing code as this feature simply improves an existing feature making new code possible.<br></p><p> &lt;&gt;Alternatives Considered<br>A clear alternative is allowing additional flags to be specified in a system-module package’s Package.swift.<br></p><p>However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the system package itself, and in fact almost all packages nowadays provide it in a .pc pkg-config file.<br></p><p>Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”.<br></p><p> &lt;&gt;Future Directions<br>The build system could be made more reliable by having the specific packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up.<br></p><p>If this was done pkg-config could become just one option for providing this data, and be used only as a fallback.<br></p><p>We could add an additional flag so that deployment of Swift Packages could be made simpler and system dependencies be installed automatically.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160323/880b1448/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Max,<br></p><p>Thanks for sending out this proposal. I admit I’m somewhat ignorant of the current state of SwiftPM so feel free to point me at existing resources if I’m missing basic things.<br></p><p>You don’t cover it in your proposal, but does this mean pkg-config is now a dependency for SwiftPM? I may be mistaken but it doesn’t seem as though pkg-config is installed on the base OS X system. (This leads me to assume it’s an optional dependency.)<br></p><p>Your proposal suggests the set of supported package mangers will be closed. What about folks using new, or non-standard package managers? What about packages that are installed system-wide without a package manager (e.g. with ./configure &amp;&amp; make &amp;&amp; make install)? <br></p><p>This may be covered elsewhere, but about the case of a C package that is normally system-wide but is currently being hacked on by the user? (For example to while debugging it, or writing bindings for it.)<br></p><p>-Colin<br></p><p>&gt; On Mar 23, 2016, at 2:10 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; SwiftPM System Module Search Paths<br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>&gt; Author: Max Howell &lt;https://github.com/mxcl&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: Anders Bertelrud<br>&gt;  &lt;&gt;Introduction<br>&gt; Swift is able to import C libraries in the same manner as Swift libraries.<br>&gt; <br>&gt; For this to occur the library must be represented by a clang module-map file.<br>&gt; <br>&gt; The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed.<br>&gt; <br>&gt;  &lt;&gt;Motivation<br>&gt; The current implementation of system module packages have a number of problems:<br>&gt; <br>&gt; Install locations vary across platforms and modulemap files require absolute paths<br>&gt; /usr/lib:/usr/local/lib is not always a sufficient -L search path<br>&gt; /usr/include:/usr/local/include is not always a sufficient -I C compiler search path<br>&gt; Installing the system library is left up to the end-user to figure out<br>&gt; For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK.<br>&gt; <br>&gt; For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this system package is libgtk-3-0-dev which is not entirely intuitive.<br>&gt; <br>&gt; For example, Homebrew and MacPorts on OS X install to prefixes other than /usr..modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br>&gt; <br>&gt;  &lt;&gt;Proposed Solution<br>&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool so that it can query pkg-config for the missing path and flag arguments.<br>&gt; <br>&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool to identify when the system package is not installed to a /usr and in such a case preprocess the modulemap changing the prefix it uses.<br>&gt; <br>&gt; We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms.<br>&gt; <br>&gt;  &lt;&gt;Detailed Design<br>&gt;  &lt;&gt;Solving Path/Flags Issues<br>&gt; Some of our problems can be solved by using the cross platform tool: pkg-config.<br>&gt; <br>&gt; A C package can provide a pkg-config file (.pc) which describes:<br>&gt; <br>&gt; Its install location<br>&gt; Supplementary C-flags that should be used when building against this library<br>&gt; If SwiftPM used the .pc file that comes with packages, this solves problems 1 through 3.<br>&gt; <br>&gt; Of the tickets we currently have open describing issues using Swift-system-module-packages, reading the .pc file would fix all of them.<br>&gt; <br>&gt; It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-config for by parsing the .modulemap file in the Swift package.<br>&gt; <br>&gt;  &lt;&gt;Providing Package Install Names<br>&gt; Package.swift would be supplemented like so:<br>&gt; <br>&gt; let package = Package(<br>&gt;     name: &quot;CFoo&quot;,<br>&gt;     providers: .Brew(installName: &quot;foo&quot;),<br>&gt;                 .Apt(installName: &quot;libfoo-dev&quot;),<br>&gt; )<br>&gt; Thus, in the event of build failure for modules that depend on this package we provide additional help to the user:<br>&gt; <br>&gt; error: failed to build module `bar&#39;<br>&gt; note: you may need to install `foo&#39; using your system-packager:<br>&gt; <br>&gt;     apt-get install libfoo-dev<br>&gt; Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific packager requires additional parameters, they can be added on a per enum basis.<br>&gt; <br>&gt;  &lt;&gt;Impact on Existing Code<br>&gt; There will be no impact on existing code as this feature simply improves an existing feature making new code possible.<br>&gt; <br>&gt;  &lt;&gt;Alternatives Considered<br>&gt; A clear alternative is allowing additional flags to be specified in a system-module package’s Package.swift.<br>&gt; <br>&gt; However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the system package itself, and in fact almost all packages nowadays provide it in a .pc pkg-config file.<br>&gt; <br>&gt; Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”.<br>&gt; <br>&gt;  &lt;&gt;Future Directions<br>&gt; The build system could be made more reliable by having the specific packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up.<br>&gt; <br>&gt; If this was done pkg-config could become just one option for providing this data, and be used only as a fallback.<br>&gt; <br>&gt; We could add an additional flag so that deployment of Swift Packages could be made simpler and system dependencies be installed automatically.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/d3a4592d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 24, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; Thanks for sending out this proposal. I admit I’m somewhat ignorant of the current state of SwiftPM so feel free to point me at existing resources if I’m missing basic things.<br>&gt; <br>&gt; You don’t cover it in your proposal, but does this mean pkg-config is now a dependency for SwiftPM? I may be mistaken but it doesn’t seem as though pkg-config is installed on the base OS X system. (This leads me to assume it’s an optional dependency.)<br></p><p>This is a good point, I’ll revise the proposal.<br></p><p>My intentions were: if available, use it, if not, then things may not build. Long term we could parse pkg-config files ourselves since the format is very basic which would be preferable since “your package graph *may* or *may not* build” is hardly fun.<br></p><p>&gt; Your proposal suggests the set of supported package mangers will be closed. What about folks using new, or non-standard package managers?<br></p><p>They can add their package manager to the supported list via a Pull Request.<br></p><p>&gt; What about packages that are installed system-wide without a package manager (e.g. with ./configure &amp;&amp; make &amp;&amp; make install)? <br></p><p>Such packages should come with a .pc file.<br></p><p>&gt; This may be covered elsewhere, but about the case of a C package that is normally system-wide but is currently being hacked on by the user? (For example to while debugging it, or writing bindings for it.)<br></p><p>There is no convenient way to do this at this time, but proposals are welcome. It *is* possible currently, you can make a local module map package that encapsulates the C library, or if it is simple enough our C-target support may be sufficient.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>March 24, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mar 24, 2016, at 5:55 PM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt;&gt; Thanks for sending out this proposal. I admit I’m somewhat ignorant of the current state of SwiftPM so feel free to point me at existing resources if I’m missing basic things.<br>&gt;&gt; <br>&gt;&gt; You don’t cover it in your proposal, but does this mean pkg-config is now a dependency for SwiftPM? I may be mistaken but it doesn’t seem as though pkg-config is installed on the base OS X system. (This leads me to assume it’s an optional dependency.)<br>&gt; <br>&gt; This is a good point, I’ll revise the proposal.<br>&gt; <br>&gt; My intentions were: if available, use it, if not, then things may not build. Long term we could parse pkg-config files ourselves since the format is very basic which would be preferable since “your package graph *may* or *may not* build” is hardly fun<br></p><p>Great! Myself, I would just parse the pc files straight away. Avoiding dependencies seems  highly desirable for something this low in the stack.<br></p><p>&gt;&gt; Your proposal suggests the set of supported package mangers will be closed. What about folks using new, or non-standard package managers?<br>&gt; <br>&gt; They can add their package manager to the supported list via a Pull Request.<br></p><p>This is a surprising answer! Just to be clear―what functionality, specifically, is this enabling?<br></p><p>&gt;&gt; What about packages that are installed system-wide without a package manager (e.g. with ./configure &amp;&amp; make &amp;&amp; make install)? <br>&gt; <br>&gt; Such packages should come with a .pc file.<br>&gt; <br>&gt;&gt; This may be covered elsewhere, but about the case of a C package that is normally system-wide but is currently being hacked on by the user? (For example to while debugging it, or writing bindings for it.)<br>&gt; <br>&gt; There is no convenient way to do this at this time, but proposals are welcome. It *is* possible currently, you can make a local module map package that encapsulates the C library, or if it is simple enough our C-target support may be sufficient<br></p><p>No proposal here, but this is more common than you&#39;d think―it merits at least an FAQ in the final proposal.<br></p><p>Thanks Max!<br>-Colin<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>March 27, 2016 at 12:00:00am</p></header><div class="content"><p>&gt;<br>&gt; It is a convention to name the .pc file after the library link-name, so<br>&gt; we can determine which .pc file to ask pkg-config for by parsing the<br>&gt; .modulemap file in the Swift package.<br></p><p><br>what about the cases where .pc file doesn&#39;t matches the link-name from<br>modulemap for eg : gtk+2 or 3 has these link-names: `link &quot;gtk-2.0&quot;`, `link<br>&quot;gtk-3.0&quot;` and .pc files are `gtk+-2.0.pc`, `gtk+-3.0.pc`<br></p><p>One option could be an optional in Package -&gt; `pkgconfig: &quot;gtk+-2.0&quot;`<br></p><p>----<br></p><p>Probably not in scope of this proposal, I noticed that pkg-config can give<br>versions of the system libs, would it be a good idea for user to mention a<br>version range of system lib while creating the modulemap wrapper package.<br></p><p><br></p><p>On Wed, Mar 23, 2016 at 11:40 PM, Max Howell via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; SwiftPM System Module Search Paths<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>&gt;    - Author: Max Howell &lt;https://github.com/mxcl&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: Anders Bertelrud<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift is able to import C libraries in the same manner as Swift libraries.<br>&gt;<br>&gt; For this to occur the library must be represented by a clang module-map<br>&gt; file.<br>&gt;<br>&gt; The current system for using these module-map files with SwiftPM works,<br>&gt; but with a number of caveats that must be addressed.<br>&gt; Motivation<br>&gt;<br>&gt; The current implementation of system module packages have a number of<br>&gt; problems:<br>&gt;<br>&gt;    1. Install locations vary across platforms and modulemap files require<br>&gt;    absolute paths<br>&gt;    2. /usr/lib:/usr/local/lib is not always a sufficient -L search path<br>&gt;    3. /usr/include:/usr/local/include is not always a sufficient -I C<br>&gt;    compiler search path<br>&gt;    4. Installing the system library is left up to the end-user to figure<br>&gt;    out<br>&gt;<br>&gt; For example to import a module map representing the GTK library, the<br>&gt; include search path must be supplemented with -I/usr/include/gtk so that<br>&gt; a number of includes in the gtk.h header can be sourced for the complete<br>&gt; modular definition of GTK.<br>&gt;<br>&gt; For example to import a module map representing the GTK library a user<br>&gt; must first have a copy of GTK and its headers installed. On Debian based<br>&gt; systems the install name for this system package is libgtk-3-0-dev which<br>&gt; is not entirely intuitive.<br>&gt;<br>&gt; For example, Homebrew and MacPorts on OS X install to prefixes other than<br>&gt; /usr..modulemap files must specify headers with absolute paths. The<br>&gt; standard we encourage with modulemaps is for the headers to be specified<br>&gt; with an assumed prefix of /usr, but you will not find eg. jpeglib.h at<br>&gt; /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br>&gt; Proposed Solution<br>&gt;<br>&gt; We propose that SwiftPM gains the ability to use the cross-platform<br>&gt; pkg-config tool so that it can query pkg-config for the missing path and<br>&gt; flag arguments.<br>&gt;<br>&gt; We propose that SwiftPM gains the ability to use the cross-platform<br>&gt; pkg-config tool to identify when the system package is not installed to a<br>&gt; /usr and in such a case preprocess the modulemap changing the prefix it<br>&gt; uses.<br>&gt;<br>&gt; We propose that Package.swift is supplemented with metadata that provides<br>&gt; the package-install-name for specific platforms.<br>&gt; Detailed DesignSolving Path/Flags Issues<br>&gt;<br>&gt; Some of our problems can be solved by using the cross platform tool:<br>&gt; pkg-config.<br>&gt;<br>&gt; A C package can provide a pkg-config file (.pc) which describes:<br>&gt;<br>&gt;    1. Its install location<br>&gt;    2. Supplementary C-flags that should be used when building against<br>&gt;    this library<br>&gt;<br>&gt; If SwiftPM used the .pc file that comes with packages, this solves<br>&gt; problems 1 through 3.<br>&gt;<br>&gt; Of the tickets we currently have open describing issues using<br>&gt; Swift-system-module-packages, reading the .pc file would fix all of them.<br>&gt;<br>&gt; It is a convention to name the .pc file after the library link-name, so<br>&gt; we can determine which .pc file to ask pkg-config for by parsing the<br>&gt; .modulemap file in the Swift package.<br>&gt; Providing Package Install Names<br>&gt;<br>&gt; Package.swift would be supplemented like so:<br>&gt;<br>&gt; let package = Package(<br>&gt;     name: &quot;CFoo&quot;,<br>&gt;     providers: .Brew(installName: &quot;foo&quot;),<br>&gt;                 .Apt(installName: &quot;libfoo-dev&quot;),<br>&gt; )<br>&gt;<br>&gt; Thus, in the event of build failure for modules that depend on this<br>&gt; package we provide additional help to the user:<br>&gt;<br>&gt; error: failed to build module `bar&#39;<br>&gt; note: you may need to install `foo&#39; using your system-packager:<br>&gt;<br>&gt;     apt-get install libfoo-dev<br>&gt;<br>&gt; Since the syntax to provide this information uses an explicit enum we can<br>&gt; add code for each enum to detect which system packagers should be<br>&gt; recommended. The community will need to write the code for their own<br>&gt; platforms. It also means that if a specific packager requires additional<br>&gt; parameters, they can be added on a per enum basis.<br>&gt; Impact on Existing Code<br>&gt;<br>&gt; There will be no impact on existing code as this feature simply improves<br>&gt; an existing feature making new code possible.<br>&gt; Alternatives Considered<br>&gt;<br>&gt; A clear alternative is allowing additional flags to be specified in a<br>&gt; system-module package’s Package.swift.<br>&gt;<br>&gt; However since these paths and flags will vary by platform this would<br>&gt; because a large matrix that is quite a maintenance burden. Really this<br>&gt; information is recorded already, in the system package itself, and in fact<br>&gt; almost all packages nowadays provide it in a .pc pkg-config file.<br>&gt;<br>&gt; Also we do not want to allow arbitrary flags to be specified in<br>&gt; Package.swift, this allows packages too much power to break a large<br>&gt; dependency graph with bad compiles. The only entity that understands the<br>&gt; whole graph and can manage the build without breakage is SwiftPM, and<br>&gt; allowing packages themselves to add arbitrary flags prevents SwiftPM from<br>&gt; being able to understand and control the build ensuring reliability and<br>&gt; preventing “Dependency Hell”.<br>&gt; Future Directions<br>&gt;<br>&gt; The build system could be made more reliable by having the specific<br>&gt; packager provide the information that this proposal garners from<br>&gt; pkg-config. For example, Homebrew installs everything into independent<br>&gt; directories, using these directories instead of more general POSIX search<br>&gt; paths means there is no danger of edge-case search path collisions and the<br>&gt; wrong libraries being picked up.<br>&gt;<br>&gt; If this was done pkg-config could become just one option for providing<br>&gt; this data, and be used only as a fallback.<br>&gt; ------------------------------<br>&gt;<br>&gt; We could add an additional flag so that deployment of Swift Packages could<br>&gt; be made simpler and system dependencies be installed automatically.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160327/df184879/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 31, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 26, 2016, at 12:15 PM, Ankit Agarwal &lt;ankit at ankit.im &lt;mailto:ankit at ankit.im&gt;&gt; wrote:<br>&gt; <br>&gt; It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-config for by parsing the .modulemap file in the Swift package.<br>&gt; <br>&gt; what about the cases where .pc file doesn&#39;t matches the link-name from modulemap for eg : gtk+2 or 3 has these link-names: `link &quot;gtk-2.0&quot;`, `link &quot;gtk-3.0&quot;` and .pc files are `gtk+-2.0.pc`, `gtk+-3.0.pc`<br>&gt; <br>&gt; One option could be an optional in Package -&gt; `pkgconfig: &quot;gtk+-2.0&quot;`<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; Probably not in scope of this proposal, I noticed that pkg-config can give versions of the system libs, would it be a good idea for user to mention a version range of system lib while creating the modulemap wrapper package.<br></p><p>Our decision here was that if you have CFoo then CFoo2 is the name of the package for the major version bump to 2.<br></p><p>The rationale for this is: this is how it basically works in the C library packaging system currently.<br></p><p>Major version bumps are much rarer and the approach taken by system packagers has been to make entirely new packages for them. Even the .pc files are versioned thus, at least, this is all I’ve ever seen.<br></p><p>It’s not clean, but we’re building on top of what is there.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/8b70b4d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>March 31, 2016 at 04:00:00pm</p></header><div class="content"><p>I have updated the proposal with everyone’s feedback:<br></p><p>SwiftPM System Module Search Paths<br>Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>Author: Max Howell &lt;https://github.com/mxcl&gt;<br>Status: Awaiting review<br>Review manager: Anders Bertelrud<br> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#introduction&gt;Introduction<br></p><p>Swift is able to import C libraries in the same manner as Swift libraries.<br></p><p>For this to occur the library must be represented by a clang module-map file.<br></p><p>The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#motivation&gt;Motivation<br></p><p>The current implementation of system module packages have a number of problems:<br></p><p>Install locations vary across platforms and modulemap files require absolute paths<br>/usr/lib:/usr/local/lib is not always a sufficient -L search path<br>/usr/include:/usr/local/include is not always a sufficient -I C compiler search path<br>Installing the system library is left up to the end-user to figure out<br>For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK.<br></p><p>For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this system package is libgtk-3-0-dev which is not entirely intuitive.<br></p><p>For example, Homebrew and MacPorts on OS X install to prefixes other than /usr. .modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#proposed-solution&gt;Proposed Solution<br></p><p>We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool so that it can query pkg-config for the missing path and flag arguments.<br></p><p>We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool to identify when the system package is not installed to a /usr and in such a case preprocess the modulemap changing the prefix it uses.<br></p><p>We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#detailed-design&gt;Detailed Design<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#solving-pathflags-issues&gt;Solving Path/Flags Issues<br></p><p>Some of our problems can be solved by using the cross platform tool: pkg-config.<br></p><p>A C package can provide a pkg-config file (.pc) which describes:<br></p><p>Its install location<br>Supplementary C-flags that should be used when compiling against this library<br>Supplementary C-flags that should be used when linking against this library<br>If SwiftPM used the .pc file that comes with packages, this solves problems 1 through 3.<br></p><p>Of the tickets we currently have open describing issues using Swift-system-module-packages, reading the .pc file would fix all of them.<br></p><p>It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-configfor by parsing the .modulemap file in the Swift package. However sometimes this is not true, (eg. GTK-3 on Ubuntu), so we will make it possible to specify the .pc file name in Package.swift.<br></p><p>pkg-config is not currently a dependency of the Swift toolchain, and thus to avoid depending on it we will schedule work to interpret .pc files without requiring pkg-config to be installed. The file format for .pc files is simple and standard so despite reinventing the wheel, this is a low risk choice.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#providing-package-install-names&gt;Providing Package Install Names<br></p><p>Package.swift would be supplemented like so:<br></p><p>let package = Package(<br>    name: &quot;CFoo&quot;,<br>    providers: .Brew(installName: &quot;foo&quot;),<br>                .Apt(installName: &quot;libfoo-dev&quot;),<br>          .PkgConfig(&quot;foo.pc&quot;),<br>)<br>Thus, in the event of build failure for modules that depend on this package we provide additional help to the user:<br></p><p>error: failed to build module `bar&#39;<br>note: you may need to install `foo&#39; using your system-packager:<br></p><p>    apt-get install libfoo-dev<br>Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific packager requires additional parameters, they can be added on a per enum basis.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#install-names-are-not-standard&gt;Install-names are not standard<br></p><p>apt is used across multiple distirbutions and the install-names for tools vary. Even for the same distribution install-names may vary across releases (eg. from Ubuntu 15.04 to Ubuntu 15.10) or even on ocassion at finer granularity.<br></p><p>We will not add explicit handling for this, but one can imagine the enums for different system packagers could be supplemented in a backwards compatible way to provide specific handling as real-world uses emerge, eg:<br></p><p>case Apt(installName: String)<br></p><p>// …could be adapted to:<br></p><p>struct Debian: Linux {}<br>struct Ubuntu: Debian {<br>    enum Variant {<br>        case Gubuntu<br>        case Kubuntu(Version)<br>    }<br>    enum Version {<br>        case v1510<br>        case v1504<br>    }<br>}<br>case Apt(installName: String, distribution: Linux? = nil)<br> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>There will be no impact on existing code as this feature simply improves an existing feature making new code possible.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#alternatives-considered&gt;Alternatives Considered<br></p><p>A clear alternative is allowing additional flags to be specified in a system-module package’s Package.swift.<br></p><p>However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the system package itself, and in fact almost all packages nowadays provide it in a .pc pkg-config file.<br></p><p>Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#unsolved-problems&gt;Unsolved Problems<br></p><p>Some (usually more legacy) C libraries do not provide .pc files instead they may provide a tool named eg. foo-configthat can be queried for compile and link flags. We do not yet support these tools, and would prefer to take a wait and see approach to determine how important supporting them may be.<br></p><p>Some libraries on OS X do not come with .pc files. Again we&#39;d like to see which libraries are affected before potentially offering a solution here.<br></p><p> &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#future-directions&gt;Future Directions<br></p><p>The build system could be made more reliable by having the specific packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up.<br></p><p>If this was done pkg-config could become just one option for providing this data, and be used only as a fallback.<br></p><p>We do not wish to provide a flag to automatically install dependencies via the system packager. We feel this opens us up to security implications beyond the scope of this tool.<br></p><p>Instead we can provide JSON output that can be parsed and executed by some other tooling developed outside of Apple.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160331/61c10ea5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/05540cd6be96706f76aa66a4519f7db9?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Ankit Agarwal</string> &lt;ankit at ankit.im&gt;<p>April  1, 2016 at 08:00:00am</p></header><div class="content"><p>👍<br></p><p>On Friday 1 April 2016, Max Howell &lt;max.howell at apple.com&gt; wrote:<br></p><p>&gt; I have updated the proposal with everyone’s feedback:<br>&gt;<br>&gt; SwiftPM System Module Search Paths<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>&gt;    - Author: Max Howell &lt;https://github.com/mxcl&gt;<br>&gt;    - Status: *Awaiting review*<br>&gt;    - Review manager: Anders Bertelrud<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Swift is able to import C libraries in the same manner as Swift libraries.<br>&gt;<br>&gt; For this to occur the library must be represented by a clang module-map<br>&gt; file.<br>&gt;<br>&gt; The current system for using these module-map files with SwiftPM works,<br>&gt; but with a number of caveats that must be addressed.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The current implementation of system module packages have a number of<br>&gt; problems:<br>&gt;<br>&gt;    1. Install locations vary across platforms and modulemap files require<br>&gt;    absolute paths<br>&gt;    2. /usr/lib:/usr/local/lib is not always a sufficient -L search path<br>&gt;    3. /usr/include:/usr/local/include is not always a sufficient -I C<br>&gt;    compiler search path<br>&gt;    4. Installing the system library is left up to the end-user to figure<br>&gt;    out<br>&gt;<br>&gt; For example to import a module map representing the GTK library, the<br>&gt; include search path must be supplemented with -I/usr/include/gtk so that<br>&gt; a number of includes in the gtk.h header can be sourced for the complete<br>&gt; modular definition of GTK.<br>&gt;<br>&gt; For example to import a module map representing the GTK library a user<br>&gt; must first have a copy of GTK and its headers installed. On Debian based<br>&gt; systems the install name for this system package is libgtk-3-0-dev which<br>&gt; is not entirely intuitive.<br>&gt;<br>&gt; For example, Homebrew and MacPorts on OS X install to prefixes other than<br>&gt; /usr. .modulemap files must specify headers with absolute paths. The<br>&gt; standard we encourage with modulemaps is for the headers to be specified<br>&gt; with an assumed prefix of /usr, but you will not find eg. jpeglib.h at<br>&gt; /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#proposed-solution&gt;Proposed<br>&gt; Solution<br>&gt;<br>&gt; We propose that SwiftPM gains the ability to use the cross-platform<br>&gt; pkg-config tool so that it can query pkg-config for the missing path and<br>&gt; flag arguments.<br>&gt;<br>&gt; We propose that SwiftPM gains the ability to use the cross-platform<br>&gt; pkg-config tool to identify when the system package is not installed to a<br>&gt; /usr and in such a case preprocess the modulemap changing the prefix it<br>&gt; uses.<br>&gt;<br>&gt; We propose that Package.swift is supplemented with metadata that provides<br>&gt; the package-install-name for specific platforms.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#detailed-design&gt;Detailed<br>&gt; Design<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#solving-pathflags-issues&gt;Solving<br>&gt; Path/Flags Issues<br>&gt;<br>&gt; Some of our problems can be solved by using the cross platform tool:<br>&gt; pkg-config.<br>&gt;<br>&gt; A C package can provide a pkg-config file (.pc) which describes:<br>&gt;<br>&gt;    1. Its install location<br>&gt;    2. Supplementary C-flags that should be used when compiling against<br>&gt;    this library<br>&gt;    3. Supplementary C-flags that should be used when linking against this<br>&gt;    library<br>&gt;<br>&gt; If SwiftPM used the .pc file that comes with packages, this solves<br>&gt; problems 1 through 3.<br>&gt;<br>&gt; Of the tickets we currently have open describing issues using<br>&gt; Swift-system-module-packages, reading the .pc file would fix all of them.<br>&gt;<br>&gt; It is a convention to name the .pc file after the library link-name, so<br>&gt; we can determine which .pc file to ask pkg-configfor by parsing the<br>&gt; .modulemap file in the Swift package. However sometimes this is not true,<br>&gt; (eg. GTK-3 on Ubuntu), so we will make it possible to specify the .pc file<br>&gt; name in Package.swift.<br>&gt;<br>&gt; pkg-config is not currently a dependency of the Swift toolchain, and thus<br>&gt; to avoid depending on it we will schedule work to interpret .pc files<br>&gt; without requiring pkg-config to be installed. The file format for .pc files<br>&gt; is simple and standard so despite reinventing the wheel, this is a low risk<br>&gt; choice.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#providing-package-install-names&gt;Providing<br>&gt; Package Install Names<br>&gt;<br>&gt; Package.swift would be supplemented like so:<br>&gt;<br>&gt; let package = Package(<br>&gt;     name: &quot;CFoo&quot;,<br>&gt;     providers: .Brew(installName: &quot;foo&quot;),<br>&gt;                 .Apt(installName: &quot;libfoo-dev&quot;),<br>&gt;           .PkgConfig(&quot;foo.pc&quot;),<br>&gt; )<br>&gt;<br>&gt; Thus, in the event of build failure for modules that depend on this<br>&gt; package we provide additional help to the user:<br>&gt;<br>&gt; error: failed to build module `bar&#39;<br>&gt; note: you may need to install `foo&#39; using your system-packager:<br>&gt;<br>&gt;     apt-get install libfoo-dev<br>&gt;<br>&gt; Since the syntax to provide this information uses an explicit enum we can<br>&gt; add code for each enum to detect which system packagers should be<br>&gt; recommended. The community will need to write the code for their own<br>&gt; platforms. It also means that if a specific packager requires additional<br>&gt; parameters, they can be added on a per enum basis.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#install-names-are-not-standard&gt;Install-names<br>&gt; are not standard<br>&gt;<br>&gt; apt is used across multiple distirbutions and the install-names for tools<br>&gt; vary. Even for the same distribution install-names may vary across releases<br>&gt; (eg. from Ubuntu 15.04 to Ubuntu 15.10) or even on ocassion at finer<br>&gt; granularity.<br>&gt;<br>&gt; We will not add explicit handling for this, but one can imagine the enums<br>&gt; for different system packagers could be supplemented in a backwards<br>&gt; compatible way to provide specific handling as real-world uses emerge, eg:<br>&gt;<br>&gt; case Apt(installName: String)<br>&gt; // …could be adapted to:<br>&gt; struct Debian: Linux {}struct Ubuntu: Debian {<br>&gt;     enum Variant {<br>&gt;         case Gubuntu<br>&gt;         case Kubuntu(Version)<br>&gt;     }<br>&gt;     enum Version {<br>&gt;         case v1510<br>&gt;         case v1504<br>&gt;     }<br>&gt; }case Apt(installName: String, distribution: Linux? = nil)<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#impact-on-existing-code&gt;Impact<br>&gt; on Existing Code<br>&gt;<br>&gt; There will be no impact on existing code as this feature simply improves<br>&gt; an existing feature making new code possible.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt;<br>&gt; A clear alternative is allowing additional flags to be specified in a<br>&gt; system-module package’s Package.swift.<br>&gt;<br>&gt; However since these paths and flags will vary by platform this would<br>&gt; because a large matrix that is quite a maintenance burden. Really this<br>&gt; information is recorded already, in the system package itself, and in fact<br>&gt; almost all packages nowadays provide it in a .pc pkg-config file.<br>&gt;<br>&gt; Also we do not want to allow arbitrary flags to be specified in<br>&gt; Package.swift, this allows packages too much power to break a large<br>&gt; dependency graph with bad compiles. The only entity that understands the<br>&gt; whole graph and can manage the build without breakage is SwiftPM, and<br>&gt; allowing packages themselves to add arbitrary flags prevents SwiftPM from<br>&gt; being able to understand and control the build ensuring reliability and<br>&gt; preventing “Dependency Hell”.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#unsolved-problems&gt;Unsolved<br>&gt; Problems<br>&gt;<br>&gt; Some (usually more legacy) C libraries do not provide .pc files instead<br>&gt; they may provide a tool named eg. foo-configthat can be queried for<br>&gt; compile and link flags. We do not yet support these tools, and would prefer<br>&gt; to take a wait and see approach to determine how important supporting them<br>&gt; may be.<br>&gt;<br>&gt; Some libraries on OS X do not come with .pc files. Again we&#39;d like to see<br>&gt; which libraries are affected before potentially offering a solution here.<br>&gt;<br>&gt; &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#future-directions&gt;Future<br>&gt; Directions<br>&gt;<br>&gt; The build system could be made more reliable by having the specific<br>&gt; packager provide the information that this proposal garners from<br>&gt; pkg-config. For example, Homebrew installs everything into independent<br>&gt; directories, using these directories instead of more general POSIX search<br>&gt; paths means there is no danger of edge-case search path collisions and the<br>&gt; wrong libraries being picked up.<br>&gt;<br>&gt; If this was done pkg-config could become just one option for providing<br>&gt; this data, and be used only as a fallback.<br>&gt; ------------------------------<br>&gt;<br>&gt; We do not wish to provide a flag to automatically install dependencies via<br>&gt; the system packager. We feel this opens us up to security implications<br>&gt; beyond the scope of this tool.<br>&gt; Instead we can provide JSON output that can be parsed and executed by some<br>&gt; other tooling developed outside of Apple.<br>&gt;<br></p><p><br>-- <br>Ankit<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160401/1c5b8cb5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April  3, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Max,<br></p><p>The proposal refers to &quot;the pkg-config specification&quot;, can you add a link to that? In particular, I am curious how SwiftPM will know where to look for those files.<br></p><p> - Daniel<br></p><p>&gt; On Mar 31, 2016, at 4:04 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have updated the proposal with everyone’s feedback:<br>&gt; <br>&gt; SwiftPM System Module Search Paths<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>&gt; Author: Max Howell &lt;https://github.com/mxcl&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: Anders Bertelrud<br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#introduction&gt;Introduction<br>&gt; <br>&gt; Swift is able to import C libraries in the same manner as Swift libraries.<br>&gt; <br>&gt; For this to occur the library must be represented by a clang module-map file.<br>&gt; <br>&gt; The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#motivation&gt;Motivation<br>&gt; <br>&gt; The current implementation of system module packages have a number of problems:<br>&gt; <br>&gt; Install locations vary across platforms and modulemap files require absolute paths<br>&gt; /usr/lib:/usr/local/lib is not always a sufficient -L search path<br>&gt; /usr/include:/usr/local/include is not always a sufficient -I C compiler search path<br>&gt; Installing the system library is left up to the end-user to figure out<br>&gt; For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK.<br>&gt; <br>&gt; For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this system package is libgtk-3-0-dev which is not entirely intuitive.<br>&gt; <br>&gt; For example, Homebrew and MacPorts on OS X install to prefixes other than /usr. .modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#proposed-solution&gt;Proposed Solution<br>&gt; <br>&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool so that it can query pkg-config for the missing path and flag arguments.<br>&gt; <br>&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool to identify when the system package is not installed to a /usr and in such a case preprocess the modulemap changing the prefix it uses.<br>&gt; <br>&gt; We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#detailed-design&gt;Detailed Design<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#solving-pathflags-issues&gt;Solving Path/Flags Issues<br>&gt; <br>&gt; Some of our problems can be solved by using the cross platform tool: pkg-config.<br>&gt; <br>&gt; A C package can provide a pkg-config file (.pc) which describes:<br>&gt; <br>&gt; Its install location<br>&gt; Supplementary C-flags that should be used when compiling against this library<br>&gt; Supplementary C-flags that should be used when linking against this library<br>&gt; If SwiftPM used the .pc file that comes with packages, this solves problems 1 through 3.<br>&gt; <br>&gt; Of the tickets we currently have open describing issues using Swift-system-module-packages, reading the .pc file would fix all of them.<br>&gt; <br>&gt; It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-configfor by parsing the .modulemap file in the Swift package. However sometimes this is not true, (eg. GTK-3 on Ubuntu), so we will make it possible to specify the .pc file name in Package.swift.<br>&gt; <br>&gt; pkg-config is not currently a dependency of the Swift toolchain, and thus to avoid depending on it we will schedule work to interpret .pc files without requiring pkg-config to be installed. The file format for .pc files is simple and standard so despite reinventing the wheel, this is a low risk choice.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#providing-package-install-names&gt;Providing Package Install Names<br>&gt; <br>&gt; Package.swift would be supplemented like so:<br>&gt; <br>&gt; let package = Package(<br>&gt;     name: &quot;CFoo&quot;,<br>&gt;     providers: .Brew(installName: &quot;foo&quot;),<br>&gt;                 .Apt(installName: &quot;libfoo-dev&quot;),<br>&gt;           .PkgConfig(&quot;foo.pc&quot;),<br>&gt; )<br>&gt; Thus, in the event of build failure for modules that depend on this package we provide additional help to the user:<br>&gt; <br>&gt; error: failed to build module `bar&#39;<br>&gt; note: you may need to install `foo&#39; using your system-packager:<br>&gt; <br>&gt;     apt-get install libfoo-dev<br>&gt; Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific packager requires additional parameters, they can be added on a per enum basis.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#install-names-are-not-standard&gt;Install-names are not standard<br>&gt; <br>&gt; apt is used across multiple distirbutions and the install-names for tools vary. Even for the same distribution install-names may vary across releases (eg. from Ubuntu 15.04 to Ubuntu 15.10) or even on ocassion at finer granularity.<br>&gt; <br>&gt; We will not add explicit handling for this, but one can imagine the enums for different system packagers could be supplemented in a backwards compatible way to provide specific handling as real-world uses emerge, eg:<br>&gt; <br>&gt; case Apt(installName: String)<br>&gt; <br>&gt; // …could be adapted to:<br>&gt; <br>&gt; struct Debian: Linux {}<br>&gt; struct Ubuntu: Debian {<br>&gt;     enum Variant {<br>&gt;         case Gubuntu<br>&gt;         case Kubuntu(Version)<br>&gt;     }<br>&gt;     enum Version {<br>&gt;         case v1510<br>&gt;         case v1504<br>&gt;     }<br>&gt; }<br>&gt; case Apt(installName: String, distribution: Linux? = nil)<br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#impact-on-existing-code&gt;Impact on Existing Code<br>&gt; <br>&gt; There will be no impact on existing code as this feature simply improves an existing feature making new code possible.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; A clear alternative is allowing additional flags to be specified in a system-module package’s Package.swift.<br>&gt; <br>&gt; However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the system package itself, and in fact almost all packages nowadays provide it in a .pc pkg-config file.<br>&gt; <br>&gt; Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#unsolved-problems&gt;Unsolved Problems<br>&gt; <br>&gt; Some (usually more legacy) C libraries do not provide .pc files instead they may provide a tool named eg. foo-configthat can be queried for compile and link flags. We do not yet support these tools, and would prefer to take a wait and see approach to determine how important supporting them may be.<br>&gt; <br>&gt; Some libraries on OS X do not come with .pc files. Again we&#39;d like to see which libraries are affected before potentially offering a solution here.<br>&gt; <br>&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#future-directions&gt;Future Directions<br>&gt; <br>&gt; The build system could be made more reliable by having the specific packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up.<br>&gt; <br>&gt; If this was done pkg-config could become just one option for providing this data, and be used only as a fallback.<br>&gt; <br>&gt; We do not wish to provide a flag to automatically install dependencies via the system packager. We feel this opens us up to security implications beyond the scope of this tool.<br>&gt; <br>&gt; Instead we can provide JSON output that can be parsed and executed by some other tooling developed outside of Apple.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160403/88d16523/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April  6, 2016 at 10:00:00am</p></header><div class="content"><p>There is no spec, but the man page has info on what you asked<br></p><p>http://linux.die.net/man/1/pkg-config<br></p><p>&gt; Hi Max,<br>&gt; <br>&gt; The proposal refers to &quot;the pkg-config specification&quot;, can you add a link to that? In particular, I am curious how SwiftPM will know where to look for those files.<br>&gt; <br>&gt;  - Daniel<br>&gt; <br>&gt;&gt; On Mar 31, 2016, at 4:04 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have updated the proposal with everyone’s feedback:<br>&gt;&gt; <br>&gt;&gt; SwiftPM System Module Search Paths<br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>&gt;&gt; Author: Max Howell &lt;https://github.com/mxcl&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: Anders Bertelrud<br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; Swift is able to import C libraries in the same manner as Swift libraries.<br>&gt;&gt; <br>&gt;&gt; For this to occur the library must be represented by a clang module-map file.<br>&gt;&gt; <br>&gt;&gt; The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; The current implementation of system module packages have a number of problems:<br>&gt;&gt; <br>&gt;&gt; Install locations vary across platforms and modulemap files require absolute paths<br>&gt;&gt; /usr/lib:/usr/local/lib is not always a sufficient -L search path<br>&gt;&gt; /usr/include:/usr/local/include is not always a sufficient -I C compiler search path<br>&gt;&gt; Installing the system library is left up to the end-user to figure out<br>&gt;&gt; For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK.<br>&gt;&gt; <br>&gt;&gt; For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this system package is libgtk-3-0-dev which is not entirely intuitive.<br>&gt;&gt; <br>&gt;&gt; For example, Homebrew and MacPorts on OS X install to prefixes other than /usr. .modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#proposed-solution&gt;Proposed Solution<br>&gt;&gt; <br>&gt;&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool so that it can query pkg-config for the missing path and flag arguments.<br>&gt;&gt; <br>&gt;&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool to identify when the system package is not installed to a /usr and in such a case preprocess the modulemap changing the prefix it uses.<br>&gt;&gt; <br>&gt;&gt; We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#detailed-design&gt;Detailed Design<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#solving-pathflags-issues&gt;Solving Path/Flags Issues<br>&gt;&gt; <br>&gt;&gt; Some of our problems can be solved by using the cross platform tool: pkg-config.<br>&gt;&gt; <br>&gt;&gt; A C package can provide a pkg-config file (.pc) which describes:<br>&gt;&gt; <br>&gt;&gt; Its install location<br>&gt;&gt; Supplementary C-flags that should be used when compiling against this library<br>&gt;&gt; Supplementary C-flags that should be used when linking against this library<br>&gt;&gt; If SwiftPM used the .pc file that comes with packages, this solves problems 1 through 3.<br>&gt;&gt; <br>&gt;&gt; Of the tickets we currently have open describing issues using Swift-system-module-packages, reading the .pc file would fix all of them.<br>&gt;&gt; <br>&gt;&gt; It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-configfor by parsing the .modulemap file in the Swift package. However sometimes this is not true, (eg. GTK-3 on Ubuntu), so we will make it possible to specify the .pc file name in Package.swift.<br>&gt;&gt; <br>&gt;&gt; pkg-config is not currently a dependency of the Swift toolchain, and thus to avoid depending on it we will schedule work to interpret .pc files without requiring pkg-config to be installed. The file format for .pc files is simple and standard so despite reinventing the wheel, this is a low risk choice.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#providing-package-install-names&gt;Providing Package Install Names<br>&gt;&gt; <br>&gt;&gt; Package.swift would be supplemented like so:<br>&gt;&gt; <br>&gt;&gt; let package = Package(<br>&gt;&gt;     name: &quot;CFoo&quot;,<br>&gt;&gt;     providers: .Brew(installName: &quot;foo&quot;),<br>&gt;&gt;                 .Apt(installName: &quot;libfoo-dev&quot;),<br>&gt;&gt;           .PkgConfig(&quot;foo.pc&quot;),<br>&gt;&gt; )<br>&gt;&gt; Thus, in the event of build failure for modules that depend on this package we provide additional help to the user:<br>&gt;&gt; <br>&gt;&gt; error: failed to build module `bar&#39;<br>&gt;&gt; note: you may need to install `foo&#39; using your system-packager:<br>&gt;&gt; <br>&gt;&gt;     apt-get install libfoo-dev<br>&gt;&gt; Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific packager requires additional parameters, they can be added on a per enum basis.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#install-names-are-not-standard&gt;Install-names are not standard<br>&gt;&gt; <br>&gt;&gt; apt is used across multiple distirbutions and the install-names for tools vary. Even for the same distribution install-names may vary across releases (eg. from Ubuntu 15.04 to Ubuntu 15.10) or even on ocassion at finer granularity.<br>&gt;&gt; <br>&gt;&gt; We will not add explicit handling for this, but one can imagine the enums for different system packagers could be supplemented in a backwards compatible way to provide specific handling as real-world uses emerge, eg:<br>&gt;&gt; <br>&gt;&gt; case Apt(installName: String)<br>&gt;&gt; <br>&gt;&gt; // …could be adapted to:<br>&gt;&gt; <br>&gt;&gt; struct Debian: Linux {}<br>&gt;&gt; struct Ubuntu: Debian {<br>&gt;&gt;     enum Variant {<br>&gt;&gt;         case Gubuntu<br>&gt;&gt;         case Kubuntu(Version)<br>&gt;&gt;     }<br>&gt;&gt;     enum Version {<br>&gt;&gt;         case v1510<br>&gt;&gt;         case v1504<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; case Apt(installName: String, distribution: Linux? = nil)<br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; There will be no impact on existing code as this feature simply improves an existing feature making new code possible.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; A clear alternative is allowing additional flags to be specified in a system-module package’s Package.swift.<br>&gt;&gt; <br>&gt;&gt; However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the system package itself, and in fact almost all packages nowadays provide it in a .pc pkg-config file.<br>&gt;&gt; <br>&gt;&gt; Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#unsolved-problems&gt;Unsolved Problems<br>&gt;&gt; <br>&gt;&gt; Some (usually more legacy) C libraries do not provide .pc files instead they may provide a tool named eg. foo-configthat can be queried for compile and link flags. We do not yet support these tools, and would prefer to take a wait and see approach to determine how important supporting them may be.<br>&gt;&gt; <br>&gt;&gt; Some libraries on OS X do not come with .pc files. Again we&#39;d like to see which libraries are affected before potentially offering a solution here.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#future-directions&gt;Future Directions<br>&gt;&gt; <br>&gt;&gt; The build system could be made more reliable by having the specific packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up.<br>&gt;&gt; <br>&gt;&gt; If this was done pkg-config could become just one option for providing this data, and be used only as a fallback.<br>&gt;&gt; <br>&gt;&gt; We do not wish to provide a flag to automatically install dependencies via the system packager. We feel this opens us up to security implications beyond the scope of this tool.<br>&gt;&gt; <br>&gt;&gt; Instead we can provide JSON output that can be parsed and executed by some other tooling developed outside of Apple.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/6ae28f0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>I don&#39;t see that information in the man page (also, I am not familiar enough with pkg-config to know how results described in that man page translate to other systems).<br></p><p>Specifically, that man page does not seem to document where on disk the .pc files live. How are we going to know that?<br></p><p>For example, one on random VM I have lying about I see .pc files here:<br>--<br>/# find / -name \*.pc | xargs dirname | sort | uniq<br>/usr/lib/pkgconfig<br>/usr/lib/x86_64-linux-gnu/pkgconfig<br>/usr/lib/x86_64-linux-gnu/pkgconfig/mit-krb5<br>/usr/share/pkgconfig<br>--<br>and the pkg-config tool appears to be able to find results from all of those. How would we know those directory names if we don&#39;t have a dependency on the actual tool?<br></p><p> - Daniel<br></p><p>&gt; On Apr 6, 2016, at 10:43 AM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt; There is no spec, but the man page has info on what you asked<br>&gt; <br>&gt; http://linux.die.net/man/1/pkg-config &lt;http://linux.die.net/man/1/pkg-config&gt;<br>&gt; <br>&gt;&gt; Hi Max,<br>&gt;&gt; <br>&gt;&gt; The proposal refers to &quot;the pkg-config specification&quot;, can you add a link to that? In particular, I am curious how SwiftPM will know where to look for those files.<br>&gt;&gt; <br>&gt;&gt;  - Daniel<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 31, 2016, at 4:04 PM, Max Howell via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have updated the proposal with everyone’s feedback:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SwiftPM System Module Search Paths<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-swiftpm-system-module-search-paths.md&gt;<br>&gt;&gt;&gt; Author: Max Howell &lt;https://github.com/mxcl&gt;<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: Anders Bertelrud<br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#introduction&gt;Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is able to import C libraries in the same manner as Swift libraries.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For this to occur the library must be represented by a clang module-map file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current system for using these module-map files with SwiftPM works, but with a number of caveats that must be addressed.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The current implementation of system module packages have a number of problems:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Install locations vary across platforms and modulemap files require absolute paths<br>&gt;&gt;&gt; /usr/lib:/usr/local/lib is not always a sufficient -L search path<br>&gt;&gt;&gt; /usr/include:/usr/local/include is not always a sufficient -I C compiler search path<br>&gt;&gt;&gt; Installing the system library is left up to the end-user to figure out<br>&gt;&gt;&gt; For example to import a module map representing the GTK library, the include search path must be supplemented with -I/usr/include/gtk so that a number of includes in the gtk.h header can be sourced for the complete modular definition of GTK.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example to import a module map representing the GTK library a user must first have a copy of GTK and its headers installed. On Debian based systems the install name for this system package is libgtk-3-0-dev which is not entirely intuitive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, Homebrew and MacPorts on OS X install to prefixes other than /usr. .modulemap files must specify headers with absolute paths. The standard we encourage with modulemaps is for the headers to be specified with an assumed prefix of /usr, but you will not find eg. jpeglib.h at /usr/include/jpeglib.h if it is installed with Homebrew or MacPorts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#proposed-solution&gt;Proposed Solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool so that it can query pkg-config for the missing path and flag arguments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose that SwiftPM gains the ability to use the cross-platform pkg-config tool to identify when the system package is not installed to a /usr and in such a case preprocess the modulemap changing the prefix it uses.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We propose that Package.swift is supplemented with metadata that provides the package-install-name for specific platforms.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#detailed-design&gt;Detailed Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#solving-pathflags-issues&gt;Solving Path/Flags Issues<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some of our problems can be solved by using the cross platform tool: pkg-config.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A C package can provide a pkg-config file (.pc) which describes:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Its install location<br>&gt;&gt;&gt; Supplementary C-flags that should be used when compiling against this library<br>&gt;&gt;&gt; Supplementary C-flags that should be used when linking against this library<br>&gt;&gt;&gt; If SwiftPM used the .pc file that comes with packages, this solves problems 1 through 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of the tickets we currently have open describing issues using Swift-system-module-packages, reading the .pc file would fix all of them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is a convention to name the .pc file after the library link-name, so we can determine which .pc file to ask pkg-configfor by parsing the .modulemap file in the Swift package. However sometimes this is not true, (eg. GTK-3 on Ubuntu), so we will make it possible to specify the .pc file name in Package.swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; pkg-config is not currently a dependency of the Swift toolchain, and thus to avoid depending on it we will schedule work to interpret .pc files without requiring pkg-config to be installed. The file format for .pc files is simple and standard so despite reinventing the wheel, this is a low risk choice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#providing-package-install-names&gt;Providing Package Install Names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Package.swift would be supplemented like so:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let package = Package(<br>&gt;&gt;&gt;     name: &quot;CFoo&quot;,<br>&gt;&gt;&gt;     providers: .Brew(installName: &quot;foo&quot;),<br>&gt;&gt;&gt;                 .Apt(installName: &quot;libfoo-dev&quot;),<br>&gt;&gt;&gt;           .PkgConfig(&quot;foo.pc&quot;),<br>&gt;&gt;&gt; )<br>&gt;&gt;&gt; Thus, in the event of build failure for modules that depend on this package we provide additional help to the user:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; error: failed to build module `bar&#39;<br>&gt;&gt;&gt; note: you may need to install `foo&#39; using your system-packager:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     apt-get install libfoo-dev<br>&gt;&gt;&gt; Since the syntax to provide this information uses an explicit enum we can add code for each enum to detect which system packagers should be recommended. The community will need to write the code for their own platforms. It also means that if a specific packager requires additional parameters, they can be added on a per enum basis.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#install-names-are-not-standard&gt;Install-names are not standard<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; apt is used across multiple distirbutions and the install-names for tools vary. Even for the same distribution install-names may vary across releases (eg. from Ubuntu 15.04 to Ubuntu 15.10) or even on ocassion at finer granularity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We will not add explicit handling for this, but one can imagine the enums for different system packagers could be supplemented in a backwards compatible way to provide specific handling as real-world uses emerge, eg:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; case Apt(installName: String)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // …could be adapted to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Debian: Linux {}<br>&gt;&gt;&gt; struct Ubuntu: Debian {<br>&gt;&gt;&gt;     enum Variant {<br>&gt;&gt;&gt;         case Gubuntu<br>&gt;&gt;&gt;         case Kubuntu(Version)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     enum Version {<br>&gt;&gt;&gt;         case v1510<br>&gt;&gt;&gt;         case v1504<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; case Apt(installName: String, distribution: Linux? = nil)<br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#impact-on-existing-code&gt;Impact on Existing Code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There will be no impact on existing code as this feature simply improves an existing feature making new code possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A clear alternative is allowing additional flags to be specified in a system-module package’s Package.swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However since these paths and flags will vary by platform this would because a large matrix that is quite a maintenance burden. Really this information is recorded already, in the system package itself, and in fact almost all packages nowadays provide it in a .pc pkg-config file.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also we do not want to allow arbitrary flags to be specified in Package.swift, this allows packages too much power to break a large dependency graph with bad compiles. The only entity that understands the whole graph and can manage the build without breakage is SwiftPM, and allowing packages themselves to add arbitrary flags prevents SwiftPM from being able to understand and control the build ensuring reliability and preventing “Dependency Hell”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#unsolved-problems&gt;Unsolved Problems<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some (usually more legacy) C libraries do not provide .pc files instead they may provide a tool named eg. foo-configthat can be queried for compile and link flags. We do not yet support these tools, and would prefer to take a wait and see approach to determine how important supporting them may be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some libraries on OS X do not come with .pc files. Again we&#39;d like to see which libraries are affected before potentially offering a solution here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/mxcl/swift-evolution/blob/system-module-search-paths/proposals/NNNN-swiftpm-system-module-search-paths.md#future-directions&gt;Future Directions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The build system could be made more reliable by having the specific packager provide the information that this proposal garners from pkg-config. For example, Homebrew installs everything into independent directories, using these directories instead of more general POSIX search paths means there is no danger of edge-case search path collisions and the wrong libraries being picked up.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this was done pkg-config could become just one option for providing this data, and be used only as a fallback.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We do not wish to provide a flag to automatically install dependencies via the system packager. We feel this opens us up to security implications beyond the scope of this tool.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instead we can provide JSON output that can be parsed and executed by some other tooling developed outside of Apple.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/6a226d9d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; I don&#39;t see that information in the man page (also, I am not familiar enough with pkg-config to know how results described in that man page translate to other systems).<br>&gt; <br>&gt; Specifically, that man page does not seem to document where on disk the .pc files live. How are we going to know that?<br>&gt; <br>&gt; For example, one on random VM I have lying about I see .pc files here:<br>&gt; --<br>&gt; /# find / -name \*.pc | xargs dirname | sort | uniq<br>&gt; /usr/lib/pkgconfig<br>&gt; /usr/lib/x86_64-linux-gnu/pkgconfig<br>&gt; /usr/lib/x86_64-linux-gnu/pkgconfig/mit-krb5<br>&gt; /usr/share/pkgconfig<br>&gt; --<br>&gt; and the pkg-config tool appears to be able to find results from all of those. How would we know those directory names if we don&#39;t have a dependency on the actual tool?<br></p><p>There is a config file and an environment variable.<br></p><p>Do you need me to document them completely so that we can move forward with this?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/8231ff5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5d9baa679148bd83458d11df12327ce0?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Daniel Dunbar</string> &lt;daniel_dunbar at apple.com&gt;<p>April  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 6, 2016, at 11:11 AM, Max Howell &lt;max.howell at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; I don&#39;t see that information in the man page (also, I am not familiar enough with pkg-config to know how results described in that man page translate to other systems).<br>&gt;&gt; <br>&gt;&gt; Specifically, that man page does not seem to document where on disk the .pc files live. How are we going to know that?<br>&gt;&gt; <br>&gt;&gt; For example, one on random VM I have lying about I see .pc files here:<br>&gt;&gt; --<br>&gt;&gt; /# find / -name \*.pc | xargs dirname | sort | uniq<br>&gt;&gt; /usr/lib/pkgconfig<br>&gt;&gt; /usr/lib/x86_64-linux-gnu/pkgconfig<br>&gt;&gt; /usr/lib/x86_64-linux-gnu/pkgconfig/mit-krb5<br>&gt;&gt; /usr/share/pkgconfig<br>&gt;&gt; --<br>&gt;&gt; and the pkg-config tool appears to be able to find results from all of those. How would we know those directory names if we don&#39;t have a dependency on the actual tool?<br>&gt; <br>&gt; There is a config file and an environment variable.<br>&gt; <br>&gt; Do you need me to document them completely so that we can move forward with this?<br></p><p>No, not at all, I think the proposal makes complete sense and should be moved along.<br></p><p>Nevertheless, I still want to understand how it will work... I might be missing some information from the man page but I just don&#39;t see where this is described. It *looks* to me like the default search list is hard coded into the tool.<br></p><p> - Daniel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160406/cfca1583/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ae51ca494b37cc270597830da66f089f?s=50"></div><header><strong>Draft Proposal SwiftPM System Module Search Paths</strong> from <string>Max Howell</string> &lt;max.howell at apple.com&gt;<p>April  7, 2016 at 09:00:00am</p></header><div class="content"><p>&gt;&gt;&gt; I don&#39;t see that information in the man page (also, I am not familiar enough with pkg-config to know how results described in that man page translate to other systems).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Specifically, that man page does not seem to document where on disk the .pc files live. How are we going to know that?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For example, one on random VM I have lying about I see .pc files here:<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; /# find / -name \*.pc | xargs dirname | sort | uniq<br>&gt;&gt;&gt; /usr/lib/pkgconfig<br>&gt;&gt;&gt; /usr/lib/x86_64-linux-gnu/pkgconfig<br>&gt;&gt;&gt; /usr/lib/x86_64-linux-gnu/pkgconfig/mit-krb5<br>&gt;&gt;&gt; /usr/share/pkgconfig<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; and the pkg-config tool appears to be able to find results from all of those. How would we know those directory names if we don&#39;t have a dependency on the actual tool?<br>&gt;&gt; <br>&gt;&gt; There is a config file and an environment variable.<br>&gt;&gt; <br>&gt;&gt; Do you need me to document them completely so that we can move forward with this?<br>&gt; <br>&gt; No, not at all, I think the proposal makes complete sense and should be moved along.<br>&gt; <br>&gt; Nevertheless, I still want to understand how it will work... I might be missing some information from the man page but I just don&#39;t see where this is described. It *looks* to me like the default search list is hard coded into the tool.<br></p><p>Best docs I have found are: https://people.freedesktop.org/~dbn/pkg-config-guide.html<br></p><p>Essentially:<br></p><p>The std path is /usr/lib/pkg-config and /usr/share/pkg-config, this can be supplemented by an env var PKG_CONFIG_PATH<br></p><p>It is common for system packagers to add more paths. Eg. brew does this, I coded it myself.<br></p><p>This is fine, because the additional paths can only be queried by a custom configured pkg-config, and in such cases we can just ask the custom configured pkg-config, if it’s there, there may be more paths, if it’s not then there cannot.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160407/689d4a49/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
