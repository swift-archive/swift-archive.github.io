<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 23, 2016 at 03:00:00pm</p></header><div class="content"><p>Introduction<br></p><p>Optionals can be used as values of the type Any, but only bridge as opaque objects in Objective-C. We should bridge Optionals with some value by bridging the wrapped value, and bridge nils to the NSNull singleton.<br></p><p>Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#motivation&gt;Motivation<br></p><p>SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the opportunity for optionality mismatches, since an Any can contain a wrapped Optional value just like anything else. Our current behavior, where Optional is given only the default opaque bridging behavior, leads to brittle transitivity problems with collection subtyping. For example, an array of Optional objects bridges to an NSArray of opaque objects, unusable from ObjC:<br></p><p>class C {}<br>let objects: [C?] = [C(), nil, C()]<br>The more idiomatic mapping would be to use NSNull or some other sentinel to represent the missing values (since NSArray cannot directly store nil). Counterintuitively, this is in fact what you get if you bridge an array of Any with nil elements:<br></p><p>class C {}<br>let objects: [Any] = [C(), nil as C?, C()]<br>though with an opaque box taking the place of the standard NSNull sentinel. Since there&#39;s a subtype relationship between T and Optional&lt;T&gt;, it&#39;s also intuitive to expect that the bridging operation be consistent between T and occupied values of Optional&lt;T&gt;.<br></p><p> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#proposed-solution&gt;Proposed solution<br></p><p>When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br></p><p> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#detailed-design&gt;Detailed design<br></p><p>some maps to the bridged value<br>none maps to NSNull<br>if we don&#39;t want to lose information about nested optionals, we&#39;d need a unique SwiftNull object for every optional type, so that .some(.none) maps to NSNull and .none maps to SwiftNull(T?)<br> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from Optional to Any to id to Anyand back by dynamic casting.<br></p><p> &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#alternatives-considered&gt;Alternatives considered<br></p><p>Do nothing<br>Attempt to trap or error when Optionals are used as Anys -- would be good QoI to warn, but it can&#39;t be prevented, and is occasionally desired<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160823/f9692666/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>August 24, 2016 at 01:00:00pm</p></header><div class="content"><p>I have some problems understanding the scope of this proposal. More specifically if it’s limited to arrays and dictionaries or if it’s broader than that, and if it’s limited to objects that originate in Swift or if the same applies for objects that originate in Objective-C code.<br></p><p>For me, it makes sense that Swift arrays of type [C?] and [Any] would bridge to Objective-C as NSArrays bridge nils to NSNull. That feels like the most natural way of representing those missing values in Objective-C. <br></p><p>For dictionaries of type [K:C?] and [K:Any] I feel that bridging Swift nils to NSNull is pretty straight forward and allows for the distinction of a key with no value and a key with an explicit nil value. However, I feel that the same doesn’t work in the other direction. If a NSNull value in an Objective-C NSDictionary would bridge to a nil value it wouldn’t be possible to distinguish between a key without a value and key with a nil value (something one might have to do when checking the KVO change dictionary).  <br></p><p>There are also some APIs that make a distinction between NSNull and nil, for example action(for:forKey:) on CALayerDelegate. Does this proposal have any impact on those APIs?<br></p><p>- David<br></p><p>&gt; On 24 Aug 2016, at 00:36, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Optionals can be used as values of the type Any, but only bridge as opaque objects in Objective-C. We should bridge Optionals with some value by bridging the wrapped value, and bridge nils to the NSNull singleton.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#motivation&gt;Motivation<br>&gt; <br>&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the opportunity for optionality mismatches, since an Any can contain a wrapped Optional value just like anything else. Our current behavior, where Optional is given only the default opaque bridging behavior, leads to brittle transitivity problems with collection subtyping. For example, an array of Optional objects bridges to an NSArray of opaque objects, unusable from ObjC:<br>&gt; <br>&gt; class C {}<br>&gt; let objects: [C?] = [C(), nil, C()]<br>&gt; The more idiomatic mapping would be to use NSNull or some other sentinel to represent the missing values (since NSArray cannot directly store nil). Counterintuitively, this is in fact what you get if you bridge an array of Any with nil elements:<br>&gt; <br>&gt; class C {}<br>&gt; let objects: [Any] = [C(), nil as C?, C()]<br>&gt; though with an opaque box taking the place of the standard NSNull sentinel. Since there&#39;s a subtype relationship between T and Optional&lt;T&gt;, it&#39;s also intuitive to expect that the bridging operation be consistent between T and occupied values of Optional&lt;T&gt;.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; some maps to the bridged value<br>&gt; none maps to NSNull<br>&gt; if we don&#39;t want to lose information about nested optionals, we&#39;d need a unique SwiftNull object for every optional type, so that .some(.none) maps to NSNull and .none maps to SwiftNull(T?)<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from Optional to Any to id to Anyand back by dynamic casting.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Do nothing<br>&gt; Attempt to trap or error when Optionals are used as Anys -- would be good QoI to warn, but it can&#39;t be prevented, and is occasionally desired<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/8f1bc1e6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 4:16 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have some problems understanding the scope of this proposal. More specifically if it’s limited to arrays and dictionaries or if it’s broader than that, and if it’s limited to objects that originate in Swift or if the same applies for objects that originate in Objective-C code.<br></p><p>It’s broader than that. It affects any Optional value that is put into an ‘Any’ and passed to Objective-C. Note, however, that if you have a nullable parameter in Objective-C, e.g.,<br></p><p>	-(void)methodWithObject:(nullable id)object;<br></p><p>Which comes into Swift as<br></p><p>	func method(with object: Any?)<br></p><p>Then ‘nil’ will be passed through as ‘nil’. This only affects the case where you’re passing a Swift optional to a non-optional parameter:<br></p><p>	-(void)methodWithNonNullObject:(nonnull id)object;<br></p><p>	func method(withNonNullObject object: Any)<br></p><p>&gt; <br>&gt; For me, it makes sense that Swift arrays of type [C?] and [Any] would bridge to Objective-C as NSArrays bridge nils to NSNull. That feels like the most natural way of representing those missing values in Objective-C. <br></p><p>Right. The alternative is that nil values bridge to an opaque box type known only to the Swift runtime. NSNull seems strictly better here, because Objective-C code can reason about it.<br></p><p>&gt; For dictionaries of type [K:C?] and [K:Any] I feel that bridging Swift nils to NSNull is pretty straight forward and allows for the distinction of a key with no value and a key with an explicit nil value. However, I feel that the same doesn’t work in the other direction. If a NSNull value in an Objective-C NSDictionary would bridge to a nil value it wouldn’t be possible to distinguish between a key without a value and key with a nil value (something one might have to do when checking the KVO change dictionary).  <br></p><p>NSNulls are handled dynamically. If you wanted to check whether Objective-C put an ‘NSNull’ in there explicitly, you can do so with “as? NSNull”.  If instead you do “as? SomeType?”, the NSNull will become the ‘nil’ value in the SomeType.<br></p><p>&gt; <br>&gt; There are also some APIs that make a distinction between NSNull and nil, for example action(for:forKey:) on CALayerDelegate. Does this proposal have any impact on those APIs?<br></p><p>That method returns “CAAction?”, so ‘nil’ will come through as ‘nil’ and NSNull can be stored in the .some(x).<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; - David<br>&gt; <br>&gt;&gt; On 24 Aug 2016, at 00:36, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; Optionals can be used as values of the type Any, but only bridge as opaque objects in Objective-C. We should bridge Optionals with some value by bridging the wrapped value, and bridge nils to the NSNull singleton.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the opportunity for optionality mismatches, since an Any can contain a wrapped Optional value just like anything else. Our current behavior, where Optional is given only the default opaque bridging behavior, leads to brittle transitivity problems with collection subtyping. For example, an array of Optional objects bridges to an NSArray of opaque objects, unusable from ObjC:<br>&gt;&gt; <br>&gt;&gt; class C {}<br>&gt;&gt; let objects: [C?] = [C(), nil, C()]<br>&gt;&gt; The more idiomatic mapping would be to use NSNull or some other sentinel to represent the missing values (since NSArray cannot directly store nil). Counterintuitively, this is in fact what you get if you bridge an array of Any with nil elements:<br>&gt;&gt; <br>&gt;&gt; class C {}<br>&gt;&gt; let objects: [Any] = [C(), nil as C?, C()]<br>&gt;&gt; though with an opaque box taking the place of the standard NSNull sentinel. Since there&#39;s a subtype relationship between T and Optional&lt;T&gt;, it&#39;s also intuitive to expect that the bridging operation be consistent between T and occupied values of Optional&lt;T&gt;.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; some maps to the bridged value<br>&gt;&gt; none maps to NSNull<br>&gt;&gt; if we don&#39;t want to lose information about nested optionals, we&#39;d need a unique SwiftNull object for every optional type, so that .some(.none) maps to NSNull and .none maps to SwiftNull(T?)<br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from Optional to Any to id to Anyand back by dynamic casting.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Do nothing<br>&gt;&gt; Attempt to trap or error when Optionals are used as Anys -- would be good QoI to warn, but it can&#39;t be prevented, and is occasionally desired<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/140c796f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 04:00:00pm</p></header><div class="content"><p>First of all, I&#39;m really happy with this proposal so far. I really appreciate the work that&#39;s been done to improve Swift and Objective-C interoperability.<br></p><p>Now, question: Does this proposal also improve bridging from Objective-C to Swift or only the other direction? For example, let&#39;s say an `[Any]` contains either `Foo` or `NSNull`. Could this bridge to Swift as `[Foo?]`? I&#39;d like to be able to write<br></p><p>let x = [Foo(), Foo(), nil] as [Foo?] as [Any]<br>let x2 = x as! [Foo?] // Already works<br></p><p>let y = [Foo(), Foo(), NSNull()] as [Any]<br>let y2 = y as! [Foo?] // Should work<br></p><p>and have this succeed. That is, an `[Any]` can be cast to `[T?]` either if it only contains `T` and `NSNull` or if it only contains `T?`, not some combination of both.<br></p><p>&gt; On Aug 24, 2016, at 11:20 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 4:16 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have some problems understanding the scope of this proposal. More specifically if it’s limited to arrays and dictionaries or if it’s broader than that, and if it’s limited to objects that originate in Swift or if the same applies for objects that originate in Objective-C code.<br>&gt; <br>&gt; It’s broader than that. It affects any Optional value that is put into an ‘Any’ and passed to Objective-C. Note, however, that if you have a nullable parameter in Objective-C, e.g.,<br>&gt; <br>&gt; 	-(void)methodWithObject:(nullable id)object;<br>&gt; <br>&gt; Which comes into Swift as<br>&gt; <br>&gt; 	func method(with object: Any?)<br>&gt; <br>&gt; Then ‘nil’ will be passed through as ‘nil’. This only affects the case where you’re passing a Swift optional to a non-optional parameter:<br>&gt; <br>&gt; 	-(void)methodWithNonNullObject:(nonnull id)object;<br>&gt; <br>&gt; 	func method(withNonNullObject object: Any)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; For me, it makes sense that Swift arrays of type [C?] and [Any] would bridge to Objective-C as NSArrays bridge nils to NSNull. That feels like the most natural way of representing those missing values in Objective-C. <br>&gt; <br>&gt; Right. The alternative is that nil values bridge to an opaque box type known only to the Swift runtime. NSNull seems strictly better here, because Objective-C code can reason about it.<br>&gt; <br>&gt;&gt; For dictionaries of type [K:C?] and [K:Any] I feel that bridging Swift nils to NSNull is pretty straight forward and allows for the distinction of a key with no value and a key with an explicit nil value. However, I feel that the same doesn’t work in the other direction. If a NSNull value in an Objective-C NSDictionary would bridge to a nil value it wouldn’t be possible to distinguish between a key without a value and key with a nil value (something one might have to do when checking the KVO change dictionary).  <br>&gt; <br>&gt; NSNulls are handled dynamically. If you wanted to check whether Objective-C put an ‘NSNull’ in there explicitly, you can do so with “as? NSNull”.  If instead you do “as? SomeType?”, the NSNull will become the ‘nil’ value in the SomeType.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; There are also some APIs that make a distinction between NSNull and nil, for example action(for:forKey:) on CALayerDelegate. Does this proposal have any impact on those APIs?<br>&gt; <br>&gt; That method returns “CAAction?”, so ‘nil’ will come through as ‘nil’ and NSNull can be stored in the .some(x).<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - David<br>&gt;&gt; <br>&gt;&gt;&gt; On 24 Aug 2016, at 00:36, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Optionals can be used as values of the type Any, but only bridge as opaque objects in Objective-C. We should bridge Optionals with some value by bridging the wrapped value, and bridge nils to the NSNull singleton.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#motivation&gt;Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the opportunity for optionality mismatches, since an Any can contain a wrapped Optional value just like anything else. Our current behavior, where Optional is given only the default opaque bridging behavior, leads to brittle transitivity problems with collection subtyping. For example, an array of Optional objects bridges to an NSArray of opaque objects, unusable from ObjC:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {}<br>&gt;&gt;&gt; let objects: [C?] = [C(), nil, C()]<br>&gt;&gt;&gt; The more idiomatic mapping would be to use NSNull or some other sentinel to represent the missing values (since NSArray cannot directly store nil). Counterintuitively, this is in fact what you get if you bridge an array of Any with nil elements:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class C {}<br>&gt;&gt;&gt; let objects: [Any] = [C(), nil as C?, C()]<br>&gt;&gt;&gt; though with an opaque box taking the place of the standard NSNull sentinel. Since there&#39;s a subtype relationship between T and Optional&lt;T&gt;, it&#39;s also intuitive to expect that the bridging operation be consistent between T and occupied values of Optional&lt;T&gt;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; some maps to the bridged value<br>&gt;&gt;&gt; none maps to NSNull<br>&gt;&gt;&gt; if we don&#39;t want to lose information about nested optionals, we&#39;d need a unique SwiftNull object for every optional type, so that .some(.none) maps to NSNull and .none maps to SwiftNull(T?)<br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from Optional to Any to id to Anyand back by dynamic casting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do nothing<br>&gt;&gt;&gt; Attempt to trap or error when Optionals are used as Anys -- would be good QoI to warn, but it can&#39;t be prevented, and is occasionally desired<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/a6515077/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;d imagine an implementation something like this (but, in the bridging logic, not as a top level function…):<br></p><p>func dynamicCast&lt;T&gt;(_ array: [Any]) -&gt; [T?] {<br>    var _type: CollectionCastType?<br>    func assertType(_ checkType: CollectionCastType) {<br>        guard let type = _type else {<br>            _type = checkType<br>            return<br>        }<br>        assert(type == checkType)<br>    }<br>    return array.map { element in<br>        switch element {<br>        case let element as T?:<br>            assertType(.normal)<br>            return element<br>        case let element as T:<br>            assertType(.lifting)<br>            return element<br>        case is NSNull:<br>            assertType(.lifting)<br>            return nil<br>        default:<br>            fatalError(&quot;Incorrect types&quot;)<br>        }<br>    }<br>}<br></p><p>Essentially, it either identifies an array as being entirely of `T?` (normal cast type) or being entirely of both `T` and `NSNull` (lifted cast type) and returns the proper value. In the bridging logic, this would be done lazily (like how `NSArray`s bridged to `[T]` lazily check element type on access).<br></p><p>What are your thoughts?<br></p><p>&gt; On Aug 24, 2016, at 4:08 PM, Jaden Geller &lt;jaden.geller at gmail.com&gt; wrote:<br>&gt; <br>&gt; First of all, I&#39;m really happy with this proposal so far. I really appreciate the work that&#39;s been done to improve Swift and Objective-C interoperability.<br>&gt; <br>&gt; Now, question: Does this proposal also improve bridging from Objective-C to Swift or only the other direction? For example, let&#39;s say an `[Any]` contains either `Foo` or `NSNull`. Could this bridge to Swift as `[Foo?]`? I&#39;d like to be able to write<br>&gt; <br>&gt; let x = [Foo(), Foo(), nil] as [Foo?] as [Any]<br>&gt; let x2 = x as! [Foo?] // Already works<br>&gt; <br>&gt; let y = [Foo(), Foo(), NSNull()] as [Any]<br>&gt; let y2 = y as! [Foo?] // Should work<br>&gt; <br>&gt; and have this succeed. That is, an `[Any]` can be cast to `[T?]` either if it only contains `T` and `NSNull` or if it only contains `T?`, not some combination of both.<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 11:20 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 4:16 AM, David Rönnqvist &lt;david.ronnqvist at gmail.com &lt;mailto:david.ronnqvist at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have some problems understanding the scope of this proposal. More specifically if it’s limited to arrays and dictionaries or if it’s broader than that, and if it’s limited to objects that originate in Swift or if the same applies for objects that originate in Objective-C code.<br>&gt;&gt; <br>&gt;&gt; It’s broader than that. It affects any Optional value that is put into an ‘Any’ and passed to Objective-C. Note, however, that if you have a nullable parameter in Objective-C, e.g.,<br>&gt;&gt; <br>&gt;&gt; 	-(void)methodWithObject:(nullable id)object;<br>&gt;&gt; <br>&gt;&gt; Which comes into Swift as<br>&gt;&gt; <br>&gt;&gt; 	func method(with object: Any?)<br>&gt;&gt; <br>&gt;&gt; Then ‘nil’ will be passed through as ‘nil’. This only affects the case where you’re passing a Swift optional to a non-optional parameter:<br>&gt;&gt; <br>&gt;&gt; 	-(void)methodWithNonNullObject:(nonnull id)object;<br>&gt;&gt; <br>&gt;&gt; 	func method(withNonNullObject object: Any)<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For me, it makes sense that Swift arrays of type [C?] and [Any] would bridge to Objective-C as NSArrays bridge nils to NSNull. That feels like the most natural way of representing those missing values in Objective-C. <br>&gt;&gt; <br>&gt;&gt; Right. The alternative is that nil values bridge to an opaque box type known only to the Swift runtime. NSNull seems strictly better here, because Objective-C code can reason about it.<br>&gt;&gt; <br>&gt;&gt;&gt; For dictionaries of type [K:C?] and [K:Any] I feel that bridging Swift nils to NSNull is pretty straight forward and allows for the distinction of a key with no value and a key with an explicit nil value. However, I feel that the same doesn’t work in the other direction. If a NSNull value in an Objective-C NSDictionary would bridge to a nil value it wouldn’t be possible to distinguish between a key without a value and key with a nil value (something one might have to do when checking the KVO change dictionary).  <br>&gt;&gt; <br>&gt;&gt; NSNulls are handled dynamically. If you wanted to check whether Objective-C put an ‘NSNull’ in there explicitly, you can do so with “as? NSNull”.  If instead you do “as? SomeType?”, the NSNull will become the ‘nil’ value in the SomeType.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are also some APIs that make a distinction between NSNull and nil, for example action(for:forKey:) on CALayerDelegate. Does this proposal have any impact on those APIs?<br>&gt;&gt; <br>&gt;&gt; That method returns “CAAction?”, so ‘nil’ will come through as ‘nil’ and NSNull can be stored in the .some(x).<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 24 Aug 2016, at 00:36, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Optionals can be used as values of the type Any, but only bridge as opaque objects in Objective-C. We should bridge Optionals with some value by bridging the wrapped value, and bridge nils to the NSNull singleton.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the opportunity for optionality mismatches, since an Any can contain a wrapped Optional value just like anything else. Our current behavior, where Optional is given only the default opaque bridging behavior, leads to brittle transitivity problems with collection subtyping. For example, an array of Optional objects bridges to an NSArray of opaque objects, unusable from ObjC:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C {}<br>&gt;&gt;&gt;&gt; let objects: [C?] = [C(), nil, C()]<br>&gt;&gt;&gt;&gt; The more idiomatic mapping would be to use NSNull or some other sentinel to represent the missing values (since NSArray cannot directly store nil). Counterintuitively, this is in fact what you get if you bridge an array of Any with nil elements:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class C {}<br>&gt;&gt;&gt;&gt; let objects: [Any] = [C(), nil as C?, C()]<br>&gt;&gt;&gt;&gt; though with an opaque box taking the place of the standard NSNull sentinel. Since there&#39;s a subtype relationship between T and Optional&lt;T&gt;, it&#39;s also intuitive to expect that the bridging operation be consistent between T and occupied values of Optional&lt;T&gt;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#proposed-solution&gt;Proposed solution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#detailed-design&gt;Detailed design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; some maps to the bridged value<br>&gt;&gt;&gt;&gt; none maps to NSNull<br>&gt;&gt;&gt;&gt; if we don&#39;t want to lose information about nested optionals, we&#39;d need a unique SwiftNull object for every optional type, so that .some(.none) maps to NSNull and .none maps to SwiftNull(T?)<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from Optional to Any to id to Anyand back by dynamic casting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do nothing<br>&gt;&gt;&gt;&gt; Attempt to trap or error when Optionals are used as Anys -- would be good QoI to warn, but it can&#39;t be prevented, and is occasionally desired<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/c0fe2739/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>August 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt; <br>I don&#39;t think I like this.<br></p><p>Let me verify my understanding. If I have this:<br></p><p>    // imported from ObjC<br>    func f(with object: Any)<br>    <br>    let s: String? = nil<br>    f(s)<br></p><p>then at runtime it will call <br>    f([NSNull null])<br>?<br></p><p>The problem is that NSNull is in fact rare in Cocoa. They are used in the Foundation containers and almost nowhere else. Passing NSNull into almost any API is going to do something confusing at runtime. If you&#39;re lucky you get a prompt error &quot;-[NSNull something]: unrecognized selector&quot;. If you&#39;re not lucky you&#39;ll get that error somewhere much later, or something even less obviously related to NSNull and your call site. That sounds like the wrong outcome for developers who are confused or careless or unaware of an optional.<br></p><p><br>-- <br>Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/25ba3223/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 8:27 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt; <br>&gt; I don&#39;t think I like this.<br>&gt; <br>&gt; Let me verify my understanding. If I have this:<br>&gt; <br>&gt;     // imported from ObjC<br>&gt;     func f(with object: Any)<br>&gt;     <br>&gt;     let s: String? = nil<br>&gt;     f(s)<br>&gt; <br>&gt; then at runtime it will call <br>&gt;     f([NSNull null])<br>&gt; ?<br>&gt; <br>&gt; The problem is that NSNull is in fact rare in Cocoa. They are used in the Foundation containers and almost nowhere else. Passing NSNull into almost any API is going to do something confusing at runtime. If you&#39;re lucky you get a prompt error &quot;-[NSNull something]: unrecognized selector&quot;. If you&#39;re not lucky you&#39;ll get that error somewhere much later, or something even less obviously related to NSNull and your call site. That sounds like the wrong outcome for developers who are confused or careless or unaware of an optional.<br></p><p>I agree, particularly since passing an array of optionals to an Objective-C API is much more likely to be the result of a typo or other programmer error than something actually intentional that ought to invoke the bridge.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/c3c6cc51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e95942f1fe843f007ef5430b9acff78b?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Jaden Geller</string> &lt;jaden.geller at gmail.com&gt;<p>August 24, 2016 at 08:00:00pm</p></header><div class="content"><p>Why is exposing an Optional as an opaque box less error prone than an NSNull? That doesn&#39;t seem obviously true to me.<br></p><p>&gt; On Aug 24, 2016, at 8:00 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Aug 24, 2016, at 8:27 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt;&gt; <br>&gt;&gt; I don&#39;t think I like this.<br>&gt;&gt; <br>&gt;&gt; Let me verify my understanding. If I have this:<br>&gt;&gt; <br>&gt;&gt;     // imported from ObjC<br>&gt;&gt;     func f(with object: Any)<br>&gt;&gt;     <br>&gt;&gt;     let s: String? = nil<br>&gt;&gt;     f(s)<br>&gt;&gt; <br>&gt;&gt; then at runtime it will call <br>&gt;&gt;     f([NSNull null])<br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; The problem is that NSNull is in fact rare in Cocoa. They are used in the Foundation containers and almost nowhere else. Passing NSNull into almost any API is going to do something confusing at runtime. If you&#39;re lucky you get a prompt error &quot;-[NSNull something]: unrecognized selector&quot;. If you&#39;re not lucky you&#39;ll get that error somewhere much later, or something even less obviously related to NSNull and your call site. That sounds like the wrong outcome for developers who are confused or careless or unaware of an optional.<br>&gt; <br>&gt; I agree, particularly since passing an array of optionals to an Objective-C API is much more likely to be the result of a typo or other programmer error than something actually intentional that ought to invoke the bridge.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160824/f43f0b69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August 24, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 10:40 PM, jaden.geller at gmail.com wrote:<br></p><p>&gt; <br>&gt; Why is exposing an Optional as an opaque box less error prone than an NSNull? That doesn&#39;t seem obviously true to me.<br></p><p>Firstly, to answer your question: It is less error-prone because the error is more obvious. If an Objective-C API is passed an array of optionals, resulting in a bunch of completely useless opaque objects, whatever was intended in sending that array will likely fail completely in a way that will almost certainly be discovered and fixed before the product ships. If we implement this proposal, however, it is probable that arrays of optionals will be sent to Objective-C APIs accidentally, and this error can slip past testing if it turns out that all of the elements in the array are usually all .Some, with nil only appearing in unusual edge cases. This can lead to NSNull showing up in contexts where it was not expected at all, leading to crashes in shipping code that would appear very mysterious and difficult to debug. NSNull seems to me to be the sort of thing that should only ever put in as a deliberate and conscious choice on the part of the developer.<br></p><p>Secondly, even if you disregard all of the above, the burden of proof in these matters should be on the side proposing the change, and it does not seem evident to me that NSNull would be less error-prone than the optional box.<br></p><p>Charles<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>August 25, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 5:00 AM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Aug 24, 2016, at 8:27 PM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt;&gt; <br>&gt;&gt; I don&#39;t think I like this.<br>&gt;&gt; <br>&gt;&gt; Let me verify my understanding. If I have this:<br>&gt;&gt; <br>&gt;&gt;     // imported from ObjC<br>&gt;&gt;     func f(with object: Any)<br>&gt;&gt;     <br>&gt;&gt;     let s: String? = nil<br>&gt;&gt;     f(s)<br>&gt;&gt; <br>&gt;&gt; then at runtime it will call <br>&gt;&gt;     f([NSNull null])<br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; The problem is that NSNull is in fact rare in Cocoa. They are used in the Foundation containers and almost nowhere else. Passing NSNull into almost any API is going to do something confusing at runtime. If you&#39;re lucky you get a prompt error &quot;-[NSNull something]: unrecognized selector&quot;. If you&#39;re not lucky you&#39;ll get that error somewhere much later, or something even less obviously related to NSNull and your call site. That sounds like the wrong outcome for developers who are confused or careless or unaware of an optional.<br>&gt; <br>&gt; I agree, particularly since passing an array of optionals to an Objective-C API is much more likely to be the result of a typo or other programmer error than something actually intentional that ought to invoke the bridge.<br></p><p>Agreed. I was going back and forth on this proposal and I think there still is a lot of unaudited API (untyped NSArray/NSDictionary) out there that simply expects some type of values and this is very error-prone to passing in NSNull, which personally was the worst nightmare for me when dealing with JSONs in ObjC - that I pass NSNull instead of NSString somewhere; since this is an issue that can - as Charles mentioned - reveal itself much much later and is then hard to debug - in such cases, I&#39;d strongly prefer the app crashing at call site.<br></p><p>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/129c08a4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1fa91245461a93e6c0b423cd19fc73b0?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Omer Iqbal</string> &lt;momeriqbal2 at gmail.com&gt;<p>August 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; The problem is that NSNull is in fact rare in Cocoa.<br></p><p>I couldn&#39;t agree more. I think this proposal is quite dangerous for (often<br>legacy) Objective C codebases where checking for NSNull is not common<br>practice. Since Optionals are not a construct in Objective C, I don&#39;t see<br>any reason for why Objective C Collection types would be populated with<br>Optionals unless it&#39;s unintentional.<br></p><p>I&#39;m not sure whether it&#39;s possible, but an ideal solution would be if the<br>Swift Compiler can give a type error when passing an Optional to an<br>Objective C Collection type.<br></p><p>On Thu, Aug 25, 2016 at 9:27 AM, Greg Parker via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposed solution<br>&gt;<br>&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it<br>&gt; contains some value, that value should be bridged; otherwise, NSNull or<br>&gt; another sentinel object should be used.<br>&gt;<br>&gt; I don&#39;t think I like this.<br>&gt;<br>&gt; Let me verify my understanding. If I have this:<br>&gt;<br>&gt;     // imported from ObjC<br>&gt;     func f(with object: Any)<br>&gt;<br>&gt;     let s: String? = nil<br>&gt;     f(s)<br>&gt;<br>&gt; then at runtime it will call<br>&gt;     f([NSNull null])<br>&gt; ?<br>&gt;<br>&gt; The problem is that NSNull is in fact rare in Cocoa. They are used in the<br>&gt; Foundation containers and almost nowhere else. Passing NSNull into almost<br>&gt; any API is going to do something confusing at runtime. If you&#39;re lucky you<br>&gt; get a prompt error &quot;-[NSNull something]: unrecognized selector&quot;. If you&#39;re<br>&gt; not lucky you&#39;ll get that error somewhere much later, or something even<br>&gt; less obviously related to NSNull and your call site. That sounds like the<br>&gt; wrong outcome for developers who are confused or careless or unaware of an<br>&gt; optional.<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/87d5f215/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 24, 2016, at 6:27 PM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 23, 2016, at 3:36 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt;&gt; <br>&gt; I don&#39;t think I like this.<br>&gt; <br>&gt; Let me verify my understanding. If I have this:<br>&gt; <br>&gt;     // imported from ObjC<br>&gt;     func f(with object: Any)<br>&gt;     <br>&gt;     let s: String? = nil<br>&gt;     f(s)<br>&gt; <br>&gt; then at runtime it will call <br>&gt;     f([NSNull null])<br>&gt; ?<br>&gt; <br>&gt; The problem is that NSNull is in fact rare in Cocoa. They are used in the Foundation containers and almost nowhere else. Passing NSNull into almost any API is going to do something confusing at runtime. If you&#39;re lucky you get a prompt error &quot;-[NSNull something]: unrecognized selector&quot;. If you&#39;re not lucky you&#39;ll get that error somewhere much later, or something even less obviously related to NSNull and your call site. That sounds like the wrong outcome for developers who are confused or careless or unaware of an optional.<br></p><p>I think there’s some confusion about what’s already in place due to SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; vs. what’s being proposed here. Specifically, your example:<br></p><p>&gt;     // imported from ObjC<br>&gt;     func f(with object: Any)<br>&gt;     <br>&gt;     let s: String? = nil<br>&gt;     f(with:s)<br></p><p><br>Is accepted as part of SE-0116, because any Swift type can be placed in an Any, and anything can be bridged to Objective-C. Nearly all of the concerns in this thread are about this aspect of the already-accepted-and-implemented SE-0116: that an optional can get passed through to an Objective-C ‘id’ without being explicitly unwrapped. That behavior exists, and the type of the object seen in Objective-C is an opaque Swift wrapper type. I’d thought we were going to get some warnings when putting an optional into an Any that would end up going into Objective-C, but I don’t see the warning: maybe Joe can weigh in as to why we didn’t do that. <br></p><p>*This* proposal is to make the object seen from Objective-C [NSNull null], so at least it’s predictable/detectable on the Objective-C side.<br></p><p>Now, for the related example:<br></p><p>	let s2: String? = “hello”<br>	f(with: s2)<br></p><p>Objective-C will see an NSString (well, Swift’s private subclass of NSString), rather than an opaque Swift wrapper type.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160825/14948e68/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>August 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 25, 2016, at 9:34 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br></p><p>&gt; I’d thought we were going to get some warnings when putting an optional into an Any that would end up going into Objective-C, but I don’t see the warning: maybe Joe can weigh in as to why we didn’t do that.<br></p><p>Warning on Optional-to-Any conversion was on the todo list, but time constraints meant we didn&#39;t get around to it yet.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal draft] Bridge Optional As Its Payload Or NSNull</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>August 26, 2016 at 08:00:00am</p></header><div class="content"><p>For what it’s worth, I’m very much behind this proposal. +1<br></p><p>&gt; On 24 Aug 2016, at 00:36, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction<br>&gt; <br>&gt; Optionals can be used as values of the type Any, but only bridge as opaque objects in Objective-C. We should bridge Optionals with some value by bridging the wrapped value, and bridge nils to the NSNull singleton.<br>&gt; <br>&gt; Swift-evolution thread: TBD &lt;https://lists.swift.org/pipermail/swift-evolution/&gt;<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#motivation&gt;Motivation<br>&gt; <br>&gt; SE-0116 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0116-id-as-any.md&gt; changed how Objective-C&#39;s id and untyped collections import into Swift to use the Any type. This makes it much more natural to pass in Swift value types such as String and Array, but introduces the opportunity for optionality mismatches, since an Any can contain a wrapped Optional value just like anything else. Our current behavior, where Optional is given only the default opaque bridging behavior, leads to brittle transitivity problems with collection subtyping. For example, an array of Optional objects bridges to an NSArray of opaque objects, unusable from ObjC:<br>&gt; <br>&gt; class C {}<br>&gt; let objects: [C?] = [C(), nil, C()]<br>&gt; The more idiomatic mapping would be to use NSNull or some other sentinel to represent the missing values (since NSArray cannot directly store nil). Counterintuitively, this is in fact what you get if you bridge an array of Any with nil elements:<br>&gt; <br>&gt; class C {}<br>&gt; let objects: [Any] = [C(), nil as C?, C()]<br>&gt; though with an opaque box taking the place of the standard NSNull sentinel. Since there&#39;s a subtype relationship between T and Optional&lt;T&gt;, it&#39;s also intuitive to expect that the bridging operation be consistent between T and occupied values of Optional&lt;T&gt;.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt; When an Optional&lt;T&gt; value is bridged to an Objective-C object, if it contains some value, that value should be bridged; otherwise, NSNull or another sentinel object should be used.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; some maps to the bridged value<br>&gt; none maps to NSNull<br>&gt; if we don&#39;t want to lose information about nested optionals, we&#39;d need a unique SwiftNull object for every optional type, so that .some(.none) maps to NSNull and .none maps to SwiftNull(T?)<br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; This change has no static source impact, but changes the dynamic behavior of the Objective-C bridge. From Objective-C&#39;s perspective, Optionals that used to bridge as opaque objects will now come in as semantically meaningful Objective-C objects. This should be a safe change, since existing code should not be relying on the behavior of opaque bridged objects. From Swift&#39;s perspective, values should still be able to round-trip from Optional to Any to id to Anyand back by dynamic casting.<br>&gt; <br>&gt;  &lt;https://github.com/jckarter/swift-evolution/blob/be49e08f56450ffea394306198bcd25f58915e30/proposals/XXXX-bridge-optional-to-nsnull.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; Do nothing<br>&gt; Attempt to trap or error when Optionals are used as Anys -- would be good QoI to warn, but it can&#39;t be prevented, and is occasionally desired<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160826/256e752a/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
