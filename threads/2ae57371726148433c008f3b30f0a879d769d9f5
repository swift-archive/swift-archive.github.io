<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  3, 2016 at 09:00:00am</p></header><div class="content"><p>This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum<br>proposal.<br></p><p>## Introduction<br></p><p>This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>members are strict subsets of explicitly defined enums.<br></p><p>Swift-evolution thread: [Discussion thread topic for that proposal](<br>http://news.gmane.org/gmane.comp.lang.swift.evolution)<br></p><p>## Motivation<br>Consider a situation where we have an enum `Colors` which represents the<br>entire set of colors relevant to your application with many salient methods<br>and operations. We have also declared an enum `LCDColorModel` with only<br>three colors, `red, blue, green` .<br></p><p>``` swift<br>enum Colors {<br>case red, orange, yellow, green, blue, indigo, violet<br>…<br>}<br></p><p>enum LCDColors {<br>case red, green, blue<br>}<br>```<br></p><p>The cases in `LCDColors` in our scenario do not require different behavior<br>from their similarly named cases in `Colors`. We would like, simply stated,<br>to explicitly restrict the cases allowed within a specific portion of our<br>software. There are, currently, a few approaches<br>1. Duplicate functionality in `LCDColors`<br>- Completely manually<br>- Protocols with &#39;minimal&#39; manual duplication<br>2. Avoid duplication by allowing conversion to `Colors`.<br></p><p>Neither of these solutions make the subset relationship between `Colors`<br>and `LCDColors`  clear or strict.<br></p><p>## Proposed solution<br></p><p>Add syntax to describe a restricted set of cases from an enum.<br></p><p>```swift<br>typealias LCDColors = Colors.(red|green|blue)<br>```<br></p><p>`LCDColors ` has all of the type and instance methods of `Colors`. Cases<br>must appear in the same order as their original declaration.<br></p><p><br>## Detailed design<br></p><p>While I am unsure of the entirety of the design, I propose that name<br>mangling be used which, along with the declaration order restriction should<br>mean that all possible subsets have a stable and predictable name which<br>contains all of the information necessary to infer cases.<br></p><p>## Impact on existing code<br></p><p>This is an additive change which should have no breaking change to existing<br>code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/2ae5d9f5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  3, 2016 at 10:00:00am</p></header><div class="content"><p>This could be useful in categorizing and grouping within large enums ErrorType enums come to mind. Would there be any problem with making the subset more explicit? e.g.<br></p><p><br></p><p>``` swift<br>enum Colors {<br>	case red, orange, yellow, green, blue, indigo, violet<br>	…<br>}<br></p><p>extension Colors {<br>	subset  LCDColors  red, green, blue<br>}<br>```<br></p><p>&gt; On Jun 3, 2016, at 7:22 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum proposal.<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose members are strict subsets of explicitly defined enums.<br>&gt; <br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; Consider a situation where we have an enum `Colors` which represents the entire set of colors relevant to your application with many salient methods and operations. We have also declared an enum `LCDColorModel` with only three colors, `red, blue, green` .<br>&gt; <br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; enum LCDColors {<br>&gt; 	case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The cases in `LCDColors` in our scenario do not require different behavior from their similarly named cases in `Colors`. We would like, simply stated, to explicitly restrict the cases allowed within a specific portion of our software. There are, currently, a few approaches <br>&gt; 	1. Duplicate functionality in `LCDColors` <br>&gt; 		- Completely manually<br>&gt; 		- Protocols with &#39;minimal&#39; manual duplication<br>&gt; 	2. Avoid duplication by allowing conversion to `Colors`. <br>&gt; <br>&gt; Neither of these solutions make the subset relationship between `Colors` and `LCDColors`  clear or strict.<br></p><p>&gt; ## Proposed solution<br>&gt; <br>&gt; Add syntax to describe a restricted set of cases from an enum. <br>&gt; <br>&gt; ```swift<br>&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt; ```<br>&gt; <br>&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases must appear in the same order as their original declaration. <br>&gt; <br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; While I am unsure of the entirety of the design, I propose that name mangling be used which, along with the declaration order restriction should mean that all possible subsets have a stable and predictable name which contains all of the information necessary to infer cases. <br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This is an additive change which should have no breaking change to existing code.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/778233a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  3, 2016 at 12:00:00pm</p></header><div class="content"><p>I don&#39;t have a problem with something as explicit as that. I was mostly<br>avoiding adding keywords with my proposed syntax. I have basically no tie<br>to the proposed syntax.<br></p><p>TJ<br></p><p>On Fri, Jun 3, 2016 at 12:32 PM, Christopher Kornher &lt;ckornher at me.com&gt;<br>wrote:<br></p><p>&gt; This could be useful in categorizing and grouping within large enums<br>&gt; ErrorType enums come to mind. Would there be any problem with making the<br>&gt; subset more explicit? e.g.<br>&gt;<br>&gt;<br>&gt;<br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt; …<br>&gt; }<br>&gt;<br>&gt; extension Colors {<br>&gt; subset  LCDColors  red, green, blue<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; On Jun 3, 2016, at 7:22 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum<br>&gt; proposal.<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>&gt; members are strict subsets of explicitly defined enums.<br>&gt;<br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal](<br>&gt; http://news.gmane.org/gmane.comp.lang.swift.evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt; Consider a situation where we have an enum `Colors` which represents the<br>&gt; entire set of colors relevant to your application with many salient methods<br>&gt; and operations. We have also declared an enum `LCDColorModel` with only<br>&gt; three colors, `red, blue, green` .<br>&gt;<br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt; …<br>&gt; }<br>&gt;<br>&gt; enum LCDColors {<br>&gt; case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The cases in `LCDColors` in our scenario do not require different behavior<br>&gt; from their similarly named cases in `Colors`. We would like, simply stated,<br>&gt; to explicitly restrict the cases allowed within a specific portion of our<br>&gt; software. There are, currently, a few approaches<br>&gt; 1. Duplicate functionality in `LCDColors`<br>&gt; - Completely manually<br>&gt; - Protocols with &#39;minimal&#39; manual duplication<br>&gt; 2. Avoid duplication by allowing conversion to `Colors`.<br>&gt;<br>&gt; Neither of these solutions make the subset relationship between `Colors`<br>&gt; and `LCDColors`  clear or strict.<br>&gt;<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; Add syntax to describe a restricted set of cases from an enum.<br>&gt;<br>&gt; ```swift<br>&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt; ```<br>&gt;<br>&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases<br>&gt; must appear in the same order as their original declaration.<br>&gt;<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; While I am unsure of the entirety of the design, I propose that name<br>&gt; mangling be used which, along with the declaration order restriction should<br>&gt; mean that all possible subsets have a stable and predictable name which<br>&gt; contains all of the information necessary to infer cases.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; This is an additive change which should have no breaking change to<br>&gt; existing code.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/4be7c23d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Your original syntax makes  LCDColors clearly a type. The typealias obscures the fact that a new type is being created. An alternative might be something like:<br></p><p>```<br>enum LCDColors : Colors {<br>	case red, green, blue<br>}<br>```<br></p><p>or perhaps<br></p><p>```<br>enum LCDColors subset: Colors {<br>	case red, green, blue<br>}<br>```<br></p><p>This would would be compatible with something that I have been hoping for, creating superset enums from multiple enums for things like errors:<br></p><p>```<br>enum AppErrors  {<br>	// Defined by its subsets<br>}<br></p><p>enum NetworkingErrors  subset: AppErrors {<br>	case NWError1 = 1000, NWError2. NWError3<br>}<br></p><p> <br>enum UserInputErrors  subset: AppErrors {<br>	case UIError1 = 2000, UIError2. UIError3<br>}<br> ```<br>The compiler would have to check for rawValue collisions.<br></p><p>having the superset enum define values that could be used in children would allow:<br></p><p> ```<br>enum AppErrors  {<br>	// Defined by its subsets<br>	case NetworkingErrorBase = 1000<br>	case UIErrorBase = 2000<br>}<br></p><p>enum NetworkingErrors  subset: AppErrors {<br>	case NWError1 = NetworkingErrorBase, NWError2. NWError3<br>}<br></p><p>enum UserInputErrors  subset: AppErrors {<br>	case UIError1 = UIErrorBase, UIError2. UIError3<br>}<br> ```<br></p><p>&gt; On Jun 3, 2016, at 10:39 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don&#39;t have a problem with something as explicit as that. I was mostly avoiding adding keywords with my proposed syntax. I have basically no tie to the proposed syntax.<br>&gt; <br>&gt; TJ<br>&gt; <br>&gt; On Fri, Jun 3, 2016 at 12:32 PM, Christopher Kornher &lt;ckornher at me.com &lt;mailto:ckornher at me.com&gt;&gt; wrote:<br>&gt; This could be useful in categorizing and grouping within large enums ErrorType enums come to mind. Would there be any problem with making the subset more explicit? e.g.<br>&gt; <br>&gt; <br>&gt; <br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; extension Colors {<br>&gt; 	subset  LCDColors  red, green, blue<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 7:22 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum proposal.<br>&gt;&gt; <br>&gt;&gt; ## Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose members are strict subsets of explicitly defined enums.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt;&gt; <br>&gt;&gt; ## Motivation<br>&gt;&gt; Consider a situation where we have an enum `Colors` which represents the entire set of colors relevant to your application with many salient methods and operations. We have also declared an enum `LCDColorModel` with only three colors, `red, blue, green` .<br>&gt;&gt; <br>&gt;&gt; ``` swift<br>&gt;&gt; enum Colors {<br>&gt;&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt; 	…<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum LCDColors {<br>&gt;&gt; 	case red, green, blue<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; The cases in `LCDColors` in our scenario do not require different behavior from their similarly named cases in `Colors`. We would like, simply stated, to explicitly restrict the cases allowed within a specific portion of our software. There are, currently, a few approaches <br>&gt;&gt; 	1. Duplicate functionality in `LCDColors` <br>&gt;&gt; 		- Completely manually<br>&gt;&gt; 		- Protocols with &#39;minimal&#39; manual duplication<br>&gt;&gt; 	2. Avoid duplication by allowing conversion to `Colors`. <br>&gt;&gt; <br>&gt;&gt; Neither of these solutions make the subset relationship between `Colors` and `LCDColors`  clear or strict.<br>&gt; <br>&gt;&gt; ## Proposed solution<br>&gt;&gt; <br>&gt;&gt; Add syntax to describe a restricted set of cases from an enum. <br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases must appear in the same order as their original declaration. <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ## Detailed design<br>&gt;&gt; <br>&gt;&gt; While I am unsure of the entirety of the design, I propose that name mangling be used which, along with the declaration order restriction should mean that all possible subsets have a stable and predictable name which contains all of the information necessary to infer cases. <br>&gt;&gt; <br>&gt;&gt; ## Impact on existing code<br>&gt;&gt; <br>&gt;&gt; This is an additive change which should have no breaking change to existing code.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/e56ba7cb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  3, 2016 at 04:00:00pm</p></header><div class="content"><p>My only hesitation with using `enum LCDColors : Colors` is that that syntax<br>usually signals extending a type and I am not sure whether I am advocating<br>for the ability to add something to `LCDColors` without adding it to<br>`Colors`. I envisioned it as &#39;simply a subset of cases&#39; but that is<br>probably just limited vision on my part.<br></p><p>Using the subtype syntax works for the most part, so I could certainly live<br>with it.<br></p><p>On Fri, Jun 3, 2016 at 3:56 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br></p><p>&gt; Your original syntax makes  LCDColors clearly a type. The typealias<br>&gt; obscures the fact that a new type is being created. An alternative might be<br>&gt; something like:<br>&gt;<br>&gt; ```<br>&gt; enum LCDColors : Colors {<br>&gt; case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; or perhaps<br>&gt;<br>&gt; ```<br>&gt; enum LCDColors subset: Colors {<br>&gt; case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; This would would be compatible with something that I have been hoping for,<br>&gt; creating superset enums from multiple enums for things like errors:<br>&gt;<br>&gt; ```<br>&gt; enum AppErrors  {<br>&gt; // Defined by its subsets<br>&gt; }<br>&gt;<br>&gt; enum NetworkingErrors  subset: AppErrors {<br>&gt; case NWError1 = 1000, NWError2. NWError3<br>&gt; }<br>&gt;<br>&gt;<br>&gt; enum UserInputErrors  subset: AppErrors {<br>&gt; case UIError1 = 2000, UIError2. UIError3<br>&gt; }<br>&gt;  ```<br>&gt;<br>&gt; The compiler would have to check for rawValue collisions.<br>&gt;<br>&gt; having the superset enum define values that could be used in children<br>&gt; would allow:<br>&gt;<br>&gt;<br>&gt;  ```<br>&gt; enum AppErrors  {<br>&gt; // Defined by its subsets<br>&gt; case NetworkingErrorBase = 1000<br>&gt; case UIErrorBase = 2000<br>&gt; }<br>&gt;<br>&gt; enum NetworkingErrors  subset: AppErrors {<br>&gt; case NWError1 = NetworkingErrorBase, NWError2. NWError3<br>&gt; }<br>&gt;<br>&gt; enum UserInputErrors  subset: AppErrors {<br>&gt; case UIError1 = UIErrorBase, UIError2. UIError3<br>&gt; }<br>&gt;  ```<br>&gt;<br>&gt;<br>&gt; On Jun 3, 2016, at 10:39 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I don&#39;t have a problem with something as explicit as that. I was mostly<br>&gt; avoiding adding keywords with my proposed syntax. I have basically no tie<br>&gt; to the proposed syntax.<br>&gt;<br>&gt; TJ<br>&gt;<br>&gt; On Fri, Jun 3, 2016 at 12:32 PM, Christopher Kornher &lt;ckornher at me.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; This could be useful in categorizing and grouping within large enums<br>&gt;&gt; ErrorType enums come to mind. Would there be any problem with making the<br>&gt;&gt; subset more explicit? e.g.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ``` swift<br>&gt;&gt; enum Colors {<br>&gt;&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; extension Colors {<br>&gt;&gt; subset  LCDColors  red, green, blue<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; On Jun 3, 2016, at 7:22 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc<br>&gt;&gt; enum proposal.<br>&gt;&gt;<br>&gt;&gt; ## Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>&gt;&gt; members are strict subsets of explicitly defined enums.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](<br>&gt;&gt; http://news.gmane.org/gmane.comp.lang.swift.evolution)<br>&gt;&gt;<br>&gt;&gt; ## Motivation<br>&gt;&gt; Consider a situation where we have an enum `Colors` which represents the<br>&gt;&gt; entire set of colors relevant to your application with many salient methods<br>&gt;&gt; and operations. We have also declared an enum `LCDColorModel` with only<br>&gt;&gt; three colors, `red, blue, green` .<br>&gt;&gt;<br>&gt;&gt; ``` swift<br>&gt;&gt; enum Colors {<br>&gt;&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; enum LCDColors {<br>&gt;&gt; case red, green, blue<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; The cases in `LCDColors` in our scenario do not require different<br>&gt;&gt; behavior from their similarly named cases in `Colors`. We would like,<br>&gt;&gt; simply stated, to explicitly restrict the cases allowed within a specific<br>&gt;&gt; portion of our software. There are, currently, a few approaches<br>&gt;&gt; 1. Duplicate functionality in `LCDColors`<br>&gt;&gt; - Completely manually<br>&gt;&gt; - Protocols with &#39;minimal&#39; manual duplication<br>&gt;&gt; 2. Avoid duplication by allowing conversion to `Colors`.<br>&gt;&gt;<br>&gt;&gt; Neither of these solutions make the subset relationship between `Colors`<br>&gt;&gt; and `LCDColors`  clear or strict.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ## Proposed solution<br>&gt;&gt;<br>&gt;&gt; Add syntax to describe a restricted set of cases from an enum.<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases<br>&gt;&gt; must appear in the same order as their original declaration.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ## Detailed design<br>&gt;&gt;<br>&gt;&gt; While I am unsure of the entirety of the design, I propose that name<br>&gt;&gt; mangling be used which, along with the declaration order restriction should<br>&gt;&gt; mean that all possible subsets have a stable and predictable name which<br>&gt;&gt; contains all of the information necessary to infer cases.<br>&gt;&gt;<br>&gt;&gt; ## Impact on existing code<br>&gt;&gt;<br>&gt;&gt; This is an additive change which should have no breaking change to<br>&gt;&gt; existing code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/37460a72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June  3, 2016 at 03:00:00pm</p></header><div class="content"><p>The syntax I described here has a number of problems, among them being: <br>	1) Creating a supersets in the way described breaks down badly when the declarations exist within multiple modules. <br>	2) The empty enum declaration is currently illegal and probably should be<br>	3) The superset declaration contains no clue as to what it really is.<br>	4) Possibly the most commonly needed use case is not possible with this syntax: Extending enums defined in other modules<br></p><p>I believe that best solution is explicit ```subset:``` and ‘’’superset:``` relationships. They could be added to the language at the same time, or not, but it seems to make sense to consider the possibility of creating supersets along with creating subsets.<br></p><p>I will take more time to think this through before I reply again. It would be nice not to add a variation to ```:``` but that is the best syntax I could think of at the time.<br></p><p><br>&gt; On Jun 3, 2016, at 2:18 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My only hesitation with using `enum LCDColors : Colors` is that that syntax usually signals extending a type and I am not sure whether I am advocating for the ability to add something to `LCDColors` without adding it to `Colors`. I envisioned it as &#39;simply a subset of cases&#39; but that is probably just limited vision on my part.<br></p><p>I agree.<br></p><p>&gt; <br>&gt; Using the subtype syntax works for the most part, so I could certainly live with it. <br>&gt; <br>&gt; On Fri, Jun 3, 2016 at 3:56 PM, Christopher Kornher &lt;ckornher at me.com &lt;mailto:ckornher at me.com&gt;&gt; wrote:<br>&gt; Your original syntax makes  LCDColors clearly a type. The typealias obscures the fact that a new type is being created. An alternative might be something like:<br>&gt; <br>&gt; ```<br>&gt; enum LCDColors : Colors {<br>&gt; 	case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; or perhaps<br>&gt; <br>&gt; ```<br>&gt; enum LCDColors subset: Colors {<br>&gt; 	case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; This would would be compatible with something that I have been hoping for, creating superset enums from multiple enums for things like errors:<br>&gt; <br>&gt; ```<br>&gt; enum AppErrors  {<br>&gt; 	// Defined by its subsets<br>&gt; }<br>&gt; <br>&gt; enum NetworkingErrors  subset: AppErrors {<br>&gt; 	case NWError1 = 1000, NWError2. NWError3<br>&gt; }<br>&gt; <br>&gt;  <br>&gt; enum UserInputErrors  subset: AppErrors {<br>&gt; 	case UIError1 = 2000, UIError2. UIError3<br>&gt; }<br>&gt;  ```<br>&gt; The compiler would have to check for rawValue collisions.<br>&gt; <br>&gt; having the superset enum define values that could be used in children would allow:<br>&gt; <br>&gt;  ```<br>&gt; enum AppErrors  {<br>&gt; 	// Defined by its subsets<br>&gt; 	case NetworkingErrorBase = 1000<br>&gt; 	case UIErrorBase = 2000<br>&gt; }<br>&gt; <br>&gt; enum NetworkingErrors  subset: AppErrors {<br>&gt; 	case NWError1 = NetworkingErrorBase, NWError2. NWError3<br>&gt; }<br>&gt; <br>&gt; enum UserInputErrors  subset: AppErrors {<br>&gt; 	case UIError1 = UIErrorBase, UIError2. UIError3<br>&gt; }<br>&gt;  ```<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 10:39 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t have a problem with something as explicit as that. I was mostly avoiding adding keywords with my proposed syntax. I have basically no tie to the proposed syntax.<br>&gt;&gt; <br>&gt;&gt; TJ<br>&gt;&gt; <br>&gt;&gt; On Fri, Jun 3, 2016 at 12:32 PM, Christopher Kornher &lt;ckornher at me.com &lt;mailto:ckornher at me.com&gt;&gt; wrote:<br>&gt;&gt; This could be useful in categorizing and grouping within large enums ErrorType enums come to mind. Would there be any problem with making the subset more explicit? e.g.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ``` swift<br>&gt;&gt; enum Colors {<br>&gt;&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt; 	…<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Colors {<br>&gt;&gt; 	subset  LCDColors  red, green, blue<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 7:22 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose members are strict subsets of explicitly defined enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; Consider a situation where we have an enum `Colors` which represents the entire set of colors relevant to your application with many salient methods and operations. We have also declared an enum `LCDColorModel` with only three colors, `red, blue, green` .<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt; enum Colors {<br>&gt;&gt;&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt;&gt; 	…<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum LCDColors {<br>&gt;&gt;&gt; 	case red, green, blue<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The cases in `LCDColors` in our scenario do not require different behavior from their similarly named cases in `Colors`. We would like, simply stated, to explicitly restrict the cases allowed within a specific portion of our software. There are, currently, a few approaches <br>&gt;&gt;&gt; 	1. Duplicate functionality in `LCDColors` <br>&gt;&gt;&gt; 		- Completely manually<br>&gt;&gt;&gt; 		- Protocols with &#39;minimal&#39; manual duplication<br>&gt;&gt;&gt; 	2. Avoid duplication by allowing conversion to `Colors`. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Neither of these solutions make the subset relationship between `Colors` and `LCDColors`  clear or strict.<br>&gt;&gt; <br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Add syntax to describe a restricted set of cases from an enum. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases must appear in the same order as their original declaration. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; While I am unsure of the entirety of the design, I propose that name mangling be used which, along with the declaration order restriction should mean that all possible subsets have a stable and predictable name which contains all of the information necessary to infer cases. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an additive change which should have no breaking change to existing code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/3b30387e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June  3, 2016 at 09:00:00pm</p></header><div class="content"><p>I really like this idea, a few comments I have:<br>Would this subset be exhaustive within only the subset you’ve restricted it to? I’m hoping so! i.e- if I do a switch on LCDColors I assume I only have to provide three cases, but this doesn’t appear to be expressly mentioned.<br>Do you envision this being usable in function signatures without declaring a type alias first? I can see cases where it may be convenient to do so, but some of the concerns with ad-hoc enums has been over there being no formal declaration of the type.<br>Lastly, is the ordering of the labels really important? Can’t the compiler just reorder them behind the scenes if necessary? I don’t think there should be any problem with the compiler detecting that Colors.(violet|orange|green) is the same as Colors.(orange|green|violet). I mean it’d be good practice to maintain the same order of course, but I think it’s better to allow any order, as the parent type’s ordering may change and break stuff; I’m not sure if relying on the parent’s ordering is really wise anyway, if you need it for some purpose then it should be defined in a method.<br>You need to cover conversion between the two types. I assume that if I have an LCDColors case it will work anywhere that takes a case from Colors, but how does the reverse work? Can I assign an instance of Colors to LCDColors via casting for example (with a failure if it’s not one of the specified cases)?<br>But yeah, I like this idea, it’s kind of like an enum “slice”, and while it’s not strictly the same as ad-hoc enums it could solve many of their use-cases in a safer way.<br></p><p>&gt; On 3 Jun 2016, at 14:22, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum proposal.<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose members are strict subsets of explicitly defined enums.<br>&gt; <br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; Consider a situation where we have an enum `Colors` which represents the entire set of colors relevant to your application with many salient methods and operations. We have also declared an enum `LCDColorModel` with only three colors, `red, blue, green` .<br>&gt; <br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; enum LCDColors {<br>&gt; 	case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The cases in `LCDColors` in our scenario do not require different behavior from their similarly named cases in `Colors`. We would like, simply stated, to explicitly restrict the cases allowed within a specific portion of our software. There are, currently, a few approaches <br>&gt; 	1. Duplicate functionality in `LCDColors` <br>&gt; 		- Completely manually<br>&gt; 		- Protocols with &#39;minimal&#39; manual duplication<br>&gt; 	2. Avoid duplication by allowing conversion to `Colors`. <br>&gt; <br>&gt; Neither of these solutions make the subset relationship between `Colors` and `LCDColors`  clear or strict.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Add syntax to describe a restricted set of cases from an enum. <br>&gt; <br>&gt; ```swift<br>&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt; ```<br>&gt; <br>&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases must appear in the same order as their original declaration. <br>&gt; <br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; While I am unsure of the entirety of the design, I propose that name mangling be used which, along with the declaration order restriction should mean that all possible subsets have a stable and predictable name which contains all of the information necessary to infer cases. <br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This is an additive change which should have no breaking change to existing code.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/5844fa5f/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  3, 2016 at 01:00:00pm</p></header><div class="content"><p>I really like the idea behind this proposal.<br></p><p>Some questions:<br></p><p>- Would the enum &#39;slice&#39; be a distinct type relative to the base enum?<br>- On a related note, would shared cases between the sliced enum and the<br>base enum be implicitly convertible?<br>- If they aren&#39;t implicitly convertible between each other, would there be<br>an affordance to perform conversions (e.g. a &quot;parentEnumType&quot; property and<br>an &quot;init?(parentEnumType:)&quot; initializer)/<br>- Would you be able to further slice a sliced enum? If so, would they share<br>the same parent, or would the &#39;parent&#39; of the sliced sliced enum be the<br>sliced enum?<br>- If the parent enum has members that switch on &#39;self&#39;, would those members<br>be available to the child automatically?<br>- What happens if you have two (or more) slices with disjoint members?<br>(e.g. &#39;LCDColors&#39; and &#39;TrafficLightColors&#39;) Would they be considered<br>completely separate &#39;sub-types&#39;?<br></p><p>Best,<br>Austin<br></p><p><br></p><p><br>On Fri, Jun 3, 2016 at 6:22 AM, T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum<br>&gt; proposal.<br>&gt;<br>&gt; ## Introduction<br>&gt;<br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>&gt; members are strict subsets of explicitly defined enums.<br>&gt;<br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal](<br>&gt; http://news.gmane.org/gmane.comp.lang.swift.evolution)<br>&gt;<br>&gt; ## Motivation<br>&gt; Consider a situation where we have an enum `Colors` which represents the<br>&gt; entire set of colors relevant to your application with many salient methods<br>&gt; and operations. We have also declared an enum `LCDColorModel` with only<br>&gt; three colors, `red, blue, green` .<br>&gt;<br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt; …<br>&gt; }<br>&gt;<br>&gt; enum LCDColors {<br>&gt; case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; The cases in `LCDColors` in our scenario do not require different behavior<br>&gt; from their similarly named cases in `Colors`. We would like, simply stated,<br>&gt; to explicitly restrict the cases allowed within a specific portion of our<br>&gt; software. There are, currently, a few approaches<br>&gt; 1. Duplicate functionality in `LCDColors`<br>&gt; - Completely manually<br>&gt; - Protocols with &#39;minimal&#39; manual duplication<br>&gt; 2. Avoid duplication by allowing conversion to `Colors`.<br>&gt;<br>&gt; Neither of these solutions make the subset relationship between `Colors`<br>&gt; and `LCDColors`  clear or strict.<br>&gt;<br>&gt; ## Proposed solution<br>&gt;<br>&gt; Add syntax to describe a restricted set of cases from an enum.<br>&gt;<br>&gt; ```swift<br>&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt; ```<br>&gt;<br>&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases<br>&gt; must appear in the same order as their original declaration.<br>&gt;<br>&gt;<br>&gt; ## Detailed design<br>&gt;<br>&gt; While I am unsure of the entirety of the design, I propose that name<br>&gt; mangling be used which, along with the declaration order restriction should<br>&gt; mean that all possible subsets have a stable and predictable name which<br>&gt; contains all of the information necessary to infer cases.<br>&gt;<br>&gt; ## Impact on existing code<br>&gt;<br>&gt; This is an additive change which should have no breaking change to<br>&gt; existing code.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/d9ef7c51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Since this seems to have some interest, I&#39;ve made a gist.<br></p><p>https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c<br>Introduction<br></p><p>This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>members are strict subsets of explicitly defined enums.<br></p><p>Swift-evolution thread: Discussion thread topic for that proposal<br>&lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/020025.html&gt;<br>Motivation<br></p><p>Consider a situation where we have an enum Color which represents the<br>entire set of colors relevant to your application with many salient methods<br>and operations. We have also declared an enum LCDColorModel with only three<br>colors, red, blue, green .<br></p><p>enum Color {<br>    case red, orange, yellow, green, blue, indigo, violet<br>    …<br>}<br>enum LCDColor {<br>    case red, green, blue<br>}<br></p><p>The cases in LCDColor in our scenario do not require different behavior<br>from their similarly named cases in Color. We would like, simply stated, to<br>explicitly restrict the cases allowed within a specific portion of our<br>software. There are, currently, a few approaches<br>1. Duplicate functionality in LCDColor<br>- Completely manually<br>- Protocols with ‘minimal’ manual duplication<br>2. Avoid duplication by allowing conversion to Color.<br></p><p>Neither of these solutions make the subset relationship between Color and<br>LCDColor clear or strict.<br>Proposed solution<br></p><p>Add syntax to describe a restricted set of cases from an enum.<br></p><p>typealias LCDColor = Color.(red|green|blue)<br></p><p>LCDColor has all of the type and instance methods of Color.<br></p><p>   - Barring any technical reason, the ‘actual’ name of the type, in this<br>   example, is Color.(red|green|blue) This makes the relationship to<br>Colorsyntactically<br>   clear. If a typealias is not desired, Color.(red|green|blue) should<br>   refer to the same type as LCDColor<br>   - Switching over Color.(red|green|blue) should only need to be<br>   exhaustive for the three cases .red, .green, and .blue.<br>   - Two initializers should be implicitly created<br>      - Color to LCDColor?<br>         - returns nil for all cases not in LCDColor<br>      - LCDColor to Color<br>         - Obvious and trivial implementation mapping cases from LCDColor<br>          to Color<br>      - Casting should be allowed<br>      - from superset to subset only using as? or as! syntax.<br>      - from subset to superset using as<br>   - Creating subsets of subsets is not allowed but reasonable conversions<br>   among subsets should be allowed if technically feasible such that:<br>      - Given subsets of C A and B, where A is a superset of B, the casting<br>      relationship between A and B should be similar to that between C and<br>      either of the other two named subsets.<br></p><p>Detailed design<br></p><p>While I am unsure of the entirety of the design, I propose that name<br>mangling be used which, along with the declaration order restriction should<br>mean that all possible subsets have a stable and predictable name which<br>contains all of the information necessary to infer cases.<br>If a mangled name approach is taken, the ordering of cases should be sorted<br>to ensure stability.<br>Alternatives considered<br></p><p>   - Do nothing. This feature is not strictly necessary but does allow for<br>   expressivity not currently available in the language.<br>   - implicitly create properties which convert to superset type.<br></p><p>Impact on existing code<br></p><p>This is an additive change which should have no breaking change to existing<br>code.<br></p><p>On Fri, Jun 3, 2016 at 4:57 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br></p><p>&gt; I really like the idea behind this proposal.<br>&gt;<br>&gt; Some questions:<br>&gt;<br>&gt; - Would the enum &#39;slice&#39; be a distinct type relative to the base enum?<br>&gt; - On a related note, would shared cases between the sliced enum and the<br>&gt; base enum be implicitly convertible?<br>&gt; - If they aren&#39;t implicitly convertible between each other, would there be<br>&gt; an affordance to perform conversions (e.g. a &quot;parentEnumType&quot; property and<br>&gt; an &quot;init?(parentEnumType:)&quot; initializer)/<br>&gt; - Would you be able to further slice a sliced enum? If so, would they<br>&gt; share the same parent, or would the &#39;parent&#39; of the sliced sliced enum be<br>&gt; the sliced enum?<br>&gt; - If the parent enum has members that switch on &#39;self&#39;, would those<br>&gt; members be available to the child automatically?<br>&gt; - What happens if you have two (or more) slices with disjoint members?<br>&gt; (e.g. &#39;LCDColors&#39; and &#39;TrafficLightColors&#39;) Would they be considered<br>&gt; completely separate &#39;sub-types&#39;?<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, Jun 3, 2016 at 6:22 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc<br>&gt;&gt; enum proposal.<br>&gt;&gt;<br>&gt;&gt; ## Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>&gt;&gt; members are strict subsets of explicitly defined enums.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](<br>&gt;&gt; http://news.gmane.org/gmane.comp.lang.swift.evolution)<br>&gt;&gt;<br>&gt;&gt; ## Motivation<br>&gt;&gt; Consider a situation where we have an enum `Colors` which represents the<br>&gt;&gt; entire set of colors relevant to your application with many salient methods<br>&gt;&gt; and operations. We have also declared an enum `LCDColorModel` with only<br>&gt;&gt; three colors, `red, blue, green` .<br>&gt;&gt;<br>&gt;&gt; ``` swift<br>&gt;&gt; enum Colors {<br>&gt;&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt; …<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; enum LCDColors {<br>&gt;&gt; case red, green, blue<br>&gt;&gt; }<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; The cases in `LCDColors` in our scenario do not require different<br>&gt;&gt; behavior from their similarly named cases in `Colors`. We would like,<br>&gt;&gt; simply stated, to explicitly restrict the cases allowed within a specific<br>&gt;&gt; portion of our software. There are, currently, a few approaches<br>&gt;&gt; 1. Duplicate functionality in `LCDColors`<br>&gt;&gt; - Completely manually<br>&gt;&gt; - Protocols with &#39;minimal&#39; manual duplication<br>&gt;&gt; 2. Avoid duplication by allowing conversion to `Colors`.<br>&gt;&gt;<br>&gt;&gt; Neither of these solutions make the subset relationship between `Colors`<br>&gt;&gt; and `LCDColors`  clear or strict.<br>&gt;&gt;<br>&gt;&gt; ## Proposed solution<br>&gt;&gt;<br>&gt;&gt; Add syntax to describe a restricted set of cases from an enum.<br>&gt;&gt;<br>&gt;&gt; ```swift<br>&gt;&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt;&gt; ```<br>&gt;&gt;<br>&gt;&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases<br>&gt;&gt; must appear in the same order as their original declaration.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ## Detailed design<br>&gt;&gt;<br>&gt;&gt; While I am unsure of the entirety of the design, I propose that name<br>&gt;&gt; mangling be used which, along with the declaration order restriction should<br>&gt;&gt; mean that all possible subsets have a stable and predictable name which<br>&gt;&gt; contains all of the information necessary to infer cases.<br>&gt;&gt;<br>&gt;&gt; ## Impact on existing code<br>&gt;&gt;<br>&gt;&gt; This is an additive change which should have no breaking change to<br>&gt;&gt; existing code.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/3a9fbf1d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June  3, 2016 at 03:00:00pm</p></header><div class="content"><p>A few ideas:<br></p><p>* Mention the pull request about member sets?<br>* I&#39;d try to give some more compelling use cases (Where a union type can be broadly applied across more specific uses, which then tend to narrow the applicable cases, and you want to limit (and compile check) those cases while inheriting behavior).<br>* Mention how enum specialization tends to limit possible cases, and consider how enum expansion/inheritance might be another direction for expanding existing enums (for example, when adding new phone models, but using an existing enum, with an extension), and how this might impact footprint in associated types.<br>* Discuss how behavior extensions on narrowed enums could be limited to the subset, so would be syntactically limited to the semantic subset as a motivation for why LCD colors might appropriately be used in a calibrate functions but the full color cases would not, etc.<br></p><p>-- E<br></p><p><br></p><p>&gt; On Jun 3, 2016, at 3:35 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt; <br>&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c &lt;https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c&gt;<br>&gt; Introduction<br>&gt; <br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose members are strict subsets of explicitly defined enums.<br>&gt; <br>&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/020025.html&gt;<br>&gt; Motivation<br>&gt; <br>&gt; Consider a situation where we have an enum Color which represents the entire set of colors relevant to your application with many salient methods and operations. We have also declared an enum LCDColorModel with only three colors, red, blue, green .<br>&gt; <br>&gt; enum Color {<br>&gt;     case red, orange, yellow, green, blue, indigo, violet<br>&gt;     …<br>&gt; }<br>&gt; <br>&gt; enum LCDColor {<br>&gt;     case red, green, blue<br>&gt; }<br>&gt; The cases in LCDColor in our scenario do not require different behavior from their similarly named cases in Color. We would like, simply stated, to explicitly restrict the cases allowed within a specific portion of our software. There are, currently, a few approaches<br>&gt; 1. Duplicate functionality in LCDColor<br>&gt; - Completely manually<br>&gt; - Protocols with ‘minimal’ manual duplication<br>&gt; 2. Avoid duplication by allowing conversion to Color. <br>&gt; <br>&gt; Neither of these solutions make the subset relationship between Color and LCDColor clear or strict.<br>&gt; <br>&gt; Proposed solution<br>&gt; <br>&gt; Add syntax to describe a restricted set of cases from an enum. <br>&gt; <br>&gt; typealias LCDColor = Color.(red|green|blue)<br>&gt; LCDColor has all of the type and instance methods of Color.<br>&gt; <br>&gt; Barring any technical reason, the ‘actual’ name of the type, in this example, is Color.(red|green|blue) This makes the relationship to Colorsyntactically clear. If a typealias is not desired, Color.(red|green|blue) should refer to the same type as LCDColor<br>&gt; Switching over Color.(red|green|blue) should only need to be exhaustive for the three cases .red, .green, and .blue.<br>&gt; Two initializers should be implicitly created<br>&gt; Color to LCDColor?<br>&gt; returns nil for all cases not in LCDColor<br>&gt; LCDColor to Color<br>&gt; Obvious and trivial implementation mapping cases from LCDColor to Color<br>&gt; Casting should be allowed<br>&gt; from superset to subset only using as? or as! syntax.<br>&gt; from subset to superset using as<br>&gt; Creating subsets of subsets is not allowed but reasonable conversions among subsets should be allowed if technically feasible such that:<br>&gt; Given subsets of C A and B, where A is a superset of B, the casting relationship between A and B should be similar to that between C and either of the other two named subsets.<br>&gt; Detailed design<br>&gt; <br>&gt; While I am unsure of the entirety of the design, I propose that name mangling be used which, along with the declaration order restriction should mean that all possible subsets have a stable and predictable name which contains all of the information necessary to infer cases.<br>&gt; If a mangled name approach is taken, the ordering of cases should be sorted to ensure stability.<br>&gt; <br>&gt; Alternatives considered<br>&gt; <br>&gt; Do nothing. This feature is not strictly necessary but does allow for expressivity not currently available in the language.<br>&gt; implicitly create properties which convert to superset type.<br>&gt; Impact on existing code<br>&gt; <br>&gt; This is an additive change which should have no breaking change to existing code.<br>&gt; <br>&gt; <br>&gt; On Fri, Jun 3, 2016 at 4:57 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; I really like the idea behind this proposal.<br>&gt; <br>&gt; Some questions:<br>&gt; <br>&gt; - Would the enum &#39;slice&#39; be a distinct type relative to the base enum?<br>&gt; - On a related note, would shared cases between the sliced enum and the base enum be implicitly convertible?<br>&gt; - If they aren&#39;t implicitly convertible between each other, would there be an affordance to perform conversions (e.g. a &quot;parentEnumType&quot; property and an &quot;init?(parentEnumType:)&quot; initializer)/<br>&gt; - Would you be able to further slice a sliced enum? If so, would they share the same parent, or would the &#39;parent&#39; of the sliced sliced enum be the sliced enum?<br>&gt; - If the parent enum has members that switch on &#39;self&#39;, would those members be available to the child automatically?<br>&gt; - What happens if you have two (or more) slices with disjoint members? (e.g. &#39;LCDColors&#39; and &#39;TrafficLightColors&#39;) Would they be considered completely separate &#39;sub-types&#39;?<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Fri, Jun 3, 2016 at 6:22 AM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc enum proposal.<br>&gt; <br>&gt; ## Introduction<br>&gt; <br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose members are strict subsets of explicitly defined enums.<br>&gt; <br>&gt; Swift-evolution thread: [Discussion thread topic for that proposal](http://news.gmane.org/gmane.comp.lang.swift.evolution &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;)<br>&gt; <br>&gt; ## Motivation<br>&gt; Consider a situation where we have an enum `Colors` which represents the entire set of colors relevant to your application with many salient methods and operations. We have also declared an enum `LCDColorModel` with only three colors, `red, blue, green` .<br>&gt; <br>&gt; ``` swift<br>&gt; enum Colors {<br>&gt; 	case red, orange, yellow, green, blue, indigo, violet<br>&gt; 	…<br>&gt; }<br>&gt; <br>&gt; enum LCDColors {<br>&gt; 	case red, green, blue<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; The cases in `LCDColors` in our scenario do not require different behavior from their similarly named cases in `Colors`. We would like, simply stated, to explicitly restrict the cases allowed within a specific portion of our software. There are, currently, a few approaches <br>&gt; 	1. Duplicate functionality in `LCDColors` <br>&gt; 		- Completely manually<br>&gt; 		- Protocols with &#39;minimal&#39; manual duplication<br>&gt; 	2. Avoid duplication by allowing conversion to `Colors`. <br>&gt; <br>&gt; Neither of these solutions make the subset relationship between `Colors` and `LCDColors`  clear or strict.<br>&gt; <br>&gt; ## Proposed solution<br>&gt; <br>&gt; Add syntax to describe a restricted set of cases from an enum. <br>&gt; <br>&gt; ```swift<br>&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt; ```<br>&gt; <br>&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases must appear in the same order as their original declaration. <br>&gt; <br>&gt; <br>&gt; ## Detailed design<br>&gt; <br>&gt; While I am unsure of the entirety of the design, I propose that name mangling be used which, along with the declaration order restriction should mean that all possible subsets have a stable and predictable name which contains all of the information necessary to infer cases. <br>&gt; <br>&gt; ## Impact on existing code<br>&gt; <br>&gt; This is an additive change which should have no breaking change to existing code.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/80897d17/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>June  3, 2016 at 10:00:00pm</p></header><div class="content"><p>I like the idea, conceptually—having more set-like semantics for enums<br>sounds like it would open up some interesting possibilities. (And I don&#39;t<br>think we should limit ourselves to subsets either. Supersets are also<br>interesting.)<br></p><p>Things could get pretty tricky though, so there are a lot of gaps to fill<br>in here. Off the top of my head, I&#39;d be curious about the following<br>situations:<br></p><p>* You don&#39;t mention cases with associated values anywhere. Is it your<br>intention to prohibit those, or would the following work?<br></p><p>enum Foo {<br>   case Bar<br>   case Baz(Int)<br>   case Blorp(String)<br>}<br>typealias FooSubset = Foo.(Bar|Baz)<br>// FooSubset is effectively: enum FooSubset { case Bar; case Baz(Int) }?<br></p><p>I can&#39;t think of any reason off the top of my head to prohibit cases with<br>associated values, for what it&#39;s worth.<br></p><p>* How would non-case members of an enum (i.e., computed properties,<br>methods, etc.) be effected? Other folks in the thread have mentioned<br>methods that switch on self. In a very abstract sense, there are two kinds<br>of these properties/methods: those that simply use &quot;self&quot; to branch, and<br>those that use the enum in other ways. For example, I see no reason that<br>this shouldn&#39;t work:<br></p><p>enum Color {<br>  case red<br>  case blue<br>  case green<br></p><p>  var uiColor: UIColor {<br>    switch self {<br>      case .red: return UIColor.red()<br>      case .blue: return UIColor.blue()<br>      case .green: return UIColor.green()<br>    }<br>  }<br>}<br>let x: Color.(blue|green) = Color.blue<br>let color = x.uiColor<br></p><p>But on the other hand, you could have something like this:<br></p><p>enum Color {<br>  case red<br>  case blue<br>  case green<br></p><p>  var nextColor: Color {<br>    switch self {<br>      case .red: return .blue<br>      case .blue: return .green<br>      case .green: return .red<br>    }<br>  }<br>}<br>let x: Color.(blue|green) = Color.blue<br>let color = x.nextColor  // umm....<br></p><p>Things start getting really hard to predict because it&#39;s very hard to<br>reason about what happens inside these computed properties, and I fear that<br>the solution becomes &quot;conservatively exclude a lot of stuff&quot; and that<br>starts taking a lot of the power away from those enums.<br></p><p><br></p><p>On Fri, Jun 3, 2016 at 2:35 PM T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt;<br>&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c<br>&gt; Introduction<br>&gt;<br>&gt; This proposal adds/creates syntax to allow ad hoc creation of enums whose<br>&gt; members are strict subsets of explicitly defined enums.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160530/020025.html&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Consider a situation where we have an enum Color which represents the<br>&gt; entire set of colors relevant to your application with many salient methods<br>&gt; and operations. We have also declared an enum LCDColorModel with only<br>&gt; three colors, red, blue, green .<br>&gt;<br>&gt; enum Color {<br>&gt;<br>&gt;<br>&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt;     …<br>&gt; }<br>&gt;<br>&gt;<br>&gt; enum LCDColor {<br>&gt;     case red, green, blue<br>&gt; }<br>&gt;<br>&gt; The cases in LCDColor in our scenario do not require different behavior<br>&gt; from their similarly named cases in Color. We would like, simply stated,<br>&gt; to explicitly restrict the cases allowed within a specific portion of our<br>&gt; software. There are, currently, a few approaches<br>&gt; 1. Duplicate functionality in LCDColor<br>&gt;<br>&gt;<br>&gt; - Completely manually<br>&gt; - Protocols with ‘minimal’ manual duplication<br>&gt;<br>&gt; 2. Avoid duplication by allowing conversion to Color.<br>&gt;<br>&gt; Neither of these solutions make the subset relationship between Color and<br>&gt; LCDColor clear or strict.<br>&gt; Proposed solution<br>&gt;<br>&gt; Add syntax to describe a restricted set of cases from an enum.<br>&gt;<br>&gt; typealias LCDColor = Color.(red|green|blue)<br>&gt;<br>&gt; LCDColor has all of the type and instance methods of Color.<br>&gt;<br>&gt;    - Barring any technical reason, the ‘actual’ name of the type, in this<br>&gt;    example, is Color.(red|green|blue) This makes the relationship to Colorsyntactically<br>&gt;    clear. If a typealias is not desired, Color.(red|green|blue) should<br>&gt;    refer to the same type as LCDColor<br>&gt;    - Switching over Color.(red|green|blue) should only need to be<br>&gt;    exhaustive for the three cases .red, .green, and .blue.<br>&gt;    - Two initializers should be implicitly created<br>&gt;       - Color to LCDColor?<br>&gt;          - returns nil for all cases not in LCDColor<br>&gt;       - LCDColor to Color<br>&gt;          - Obvious and trivial implementation mapping cases from LCDColor<br>&gt;           to Color<br>&gt;       - Casting should be allowed<br>&gt;       - from superset to subset only using as? or as! syntax.<br>&gt;       - from subset to superset using as<br>&gt;    - Creating subsets of subsets is not allowed but reasonable<br>&gt;    conversions among subsets should be allowed if technically feasible such<br>&gt;    that:<br>&gt;       - Given subsets of C A and B, where A is a superset of B, the<br>&gt;       casting relationship between A and B should be similar to that<br>&gt;       between C and either of the other two named subsets.<br>&gt;<br>&gt; Detailed design<br>&gt;<br>&gt; While I am unsure of the entirety of the design, I propose that name<br>&gt; mangling be used which, along with the declaration order restriction should<br>&gt; mean that all possible subsets have a stable and predictable name which<br>&gt; contains all of the information necessary to infer cases.<br>&gt;<br>&gt; If a mangled name approach is taken, the ordering of cases should be<br>&gt; sorted to ensure stability.<br>&gt; Alternatives considered<br>&gt;<br>&gt;    - Do nothing. This feature is not strictly necessary but does allow<br>&gt;    for expressivity not currently available in the language.<br>&gt;    - implicitly create properties which convert to superset type.<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; This is an additive change which should have no breaking change to<br>&gt; existing code.<br>&gt;<br>&gt; On Fri, Jun 3, 2016 at 4:57 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I really like the idea behind this proposal.<br>&gt;&gt;<br>&gt;&gt; Some questions:<br>&gt;&gt;<br>&gt;&gt; - Would the enum &#39;slice&#39; be a distinct type relative to the base enum?<br>&gt;&gt; - On a related note, would shared cases between the sliced enum and the<br>&gt;&gt; base enum be implicitly convertible?<br>&gt;&gt; - If they aren&#39;t implicitly convertible between each other, would there<br>&gt;&gt; be an affordance to perform conversions (e.g. a &quot;parentEnumType&quot; property<br>&gt;&gt; and an &quot;init?(parentEnumType:)&quot; initializer)/<br>&gt;&gt; - Would you be able to further slice a sliced enum? If so, would they<br>&gt;&gt; share the same parent, or would the &#39;parent&#39; of the sliced sliced enum be<br>&gt;&gt; the sliced enum?<br>&gt;&gt; - If the parent enum has members that switch on &#39;self&#39;, would those<br>&gt;&gt; members be available to the child automatically?<br>&gt;&gt; - What happens if you have two (or more) slices with disjoint members?<br>&gt;&gt; (e.g. &#39;LCDColors&#39; and &#39;TrafficLightColors&#39;) Would they be considered<br>&gt;&gt; completely separate &#39;sub-types&#39;?<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Fri, Jun 3, 2016 at 6:22 AM, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; This is loosely related to but not meant to &#39;compete&#39; with the ad hoc<br>&gt;&gt;&gt; enum proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This proposal adds/creates syntax to allow ad hoc creation of enums<br>&gt;&gt;&gt; whose members are strict subsets of explicitly defined enums.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift-evolution thread: [Discussion thread topic for that proposal](<br>&gt;&gt;&gt; http://news.gmane.org/gmane.comp.lang.swift.evolution)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Motivation<br>&gt;&gt;&gt; Consider a situation where we have an enum `Colors` which represents the<br>&gt;&gt;&gt; entire set of colors relevant to your application with many salient methods<br>&gt;&gt;&gt; and operations. We have also declared an enum `LCDColorModel` with only<br>&gt;&gt;&gt; three colors, `red, blue, green` .<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ``` swift<br>&gt;&gt;&gt; enum Colors {<br>&gt;&gt;&gt; case red, orange, yellow, green, blue, indigo, violet<br>&gt;&gt;&gt; …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; enum LCDColors {<br>&gt;&gt;&gt; case red, green, blue<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The cases in `LCDColors` in our scenario do not require different<br>&gt;&gt;&gt; behavior from their similarly named cases in `Colors`. We would like,<br>&gt;&gt;&gt; simply stated, to explicitly restrict the cases allowed within a specific<br>&gt;&gt;&gt; portion of our software. There are, currently, a few approaches<br>&gt;&gt;&gt; 1. Duplicate functionality in `LCDColors`<br>&gt;&gt;&gt; - Completely manually<br>&gt;&gt;&gt; - Protocols with &#39;minimal&#39; manual duplication<br>&gt;&gt;&gt; 2. Avoid duplication by allowing conversion to `Colors`.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Neither of these solutions make the subset relationship between `Colors`<br>&gt;&gt;&gt; and `LCDColors`  clear or strict.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Add syntax to describe a restricted set of cases from an enum.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ```swift<br>&gt;&gt;&gt; typealias LCDColors = Colors.(red|green|blue)<br>&gt;&gt;&gt; ```<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; `LCDColors ` has all of the type and instance methods of `Colors`. Cases<br>&gt;&gt;&gt; must appear in the same order as their original declaration.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Detailed design<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; While I am unsure of the entirety of the design, I propose that name<br>&gt;&gt;&gt; mangling be used which, along with the declaration order restriction should<br>&gt;&gt;&gt; mean that all possible subsets have a stable and predictable name which<br>&gt;&gt;&gt; contains all of the information necessary to infer cases.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ## Impact on existing code<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is an additive change which should have no breaking change to<br>&gt;&gt;&gt; existing code.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/6e750c7d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 2:35 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt; <br>&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c &lt;https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c&gt;<br>We have frequently discussed introducing subtype relationships between structs and enums, in an effort to allow limited implicit promotions (e.g. from small integers to wider integers).  Wouldn’t that be a more general solution to this same problem?<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/fd069cfd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>June  3, 2016 at 10:00:00pm</p></header><div class="content"><p>It seems like it would make sense to model enum subsets as a subtype relationship.<br></p><p>Is the core team planning on drawing up a structs/enums subtyping proposal later this year?<br></p><p>Austin<br></p><p>&gt; On Jun 3, 2016, at 10:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 2:35 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c &lt;https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c&gt;<br>&gt; We have frequently discussed introducing subtype relationships between structs and enums, in an effort to allow limited implicit promotions (e.g. from small integers to wider integers).  Wouldn’t that be a more general solution to this same problem?<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160603/e580e3a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June  4, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 4, 2016, at 12:34 AM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It seems like it would make sense to model enum subsets as a subtype relationship.<br>&gt; <br>&gt; Is the core team planning on drawing up a structs/enums subtyping proposal later this year?<br></p><p>+1.  Subtype relationship is mostly what is desired here.  <br></p><p>Some people have also talked about members of the supertype also being available on the subtype which would involve implementation inheritance.  That could probably be made to work for enums if the subtype receives identical storage and as long as all supertype members are considered final (because value type members are always final).  But it&#39;s a slippery slope and would likely bloat the storage of many subtype enums.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 10:25 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 3, 2016, at 2:35 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c<br>&gt;&gt; <br>&gt;&gt; We have frequently discussed introducing subtype relationships between structs and enums, in an effort to allow limited implicit promotions (e.g. from small integers to wider integers).  Wouldn’t that be a more general solution to this same problem?<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/c57d06a0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 3, 2016, at 10:34 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; It seems like it would make sense to model enum subsets as a subtype relationship.<br>&gt; <br>&gt; Is the core team planning on drawing up a structs/enums subtyping proposal later this year?<br></p><p>I would *love* to get it in Swift 3.x or Swift 4, but we’ll have to see.  Generics features needed by the standard library will be higher priority, for example.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  4, 2016 at 04:00:00pm</p></header><div class="content"><p>It could be a more general solution. I am unclear about what &#39;subtype<br>relationships&#39; means here though.<br></p><p>Are you talking a about what you allude to here?<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000525.html<br></p><p><br>The benefit of explicitly narrowing, in my opinion, is that there is no<br>unnecessary cost to figuring out lookup. (Please correct me if I am<br>mistaken.) Implicit promotions introduce uncertainty with regard to what a<br>value is being treated as in any given moment. This uncertainty is worth it<br>in many cases but I will suggest that it is not worth it when trying to<br>deal with a narrower set of cases from an already established set. For<br>example, in the graph/lattice situation, conversions must be written<br>because there is no reasonable conversion that can be assumed. In this<br>proposal, the conversion is obvious and trivial because the relationship is<br>completely clear.<br></p><p>All of that said, I *am* unclear about what subtype relationships means so<br>it may very well be a better solution. It certainly sounds like a more<br>general solution but I am not convinced that that is an advantage when<br>trying to deal with a strict subset.<br></p><p>TJ<br>On Sat, Jun 4, 2016 at 1:25 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 3, 2016, at 2:35 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt;<br>&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c<br>&gt;<br>&gt;<br>&gt; We have frequently discussed introducing subtype relationships between<br>&gt; structs and enums, in an effort to allow limited implicit promotions (e.g.<br>&gt; from small integers to wider integers).  Wouldn’t that be a more general<br>&gt; solution to this same problem?<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160604/d4a42c48/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>June  5, 2016 at 11:00:00pm</p></header><div class="content"><p>Sub typing is the answer that we&#39;re going with then?<br></p><p>On Sat, Jun 4, 2016 at 4:26 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; It could be a more general solution. I am unclear about what &#39;subtype<br>&gt; relationships&#39; means here though.<br>&gt;<br>&gt; Are you talking a about what you allude to here?<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000525.html<br>&gt;<br>&gt;<br>&gt; The benefit of explicitly narrowing, in my opinion, is that there is no<br>&gt; unnecessary cost to figuring out lookup. (Please correct me if I am<br>&gt; mistaken.) Implicit promotions introduce uncertainty with regard to what a<br>&gt; value is being treated as in any given moment. This uncertainty is worth it<br>&gt; in many cases but I will suggest that it is not worth it when trying to<br>&gt; deal with a narrower set of cases from an already established set. For<br>&gt; example, in the graph/lattice situation, conversions must be written<br>&gt; because there is no reasonable conversion that can be assumed. In this<br>&gt; proposal, the conversion is obvious and trivial because the relationship is<br>&gt; completely clear.<br>&gt;<br>&gt; All of that said, I *am* unclear about what subtype relationships means so<br>&gt; it may very well be a better solution. It certainly sounds like a more<br>&gt; general solution but I am not convinced that that is an advantage when<br>&gt; trying to deal with a strict subset.<br>&gt;<br>&gt; TJ<br>&gt; On Sat, Jun 4, 2016 at 1:25 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jun 3, 2016, at 2:35 PM, T.J. Usiyan via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt;&gt;<br>&gt;&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; We have frequently discussed introducing subtype relationships between<br>&gt;&gt; structs and enums, in an effort to allow limited implicit promotions (e.g.<br>&gt;&gt; from small integers to wider integers).  Wouldn’t that be a more general<br>&gt;&gt; solution to this same problem?<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160605/afffaaf4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Enum subsets</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>June  7, 2016 at 08:00:00pm</p></header><div class="content"><p>On Jun 5, 2016, at 8:24 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Sub typing is the answer that we&#39;re going with then?<br></p><p>Most likely.  At this point, we’re not really accepting additive changes to Swift 3 anyway, so any proposal would need to wait until post-swift 3 in any case.  <br></p><p>Plans for releases beyond Swift 3 haven’t been made yet - the metaplan is to come up with a plan in ~August timeframe.<br></p><p>-Chris<br></p><p><br>&gt; On Sat, Jun 4, 2016 at 4:26 PM, T.J. Usiyan &lt;griotspeak at gmail.com &lt;mailto:griotspeak at gmail.com&gt;&gt; wrote:<br>&gt; It could be a more general solution. I am unclear about what &#39;subtype relationships&#39; means here though.<br>&gt; <br>&gt; Are you talking a about what you allude to here? https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000525.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151130/000525.html&gt; <br>&gt; <br>&gt; The benefit of explicitly narrowing, in my opinion, is that there is no unnecessary cost to figuring out lookup. (Please correct me if I am mistaken.) Implicit promotions introduce uncertainty with regard to what a value is being treated as in any given moment. This uncertainty is worth it in many cases but I will suggest that it is not worth it when trying to deal with a narrower set of cases from an already established set. For example, in the graph/lattice situation, conversions must be written because there is no reasonable conversion that can be assumed. In this proposal, the conversion is obvious and trivial because the relationship is completely clear.<br>&gt; <br>&gt; All of that said, I *am* unclear about what subtype relationships means so it may very well be a better solution. It certainly sounds like a more general solution but I am not convinced that that is an advantage when trying to deal with a strict subset.<br>&gt; <br>&gt; TJ<br>&gt; On Sat, Jun 4, 2016 at 1:25 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jun 3, 2016, at 2:35 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since this seems to have some interest, I&#39;ve made a gist.<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c &lt;https://gist.github.com/griotspeak/963bc87a0c244c120264b11fb022d78c&gt;<br>&gt; We have frequently discussed introducing subtype relationships between structs and enums, in an effort to allow limited implicit promotions (e.g. from small integers to wider integers).  Wouldn’t that be a more general solution to this same problem?<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160607/43c29954/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
