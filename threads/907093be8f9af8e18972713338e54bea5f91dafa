<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>December 15, 2015 at 11:00:00am</p></header><div class="content"><p>I&#39;ve been playing around with a Swift wrapper for the FFmpeg C libraries<br>(e.g., libavutil, libavcodec, libavformat, etc...). While providing some<br>extensions to some of the core C structures I&#39;ve run into something that<br>doesn&#39;t feel quite right to me.<br></p><p>Before I provide a discussion here is a Gist [0] that I hope illustrates<br>the problem.<br></p><p>When inside of a Swift function declaration if I take `self` and send it<br>to `withUnsafePointer` Swift requires the function to mark the function<br>as `mutating`. This surprised me. Thanks to Swift being open source (ðŸŽ‰)<br>I was able to go look at the implementation of `withUnsafePointer` [1].<br>And I&#39;m no longer surprised that its required by the compiler; the<br>definition marks the argument as `inout`.<br></p><p>However, this seems wrong to me. In the &quot;Pointers&quot; section of &quot;Using<br>Swift with Cocoa and Objective-C (Swift 2.1)&quot; [2] it says that `cost<br>Type *` (pointer to a constant value) is equivalent to<br>`UnsafePointer&lt;Type&gt;`. My understanding of C says that `const Type *`<br>means that the instance of `Type` that the pointer points to cannot be<br>modified. This corresponds with my understanding of the difference<br>between `UnsafePointer&lt;Type&gt;` and `UnsafeMutablePointer&lt;Type&gt;`.<br></p><p>Therefore, from my perspective I feel like there is a bug here. It also<br>seems that marking the `arg` of `withUnsafePointer` to `var` instead of<br>`inout` would allow it to compile and would more closely model the<br>`UnsafePointer`. I&#39;m still new to all this and I don&#39;t want to make a<br>fool of myself. So I&#39;d rather ask here before I move forward and file a<br>bug and MR.<br></p><p>[0] https://gist.github.com/RLovelett/e5ee7f173877bb8475dc<br>[1]<br>https://github.com/apple/swift/blob/8d9ef80304d7b36e13619ea50e6e76f3ec9221ba/stdlib/public/core/LifetimeManager.swift#L93-L102<br>[2]<br>https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID17<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 8:12 AM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve been playing around with a Swift wrapper for the FFmpeg C libraries<br>&gt; (e.g., libavutil, libavcodec, libavformat, etc...). While providing some<br>&gt; extensions to some of the core C structures I&#39;ve run into something that<br>&gt; doesn&#39;t feel quite right to me.<br>&gt; <br>&gt; Before I provide a discussion here is a Gist [0] that I hope illustrates<br>&gt; the problem.<br>&gt; <br>&gt; When inside of a Swift function declaration if I take `self` and send it<br>&gt; to `withUnsafePointer` Swift requires the function to mark the function<br>&gt; as `mutating`. This surprised me. Thanks to Swift being open source (ðŸŽ‰)<br>&gt; I was able to go look at the implementation of `withUnsafePointer` [1].<br>&gt; And I&#39;m no longer surprised that its required by the compiler; the<br>&gt; definition marks the argument as `inout`.<br>&gt; <br>&gt; However, this seems wrong to me. In the &quot;Pointers&quot; section of &quot;Using<br>&gt; Swift with Cocoa and Objective-C (Swift 2.1)&quot; [2] it says that `cost<br>&gt; Type *` (pointer to a constant value) is equivalent to<br>&gt; `UnsafePointer&lt;Type&gt;`. My understanding of C says that `const Type *`<br>&gt; means that the instance of `Type` that the pointer points to cannot be<br>&gt; modified. This corresponds with my understanding of the difference<br>&gt; between `UnsafePointer&lt;Type&gt;` and `UnsafeMutablePointer&lt;Type&gt;`.<br>&gt; <br>&gt; Therefore, from my perspective I feel like there is a bug here. It also<br>&gt; seems that marking the `arg` of `withUnsafePointer` to `var` instead of<br>&gt; `inout` would allow it to compile and would more closely model the<br>&gt; `UnsafePointer`. I&#39;m still new to all this and I don&#39;t want to make a<br>&gt; fool of myself. So I&#39;d rather ask here before I move forward and file a<br>&gt; bug and MR.<br></p><p>Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt; <br>&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br></p><p>A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 6:33 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt;&gt; <br>&gt;&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br>&gt; <br>&gt; A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br></p><p>Two questions:<br></p><p>1. Donâ€™t we want a withUnsafeMutablePointer for the mutating cases (where the inout optimization can take effect) anyway?<br></p><p>2. Joe, these APIs predate many of your changes that make &amp;x transparently convert to Unsafe[Mutable]Pointer arguments.  Are they obsolete?  Can we replace them with { x: Unsafe[Mutable]Pointer in â€¦ }(&amp;y) ?<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 06:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015, at 06:39 PM, Dave Abrahams wrote:<br>&gt; <br>&gt; &gt; On Dec 15, 2015, at 6:33 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br>&gt; &gt; <br>&gt; &gt; A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br>&gt; <br>&gt; Two questions:<br>&gt; <br>&gt; 1. Donâ€™t we want a withUnsafeMutablePointer for the mutating cases (where the inout optimization can take effect) anyway?<br></p><p>I&#39;m thinking here of cases like passing a context pointer to KVO. You&#39;re not actually mutating it, you just need a pointer that&#39;s the same every time you call the code.<br></p><p>&gt; 2. Joe, these APIs predate many of your changes that make &amp;x transparently convert to Unsafe[Mutable]Pointer arguments.  Are they obsolete?  Can we replace them with { x: Unsafe[Mutable]Pointer in â€¦ }(&amp;y) ?<br></p><p>Interesting idea. I rarely use withUnsafePointer/withUnsafeMutablePointer because the &amp;x shorthand exists. If withUnsafePointer() is modified to take its argument by-value and create a pointer from it, I expect people will start using it in place of &amp;x shorthand so they can use it with immutable values, without realizing that they&#39;re getting a different pointer back each time (whether they notice this depends on what they&#39;re using the pointer for).<br></p><p>If { x: UnsafePointer&lt;Int&gt; in ... }(&amp;y) works, that&#39;s a cute replacement. Although it does move the &amp;y reference to after the scope instead of before, which is a little unfortunate.<br></p><p>...huh. On a whim I tested the following and it shocked me by working.<br></p><p>var x: Int = 42<br>withExtendedLifetime(&amp;x) { (x: UnsafeMutablePointer&lt;Int&gt;) in<br>    x.memory += 1<br>}<br>print(x) // prints 43<br></p><p>If we want to replace withUnsafe[Mutable]Pointer() with a common idiom, I&#39;d recommend using withExtendedLifetime like that, because a) it guarantees the pointed-to value exists for the duration of the scope, and b) it already works.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>December 15, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 6:46 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 15, 2015, at 06:39 PM, Dave Abrahams wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 6:33 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br>&gt;&gt; <br>&gt;&gt; Two questions:<br>&gt;&gt; <br>&gt;&gt; 1. Donâ€™t we want a withUnsafeMutablePointer for the mutating cases (where the inout optimization can take effect) anyway?<br>&gt; <br>&gt; I&#39;m thinking here of cases like passing a context pointer to KVO. You&#39;re not actually mutating it, you just need a pointer that&#39;s the same every time you call the code.<br></p><p>Well, it is not possible to code a version of withUnsafePointer that makes that guarantee in Swift.<br></p><p>&gt; <br>&gt;&gt; 2. Joe, these APIs predate many of your changes that make &amp;x transparently convert to Unsafe[Mutable]Pointer arguments. Are they obsolete?  Can we replace them with { x: Unsafe[Mutable]Pointer in â€¦ }(&amp;y) ?<br>&gt; <br>&gt; Interesting idea. I rarely use withUnsafePointer/withUnsafeMutablePointer because the &amp;x shorthand exists. If withUnsafePointer() is modified to take its argument by-value and create a pointer from it, I expect people will start using it in place of &amp;x shorthand so they can use it with immutable values, without realizing that they&#39;re getting a different pointer back each time (whether they notice this depends on what they&#39;re using the pointer for).<br>&gt; <br>&gt; If { x: UnsafePointer&lt;Int&gt; in ... }(&amp;y) works, that&#39;s a cute replacement. Although it does move the &amp;y reference to after the scope instead of before, which is a little unfortunate.<br>&gt; <br>&gt; ...huh. On a whim I tested the following and it shocked me by working.<br>&gt; <br>&gt; var x: Int = 42<br>&gt; withExtendedLifetime(&amp;x) { (x: UnsafeMutablePointer&lt;Int&gt;) in<br>&gt;    x.memory += 1<br>&gt; }<br>&gt; print(x) // prints 43<br>&gt; <br>&gt; If we want to replace withUnsafe[Mutable]Pointer() with a common idiom, I&#39;d recommend using withExtendedLifetime like that, because a) it guarantees the pointed-to value exists for the duration of the scope, and b) it already works.<br>&gt; <br>&gt; -Kevin Ballard<br></p><p>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 15, 2015 at 11:00:00pm</p></header><div class="content"><p>On Tue, Dec 15, 2015, at 11:25 PM, Dave Abrahams wrote:<br>&gt; <br>&gt; &gt; On Dec 15, 2015, at 6:46 PM, Kevin Ballard &lt;kevin at sb.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; On Tue, Dec 15, 2015, at 06:39 PM, Dave Abrahams wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On Dec 15, 2015, at 6:33 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt; &gt;&gt;&gt;&gt; <br>&gt; &gt;&gt;&gt;&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Two questions:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; 1. Donâ€™t we want a withUnsafeMutablePointer for the mutating cases (where the inout optimization can take effect) anyway?<br>&gt; &gt; <br>&gt; &gt; I&#39;m thinking here of cases like passing a context pointer to KVO. You&#39;re not actually mutating it, you just need a pointer that&#39;s the same every time you call the code.<br>&gt; <br>&gt; Well, it is not possible to code a version of withUnsafePointer that makes that guarantee in Swift.<br></p><p>Yeah but we want to move in the direction of making that more reliable, not less. I forget who but someone said in another thread that global variables can be reliably passed by-ref to functions that take pointers already (even though the Swift documentation does not guarantee this).<br></p><p>Come to think of it, what&#39;s the actual use-case for withUnsafePointer()? If a value is mutable, you can already use &amp;x or withUnsafeMutablePointer(), and if it&#39;s immutable, you can&#39;t call withUnsafePointer() today anyway. The proposed change would just make withUnsafePointer() into the equivalent of `var x = value; callSomethingWith(&amp;x)`. The only reason to really want a withUnsafePointer() function is if it can give you an UnsafePointer to an immutable value without copying it, but we can&#39;t do that. I&#39;m inclined to say we should just get rid of withUnsafePointer() entirely, at least until such time as Swift has a way to pass immutable values by-ref.<br></p><p>-Kevin Ballard<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 6:39 PM, Dave Abrahams via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 6:33 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br>&gt;&gt; <br>&gt;&gt; A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br>&gt; <br>&gt; Two questions:<br>&gt; <br>&gt; 1. Donâ€™t we want a withUnsafeMutablePointer for the mutating cases (where the inout optimization can take effect) anyway?<br></p><p>Yeah, a withUnsafeMutablePointer variant that is inout would be necessary.<br></p><p>&gt; 2. Joe, these APIs predate many of your changes that make &amp;x transparently convert to Unsafe[Mutable]Pointer arguments.  Are they obsolete?  Can we replace them with { x: Unsafe[Mutable]Pointer in â€¦ }(&amp;y) ?<br></p><p>Not if you need the same pointer across multiple calls, or you need to convert or adjust the pointer before the call. A call like foo(&amp;x) that involves a pointer conversion only guarantees that pointer for that exact call, as if you&#39;d written withUnsafe[Mutable]Pointer(&amp;x) { foo($0) }. <br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>`withUnsafePointer` mutates `self`</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 16, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 6:33 PM, Kevin Ballard via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; On Tue, Dec 15, 2015, at 03:03 PM, Joe Groff via swift-dev wrote:<br>&gt;&gt; <br>&gt;&gt; Yeah, it seems to me like a reasonable refinement for &#39;withUnsafePointer&#39; to take an immutable parameter. Since this is a stdlib API change, you should suggest that on swift-evolution.<br>&gt; <br>&gt; A change like that is going to break any code that relies on the inout optimization (where it uses call-by-reference instead of copy-in copy-out when possible). Yes, such code is in violation of Swift semantics today, but it does work.<br></p><p>If a value is immutable, it should be easy for the compiler to reuse the address of memory it may already be using for it. <br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
