<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 26, 2016 at 01:00:00pm</p></header><div class="content"><p>I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br></p><p>The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing others’ opinions as to whether the benefits outweigh the costs of various options.<br></p><p>I have found that Swift’s capture lists and rules are a bit of a mystery to many experienced developers, even though Swift’s closure capture rules are very similar to those of Objective-C. Capture lists are probably thought of as opaque incantations by many new Swift developers if they are aware of them at all. Capture lists should, ideally, not be needed for sensible and safe default behavior.<br></p><p>This discussion is iOS / OS X centric and uses terms from those domains, but these issues should be applicable to almost any codebase that uses closures capturing object references.<br></p><p>Capture lists are required by the fact that object references are captured as `strong` by default, often leading to strong reference cycles and memory leaks.<br></p><p>Use of ‘unowned’ <br>————————<br>Many examples of using closures capture self as `unowned`. Often, this pattern does not scale well beyond simple examples. iOS and MacOS applications with dynamic UIs, for example, switch between numerous views and view controllers. These objects are dereferenced and reclaimed when they are no longer needed. Closures capturing these objects as `unowned` crash when the references are accessed.<br></p><p>Unfortunately, ‘unowned’ captures are tempting because they eliminate `guard` and `if let` constructs and avoid littering code with optional unwrapping. They are also slightly more performant, but this difference is probably negligible in most application code.<br></p><p>Capturing escaping object references as `unowned` is only safe when object lifetimes are perfectly understood. In complex systems, it is difficult to predict execution order. Even if object lifetimes are perfectly understood when code is originally written, seemingly innocuous changes to complex systems can negate original assumptions.<br></p><p>For these reasons, I believe that capturing object references as `unowned` should be considered an advanced optimization technique.<br></p><p>I now routinely create closures that capture `self` and other object references as ‘weak’ even if I think that I feel that `unowned ` would be safe. This may not be the absolutely most performant solution, but it is straightforward and robust.<br></p><p><br>The core proposal:<br>——————<br></p><p>Closures capturing object references should automatically capture all object references as weak.<br></p><p>The closure defined in:<br></p><p>```<br>class ClosureOwner2 {<br>    var aClosure: (() -&gt; Void)?<br>    <br>    func aMethod() {<br>        aClosure = { [weak self] in<br>           self?.someOtherMethod()<br>       }<br>    }<br></p><p>    func someOtherMethod(){}<br>}<br>```<br></p><p>would normally be written as: <br></p><p>```<br>        aClosure = {<br>           self?.someOtherMethod()<br>        }<br>```<br>Closures that can be optimized to safely capture object references as `unowned` can use the current syntax.<br></p><p>Swift 2 closure without explicit capture lists for object references will not compile.<br></p><p>Capturing strong object references can be very useful in certain circumstances and have a straightforward syntax:<br></p><p>```<br>        aClosure = { [strong self] in<br>           self.someOtherMethod()<br>        }<br>```<br></p><p><br>Alternatives / Modifications / Improvements(?):<br>—————————————————————<br></p><p>1) Closures with object references could be simplified further by implicitly including ‘let’ guards for all object references: <br> <br>        aClosure = {<br>           // This is included implicitly at the top of the closure:<br>	// guard let strongSelf = self else { return }<br></p><p>            /*strongSelf*/ self.someOtherMethod()<br>	print( “This will not appear when self is nil.” )<br></p><p>	… other uses of strongSelf…<br></p><p>        }<br></p><p>This would have the effect of making the execution of the closure dependent upon the successful unwrapping of all of its object references. Object references that are not required to unwrap successfully can be captured as `weak’ if desired. <br></p><p><br>2) Some of the magic in #1 could be eliminated by introducing a new capture type:  ‘required’ to specify ‘weak guarded’ captures, allowing the example closure to be written:<br></p><p>```<br>        aClosure = { [required self] in<br>           self.someOtherMethod()<br>	print( “This will not appear when self is nil.” )<br>	print( “This is not the default behavior and the reason for this is clearly stated.” ) <br>        }<br>```<br>This reduces the amount of code required, but may increase the cognitive burden over using the current syntax.<br></p><p>`required` is called `guard` in the “Simplified notation” proposal: https://gist.github.com/emaloney/d34ac9b134ece7c60440 &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;<br></p><p>This proposal will differ from the “Simplified notation” proposal in that all object references would be captured as `weak` by default in all closures.<br></p><p>Summary<br>—————-<br>Closures with objects references occur frequently in Swift code and the use of closures is probably only going to increase. Current capture list rules are not developer friendly and force developers to deal with subtle asynchronous memory management issues. This increases the cognitive burden particularly for new developers.<br></p><p>Closures should be safe and straightforward by default.<br></p><p>Enhancement #1 without #2 would probably be the easiest option for new developers and result the smallest code size. The question is: is it too “magical” and are the changes in execution behavior going to be significant in practice?<br></p><p>The rules for closure object references with enhancement #1 can be stated succinctly:<br></p><p>By default:<br></p><p>Closures do not affect reference counts of the objects that they reference.<br>All object references used within a closure must unwrap successfully for the closure to execute.<br></p><p>I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/99eb0775/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>June 26, 2016 at 04:00:00pm</p></header><div class="content"><p>I like it. Accidental capture of a variable is probably one of the primary causes of retain cycles in modern Swift code. Requiring the capture to be explicit would take a lot of the surprise out of it and force the developer to think about the capture semantics.<br></p><p>+1.<br></p><p>Charles<br></p><p>&gt; On Jun 26, 2016, at 2:10 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br>&gt; <br>&gt; The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing others’ opinions as to whether the benefits outweigh the costs of various options.<br>&gt; <br>&gt; I have found that Swift’s capture lists and rules are a bit of a mystery to many experienced developers, even though Swift’s closure capture rules are very similar to those of Objective-C. Capture lists are probably thought of as opaque incantations by many new Swift developers if they are aware of them at all. Capture lists should, ideally, not be needed for sensible and safe default behavior.<br>&gt; <br>&gt; This discussion is iOS / OS X centric and uses terms from those domains, but these issues should be applicable to almost any codebase that uses closures capturing object references.<br>&gt; <br>&gt; Capture lists are required by the fact that object references are captured as `strong` by default, often leading to strong reference cycles and memory leaks.<br>&gt; <br>&gt; Use of ‘unowned’ <br>&gt; ————————<br>&gt; Many examples of using closures capture self as `unowned`. Often, this pattern does not scale well beyond simple examples. iOS and MacOS applications with dynamic UIs, for example, switch between numerous views and view controllers. These objects are dereferenced and reclaimed when they are no longer needed. Closures capturing these objects as `unowned` crash when the references are accessed.<br>&gt; <br>&gt; Unfortunately, ‘unowned’ captures are tempting because they eliminate `guard` and `if let` constructs and avoid littering code with optional unwrapping. They are also slightly more performant, but this difference is probably negligible in most application code.<br>&gt; <br>&gt; Capturing escaping object references as `unowned` is only safe when object lifetimes are perfectly understood. In complex systems, it is difficult to predict execution order. Even if object lifetimes are perfectly understood when code is originally written, seemingly innocuous changes to complex systems can negate original assumptions.<br>&gt; <br>&gt; For these reasons, I believe that capturing object references as `unowned` should be considered an advanced optimization technique.<br>&gt; <br>&gt; I now routinely create closures that capture `self` and other object references as ‘weak’ even if I think that I feel that `unowned ` would be safe. This may not be the absolutely most performant solution, but it is straightforward and robust.<br>&gt; <br>&gt; <br>&gt; The core proposal:<br>&gt; ——————<br>&gt; <br>&gt; Closures capturing object references should automatically capture all object references as weak.<br>&gt; <br>&gt; The closure defined in:<br>&gt; <br>&gt; ```<br>&gt; class ClosureOwner2 {<br>&gt;     var aClosure: (() -&gt; Void)?<br>&gt;     <br>&gt;     func aMethod() {<br>&gt;         aClosure = { [weak self] in<br>&gt;            self?.someOtherMethod()<br>&gt;        }<br>&gt;     }<br>&gt; <br>&gt;     func someOtherMethod(){}<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; would normally be written as: <br>&gt; <br>&gt; ```<br>&gt;         aClosure = {<br>&gt;            self?.someOtherMethod()<br>&gt;         }<br>&gt; ```<br>&gt; Closures that can be optimized to safely capture object references as `unowned` can use the current syntax.<br>&gt; <br>&gt; Swift 2 closure without explicit capture lists for object references will not compile.<br>&gt; <br>&gt; Capturing strong object references can be very useful in certain circumstances and have a straightforward syntax:<br>&gt; <br>&gt; ```<br>&gt;         aClosure = { [strong self] in<br>&gt;            self.someOtherMethod()<br>&gt;         }<br>&gt; ```<br>&gt; <br>&gt; <br>&gt; Alternatives / Modifications / Improvements(?):<br>&gt; —————————————————————<br>&gt; <br>&gt; 1) Closures with object references could be simplified further by implicitly including ‘let’ guards for all object references: <br>&gt;  <br>&gt;         aClosure = {<br>&gt;            // This is included implicitly at the top of the closure:<br>&gt; 	// guard let strongSelf = self else { return }<br>&gt; <br>&gt;             /*strongSelf*/ self.someOtherMethod()<br>&gt; 	print( “This will not appear when self is nil.” )<br>&gt; <br>&gt; 	… other uses of strongSelf…<br>&gt; <br>&gt;         }<br>&gt; <br>&gt; This would have the effect of making the execution of the closure dependent upon the successful unwrapping of all of its object references. Object references that are not required to unwrap successfully can be captured as `weak’ if desired. <br>&gt; <br>&gt; <br>&gt; 2) Some of the magic in #1 could be eliminated by introducing a new capture type:  ‘required’ to specify ‘weak guarded’ captures, allowing the example closure to be written:<br>&gt; <br>&gt; ```<br>&gt;         aClosure = { [required self] in<br>&gt;            self.someOtherMethod()<br>&gt; 	print( “This will not appear when self is nil.” )<br>&gt; 	print( “This is not the default behavior and the reason for this is clearly stated.” ) <br>&gt;         }<br>&gt; ```<br>&gt; This reduces the amount of code required, but may increase the cognitive burden over using the current syntax.<br>&gt; <br>&gt; `required` is called `guard` in the “Simplified notation” proposal: https://gist.github.com/emaloney/d34ac9b134ece7c60440 &lt;https://gist.github.com/emaloney/d34ac9b134ece7c60440&gt;<br>&gt; <br>&gt; This proposal will differ from the “Simplified notation” proposal in that all object references would be captured as `weak` by default in all closures.<br>&gt; <br>&gt; Summary<br>&gt; —————-<br>&gt; Closures with objects references occur frequently in Swift code and the use of closures is probably only going to increase. Current capture list rules are not developer friendly and force developers to deal with subtle asynchronous memory management issues. This increases the cognitive burden particularly for new developers.<br>&gt; <br>&gt; Closures should be safe and straightforward by default.<br>&gt; <br>&gt; Enhancement #1 without #2 would probably be the easiest option for new developers and result the smallest code size. The question is: is it too “magical” and are the changes in execution behavior going to be significant in practice?<br>&gt; <br>&gt; The rules for closure object references with enhancement #1 can be stated succinctly:<br>&gt; <br>&gt; By default:<br>&gt; <br>&gt; Closures do not affect reference counts of the objects that they reference.<br>&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt; <br>&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/f3aaa1e6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 26, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 12:10 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br>&gt; <br>&gt; The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing others’ opinions as to whether the benefits outweigh the costs of various options.<br></p><p>The problem is that strong reference capture is probably the far more common case.<br></p><p>If you wanted to say that @noescape closures capture references strongly by default, while escaping closures capture them weakly by default that may be closer to reasonable for most situations but now you have magic behavior with an even greater cognitive overhead. (I wonder if it would be more common that @noescape captures strongly, escaping captures self weak by default but other objects strongly… of course that would have even worse cognitive overhead.)<br></p><p>No matter what, without a garbage collector you are stuck with sub-optimal solutions for fixing reference cycles. I could imagine a language feature that automatically detected trivial cycles (A -&gt; B -&gt; A) but anything more complex just becomes a form of garbage collection anyway.<br></p><p>I don’t think there is a way to square this circle. Either you have one “automagic” behavior that is wrong for some cases (whether strong or weak is the default), or you require everyone to spam their closures with explicit capture annotations even if there’s a default “capture everything strongly” variant (see C++ lambdas).<br></p><p>&gt; <br>&gt; <br>&gt; Use of ‘unowned’ <br>&gt; ————————<br>&gt; <br>&gt; I now routinely create closures that capture `self` and other object references as ‘weak’ even if I think that I feel that `unowned ` would be safe. This may not be the absolutely most performant solution, but it is straightforward and robust.<br></p><p>I agree and our team has adopted the rule that use of unowned is not allowed unless the declaration is private and there is profiler proof that it represents a performance problem, and if used warning comments must be placed in the code. Weak is almost never a performance problem and eliminates the risk of a crash, so it is highly preferable to unowned.<br></p><p>I’d go so far as to say unowned should be removed; let the user use Unmanaged&lt;T&gt; if they need to capture an unowned reference. They’re entering expert territory anyway.<br></p><p><br></p><p>&gt; <br>&gt; The core proposal:<br>&gt; ——————<br>&gt; <br>&gt; Closures capturing object references should automatically capture all object references as weak.<br>&gt; <br></p><p>This becomes a form of the Objective-C messages-to-nil-do-nothing problem where you don’t crash but your closure doesn’t do any work (or does half the work!) because the reference(s) are/become nil. It doesn’t save you from reasoning about object lifetime because it is just as easy for the closure to capture the last reference to an object or for the lifetime to differ from the closure lifetime. You’re just trading reference cycles for a different problem.<br></p><p><br>&gt; <br>&gt; <br>&gt; 2) Some of the magic in #1 could be eliminated by introducing a new capture type:  ‘required’ to specify ‘weak guarded’ captures, allowing the example closure to be written:<br>&gt; <br></p><p>This has been debated before. I support the idea of a “required” capture specifier but IIRC the core team was not supportive of the idea because it adds another layer of magic on the existing magic (object deallocated magically means your closure never executes).<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/5b8727d5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 27, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 4:25 PM, Russ Bishop &lt;xenadu at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 26, 2016, at 12:10 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br>&gt;&gt; <br>&gt;&gt; The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing others’ opinions as to whether the benefits outweigh the costs of various options.<br>&gt; <br>&gt; The problem is that strong reference capture is probably the far more common case.<br></p><p>Strong reference capture has not been more common in carefully written code in my experience. Swift is starting to be used for many different problem domains, so your experience may be different. Any examples of real-world code would be greatly appreciated.<br></p><p>Sometimes closures contain the only references to objects, but this is not common in code that I have seen. It would be extremely rare for strong references to be required for all the references in closure with multiple references (the current default behavior). Long closures can reference many objects and it is all too easy to leave a reference out of the capture list and create a reference cycle. I believe that this pattern should be called-out (see below).<br></p><p>Strong references are occasionally needed to ensure operations are performed when objects would otherwise be reclaimed, but I have not seen many of these cases. This pattern could be more common in other frameworks. I believe that this pattern should be called-out (see below).<br></p><p>Multiple capture rules for closures can be supported if desired. The ```[required…``` capture qualifier in the original email is one way todo this. The question mark could be used in a way analogous to `try?` to identify closures using the proposed rules: <br></p><p>```let a:()-&gt;Void = {…}?```<br>or <br>``` let a:()-&gt;Void = ?{…}```<br>etc.<br></p><p>This would obviously add more complexity but would still be an improvement, I believe.<br></p><p><br>&gt; If you wanted to say that @noescape closures capture references strongly by default, while escaping closures capture them weakly by default that may be closer to reasonable for most situations but now you have magic behavior with an even greater cognitive overhead. (I wonder if it would be more common that @noescape captures strongly, escaping captures self weak by default but other objects strongly… of course that would have even worse cognitive overhead.)<br></p><p>I did consider treating self differently, but this leads to some very strange cases when delegation, factories and other patterns are considered. <br></p><p>This email was implicitly referring to escaping uses of closures. The same closure can be used as escaping or non-escaping. The Swift documentation states:<br></p><p> &quot;Marking a closure with @noescape lets the compiler make more aggressive optimizations because it knows more information about the closure’s lifespan.&quot;<br></p><p>@noescape is essentially a hint to the compiler. Optimizers would be free to use strong or unowned references if they can determine that it is safe to do so without altering behavior. <br></p><p>&gt; No matter what, without a garbage collector you are stuck with sub-optimal solutions for fixing reference cycles. I could imagine a language feature that automatically detected trivial cycles (A -&gt; B -&gt; A) but anything more complex just becomes a form of garbage collection anyway.<br></p><p>Object networks are difficult enough with ARC without dozens of closures with unnecessary strongly captured references. The new Xcode tools will be a huge help with leaks, but they should not be required.<br></p><p>&gt; <br>&gt; I don’t think there is a way to square this circle. Either you have one “automagic” behavior that is wrong for some cases (whether strong or weak is the default), or you require everyone to spam their closures with explicit capture annotations even if there’s a default “capture everything strongly” variant (see C++ lambdas).<br></p><p>Yes, we are discussing tradeoffs. Writing correct code with closures will always require care.I believe that is is better to have safe, leak free code by default than not. I also believe that capturing strong references by default can probably lead to at least as many unexpected behaviors as capturing weak references. I don’t think that many developers would expect, for example, to see zombie view controllers that have not been associated with an active view hierarchy for weeks because a closure is holding on to a strong reference.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; Use of ‘unowned’ <br>&gt;&gt; ————————<br>&gt;&gt; <br>&gt;&gt; I now routinely create closures that capture `self` and other object references as ‘weak’ even if I think that I feel that `unowned ` would be safe. This may not be the absolutely most performant solution, but it is straightforward and robust.<br>&gt; <br>&gt; I agree and our team has adopted the rule that use of unowned is not allowed unless the declaration is private and there is profiler proof that it represents a performance problem, and if used warning comments must be placed in the code. Weak is almost never a performance problem and eliminates the risk of a crash, so it is highly preferable to unowned.<br>&gt; <br>&gt; I’d go so far as to say unowned should be removed; let the user use Unmanaged&lt;T&gt; if they need to capture an unowned reference. They’re entering expert territory anyway.<br></p><p>I use ‘unowned&#39; regularly for back pointers but not closures. The documentation should contain more warnings about the use of `unowned` at least.<br></p><p>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; The core proposal:<br>&gt;&gt; ——————<br>&gt;&gt; <br>&gt;&gt; Closures capturing object references should automatically capture all object references as weak.<br>&gt;&gt; <br>&gt; <br>&gt; This becomes a form of the Objective-C messages-to-nil-do-nothing problem where you don’t crash but your closure doesn’t do any work (or does half the work!) because the reference(s) are/become nil. It doesn’t save you from reasoning about object lifetime because it is just as easy for the closure to capture the last reference to an object or for the lifetime to differ from the closure lifetime. You’re just trading reference cycles for a different problem.<br></p><p>Yes, this is based upon the opinion that operations on objects that would otherwise have been reclaimed very often can be ignored. If they cannot be ignored, the reference must be captured strongly, but this is relatively rare and should probably be called-out anyway, given the way that developers are forced to automatically invoke the weak/strong dance when creating closures. This suggestion is based upon my experience with thousands(?) of Swift closures in iOS apps in the past two years.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; 2) Some of the magic in #1 could be eliminated by introducing a new capture type:  ‘required’ to specify ‘weak guarded’ captures, allowing the example closure to be written:<br>&gt;&gt; <br>&gt; <br>&gt; This has been debated before. I support the idea of a “required” capture specifier but IIRC the core team was not supportive of the idea because it adds another layer of magic on the existing magic (object deallocated magically means your closure never executes).<br></p><p>The increase in complexity may not be worth the elimination of guard statements. This proposal is different in that it retains a single capture default for closures. The ‘required’ keyword does not change the way references are captured. This may be a significant difference or not.<br></p><p>&gt; <br>&gt; Russ<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/da41ef59/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 12:35 AM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 26, 2016, at 4:25 PM, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 26, 2016, at 12:10 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing others’ opinions as to whether the benefits outweigh the costs of various options.<br>&gt;&gt; <br>&gt;&gt; The problem is that strong reference capture is probably the far more common case.<br>&gt; <br>&gt; Strong reference capture has not been more common in carefully written code in my experience. Swift is starting to be used for many different problem domains, so your experience may be different. Any examples of real-world code would be greatly appreciated.<br></p><p>In my experience reference cycles are almost always caused by capturing self strongly.<br></p><p>&gt; <br>&gt; Sometimes closures contain the only references to objects, but this is not common in code that I have seen. It would be extremely rare for strong references to be required for all the references in closure with multiple references (the current default behavior). Long closures can reference many objects and it is all too easy to leave a reference out of the capture list and create a reference cycle. I believe that this pattern should be called-out (see below).<br>&gt; <br>&gt; Strong references are occasionally needed to ensure operations are performed when objects would otherwise be reclaimed, but I have not seen many of these cases. This pattern could be more common in other frameworks. I believe that this pattern should be called-out (see below).<br>&gt; <br>&gt; Multiple capture rules for closures can be supported if desired. The ```[required…``` capture qualifier in the original email is one way todo this. The question mark could be used in a way analogous to `try?` to identify closures using the proposed rules: <br>&gt; <br>&gt; ```let a:()-&gt;Void = {…}?```<br>&gt; or <br>&gt; ``` let a:()-&gt;Void = ?{…}```<br>&gt; etc.<br>&gt; <br>&gt; This would obviously add more complexity but would still be an improvement, I believe.<br></p><p>Possibly, though this inevitably ends up with the C++ lambda rules more or less. To put it another way, why would Swift introduce a new way of handling this instead of just requiring all closures to specify whether they want strong default, weak default, or whatever and completely eliminate any automatic behavior? Unfortunately that makes creating closures much more annoying.<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; If you wanted to say that @noescape closures capture references strongly by default, while escaping closures capture them weakly by default that may be closer to reasonable for most situations but now you have magic behavior with an even greater cognitive overhead. (I wonder if it would be more common that @noescape captures strongly, escaping captures self weak by default but other objects strongly… of course that would have even worse cognitive overhead.)<br>&gt; <br>&gt; I did consider treating self differently, but this leads to some very strange cases when delegation, factories and other patterns are considered. <br>&gt; <br>&gt; This email was implicitly referring to escaping uses of closures. The same closure can be used as escaping or non-escaping. The Swift documentation states:<br>&gt; <br>&gt;  &quot;Marking a closure with @noescape lets the compiler make more aggressive optimizations because it knows more information about the closure’s lifespan.&quot;<br>&gt; <br>&gt; @noescape is essentially a hint to the compiler. Optimizers would be free to use strong or unowned references if they can determine that it is safe to do so without altering behavior. <br></p><p>The majority of all closures are passed to non-escaping functional methods like map, filter, etc. I don’t see how having them default to weak is a good thing in any capacity. Once we agree on that anything else but strong capture by default will by necessity introduce a cognitive burden.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t think there is a way to square this circle. Either you have one “automagic” behavior that is wrong for some cases (whether strong or weak is the default), or you require everyone to spam their closures with explicit capture annotations even if there’s a default “capture everything strongly” variant (see C++ lambdas).<br>&gt; <br>&gt; Yes, we are discussing tradeoffs. Writing correct code with closures will always require care.I believe that is is better to have safe, leak free code by default than not. I also believe that capturing strong references by default can probably lead to at least as many unexpected behaviors as capturing weak references. I don’t think that many developers would expect, for example, to see zombie view controllers that have not been associated with an active view hierarchy for weeks because a closure is holding on to a strong reference.<br></p><p>I don’t agree that weak by default would equal “safe, leak free”. It might be leak-free but it certainly isn’t necessarily safe. In the face of concurrency you can’t overlook the “half executed” situation of consecutively doing “self?.xyz(); self?.abc()”. Most programmers will assume both xyz() and abc() execute or neither execute but that simply isn’t the case. By making weak the default capture this existing problem is greatly exacerbated.<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/d9948576/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 2:51 PM, Russ Bishop via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 27, 2016, at 12:35 AM, Christopher Kornher &lt;ckornher at me.com &lt;mailto:ckornher at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 26, 2016, at 4:25 PM, Russ Bishop &lt;xenadu at gmail.com &lt;mailto:xenadu at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jun 26, 2016, at 12:10 PM, Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I may be too late for Swift 3, but I am planning to propose changes to the default behavior for closures capturing object references. The introduction of Swift Playgrounds has raised the importance of simplifying the coding of leak-free, crash-free closures. New developers should not have to understand closure memory management to start writing useful and correct code.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The topic of the closure weak/strong dance has been discussed on this list before. This proposal differs from previous proposals in that it will eliminate the dance altogether by default. I am very interested in hearing others’ opinions as to whether the benefits outweigh the costs of various options.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem is that strong reference capture is probably the far more common case.<br>&gt;&gt; <br>&gt;&gt; Strong reference capture has not been more common in carefully written code in my experience. Swift is starting to be used for many different problem domains, so your experience may be different. Any examples of real-world code would be greatly appreciated.<br>&gt; <br>&gt; In my experience reference cycles are almost always caused by capturing self strongly.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sometimes closures contain the only references to objects, but this is not common in code that I have seen. It would be extremely rare for strong references to be required for all the references in closure with multiple references (the current default behavior). Long closures can reference many objects and it is all too easy to leave a reference out of the capture list and create a reference cycle. I believe that this pattern should be called-out (see below).<br>&gt;&gt; <br>&gt;&gt; Strong references are occasionally needed to ensure operations are performed when objects would otherwise be reclaimed, but I have not seen many of these cases. This pattern could be more common in other frameworks. I believe that this pattern should be called-out (see below).<br>&gt;&gt; <br>&gt;&gt; Multiple capture rules for closures can be supported if desired. The ```[required…``` capture qualifier in the original email is one way todo this. The question mark could be used in a way analogous to `try?` to identify closures using the proposed rules: <br>&gt;&gt; <br>&gt;&gt; ```let a:()-&gt;Void = {…}?```<br>&gt;&gt; or <br>&gt;&gt; ``` let a:()-&gt;Void = ?{…}```<br>&gt;&gt; etc.<br>&gt;&gt; <br>&gt;&gt; This would obviously add more complexity but would still be an improvement, I believe.<br>&gt; <br>&gt; Possibly, though this inevitably ends up with the C++ lambda rules more or less. To put it another way, why would Swift introduce a new way of handling this instead of just requiring all closures to specify whether they want strong default, weak default, or whatever and completely eliminate any automatic behavior? Unfortunately that makes creating closures much more annoying.<br></p><p>I took a quick look at C++ capture lists. Yeah, we don’t want those. But another default behavior for captures does make sense for Swift I think. More to come.<br></p><p>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; If you wanted to say that @noescape closures capture references strongly by default, while escaping closures capture them weakly by default that may be closer to reasonable for most situations but now you have magic behavior with an even greater cognitive overhead. (I wonder if it would be more common that @noescape captures strongly, escaping captures self weak by default but other objects strongly… of course that would have even worse cognitive overhead.)<br>&gt;&gt; <br>&gt;&gt; I did consider treating self differently, but this leads to some very strange cases when delegation, factories and other patterns are considered. <br>&gt;&gt; <br>&gt;&gt; This email was implicitly referring to escaping uses of closures. The same closure can be used as escaping or non-escaping. The Swift documentation states:<br>&gt;&gt; <br>&gt;&gt;  &quot;Marking a closure with @noescape lets the compiler make more aggressive optimizations because it knows more information about the closure’s lifespan.&quot;<br>&gt;&gt; <br>&gt;&gt; @noescape is essentially a hint to the compiler. Optimizers would be free to use strong or unowned references if they can determine that it is safe to do so without altering behavior. <br>&gt; <br>&gt; The majority of all closures are passed to non-escaping functional methods like map, filter, etc.<br></p><p> Not in the iOS programming that I do most of the time, but I am sure that the is often the case for other types of development. I rarely use object references in @noescape closures, but styles differ. <br></p><p>&gt; I don’t see how having them default to weak is a good thing in any capacity.<br></p><p>After thinking about it, i agree. @noescape usages of closures should capture strongly. <br></p><p>&gt; Once we agree on that anything else but strong capture by default will by necessity introduce a cognitive burden.<br></p><p>When closures are used to define UI behaviors, capturing weak is a very reasonable default. When GUI elements go away, the reason for the behaviors usually goes with them. This is the context that inspired this. <br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t think there is a way to square this circle. Either you have one “automagic” behavior that is wrong for some cases (whether strong or weak is the default), or you require everyone to spam their closures with explicit capture annotations even if there’s a default “capture everything strongly” variant (see C++ lambdas).<br>&gt;&gt; <br>&gt;&gt; Yes, we are discussing tradeoffs. Writing correct code with closures will always require care.I believe that is is better to have safe, leak free code by default than not. I also believe that capturing strong references by default can probably lead to at least as many unexpected behaviors as capturing weak references. I don’t think that many developers would expect, for example, to see zombie view controllers that have not been associated with an active view hierarchy for weeks because a closure is holding on to a strong reference.<br>&gt; <br>&gt; I don’t agree that weak by default would equal “safe, leak free”. It might be leak-free but it certainly isn’t necessarily safe. In the face of concurrency you can’t overlook the “half executed” situation of consecutively doing “self?.xyz(); self?.abc()”. Most programmers will assume both xyz() and abc() execute or neither execute but that simply isn’t the case. By making weak the default capture this existing problem is greatly exacerbated.<br>&gt; <br>&gt; <br>&gt; Russ_______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/be349c52/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br></p><p>By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br></p><p>On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br></p><p><br>&gt; <br>&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/9027222b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt; I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br>&gt; <br>&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt; <br>&gt; On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br></p><p>Tooling could alleviate some of this mystery. For example:<br></p><p>1) In Xcode and other GUIs, closures that will not be executed could be greyed-out, perhaps with the reason overlaid on the closure perhaps this would only happen when a breakpoint was set within the closure. Perhaps the app could break on the on breakpoints within non-executing closures and notify the user that the closure did not execute.<br></p><p>2) Debugger console commands could be added to describe the execution state of closures in scope and closure variables.<br></p><p>3) Debug apps could bottleneck all closures through a function that that can be break-pointed. Breakpoints could be edited to filter on specific closures. <br></p><p>4) Some runtime switches could be added to enable verbose login modes for closures.<br></p><p>I don’t think that this is an insurmountable problem. There are many features of modern applications that are difficult to debug.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/eb20f24d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>June 27, 2016 at 08:00:00pm</p></header><div class="content"><p>My 2c:<br></p><p>This proposal is made more appealing to me because it is not simply a<br>&#39;beginners will get confused&#39; issue.<br></p><p>I have written tens of thousands of lines of Swift from Swift 1 to the<br>Swift 3 preview and I still can&#39;t shake occasionally accidentally capturing<br>`self` strongly when I, for example, assign a closure as a listener/action<br>to a UI component.<br></p><p>To spin off of Christopher&#39;s last email, my proposal is thus: we could<br>include the original proposal (without numbered addendums) and use tooling,<br>but have it alleviate the burden another way: have the tooling insert<br>`[strong self]` by default when autocompleting a block.<br></p><p>BTW, @Manuel Krebber: this proposal would not affect your run-of-the-mill<br>map statement. array.map { object in object.property } requires no explicit<br>capture since object is intuitively strongly captured there.<br></p><p>What do we think? Worth discussing?<br></p><p>On Mon, Jun 27, 2016 at 12:10 PM Christopher Kornher via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;    All object references used within a closure must unwrap successfully<br>&gt;    for the closure to execute.<br>&gt;<br>&gt; I agree with the logic of this proposal, but this is the confusing part or<br>&gt; a part that I slightly disagree with.<br>&gt;<br>&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t<br>&gt; be unwrapped, which is definitely confusing to the newcomer (to whom this<br>&gt; is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it<br>&gt; and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt;<br>&gt; On the other hand, when it crashes, it gives him some idea that<br>&gt; something&#39;s wrong.<br>&gt;<br>&gt;<br>&gt; Tooling could alleviate some of this mystery. For example:<br>&gt;<br>&gt; 1) In Xcode and other GUIs, closures that will not be executed could be<br>&gt; greyed-out, perhaps with the reason overlaid on the closure perhaps this<br>&gt; would only happen when a breakpoint was set within the closure. Perhaps the<br>&gt; app could break on the on breakpoints within non-executing closures and<br>&gt; notify the user that the closure did not execute.<br>&gt;<br>&gt; 2) Debugger console commands could be added to describe the execution<br>&gt; state of closures in scope and closure variables.<br>&gt;<br>&gt; 3) Debug apps could bottleneck all closures through a function that that<br>&gt; can be break-pointed. Breakpoints could be edited to filter on specific<br>&gt; closures.<br>&gt;<br>&gt; 4) Some runtime switches could be added to enable verbose login modes for<br>&gt; closures.<br>&gt;<br>&gt; I don’t think that this is an insurmountable problem. There are many<br>&gt; features of modern applications that are difficult to debug.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; I believe that these are safe, sensible and understandable rules that will<br>&gt; eliminate the need for capture lists for many closures. What do you think?<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/60bdb94f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jun 27, 2016, at 10:18 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My 2c:<br>&gt; <br>&gt; This proposal is made more appealing to me because it is not simply a &#39;beginners will get confused&#39; issue. <br>&gt; <br>&gt; I have written tens of thousands of lines of Swift from Swift 1 to the Swift 3 preview and I still can&#39;t shake occasionally accidentally capturing `self` strongly when I, for example, assign a closure as a listener/action to a UI component.<br></p><p>The problem of is that it is easier for an app to survive an accidental extra capture than it is for it the survive a missing one.. So if this is really for beginners, then it is much better to keep the current behavior which will lead them to have leaky apps, than it is to give them apps whre objects will vanish from under their feet... granted neither is good to begin with.<br></p><p><br>&gt; <br>&gt; To spin off of Christopher&#39;s last email, my proposal is thus: we could include the original proposal (without numbered addendums) and use tooling, but have it alleviate the burden another way: have the tooling insert `[strong self]` by default when autocompleting a block.<br>&gt; <br>&gt; BTW, @Manuel Krebber: this proposal would not affect your run-of-the-mill map statement. array.map { object in object.property } requires no explicit capture since object is intuitively strongly captured there.<br>&gt; <br>&gt; What do we think? Worth discussing?<br>&gt; <br>&gt; On Mon, Jun 27, 2016 at 12:10 PM Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt;&gt;&gt; I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br>&gt;&gt; <br>&gt;&gt; Tooling could alleviate some of this mystery. For example:<br>&gt;&gt; <br>&gt;&gt; 1) In Xcode and other GUIs, closures that will not be executed could be greyed-out, perhaps with the reason overlaid on the closure perhaps this would only happen when a breakpoint was set within the closure. Perhaps the app could break on the on breakpoints within non-executing closures and notify the user that the closure did not execute.<br>&gt;&gt; <br>&gt;&gt; 2) Debugger console commands could be added to describe the execution state of closures in scope and closure variables.<br>&gt;&gt; <br>&gt;&gt; 3) Debug apps could bottleneck all closures through a function that that can be break-pointed. Breakpoints could be edited to filter on specific closures. <br>&gt;&gt; <br>&gt;&gt; 4) Some runtime switches could be added to enable verbose login modes for closures.<br>&gt;&gt; <br>&gt;&gt; I don’t think that this is an insurmountable problem. There are many features of modern applications that are difficult to debug.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/8995e4d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 2:35 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 27, 2016, at 10:18 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; My 2c:<br>&gt;&gt; <br>&gt;&gt; This proposal is made more appealing to me because it is not simply a &#39;beginners will get confused&#39; issue. <br>&gt;&gt; <br>&gt;&gt; I have written tens of thousands of lines of Swift from Swift 1 to the Swift 3 preview and I still can&#39;t shake occasionally accidentally capturing `self` strongly when I, for example, assign a closure as a listener/action to a UI component.<br>&gt; <br>&gt; The problem of is that it is easier for an app to survive an accidental extra capture than it is for it the survive a missing one.. So if this is really for beginners, then it is much better to keep the current behavior which will lead them to have leaky apps, than it is to give them apps whre objects will vanish from under their feet... granted neither is good to begin with.<br></p><p>For many cases, that is exactly the behavior you want. In my experience, the instances of closures being the only live reference to objects not being constructed by the closure are rare. <br></p><p>To clarify, the proposed implicit guard statements would create strong references once the closure starts executing, so referenced objects would not disappear during the execution of the closure. <br></p><p><br>&gt;&gt; To spin off of Christopher&#39;s last email, my proposal is thus: we could include the original proposal (without numbered addendums) and use tooling, but have it alleviate the burden another way: have the tooling insert `[strong self]` by default when autocompleting a block.<br>&gt;&gt; <br>&gt;&gt; BTW, @Manuel Krebber: this proposal would not affect your run-of-the-mill map statement. array.map { object in object.property } requires no explicit capture since object is intuitively strongly captured there.<br>&gt;&gt; <br>&gt;&gt; What do we think? Worth discussing?<br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 12:10 PM Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt;&gt;&gt; I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br>&gt;&gt; <br>&gt;&gt; Tooling could alleviate some of this mystery. For example:<br>&gt;&gt; <br>&gt;&gt; 1) In Xcode and other GUIs, closures that will not be executed could be greyed-out, perhaps with the reason overlaid on the closure perhaps this would only happen when a breakpoint was set within the closure. Perhaps the app could break on the on breakpoints within non-executing closures and notify the user that the closure did not execute.<br>&gt;&gt; <br>&gt;&gt; 2) Debugger console commands could be added to describe the execution state of closures in scope and closure variables.<br>&gt;&gt; <br>&gt;&gt; 3) Debug apps could bottleneck all closures through a function that that can be break-pointed. Breakpoints could be edited to filter on specific closures. <br>&gt;&gt; <br>&gt;&gt; 4) Some runtime switches could be added to enable verbose login modes for closures.<br>&gt;&gt; <br>&gt;&gt; I don’t think that this is an insurmountable problem. There are many features of modern applications that are difficult to debug.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/2cbf2d75/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 2:35 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt; On Jun 27, 2016, at 10:18 PM, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; My 2c:<br>&gt;&gt; <br>&gt;&gt; This proposal is made more appealing to me because it is not simply a &#39;beginners will get confused&#39; issue. <br>&gt;&gt; <br>&gt;&gt; I have written tens of thousands of lines of Swift from Swift 1 to the Swift 3 preview and I still can&#39;t shake occasionally accidentally capturing `self` strongly when I, for example, assign a closure as a listener/action to a UI component.<br>&gt; <br>&gt; The problem of is that it is easier for an app to survive an accidental extra capture than it is for it the survive a missing one.. So if this is really for beginners, then it is much better to keep the current behavior which will lead them to have leaky apps, than it is to give them apps whre objects will vanish from under their feet... granted neither is good to begin with.<br></p><p>Not always. large memory leaks are often fatal in iOS because of the limited memory footprint. On more constrained devices the problem would e worse.<br></p><p>All of the great feedback has made me realize that my original proposal was more UIKit centric that I thought. One size does not fit all. Any errors in closure memory management can be fatal and the challenge is to optimize the experience for all programming domains and styles.<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; To spin off of Christopher&#39;s last email, my proposal is thus: we could include the original proposal (without numbered addendums) and use tooling, but have it alleviate the burden another way: have the tooling insert `[strong self]` by default when autocompleting a block.<br>&gt;&gt; <br>&gt;&gt; BTW, @Manuel Krebber: this proposal would not affect your run-of-the-mill map statement. array.map { object in object.property } requires no explicit capture since object is intuitively strongly captured there.<br>&gt;&gt; <br>&gt;&gt; What do we think? Worth discussing?<br>&gt;&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 12:10 PM Christopher Kornher via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt;&gt;&gt; I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br>&gt;&gt; <br>&gt;&gt; Tooling could alleviate some of this mystery. For example:<br>&gt;&gt; <br>&gt;&gt; 1) In Xcode and other GUIs, closures that will not be executed could be greyed-out, perhaps with the reason overlaid on the closure perhaps this would only happen when a breakpoint was set within the closure. Perhaps the app could break on the on breakpoints within non-executing closures and notify the user that the closure did not execute.<br>&gt;&gt; <br>&gt;&gt; 2) Debugger console commands could be added to describe the execution state of closures in scope and closure variables.<br>&gt;&gt; <br>&gt;&gt; 3) Debug apps could bottleneck all closures through a function that that can be break-pointed. Breakpoints could be edited to filter on specific closures. <br>&gt;&gt; <br>&gt;&gt; 4) Some runtime switches could be added to enable verbose login modes for closures.<br>&gt;&gt; <br>&gt;&gt; I don’t think that this is an insurmountable problem. There are many features of modern applications that are difficult to debug.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/80e04a5a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 28, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 9:10 PM, Christopher Kornher &lt;ckornher at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt;&gt; I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br>&gt;&gt; <br>&gt;&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt;&gt; <br>&gt;&gt; On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br>&gt; <br>&gt; Tooling could alleviate some of this mystery. For example:<br>&gt; <br>&gt; 1) In Xcode and other GUIs, closures that will not be executed could be greyed-out, perhaps with the reason overlaid on the closure perhaps this would only happen when a breakpoint was set within the closure. Perhaps the app could break on the on breakpoints within non-executing closures and notify the user that the closure did not execute.<br>&gt; <br>&gt; 2) Debugger console commands could be added to describe the execution state of closures in scope and closure variables.<br>&gt; <br>&gt; 3) Debug apps could bottleneck all closures through a function that that can be break-pointed. Breakpoints could be edited to filter on specific closures. <br>&gt; <br>&gt; 4) Some runtime switches could be added to enable verbose login modes for closures.<br></p><p>This can solve issues that you may have with a 2KLOC project that does nothing but waits for the user to click on something. When you have a project of 100KLOC, running at 100% CPU on a background thread, I don&#39;t think you&#39;d debug anything since console would be flooded by thousands of log messages...<br></p><p>&gt; <br>&gt; I don’t think that this is an insurmountable problem. There are many features of modern applications that are difficult to debug.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/b962b97a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 11:52 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:10 PM, Christopher Kornher &lt;ckornher at me.com &lt;mailto:ckornher at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 26, 2016, at 11:22 PM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All object references used within a closure must unwrap successfully for the closure to execute.<br>&gt;&gt;&gt; I agree with the logic of this proposal, but this is the confusing part or a part that I slightly disagree with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By this logic, the block won&#39;t be invoked if all captured variables can&#39;t be unwrapped, which is definitely confusing to the newcomer (to whom this is partially targetted as you&#39;ve mentioned) if he puts a breakpoint in it and doesn&#39;t get executed even when he&#39;s explicitely invoking it somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, when it crashes, it gives him some idea that something&#39;s wrong.<br>&gt;&gt; <br>&gt;&gt; Tooling could alleviate some of this mystery. For example:<br>&gt;&gt; <br>&gt;&gt; 1) In Xcode and other GUIs, closures that will not be executed could be greyed-out, perhaps with the reason overlaid on the closure perhaps this would only happen when a breakpoint was set within the closure. Perhaps the app could break on the on breakpoints within non-executing closures and notify the user that the closure did not execute.<br>&gt;&gt; <br>&gt;&gt; 2) Debugger console commands could be added to describe the execution state of closures in scope and closure variables.<br>&gt;&gt; <br>&gt;&gt; 3) Debug apps could bottleneck all closures through a function that that can be break-pointed. Breakpoints could be edited to filter on specific closures. <br>&gt;&gt; <br>&gt;&gt; 4) Some runtime switches could be added to enable verbose login modes for closures.<br>&gt; <br>&gt; This can solve issues that you may have with a 2KLOC project that does nothing but waits for the user to click on something. When you have a project of 100KLOC, running at 100% CPU on a background thread, I don&#39;t think you&#39;d debug anything since console would be flooded by thousands of log messages…<br></p><p>This technique is used with CoreData, OS X Bindings, and probably other frameworks and yes, it is often a tool of last resort. Tools like grep and spunk are often needed to make use of the output, but this is an effective technique, if not a very efficient one. I much prefer interactive debugger support. One advantage of global logging options is that they can be to used over long periods, on remote machines to capture infrequent errors. <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; I don’t think that this is an insurmountable problem. There are many features of modern applications that are difficult to debug.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I believe that these are safe, sensible and understandable rules that will eliminate the need for capture lists for many closures. What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/f15b8f35/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/26f915253dca7b08d59b61c883ae2e54?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>admin at wheerd.de</string> &lt;admin at wheerd.de&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>On 06/26/2016 09:10 PM, Christopher Kornher via swift-evolution wrote:<br>&gt; The core proposal:<br>&gt; ——————<br>&gt;<br>&gt; Closures capturing object references should automatically capture all<br>&gt; object references as weak.<br>In my code, most closures are used in a functional programming capacity,<br>e.g. with map(), reduce, etc. Hence, most closures are non-escaping and<br>local, where strong capture is the desired way. Otherwise I would have<br>to litter everything with optional unwrapping or add the explicit<br>capture definition which would both make the code less readable in my<br>opinion.<br>&gt; 1) Closures with object references could be simplified further by<br>&gt; implicitly including ‘let’ guards for all object references:<br>This sounds good for closures without return value, but how would you<br>handle closures with non-optional non-void return values?<br>Also I think that explicit error handling in case of &quot;expired&quot; objects<br>is safer than silent failure (by not executing the closure).<br></p><p>Kind regards, Manuel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 2:45 AM, Manuel Krebber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 06/26/2016 09:10 PM, Christopher Kornher via swift-evolution wrote:<br>&gt;&gt; The core proposal:<br>&gt;&gt; ——————<br>&gt;&gt; <br>&gt;&gt; Closures capturing object references should automatically capture all<br>&gt;&gt; object references as weak.<br>&gt; In my code, most closures are used in a functional programming capacity,<br>&gt; e.g. with map(), reduce, etc. Hence, most closures are non-escaping and<br>&gt; local, where strong capture is the desired way. Otherwise I would have<br>&gt; to litter everything with optional unwrapping or add the explicit<br>&gt; capture definition which would both make the code less readable in my<br>&gt; opinion.<br></p><p>I thought about this some more and it makes sense to treat non-escaping closures are they are treated now. This might increase the burden on the compiler especially because these closures may not be declared inline. This would be far more straightforward than having to worry about changes to object existence within one or more invocations of a @nonescaping closure, especially in multi-threaded code.<br></p><p>I do not think that this would be a significant change for developers in practice. Any developer who would try to rely upon object references changing within the application of a @nonescaping closure would probably have read the manual very carefully :)<br></p><p><br>&gt;&gt; 1) Closures with object references could be simplified further by<br>&gt;&gt; implicitly including ‘let’ guards for all object references:<br>&gt; This sounds good for closures without return value, but how would you<br>&gt; handle closures with non-optional non-void return values?<br></p><p>Good point.<br></p><p>1) The simplest solution would be to have these closures require capture lists to some or all object references. Given the prevalence of the weak/strong dance, calling these out in some way probably should be done anyway.<br></p><p>2) Another option would be to eliminate the implicit nil check guards, making all object references optional. The compiler would force these to be unwrapped, so users would be guided to do the right thing.<br></p><p>3) Just always weakly capturing all object references would treat all closures uniformly.<br></p><p>&gt; Also I think that explicit error handling in case of &quot;expired&quot; objects<br>&gt; is safer than silent failure (by not executing the closure).<br></p><p><br>I believe that it is decision that should be left up to the author of the closure. Sometimes it is, sometimes it isn’t.<br></p><p>&gt; <br>&gt; Kind regards, Manuel<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/26f915253dca7b08d59b61c883ae2e54?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>admin at wheerd.de</string> &lt;admin at wheerd.de&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>Am 27.06.2016 20:55, schrieb Christopher Kornher:<br>&gt;&gt; On Jun 27, 2016, at 2:45 AM, Manuel Krebber via swift-evolution <br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On 06/26/2016 09:10 PM, Christopher Kornher via swift-evolution wrote:<br>&gt;&gt;&gt; The core proposal:<br>&gt;&gt;&gt; ——————<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Closures capturing object references should automatically capture all<br>&gt;&gt;&gt; object references as weak.<br>&gt;&gt; In my code, most closures are used in a functional programming <br>&gt;&gt; capacity,<br>&gt;&gt; e.g. with map(), reduce, etc. Hence, most closures are non-escaping <br>&gt;&gt; and<br>&gt;&gt; local, where strong capture is the desired way. Otherwise I would have<br>&gt;&gt; to litter everything with optional unwrapping or add the explicit<br>&gt;&gt; capture definition which would both make the code less readable in my<br>&gt;&gt; opinion.<br>&gt; <br>&gt; I thought about this some more and it makes sense to treat<br>&gt; non-escaping closures are they are treated now. This might increase<br>&gt; the burden on the compiler especially because these closures may not<br>&gt; be declared inline. This would be far more straightforward than having<br>&gt; to worry about changes to object existence within one or more<br>&gt; invocations of a @nonescaping closure, especially in multi-threaded<br>&gt; code.<br>&gt; <br>&gt; I do not think that this would be a significant change for developers<br>&gt; in practice. Any developer who would try to rely upon object<br>&gt; references changing within the application of a @nonescaping closure<br>&gt; would probably have read the manual very carefully :)<br>&gt; <br>&gt; <br></p><p>I am unsure whether treating closures differently depending on a <br>@nonescaping attribute on a function is a good idea.<br>The problem is that, theoretically, the closure might be stored in a <br>variable or used with different functions. Then how do you decide <br>whether the default is strong or weak capture?<br></p><p>Example:<br></p><p>func f1(_ f : (Int) -&gt; Int) {<br>...<br>}<br></p><p>func f2(_ f : @noescape  (Int) -&gt; Int) {<br>...<br>}<br></p><p>let foo = Foo()<br>let f : (Int) -&gt; Int = {<br>   return foo.x<br>}<br></p><p>f1(f)<br>f2(f)<br></p><p>In addition different default capture behaviour dependant on context <br>could be confusing for developers I think.<br></p><p>&gt;&gt;&gt; 1) Closures with object references could be simplified further by<br>&gt;&gt;&gt; implicitly including ‘let’ guards for all object references:<br>&gt;&gt; This sounds good for closures without return value, but how would you<br>&gt;&gt; handle closures with non-optional non-void return values?<br>&gt; <br>&gt; Good point.<br>&gt; <br>&gt; 1) The simplest solution would be to have these closures require<br>&gt; capture lists to some or all object references. Given the prevalence<br>&gt; of the weak/strong dance, calling these out in some way probably<br>&gt; should be done anyway.<br>&gt; <br>&gt; 2) Another option would be to eliminate the implicit nil check guards,<br>&gt; making all object references optional. The compiler would force these<br>&gt; to be unwrapped, so users would be guided to do the right thing.<br>&gt; <br>&gt; 3) Just always weakly capturing all object references would treat all<br>&gt; closures uniformly.<br>&gt; <br></p><p>I think I favour 2) out of these, even though it still means the code <br>will potentially be littered with ?. or let guards...<br></p><p>Kind regards, Manuel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4a9841be165fb834d08296761b4a32e3?s=50"></div><header><strong>An upcoming proposal for simplifying leak free, safe closures.</strong> from <string>Christopher Kornher</string> &lt;ckornher at me.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 6:53 AM, admin at wheerd.de wrote:<br>&gt; <br>&gt; Am 27.06.2016 20:55, schrieb Christopher Kornher:<br>&gt;&gt;&gt; On Jun 27, 2016, at 2:45 AM, Manuel Krebber via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On 06/26/2016 09:10 PM, Christopher Kornher via swift-evolution wrote:<br>&gt;&gt;&gt;&gt; The core proposal:<br>&gt;&gt;&gt;&gt; ——————<br>&gt;&gt;&gt;&gt; Closures capturing object references should automatically capture all<br>&gt;&gt;&gt;&gt; object references as weak.<br>&gt;&gt;&gt; In my code, most closures are used in a functional programming capacity,<br>&gt;&gt;&gt; e.g. with map(), reduce, etc. Hence, most closures are non-escaping and<br>&gt;&gt;&gt; local, where strong capture is the desired way. Otherwise I would have<br>&gt;&gt;&gt; to litter everything with optional unwrapping or add the explicit<br>&gt;&gt;&gt; capture definition which would both make the code less readable in my<br>&gt;&gt;&gt; opinion.<br>&gt;&gt; I thought about this some more and it makes sense to treat<br>&gt;&gt; non-escaping closures are they are treated now. This might increase<br>&gt;&gt; the burden on the compiler especially because these closures may not<br>&gt;&gt; be declared inline. This would be far more straightforward than having<br>&gt;&gt; to worry about changes to object existence within one or more<br>&gt;&gt; invocations of a @nonescaping closure, especially in multi-threaded<br>&gt;&gt; code.<br>&gt;&gt; I do not think that this would be a significant change for developers<br>&gt;&gt; in practice. Any developer who would try to rely upon object<br>&gt;&gt; references changing within the application of a @nonescaping closure<br>&gt;&gt; would probably have read the manual very carefully :)<br>&gt; <br>&gt; I am unsure whether treating closures differently depending on a @nonescaping attribute on a function is a good idea.<br>&gt; The problem is that, theoretically, the closure might be stored in a variable or used with different functions. Then how do you decide whether the default is strong or weak capture?<br></p><p>The compiler/runtime (in theory at least) knows how a closure is going to be applied. I am not a compiler writer, but two versions of the closure could be created when necessary and the appropriate one could be used depending upon the context.<br></p><p>&gt; <br>&gt; Example:<br>&gt; <br>&gt; func f1(_ f : (Int) -&gt; Int) {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; func f2(_ f : @noescape  (Int) -&gt; Int) {<br>&gt; ...<br>&gt; }<br>&gt; <br>&gt; let foo = Foo()<br>&gt; let f : (Int) -&gt; Int = {<br>&gt;  return foo.x<br>&gt; }<br>&gt; <br>&gt; f1(f)<br>&gt; f2(f)<br>&gt; <br>&gt; In addition different default capture behaviour dependant on context could be confusing for developers I think.<br></p><p>The changes in behavior in the application of @noescaping closures are very much] edge case and are as likely to result from actions in other threads as anything else. So Capturing references as strong by default makes @noescaping closures more predictable and eliminates the potential for really some really subtle bug and race conditions.<br></p><p>For the same reason, implicit “let guards” in escaping closures should be applied early to improve predicability. Developers wanting to modify reference counts within closures are free to use traditional capture lists and capture and un-capture references as needed.<br></p><p>Memory management within closures should not be the default behavior, but it should be possible and discoverable. <br></p><p><br>&gt; <br>&gt;&gt;&gt;&gt; 1) Closures with object references could be simplified further by<br>&gt;&gt;&gt;&gt; implicitly including ‘let’ guards for all object references:<br>&gt;&gt;&gt; This sounds good for closures without return value, but how would you<br>&gt;&gt;&gt; handle closures with non-optional non-void return values?<br>&gt;&gt; Good point.<br>&gt;&gt; 1) The simplest solution would be to have these closures require<br>&gt;&gt; capture lists to some or all object references. Given the prevalence<br>&gt;&gt; of the weak/strong dance, calling these out in some way probably<br>&gt;&gt; should be done anyway.<br>&gt;&gt; 2) Another option would be to eliminate the implicit nil check guards,<br>&gt;&gt; making all object references optional. The compiler would force these<br>&gt;&gt; to be unwrapped, so users would be guided to do the right thing.<br>&gt;&gt; 3) Just always weakly capturing all object references would treat all<br>&gt;&gt; closures uniformly.<br>&gt; <br>&gt; I think I favour 2) out of these, even though it still means the code will potentially be littered with ?. or let guards...<br>&gt; <br>&gt; Kind regards, Manuel<br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
