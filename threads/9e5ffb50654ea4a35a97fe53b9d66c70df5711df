<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>January  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Introduction of interfaces will clean up the current blend of static and<br>dynamic protocols, and solve at least three popular issues.<br>Please see:<br>https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/9e5f11df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January  3, 2016 at 09:00:00am</p></header><div class="content"><p>I like this, and had considered proposing something similar.<br></p><p>Points:<br>I would have chose to leave protocol to mean the dynamically dispatch-able type declaration, as that is what it indicates in Objective-C. Your proposal would cause every Objective-C protocol to now be considered an interface in Swift terms.<br></p><p>Some discussion on this list makes me think that you might instead have a modifier for declaring statically dispatched, existential protocols - e.g. “existential protocol SequenceType { … }”<br></p><p>Also, note not all usage of Self need be disallowed in dynamically dispatch-able types today:<br></p><p>protocol Test { <br>     func foo() -&gt; Self <br>}    <br></p><p>var t:Test? // legal, I assume on purpose due to the covariance of the return type<br></p><p>-DW<br></p><p>&gt; On Jan 3, 2016, at 7:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt; Please see:<br>&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/2a1ab885/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jan 3, 2016, at 10:53 AM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I like this, and had considered proposing something similar.<br>&gt; <br>&gt; Points:<br>&gt; I would have chose to leave protocol to mean the dynamically dispatch-able type declaration, as that is what it indicates in Objective-C. Your proposal would cause every Objective-C protocol to now be considered an interface in Swift terms.<br>&gt; <br>&gt; Some discussion on this list makes me think that you might instead have a modifier for declaring statically dispatched, existential protocols - e.g. “existential protocol SequenceType { … }”<br></p><p>The problem with *requiring* distinct syntax for protocols that are intended to be used as existential a is that it is a stated goal to expand the kinds of protocols which can be used as existentials.  In other words, the set of protocols that can be used as existentials is a moving target that is likely to grow substantially in the future.<br></p><p>I would be comfortable with some kind of optional assertion that a protocol can be used as an existential but probably not comfortable with anything more than that.<br></p><p>&gt; <br>&gt; Also, note not all usage of Self need be disallowed in dynamically dispatch-able types today:<br>&gt; <br>&gt; protocol Test { <br>&gt;      func foo() -&gt; Self <br>&gt; }    <br>&gt; <br>&gt; var t:Test? // legal, I assume on purpose due to the covariance of the return type<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 7:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt; Please see:<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/80995259/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  3, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt; Please see:<br>&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br></p><p>I am *completely* against this proposal.<br></p><p>Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br></p><p>  func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>    // give the name T to the dynamic type stored in xT<br>    let xT = open x as T<br>    // is y also storing a T?<br>    guard let yT = y as? T else { return false }<br>    // check whether the Ts are equal<br>    return xT == yT<br>  }<br></p><p>Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br></p><p>Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br></p><p>As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/b83ba82d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January  3, 2016 at 05:00:00pm</p></header><div class="content"><p>This would be wonderful - is it something that could happen in the Swift 3 timeframe? Is it something that myself or someone else could work on a formal proposal for?<br></p><p>-DW<br></p><p>&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt; Please see:<br>&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt; I am *completely* against this proposal.<br>&gt; <br>&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt; <br>&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;     // give the name T to the dynamic type stored in xT<br>&gt;     let xT = open x as T<br>&gt;     // is y also storing a T?<br>&gt;     guard let yT = y as? T else { return false }<br>&gt;     // check whether the Ts are equal<br>&gt;     return xT == yT<br>&gt;   }<br>&gt; <br>&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt; <br>&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt; <br>&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/38de8fcd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January  3, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 to &quot;opening&quot; values of existential type, I remember trying (and failing)<br>to do this when Swift 1 came out. Being able to capture the dynamic type of<br>an object at runtime and do stuff with it would be incredible.<br></p><p>Austin<br></p><p>On Sun, Jan 3, 2016 at 4:19 PM, David Waite via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This would be wonderful - is it something that could happen in the Swift 3<br>&gt; timeframe? Is it something that myself or someone else could work on a<br>&gt; formal proposal for?<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Introduction of interfaces will clean up the current blend of static and<br>&gt; dynamic protocols, and solve at least three popular issues.<br>&gt; Please see:<br>&gt;<br>&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br>&gt;<br>&gt;<br>&gt; I am *completely* against this proposal.<br>&gt;<br>&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with<br>&gt; Self or associated type requirements can&#39;t be existential. But it&#39;s just a<br>&gt; limitation that isn&#39;t (conceptually) that hard to fix: the primary<br>&gt; operation you need to work with an existing of such a protocol is to &quot;open&quot;<br>&gt; a value of existential type, giving a name to the dynamic type it stores.<br>&gt; Let&#39;s invent one:<br>&gt;<br>&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;     // give the name T to the dynamic type stored in xT<br>&gt;     let xT = open x as T<br>&gt;     // is y also storing a T?<br>&gt;     guard let yT = y as? T else { return false }<br>&gt;     // check whether the Ts are equal<br>&gt;     return xT == yT<br>&gt;   }<br>&gt;<br>&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential<br>&gt; thing back to something more &quot;static&quot;, just by giving a name to the type.<br>&gt; Swift generics aren&#39;t really even static in any sense: what the do is give<br>&gt; names to the types of values so one can establish relationships among<br>&gt; different values. &quot;open..as&quot; would do that for existentials.<br>&gt;<br>&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot;<br>&gt; operations that do this internally. They have no spelling in Swift code,<br>&gt; but they are useful to describe operations on existentials. At present,<br>&gt; they cannot be formed when the existential involves a protocol with Self or<br>&gt; associated type requirements, but that&#39;s a limitation that isn&#39;t hard to<br>&gt; address.<br>&gt;<br>&gt; As for your concerns about knowing when one can dynamically override and<br>&gt; when one cannot...  There are issues here that need to be addressed. They<br>&gt; aren&#39;t significant enough to warrant such a drastic change, and may not<br>&gt; even require language changes at all.<br>&gt;<br>&gt; - Doug<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/33e7889f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  3, 2016 at 08:00:00pm</p></header><div class="content"><p>I offer a +1, but I have two criticisms of the proposal.<br></p><p>The first is that the example given in the proposal is stated a lot more strongly than is true:<br></p><p>&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;   if first &lt; second {<br>&gt;     return -1<br>&gt;   }<br>&gt;   //...<br>&gt; }<br>&gt; The code above yields an error, and rightfully so, because if the real types of first and second are not equal, they cannot actually be compared.<br>&gt; <br>It is true for Swift 2 code.  However, whether this is true forever is less clear.  There is a thread here discussing &quot;existential protocols&quot;, which AFAIK would make this code listing into a non-error, and in that thread Douglas Gregor said:<br></p><p>&gt; Do recall that I’m saying “not now” rather than “not ever” for this feature. I think it’s very, very cool, but it’s complicated and we need a while to understand its overall effects.<br></p><p>As long as the door is open to allowing the syntax, I think saying something strong and normative about it in an official proposal would be a mistake.  The example is fine, but the comment should be that this &quot;currently errors&quot; or &quot;surprises new programmers&quot; or something weaker than &quot;it&#39;s obvious to all of us this shouldn&#39;t work&quot; because it&#39;s obvious to some people that it should work after all.<br></p><p>The second thing is that I think using the words &quot;dynamically dispatched&quot; or &quot;dynamically dispatched interfaces&quot; in the body of the proposal is a mistake.  It is not that interfaces &quot;are&quot; dynamically dispatched.  It is that they may be, e.g. that the compiler may select a dynamic implementation (or it may be able to find a static implementation), whereas for a protocol the compiler is guaranteed to use a static implementation.  This is I think more consistent with CL&#39;s position on static/dynamic in Swift &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001948.html&gt; generally.  So I think we should find a turn of phrase like &quot;behaves dynamically&quot; or &quot;has dynamic dispatch semantics&quot; rather than saying &quot;it *is* dynamically dispatched&quot; as if we will force the optimizer to spit out a vtable when it can find a static implementation.<br></p><p>With those two details resolved I think it is a strong proposal, and very much in line with the proposal we&#39;re reviewing about separating typealias vs associatedtype, which strikes at a similar confusion where we&#39;re separating two different concepts into their own keywords.<br></p><p><br>&gt; On Jan 3, 2016, at 7:44 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1 to &quot;opening&quot; values of existential type, I remember trying (and failing) to do this when Swift 1 came out. Being able to capture the dynamic type of an object at runtime and do stuff with it would be incredible.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt; On Sun, Jan 3, 2016 at 4:19 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe? Is it something that myself or someone else could work on a formal proposal for?<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt; <br>&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt; <br>&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;     let xT = open x as T<br>&gt;&gt;     // is y also storing a T?<br>&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;     return xT == yT<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt; <br>&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt; <br>&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/4a520a3d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 8:52 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I offer a +1, but I have two criticisms of the proposal.<br>&gt; <br>&gt; The first is that the example given in the proposal is stated a lot more strongly than is true:<br>&gt; <br>&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;   if first &lt; second {<br>&gt;&gt;     return -1<br>&gt;&gt;   }<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt;&gt; The code above yields an error, and rightfully so, because if the real types of first and second are not equal, they cannot actually be compared.<br>&gt;&gt; <br>&gt; It is true for Swift 2 code.  However, whether this is true forever is less clear.  There is a thread here discussing &quot;existential protocols&quot;, which AFAIK would make this code listing into a non-error, and in that thread Douglas Gregor said:<br>&gt; <br>&gt;&gt; Do recall that I’m saying “not now” rather than “not ever” for this feature. I think it’s very, very cool, but it’s complicated and we need a while to understand its overall effects.<br></p><p>Existentials for protocols with Self and / or associated type requirements would require bindings for Self and / or the associated type(s).  At least when you use a member that contains Self and / or an associated type in its signature.  So the previous example will always fail to compile. <br></p><p>&gt; <br>&gt; As long as the door is open to allowing the syntax, I think saying something strong and normative about it in an official proposal would be a mistake.  The example is fine, but the comment should be that this &quot;currently errors&quot; or &quot;surprises new programmers&quot; or something weaker than &quot;it&#39;s obvious to all of us this shouldn&#39;t work&quot; because it&#39;s obvious to some people that it should work after all.<br>&gt; <br>&gt; The second thing is that I think using the words &quot;dynamically dispatched&quot; or &quot;dynamically dispatched interfaces&quot; in the body of the proposal is a mistake.  It is not that interfaces &quot;are&quot; dynamically dispatched.  It is that they may be, e.g. that the compiler may select a dynamic implementation (or it may be able to find a static implementation), whereas for a protocol the compiler is guaranteed to use a static implementation.  This is I think more consistent with CL&#39;s position on static/dynamic in Swift &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001948.html&gt; generally.  So I think we should find a turn of phrase like &quot;behaves dynamically&quot; or &quot;has dynamic dispatch semantics&quot; rather than saying &quot;it *is* dynamically dispatched&quot; as if we will force the optimizer to spit out a vtable when it can find a static implementation.<br>&gt; <br>&gt; With those two details resolved I think it is a strong proposal, and very much in line with the proposal we&#39;re reviewing about separating typealias vs associatedtype, which strikes at a similar confusion where we&#39;re separating two different concepts into their own keywords.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 7:44 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 to &quot;opening&quot; values of existential type, I remember trying (and failing) to do this when Swift 1 came out. Being able to capture the dynamic type of an object at runtime and do stuff with it would be incredible.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt; On Sun, Jan 3, 2016 at 4:19 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe? Is it something that myself or someone else could work on a formal proposal for?<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt;&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;&gt;     let xT = open x as T<br>&gt;&gt;&gt;     // is y also storing a T?<br>&gt;&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;&gt;     return xT == yT<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/223d481f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Existentials for protocols with Self and / or associated type requirements would require bindings for Self and / or the associated type(s).  At least when you use a member that contains Self and / or an associated type in its signature.  So the previous example will always fail to compile. <br></p><p>Not true.  Joe Groff:<br></p><p>&gt; This seems like it would be addressed just by allowing Factory to be used as a dynamic type, with its Product type generalized to Any. We&#39;ll be set up to support that with some runtime work to store associated types in protocol witness tables (which is also necessary to fix cyclic conformances, one of our Swift 3 goals).<br></p><p><br>&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 9:08 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt;&gt; Existentials for protocols with Self and / or associated type requirements would require bindings for Self and / or the associated type(s).  At least when you use a member that contains Self and / or an associated type in its signature.  So the previous example will always fail to compile. <br>&gt; <br>&gt; Not true.  Joe Groff:<br></p><p>Can you point me to the source?  I would like more context around these comments.<br></p><p>&gt; <br>&gt;&gt; This seems like it would be addressed just by allowing Factory to be used as a dynamic type, with its Product type generalized to Any. We&#39;ll be set up to support that with some runtime work to store associated types in protocol witness tables (which is also necessary to fix cyclic conformances, one of our Swift 3 goals).<br>&gt; <br>&gt; <br>&gt;&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>January  3, 2016 at 09:00:00pm</p></header><div class="content"><p>Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br></p><p><br>&gt; On Jan 3, 2016, at 9:10 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 9:08 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Existentials for protocols with Self and / or associated type requirements would require bindings for Self and / or the associated type(s).  At least when you use a member that contains Self and / or an associated type in its signature.  So the previous example will always fail to compile. <br>&gt;&gt; <br>&gt;&gt; Not true.  Joe Groff:<br>&gt; <br>&gt; Can you point me to the source?  I would like more context around these comments.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; This seems like it would be addressed just by allowing Factory to be used as a dynamic type, with its Product type generalized to Any. We&#39;ll be set up to support that with some runtime work to store associated types in protocol witness tables (which is also necessary to fix cyclic conformances, one of our Swift 3 goals).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/e5ec9cba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  3, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 9:14 PM, Drew Crawford &lt;drew at sealedabstract.com&gt; wrote:<br>&gt; <br>&gt; Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br>Thanks.  Joe was basically saying is that associated types would be automatically bound to the existential for their constraints, or Any if there are no constraints.  <br></p><p>He didn’t specifically mention anything about Self, but I suppose Self requirements could also be automatically bound to Any if the existential type doesn’t specify anything more specific, although I’m not sure I would like that behavior.<br></p><p>Self is what would apply in the case of:<br></p><p>&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;   if first &lt; second {<br>&gt;     return -1<br>&gt;   }<br>&gt;   //...<br>&gt; }<br>If Self were automatically bound to Any what would this do?  Would it compile and invoke a `&lt;` operator that takes two Any parameters?  That doesn’t seem to make sense to me.  It certainly wouldn’t guarantee you get the correct behavior if first and second were both Int for example.<br></p><p><br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 9:10 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 9:08 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Existentials for protocols with Self and / or associated type requirements would require bindings for Self and / or the associated type(s).  At least when you use a member that contains Self and / or an associated type in its signature.  So the previous example will always fail to compile. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not true.  Joe Groff:<br>&gt;&gt; <br>&gt;&gt; Can you point me to the source?  I would like more context around these comments.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems like it would be addressed just by allowing Factory to be used as a dynamic type, with its Product type generalized to Any. We&#39;ll be set up to support that with some runtime work to store associated types in protocol witness tables (which is also necessary to fix cyclic conformances, one of our Swift 3 goals).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160103/feae2001/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 10:44 PM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 9:14 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br>&gt; Thanks.  Joe was basically saying is that associated types would be automatically bound to the existential for their constraints, or Any if there are no constraints.  <br>&gt; <br>&gt; He didn’t specifically mention anything about Self, but I suppose Self requirements could also be automatically bound to Any if the existential type doesn’t specify anything more specific, although I’m not sure I would like that behavior.<br>&gt; <br>&gt; Self is what would apply in the case of:<br>&gt; <br>&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;   if first &lt; second {<br>&gt;&gt;     return -1<br>&gt;&gt;   }<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt; If Self were automatically bound to Any what would this do?  Would it compile and invoke a `&lt;` operator that takes two Any parameters?  That doesn’t seem to make sense to me.  It certainly wouldn’t guarantee you get the correct behavior if first and second were both Int for example.<br></p><p>I gave this some further thought last night and realized what would happen here is pretty clear.  I hadn’t considered existentials where associated types aren’t bound to concrete types before so it just took a few minutes to work through.<br></p><p>Existentials reference a witness table pointing to an actual implementations of the protocol requirements.  Actual implementations require parameters of concrete types.  This means that you must know what that concrete type is and supply a value of that type in order to actually call the member.  The implication of this is that members which require parameters of an associated type that is not bound to a concrete type will not be available on that existential.  <br></p><p>In this example, `&lt;` requires two arguments of type Self.  However, the `Comparable` existential, if allowed, would have Self bound to `Any`, not a concrete type.  Therefore `&lt;` would not be available and you would receive a compiler error on that line.  It would be different than the current error and on a different line of code but it would still fail to compile.<br></p><p>With return types, you do not necessarily need to know the concrete type returned by the implementation.  Swift could theoretically box the result itself into an existential and return that to the caller.  I do not know whether this is the actual design that will be implemented or not.<br></p><p>If I any of the above details are incorrect I hope Joe or someone else will correct me.  :)<br></p><p>Matthew<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 9:10 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 9:08 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Existentials for protocols with Self and / or associated type requirements would require bindings for Self and / or the associated type(s).  At least when you use a member that contains Self and / or an associated type in its signature.  So the previous example will always fail to compile. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not true.  Joe Groff:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you point me to the source?  I would like more context around these comments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems like it would be addressed just by allowing Factory to be used as a dynamic type, with its Product type generalized to Any. We&#39;ll be set up to support that with some runtime work to store associated types in protocol witness tables (which is also necessary to fix cyclic conformances, one of our Swift 3 goals).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yeah, when generalizing a protocol type, we ought to be able to either generalize the associated types to their upper bounds, for use cases like yours, or constrain them to specific types, for the AnyGenerator&lt;T&gt; kind of case.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/b766a3b9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 6:24 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 3, 2016, at 10:44 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 9:14 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br>&gt;&gt; Thanks.  Joe was basically saying is that associated types would be automatically bound to the existential for their constraints, or Any if there are no constraints.  <br>&gt;&gt; <br>&gt;&gt; He didn’t specifically mention anything about Self, but I suppose Self requirements could also be automatically bound to Any if the existential type doesn’t specify anything more specific, although I’m not sure I would like that behavior.<br>&gt;&gt; <br>&gt;&gt; Self is what would apply in the case of:<br>&gt;&gt; <br>&gt;&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;&gt;   if first &lt; second {<br>&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt;   //...<br>&gt;&gt;&gt; }<br>&gt;&gt; If Self were automatically bound to Any what would this do?  Would it compile and invoke a `&lt;` operator that takes two Any parameters?  That doesn’t seem to make sense to me.  It certainly wouldn’t guarantee you get the correct behavior if first and second were both Int for example.<br>&gt; <br>&gt; I gave this some further thought last night and realized what would happen here is pretty clear.  I hadn’t considered existentials where associated types aren’t bound to concrete types before so it just took a few minutes to work through.<br>&gt; <br>&gt; Existentials reference a witness table pointing to an actual implementations of the protocol requirements.  Actual implementations require parameters of concrete types.  This means that you must know what that concrete type is and supply a value of that type in order to actually call the member.  The implication of this is that members which require parameters of an associated type that is not bound to a concrete type will not be available on that existential.  <br></p><p>There is a concrete type, which is known dynamically to the existential value, but you would need a way to name that type to (e.g.) cast down to it before you could use the member. That’s why the open..as operation I mentioned allows one to use these members: it gives a way to name the type. It actually helps to think of any operation on existentials as implicitly using open..as, because it makes the semantics far more explicit. (The compiler does this internally as well)<br></p><p>&gt; In this example, `&lt;` requires two arguments of type Self.  However, the `Comparable` existential, if allowed, would have Self bound to `Any`, not a concrete type.  Therefore `&lt;` would not be available and you would receive a compiler error on that line.  It would be different than the current error and on a different line of code but it would still fail to compile.<br>&gt; <br>&gt; With return types, you do not necessarily need to know the concrete type returned by the implementation.  Swift could theoretically box the result itself into an existential and return that to the caller.  I do not know whether this is the actual design that will be implemented or not.<br></p><p>It’s a reasonable direction that we’ve discussed in passing but never committed to.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/2475342a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 11:43 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 6:24 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 10:44 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 9:14 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br>&gt;&gt;&gt; Thanks.  Joe was basically saying is that associated types would be automatically bound to the existential for their constraints, or Any if there are no constraints.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; He didn’t specifically mention anything about Self, but I suppose Self requirements could also be automatically bound to Any if the existential type doesn’t specify anything more specific, although I’m not sure I would like that behavior.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Self is what would apply in the case of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;&gt;&gt;   if first &lt; second {<br>&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; If Self were automatically bound to Any what would this do?  Would it compile and invoke a `&lt;` operator that takes two Any parameters?  That doesn’t seem to make sense to me.  It certainly wouldn’t guarantee you get the correct behavior if first and second were both Int for example.<br>&gt;&gt; <br>&gt;&gt; I gave this some further thought last night and realized what would happen here is pretty clear.  I hadn’t considered existentials where associated types aren’t bound to concrete types before so it just took a few minutes to work through.<br>&gt;&gt; <br>&gt;&gt; Existentials reference a witness table pointing to an actual implementations of the protocol requirements.  Actual implementations require parameters of concrete types.  This means that you must know what that concrete type is and supply a value of that type in order to actually call the member.  The implication of this is that members which require parameters of an associated type that is not bound to a concrete type will not be available on that existential.  <br>&gt; <br>&gt; There is a concrete type, which is known dynamically to the existential value, but you would need a way to name that type to (e.g.) cast down to it before you could use the member. That’s why the open..as operation I mentioned allows one to use these members: it gives a way to name the type. It actually helps to think of any operation on existentials as implicitly using open..as, because it makes the semantics far more explicit. (The compiler does this internally as well)<br></p><p>Casting down makes sense and of course you could use the member after that.  But why do we need a special cast operation “open” to do this?  Is there a reason we couldn’t just cast down with the usual operators like we can with `Any`?<br></p><p>&gt; <br>&gt;&gt; In this example, `&lt;` requires two arguments of type Self.  However, the `Comparable` existential, if allowed, would have Self bound to `Any`, not a concrete type.  Therefore `&lt;` would not be available and you would receive a compiler error on that line.  It would be different than the current error and on a different line of code but it would still fail to compile.<br>&gt;&gt; <br>&gt;&gt; With return types, you do not necessarily need to know the concrete type returned by the implementation.  Swift could theoretically box the result itself into an existential and return that to the caller.  I do not know whether this is the actual design that will be implemented or not.<br>&gt; <br>&gt; It’s a reasonable direction that we’ve discussed in passing but never committed to.<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/25bd26ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 9:54 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 11:43 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 6:24 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 10:44 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 9:14 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br>&gt;&gt;&gt;&gt; Thanks.  Joe was basically saying is that associated types would be automatically bound to the existential for their constraints, or Any if there are no constraints.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; He didn’t specifically mention anything about Self, but I suppose Self requirements could also be automatically bound to Any if the existential type doesn’t specify anything more specific, although I’m not sure I would like that behavior.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Self is what would apply in the case of:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;&gt;&gt;&gt;   if first &lt; second {<br>&gt;&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; If Self were automatically bound to Any what would this do?  Would it compile and invoke a `&lt;` operator that takes two Any parameters?  That doesn’t seem to make sense to me.  It certainly wouldn’t guarantee you get the correct behavior if first and second were both Int for example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I gave this some further thought last night and realized what would happen here is pretty clear.  I hadn’t considered existentials where associated types aren’t bound to concrete types before so it just took a few minutes to work through.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Existentials reference a witness table pointing to an actual implementations of the protocol requirements.  Actual implementations require parameters of concrete types.  This means that you must know what that concrete type is and supply a value of that type in order to actually call the member.  The implication of this is that members which require parameters of an associated type that is not bound to a concrete type will not be available on that existential.  <br>&gt;&gt; <br>&gt;&gt; There is a concrete type, which is known dynamically to the existential value, but you would need a way to name that type to (e.g.) cast down to it before you could use the member. That’s why the open..as operation I mentioned allows one to use these members: it gives a way to name the type. It actually helps to think of any operation on existentials as implicitly using open..as, because it makes the semantics far more explicit. (The compiler does this internally as well)<br>&gt; <br>&gt; Casting down makes sense and of course you could use the member after that.  But why do we need a special cast operation “open” to do this?  Is there a reason we couldn’t just cast down with the usual operators like we can with `Any`?<br></p><p>How are you going to name the type you’re casting to?<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/c8811757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 11:56 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 9:54 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 11:43 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 4, 2016, at 6:24 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 10:44 PM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 9:14 PM, Drew Crawford &lt;drew at sealedabstract.com &lt;mailto:drew at sealedabstract.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Sure, here&#39;s the start of the thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20151207/001856.html&gt;<br>&gt;&gt;&gt;&gt;&gt; Thanks.  Joe was basically saying is that associated types would be automatically bound to the existential for their constraints, or Any if there are no constraints.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; He didn’t specifically mention anything about Self, but I suppose Self requirements could also be automatically bound to Any if the existential type doesn’t specify anything more specific, although I’m not sure I would like that behavior.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Self is what would apply in the case of:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;&gt;&gt;&gt;&gt;   if first &lt; second {<br>&gt;&gt;&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;   //...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; If Self were automatically bound to Any what would this do?  Would it compile and invoke a `&lt;` operator that takes two Any parameters?  That doesn’t seem to make sense to me.  It certainly wouldn’t guarantee you get the correct behavior if first and second were both Int for example.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I gave this some further thought last night and realized what would happen here is pretty clear.  I hadn’t considered existentials where associated types aren’t bound to concrete types before so it just took a few minutes to work through.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Existentials reference a witness table pointing to an actual implementations of the protocol requirements.  Actual implementations require parameters of concrete types.  This means that you must know what that concrete type is and supply a value of that type in order to actually call the member.  The implication of this is that members which require parameters of an associated type that is not bound to a concrete type will not be available on that existential.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is a concrete type, which is known dynamically to the existential value, but you would need a way to name that type to (e.g.) cast down to it before you could use the member. That’s why the open..as operation I mentioned allows one to use these members: it gives a way to name the type. It actually helps to think of any operation on existentials as implicitly using open..as, because it makes the semantics far more explicit. (The compiler does this internally as well)<br>&gt;&gt; <br>&gt;&gt; Casting down makes sense and of course you could use the member after that.  But why do we need a special cast operation “open” to do this?  Is there a reason we couldn’t just cast down with the usual operators like we can with `Any`?<br>&gt; <br>&gt; How are you going to name the type you’re casting to?<br></p><p>Ok, I see now.  I missed that you’re introducing a type variable in the open operation.  :)  I mistook T for an arbitrary but concrete type.<br></p><p>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/d1317aa1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>January  4, 2016 at 07:00:00am</p></header><div class="content"><p>In his message Chris stated that protocols are obviously dynamic while in the case of protocol extensions we have default implementations (IMHO out of place in protocols if we see protocols are pure abstract contracts designed to decouple from the actual implementation) and the compiler will use a static implementation just because of the dressing/the type our object is casted as. It just feels wrong and an indication that we are now leaking implementation details we were trying to hide.<br></p><p>I think this is a compiler optimisation which should not be implicitly applied unless it has side effects and this example shows one of those side effects. In such cases, I think we should have a keyword to override the compiler with and strongly hint we want to enforce the compiler to use the static implementation.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 4 Jan 2016, at 02:52, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I offer a +1, but I have two criticisms of the proposal.<br>&gt; <br>&gt; The first is that the example given in the proposal is stated a lot more strongly than is true:<br>&gt; <br>&gt;&gt; func compareTwo(first: Comparable, _ second: Comparable) -&gt; Int {  // error!<br>&gt;&gt;   if first &lt; second {<br>&gt;&gt;     return -1<br>&gt;&gt;   }<br>&gt;&gt;   //...<br>&gt;&gt; }<br>&gt;&gt; The code above yields an error, and rightfully so, because if the real types of first and second are not equal, they cannot actually be compared.<br>&gt;&gt; <br>&gt; It is true for Swift 2 code.  However, whether this is true forever is less clear.  There is a thread here discussing &quot;existential protocols&quot;, which AFAIK would make this code listing into a non-error, and in that thread Douglas Gregor said:<br>&gt; <br>&gt;&gt; Do recall that I’m saying “not now” rather than “not ever” for this feature. I think it’s very, very cool, but it’s complicated and we need a while to understand its overall effects.<br>&gt; <br>&gt; As long as the door is open to allowing the syntax, I think saying something strong and normative about it in an official proposal would be a mistake.  The example is fine, but the comment should be that this &quot;currently errors&quot; or &quot;surprises new programmers&quot; or something weaker than &quot;it&#39;s obvious to all of us this shouldn&#39;t work&quot; because it&#39;s obvious to some people that it should work after all.<br>&gt; <br>&gt; The second thing is that I think using the words &quot;dynamically dispatched&quot; or &quot;dynamically dispatched interfaces&quot; in the body of the proposal is a mistake.  It is not that interfaces &quot;are&quot; dynamically dispatched.  It is that they may be, e.g. that the compiler may select a dynamic implementation (or it may be able to find a static implementation), whereas for a protocol the compiler is guaranteed to use a static implementation.  This is I think more consistent with CL&#39;s position on static/dynamic in Swift generally.  So I think we should find a turn of phrase like &quot;behaves dynamically&quot; or &quot;has dynamic dispatch semantics&quot; rather than saying &quot;it *is* dynamically dispatched&quot; as if we will force the optimizer to spit out a vtable when it can find a static implementation.<br>&gt; <br>&gt; With those two details resolved I think it is a strong proposal, and very much in line with the proposal we&#39;re reviewing about separating typealias vs associatedtype, which strikes at a similar confusion where we&#39;re separating two different concepts into their own keywords.<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 7:44 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; +1 to &quot;opening&quot; values of existential type, I remember trying (and failing) to do this when Swift 1 came out. Being able to capture the dynamic type of an object at runtime and do stuff with it would be incredible.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Sun, Jan 3, 2016 at 4:19 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe? Is it something that myself or someone else could work on a formal proposal for?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;&gt;&gt;     let xT = open x as T<br>&gt;&gt;&gt;&gt;     // is y also storing a T?<br>&gt;&gt;&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;&gt;&gt;     return xT == yT<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/31e81cb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>January  4, 2016 at 03:00:00pm</p></header><div class="content"><p>Cleared up that interfaces can be used in static dispatch as well. Added<br>other possible keyword variants instead of protocol/interface (there may<br>still be more). Added some lines about interoperation with existentials<br>proposal.<br>I agree that current proposal is in opposition of it, and that existentials<br>proposal can be cleaner if properly implemented. Whether the two proposals<br>are compatible, will be more clear once the syntax for existential types is<br>established.<br></p><p>Proposal page:<br>https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/70bd1f65/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 3, 2016, at 4:19 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe?<br></p><p>I hesitate to say “yes” here. I think it fits with the goals of Swift 3, but my main concern is that there isn’t enough engineering bandwidth to implement it for Swift 3.<br></p><p>&gt; Is it something that myself or someone else could work on a formal proposal for?<br></p><p>Yes, absolutely. This is a case where I think it’s useful to design what we want, even if we cannot fit the implementation into the Swift 3 schedule. It’s also a case where the compiler has a lot of the pieces already implemented (with some runtime bits landing soon), so the implementation should not be *that* hard and will likely not require architectural changes.<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt; <br>&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt; <br>&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;     let xT = open x as T<br>&gt;&gt;     // is y also storing a T?<br>&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;     return xT == yT<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt; <br>&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt; <br>&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/ccdf81b3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 12:21 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 3, 2016, at 4:19 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe?<br>&gt; <br>&gt; I hesitate to say “yes” here. I think it fits with the goals of Swift 3, but my main concern is that there isn’t enough engineering bandwidth to implement it for Swift 3.<br>&gt; <br>&gt;&gt; Is it something that myself or someone else could work on a formal proposal for?<br>&gt; <br>&gt; Yes, absolutely. This is a case where I think it’s useful to design what we want, even if we cannot fit the implementation into the Swift 3 schedule. It’s also a case where the compiler has a lot of the pieces already implemented (with some runtime bits landing soon), so the implementation should not be *that* hard and will likely not require architectural changes.<br></p><p>Interesting.  I was under the impression the core team was taking on the generics features.  I am also very interested in helping to accelerate the process if that is possible (whether that means Swift 3 or not).<br></p><p>Are you thinking specifically about unbound existentials like in your Equatable example or also partly / fully bound existentials such as SequenceType&lt;Generator.Element == Int&gt;?<br></p><p>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt;&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;&gt;     let xT = open x as T<br>&gt;&gt;&gt;     // is y also storing a T?<br>&gt;&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;&gt;     return xT == yT<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/4d9144b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January  4, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 12:21 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 3, 2016, at 4:19 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe?<br>&gt;&gt; <br>&gt;&gt; I hesitate to say “yes” here. I think it fits with the goals of Swift 3, but my main concern is that there isn’t enough engineering bandwidth to implement it for Swift 3.<br>&gt;&gt; <br>&gt;&gt;&gt; Is it something that myself or someone else could work on a formal proposal for?<br>&gt;&gt; <br>&gt;&gt; Yes, absolutely. This is a case where I think it’s useful to design what we want, even if we cannot fit the implementation into the Swift 3 schedule. It’s also a case where the compiler has a lot of the pieces already implemented (with some runtime bits landing soon), so the implementation should not be *that* hard and will likely not require architectural changes.<br>&gt; <br>&gt; Interesting.  I was under the impression the core team was taking on the generics features.<br></p><p>We are, and lots of them. I doubt we can handle another.<br></p><p>&gt;  I am also very interested in helping to accelerate the process if that is possible (whether that means Swift 3 or not).<br>&gt; <br>&gt; Are you thinking specifically about unbound existentials like in your Equatable example or also partly / fully bound existentials such as SequenceType&lt;Generator.Element == Int&gt;?<br></p><p>I was thinking mostly about the former. However, the latter is also a highly-requested feature [*] that complements this one, and I think it’s reasonable to discuss both together.<br></p><p>	- Doug<br></p><p>[*] And is often the underlying reason why developers ask for parameterized protocols.<br></p><p><br>&gt; <br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt;&gt;&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;&gt;&gt;     let xT = open x as T<br>&gt;&gt;&gt;&gt;     // is y also storing a T?<br>&gt;&gt;&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;&gt;&gt;     return xT == yT<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/e707772d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] Separate protocols and interfaces</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>January  4, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 12:40 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 12:21 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 3, 2016, at 4:19 PM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would be wonderful - is it something that could happen in the Swift 3 timeframe?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hesitate to say “yes” here. I think it fits with the goals of Swift 3, but my main concern is that there isn’t enough engineering bandwidth to implement it for Swift 3.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is it something that myself or someone else could work on a formal proposal for?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, absolutely. This is a case where I think it’s useful to design what we want, even if we cannot fit the implementation into the Swift 3 schedule. It’s also a case where the compiler has a lot of the pieces already implemented (with some runtime bits landing soon), so the implementation should not be *that* hard and will likely not require architectural changes.<br>&gt;&gt; <br>&gt;&gt; Interesting.  I was under the impression the core team was taking on the generics features. <br>&gt; <br>&gt; We are, and lots of them. I doubt we can handle another.<br>&gt; <br>&gt;&gt;  I am also very interested in helping to accelerate the process if that is possible (whether that means Swift 3 or not).<br>&gt;&gt; <br>&gt;&gt; Are you thinking specifically about unbound existentials like in your Equatable example or also partly / fully bound existentials such as SequenceType&lt;Generator.Element == Int&gt;?<br>&gt; <br>&gt; I was thinking mostly about the former. However, the latter is also a highly-requested feature [*] that complements this one, and I think it’s reasonable to discuss both together.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] And is often the underlying reason why developers ask for parameterized protocols.<br></p><p>Agree.  The other primary motivation I know of for that request is something like ConvertibleTo&lt;T&gt; where you multiple conformances would be possible.  <br></p><p>I am familiar with the reasons why Swift is avoiding that path. :)<br></p><p>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 4:17 PM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 3, 2016, at 6:48 AM, Антон Жилин via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction of interfaces will clean up the current blend of static and dynamic protocols, and solve at least three popular issues.<br>&gt;&gt;&gt;&gt;&gt;&gt; Please see:<br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md &lt;https://github.com/Anton3/swift-evolution/blob/master/proposals/0000-introducing-interfaces.md&gt;<br>&gt;&gt;&gt;&gt;&gt; I am *completely* against this proposal.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fundamentally, you&#39;re trying to address the limitation that protocols with Self or associated type requirements can&#39;t be existential. But it&#39;s just a limitation that isn&#39;t (conceptually) that hard to fix: the primary operation you need to work with an existing of such a protocol is to &quot;open&quot; a value of existential type, giving a name to the dynamic type it stores. Let&#39;s invent one:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   func eq(x: Equatable, y: Equatable) -&gt; Bool {<br>&gt;&gt;&gt;&gt;&gt;     // give the name T to the dynamic type stored in xT<br>&gt;&gt;&gt;&gt;&gt;     let xT = open x as T<br>&gt;&gt;&gt;&gt;&gt;     // is y also storing a T?<br>&gt;&gt;&gt;&gt;&gt;     guard let yT = y as? T else { return false }<br>&gt;&gt;&gt;&gt;&gt;     // check whether the Ts are equal<br>&gt;&gt;&gt;&gt;&gt;     return xT == yT<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Ignore the syntax: semantically, we&#39;ve gone from a &quot;dynamic&quot; existential thing back to something more &quot;static&quot;, just by giving a name to the type. Swift generics aren&#39;t really even static in any sense: what the do is give names to the types of values so one can establish relationships among different values. &quot;open..as&quot; would do that for existentials. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that ether Swift compilers AST and SIL both have &quot;open existential&quot; operations that do this internally. They have no spelling in Swift code, but they are useful to describe operations on existentials. At present, they cannot be formed when the existential involves a protocol with Self or associated type requirements, but that&#39;s a limitation that isn&#39;t hard to address. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As for your concerns about knowing when one can dynamically override and when one cannot...  There are issues here that need to be addressed. They aren&#39;t significant enough to warrant such a drastic change, and may not even require language changes at all. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160104/47965ceb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 4, 2016, at 11:40 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 4, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt; Interesting.  I was under the impression the core team was taking on the generics features. <br>&gt; <br>&gt; We are, and lots of them. I doubt we can handle another.<br>&gt; <br>&gt;&gt;  I am also very interested in helping to accelerate the process if that is possible (whether that means Swift 3 or not).<br>&gt;&gt; <br>&gt;&gt; Are you thinking specifically about unbound existentials like in your Equatable example or also partly / fully bound existentials such as SequenceType&lt;Generator.Element == Int&gt;?<br>&gt; <br>&gt; I was thinking mostly about the former. However, the latter is also a highly-requested feature [*] that complements this one, and I think it’s reasonable to discuss both together.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; [*] And is often the underlying reason why developers ask for parameterized protocols.<br></p><p>Resurrecting this conversation, I’ve been working on a proposal to (I believe) cover all these points. I’ve decided it is probably better to resurrect this conversation first in order to start having discussion about the features in general, rather than my specific proposal.<br></p><p>Specifically I am seeking to define:<br>1. The ability for protocols with Self or associated type constraints to be used other than as generic constraints on concrete types (i.e. as existential types)<br>2. The ability to use said protocols with none, some, or all of the associated types being constrained/bound.<br>3. Rules on what functionality (methods, properties) are exposed when working with a protocol (in various states of constraint) rather than a concrete type.<br>4. The ability to dynamically capture and use a concrete type for the purpose of satisfying Self constraints. This one is the least specified at the moment, but seems the best way to deal with Self constraints.<br></p><p>For the first three, I’ve tried to keep the behavior as close to as if I had instead defined a new protocol without self or associated types based on the constraints given, then had every concrete type in the system meeting the old protocol and the constraints be extended to implement the new one. (This model ignores that there are cases you cannot declare extensions like this today, such as extending a protocol to support another protocol, or extending either a concrete type or protocol to support a new protocol conditionally.)<br></p><p>These new protocols include exposing methods which are invariant based on the constraints given, or which have covariant return types (e.g. functions returning Self would indicate they return instances of this protocol). <br></p><p>The rule complexity hopefully will be sophisticated enough to expose (for example) an unbound SequenceType filter method with the approx. signature: “func filter(includedElements:(Any) throws -&gt; Bool ) rethrows -&gt; [Any]” based on existing function/array behavior.<br></p><p>Non-bikeshedded syntax currently is something in the manner of:<br></p><p>let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br></p><p>One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br></p><p>For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from - I’m instead overloading the typealias keyword when used within an expression context:<br></p><p>typealias T = x.dynamicType<br>let xT = x as! T<br></p><p>My next step is to become more familiar with the bounds of what can be done with this today by the AST/SIL. In particular, using “typealias” as above may imply capabilities which are simply more dynamic than is feasible/appropriate to support.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160113/0cef4dc0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 18, 2016 at 10:00:00am</p></header><div class="content"><p>No feedback at all?<br></p><p>-David Waite<br></p><p>&gt; On Jan 13, 2016, at 3:50 PM, David Waite via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 4, 2016, at 11:40 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com &lt;mailto:matthew at anandabits.com&gt;&gt; wrote:<br>&gt;&gt;&gt; Interesting.  I was under the impression the core team was taking on the generics features. <br>&gt;&gt; <br>&gt;&gt; We are, and lots of them. I doubt we can handle another.<br>&gt;&gt; <br>&gt;&gt;&gt;  I am also very interested in helping to accelerate the process if that is possible (whether that means Swift 3 or not).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you thinking specifically about unbound existentials like in your Equatable example or also partly / fully bound existentials such as SequenceType&lt;Generator.Element == Int&gt;?<br>&gt;&gt; <br>&gt;&gt; I was thinking mostly about the former. However, the latter is also a highly-requested feature [*] that complements this one, and I think it’s reasonable to discuss both together.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] And is often the underlying reason why developers ask for parameterized protocols.<br>&gt; <br>&gt; Resurrecting this conversation, I’ve been working on a proposal to (I believe) cover all these points. I’ve decided it is probably better to resurrect this conversation first in order to start having discussion about the features in general, rather than my specific proposal.<br>&gt; <br>&gt; Specifically I am seeking to define:<br>&gt; 1. The ability for protocols with Self or associated type constraints to be used other than as generic constraints on concrete types (i.e. as existential types)<br>&gt; 2. The ability to use said protocols with none, some, or all of the associated types being constrained/bound.<br>&gt; 3. Rules on what functionality (methods, properties) are exposed when working with a protocol (in various states of constraint) rather than a concrete type.<br>&gt; 4. The ability to dynamically capture and use a concrete type for the purpose of satisfying Self constraints. This one is the least specified at the moment, but seems the best way to deal with Self constraints.<br>&gt; <br>&gt; For the first three, I’ve tried to keep the behavior as close to as if I had instead defined a new protocol without self or associated types based on the constraints given, then had every concrete type in the system meeting the old protocol and the constraints be extended to implement the new one. (This model ignores that there are cases you cannot declare extensions like this today, such as extending a protocol to support another protocol, or extending either a concrete type or protocol to support a new protocol conditionally.)<br>&gt; <br>&gt; These new protocols include exposing methods which are invariant based on the constraints given, or which have covariant return types (e.g. functions returning Self would indicate they return instances of this protocol). <br>&gt; <br>&gt; The rule complexity hopefully will be sophisticated enough to expose (for example) an unbound SequenceType filter method with the approx. signature: “func filter(includedElements:(Any) throws -&gt; Bool ) rethrows -&gt; [Any]” based on existing function/array behavior.<br>&gt; <br>&gt; Non-bikeshedded syntax currently is something in the manner of:<br>&gt; <br>&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt; <br>&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt; <br>&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt; <br>&gt; typealias T = x.dynamicType<br>&gt; let xT = x as! T<br>&gt; <br>&gt; My next step is to become more familiar with the bounds of what can be done with this today by the AST/SIL. In particular, using “typealias” as above may imply capabilities which are simply more dynamic than is feasible/appropriate to support.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/1bef0152/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 18, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jan 13, 2016, at 2:50 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 11:40 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 4, 2016, at 10:30 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; Interesting.  I was under the impression the core team was taking on the generics features. <br>&gt;&gt; <br>&gt;&gt; We are, and lots of them. I doubt we can handle another.<br>&gt;&gt; <br>&gt;&gt;&gt;  I am also very interested in helping to accelerate the process if that is possible (whether that means Swift 3 or not).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Are you thinking specifically about unbound existentials like in your Equatable example or also partly / fully bound existentials such as SequenceType&lt;Generator.Element == Int&gt;?<br>&gt;&gt; <br>&gt;&gt; I was thinking mostly about the former. However, the latter is also a highly-requested feature [*] that complements this one, and I think it’s reasonable to discuss both together.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; [*] And is often the underlying reason why developers ask for parameterized protocols.<br>&gt; <br>&gt; Resurrecting this conversation, I’ve been working on a proposal to (I believe) cover all these points. I’ve decided it is probably better to resurrect this conversation first in order to start having discussion about the features in general, rather than my specific proposal.<br>&gt; <br>&gt; Specifically I am seeking to define:<br>&gt; 1. The ability for protocols with Self or associated type constraints to be used other than as generic constraints on concrete types (i.e. as existential types)<br>&gt; 2. The ability to use said protocols with none, some, or all of the associated types being constrained/bound.<br>&gt; 3. Rules on what functionality (methods, properties) are exposed when working with a protocol (in various states of constraint) rather than a concrete type.<br>&gt; 4. The ability to dynamically capture and use a concrete type for the purpose of satisfying Self constraints. This one is the least specified at the moment, but seems the best way to deal with Self constraints.<br></p><p>Okay. <br></p><p>&gt; <br>&gt; For the first three, I’ve tried to keep the behavior as close to as if I had instead defined a new protocol without self or associated types based on the constraints given, then had every concrete type in the system meeting the old protocol and the constraints be extended to implement the new one. (This model ignores that there are cases you cannot declare extensions like this today, such as extending a protocol to support another protocol, or extending either a concrete type or protocol to support a new protocol conditionally.)<br>&gt; <br>&gt; These new protocols include exposing methods which are invariant based on the constraints given, or which have covariant return types (e.g. functions returning Self would indicate they return instances of this protocol). <br>&gt; <br>&gt; The rule complexity hopefully will be sophisticated enough to expose (for example) an unbound SequenceType filter method with the approx. signature: “func filter(includedElements:(Any) throws -&gt; Bool ) rethrows -&gt; [Any]” based on existing function/array behavior.<br>&gt; <br>&gt; Non-bikeshedded syntax currently is something in the manner of:<br>&gt; <br>&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br></p><p>Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br></p><p>&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br></p><p>Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator&quot;.<br></p><p>&gt; <br>&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br></p><p>Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br></p><p>&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt; <br>&gt; typealias T = x.dynamicType<br>&gt; let xT = x as! T<br></p><p>x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br></p><p>&gt; <br>&gt; My next step is to become more familiar with the bounds of what can be done with this today by the AST/SIL. In particular, using “typealias” as above may imply capabilities which are simply more dynamic than is feasible/appropriate to support.<br></p><p>I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br></p><p>  - Doug<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/e4208d38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 18, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Am 18.01.2016 um 21:18 schrieb Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br></p><p>I think this should be possible as SequenceType.Generator is in a covariant position and changes covariantly with the Element type.<br>The type should use the same bounds as that of the SequenceType:<br></p><p>var zs: protocol&lt;SequenceType where Generator.Element : SomeProtocol&gt;<br>var gz: protocol&lt;SequenceType.GeneratorType where .Element : SomeProtocol&gt; = zs.generate()<br>var z: SomeProtocol? = gz.next()<br></p><p>If no bounds would have been given Element would have the type Any.<br></p><p>Should we have path-dependent types like Scala?<br>(see e.g. http://stackoverflow.com/questions/2693067/what-is-meant-by-scalas-path-dependent-types)<br></p><p>var zs: protocol&lt;SequenceType where Generator.Element : SomeProtocol&gt;<br>var gz: zs.Generator = zs.generate()<br>var z: SomeProtocol? = gz.next()<br>var ys: protocol&lt;SequenceType where Generator.Element : SomeProtocol&gt;<br>var gy: ys.Generator = gz // type error: path-dependent types ys.Generator and zs.Generator differ<br></p><p>-Thorsten<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/c1cd06db/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 18, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt; <br>&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br></p><p>Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br></p><p>	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br></p><p>&gt; <br>&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt; <br>&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br></p><p>Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt; <br>&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt; <br>&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt; <br>&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt; let xT = x as! T<br>&gt; <br>&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br></p><p>This is an area that I need to understand compiler behavior more here (I’ve been researching)<br></p><p>If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br></p><p>var x:Any = “Initial”<br>typealias T = x.dynamicType // String<br>x = 1<br>let xT = x as! T // fails precondition as if I had said x as! String<br></p><p>I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br></p><p>&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br></p><p>Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br></p><p>If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br></p><p>To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>- pruning some alternate forms<br>- removing SubSequence and Generator associated types and just having Element<br>- using the protocol&lt;&gt; syntax described before (with . prefix)<br>- returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>- eliminate usage of AnySequence in definitions (not needed)<br>- assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br></p><p>protocol SequenceType {<br>    associatedtype Element<br></p><p>    var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>    func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>    func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>    func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>    func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>    func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>    func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>    func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>    func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>    func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>    func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>    func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>    func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>    func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>    func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>    func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>    func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>    func reverse() -&gt; [Element]<br>    func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>    func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>    func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>    func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>    func underestimateCount() -&gt; Int<br>}<br></p><p>extension SequenceType where Element:Equatable {<br>    func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>    func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>    func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>}<br></p><p>extension SequenceType where Element == String {<br>    func joinWithSeparator(separator:String) -&gt; String<br>}<br></p><p>extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>}<br></p><p>extension SequenceType where Element:Comparable {<br>    func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>    func maxElement() -&gt; Element?<br>    func minElement() -&gt; Element?<br>    func sort() -&gt; [Element]<br>}<br>Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>- None of the extensions match the constraint on Element, so they are not exposed<br>- property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>- the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>- dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>- elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>- enumerate() will return a sequence with elements of type (Int, Any)<br>- filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>- flatMap and forEach are exposed similar to contains above<br>- generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>- lexicographicalCompare fails, more below<br>- reduce has effective syntax:<br> func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>- the rest are exposed as above except for startsWith<br></p><p>So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br></p><p>This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/afd41682/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 19, 2016 at 03:00:00pm</p></header><div class="content"><p>I like the idea to use protocol&lt;&gt; for an abstraction with many constrained protocols but for a single type constraint it is a bit verbose.<br></p><p>What about generics in protocols which are only a view to its associated types or generics which create/are associated types?<br></p><p>Example of a simple protocol which models a node of a tree:<br></p><p>// Before<br></p><p>// NodeType can be anything<br>// currently Swift doesn&#39;t allow<br>// `typealias NodeType: Node`<br>//<br>// or even where clauses <br>// `typealias NodeType: Node where NodeType.T == T`<br>protocol Node {<br>	typealias T<br>	typealias NodeType<br>	<br>	var value: T { get }<br>	var nodes: [NodeType] { get }<br>}<br></p><p>// After<br>protocol Node&lt;T&gt; {<br>	typealias T // probably remove this declaration (see reason below)<br>	var value: T { get }<br>	var nodes: [Node&lt;T&gt;] { get }<br>}<br></p><p>So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br></p><p>In order to let this still compile:<br></p><p>	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br></p><p>there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br></p><p><br>Implementation:<br>The function declaration above could be rewritten to using a function like generic parameter parameter syntax for protocols:<br></p><p>        // Declaration of SequenceType<br>        protocol SequenceType&lt;Element: Generator.Element, Generator: GeneratorType, SubSequence&gt; { … }<br>    //                           ^~~~ using : in oder to allow default types with =<br></p><p>        // Using &quot;_&quot; to leave it unspecified eg. Any<br>    func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;, SubSequence: _&gt;){}<br>    // omitting `SubSequence: _` since the type is already unambiguous<br>    func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;&gt;){}<br>    // omitting `Generator: GeneratorType&lt;Int&gt;` since the type of `Generator` can be inferred from Element<br>    func afunction(s: SequenceType&lt;Element: Int&gt;){}<br></p><p>The order of arguments is in this case irrelevant, but should probably be in a strict ordering to make it more consistent with the point below.<br></p><p>In order to have a more general generic parameter behavior (to work with structs, classes and enums) we could also allow to use these without external names and only their order. So the example above would look like this:<br></p><p>    func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;, _&gt;){}<br>    func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;&gt;){}<br>    func afunction(s: SequenceType&lt;Int&gt;){}<br>    <br>    // These two functions don&#39;t produce an error since `Element` can be inferred<br>    func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;, _&gt;){}<br>    func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;&gt;){}<br></p><p>    // for an unconstrained Sequence &quot;_&quot; can be used in order to make it clear: &quot;there could be generic parameters&quot;<br>    func afunction(s: SequenceType&lt;_&gt;){}<br></p><p>For instance `Array` and `Dictionary` also can apply to this model.<br></p><p>Also where clauses could be used in generic parameter declarations which are disallowed for associated types (currently).<br></p><p><br>What do you think about this approach?<br></p><p>Should SequenceType&lt;_&gt; be equal to SequenceType&lt;Any&gt; / SequenceType&lt;Element: Any&gt; ?<br></p><p><br>- Maximilian<br></p><p>&gt; Am 19.01.2016 um 00:32 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt;&gt; <br>&gt;&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br>&gt; <br>&gt; Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br>&gt; <br>&gt; 	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt;&gt; <br>&gt;&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br>&gt; <br>&gt; Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt;&gt; <br>&gt;&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt;&gt; <br>&gt;&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt;&gt; let xT = x as! T<br>&gt;&gt; <br>&gt;&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br>&gt; <br>&gt; This is an area that I need to understand compiler behavior more here (I’ve been researching)<br>&gt; <br>&gt; If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br>&gt; <br>&gt; var x:Any = “Initial”<br>&gt; typealias T = x.dynamicType // String<br>&gt; x = 1<br>&gt; let xT = x as! T // fails precondition as if I had said x as! String<br>&gt; <br>&gt; I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br>&gt; <br>&gt;&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br>&gt; <br>&gt; Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br>&gt; <br>&gt; If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br>&gt; <br>&gt; To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>&gt; - pruning some alternate forms<br>&gt; - removing SubSequence and Generator associated types and just having Element<br>&gt; - using the protocol&lt;&gt; syntax described before (with . prefix)<br>&gt; - returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>&gt; - eliminate usage of AnySequence in definitions (not needed)<br>&gt; - assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br>&gt; <br>&gt; protocol SequenceType {<br>&gt;     associatedtype Element<br>&gt; <br>&gt;     var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>&gt;     func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;     func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;     func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;     func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>&gt;     func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>&gt;     func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>&gt;     func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>&gt;     func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>&gt;     func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>&gt;     func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>&gt;     func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;     func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;     func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;     func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;     func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>&gt;     func reverse() -&gt; [Element]<br>&gt;     func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>&gt;     func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;     func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;     func underestimateCount() -&gt; Int<br>&gt; }<br>&gt; <br>&gt; extension SequenceType where Element:Equatable {<br>&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; extension SequenceType where Element == String {<br>&gt;     func joinWithSeparator(separator:String) -&gt; String<br>&gt; }<br>&gt; <br>&gt; extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>&gt; func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>&gt; func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>&gt; }<br>&gt; <br>&gt; extension SequenceType where Element:Comparable {<br>&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>&gt;     func maxElement() -&gt; Element?<br>&gt;     func minElement() -&gt; Element?<br>&gt;     func sort() -&gt; [Element]<br>&gt; }<br>&gt; Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>&gt; - None of the extensions match the constraint on Element, so they are not exposed<br>&gt; - property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>&gt; - the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>&gt; func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt; - dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>&gt; - elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>&gt; - enumerate() will return a sequence with elements of type (Int, Any)<br>&gt; - filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>&gt; - flatMap and forEach are exposed similar to contains above<br>&gt; - generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>&gt; - lexicographicalCompare fails, more below<br>&gt; - reduce has effective syntax:<br>&gt;  func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>&gt; - the rest are exposed as above except for startsWith<br>&gt; <br>&gt; So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br>&gt; <br>&gt; This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/10dd6339/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 7:49 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I like the idea to use protocol&lt;&gt; for an abstraction with many constrained protocols but for a single type constraint it is a bit verbose.<br>&gt; <br>&gt; What about generics in protocols which are only a view to its associated types or generics which create/are associated types?<br></p><p>Since I imagine reusing generics syntax for constraining protocols will be a popular proposal, I figure I’ll give the reasoning I personally didn’t use, at it for my initial placeholder syntax.<br></p><p>The main reason l chose an alternate syntax was that generic type usage and protocol constraints aren’t expressed the same way - protocol constraints on associated types aren’t positional and can be missing. This meant that ConcreteThing&lt;…&gt; and ProtocolType&lt;…&gt; would have different syntaxes inside the angle brackets, and thus felt like it would promote more syntax bike shedding (in addition to personally seeming less clean to me). <br></p><p>Using ProtocolType&lt;…&gt; syntax would I believe be the 5th syntactic usage for &lt;...&gt; (generic type declaration, generic type use, generic constraints on methods, protocol union and now generic protocol use). Swift gets away with the multiple usages today because the syntax within the angle brackets is very similar. Expanding protocol unions meant I stayed closer to generic constraint syntax, while still having was only four syntactic usages (as in, protocol unions would umbrella under/into partial protocol constraints as a new existential type redefinition “thing&quot;)<br></p><p>As an example, the liberties I took with SequenceType took it down to a single associated type, but CollectionType would still have a minimum of Index and Element. I would need to declare CollectionType&lt;where .Index == Index&gt; or similar if I were wishing to partially constrain just one parameter. This is also eliminates most of the typing savings of using generic type usage syntax.<br></p><p>Finally and to a lesser degree, the parameters for a generic type define a single concrete type, while for a protocol it defines a view of some concrete type. Today I can intuit Foo&lt;String&gt; is the name of a concrete type. During proposal, there was more value in having a placeholder syntax that did not damage intuition about concrete types.<br></p><p>-DW<br></p><p>&gt; <br>&gt; Example of a simple protocol which models a node of a tree:<br>&gt; <br>&gt; // Before<br>&gt; <br>&gt; // NodeType can be anything<br>&gt; // currently Swift doesn&#39;t allow<br>&gt; // `typealias NodeType: Node`<br>&gt; //<br>&gt; // or even where clauses <br>&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt; protocol Node {<br>&gt; 	typealias T<br>&gt; 	typealias NodeType<br>&gt; 	<br>&gt; 	var value: T { get }<br>&gt; 	var nodes: [NodeType] { get }<br>&gt; }<br>&gt; <br>&gt; // After<br>&gt; protocol Node&lt;T&gt; {<br>&gt; 	typealias T // probably remove this declaration (see reason below)<br>&gt; 	var value: T { get }<br>&gt; 	var nodes: [Node&lt;T&gt;] { get }<br>&gt; }<br>&gt; <br>&gt; So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br>&gt; <br>&gt; In order to let this still compile:<br>&gt; <br>&gt; 	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt; <br>&gt; there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br>&gt; <br>&gt; <br>&gt; Implementation:<br>&gt; The function declaration above could be rewritten to using a function like generic parameter parameter syntax for protocols:<br>&gt; <br>&gt;         // Declaration of SequenceType<br>&gt;         protocol SequenceType&lt;Element: Generator.Element, Generator: GeneratorType, SubSequence&gt; { … }<br>&gt;     //                           ^~~~ using : in oder to allow default types with =<br>&gt; <br>&gt;         // Using &quot;_&quot; to leave it unspecified eg. Any<br>&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;, SubSequence: _&gt;){}<br>&gt;     // omitting `SubSequence: _` since the type is already unambiguous<br>&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;&gt;){}<br>&gt;     // omitting `Generator: GeneratorType&lt;Int&gt;` since the type of `Generator` can be inferred from Element<br>&gt;     func afunction(s: SequenceType&lt;Element: Int&gt;){}<br>&gt; <br>&gt; The order of arguments is in this case irrelevant, but should probably be in a strict ordering to make it more consistent with the point below.<br>&gt; <br>&gt; In order to have a more general generic parameter behavior (to work with structs, classes and enums) we could also allow to use these without external names and only their order. So the example above would look like this:<br>&gt; <br>&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;&gt;){}<br>&gt;     func afunction(s: SequenceType&lt;Int&gt;){}<br>&gt;     <br>&gt;     // These two functions don&#39;t produce an error since `Element` can be inferred<br>&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;&gt;){}<br>&gt; <br>&gt;     // for an unconstrained Sequence &quot;_&quot; can be used in order to make it clear: &quot;there could be generic parameters&quot;<br>&gt;     func afunction(s: SequenceType&lt;_&gt;){}<br>&gt; <br>&gt; For instance `Array` and `Dictionary` also can apply to this model.<br>&gt; <br>&gt; Also where clauses could be used in generic parameter declarations which are disallowed for associated types (currently).<br>&gt; <br>&gt; <br>&gt; What do you think about this approach?<br>&gt; <br>&gt; Should SequenceType&lt;_&gt; be equal to SequenceType&lt;Any&gt; / SequenceType&lt;Element: Any&gt; ?<br>&gt; <br>&gt; <br>&gt; - Maximilian<br>&gt; <br>&gt;&gt; Am 19.01.2016 um 00:32 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt;&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br>&gt;&gt; <br>&gt;&gt; Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br>&gt;&gt; <br>&gt;&gt; 	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br>&gt;&gt; <br>&gt;&gt; Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt;&gt;&gt; let xT = x as! T<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br>&gt;&gt; <br>&gt;&gt; This is an area that I need to understand compiler behavior more here (I’ve been researching)<br>&gt;&gt; <br>&gt;&gt; If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br>&gt;&gt; <br>&gt;&gt; var x:Any = “Initial”<br>&gt;&gt; typealias T = x.dynamicType // String<br>&gt;&gt; x = 1<br>&gt;&gt; let xT = x as! T // fails precondition as if I had said x as! String<br>&gt;&gt; <br>&gt;&gt; I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br>&gt;&gt; <br>&gt;&gt;&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br>&gt;&gt; <br>&gt;&gt; Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br>&gt;&gt; <br>&gt;&gt; If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br>&gt;&gt; <br>&gt;&gt; To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>&gt;&gt; - pruning some alternate forms<br>&gt;&gt; - removing SubSequence and Generator associated types and just having Element<br>&gt;&gt; - using the protocol&lt;&gt; syntax described before (with . prefix)<br>&gt;&gt; - returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>&gt;&gt; - eliminate usage of AnySequence in definitions (not needed)<br>&gt;&gt; - assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br>&gt;&gt; <br>&gt;&gt; protocol SequenceType {<br>&gt;&gt;     associatedtype Element<br>&gt;&gt; <br>&gt;&gt;     var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>&gt;&gt;     func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;     func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;     func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;     func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>&gt;&gt;     func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>&gt;&gt;     func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;     func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>&gt;&gt;     func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>&gt;&gt;     func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>&gt;&gt;     func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;     func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;     func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;     func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;     func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;     func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;     func reverse() -&gt; [Element]<br>&gt;&gt;     func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;     func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;     func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;     func underestimateCount() -&gt; Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SequenceType where Element:Equatable {<br>&gt;&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SequenceType where Element == String {<br>&gt;&gt;     func joinWithSeparator(separator:String) -&gt; String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>&gt;&gt; func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>&gt;&gt; func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SequenceType where Element:Comparable {<br>&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>&gt;&gt;     func maxElement() -&gt; Element?<br>&gt;&gt;     func minElement() -&gt; Element?<br>&gt;&gt;     func sort() -&gt; [Element]<br>&gt;&gt; }<br>&gt;&gt; Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>&gt;&gt; - None of the extensions match the constraint on Element, so they are not exposed<br>&gt;&gt; - property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>&gt;&gt; - the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>&gt;&gt; func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt; - dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>&gt;&gt; - elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>&gt;&gt; - enumerate() will return a sequence with elements of type (Int, Any)<br>&gt;&gt; - filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>&gt;&gt; - flatMap and forEach are exposed similar to contains above<br>&gt;&gt; - generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>&gt;&gt; - lexicographicalCompare fails, more below<br>&gt;&gt; - reduce has effective syntax:<br>&gt;&gt;  func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt; - the rest are exposed as above except for startsWith<br>&gt;&gt; <br>&gt;&gt; So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br>&gt;&gt; <br>&gt;&gt; This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/0930ecef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 10:47 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:49 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com &lt;mailto:m.huenenberger at me.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the idea to use protocol&lt;&gt; for an abstraction with many constrained protocols but for a single type constraint it is a bit verbose.<br>&gt;&gt; <br>&gt;&gt; What about generics in protocols which are only a view to its associated types or generics which create/are associated types?<br>&gt; <br>&gt; Since I imagine reusing generics syntax for constraining protocols will be a popular proposal, I figure I’ll give the reasoning I personally didn’t use, at it for my initial placeholder syntax.<br>&gt; <br>&gt; The main reason l chose an alternate syntax was that generic type usage and protocol constraints aren’t expressed the same way - protocol constraints on associated types aren’t positional and can be missing. This meant that ConcreteThing&lt;…&gt; and ProtocolType&lt;…&gt; would have different syntaxes inside the angle brackets, and thus felt like it would promote more syntax bike shedding (in addition to personally seeming less clean to me). <br>&gt; <br>&gt; Using ProtocolType&lt;…&gt; syntax would I believe be the 5th syntactic usage for &lt;...&gt; (generic type declaration, generic type use, generic constraints on methods, protocol union and now generic protocol use). Swift gets away with the multiple usages today because the syntax within the angle brackets is very similar. Expanding protocol unions meant I stayed closer to generic constraint syntax, while still having was only four syntactic usages (as in, protocol unions would umbrella under/into partial protocol constraints as a new existential type redefinition “thing&quot;)<br>&gt; <br>&gt; As an example, the liberties I took with SequenceType took it down to a single associated type, but CollectionType would still have a minimum of Index and Element. I would need to declare CollectionType&lt;where .Index == Index&gt; or similar if I were wishing to partially constrain just one parameter. This is also eliminates most of the typing savings of using generic type usage syntax.<br></p><p>Right. There’s also SubSequence, which you almost certainly don’t want to have to specify. For reference, once we get generic typealiases, one would be free to add<br></p><p>	typealias AnyCollection&lt;Element&gt; = protocol&lt;CollectionType where .Element == Element&gt;<br></p><p>to cover the common case.<br></p><p>	- Doug<br></p><p>&gt;&gt; <br>&gt;&gt; Example of a simple protocol which models a node of a tree:<br>&gt;&gt; <br>&gt;&gt; // Before<br>&gt;&gt; <br>&gt;&gt; // NodeType can be anything<br>&gt;&gt; // currently Swift doesn&#39;t allow<br>&gt;&gt; // `typealias NodeType: Node`<br>&gt;&gt; //<br>&gt;&gt; // or even where clauses <br>&gt;&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt;&gt; protocol Node {<br>&gt;&gt; 	typealias T<br>&gt;&gt; 	typealias NodeType<br>&gt;&gt; 	<br>&gt;&gt; 	var value: T { get }<br>&gt;&gt; 	var nodes: [NodeType] { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // After<br>&gt;&gt; protocol Node&lt;T&gt; {<br>&gt;&gt; 	typealias T // probably remove this declaration (see reason below)<br>&gt;&gt; 	var value: T { get }<br>&gt;&gt; 	var nodes: [Node&lt;T&gt;] { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br>&gt;&gt; <br>&gt;&gt; In order to let this still compile:<br>&gt;&gt; <br>&gt;&gt; 	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;&gt; <br>&gt;&gt; there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Implementation:<br>&gt;&gt; The function declaration above could be rewritten to using a function like generic parameter parameter syntax for protocols:<br>&gt;&gt; <br>&gt;&gt;         // Declaration of SequenceType<br>&gt;&gt;         protocol SequenceType&lt;Element: Generator.Element, Generator: GeneratorType, SubSequence&gt; { … }<br>&gt;&gt;     //                           ^~~~ using : in oder to allow default types with =<br>&gt;&gt; <br>&gt;&gt;         // Using &quot;_&quot; to leave it unspecified eg. Any<br>&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;, SubSequence: _&gt;){}<br>&gt;&gt;     // omitting `SubSequence: _` since the type is already unambiguous<br>&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;&gt;){}<br>&gt;&gt;     // omitting `Generator: GeneratorType&lt;Int&gt;` since the type of `Generator` can be inferred from Element<br>&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int&gt;){}<br>&gt;&gt; <br>&gt;&gt; The order of arguments is in this case irrelevant, but should probably be in a strict ordering to make it more consistent with the point below.<br>&gt;&gt; <br>&gt;&gt; In order to have a more general generic parameter behavior (to work with structs, classes and enums) we could also allow to use these without external names and only their order. So the example above would look like this:<br>&gt;&gt; <br>&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;     func afunction(s: SequenceType&lt;Int&gt;){}<br>&gt;&gt;     <br>&gt;&gt;     // These two functions don&#39;t produce an error since `Element` can be inferred<br>&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt; <br>&gt;&gt;     // for an unconstrained Sequence &quot;_&quot; can be used in order to make it clear: &quot;there could be generic parameters&quot;<br>&gt;&gt;     func afunction(s: SequenceType&lt;_&gt;){}<br>&gt;&gt; <br>&gt;&gt; For instance `Array` and `Dictionary` also can apply to this model.<br>&gt;&gt; <br>&gt;&gt; Also where clauses could be used in generic parameter declarations which are disallowed for associated types (currently).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think about this approach?<br>&gt;&gt; <br>&gt;&gt; Should SequenceType&lt;_&gt; be equal to SequenceType&lt;Any&gt; / SequenceType&lt;Element: Any&gt; ?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt; Am 19.01.2016 um 00:32 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt;&gt;&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt;&gt;&gt;&gt; let xT = x as! T<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an area that I need to understand compiler behavior more here (I’ve been researching)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x:Any = “Initial”<br>&gt;&gt;&gt; typealias T = x.dynamicType // String<br>&gt;&gt;&gt; x = 1<br>&gt;&gt;&gt; let xT = x as! T // fails precondition as if I had said x as! String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>&gt;&gt;&gt; - pruning some alternate forms<br>&gt;&gt;&gt; - removing SubSequence and Generator associated types and just having Element<br>&gt;&gt;&gt; - using the protocol&lt;&gt; syntax described before (with . prefix)<br>&gt;&gt;&gt; - returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>&gt;&gt;&gt; - eliminate usage of AnySequence in definitions (not needed)<br>&gt;&gt;&gt; - assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol SequenceType {<br>&gt;&gt;&gt;     associatedtype Element<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>&gt;&gt;&gt;     func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;     func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>&gt;&gt;&gt;     func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>&gt;&gt;&gt;     func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;     func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>&gt;&gt;&gt;     func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>&gt;&gt;&gt;     func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>&gt;&gt;&gt;     func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;     func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;     func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;     func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;     func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;     func reverse() -&gt; [Element]<br>&gt;&gt;&gt;     func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;     func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;     func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func underestimateCount() -&gt; Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element:Equatable {<br>&gt;&gt;&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;&gt;&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element == String {<br>&gt;&gt;&gt;     func joinWithSeparator(separator:String) -&gt; String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>&gt;&gt;&gt; func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>&gt;&gt;&gt; func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element:Comparable {<br>&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>&gt;&gt;&gt;     func maxElement() -&gt; Element?<br>&gt;&gt;&gt;     func minElement() -&gt; Element?<br>&gt;&gt;&gt;     func sort() -&gt; [Element]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>&gt;&gt;&gt; - None of the extensions match the constraint on Element, so they are not exposed<br>&gt;&gt;&gt; - property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>&gt;&gt;&gt; - the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>&gt;&gt;&gt; func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt; - dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>&gt;&gt;&gt; - elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>&gt;&gt;&gt; - enumerate() will return a sequence with elements of type (Int, Any)<br>&gt;&gt;&gt; - filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>&gt;&gt;&gt; - flatMap and forEach are exposed similar to contains above<br>&gt;&gt;&gt; - generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>&gt;&gt;&gt; - lexicographicalCompare fails, more below<br>&gt;&gt;&gt; - reduce has effective syntax:<br>&gt;&gt;&gt;  func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt; - the rest are exposed as above except for startsWith<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/428b2de5/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 1:21 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; Right. There’s also SubSequence, which you almost certainly don’t want to have to specify. For reference, once we get generic typealiases, one would be free to add<br></p><p>Yes, although in the version of SequenceType which declared earlier in the thread, there was no longer a need for SubSequence, as I could just return protocol&lt;SequenceType where .Element == Element&gt; where needed.<br></p><p>&gt; 	typealias AnyCollection&lt;Element&gt; = protocol&lt;CollectionType where .Element == Element&gt;<br></p><p>Eventually if you had typealiases in protocols (since the keyword will be freed up eventually due to the new associatedtype keyword) you could declare<br></p><p>protocol SequenceType {<br>  associatedtype Element<br>  typealias SubSequence = protocol&lt;SequenceType where .Element = Self.Element&gt;<br></p><p>But thats a whole bucket of deprecation issues which aren’t worth it ATM - it would be a proposal for Swift 4.<br></p><p>-DW<br></p><p>&gt; <br>&gt; to cover the common case.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example of a simple protocol which models a node of a tree:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Before<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // NodeType can be anything<br>&gt;&gt;&gt; // currently Swift doesn&#39;t allow<br>&gt;&gt;&gt; // `typealias NodeType: Node`<br>&gt;&gt;&gt; //<br>&gt;&gt;&gt; // or even where clauses <br>&gt;&gt;&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt;&gt;&gt; protocol Node {<br>&gt;&gt;&gt; 	typealias T<br>&gt;&gt;&gt; 	typealias NodeType<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; 	var value: T { get }<br>&gt;&gt;&gt; 	var nodes: [NodeType] { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // After<br>&gt;&gt;&gt; protocol Node&lt;T&gt; {<br>&gt;&gt;&gt; 	typealias T // probably remove this declaration (see reason below)<br>&gt;&gt;&gt; 	var value: T { get }<br>&gt;&gt;&gt; 	var nodes: [Node&lt;T&gt;] { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to let this still compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implementation:<br>&gt;&gt;&gt; The function declaration above could be rewritten to using a function like generic parameter parameter syntax for protocols:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // Declaration of SequenceType<br>&gt;&gt;&gt;         protocol SequenceType&lt;Element: Generator.Element, Generator: GeneratorType, SubSequence&gt; { … }<br>&gt;&gt;&gt;     //                           ^~~~ using : in oder to allow default types with =<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         // Using &quot;_&quot; to leave it unspecified eg. Any<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;, SubSequence: _&gt;){}<br>&gt;&gt;&gt;     // omitting `SubSequence: _` since the type is already unambiguous<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;&gt;){}<br>&gt;&gt;&gt;     // omitting `Generator: GeneratorType&lt;Int&gt;` since the type of `Generator` can be inferred from Element<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int&gt;){}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The order of arguments is in this case irrelevant, but should probably be in a strict ordering to make it more consistent with the point below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to have a more general generic parameter behavior (to work with structs, classes and enums) we could also allow to use these without external names and only their order. So the example above would look like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Int&gt;){}<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // These two functions don&#39;t produce an error since `Element` can be inferred<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // for an unconstrained Sequence &quot;_&quot; can be used in order to make it clear: &quot;there could be generic parameters&quot;<br>&gt;&gt;&gt;     func afunction(s: SequenceType&lt;_&gt;){}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance `Array` and `Dictionary` also can apply to this model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also where clauses could be used in generic parameter declarations which are disallowed for associated types (currently).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What do you think about this approach?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Should SequenceType&lt;_&gt; be equal to SequenceType&lt;Any&gt; / SequenceType&lt;Element: Any&gt; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 19.01.2016 um 00:32 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt;&gt;&gt;&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt;&gt;&gt;&gt;&gt; let xT = x as! T<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is an area that I need to understand compiler behavior more here (I’ve been researching)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; var x:Any = “Initial”<br>&gt;&gt;&gt;&gt; typealias T = x.dynamicType // String<br>&gt;&gt;&gt;&gt; x = 1<br>&gt;&gt;&gt;&gt; let xT = x as! T // fails precondition as if I had said x as! String<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>&gt;&gt;&gt;&gt; - pruning some alternate forms<br>&gt;&gt;&gt;&gt; - removing SubSequence and Generator associated types and just having Element<br>&gt;&gt;&gt;&gt; - using the protocol&lt;&gt; syntax described before (with . prefix)<br>&gt;&gt;&gt;&gt; - returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>&gt;&gt;&gt;&gt; - eliminate usage of AnySequence in definitions (not needed)<br>&gt;&gt;&gt;&gt; - assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol SequenceType {<br>&gt;&gt;&gt;&gt;     associatedtype Element<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>&gt;&gt;&gt;&gt;     func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;     func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;     func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;     func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>&gt;&gt;&gt;&gt;     func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>&gt;&gt;&gt;&gt;     func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;&gt;     func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>&gt;&gt;&gt;&gt;     func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;     func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>&gt;&gt;&gt;&gt;     func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;     func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;     func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;&gt;     func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;&gt;     func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;     func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;&gt;     func reverse() -&gt; [Element]<br>&gt;&gt;&gt;&gt;     func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;&gt;     func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;     func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;     func underestimateCount() -&gt; Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SequenceType where Element:Equatable {<br>&gt;&gt;&gt;&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;&gt;&gt;&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SequenceType where Element == String {<br>&gt;&gt;&gt;&gt;     func joinWithSeparator(separator:String) -&gt; String<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>&gt;&gt;&gt;&gt; func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>&gt;&gt;&gt;&gt; func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SequenceType where Element:Comparable {<br>&gt;&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>&gt;&gt;&gt;&gt;     func maxElement() -&gt; Element?<br>&gt;&gt;&gt;&gt;     func minElement() -&gt; Element?<br>&gt;&gt;&gt;&gt;     func sort() -&gt; [Element]<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>&gt;&gt;&gt;&gt; - None of the extensions match the constraint on Element, so they are not exposed<br>&gt;&gt;&gt;&gt; - property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>&gt;&gt;&gt;&gt; - the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>&gt;&gt;&gt;&gt; func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt; - dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>&gt;&gt;&gt;&gt; - elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>&gt;&gt;&gt;&gt; - enumerate() will return a sequence with elements of type (Int, Any)<br>&gt;&gt;&gt;&gt; - filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>&gt;&gt;&gt;&gt; - flatMap and forEach are exposed similar to contains above<br>&gt;&gt;&gt;&gt; - generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>&gt;&gt;&gt;&gt; - lexicographicalCompare fails, more below<br>&gt;&gt;&gt;&gt; - reduce has effective syntax:<br>&gt;&gt;&gt;&gt;  func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;&gt; - the rest are exposed as above except for startsWith<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/4395e7eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 12:54 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 1:21 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Right. There’s also SubSequence, which you almost certainly don’t want to have to specify. For reference, once we get generic typealiases, one would be free to add<br>&gt; <br>&gt; Yes, although in the version of SequenceType which declared earlier in the thread, there was no longer a need for SubSequence, as I could just return protocol&lt;SequenceType where .Element == Element&gt; where needed.<br></p><p>I suspect that there is a class of algorithms for which it is interesting to limit ourselves to “SubSequence == Self”, which one would lose by making SubSequence an existential.<br></p><p>	- Doug<br></p><p><br>&gt; <br>&gt;&gt; 	typealias AnyCollection&lt;Element&gt; = protocol&lt;CollectionType where .Element == Element&gt;<br>&gt; <br>&gt; Eventually if you had typealiases in protocols (since the keyword will be freed up eventually due to the new associatedtype keyword) you could declare<br>&gt; <br>&gt; protocol SequenceType {<br>&gt;   associatedtype Element<br>&gt;   typealias SubSequence = protocol&lt;SequenceType where .Element = Self.Element&gt;<br>&gt; <br>&gt; But thats a whole bucket of deprecation issues which aren’t worth it ATM - it would be a proposal for Swift 4.<br>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; <br>&gt;&gt; to cover the common case.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example of a simple protocol which models a node of a tree:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // Before<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // NodeType can be anything<br>&gt;&gt;&gt;&gt; // currently Swift doesn&#39;t allow<br>&gt;&gt;&gt;&gt; // `typealias NodeType: Node`<br>&gt;&gt;&gt;&gt; //<br>&gt;&gt;&gt;&gt; // or even where clauses <br>&gt;&gt;&gt;&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt;&gt;&gt;&gt; protocol Node {<br>&gt;&gt;&gt;&gt; 	typealias T<br>&gt;&gt;&gt;&gt; 	typealias NodeType<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; 	var value: T { get }<br>&gt;&gt;&gt;&gt; 	var nodes: [NodeType] { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // After<br>&gt;&gt;&gt;&gt; protocol Node&lt;T&gt; {<br>&gt;&gt;&gt;&gt; 	typealias T // probably remove this declaration (see reason below)<br>&gt;&gt;&gt;&gt; 	var value: T { get }<br>&gt;&gt;&gt;&gt; 	var nodes: [Node&lt;T&gt;] { get }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to let this still compile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implementation:<br>&gt;&gt;&gt;&gt; The function declaration above could be rewritten to using a function like generic parameter parameter syntax for protocols:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         // Declaration of SequenceType<br>&gt;&gt;&gt;&gt;         protocol SequenceType&lt;Element: Generator.Element, Generator: GeneratorType, SubSequence&gt; { … }<br>&gt;&gt;&gt;&gt;     //                           ^~~~ using : in oder to allow default types with =<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;         // Using &quot;_&quot; to leave it unspecified eg. Any<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;, SubSequence: _&gt;){}<br>&gt;&gt;&gt;&gt;     // omitting `SubSequence: _` since the type is already unambiguous<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;&gt;){}<br>&gt;&gt;&gt;&gt;     // omitting `Generator: GeneratorType&lt;Int&gt;` since the type of `Generator` can be inferred from Element<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int&gt;){}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The order of arguments is in this case irrelevant, but should probably be in a strict ordering to make it more consistent with the point below.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to have a more general generic parameter behavior (to work with structs, classes and enums) we could also allow to use these without external names and only their order. So the example above would look like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;Int&gt;){}<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // These two functions don&#39;t produce an error since `Element` can be inferred<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     // for an unconstrained Sequence &quot;_&quot; can be used in order to make it clear: &quot;there could be generic parameters&quot;<br>&gt;&gt;&gt;&gt;     func afunction(s: SequenceType&lt;_&gt;){}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For instance `Array` and `Dictionary` also can apply to this model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Also where clauses could be used in generic parameter declarations which are disallowed for associated types (currently).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What do you think about this approach?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Should SequenceType&lt;_&gt; be equal to SequenceType&lt;Any&gt; / SequenceType&lt;Element: Any&gt; ?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Maximilian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 19.01.2016 um 00:32 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let xT = x as! T<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is an area that I need to understand compiler behavior more here (I’ve been researching)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; var x:Any = “Initial”<br>&gt;&gt;&gt;&gt;&gt; typealias T = x.dynamicType // String<br>&gt;&gt;&gt;&gt;&gt; x = 1<br>&gt;&gt;&gt;&gt;&gt; let xT = x as! T // fails precondition as if I had said x as! String<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>&gt;&gt;&gt;&gt;&gt; - pruning some alternate forms<br>&gt;&gt;&gt;&gt;&gt; - removing SubSequence and Generator associated types and just having Element<br>&gt;&gt;&gt;&gt;&gt; - using the protocol&lt;&gt; syntax described before (with . prefix)<br>&gt;&gt;&gt;&gt;&gt; - returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>&gt;&gt;&gt;&gt;&gt; - eliminate usage of AnySequence in definitions (not needed)<br>&gt;&gt;&gt;&gt;&gt; - assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol SequenceType {<br>&gt;&gt;&gt;&gt;&gt;     associatedtype Element<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>&gt;&gt;&gt;&gt;&gt;     func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;     func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;     func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>&gt;&gt;&gt;&gt;&gt;     func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;&gt;&gt;     func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>&gt;&gt;&gt;&gt;&gt;     func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;&gt;     func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>&gt;&gt;&gt;&gt;&gt;     func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;&gt;&gt;     func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;&gt;&gt;     func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;&gt;&gt;     func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;     func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;&gt;&gt;     func reverse() -&gt; [Element]<br>&gt;&gt;&gt;&gt;&gt;     func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;&gt;&gt;     func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;&gt;&gt;     func underestimateCount() -&gt; Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension SequenceType where Element:Equatable {<br>&gt;&gt;&gt;&gt;&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension SequenceType where Element == String {<br>&gt;&gt;&gt;&gt;&gt;     func joinWithSeparator(separator:String) -&gt; String<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>&gt;&gt;&gt;&gt;&gt; func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>&gt;&gt;&gt;&gt;&gt; func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension SequenceType where Element:Comparable {<br>&gt;&gt;&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt;     func maxElement() -&gt; Element?<br>&gt;&gt;&gt;&gt;&gt;     func minElement() -&gt; Element?<br>&gt;&gt;&gt;&gt;&gt;     func sort() -&gt; [Element]<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>&gt;&gt;&gt;&gt;&gt; - None of the extensions match the constraint on Element, so they are not exposed<br>&gt;&gt;&gt;&gt;&gt; - property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>&gt;&gt;&gt;&gt;&gt; - the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>&gt;&gt;&gt;&gt;&gt; func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;&gt;&gt; - dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>&gt;&gt;&gt;&gt;&gt; - elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; - enumerate() will return a sequence with elements of type (Int, Any)<br>&gt;&gt;&gt;&gt;&gt; - filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>&gt;&gt;&gt;&gt;&gt; - flatMap and forEach are exposed similar to contains above<br>&gt;&gt;&gt;&gt;&gt; - generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>&gt;&gt;&gt;&gt;&gt; - lexicographicalCompare fails, more below<br>&gt;&gt;&gt;&gt;&gt; - reduce has effective syntax:<br>&gt;&gt;&gt;&gt;&gt;  func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;&gt;&gt; - the rest are exposed as above except for startsWith<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -DW<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/b5895f99/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 3:45 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 12:54 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 1:21 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right. There’s also SubSequence, which you almost certainly don’t want to have to specify. For reference, once we get generic typealiases, one would be free to add<br>&gt;&gt; <br>&gt;&gt; Yes, although in the version of SequenceType which declared earlier in the thread, there was no longer a need for SubSequence, as I could just return protocol&lt;SequenceType where .Element == Element&gt; where needed.<br>&gt; <br>&gt; I suspect that there is a class of algorithms for which it is interesting to limit ourselves to “SubSequence == Self”, which one would lose by making SubSequence an existential.<br>&gt; <br>&gt; 	- Doug<br></p><p>So something like the following?<br></p><p>	protocol SequenceType {<br>	    associatedtype Element <br>	    associatedtype SubSequence:protocol&lt;SequenceType where .Element == Element&gt;<br>	    …<br>	}<br>	<br>	extension SequenceType where SubSequence == Self {<br>	    …<br>	}<br></p><p>-DW<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 19, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 19, 2016, at 5:23 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 19, 2016, at 3:45 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 19, 2016, at 12:54 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 19, 2016, at 1:21 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right. There’s also SubSequence, which you almost certainly don’t want to have to specify. For reference, once we get generic typealiases, one would be free to add<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, although in the version of SequenceType which declared earlier in the thread, there was no longer a need for SubSequence, as I could just return protocol&lt;SequenceType where .Element == Element&gt; where needed.<br>&gt;&gt; <br>&gt;&gt; I suspect that there is a class of algorithms for which it is interesting to limit ourselves to “SubSequence == Self”, which one would lose by making SubSequence an existential.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>&gt; So something like the following?<br>&gt; <br>&gt; 	protocol SequenceType {<br>&gt; 	    associatedtype Element <br>&gt; 	    associatedtype SubSequence:protocol&lt;SequenceType where .Element == Element&gt;<br>&gt; 	    …<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension SequenceType where SubSequence == Self {<br>&gt; 	    …<br>&gt; 	}<br></p><p><br>Yes, exactly. I found 6 occurrences of this in the Swift standard library.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/bc947c18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 21, 2016 at 07:00:00pm</p></header><div class="content"><p>All,<br></p><p>What do you feel are the appropriate next steps for this? <br></p><p>I’m trying to decide if I should target my energy into an initial formal proposal, experimenting to get a better idea for the details of an implementation by tinkering with the swift compiler, or focusing my energies elsewhere (either deferring or abandoning due to lack of community interest)<br></p><p>-DW<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 21, 2016 at 09:00:00pm</p></header><div class="content"><p>See inline<br></p><p>&gt; Am 19.01.2016 um 19:47 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 19, 2016, at 7:49 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like the idea to use protocol&lt;&gt; for an abstraction with many constrained protocols but for a single type constraint it is a bit verbose.<br>&gt;&gt; <br>&gt;&gt; What about generics in protocols which are only a view to its associated types or generics which create/are associated types?<br>&gt; <br>&gt; Since I imagine reusing generics syntax for constraining protocols will be a popular proposal, I figure I’ll give the reasoning I personally didn’t use, at it for my initial placeholder syntax.<br>&gt; <br>&gt; The main reason l chose an alternate syntax was that generic type usage and protocol constraints aren’t expressed the same way - protocol constraints on associated types aren’t positional and can be missing. This meant that ConcreteThing&lt;…&gt; and ProtocolType&lt;…&gt; would have different syntaxes inside the angle brackets, and thus felt like it would promote more syntax bike shedding (in addition to personally seeming less clean to me). <br>&gt; <br>&gt; Using ProtocolType&lt;…&gt; syntax would I believe be the 5th syntactic usage for &lt;...&gt; (generic type declaration, generic type use, generic constraints on methods, protocol union and now generic protocol use). Swift gets away with the multiple usages today because the syntax within the angle brackets is very similar. Expanding protocol unions meant I stayed closer to generic constraint syntax, while still having was only four syntactic usages (as in, protocol unions would umbrella under/into partial protocol constraints as a new existential type redefinition “thing&quot;)<br>&gt; <br></p><p>I think we could make ConcreteThing&lt;…&gt; and ProtocolType&lt;…&gt; equal in terms of generic syntax (which could be &quot;redefined&quot; as I proposed). Where you can also omit generic parameters for example in dictionary:<br></p><p>Dictionary&lt;Key: _ , Value: String&gt;<br>// or short form<br>Dictionary&lt; _ , String&gt;<br>// even shorter<br>[ _ : String]<br></p><p>Where the Key of Dictionary is of any type which conforms to `Hashable`.<br></p><p>Note: `Hashable` is self constrained and behaviors of an any type of a self constrained protocol has to be discussed.<br>Second note: This is probably a bad example in terms of usability but it should only show the similar generic syntax (see my proposal).<br></p><p>&gt; As an example, the liberties I took with SequenceType took it down to a single associated type, but CollectionType would still have a minimum of Index and Element. I would need to declare CollectionType&lt;where .Index == Index&gt; or similar if I were wishing to partially constrain just one parameter. This is also eliminates most of the typing savings of using generic type usage syntax.<br></p><p>I thought the proposed syntax would be:<br></p><p>// for a concrete index of type Int<br>protocol&lt;CollectionType where .Index == Int&gt;<br></p><p>What do you think about my proposed syntax ?<br></p><p>CollectionType&lt;Index: Int&gt;<br></p><p>&gt; <br>&gt; Finally and to a lesser degree, the parameters for a generic type define a single concrete type, while for a protocol it defines a view of some concrete type. Today I can intuit Foo&lt;String&gt; is the name of a concrete type. During proposal, there was more value in having a placeholder syntax that did not damage intuition about concrete types.<br>&gt; <br></p><p>What do you mean by &quot;intuition about concrete types&quot; ?<br>Why not allowing Foo&lt; _ &gt; (to be for instance a covariant type to all Foo) ? It&#39;s similar to a protocol, but it is a more concrete type where you don&#39;t have to define a protocol to use Foo as a standalone type in a more general way. <br></p><p>- Maximilian<br></p><p>&gt; -DW<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Example of a simple protocol which models a node of a tree:<br>&gt;&gt; <br>&gt;&gt; // Before<br>&gt;&gt; <br>&gt;&gt; // NodeType can be anything<br>&gt;&gt; // currently Swift doesn&#39;t allow<br>&gt;&gt; // `typealias NodeType: Node`<br>&gt;&gt; //<br>&gt;&gt; // or even where clauses <br>&gt;&gt; // `typealias NodeType: Node where NodeType.T == T`<br>&gt;&gt; protocol Node {<br>&gt;&gt; 	typealias T<br>&gt;&gt; 	typealias NodeType<br>&gt;&gt; 	<br>&gt;&gt; 	var value: T { get }<br>&gt;&gt; 	var nodes: [NodeType] { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // After<br>&gt;&gt; protocol Node&lt;T&gt; {<br>&gt;&gt; 	typealias T // probably remove this declaration (see reason below)<br>&gt;&gt; 	var value: T { get }<br>&gt;&gt; 	var nodes: [Node&lt;T&gt;] { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; So a generic parameter is placed after the protocol name. Therefore a corresponding associated type could be synthesized making its declaration in the body of the protocol unnecessary.<br>&gt;&gt; <br>&gt;&gt; In order to let this still compile:<br>&gt;&gt; <br>&gt;&gt; 	func afunction&lt;S: SequenceType where S.Generator.Element == Int&gt;(s: S){}<br>&gt;&gt; <br>&gt;&gt; there could be a general Swift feature to get the generic type by dot syntax (e.g. synthesized typealiases for every generic parameter).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Implementation:<br>&gt;&gt; The function declaration above could be rewritten to using a function like generic parameter parameter syntax for protocols:<br>&gt;&gt; <br>&gt;&gt;         // Declaration of SequenceType<br>&gt;&gt;         protocol SequenceType&lt;Element: Generator.Element, Generator: GeneratorType, SubSequence&gt; { … }<br>&gt;&gt;     //                           ^~~~ using : in oder to allow default types with =<br>&gt;&gt; <br>&gt;&gt;         // Using &quot;_&quot; to leave it unspecified eg. Any<br>&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;, SubSequence: _&gt;){}<br>&gt;&gt;     // omitting `SubSequence: _` since the type is already unambiguous<br>&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int, Generator: GeneratorType&lt;Element: Int&gt;&gt;){}<br>&gt;&gt;     // omitting `Generator: GeneratorType&lt;Int&gt;` since the type of `Generator` can be inferred from Element<br>&gt;&gt;     func afunction(s: SequenceType&lt;Element: Int&gt;){}<br>&gt;&gt; <br>&gt;&gt; The order of arguments is in this case irrelevant, but should probably be in a strict ordering to make it more consistent with the point below.<br>&gt;&gt; <br>&gt;&gt; In order to have a more general generic parameter behavior (to work with structs, classes and enums) we could also allow to use these without external names and only their order. So the example above would look like this:<br>&gt;&gt; <br>&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;     func afunction(s: SequenceType&lt;Int, GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt;     func afunction(s: SequenceType&lt;Int&gt;){}<br>&gt;&gt;     <br>&gt;&gt;     // These two functions don&#39;t produce an error since `Element` can be inferred<br>&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;, _&gt;){}<br>&gt;&gt;     func afunction(s: SequenceType&lt;GeneratorType&lt;Int&gt;&gt;){}<br>&gt;&gt; <br>&gt;&gt;     // for an unconstrained Sequence &quot;_&quot; can be used in order to make it clear: &quot;there could be generic parameters&quot;<br>&gt;&gt;     func afunction(s: SequenceType&lt;_&gt;){}<br>&gt;&gt; <br>&gt;&gt; For instance `Array` and `Dictionary` also can apply to this model.<br>&gt;&gt; <br>&gt;&gt; Also where clauses could be used in generic parameter declarations which are disallowed for associated types (currently).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; What do you think about this approach?<br>&gt;&gt; <br>&gt;&gt; Should SequenceType&lt;_&gt; be equal to SequenceType&lt;Any&gt; / SequenceType&lt;Element: Any&gt; ?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 19.01.2016 um 00:32 schrieb David Waite via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 1:18 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let x:SequenceType = [1,2,3] // no constraints specified whatsoever<br>&gt;&gt;&gt;&gt;&gt; let y:protocol&lt;SequenceType where Generator.Element == String&gt; = [“foo”, “bar”] // partially constrained<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Not wanting to start throwing paint, but &quot;Generator.Element&quot; could be ambiguous with a Generator in the lexical scope. You&#39;ll probably want some way to differentiate it (eg, a leading dot). Otherwise, this is the syntactic direction that I think makes the most sense.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, I’ll use that below. There is a right balance in extending protocol&lt;&gt;. For instance, I did not like the following at all:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	protocol&lt;S:SequenceType where S.Generator.Element == String&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One interesting side-effect to note is that SequenceType could be redefined to only have “Element” as an associated type. Instead of Generator or SubSequence being associated types, methods could return partially constrained GenericType or SequenceType from the appropriate methods. This would be one way of eliminating issues today with recursive use of associated types (as well as SubSequence over-constraining the output of various algorithms to a single concrete type)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Assuming nobody cares about the identity of the Generator type, which is probably a safe assumption. Note that one could implement this design today by using a function taking no arguments and returning an Element? in lieu of &quot;Generator”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, as an aside I was actually curious GeneratorType existed when I was first diving into the standard library, considering it could just be a closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; For the “opening” of an existential type to find the concrete type it stores dynamically, I’m currently using a different syntax just because the “open x as T” originally given makes ‘open’ a keyword’ and makes it unclear where ’T’ came from<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, the issue of &quot;which name did I introduce?&quot; is tricky here. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I’m instead overloading the typealias keyword when used within an expression context:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; typealias T = x.dynamicType<br>&gt;&gt;&gt;&gt;&gt; let xT = x as! T<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; x will have to be immutable for this to make sense. That&#39;s why my ugly &quot;open&quot; expression extracts a new value and gives it a fresh type in one lexically-scoped block. Both the type and the value end up being scoped. Otherwise, one might reassign &quot;x&quot; with a different dynamic type... Then what does T mean?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is an area that I need to understand compiler behavior more here (I’ve been researching)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If ’T’ internally behaves like an immutable variable with lexical scope, then ’typealias’ in a code block is just another statement, and the type would be based on the value of ‘x’ at the point of execution:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var x:Any = “Initial”<br>&gt;&gt;&gt; typealias T = x.dynamicType // String<br>&gt;&gt;&gt; x = 1<br>&gt;&gt;&gt; let xT = x as! T // fails precondition as if I had said x as! String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m guessing from your comment however that T would not a variable. In which case, it makes sense to be more restrictive in use (such as requiring immutability). This is also more consistent with the use of typealias in other contexts, if that was the syntax one was going with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I suggest you also look at what can be done with an existential value that hasn&#39;t been opened explicitly. Can I call &quot;generate&quot; on a SequenceType value, and what do I get back?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Depends on how far we are willing to go. If you are only willing to expose the invariants in the face of the constraints given (in this case none), all you would get exposed is “underestimateCount”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you are willing to expose anything which can be expressed by certain type safety rules (needing formal definition later), then you can do quite a bit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To start, let me express SequenceType relying on the partially constrained protocols, taking a few liberties: <br>&gt;&gt;&gt; - pruning some alternate forms<br>&gt;&gt;&gt; - removing SubSequence and Generator associated types and just having Element<br>&gt;&gt;&gt; - using the protocol&lt;&gt; syntax described before (with . prefix)<br>&gt;&gt;&gt; - returning partially constrained SequenceTypes rather than stdlib concrete types like JoinSequence in a few cases. <br>&gt;&gt;&gt; - eliminate usage of AnySequence in definitions (not needed)<br>&gt;&gt;&gt; - assuming a change in protocol LazySequenceType to be expressed in terms of Element rather than a base SequenceType<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol SequenceType {<br>&gt;&gt;&gt;     associatedtype Element<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     var lazy:protocol&lt;LazySequenceType where .Element == Element&gt; { get }<br>&gt;&gt;&gt;     func contains(@noescape predicate:(Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;     func dropFirst(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func dropLast(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func elementsEqual(other:protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element)) -&gt; Bool<br>&gt;&gt;&gt;     func enumerate() -&gt; protocol&lt;SequenceType where .Element == (Int, Element)&gt;<br>&gt;&gt;&gt;     func filter(@noescape includeElement: (Element) throws-&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;     func flatMap&lt;E&gt;(transform: (Element) throws -&gt; protocol&lt;SequenceType where .Element:E&gt;) rethrows -&gt; [E]<br>&gt;&gt;&gt;     func flatMap&lt;T&gt;(@noescape transform: (Element) throws -&gt; T?) rethrows -&gt; [T]<br>&gt;&gt;&gt;     func forEach(@noescape body: (Element) throws -&gt; ()) rethrows<br>&gt;&gt;&gt;     func generate() -&gt; protocol&lt;GeneratorType where .Element == Element&gt;<br>&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isOrderedBefore:(Element,Element) throws-&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;     func map&lt;T&gt;(@noescape transform: (Element) throws -&gt; T) rethrows -&gt; [T]<br>&gt;&gt;&gt;     func maxElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;     func minElement(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; Element?<br>&gt;&gt;&gt;     func prefix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Element) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt;     func reverse() -&gt; [Element]<br>&gt;&gt;&gt;     func sort(@noescape isOrderedBefore: (Element,Element) throws -&gt; Bool) rethrows -&gt; [Element]<br>&gt;&gt;&gt;     func split(maxSplit: Int, allowEmptySubsequences: Bool, @noescape isSeparator: (Element) throws -&gt; Bool) rethrows -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element&gt;, @noescape isEquivalent: (Element, Element) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt;     func suffix(n:Int) -&gt; protocol&lt;SequenceType where .Element == Element&gt;<br>&gt;&gt;&gt;     func underestimateCount() -&gt; Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element:Equatable {<br>&gt;&gt;&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;&gt;&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;&gt;&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element == String {<br>&gt;&gt;&gt;     func joinWithSeparator(separator:String) -&gt; String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element:protocol&lt;SequenceType&gt;<br>&gt;&gt;&gt; func flatten() -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;<br>&gt;&gt;&gt; func joinWithSeparator(separator: protocol&lt;SequenceType where .Element = Element.Element&gt;) -&gt; protocol&lt;SequenceType where .Element == Element.Element&gt;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SequenceType where Element:Comparable {<br>&gt;&gt;&gt;     func lexicographicalCompare(other: protocol&lt;SequenceType where .Element == Element&gt;) -&gt; Bool<br>&gt;&gt;&gt;     func maxElement() -&gt; Element?<br>&gt;&gt;&gt;     func minElement() -&gt; Element?<br>&gt;&gt;&gt;     func sort() -&gt; [Element]<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Now, mapping this in terms of just an unconstrained SequenceType, which is shorthand for protocol&lt;SequenceType where .Element:Any&gt;:<br>&gt;&gt;&gt; - None of the extensions match the constraint on Element, so they are not exposed<br>&gt;&gt;&gt; - property Lazy is exposed as an unconstrained LazySequenceType, aka protocol&lt;LazySequenceType where .Element:Any&gt;<br>&gt;&gt;&gt; - the predicate function in contains is not constrained by a particular kind of element, so it becomes (Any)-&gt;Bool, e.g.:<br>&gt;&gt;&gt; func contains(@noescape predicate:(Any) throws -&gt; Bool) rethrows -&gt; Bool<br>&gt;&gt;&gt; - dropFirst/dropLast would return an unconstrained SequenceType. This would need to leverage rules around constrained protocol variance/equivalence.<br>&gt;&gt;&gt; - elementsEqual was changed to no longer be generic - one can pass in any SequenceType constrained to have the same Element type. The function parameter, similar to contains above, now has the signature (Any, Any)-&gt;Bool<br>&gt;&gt;&gt; - enumerate() will return a sequence with elements of type (Int, Any)<br>&gt;&gt;&gt; - filter takes a (Any) throws -&gt; Bool method and returns [Any]<br>&gt;&gt;&gt; - flatMap and forEach are exposed similar to contains above<br>&gt;&gt;&gt; - generate returns an unconstrained GeneratorType (so it will have a single method func next() -&gt; Any?)<br>&gt;&gt;&gt; - lexicographicalCompare fails, more below<br>&gt;&gt;&gt; - reduce has effective syntax:<br>&gt;&gt;&gt;  func reduce&lt;T&gt;(initial: T, @noescape combine: (T, Any) throws -&gt; T) rethrows -&gt; T<br>&gt;&gt;&gt; - the rest are exposed as above except for startsWith<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So all functionality except lexicographicalCompare and startsWith could at least in theory be exposed safely. These cannot be exposed cleanly because method expected an input sequence with the same element type, but the element type is not invariantly constrained. Self properties and method arguments are an equivalent problem, except that for a Self argument can only be invariantly constrained when you know the implementing concrete type - hence wanting a system to dynamically reason about said types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems like a good amount of exposed functionality. Granted, it is not free to work at the level of protocols vs concrete types, and this does not attempt to simplify that. However, this proposal seems to bridge the gap between protocols without associated types and protocols with them. I also am happy with the amount of functionality that can be exposed safely as well as the consistency (A lexicographicalCompare function working on heterogenous sequences would have to be declared differently)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/5e0b7c21/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 21, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jan 21, 2016, at 1:29 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I think we could make ConcreteThing&lt;…&gt; and ProtocolType&lt;…&gt; equal in terms of generic syntax (which could be &quot;redefined&quot; as I proposed). Where you can also omit generic parameters for example in dictionary:<br>&gt; <br>&gt; Dictionary&lt;Key: _ , Value: String&gt;<br>&gt; // or short form<br>&gt; Dictionary&lt; _ , String&gt;<br>&gt; // even shorter<br>&gt; [ _ : String]<br>&gt; <br>&gt; Where the Key of Dictionary is of any type which conforms to `Hashable`.<br>&gt; <br>&gt; Note: `Hashable` is self constrained and behaviors of an any type of a self constrained protocol has to be discussed.<br>&gt; Second note: This is probably a bad example in terms of usability but it should only show the similar generic syntax (see my proposal).<br></p><p>I mentally treat self as an associated type bound to the first concrete subtype in the type chain. (first, because of class inheritance). <br></p><p>Re: syntax, like I said I’m trying to defer too much syntax discussion until there is more participation/interest in the concept and approach (I think only four people have participated in this thread over nearly two weeks). <br></p><p>But I’ll bite :-)<br></p><p>It appears you are proposing that generics be expanded to be keyed either by generic type parameter name or positionally and adding _ to positional syntax, while I imagine protocols would remain just keyed by name. Protocols would not have a simplistic order to implement (for example, I could be extending two parent protocols, both with their own associated types)<br></p><p>&gt; // for a concrete index of type Int<br>&gt; protocol&lt;CollectionType where .Index == Int&gt;<br>&gt; <br>&gt; What do you think about my proposed syntax ?<br>&gt; <br>&gt; CollectionType&lt;Index: Int&gt;<br></p><p>I personally think there is a bit too much overlap between ‘where’ syntax, and possibly conflicting usage. In your example, would Index: Foo indicate that index is exactly Foo, is Foo or some subtype, or is a concrete implementation of Foo? If there were two syntaxes, I’d hope one to be a much closer shortening of the other.<br></p><p>&gt;&gt; Finally and to a lesser degree, the parameters for a generic type define a single concrete type, while for a protocol it defines a view of some concrete type. Today I can intuit Foo&lt;String&gt; is the name of a concrete type. During proposal, there was more value in having a placeholder syntax that did not damage intuition about concrete types.<br>&gt;&gt; <br>&gt; <br>&gt; What do you mean by &quot;intuition about concrete types” ?<br></p><p>Today, you cannot use generics except to declare or talk about a specific concrete type with a specific implementation and behavior - you know you are dealing with a concrete, initializable Foo&lt;Int&gt;. Among other things, you know that the full published API for Foo&lt;Int&gt; is available.<br></p><p>From my perspective, Foo has an implicitly declared protocol. It is a protocol tied to a single implementation (or to subtypes which inherit and override that implementation, in the case of classes).<br></p><p>This proposal (excluding type-opening) is about being able to use a protocol with associated types more loosely. My approach is to expose the methods which can be expressed safely and uniformly based on the type constraints available, and to hide the rest. Today, you would have to do this by declaring a new protocol and using extensions to opt concrete types into it, by using generic constraints exclusively, and/or using wrapper types like AnySequence to do type erasure.<br></p><p>&gt; Why not allowing Foo&lt; _ &gt; (to be for instance a covariant type to all Foo) ? It&#39;s similar to a protocol, but it is a more concrete type where you don&#39;t have to define a protocol to use Foo as a standalone type in a more general way. <br>&gt; <br></p><p>I do have a mild personal conflict around whether exposing the ability to have partially constrained generics is a good idea, but I admit my hesitation is based on philosophies of good application and API design, and not based on language design.<br></p><p> implicit protocols on types seem pragmatic, because otherwise I’d have to create a protocol just for others to use me. <br></p><p>Allowing a protocol with associated types to be partially constrained seems pragmatic to me, since otherwise I have to use one of the workarounds above (hand-coded new protocol, generic constraints ever, and/or type-erasure struct-wrapper).<br></p><p>Expanding the usage of the implicit protocol on some generic type seems anti-pragmatic, just because it allows someone to go longer before they really evaluate whether locking consumers of their API into a single implementation is a good idea. They can always declare a protocol explicitly if they want partially constrained behavior.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160121/9a3b84aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 22, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 22.01.2016 um 03:05 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 21, 2016, at 1:29 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think we could make ConcreteThing&lt;…&gt; and ProtocolType&lt;…&gt; equal in terms of generic syntax (which could be &quot;redefined&quot; as I proposed). Where you can also omit generic parameters for example in dictionary:<br>&gt;&gt; <br>&gt;&gt; Dictionary&lt;Key: _ , Value: String&gt;<br>&gt;&gt; // or short form<br>&gt;&gt; Dictionary&lt; _ , String&gt;<br>&gt;&gt; // even shorter<br>&gt;&gt; [ _ : String]<br>&gt;&gt; <br>&gt;&gt; Where the Key of Dictionary is of any type which conforms to `Hashable`.<br>&gt;&gt; <br>&gt;&gt; Note: `Hashable` is self constrained and behaviors of an any type of a self constrained protocol has to be discussed.<br>&gt;&gt; Second note: This is probably a bad example in terms of usability but it should only show the similar generic syntax (see my proposal).<br>&gt; <br>&gt; I mentally treat self as an associated type bound to the first concrete subtype in the type chain. (first, because of class inheritance). <br></p><p>Since Hashable is only self constrained due to Equatable should we even allow this code?<br></p><p>let a: Equatable = 1<br>let b: Equatable = &quot;2&quot;<br></p><p>a == b<br></p><p>// in this case there could be a more general == function<br>func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>    if let yAsT = y as? T {<br>        return yAsT == x }<br>    return false<br>}<br></p><p>But it seems like that there has to be a different implementation of `self` constrained functions (like ==) if a self constrained protocol is used without specifying `self`.<br></p><p>&gt; <br>&gt; Re: syntax, like I said I’m trying to defer too much syntax discussion until there is more participation/interest in the concept and approach (I think only four people have participated in this thread over nearly two weeks). <br>&gt; <br>&gt; But I’ll bite :-)<br>&gt; <br>&gt; It appears you are proposing that generics be expanded to be keyed either by generic type parameter name or positionally and adding _ to positional syntax, while I imagine protocols would remain just keyed by name.<br></p><p>What do you mean by:<br></p><p>&gt; Protocols would not have a simplistic order to implement (for example, I could be extending two parent protocols, both with their own associated types)<br>&gt; <br></p><p>Do you mean conforming to a protocol by &quot;extending&quot;?<br>In this case it would be even more explicit about types:<br></p><p>struct Numbers: SequenceType&lt;Element: Int, SubSequence: Numbers&gt; { ... }<br></p><p><br>To be clear, I&#39;m proposing:<br>- Generic syntax for all types including protocols to be the same<br>- Named generic parameters eg: Array&lt;Element: Int&gt;  ,  CollectionType&lt;Element: String, Index: Int&gt;<br>- Without name: Array&lt;Int&gt;  ,  CollectionType&lt;String, Int&gt;<br>- Introduce &quot;_&quot; as placeholder for a covariant &quot;any type&quot; to make protocols and other generic types partially constrained:<br>Array&lt;Element: _ &gt;  ,  CollectionType&lt;Element: String, Index: _ &gt;<br>which is the same as<br>Array&lt; _ &gt;  ,  CollectionType&lt;String, _ &gt; == CollectionType&lt;String&gt; == CollectionType&lt;Element: String&gt;<br></p><p><br>&gt;&gt; // for a concrete index of type Int<br>&gt;&gt; protocol&lt;CollectionType where .Index == Int&gt;<br>&gt;&gt; <br>&gt;&gt; What do you think about my proposed syntax ?<br>&gt;&gt; <br>&gt;&gt; CollectionType&lt;Index: Int&gt;<br>&gt; <br>&gt; I personally think there is a bit too much overlap between ‘where’ syntax, and possibly conflicting usage. In your example, would Index: Foo indicate that index is exactly Foo, is Foo or some subtype, or is a concrete implementation of Foo? If there were two syntaxes, I’d hope one to be a much closer shortening of the other.<br>&gt; <br></p><p>Index: Foo<br>Index is of type Foo or a Subtype.<br></p><p>- If Foo is a struct or a enum, Index can be of type: Foo or a subtype e.g. Foo&lt;Int&gt; and Foo&lt; _ &gt;<br></p><p>- If Foo is a protocol or a class, Index can be of type (additionally to the ones above): subtypes e.g. Subclass&lt;Int&gt; , Subclass&lt; _ &gt; and Int if Int is of type Foo<br></p><p>&gt;&gt;&gt; Finally and to a lesser degree, the parameters for a generic type define a single concrete type, while for a protocol it defines a view of some concrete type. Today I can intuit Foo&lt;String&gt; is the name of a concrete type. During proposal, there was more value in having a placeholder syntax that did not damage intuition about concrete types.<br>&gt;&gt; <br>&gt;&gt; What do you mean by &quot;intuition about concrete types” ?<br>&gt; <br>&gt; Today, you cannot use generics except to declare or talk about a specific concrete type with a specific implementation and behavior - you know you are dealing with a concrete, initializable Foo&lt;Int&gt;. Among other things, you know that the full published API for Foo&lt;Int&gt; is available.<br>&gt; <br>&gt; From my perspective, Foo has an implicitly declared protocol. It is a protocol tied to a single implementation (or to subtypes which inherit and override that implementation, in the case of classes).<br>&gt; <br>&gt; This proposal (excluding type-opening) is about being able to use a protocol with associated types more loosely. My approach is to expose the methods which can be expressed safely and uniformly based on the type constraints available, and to hide the rest. Today, you would have to do this by declaring a new protocol and using extensions to opt concrete types into it, by using generic constraints exclusively, and/or using wrapper types like AnySequence to do type erasure.<br>&gt; <br>&gt;&gt; Why not allowing Foo&lt; _ &gt; (to be for instance a covariant type to all Foo) ? It&#39;s similar to a protocol, but it is a more concrete type where you don&#39;t have to define a protocol to use Foo as a standalone type in a more general way. <br>&gt; <br>&gt; I do have a mild personal conflict around whether exposing the ability to have partially constrained generics is a good idea, but I admit my hesitation is based on philosophies of good application and API design, and not based on language design.<br>&gt; <br>&gt;  implicit protocols on types seem pragmatic, because otherwise I’d have to create a protocol just for others to use me. <br>&gt; <br>&gt; Allowing a protocol with associated types to be partially constrained seems pragmatic to me, since otherwise I have to use one of the workarounds above (hand-coded new protocol, generic constraints ever, and/or type-erasure struct-wrapper).<br>&gt; <br>&gt; Expanding the usage of the implicit protocol on some generic type seems anti-pragmatic, just because it allows someone to go longer before they really evaluate whether locking consumers of their API into a single implementation is a good idea. They can always declare a protocol explicitly if they want partially constrained behavior.<br></p><p>That was also my concern since I want to keep the generic syntax consistent with protocols. So maybe we could make it the same in case of generic parameter names but without the &quot;_&quot; so there are no protocol like behaviors for generic types.<br></p><p>Even though it would be nice to have a covariant Array&lt; _ &gt; type.<br>Talking about covariance how about (protocol Test {} , Int conforms to Test) a covariant Array&lt;Element: Test&gt; to Array&lt;Int&gt; and an invariant Array&lt;Test&gt;?<br></p><p>- Maximilian<br>&gt; <br>&gt; -DW<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/bab5bb54/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 22, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 9:36 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 22.01.2016 um 03:05 schrieb David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt;:<br>&gt; <br>&gt; Since Hashable is only self constrained due to Equatable should we even allow this code?<br>&gt; <br>&gt; let a: Equatable = 1<br>&gt; let b: Equatable = &quot;2&quot;<br>&gt; <br>&gt; a == b<br>&gt; <br>&gt; // in this case there could be a more general == function<br>&gt; func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>&gt;     if let yAsT = y as? T {<br>&gt;         return yAsT == x }<br>&gt;     return false<br>&gt; }<br></p><p>That is fun code :-) But I don’t understand what it has to do with Hashable<br></p><p>Since today equatable mandates a defined, public == method, and I think the generic is always loses to that specificity. You don’t even need dynamic casting, because your generic version only gets called when there isn’t a non-generic version.<br></p><p>// in this case there could be a more general == function<br>func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>    return false<br>}<br></p><p>1 == 1 // true<br>1 == “1” // false<br></p><p>Swift doesn’t seem to fight as hard as other languages against overloads that may be ambiguous in some contexts (for instance, two methods identical except for different return types). The flexibility of the compiler in interpreting code is one of the reasons that implicit conversions (such as with optionals or objective C bridging types) can lead to such confusing behavior in code. Most recent case to blow my mind,<br></p><p>let a = [[1]]<br>a == a // error: binary operator &#39;==&#39; cannot be applied to two &#39;[Array&lt;Int&gt;]&#39; operands<br></p><p>import Foundation<br></p><p>a == a // $R2: Bool = true<br></p><p>This works because the compiler promotes [[1]] to either [NSArray] or an NSArray outright to get to a working == operator.<br></p><p><br>&gt; But it seems like that there has to be a different implementation of `self` constrained functions (like ==) if a self constrained protocol is used without specifying `self`.<br></p><p>Thats what we mean by opening the type - exposing enough of the dynamic type information to the calling context such that we can safely expose methods. E.g. Something like this would be equivalent to your earlier fun code, except now the call site of the function is not generically constrained:<br></p><p>let a:Equatable = 1<br>let b:Equatable = “1”<br></p><p>func ==(lhs:Equatable, rhs:Equatable) -&gt; Bool {<br>    typealias T = lhs.dynamicType<br>    let x = lhs as! T<br>    if let y = rhs as? T {<br>         return x == y<br>    }<br>    return false<br>}<br></p><p>a == b // false<br></p><p>&gt; <br>&gt;&gt; Protocols would not have a simplistic order to implement (for example, I could be extending two parent protocols, both with their own associated types)<br>&gt;&gt; <br>&gt; <br>&gt; Do you mean conforming to a protocol by &quot;extending&quot;?<br>&gt; In this case it would be even more explicit about types:<br></p><p><br>Sorry, I used Java parlance where interfaces can extend other interfaces to add additional requirements/exposed capabilities.<br></p><p>The specific example I had in mind is CollectionType, which inherits from both SequenceType and Indexable. Would Index come before or after Generator and SubSequence if you were positionally declaring arguments. Should swapping the inheritance order on CollectionType be a fragile change?<br></p><p><br>&gt; To be clear, I&#39;m proposing:<br>&gt; - Generic syntax for all types including protocols to be the same<br>&gt; - Named generic parameters eg: Array&lt;Element: Int&gt;  ,  CollectionType&lt;Element: String, Index: Int&gt;<br></p><p>I’m not a fan of this syntax, because in an example where clause “where Element:Number&quot; is a covariant constraint, and here (I think) you are using it as an invariant constraint. This seems confusing unless you specify Array&lt;Element == Int&gt;, etc.<br></p><p>You have the issue today that SequenceType does not expose Element but Generator. This kind of relationship can’t be expressed without a ‘where’ type syntax. I did sketch out a version of SequenceType that uses Element explicitly, so I assume this is what you are basing on. Still, such design can’t be assumed universal.<br></p><p>&gt; - Without name: Array&lt;Int&gt;  ,  CollectionType&lt;String, Int&gt;<br>I already pointed out the CollectionType issue with positional arguments above. In addition, SequenceType will have an associated type of SubSequence, which I assume you are assuming would be the third argument and are implicitly stating “don’t care”.<br></p><p>&gt;&gt; I personally think there is a bit too much overlap between ‘where’ syntax, and possibly conflicting usage. In your example, would Index: Foo indicate that index is exactly Foo, is Foo or some subtype, or is a concrete implementation of Foo? If there were two syntaxes, I’d hope one to be a much closer shortening of the other.<br>&gt;&gt; <br>&gt; <br>&gt; Index: Foo<br>&gt; Index is of type Foo or a Subtype.<br></p><p>In that, the covariant case, Array&lt;Element:Number&gt; is _different_ than Array&lt;Number&gt; today.<br></p><p>Today, Array&lt;Number&gt; and Array&lt;Int&gt; are different concrete types. One deals in terms of Numbers, and one in terms of Ints. They are structured in memory different, etc.<br></p><p>When I say partial constraints, applied to generics in this case (reluctantly), I’m saying the following:<br></p><p>Implicitly define a protocol around all concrete Array instances where Element is defined to be Number or a subtype of Number, exposing all methods, properties, etc which are safe.<br></p><p>Safety rules are equivalency rules here: If a method or property returns Element, I can say that it is safe to represent the result of “var first:Element {get}” as a Number, because in the cases where it returns a subtype like Int, I can still safely upcast to Number. I have a safe and uniform interface.<br></p><p>If a method takes an argument or for any property setter, I have to require Element to be invariant. Modifying the first item of an array isn’t safe, because I might try to assign an Int value when really its a UInt8 array.<br></p><p>Subscripts unfortunately require both get and set, so even the getter has to be hidden currently if the type isn’t invariant. I’m not sure why the language requires this, TBH<br></p><p>That we are constraining the exposure of a protocol to only expose what is available by the associated type rules we specified is why I stayed away from terse, generic type syntax to start the proposal. Eventually, consensus might be that generic type form is better, but it adds an additional complexity to the understanding of the type model, which is the important part now in discussion. You are now using an existing syntax to refer to a new thing with new properties.<br></p><p>This is even more confusing if you partially constrain a generic type, because now Array&lt;Number&gt; (aka Array&lt;where Element == Number&gt; and Array&lt;where Element:Number&gt; have different properties (one is a protocol while the other is a concrete type, functionality is hidden because it is unsafe, possible boxing onto the heap and dynamic dispatch, etc)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I do have a mild personal conflict around whether exposing the ability to have partially constrained generics is a good idea, but I admit my hesitation is based on philosophies of good application and API design, and not based on language design.<br>&gt;&gt; <br>&gt;&gt;  implicit protocols on types seem pragmatic, because otherwise I’d have to create a protocol just for others to use me. <br>&gt;&gt; <br>&gt;&gt; Allowing a protocol with associated types to be partially constrained seems pragmatic to me, since otherwise I have to use one of the workarounds above (hand-coded new protocol, generic constraints ever, and/or type-erasure struct-wrapper).<br>&gt;&gt; <br>&gt;&gt; Expanding the usage of the implicit protocol on some generic type seems anti-pragmatic, just because it allows someone to go longer before they really evaluate whether locking consumers of their API into a single implementation is a good idea. They can always declare a protocol explicitly if they want partially constrained behavior.<br>&gt; <br>&gt; That was also my concern since I want to keep the generic syntax consistent with protocols. So maybe we could make it the same in case of generic parameter names but without the &quot;_&quot; so there are no protocol like behaviors for generic types.<br>&gt; <br>&gt; Even though it would be nice to have a covariant Array&lt; _ &gt; type.<br></p><p>Yep :-) I can’t speak for the core team, but from my perspective whether this proposal lives or dies depends on:<br></p><p>1. Implementability<br>2. Abiding by the Principal of Least Surprise<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/9b37cec3/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 25, 2016 at 10:00:00pm</p></header><div class="content"><p>Inline<br></p><p>&gt; Am 22.01.2016 um 21:41 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 22, 2016, at 9:36 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Am 22.01.2016 um 03:05 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt;&gt; <br>&gt;&gt; Since Hashable is only self constrained due to Equatable should we even allow this code?<br>&gt;&gt; <br>&gt;&gt; let a: Equatable = 1<br>&gt;&gt; let b: Equatable = &quot;2&quot;<br>&gt;&gt; <br>&gt;&gt; a == b<br>&gt;&gt; <br>&gt;&gt; // in this case there could be a more general == function<br>&gt;&gt; func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>&gt;&gt;     if let yAsT = y as? T {<br>&gt;&gt;         return yAsT == x }<br>&gt;&gt;     return false<br>&gt;&gt; }<br>&gt; <br>&gt; That is fun code :-) But I don’t understand what it has to do with Hashable<br></p><p>It&#39;s more an issue with Equatable which has self constraints.<br></p><p>&gt; Since today equatable mandates a defined, public == method, and I think the generic is always loses to that specificity. You don’t even need dynamic casting, because your generic version only gets called when there isn’t a non-generic version.<br>&gt; <br>&gt; // in this case there could be a more general == function<br>&gt; func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>&gt;     return false<br>&gt; }<br>&gt; <br>&gt; 1 == 1 // true<br>&gt; 1 == “1” // false<br></p><p>I thought also of this example:<br></p><p>let a: Equatable = 1<br>let b: Equatable = 2<br></p><p>a == b // would fail in your case<br></p><p>&gt; Swift doesn’t seem to fight as hard as other languages against overloads that may be ambiguous in some contexts (for instance, two methods identical except for different return types). The flexibility of the compiler in interpreting code is one of the reasons that implicit conversions (such as with optionals or objective C bridging types) can lead to such confusing behavior in code. Most recent case to blow my mind,<br>&gt; <br>&gt; let a = [[1]]<br>&gt; a == a // error: binary operator &#39;==&#39; cannot be applied to two &#39;[Array&lt;Int&gt;]&#39; operands<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; a == a // $R2: Bool = true<br>&gt; <br>&gt; This works because the compiler promotes [[1]] to either [NSArray] or an NSArray outright to get to a working == operator.<br>&gt; <br>&gt; <br>&gt;&gt; But it seems like that there has to be a different implementation of `self` constrained functions (like ==) if a self constrained protocol is used without specifying `self`.<br>&gt; <br>&gt; Thats what we mean by opening the type - exposing enough of the dynamic type information to the calling context such that we can safely expose methods. E.g. Something like this would be equivalent to your earlier fun code, except now the call site of the function is not generically constrained:<br>&gt; <br>&gt; let a:Equatable = 1<br>&gt; let b:Equatable = “1”<br>&gt; <br>&gt; func ==(lhs:Equatable, rhs:Equatable) -&gt; Bool {<br>&gt;     typealias T = lhs.dynamicType<br>&gt;     let x = lhs as! T<br>&gt;     if let y = rhs as? T {<br>&gt;          return x == y<br>&gt;     }<br>&gt;     return false<br>&gt; }<br>&gt; <br>&gt; a == b // false<br></p><p>That&#39;s exactly what I wanted to do :)<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Protocols would not have a simplistic order to implement (for example, I could be extending two parent protocols, both with their own associated types)<br>&gt;&gt; <br>&gt;&gt; Do you mean conforming to a protocol by &quot;extending&quot;?<br>&gt;&gt; In this case it would be even more explicit about types:<br>&gt; <br>&gt; <br>&gt; Sorry, I used Java parlance where interfaces can extend other interfaces to add additional requirements/exposed capabilities.<br>&gt; <br>&gt; The specific example I had in mind is CollectionType, which inherits from both SequenceType and Indexable. Would Index come before or after Generator and SubSequence if you were positionally declaring arguments. Should swapping the inheritance order on CollectionType be a fragile change?<br>&gt; <br>&gt; <br>&gt;&gt; To be clear, I&#39;m proposing:<br>&gt;&gt; - Generic syntax for all types including protocols to be the same<br>&gt;&gt; - Named generic parameters eg: Array&lt;Element: Int&gt;  ,  CollectionType&lt;Element: String, Index: Int&gt;<br>&gt; <br>&gt; I’m not a fan of this syntax, because in an example where clause “where Element:Number&quot; is a covariant constraint, and here (I think) you are using it as an invariant constraint. This seems confusing unless you specify Array&lt;Element == Int&gt;, etc.<br>&gt; <br>&gt; You have the issue today that SequenceType does not expose Element but Generator. This kind of relationship can’t be expressed without a ‘where’ type syntax. I did sketch out a version of SequenceType that uses Element explicitly, so I assume this is what you are basing on. Still, such design can’t be assumed universal.<br>&gt; <br>&gt;&gt; - Without name: Array&lt;Int&gt;  ,  CollectionType&lt;String, Int&gt;<br>&gt; I already pointed out the CollectionType issue with positional arguments above. In addition, SequenceType will have an associated type of SubSequence, which I assume you are assuming would be the third argument and are implicitly stating “don’t care”.<br>&gt; <br>&gt;&gt;&gt; I personally think there is a bit too much overlap between ‘where’ syntax, and possibly conflicting usage. In your example, would Index: Foo indicate that index is exactly Foo, is Foo or some subtype, or is a concrete implementation of Foo? If there were two syntaxes, I’d hope one to be a much closer shortening of the other.<br>&gt;&gt; <br>&gt;&gt; Index: Foo<br>&gt;&gt; Index is of type Foo or a Subtype.<br>&gt; <br>&gt; In that, the covariant case, Array&lt;Element:Number&gt; is _different_ than Array&lt;Number&gt; today.<br>&gt; <br>&gt; Today, Array&lt;Number&gt; and Array&lt;Int&gt; are different concrete types. One deals in terms of Numbers, and one in terms of Ints. They are structured in memory different, etc.<br>&gt; <br>&gt; When I say partial constraints, applied to generics in this case (reluctantly), I’m saying the following:<br>&gt; <br>&gt; Implicitly define a protocol around all concrete Array instances where Element is defined to be Number or a subtype of Number, exposing all methods, properties, etc which are safe.<br>&gt; <br>&gt; Safety rules are equivalency rules here: If a method or property returns Element, I can say that it is safe to represent the result of “var first:Element {get}” as a Number, because in the cases where it returns a subtype like Int, I can still safely upcast to Number. I have a safe and uniform interface.<br>&gt; <br>&gt; If a method takes an argument or for any property setter, I have to require Element to be invariant. Modifying the first item of an array isn’t safe, because I might try to assign an Int value when really its a UInt8 array.<br></p><p>Why Element has to be invariant?<br></p><p>let uintArray: [UInt8] = [1]<br>var covariantArray: [Number] = uintArray<br>// this doesn&#39;t cause an error since Int is also a Number<br>covariantArray[0] = Int(36754)<br></p><p>&gt; <br>&gt; Subscripts unfortunately require both get and set, so even the getter has to be hidden currently if the type isn’t invariant. I’m not sure why the language requires this, TBH<br>&gt; <br>&gt; That we are constraining the exposure of a protocol to only expose what is available by the associated type rules we specified is why I stayed away from terse, generic type syntax to start the proposal. Eventually, consensus might be that generic type form is better, but it adds an additional complexity to the understanding of the type model, which is the important part now in discussion. You are now using an existing syntax to refer to a new thing with new properties.<br>&gt; <br>&gt; This is even more confusing if you partially constrain a generic type, because now Array&lt;Number&gt; (aka Array&lt;where Element == Number&gt; and Array&lt;where Element:Number&gt; have different properties (one is a protocol while the other is a concrete type, functionality is hidden because it is unsafe, possible boxing onto the heap and dynamic dispatch, etc)<br></p><p>I don&#39;t think that this would be confusing since `where` indicates that the type is used in a more generic way.<br></p><p><br>You&#39;ve convinced me. I wanted to keep the generic syntax simple but having thought over it your proposal it much better in handling more complex cases without introducing additional syntax.<br>Also considering Swifts type inference where types with long names are easier to use.<br></p><p><br>A &quot;small&quot; overview of several examples:<br></p><p>Using the former example of CollectionType which is used as a more concrete type (using a &quot;leading dot&quot; which is the same as `Self.`).<br></p><p>// These examples are only a demonstration of how you could use collection type<br></p><p>CollectionType&lt;where .Generator.Element == String, .Index == Int, .SubSequence: Self&gt;<br></p><p>CollectionType&lt;where .Generator.Element == String, .Index == Int&gt;<br></p><p>CollectionType&lt;where .Generator.Element == String&gt;<br></p><p>// if having `Element` as associated type<br>CollectionType&lt;where .Element == String&gt;<br></p><p><br>// covariance and invariance<br></p><p>protocol A {}<br>extension Int: A {}<br></p><p>let intArray: [Int] = [1, 2, 3]<br>let aArray: [A] = [1, 2, 3]<br></p><p>var col1: CollectionType&lt;where .Element == A&gt;<br>col1 = intArray // doesn&#39;t work since Int != A<br>col1 = aArray // obviously works<br></p><p>var col2: CollectionType&lt;where .Element: A&gt;<br>// both work since `Int` and `A` conform to `A` (currently in Swift 2.2 `A` does not conform to `A`, I don&#39;t know if this is a feature)<br>col2 = intArray<br>col2 = aArray<br></p><p><br>// with a concrete type using the example above:<br></p><p>// replace type of `col1` with (all replacements are equivalent)<br>`Array&lt;A&gt;` or `Array&lt;where .Element == A&gt;` or `[A]` or `[where .Element == A]`<br></p><p>// replace type of `col2` with (all replacements are equivalent)<br>`Array&lt;where .Element: A&gt;` or `[where .Element: A]`<br></p><p><br>// to be discussed: using many protocols together with protocol&lt;&gt;<br></p><p>// declaring a generic type T which is used in two protocols<br>protocol&lt;where T, Self: SequenceType&lt;where .Element == T&gt;, Self: Indexable&lt;where .Index == T&gt;&gt;<br></p><p>// although in this case it can be written as<br>SequenceType&lt;where T, .Element == T, Self: Indexable&lt;where .Index == T&gt;&gt;<br></p><p>Even though the latter one is shorter I&#39;m skeptical about using `Self:` in protocol where clauses since at a first glance it implies that the type is only a `SequenceType`.<br></p><p>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I do have a mild personal conflict around whether exposing the ability to have partially constrained generics is a good idea, but I admit my hesitation is based on philosophies of good application and API design, and not based on language design.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  implicit protocols on types seem pragmatic, because otherwise I’d have to create a protocol just for others to use me. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Allowing a protocol with associated types to be partially constrained seems pragmatic to me, since otherwise I have to use one of the workarounds above (hand-coded new protocol, generic constraints ever, and/or type-erasure struct-wrapper).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Expanding the usage of the implicit protocol on some generic type seems anti-pragmatic, just because it allows someone to go longer before they really evaluate whether locking consumers of their API into a single implementation is a good idea. They can always declare a protocol explicitly if they want partially constrained behavior.<br>&gt;&gt; <br>&gt;&gt; That was also my concern since I want to keep the generic syntax consistent with protocols. So maybe we could make it the same in case of generic parameter names but without the &quot;_&quot; so there are no protocol like behaviors for generic types.<br>&gt;&gt; <br>&gt;&gt; Even though it would be nice to have a covariant Array&lt; _ &gt; type.<br>&gt; <br>&gt; Yep :-) I can’t speak for the core team, but from my perspective whether this proposal lives or dies depends on:<br>&gt; <br>&gt; 1. Implementability<br>&gt; 2. Abiding by the Principal of Least Surprise<br>&gt; <br>&gt; -DW<br></p><p>Do you mean my proposal by &quot;this proposal&quot;?<br></p><p>Assuming you meant the proposal in general:<br></p><p>I think it can be implemented since the types are like generics in functions with where clauses. This proposal is almost only syntactic sugar.<br></p><p>I also think that it would not be surprising to offer this functionality because &quot;where clauses&quot; are quite well understood and I wouldn&#39;t count adding a new syntax as surprising.<br></p><p>- Maximilian<br></p><p>PS: Have you made a formal proposal already?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/b7592577/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 2:52 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Am 22.01.2016 um 21:41 schrieb David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt;:<br>&gt;&gt; Since today equatable mandates a defined, public == method, and I think the generic is always loses to that specificity. You don’t even need dynamic casting, because your generic version only gets called when there isn’t a non-generic version.<br>&gt;&gt; <br>&gt;&gt; // in this case there could be a more general == function<br>&gt;&gt; func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>&gt;&gt;     return false<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; 1 == 1 // true<br>&gt;&gt; 1 == “1” // false<br>&gt;&gt; <br>&gt; <br>&gt; I thought also of this example:<br>&gt; <br>&gt; let a: Equatable = 1<br>&gt; let b: Equatable = 2<br>&gt; <br>&gt; a == b // would fail in your case<br></p><p>I was speaking of today - today you can’t express &quot;let a:Equatable = 1”.<br></p><p>&gt;&gt; <br>&gt;&gt; In that, the covariant case, Array&lt;Element:Number&gt; is _different_ than Array&lt;Number&gt; today.<br>&gt;&gt; <br>&gt;&gt; Today, Array&lt;Number&gt; and Array&lt;Int&gt; are different concrete types. One deals in terms of Numbers, and one in terms of Ints. They are structured in memory different, etc.<br>&gt;&gt; <br>&gt;&gt; When I say partial constraints, applied to generics in this case (reluctantly), I’m saying the following:<br>&gt;&gt; <br>&gt;&gt; Implicitly define a protocol around all concrete Array instances where Element is defined to be Number or a subtype of Number, exposing all methods, properties, etc which are safe.<br>&gt;&gt; <br>&gt;&gt; Safety rules are equivalency rules here: If a method or property returns Element, I can say that it is safe to represent the result of “var first:Element {get}” as a Number, because in the cases where it returns a subtype like Int, I can still safely upcast to Number. I have a safe and uniform interface.<br>&gt;&gt; <br>&gt;&gt; If a method takes an argument or for any property setter, I have to require Element to be invariant. Modifying the first item of an array isn’t safe, because I might try to assign an Int value when really its a UInt8 array.<br>&gt; <br>&gt; Why Element has to be invariant?<br>&gt; <br>&gt; let uintArray: [UInt8] = [1]<br>&gt; var covariantArray: [Number] = uintArray<br>&gt; // this doesn&#39;t cause an error since Int is also a Number<br>&gt; covariantArray[0] = Int(36754)<br></p><p>A generic instance is still a concrete type, so for instance:<br>- Array&lt;.Element == Int&gt; is a concrete type, will store Int value types internally (e.g. sizeof(Int) == 8), and the API will allow you to subscript get and set Int values,etc<br>- Array&lt;.Element == Any&gt; is a concrete type, will store Any protocol references internally (e.g. sizeof(Any) == 32), and the API will allow you to subscript get and set Any values,etc<br>- a new Array&lt;.Element:Any&gt; is a protocol type, refers to/boxes any concrete Array without regards to its internal member (e.g. element size varies), and the API might allow you to subscript get Any because it can upcast all type instances to Any, but will hide the ability to set Any. The type system can’t be sure the concrete type you are supplying is appropriate for the actual Element type of the concrete Array (without changes in that feature as well, subscript must get and set, so the subscript get would also be hidden)<br></p><p>Per your proposed syntax, your set above would need to fail at compile-time or will fail at runtime, because covariantArray is a protocol boxing a copy of the [UInt8]-based uInt8Array, without additional behavior.<br></p><p>You could define a process where a Array&lt;.Element == Number&gt; is created by the compiler in that situation off of the uintArray value and assigned into covariantArray before the assignment happens, but thats a very expensive action to take implicitly, would require a dynamic check on each access. Plus, that would fail for generic types which were classes instead of value type (because you would only be updating a single reference to point to the new object)<br></p><p>&lt;snip, to respond later&gt;<br>&gt; <br>&gt; PS: Have you made a formal proposal already?<br></p><p>Not yet, I was hoping to get more feedback on the value of the idea before writing up all of the rules, which will take many hours of my time (to fail fast). There has been very little discussion so far.<br></p><p>My hope is to have a discussion on where the generics and constrained protocol systems should go for Swift 3 and beyond, but I suspect the core team is occupied by Swift 2.2 and the API guidelines discussion ATM. Type system changes are IMHO something that really warrant having a roadmap extending several releases into the future, and there are a number of ones being proposed by both the core team and evolution members (evolutioneers?) in general.<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/66e87f27/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 26, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 25.01.2016 um 23:58 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 2:52 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 22.01.2016 um 21:41 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt;&gt;&gt; Since today equatable mandates a defined, public == method, and I think the generic is always loses to that specificity. You don’t even need dynamic casting, because your generic version only gets called when there isn’t a non-generic version.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // in this case there could be a more general == function<br>&gt;&gt;&gt; func == &lt;T: Equatable, U: Equatable&gt;(x: T, y: U) -&gt; Bool {<br>&gt;&gt;&gt;     return false<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1 == 1 // true<br>&gt;&gt;&gt; 1 == “1” // false<br>&gt;&gt; <br>&gt;&gt; I thought also of this example:<br>&gt;&gt; <br>&gt;&gt; let a: Equatable = 1<br>&gt;&gt; let b: Equatable = 2<br>&gt;&gt; <br>&gt;&gt; a == b // would fail in your case<br>&gt; <br>&gt; I was speaking of today - today you can’t express &quot;let a:Equatable = 1”.<br></p><p>Oh, ok I haven&#39;t seen the &quot;today&quot;.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In that, the covariant case, Array&lt;Element:Number&gt; is _different_ than Array&lt;Number&gt; today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Today, Array&lt;Number&gt; and Array&lt;Int&gt; are different concrete types. One deals in terms of Numbers, and one in terms of Ints. They are structured in memory different, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When I say partial constraints, applied to generics in this case (reluctantly), I’m saying the following:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implicitly define a protocol around all concrete Array instances where Element is defined to be Number or a subtype of Number, exposing all methods, properties, etc which are safe.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Safety rules are equivalency rules here: If a method or property returns Element, I can say that it is safe to represent the result of “var first:Element {get}” as a Number, because in the cases where it returns a subtype like Int, I can still safely upcast to Number. I have a safe and uniform interface.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If a method takes an argument or for any property setter, I have to require Element to be invariant. Modifying the first item of an array isn’t safe, because I might try to assign an Int value when really its a UInt8 array.<br>&gt;&gt; <br>&gt;&gt; Why Element has to be invariant?<br>&gt;&gt; <br>&gt;&gt; let uintArray: [UInt8] = [1]<br>&gt;&gt; var covariantArray: [Number] = uintArray<br>&gt;&gt; // this doesn&#39;t cause an error since Int is also a Number<br>&gt;&gt; covariantArray[0] = Int(36754)<br>&gt; <br>&gt; A generic instance is still a concrete type, so for instance:<br>&gt; - Array&lt;.Element == Int&gt; is a concrete type, will store Int value types internally (e.g. sizeof(Int) == 8), and the API will allow you to subscript get and set Int values,etc<br>&gt; - Array&lt;.Element == Any&gt; is a concrete type, will store Any protocol references internally (e.g. sizeof(Any) == 32), and the API will allow you to subscript get and set Any values,etc<br>&gt; - a new Array&lt;.Element:Any&gt; is a protocol type, refers to/boxes any concrete Array without regards to its internal member (e.g. element size varies), and the API might allow you to subscript get Any because it can upcast all type instances to Any, but will hide the ability to set Any. The type system can’t be sure the concrete type you are supplying is appropriate for the actual Element type of the concrete Array (without changes in that feature as well, subscript must get and set, so the subscript get would also be hidden)<br>&gt; <br>&gt; Per your proposed syntax, your set above would need to fail at compile-time or will fail at runtime, because covariantArray is a protocol boxing a copy of the [UInt8]-based uInt8Array, without additional behavior.<br>&gt; <br>&gt; You could define a process where a Array&lt;.Element == Number&gt; is created by the compiler in that situation off of the uintArray value and assigned into covariantArray before the assignment happens, but thats a very expensive action to take implicitly, would require a dynamic check on each access. Plus, that would fail for generic types which were classes instead of value type (because you would only be updating a single reference to point to the new object)<br></p><p>To have an implicit array of type Array&lt;Number&gt; that&#39;s what I&#39;ve thought.<br></p><p>I see your point but since covariance and contra-variance is a big topic there is a thread which discusses this in more detail:<br></p><p>Make generics covariant - was: [swift-evolution] Make generics covariant and add generics to protocols<br></p><p>&gt; <br>&gt; &lt;snip, to respond later&gt;<br>&gt;&gt; <br>&gt;&gt; PS: Have you made a formal proposal already?<br>&gt; <br>&gt; Not yet, I was hoping to get more feedback on the value of the idea before writing up all of the rules, which will take many hours of my time (to fail fast). There has been very little discussion so far.<br>&gt; <br>&gt; My hope is to have a discussion on where the generics and constrained protocol systems should go for Swift 3 and beyond, but I suspect the core team is occupied by Swift 2.2 and the API guidelines discussion ATM. Type system changes are IMHO something that really warrant having a roadmap extending several releases into the future, and there are a number of ones being proposed by both the core team and evolution members (evolutioneers?) in general.<br>&gt; <br>&gt; -DW<br></p><p>We&#39;ll see. At least a better generics system is one of the main goals for Swift 3.<br></p><p>- Maximilian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/3295ac94/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 9:19 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Am 25.01.2016 um 23:58 schrieb David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt;:<br>&lt;snip&gt;<br>&gt; <br>&gt; To have an implicit array of type Array&lt;Number&gt; that&#39;s what I&#39;ve thought.<br>&gt; <br>&gt; I see your point but since covariance and contra-variance is a big topic there is a thread which discusses this in more detail:<br>&gt; <br>&gt; Make generics covariant - was: [swift-evolution] Make generics covariant and add generics to protocols<br></p><p>From what I’ve gathered the proposal for generic covariance is different. (I’m not super-keen on even exposing the functionality for generics still, but thats a side-point) :-)<br></p><p>let a:[UInt8] = [1,2,3]<br>let b:Array&lt;where .Element : Number&gt;  = a<br></p><p>b[0]= Int(1234)<br></p><p>In the proposal for generic covariance proposes a dynamic interface which would fail at runtime if unacceptable, as above. Most of the negative comments are that this does not allow one to write code which reasons about whether a method call will work or fail - array out of bounds can be avoided by manual array bounds checking, for instance. These sorts of undetectable runtime errors are what ErrorType is for, but you can’t retrofit throws behavior in based on the use of covariance either.<br></p><p>In my proposal, the compiler would not allow such a statement to proceed - the subscript functionality would be hidden because it is unsafe. This is actually similar to how Java handles wildcard-based call-site variance.<br></p><p>Then, by opening the existential type of element you can dynamically reason about whether the call should succeed or fail. e.g. something like:<br></p><p>let a:[UInt8] = [1,2,3]<br>let b:Array&lt;where .Element : Number&gt;  = a<br></p><p><br>typealias A = b.dynamicType<br>let c = b as! A<br></p><p>typealias E = b.Element<br>let val = Int(1234) as? E {<br>  c[0] = val<br>}<br>else { /* code to handle incompatible use */ }<br></p><p>Since I used Java as an example, I’ll go into more detail on how this proposal is different:<br></p><p>Java is a bit painful to have call-site variance in Java for four main reasons:<br>1. The error reporting is absolutely terrible<br>2. The generics system is not reified (it’s advisory), with a single implementation. The swift equivalent would be if the underlying only had a single kind of Array which held Any, and generics just added restrictions by the compiler onto the interface.<br>3. The generics system is incomplete. It is not possible to have arrays of generic types, for instance (a Java [ArrayList&lt;Int&gt;])<br>4. A type can be cast to any other generic constraint or even without generics with only warnings, which are maskable from being output by the compiler.<br></p><p>Because of these, I’ve seen several large projects (I won’t name names, but two of them are under Apache) where the generics definitions were unsound, yet nobody noticed because the developers just cast off the generics system completely when they ran into an edge case. <br></p><p>For further example, one common anti-pattern I’ve seen for example is the state anti pattern - I have an implementation of an interface/protocol which lets me define a specific state object type as well as operations that will return a typed state object back as a result, and expect that same state object on future requests.<br></p><p>When working at the level of that interface, it is not possible for me to reason about the type of state object needed on requests, so all the requests defined that take in that typed state object will be hidden. Instead, people will cast to the non-generic version of the interface, which will accept any of the state objects, and pass this in. If you do this by calling a method which specifies the non-generic interface version, you don’t even need to write an explicit cast operator - but the compiler will still of course have to cast, and will still fail at runtime if it can’t.<br></p><p>The only way to dynamically determine whether or not the state is appropriate is to do RTTI (runtime type inspection) to look at the return value of the method and see if your State object’s runtime type is compatible. I’ve never seen anyone attempt this, because often they are so used to Java’s generics model being incomplete that they assume any generics errors are because of Java, not their declared type system.<br></p><p>-DW<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &lt;snip, to respond later&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; PS: Have you made a formal proposal already?<br>&gt;&gt; <br>&gt;&gt; Not yet, I was hoping to get more feedback on the value of the idea before writing up all of the rules, which will take many hours of my time (to fail fast). There has been very little discussion so far.<br>&gt;&gt; <br>&gt;&gt; My hope is to have a discussion on where the generics and constrained protocol systems should go for Swift 3 and beyond, but I suspect the core team is occupied by Swift 2.2 and the API guidelines discussion ATM. Type system changes are IMHO something that really warrant having a roadmap extending several releases into the future, and there are a number of ones being proposed by both the core team and evolution members (evolutioneers?) in general.<br>&gt;&gt; <br>&gt;&gt; -DW<br>&gt; <br>&gt; We&#39;ll see. At least a better generics system is one of the main goals for Swift 3.<br>&gt; <br>&gt; - Maximilian<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/ab9aed98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 29, 2016 at 11:00:00pm</p></header><div class="content"><p>Even though generic classes cannot be safely upcasted to another generic type, value types might work like the proposal suggests (through casting).<br></p><p>Example:<br></p><p>protocol Pet {}<br>struct Dog: Pet {}<br></p><p>struct Person&lt;T&gt; {<br>    var pet: T<br>    mutating func setPet(pet: T) { self.pet = pet }<br>}<br></p><p>let p1 = Person(pet: Dog())<br>let covariantPerson: Person&lt;where T: Pet&gt; = p1<br></p><p><br>Since &quot;p1&quot; gets copied to &quot;covariantPerson&quot; it &quot;T&quot;/&quot;Dog&quot; could be internally casted to &quot;Pet&quot; without side effects. So even mutating functions can be called.<br></p><p>Like you proposed, in case of classes all methods/subscripts which mutate generic properties are inaccessible. There could be a mutating keyword for classes.<br></p><p>Although this complicates the language so it is probably better not to support generic covariance at all.<br></p><p>- Maximilian<br></p><p>&gt; Am 26.01.2016 um 19:16 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 26, 2016, at 9:19 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Am 25.01.2016 um 23:58 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt;&gt; &lt;snip&gt;<br>&gt;&gt; <br>&gt;&gt; To have an implicit array of type Array&lt;Number&gt; that&#39;s what I&#39;ve thought.<br>&gt;&gt; <br>&gt;&gt; I see your point but since covariance and contra-variance is a big topic there is a thread which discusses this in more detail:<br>&gt;&gt; <br>&gt;&gt; Make generics covariant - was: [swift-evolution] Make generics covariant and add generics to protocols<br>&gt; <br>&gt; From what I’ve gathered the proposal for generic covariance is different. (I’m not super-keen on even exposing the functionality for generics still, but thats a side-point) :-)<br>&gt; <br>&gt; let a:[UInt8] = [1,2,3]<br>&gt; let b:Array&lt;where .Element : Number&gt;  = a<br>&gt; <br>&gt; b[0]= Int(1234)<br>&gt; <br>&gt; In the proposal for generic covariance proposes a dynamic interface which would fail at runtime if unacceptable, as above. Most of the negative comments are that this does not allow one to write code which reasons about whether a method call will work or fail - array out of bounds can be avoided by manual array bounds checking, for instance. These sorts of undetectable runtime errors are what ErrorType is for, but you can’t retrofit throws behavior in based on the use of covariance either.<br>&gt; <br>&gt; In my proposal, the compiler would not allow such a statement to proceed - the subscript functionality would be hidden because it is unsafe. This is actually similar to how Java handles wildcard-based call-site variance.<br>&gt; <br>&gt; Then, by opening the existential type of element you can dynamically reason about whether the call should succeed or fail. e.g. something like:<br>&gt; <br>&gt; let a:[UInt8] = [1,2,3]<br>&gt; let b:Array&lt;where .Element : Number&gt;  = a<br>&gt; <br>&gt; <br>&gt; typealias A = b.dynamicType<br>&gt; let c = b as! A<br>&gt; <br>&gt; typealias E = b.Element<br>&gt; let val = Int(1234) as? E {<br>&gt;   c[0] = val<br>&gt; }<br>&gt; else { /* code to handle incompatible use */ }<br>&gt; <br>&gt; Since I used Java as an example, I’ll go into more detail on how this proposal is different:<br>&gt; <br>&gt; Java is a bit painful to have call-site variance in Java for four main reasons:<br>&gt; 1. The error reporting is absolutely terrible<br>&gt; 2. The generics system is not reified (it’s advisory), with a single implementation. The swift equivalent would be if the underlying only had a single kind of Array which held Any, and generics just added restrictions by the compiler onto the interface.<br>&gt; 3. The generics system is incomplete. It is not possible to have arrays of generic types, for instance (a Java [ArrayList&lt;Int&gt;])<br>&gt; 4. A type can be cast to any other generic constraint or even without generics with only warnings, which are maskable from being output by the compiler.<br>&gt; <br>&gt; Because of these, I’ve seen several large projects (I won’t name names, but two of them are under Apache) where the generics definitions were unsound, yet nobody noticed because the developers just cast off the generics system completely when they ran into an edge case. <br>&gt; <br>&gt; For further example, one common anti-pattern I’ve seen for example is the state anti pattern - I have an implementation of an interface/protocol which lets me define a specific state object type as well as operations that will return a typed state object back as a result, and expect that same state object on future requests.<br>&gt; <br>&gt; When working at the level of that interface, it is not possible for me to reason about the type of state object needed on requests, so all the requests defined that take in that typed state object will be hidden. Instead, people will cast to the non-generic version of the interface, which will accept any of the state objects, and pass this in. If you do this by calling a method which specifies the non-generic interface version, you don’t even need to write an explicit cast operator - but the compiler will still of course have to cast, and will still fail at runtime if it can’t.<br>&gt; <br>&gt; The only way to dynamically determine whether or not the state is appropriate is to do RTTI (runtime type inspection) to look at the return value of the method and see if your State object’s runtime type is compatible. I’ve never seen anyone attempt this, because often they are so used to Java’s generics model being incomplete that they assume any generics errors are because of Java, not their declared type system.<br>&gt; <br>&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &lt;snip, to respond later&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; PS: Have you made a formal proposal already?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not yet, I was hoping to get more feedback on the value of the idea before writing up all of the rules, which will take many hours of my time (to fail fast). There has been very little discussion so far.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My hope is to have a discussion on where the generics and constrained protocol systems should go for Swift 3 and beyond, but I suspect the core team is occupied by Swift 2.2 and the API guidelines discussion ATM. Type system changes are IMHO something that really warrant having a roadmap extending several releases into the future, and there are a number of ones being proposed by both the core team and evolution members (evolutioneers?) in general.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt; We&#39;ll see. At least a better generics system is one of the main goals for Swift 3.<br>&gt;&gt; <br>&gt;&gt; - Maximilian<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/0a2627fe/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 25, 2016, at 2:52 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; I don&#39;t think that this would be confusing since `where` indicates that the type is used in a more generic way.<br>&gt; <br>&gt; <br>&gt; You&#39;ve convinced me. I wanted to keep the generic syntax simple but having thought over it your proposal it much better in handling more complex cases without introducing additional syntax.<br>&gt; Also considering Swifts type inference where types with long names are easier to use.<br>&gt; <br>&gt; <br>&gt; A &quot;small&quot; overview of several examples:<br>&gt; <br>&gt; Using the former example of CollectionType which is used as a more concrete type (using a &quot;leading dot&quot; which is the same as `Self.`).<br>&gt; <br>&gt; // These examples are only a demonstration of how you could use collection type<br>&gt; <br>&gt; CollectionType&lt;where .Generator.Element == String, .Index == Int, .SubSequence: Self&gt;<br>&gt; <br>&gt; CollectionType&lt;where .Generator.Element == String, .Index == Int&gt;<br>&gt; <br>&gt; CollectionType&lt;where .Generator.Element == String&gt;<br>&gt; <br>&gt; // if having `Element` as associated type<br>&gt; CollectionType&lt;where .Element == String&gt;<br></p><p>One possible/fun option for syntax would be *if* Generics changed to have the types labelled. In that case, “where” becomes a keyword to distinguish a partial vs full constraint. <br></p><p>For instance, Optional&lt;T == BooleanType&gt; would describe a concrete Optional holding some implementation of BooleanType, while Optional&lt;where T:BooleanType&gt; would be a generated protocol to umbrella every Optional that matches (e.g. Optional&lt;T == Bool&gt;, Optional&lt;T == ObjCBool&gt;, …)<br></p><p>Then the syntax could be identical, e.g. RawRepresentable&lt;RawValue == Int&gt; vs RawRepresentable&lt;where RawValue:SignedNumberType&gt;<br></p><p>For protocols with self requirements you would likely force “where” syntax. I can say Equatable&lt;Self == Int&gt;, but the protocol can *only* be implemented by one type in the system, Int. I can’t think of a reason to support this.<br></p><p>&gt; // covariance and invariance<br>&gt; <br>&gt; protocol A {}<br>&gt; extension Int: A {}<br>&gt; <br>&gt; let intArray: [Int] = [1, 2, 3]<br>&gt; let aArray: [A] = [1, 2, 3]<br></p><p>probably still:<br>  let aArray: Array&lt;where .Element: Int&gt; = [1,2,3] <br></p><p>if you really want covariance. The limitations (detailed in the other email reply) are such that it is better to have clear syntax so people recognize there may be ramifications.<br></p><p>I could however see a way of doing<br>  let aCovariantArray: Array&lt;where .Element: Int&gt; = [1,2,3] <br>  let aArray = aCovaraintArray as [A]<br></p><p>being allowed, just as &quot;intArray as [A]&quot; works today due to internal behavior.<br></p><p>I detailed the ramifications of “is a concrete array of some specific implementation of A” behavior in the other half of my response - you are basically blocking a good deal of mutation behavior due to type safety. The restrictions are such that <br></p><p>&gt; var col1: CollectionType&lt;where .Element == A&gt;<br>&gt; col1 = intArray // doesn&#39;t work since Int != A<br>&gt; col1 = aArray // obviously works<br></p><p>The last line actually will fail as well if aArray is covariant on Element being A.<br></p><p>CollectionType “col1” is being constrained by Elements which *are* A, while aArray is a Collection type which is constrained by Elements being A *or* any subtype. if “intArray” doesn’t work directly and isn’t safe to work directly, why would discarding some of its type information by assigning to aArray make a difference? <br></p><p>&gt; var col2: CollectionType&lt;where .Element: A&gt;<br>&gt; // both work since `Int` and `A` conform to `A` (currently in Swift 2.2 `A` does not conform to `A`, I don&#39;t know if this is a feature)<br>&gt; col2 = intArray<br>&gt; col2 = aArray<br></p><p>Yep!<br></p><p>&gt; // with a concrete type using the example above:<br>&gt; <br>&gt; // replace type of `col1` with (all replacements are equivalent)<br>&gt; `Array&lt;A&gt;` or `Array&lt;where .Element == A&gt;` or `[A]` or `[where .Element == A]`<br>&gt; <br>&gt; // replace type of `col2` with (all replacements are equivalent)<br>&gt; `Array&lt;where .Element: A&gt;` or `[where .Element: A]`<br></p><p>I think yes, although col1 = aArray will still fail :D<br></p><p>&gt; // to be discussed: using many protocols together with protocol&lt;&gt;<br>&gt; <br>&gt; // declaring a generic type T which is used in two protocols<br>&gt; protocol&lt;where T, Self: SequenceType&lt;where .Element == T&gt;, Self: Indexable&lt;where .Index == T&gt;&gt;<br>&gt; <br>&gt; // although in this case it can be written as<br>&gt; SequenceType&lt;where T, .Element == T, Self: Indexable&lt;where .Index == T&gt;&gt;<br>&gt; <br>&gt; Even though the latter one is shorter I&#39;m skeptical about using `Self:` in protocol where clauses since at a first glance it implies that the type is only a `SequenceType`.<br></p><p>protocol&lt;&gt; is there for describing multiple protocols, so I’d go for the 1st.<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160125/626708ee/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 26, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Am 26.01.2016 um 00:27 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 25, 2016, at 2:52 PM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t think that this would be confusing since `where` indicates that the type is used in a more generic way.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; You&#39;ve convinced me. I wanted to keep the generic syntax simple but having thought over it your proposal it much better in handling more complex cases without introducing additional syntax.<br>&gt;&gt; Also considering Swifts type inference where types with long names are easier to use.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; A &quot;small&quot; overview of several examples:<br>&gt;&gt; <br>&gt;&gt; Using the former example of CollectionType which is used as a more concrete type (using a &quot;leading dot&quot; which is the same as `Self.`).<br>&gt;&gt; <br>&gt;&gt; // These examples are only a demonstration of how you could use collection type<br>&gt;&gt; <br>&gt;&gt; CollectionType&lt;where .Generator.Element == String, .Index == Int, .SubSequence: Self&gt;<br>&gt;&gt; <br>&gt;&gt; CollectionType&lt;where .Generator.Element == String, .Index == Int&gt;<br>&gt;&gt; <br>&gt;&gt; CollectionType&lt;where .Generator.Element == String&gt;<br>&gt;&gt; <br>&gt;&gt; // if having `Element` as associated type<br>&gt;&gt; CollectionType&lt;where .Element == String&gt;<br>&gt; <br>&gt; One possible/fun option for syntax would be *if* Generics changed to have the types labelled. In that case, “where” becomes a keyword to distinguish a partial vs full constraint. <br>&gt; <br>&gt; For instance, Optional&lt;T == BooleanType&gt; would describe a concrete Optional holding some implementation of BooleanType, while Optional&lt;where T:BooleanType&gt; would be a generated protocol to umbrella every Optional that matches (e.g. Optional&lt;T == Bool&gt;, Optional&lt;T == ObjCBool&gt;, …)<br>&gt; <br>&gt; Then the syntax could be identical, e.g. RawRepresentable&lt;RawValue == Int&gt; vs RawRepresentable&lt;where RawValue:SignedNumberType&gt;<br></p><p>That&#39;s a great idea. I wonder if the leading dot should be omitted since there is no &quot;where&quot; clause. In ambiguous situations you could then add &quot;Self.&quot; or only the leading dot.<br>There could also be an exhaustiveness check if there is no &quot;where&quot;, while forcing to write &quot;where&quot; if the protocol is partially applied.<br></p><p>&gt; For protocols with self requirements you would likely force “where” syntax. I can say Equatable&lt;Self == Int&gt;, but the protocol can *only* be implemented by one type in the system, Int. I can’t think of a reason to support this.<br></p><p>Direct self constraints (Self == ...   and   Self: .....) should probably only used in &quot;protocol&lt;&gt;&quot;.<br></p><p>&gt; <br>&gt;&gt; // covariance and invariance<br>&gt;&gt; <br>&gt;&gt; protocol A {}<br>&gt;&gt; extension Int: A {}<br>&gt;&gt; <br>&gt;&gt; let intArray: [Int] = [1, 2, 3]<br>&gt;&gt; let aArray: [A] = [1, 2, 3]<br>&gt; <br>&gt; probably still:<br>&gt;   let aArray: Array&lt;where .Element: Int&gt; = [1,2,3] <br>&gt; <br>&gt; if you really want covariance. The limitations (detailed in the other email reply) are such that it is better to have clear syntax so people recognize there may be ramifications.<br></p><p>I don&#39;t want implicit/inferred covariant types.<br>In this case invariant array:<br></p><p>let aArray: Array&lt;where .Element == A&gt; = [1,2,3] <br>// which is equivalent to<br>let aArray: [A] = [1,2,3] <br></p><p>&gt; <br>&gt; I could however see a way of doing<br>&gt;   let aCovariantArray: Array&lt;where .Element: Int&gt; = [1,2,3] <br>&gt;   let aArray = aCovaraintArray as [A]<br>&gt; <br>&gt; being allowed, just as &quot;intArray as [A]&quot; works today due to internal behavior.<br>&gt; <br>&gt; I detailed the ramifications of “is a concrete array of some specific implementation of A” behavior in the other half of my response - you are basically blocking a good deal of mutation behavior due to type safety. The restrictions are such that <br>&gt; <br>&gt;&gt; var col1: CollectionType&lt;where .Element == A&gt;<br>&gt;&gt; col1 = intArray // doesn&#39;t work since Int != A<br>&gt;&gt; col1 = aArray // obviously works<br>&gt; <br>&gt; The last line actually will fail as well if aArray is covariant on Element being A.<br></p><p>&quot;aArray&quot; is not covariant to &quot;intArray&quot; although each element is covariant to any type which conforms to &quot;A&quot;.<br></p><p>&gt; CollectionType “col1” is being constrained by Elements which *are* A, while aArray is a Collection type which is constrained by Elements being A *or* any subtype. if “intArray” doesn’t work directly and isn’t safe to work directly, why would discarding some of its type information by assigning to aArray make a difference? <br></p><p>I was inspired from the current generic system of functions:<br></p><p>func takeCollection&lt;C: CollectionType where C.Generator.Element == A&gt;(c: C) {}<br></p><p>takeCollection(intArray) // fails<br>takeCollection(aArray)  // works<br></p><p><br>Or how would you interpret &quot;CollectionType&lt;where .Element == A&gt;&quot; in contrast to &quot;CollectionType&lt;where .Element: A&gt;&quot;?<br></p><p>&gt; <br>&gt;&gt; var col2: CollectionType&lt;where .Element: A&gt;<br>&gt;&gt; // both work since `Int` and `A` conform to `A` (currently in Swift 2.2 `A` does not conform to `A`, I don&#39;t know if this is a feature)<br>&gt;&gt; col2 = intArray<br>&gt;&gt; col2 = aArray<br>&gt; <br>&gt; Yep!<br>&gt; <br>&gt;&gt; // with a concrete type using the example above:<br>&gt;&gt; <br>&gt;&gt; // replace type of `col1` with (all replacements are equivalent)<br>&gt;&gt; `Array&lt;A&gt;` or `Array&lt;where .Element == A&gt;` or `[A]` or `[where .Element == A]`<br>&gt;&gt; <br>&gt;&gt; // replace type of `col2` with (all replacements are equivalent)<br>&gt;&gt; `Array&lt;where .Element: A&gt;` or `[where .Element: A]`<br>&gt; <br>&gt; I think yes, although col1 = aArray will still fail :D<br></p><p>Why should this fail? Both have the exact same type &quot;[A]&quot;.<br></p><p>&gt; <br>&gt;&gt; // to be discussed: using many protocols together with protocol&lt;&gt;<br>&gt;&gt; <br>&gt;&gt; // declaring a generic type T which is used in two protocols<br>&gt;&gt; protocol&lt;where T, Self: SequenceType&lt;where .Element == T&gt;, Self: Indexable&lt;where .Index == T&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; // although in this case it can be written as<br>&gt;&gt; SequenceType&lt;where T, .Element == T, Self: Indexable&lt;where .Index == T&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; Even though the latter one is shorter I&#39;m skeptical about using `Self:` in protocol where clauses since at a first glance it implies that the type is only a `SequenceType`.<br>&gt; <br>&gt; protocol&lt;&gt; is there for describing multiple protocols, so I’d go for the 1st.<br></p><p>+1 For using the first<br></p><p>Suggestion:<br>separate declaration of T to make it consistent with current generic syntax<br></p><p>protocol&lt;T where Self: SequenceType&lt;where .Element == T&gt;, Self: Indexable&lt;where .Index == T&gt;&gt;<br></p><p>This example could also be rewritten to:<br>protocol&lt;where Self: SequenceType, Self: Indexable, Self.Element == Self.Index&gt;<br></p><p><br>Another suggestion:<br>For completely unconstrained protocols with associated types &quot;&lt;&gt;&quot; could be added at the end of the type to indicate that they have associated types in comparison to protocols which don&#39;t have them.<br>=&gt;<br>protocol&lt;where Self: SequenceType&lt;&gt;, Self: Indexable&lt;&gt;, Self.Element == Self.Index&gt;<br></p><p><br>- Maximilian<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/b0cbd164/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 26, 2016, at 10:32 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt; <br>&gt; Am 26.01.2016 um 00:27 schrieb David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; // covariance and invariance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol A {}<br>&gt;&gt;&gt; extension Int: A {}<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let intArray: [Int] = [1, 2, 3]<br>&gt;&gt;&gt; let aArray: [A] = [1, 2, 3]<br>&gt;&gt; <br>&gt;&gt; probably still:<br>&gt;&gt;   let aArray: Array&lt;where .Element: Int&gt; = [1,2,3] <br>&gt;&gt; <br>&gt;&gt; if you really want covariance. The limitations (detailed in the other email reply) are such that it is better to have clear syntax so people recognize there may be ramifications.<br>&gt; <br>&gt; I don&#39;t want implicit/inferred covariant types.<br>&gt; In this case invariant array:<br>&gt; <br>&gt; let aArray: Array&lt;where .Element == A&gt; = [1,2,3] <br>&gt; // which is equivalent to<br>&gt; let aArray: [A] = [1,2,3] <br></p><p>Ahh ok, you are asking for an invariant array of A’s, then. Method calls and properties may have covariant properties (such as assignment allowing any subclass of A), but the representation of Array internally is always of a list of A protocol instances.<br></p><p>A covariant _constraint_ is instead saying that you are referencing one of many different possible concrete Array types - some array based around internally having a list of A, or an array based around some particular subtype of A. <br></p><p>This will generally be restricted further for safety reasons. For example, a subscript assignment would first cast up to A, then have to cast down to some particular subtype of A. That downcast is unsafe and may fail based on the concrete kind of array behind the protocol.<br></p><p>&gt;&gt;&gt; var col1: CollectionType&lt;where .Element == A&gt;<br>&gt;&gt;&gt; col1 = intArray // doesn&#39;t work since Int != A<br>&gt;&gt;&gt; col1 = aArray // obviously works<br>&gt;&gt; <br>&gt;&gt; The last line actually will fail as well if aArray is covariant on Element being A.<br>&gt;&gt; <br>&gt; <br>&gt; &quot;aArray&quot; is not covariant to &quot;intArray&quot; although each element is covariant to any type which conforms to &quot;A”.<br></p><p>I think we may be working through the communication issue. But basically:<br></p><p>let aArray: Array&lt;where .Element: A&gt; = [1,2,3] <br></p><p>is specifying a type formed by a covariant constraint on Element. This means this could be a concrete array of A’s, or one of Ints, or one of some other implementation of A.<br></p><p>So lets name them explicitly:<br></p><p>var col1: CollectionType&lt;where .Element == A&gt;<br>let xArray:[Int] = [1,2,3]<br>let yArray:[A] = [1,2,3] // an Array of ‘A&#39;s<br></p><p>col1 = xArray // fails<br>col1 = yArray // succeeds<br></p><p>let zxArray:Array&lt;where .Element:A&gt; = xArray // similar to defining a protocol implicitly for arrays of A or of A-subtypes, of which [Int] conforms<br>let zyArray:Array&lt;where .Element:A&gt; = yArray // same for [A]<br></p><p>col1 = zxArray // fails<br>col1 = zyArray // still fails<br></p><p>Even though dynamically the zyArray type is compatible, the compiler is reasoning statically that zxArray and zyArray both could be non-working types, and therefore must be blocked for safety reasons.<br></p><p>&gt;&gt; CollectionType “col1” is being constrained by Elements which *are* A, while aArray is a Collection type which is constrained by Elements being A *or* any subtype. if “intArray” doesn’t work directly and isn’t safe to work directly, why would discarding some of its type information by assigning to aArray make a difference? <br>&gt; <br>&gt; I was inspired from the current generic system of functions:<br>&gt; <br>&gt; func takeCollection&lt;C: CollectionType where C.Generator.Element == A&gt;(c: C) {}<br>&gt; <br>&gt; takeCollection(intArray) // fails<br>&gt; takeCollection(aArray)  // works<br>&gt; <br>&gt; <br>&gt; Or how would you interpret &quot;CollectionType&lt;where .Element == A&gt;&quot; in contrast to &quot;CollectionType&lt;where .Element: A&gt;”?<br></p><p>I think we had a confusion issue about whether A was an invariant or covariant constraint in the post I was responding to. I’m assuming now that you actually did mean it to be invariant.<br></p><p>&gt;&gt; protocol&lt;&gt; is there for describing multiple protocols, so I’d go for the 1st.<br>&gt; <br>&gt; +1 For using the first<br>&gt; <br>&gt; Suggestion:<br>&gt; separate declaration of T to make it consistent with current generic syntax<br>&gt; <br>&gt; protocol&lt;T where Self: SequenceType&lt;where .Element == T&gt;, Self: Indexable&lt;where .Index == T&gt;&gt;<br>&gt; <br>&gt; This example could also be rewritten to:<br>&gt; protocol&lt;where Self: SequenceType, Self: Indexable, Self.Element == Self.Index&gt;<br>&gt; <br></p><p>How about <br></p><p>protocol&lt;SequenceType, Indexable where .Element == .Index&gt;<br></p><p>-DW<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160126/b67dc53d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4d13105de53a43ce1df97869ca6c140e?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>Maximilian Hünenberger</string> &lt;m.huenenberger at me.com&gt;<p>January 29, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; Am 26.01.2016 um 19:48 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jan 26, 2016, at 10:32 AM, Maximilian Hünenberger &lt;m.huenenberger at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 26.01.2016 um 00:27 schrieb David Waite &lt;david at alkaline-solutions.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // covariance and invariance<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol A {}<br>&gt;&gt;&gt;&gt; extension Int: A {}<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let intArray: [Int] = [1, 2, 3]<br>&gt;&gt;&gt;&gt; let aArray: [A] = [1, 2, 3]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; probably still:<br>&gt;&gt;&gt;   let aArray: Array&lt;where .Element: Int&gt; = [1,2,3] <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; if you really want covariance. The limitations (detailed in the other email reply) are such that it is better to have clear syntax so people recognize there may be ramifications.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t want implicit/inferred covariant types.<br>&gt;&gt; In this case invariant array:<br>&gt;&gt; <br>&gt;&gt; let aArray: Array&lt;where .Element == A&gt; = [1,2,3] <br>&gt;&gt; // which is equivalent to<br>&gt;&gt; let aArray: [A] = [1,2,3] <br>&gt; <br>&gt; Ahh ok, you are asking for an invariant array of A’s, then. Method calls and properties may have covariant properties (such as assignment allowing any subclass of A), but the representation of Array internally is always of a list of A protocol instances.<br>&gt; <br>&gt; A covariant _constraint_ is instead saying that you are referencing one of many different possible concrete Array types - some array based around internally having a list of A, or an array based around some particular subtype of A. <br>&gt; <br>&gt; This will generally be restricted further for safety reasons. For example, a subscript assignment would first cast up to A, then have to cast down to some particular subtype of A. That downcast is unsafe and may fail based on the concrete kind of array behind the protocol.<br>&gt; <br>&gt;&gt;&gt;&gt; var col1: CollectionType&lt;where .Element == A&gt;<br>&gt;&gt;&gt;&gt; col1 = intArray // doesn&#39;t work since Int != A<br>&gt;&gt;&gt;&gt; col1 = aArray // obviously works<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The last line actually will fail as well if aArray is covariant on Element being A.<br>&gt;&gt; <br>&gt;&gt; &quot;aArray&quot; is not covariant to &quot;intArray&quot; although each element is covariant to any type which conforms to &quot;A”.<br>&gt; <br>&gt; I think we may be working through the communication issue. But basically:<br>&gt; <br>&gt; let aArray: Array&lt;where .Element: A&gt; = [1,2,3] <br>&gt; <br>&gt; is specifying a type formed by a covariant constraint on Element. This means this could be a concrete array of A’s, or one of Ints, or one of some other implementation of A.<br>&gt; <br>&gt; So lets name them explicitly:<br>&gt; <br>&gt; var col1: CollectionType&lt;where .Element == A&gt;<br>&gt; let xArray:[Int] = [1,2,3]<br>&gt; let yArray:[A] = [1,2,3] // an Array of ‘A&#39;s<br>&gt; <br>&gt; col1 = xArray // fails<br>&gt; col1 = yArray // succeeds<br>&gt; <br>&gt; let zxArray:Array&lt;where .Element:A&gt; = xArray // similar to defining a protocol implicitly for arrays of A or of A-subtypes, of which [Int] conforms<br>&gt; let zyArray:Array&lt;where .Element:A&gt; = yArray // same for [A]<br>&gt; <br>&gt; col1 = zxArray // fails<br>&gt; col1 = zyArray // still fails<br>&gt; <br>&gt; Even though dynamically the zyArray type is compatible, the compiler is reasoning statically that zxArray and zyArray both could be non-working types, and therefore must be blocked for safety reasons.<br></p><p>That&#39;s exactly what I was thinking.<br></p><p>&gt; <br>&gt;&gt;&gt; CollectionType “col1” is being constrained by Elements which *are* A, while aArray is a Collection type which is constrained by Elements being A *or* any subtype. if “intArray” doesn’t work directly and isn’t safe to work directly, why would discarding some of its type information by assigning to aArray make a difference? <br>&gt;&gt; <br>&gt;&gt; I was inspired from the current generic system of functions:<br>&gt;&gt; <br>&gt;&gt; func takeCollection&lt;C: CollectionType where C.Generator.Element == A&gt;(c: C) {}<br>&gt;&gt; <br>&gt;&gt; takeCollection(intArray) // fails<br>&gt;&gt; takeCollection(aArray)  // works<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Or how would you interpret &quot;CollectionType&lt;where .Element == A&gt;&quot; in contrast to &quot;CollectionType&lt;where .Element: A&gt;”?<br>&gt; <br>&gt; I think we had a confusion issue about whether A was an invariant or covariant constraint in the post I was responding to. I’m assuming now that you actually did mean it to be invariant.<br></p><p>Yes &quot;==&quot; is an invariant constraint. Even though &quot;A&quot; as single type would be covariant to &quot;Int&quot;.<br></p><p>&gt; <br>&gt;&gt;&gt; protocol&lt;&gt; is there for describing multiple protocols, so I’d go for the 1st.<br>&gt;&gt; <br>&gt;&gt; +1 For using the first<br>&gt;&gt; <br>&gt;&gt; Suggestion:<br>&gt;&gt; separate declaration of T to make it consistent with current generic syntax<br>&gt;&gt; <br>&gt;&gt; protocol&lt;T where Self: SequenceType&lt;where .Element == T&gt;, Self: Indexable&lt;where .Index == T&gt;&gt;<br>&gt;&gt; <br>&gt;&gt; This example could also be rewritten to:<br>&gt;&gt; protocol&lt;where Self: SequenceType, Self: Indexable, Self.Element == Self.Index&gt;<br>&gt; <br>&gt; How about <br>&gt; <br>&gt; protocol&lt;SequenceType, Indexable where .Element == .Index&gt;<br></p><p>Oh my example was probably &quot;too simple&quot;. I thought of declaring an additional generic parameter but thinking about it, it would probably not be usable.<br></p><p>- Maximilian<br>&gt; <br>&gt; -DW<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/0606f6b3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>Partially Constrained Protocols [Was: [Proposal] Separate protocols and interfaces]</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>January 19, 2016 at 12:00:00pm</p></header><div class="content"><p>I did think of an additional type constraint needed now due to the additional flexibility in the proposed type system.<br></p><p>Today, The != operator might be defined as follows<br></p><p>func !=&lt;T:Equatable&gt;(lhs:T, rhs:T) -&gt; Bool {<br>    return !(lhs==rhs)<br>}<br></p><p>Since the only way today for there to be a reference to something equatable is for you to have a concrete implementing type, this will get the appropriate view of Equatable (e.g. can see the ==(_:Self,_:Self)-&gt;Bool method)<br></p><p>However, since the type system has expanded to now allow references to partially constrained protocols, the above is insufficient to provide access to the == operator. Example:<br></p><p>let x:Hashable = &quot;Foo&quot;<br>let y:Hashable = &quot;Bar&quot;<br></p><p>x != y // Not defined, since there is no ==(_:Hashable, _:Hashable)-&gt;Bool<br></p><p>We need a way to differentiate when we are trying to statically require a concrete type. One could reuse one of the existing keywords or an operator, but for now I’ll expand my placeholder syntax with a placeholder keyword, “concrete”<br></p><p>func !=&lt;concrete T:Equatable&gt;(lhs:T, rhs:T) -&gt; Bool {<br></p><p>or from the SequenceType version I posted yesterday:<br></p><p>&gt; extension SequenceType where concrete Element:Equatable {<br>&gt;     func elementsEqual&lt;OtherSequence : protocol&lt;SequenceType where .Element == Element&gt;(other: OtherSequence) -&gt; Bool<br>&gt;     func split(separator: Element, maxSplit: Int, allowEmptySlices: Bool) -&gt; [protocol&lt;SequenceType where .Element == Element&gt;]<br>&gt;     func startsWith(other: protocol&lt;SequenceType where .Element == Element) -&gt; Bool<br>&gt; }<br></p><p>(Another option for a new syntax would be to require explicit syntax for using Equatable as a existential type - i’m deferring that until there is more successful discussion on the ideas themselves.)<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160119/0aadf493/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
