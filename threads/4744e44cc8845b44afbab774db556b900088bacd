<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>April 30, 2016 at 07:00:00pm</p></header><div class="content"><p>on Thu Apr 28 2016, Brent Royal-Gordon &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;     Awesome. Some specific suggestions below, but feel free to iterate in a pull<br>&gt;     request if you prefer that.<br>&gt;<br>&gt; I&#39;ve adopted these suggestions in some form, though I also ended up rewriting<br>&gt; the explanation of why the feature was designed as it is and fusing it with<br>&gt; material from &quot;Alternatives considered&quot;.<br>&gt;<br>&gt; (Still not sure who I should list as a co-author. I&#39;m currently thinking John,<br>&gt; Tyler, and maybe Chris? Who&#39;s supposed to go there?)<br></p><p>A couple of remarks:<br></p><p>First, this passage is wrong about the reliability of the triple-quote syntax:<br></p><p>&gt;   (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax<br>&gt;   highlighters into working some of the time with some contents, we don&#39;t think<br>&gt;   this occasional, accidental compatibility is a big enough gain to justify<br>&gt;   changing the design.<br></p><p>I&#39;ve never seen a syntax highlighter have problems with it, I don&#39;t see<br>how it *could* ever cause a problem, and lastly I think it&#39;s both naïve<br>and presumptuous to call these effects accidental.<br></p><p>Second, this proposal should explain why it&#39;s reinventing the wheel<br>instead of standardizing existing, very successful, prior art.  Answer<br>the question: “what compelling advantages does this syntax have over<br>Python&#39;s?”<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>multi-line string literals.</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 30, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; Second, this proposal should explain why it&#39;s reinventing the wheel<br>&gt; instead of standardizing existing, very successful, prior art.  Answer<br>&gt; the question: “what compelling advantages does this syntax have over<br>&gt; Python&#39;s?”<br></p><p>Sure.<br></p><p>First of all, I will admit up front that I have not written much Python (a couple weeks ago, &quot;much&quot; would have been &quot;any&quot;) and I may not fully understand their string literals. So I&#39;ll start by describing my understanding of the design in question; then I&#39;ll critique the design as I understand it. So if something in this section is wrong, please forgive any related mistakes in the critique.<br></p><p>Python offers a `&quot;&quot;&quot;` string which is almost the same as the `&quot;` string:<br></p><p>	* Every character between the first `&quot;&quot;&quot;` and the second `&quot;&quot;&quot;` is part of its contents.<br>	* Escapes are processed normally.<br>	* There is no special behavior with regards to whitespace.<br></p><p>The only difference is that a `&quot;&quot;&quot;` string allows real, unescaped newlines in it, while a `&quot;` string forbids them. (And, of course, since the delimiter is `&quot;&quot;&quot;`, the strings `&quot;` and `&quot;&quot;` are interpreted literally.)<br></p><p>This approach is really simple, which is a plus, but it has a number of issues.<br></p><p><br></p><p>CONTENT FORMATTING<br></p><p>A number of aspects of the design combine to make `&quot;&quot;&quot;` strings harder to read than they should be:<br></p><p>	* You can&#39;t indent the contents of a `&quot;&quot;&quot;` string to match the code it&#39;s in. This is actually pretty shocking considering how sensitive Python is to indentation, and it necessitates a number of strange hacks (for instance, Python&#39;s `help()` function unindents all but the first line of doc strings).<br>	* You can&#39;t put all of the contents against the left margin, either, because a newline right after the `&quot;&quot;&quot;` is counted as part of the string&#39;s contents. (You can use a backslash to work around this.)<br>	* The last line of the string also has to have the delimiter in it, because again, a newline right before the `&quot;&quot;&quot;`is counted as part of the string&#39;s contents. (You can use a backslash to work around this, but the backslash is *not* in the mirror position of the start of the string, so good luck remembering it.)<br></p><p>In other words, the first and last lines have to be adulterated by adding a `&quot;&quot;&quot;`, and the middle lines can&#39;t be indented to line up with either the surrounding code or the beginning of the first line. If one of the selling points of this feature is that you just stick your contents in verbatim without alteration, that isn&#39;t great.<br></p><p>This is such a problem that, in researching `&quot;&quot;&quot;` to be sure I understood how it works, I came across a Stack Overflow question whose answers are full of people recommending a different, more highly punctuated, feature instead: &lt;http://stackoverflow.com/questions/1520548/how-does-pythons-triple-quote-string-work&gt;<br></p><p>(There is an alternate design which would fix the beginning and end problems: make a newline after the opening delimiter and before the closing delimiter mandatory and part of the delimiter. You might then choose to fix the indentation problem by taking the whitespace between the closing delimiter and the newline before it as the amount of indentation for the entire string, and removing that much indentation from each line. But that&#39;s not what Python does, and it&#39;s not what you seem to be proposing.)<br></p><p><br></p><p>BREAKING UP EXPRESSIONS<br></p><p>String literals are expressions, and in fact, they are expressions with no side effects. To do anything useful, they *must* be put into a larger expression. Often this expression is an assignment, but it could be anything—concatenation, method call, function parameter, you name it.<br></p><p>This creates a challenge for multiline strings, because they can become very large and effectively break up the expression they&#39;re in. The continuation-quote-based multiline strings I&#39;m proposing are aimed primarily at relatively short strings*, where this is less of a concern. But `&quot;&quot;&quot;` aims to be used not only for short strings, but for ones which may be many dozens or even hundreds of lines long. You&#39;re going to end up with code like:<br></p><p>	print(&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot;?&gt;<br>	&lt;catalog&gt;<br>		&lt;book id=&quot;bk101&quot; empty=&quot;&quot;&gt;<br>			...<br>			...<br>			...a hundred more lines of XML with interpolations in it...<br>			...<br>			...<br>		&lt;/book&gt;<br>	&lt;/catalog&gt;&quot;&quot;&quot;)<br></p><p>What does that `)` mean? Who knows? We saw the beginning of the expression an hour and a half ago. (It&#39;s common to avoid this issue by assigning the string to a constant even if it&#39;s only going to be used once, but that just changes the problem a little—now you&#39;re trying to remember the name of a local variable declared a hundred lines ago.)<br></p><p>Heredocs cleverly avoid this issue by not trying to put the literal&#39;s contents in the middle of the expression. Instead, they put a short placeholder in the expression, then start the contents on the next line. The expression is readable as an expression, while the contents of the literal are adjacent but separate. That&#39;s why I think they&#39;re a better solution than `&quot;&quot;&quot;` for truly massive string literals.<br></p><p>* This is something I am not saying in the proposal, but I really should.<br></p><p><br></p><p>NESTING<br></p><p>Another problem is that you don&#39;t get another choice besides `&quot;&quot;&quot;`. That&#39;s not so bad, though, right? It&#39;s such an uncommon sequence of characters, surely you&#39;ll never encounter it?<br></p><p>Well, sure...until you try to generate code.<br></p><p>For instance, suppose you&#39;re writing a web app using a barebones Swift framework and you have a lot of code like this:<br></p><p>	response.send(&quot;&quot;&quot;&lt;tr&gt;<br>		&lt;td&gt;\(name)&lt;/td&gt;<br>		&lt;td&gt;\(value)&lt;/td&gt;<br>	&lt;/tr&gt;<br>	&quot;&quot;&quot;)<br></p><p>Every 90s Perl hacker knows what a pain this is, and every 90s Perl hacker knows the solution: a template language. Hack together some kind of simple syntax for embedding commands in a file of content, and then convert it into runnable code with a tool that does things like:<br></p><p>	print(&quot;&quot;&quot;<br>	response.send(&quot;&quot;&quot;\(escapedContent)&quot;&quot;&quot;)<br>	&quot;&quot;&quot;)<br></p><p>...oh. Wait a minute there.<br></p><p>To get around this, you really need to support, not two delimiters, but *n* delimiters. Heredocs let you choose an arbitrary delimiter. C++ lets you augment the delimiter with arbitrary characters. Perl&#39;s `qq` construct lets you choose a single character, but it can be almost anything you want (and some of them nest). I&#39;m thinking about letting you extend the delimiter with an arbitrary number of underscores. All of these solutions have in common that they don&#39;t just have &quot;primary&quot; and &quot;alternate&quot; delimiters, but an effectively endless number of them.<br></p><p>`&quot;&quot;&quot;` does not have this feature—you just have the primary delimiter and the alternate delimiter, and if neither of them works for you, you have to escape. That isn&#39;t ideal.<br></p><p><br></p><p>RUNAWAY LITERALS<br></p><p>`&quot;&quot;&quot;` does not offer much help with preventing or diagnosing runaway literals or highlighting code with half-written literals. Heredocs don&#39;t either, but I envision heredocs being used less often than `&quot;&quot;&quot;` strings would be, since continuation quotes would handle shorter strings.<br></p><p><br></p><p>SYNTAX HIGHLIGHTING<br></p><p>So, let&#39;s talk about this:<br></p><p>&gt;&gt;  (like Python&#39;s &quot;&quot;&quot; strings) which trick some syntax<br>&gt;&gt;  highlighters into working some of the time with some contents, we don&#39;t think<br>&gt;&gt;  this occasional, accidental compatibility is a big enough gain to justify<br>&gt;&gt;  changing the design.<br>&gt; <br>&gt; I&#39;ve never seen a syntax highlighter have problems with it, I don&#39;t see<br>&gt; how it *could* ever cause a problem, and lastly I think it&#39;s both naïve<br>&gt; and presumptuous to call these effects accidental.<br></p><p>I call these effects &quot;accidental&quot; because the syntax highlighter was not designed to handle the `&quot;&quot;&quot;`; it just happens to handle it correctly because it misinterprets a `&quot;&quot;&quot;` string as an empty `&quot;` string, followed by a non-empty `&quot;` string, followed by another empty `&quot;` string. It&#39;s &quot;accidental&quot; from the perspective of the syntax highlighter designer, not the language designer, who probably intended that to happen.<br></p><p>And it only works in a specific subset of cases. It breaks if:<br></p><p>* The syntax highlighter tries to apply smarter per-language rules.<br>* The syntax highlighter assumes that strings are not allowed to be multi-line. (This is true of many languages, including C derivatives and Swift 2.)<br>* The string literal contains any `&quot;` characters, which `&quot;&quot;&quot;` is often used in order to permit.<br>* The string literal contains any escapes or special features that the syntax highlighter misinterprets, like an interpolation which itself contains a string literal.<br></p><p>Yes, it will often work, or at least sort-of work. But I just don&#39;t see that as very valuable.<br></p><p><br></p><p>WHAT&#39;S GOOD ABOUT `&quot;&quot;&quot;`?<br></p><p>In my opinion, the best thing about `&quot;&quot;&quot;` (the language feature) is `&quot;&quot;&quot;` (the token).<br></p><p>A sequence of three quote marks is a fantastic token for a feature meant to create long string literals. It clearly has something to do with string literals, but it cannot be an empty string, because there are too many quote marks—that is, it&#39;s too long. It&#39;s a really clever mnemonic which also parses unambiguously.<br></p><p>I&#39;ve spoken before in this thread and others about potentially using `&quot;&quot;&quot;` as an alternate delimiter (which could be extended to `&quot;&quot;&quot;&quot;&quot;` and beyond). I&#39;m also considering the idea that it might be a good token for a Perl-style heredoc syntax:<br></p><p>	print(&quot;&quot;&quot; + e&quot;&quot;&quot;)<br>	It was a dark and stormy \(timeOfDay) when <br>	&quot;&quot;&quot;<br>	the Swift core team invented the \(interpolation) syntax.<br>	&quot;&quot;&quot;<br></p><p>Nesting could be achieved with a version of whatever alternate delimiter syntax we use for `&quot;` strings. For instance, if we adopted the `_&quot;foo&quot;_` syntax I sketched:<br></p><p>	print(_&quot;&quot;&quot;_)<br>	response.send(&quot;&quot;&quot;)<br>	\(escapedContent)<br>	&quot;&quot;&quot;<br>	_&quot;&quot;&quot;_<br></p><p><br></p><p>(P.S. If this post seems way too long to have been written in a couple hours, that&#39;s because I&#39;ve been drafting a version of it on and off for a day or two; it just so happened that Dave directly asked me to confront `&quot;&quot;&quot;` today.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
