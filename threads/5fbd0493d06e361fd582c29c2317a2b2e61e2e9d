<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/886f7902c986a59d5cc184425d513c36?s=50"></div><header><strong>Passing an optional first argument to sequence(first:next:)</strong> from <string>Tim Vermeulen</string> &lt;tvermeulen at me.com&gt;<p>August 27, 2016 at 04:00:00am</p></header><div class="content"><p>This is when I first wanted to pass an optional for the `first` parameter:<br></p><p>extension Sequence {<br>    <br>    /// Returns a sequence of pairs of consecutive elements<br>    /// of the sequence, in order.<br>    var pairs: AnySequence&lt;(Iterator.Element, Iterator.Element)&gt; {<br>        var iterator = makeIterator()<br>        <br>        let firstPair = iterator.next().flatMap { first in<br>            iterator.next().map { second in (first, second) }<br>        }<br></p><p>        // I can&#39;t do this, because `firstPair` is optional<br>        let seq = sequence(first: firstPair) { _, second in<br>            guard let next = iterator.next() else { return nil }<br>            return (second, next)<br>        }<br>        <br>        return AnySequence(seq)<br>    }<br>    <br>}<br></p><p>In this particular case, finding a workaround is fairly easy (with a guard and `return AnySequence([])` in the `else` block). However, this becomes less elegant if you just want to iterate over it rather than wrap it in AnySequence.<br></p><p>&gt; Hi Tim,<br>&gt; <br>&gt; After having a quick conversation with Dave, here is the question I should have asked right away: can you share the typical problem you are solving with your overload of the `sequence(first:next:)` function?<br>&gt; <br>&gt; Max<br>&gt; <br>&gt; <br>&gt; &gt; On Aug 20, 2016, at 2:26 AM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; What you’re saying makes sense, and I might not have brought this up in the first place if `first.map { sequence(first: $0, next: next } ?? []` worked. The main annoyance is that the best solution (currently) seems to be to copy the source code and make a change.<br>&gt; &gt; <br>&gt; &gt; (cc-ing Jordan Rose because of a related swift-users thread) This might be a bit of a stretch, but can’t Swift upcast sequences to AnySequence implicitly, like is done with AnyHashable? That would make `first.map { sequence(first: $0, next: next } ?? []` instantly valid, I think. There’s also something to be said for consistency between type erasers. (I’m not necessarily talking about Swift 3)<br>&gt; &gt; &gt; On 20 Aug 2016, at 02:22, Max Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt; &gt; &gt; Hi Tim,<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; I still believe that having 2 termination conditions is wrong. But I guess we need a tie breaker here, someone with a strong opinion about the problem.<br>&gt; &gt; &gt; As Kevin mentioned we are very late in the release process, so waiting for another opinion for a day or two won’t change anything, really.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Meanwhile, I played a little bit with an idea of making `first.map { sequence(first $0, next: next} ?? []` work.<br>&gt; &gt; &gt; Turns out, if we add an `ExpressibleByArrayLiteral` protocol conformance to the `UnfoldSequence`, this snippet will compile just fine. One downside is that the `ExpressibleByArrayLiteral` protocol allows creating non-empty sequences as well, which does not make sense for the `UnfoldSequence`.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Max<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; On Aug 19, 2016, at 3:48 PM, Tim Vermeulen via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On 19 Aug 2016, at 19:48, Kevin Ballard&lt;kevin at sb.org(mailto:kevin at sb.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; AFAIK this issue has never been discussed with sequence(first:next:) before. It certainly wasn&#39;t brought up during review.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; As for my opinion, I&#39;m really not sure. I was going to point out that right now sequence(first:next:) guarantees that the first element of the resulting sequence is the value provided as &quot;first&quot;, but it occurs to me that if you treat the nil result from next() as an element, then this still holds true. So I guess my biggest worry is this change will make it harder to use sequence(first:next:) to produce sequences of optional values.<br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; I don’t think producing sequences of optional values would really be a problem, because type inference will figure this out based on whether you treat the argument to the `next` closure as an optional or not. And if you only do things in `next` that work both with optionals and non-optionals (very unlikely), you can always manually specify the type of the sequence.<br>&gt; &gt; &gt; &gt; &gt; So I guess I&#39;m ambivalent, and would prefer to defer to the wisdom of the Swift core team on this matter.<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; That said, didn&#39;t the deadline for source-breaking changes already come and go?<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; -Kevin Ballard<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; On Fri, Aug 19, 2016, at 10:37 AM, Max Moiseev wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; + Erica, Kevin, as the authors of the original proposal.<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Do you remember the problem of non-emptiness being discussed before? And if not, what’s your opinion on the proposed change?<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; Thanks,<br>&gt; &gt; &gt; &gt; &gt; &gt; Max<br>&gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; On Aug 19, 2016, at 7:53 AM, Tim Vermeulen&lt;tvermeulen at me.com(mailto:tvermeulen at me.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Max, thanks for having a look.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; A big part of why I’m not really happy with the current implementation is that the function always produces a nonempty sequence, though the compiler doesn’t know it. `sequence(first: first, next: next).last` returns an optional, even though it can’t possibly be nil. The same goes for something like `sequence(first: 5, next: { $0 * 3 }).first(where: { $0&gt;1000 })`, because the sequence is infinite, which means `first(while:)` will either keep running forever, or return a non-optional.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Ideally, we’d have three types of sequences, with three corresponding `sequence(first:next:)` functions:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T?, next: (T) -&gt;T?)—returns any sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T?)—returns a nonempty sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T,next: (T) -&gt;T)—returns an infinite sequence<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Default implementations for methods on sequences would either return optionals or non-optionals depending on their emptiness/finiteness. We just have the first kind of sequence right now, so in that regard it would make sense to also give `sequence(first:next)` the corresponding signature.Later, when the language / standard library supports the other two kinds of sequences (if that ever happens), the other versions could be added.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; Another reason that makes me think that the version that accepts an optional `first` argument is more natural, is the fact that the function body doesn’t need to be changed at all. It supports optional seeds by design; only the signature prevents it.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; I know these arguments might not be very convincing, but I feel like Swift misses an opportunity if it unnecessarily constrains the `first` parameter to be non-optional. The `.lazy.flatMap({ $0 })` alternative that you pointed out does work, but it makes everything very unreadable: not just the `.lazy.flatMap({ $0 })` part, but also the body of the `next` parameter because you’re now dealing with optionals (i.e. you have to `flatMap` over the closure argument). The best solution I’ve come up with is to copy the `sequence(first:next)` implementation from the source code and change the signature. :-/<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; `sequence(state:next:)` isn’t very appropriate for this task either, because naive usage with an optional seed has the downside of being unnecessarily eager just like a naive `sequence(first:next)` implementation (as described in a comment in the source code).<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On 19 Aug 2016, at 00:18, Max Moiseev&lt;moiseev at apple.com(mailto:moiseev at apple.com)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Hi Tim,<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Thanks for bringing this up.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Here are my thoughts on the change you’re proposing.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; func sequence&lt;T&gt;(first: T, next: (T) -&gt;T?) -&gt;UnfoldFirstSequence&lt;T&gt;<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; To me the type of the function as it is tells a clear story of what’s going to happen: take the `first`, make it a head of the resulting sequence, and then try to produce the tail by a series of applications of `next`. The only thing that controls when the sequence generation terminates is the result of `next`.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; If we change the type of `first` to an Optional&lt;T&gt;, it would make the termination condition non-trivial. After all, the only thing it would do is try to unwrap the `first`, before doing what it needs to, but we already have a `map` for that. One should be able to simply do the `first.map { sequence(first: $0, next: next) } ?? []` but that won’t work with the types very well, unfortunately.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; As an alternative, `let first: Int? = ...; sequence(first: first, next: next).flatMap({$0})` (or even `.lazy.flatMap({$0})`) will do the right thing without making an API more complex.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I see the point of `sequence(first:next:)` to be precisely the &quot;generate the non-empty sequence using a seed and a simple producer&quot;, for anything more than that, there is `sequence(state:next:)`.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; What do you think?<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; Max<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; On Aug 14, 2016, at 4:27 PM, Tim Vermeulen via swift-evolution&lt;swift-evolution at swift.org(mailto:swift-evolution at swift.org)&gt;wrote:<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; sequence(first:next:) takes a non-optional first argument. Is there a reason for that? sequence(state:next:) allows empty sequences, and I don’t see why sequence(first:next:) shouldn’t. The fix would be to simply add the `?` in the function signature; no other changes are required to make it work.<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; I considered just filing a bug report, but since this is a change of the public API...<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; <br>&gt; &gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; &gt; swift-evolution at swift.org(mailto:swift-evolution at swift.org)<br>&gt; &gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; <br>&gt; <br>&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160827/5fbd2e9d/attachment.html&gt;<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
