<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>December  9, 2015 at 04:00:00pm</p></header><div class="content"><p>In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br></p><p>Let me illustrate this with an example. The function<br></p><p>&gt; func foo(x : Int) -&gt; Int {<br>&gt;   return bar(x)<br>&gt; }<br></p><p>is compiled to SIL as <br></p><p>&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; // %0                                             // users: %1, %2, %4<br>&gt; bb0(%0 : $Int):<br>&gt;   debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;   return %4 : $Int                                // id: %5 line:2:3:return<br>&gt; }<br></p><p>Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>With the proposed syntax, this could like like:<br></p><p>&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt; bb0(%0 : $Int):<br>&gt;   debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;   return %4 : $Int<br>&gt; }<br></p><p>More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br></p><p>  sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>  sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>  sil-instruction ::= debug_value sil-operand dbg-var<br>  sil-instruction ::= debug_value_addr sil-operand dbg-var<br>  dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>  var-attr ::= ‘name:’ string-literal<br>  var-attr ::= ’type:’ string-literal<br>  var-attr ::= ‘argno:’ integer-literal<br></p><p>This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br></p><p>Syntax alternatives I’ve considered and rejected include:<br>1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>   Why: Hard to read, potentially ambiguous because some fields are optional.<br></p><p>2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>   Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br></p><p>3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>   Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br></p><p>-- adrian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt; <br>&gt; Let me illustrate this with an example. The function<br>&gt; <br>&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;  return bar(x)<br>&gt;&gt; }<br>&gt; <br>&gt; is compiled to SIL as <br>&gt; <br>&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;  debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;  return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt; }<br>&gt; <br>&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt; With the proposed syntax, this could like like:<br>&gt; <br>&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;  debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;  return %4 : $Int<br>&gt;&gt; }<br>&gt; <br>&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt; <br>&gt;  sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;  sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;  sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;  sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;  dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;  var-attr ::= ‘name:’ string-literal<br>&gt;  var-attr ::= ’type:’ string-literal<br>&gt;  var-attr ::= ‘argno:’ integer-literal<br>&gt; <br>&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt; <br>&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;   Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt; <br>&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;   Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt; <br>&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;   Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br></p><p>Thanks for working on this, Adrian! My thoughts:<br></p><p>- I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>- Since these are core parts of the instruction, I would say they need no decoration at all; they should just be part of the instruction syntax:<br></p><p>debug_value %0 : $Int, name &quot;x&quot;, type $Int, argno 1<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>December 10, 2015 at 08:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt; <br>&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt; <br>&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; is compiled to SIL as <br>&gt;&gt; <br>&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt; <br>&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt; <br>&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt; <br>&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt; <br>&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;  Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt; <br>&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;  Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt; <br>&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;  Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt; <br>&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt; <br>&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br></p><p>Good point. Is it safe to assume that all types representable in textual SIL? I’m slightly worried that a SIL pass might introduce a type (e.g., a generic function specialization) for which we don’t have any Swift syntax. Thinking about it though — even if there is no syntax, we would probably want to create one, so the type can be used in the debugger and REPL.<br></p><p>&gt; - Since these are core parts of the instruction, I would say they need no decoration at all; they should just be part of the instruction syntax:<br>&gt; <br>&gt; debug_value %0 : $Int, name &quot;x&quot;, type $Int, argno 1<br>&gt; <br></p><p>sil-instruction ::= &#39;alloc_stack&#39; sil-type (‘,&#39; debugvar-attr)*<br>sil-instruction ::= &#39;alloc_stack&#39; sil-type (‘,’ debugvar-attr)*<br>sil-instruction ::= debug_value sil-operand (‘,&#39; debugvar-attr)*<br>sil-instruction ::= debug_value_addr sil-operand (‘,&#39; debugvar-attr)*<br>debugvar-attr ::= ‘name’ string-literal<br>debugvar-attr ::= ’type’ type              // only needed where AST type ≠ SIL type<br>debugvar-attr ::= ‘argno’ integer-literal<br></p><p>Works for me. Thanks for the feedback,<br>Adrian<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 10, 2015 at 10:00:00am</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt; <br>&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt; <br>&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; is compiled to SIL as <br>&gt;&gt; <br>&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt; <br>&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt; <br>&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt; <br>&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt; <br>&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;  Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt; <br>&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;  Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt; <br>&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;  Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt; <br>&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt; <br>&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br></p><p>In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>December 15, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt; <br>&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt; <br>&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt; <br>&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br></p><p>By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br></p><p>Let’s say we have the function<br>  func id&lt;T&gt;(x : T) -&gt; T { return x }<br></p><p>which is translated to SIL as<br></p><p>&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt; <br>&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;   debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;   copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;   %4 = tuple ()                                   <br>&gt;   return %4 : $()                                 <br>&gt; }<br></p><p>When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>Another option is to explicitly call out the DeclContext by adding a sil-decl-ref attribute, like this:<br></p><p>&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1, declctx #id!1<br></p><p><br>But it looks like sil-decl-refs also aren’t expressive enough to distinguish between foo() / foo(x:Int) / foo&lt;T&gt;(x:T).<br></p><p>Am I missing something obvious?<br>-- adrian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt; <br>&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt; <br>&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt; <br>&gt; Let’s say we have the function<br>&gt;  func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt; <br>&gt; which is translated to SIL as<br>&gt; <br>&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt; <br>&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;  debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;  copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;  %4 = tuple ()                                   <br>&gt;&gt;  return %4 : $()                                 <br>&gt;&gt; }<br>&gt; <br>&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt; Another option is to explicitly call out the DeclContext by adding a sil-decl-ref attribute, like this:<br>&gt; <br>&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1, declctx #id!1<br>&gt; <br>&gt; <br>&gt; But it looks like sil-decl-refs also aren’t expressive enough to distinguish between foo() / foo(x:Int) / foo&lt;T&gt;(x:T).<br>&gt; <br>&gt; Am I missing something obvious?<br>&gt; <br></p><p>Don&#39;t SILFunctions already reference a context ValueDecl for debug purposes?<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151215/6f4ee280/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 2:27 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt;&gt; <br>&gt;&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt;&gt; <br>&gt;&gt; Let’s say we have the function<br>&gt;&gt;  func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt;&gt; <br>&gt;&gt; which is translated to SIL as<br>&gt;&gt; <br>&gt;&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;&gt;  debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;&gt;  copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;&gt;  %4 = tuple ()                                   <br>&gt;&gt;&gt;  return %4 : $()                                 <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt;&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt;&gt; Another option is to explicitly call out the DeclContext by adding a sil-decl-ref attribute, like this:<br>&gt;&gt; <br>&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1, declctx #id!1<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; But it looks like sil-decl-refs also aren’t expressive enough to distinguish between foo() / foo(x:Int) / foo&lt;T&gt;(x:T).<br>&gt;&gt; <br>&gt;&gt; Am I missing something obvious?<br>&gt;&gt; <br>&gt; <br>&gt; Don&#39;t SILFunctions already reference a context ValueDecl for debug purposes?<br></p><p>If you’re refering to SILFunction::getDeclContext() this field is only populated by the regular SILGen path. ParseSIL does not (yet) do this. I ran into the above problem while trying to set the DeclContext of SILFunctions that are created by ParseSIL.cpp.<br></p><p>-- adrian <br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 2:34 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 2:27 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say we have the function<br>&gt;&gt;&gt; func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is translated to SIL as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt;&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt;&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;&gt;&gt; copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;&gt;&gt; %4 = tuple ()                                   <br>&gt;&gt;&gt;&gt; return %4 : $()                                 <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt;&gt;&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt;&gt;&gt; Another option is to explicitly call out the DeclContext by adding a sil-decl-ref attribute, like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1, declctx #id!1<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But it looks like sil-decl-refs also aren’t expressive enough to distinguish between foo() / foo(x:Int) / foo&lt;T&gt;(x:T).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am I missing something obvious?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Don&#39;t SILFunctions already reference a context ValueDecl for debug purposes?<br>&gt; <br>&gt; If you’re refering to SILFunction::getDeclContext() this field is only populated by the regular SILGen path. ParseSIL does not (yet) do this. I ran into the above problem while trying to set the DeclContext of SILFunctions that are created by ParseSIL.cpp.<br></p><p>We could add some syntax to the sil function syntax to reference the debug DeclContext. I wouldn&#39;t try to demangle the name to guess what it&#39;s supposed to be.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151215/42b0b333/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>December 15, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 2:37 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 2:34 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 2:27 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s say we have the function<br>&gt;&gt;&gt;&gt; func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is translated to SIL as<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt;&gt;&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;&gt;&gt;&gt; copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;&gt;&gt;&gt; %4 = tuple ()                                   <br>&gt;&gt;&gt;&gt;&gt; return %4 : $()                                 <br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt;&gt;&gt;&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt;&gt;&gt;&gt; Another option is to explicitly call out the DeclContext by adding a sil-decl-ref attribute, like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1, declctx #id!1<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But it looks like sil-decl-refs also aren’t expressive enough to distinguish between foo() / foo(x:Int) / foo&lt;T&gt;(x:T).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am I missing something obvious?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Don&#39;t SILFunctions already reference a context ValueDecl for debug purposes?<br>&gt;&gt; <br>&gt;&gt; If you’re refering to SILFunction::getDeclContext() this field is only populated by the regular SILGen path. ParseSIL does not (yet) do this. I ran into the above problem while trying to set the DeclContext of SILFunctions that are created by ParseSIL.cpp.<br>&gt; <br>&gt; We could add some syntax to the sil function syntax to reference the debug DeclContext. I wouldn&#39;t try to demangle the name to guess what it&#39;s supposed to be.<br>&gt; <br></p><p>Here are a couple of horrible ideas how this could be done:<br></p><p><br>1. Extend sil-decl-ref to allow specifying a type:<br>   Grammar:<br>       sil-function ::= &#39;sil&#39; sil-linkage? sil-function-name &#39;:&#39; sil-type<br>                        ‘declcontext’ sil-decl-ref<br>                        &#39;{&#39; sil-basic-block+ &#39;}&#39;<br>   Example:<br></p><p>   // Decl<br>   func foo&lt;T&gt;(i : Int) -&gt; T<br></p><p>   // SIL function + DeclContextRef<br>   sil @_TF4test3foo... : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () declcontext test.foo$&lt;T&gt;(Int) -&gt; (T) {<br></p><p>2. Extend ValueDecls in .sil files with a unique id<br>   Example:<br></p><p>   // Decl + ID<br>   func foo() #1<br></p><p>   // SIL function + DeclContextRef<br>   sil @_TF4test3foo... : $... declcontext #1 {<br></p><p>3. Extend ValueDecls with a unique id that happens to be its mangled/silgen name<br>   Example:<br></p><p>   // Decl + ID<br>   @_silgen_name(&quot;@_TF4test3foo...”) func foo()<br>   // SIL function + DeclContextRef<br>   sil @_TF4test3foo... : $... declcontext @_TF4test3foo... {<br></p><p>I personally lean towards something along the lines of option 1. What do you think?<br></p><p>-- adrian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 15, 2015 at 05:00:00pm</p></header><div class="content"><p>Yeah, option 1 seems reasonable to me. I might give it attribute-like spelling, though, to help bracket it and keep it separate from the real name and declaration:<br></p><p>sil [debug_decl_context test.foo : &lt;T&gt; (T) -&gt; ()] @_Tfoo : $... {<br>}<br></p><p>-Joe<br></p><p>&gt; On Dec 15, 2015, at 4:30 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 15, 2015, at 2:37 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 2:34 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 15, 2015, at 2:27 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s say we have the function<br>&gt;&gt;&gt;&gt;&gt; func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which is translated to SIL as<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;&gt;&gt;&gt;&gt; copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;&gt;&gt;&gt;&gt; %4 = tuple ()                                   <br>&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $()                                 <br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt;&gt;&gt;&gt;&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt;&gt;&gt;&gt;&gt; Another option is to explicitly call out the DeclContext by adding a sil-decl-ref attribute, like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1, declctx #id!1<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But it looks like sil-decl-refs also aren’t expressive enough to distinguish between foo() / foo(x:Int) / foo&lt;T&gt;(x:T).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am I missing something obvious?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Don&#39;t SILFunctions already reference a context ValueDecl for debug purposes?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you’re refering to SILFunction::getDeclContext() this field is only populated by the regular SILGen path. ParseSIL does not (yet) do this. I ran into the above problem while trying to set the DeclContext of SILFunctions that are created by ParseSIL.cpp.<br>&gt;&gt; <br>&gt;&gt; We could add some syntax to the sil function syntax to reference the debug DeclContext. I wouldn&#39;t try to demangle the name to guess what it&#39;s supposed to be.<br>&gt;&gt; <br>&gt; <br>&gt; Here are a couple of horrible ideas how this could be done:<br>&gt; <br>&gt; <br>&gt; 1. Extend sil-decl-ref to allow specifying a type:<br>&gt;   Grammar:<br>&gt;       sil-function ::= &#39;sil&#39; sil-linkage? sil-function-name &#39;:&#39; sil-type<br>&gt;                        ‘declcontext’ sil-decl-ref<br>&gt;                        &#39;{&#39; sil-basic-block+ &#39;}&#39;<br>&gt;   Example:<br>&gt; <br>&gt;   // Decl<br>&gt;   func foo&lt;T&gt;(i : Int) -&gt; T<br>&gt; <br>&gt;   // SIL function + DeclContextRef<br>&gt;   sil @_TF4test3foo... : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () declcontext test.foo$&lt;T&gt;(Int) -&gt; (T) {<br>&gt; <br>&gt; 2. Extend ValueDecls in .sil files with a unique id<br>&gt;   Example:<br>&gt; <br>&gt;   // Decl + ID<br>&gt;   func foo() #1<br>&gt; <br>&gt;   // SIL function + DeclContextRef<br>&gt;   sil @_TF4test3foo... : $... declcontext #1 {<br>&gt; <br>&gt; 3. Extend ValueDecls with a unique id that happens to be its mangled/silgen name<br>&gt;   Example:<br>&gt; <br>&gt;   // Decl + ID<br>&gt;   @_silgen_name(&quot;@_TF4test3foo...”) func foo()<br>&gt;   // SIL function + DeclContextRef<br>&gt;   sil @_TF4test3foo... : $... declcontext @_TF4test3foo... {<br>&gt; <br>&gt; I personally lean towards something along the lines of option 1. What do you think?<br>&gt; <br>&gt; -- adrian<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20151215/6bb9f71e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 15, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt; <br>&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt; <br>&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt; <br>&gt; Let’s say we have the function<br>&gt;  func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt; <br>&gt; which is translated to SIL as<br>&gt; <br>&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt; <br>&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;  debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;  copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;  %4 = tuple ()                                   <br>&gt;&gt;  return %4 : $()                                 <br>&gt;&gt; }<br>&gt; <br>&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br></p><p>Well, right now the in-memory representation uses a single DeclContext for the entire SILFunction.  If that choice makes sense — and I’m willing to accept that it does — then it seems to me that the assembly representation should be consistent with that choice.  That is, you should find a way to write the DeclContext for the entire function in the parsed representation instead of writing it out for individual instructions.<br></p><p>Now, for the specific case of archetypes and mangling, the answer is probably that you don’t really need a DeclContext, you need a GenericParamList.<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09d425d65431edfdb8ce3bbb2f2e2bf0?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>Adrian Prantl</string> &lt;aprantl at apple.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 2:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt;&gt; <br>&gt;&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt;&gt; <br>&gt;&gt; Let’s say we have the function<br>&gt;&gt; func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt;&gt; <br>&gt;&gt; which is translated to SIL as<br>&gt;&gt; <br>&gt;&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;&gt; copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;&gt; %4 = tuple ()                                   <br>&gt;&gt;&gt; return %4 : $()                                 <br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt;&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt; <br>&gt; Well, right now the in-memory representation uses a single DeclContext for the entire SILFunction.  If that choice makes sense — and I’m willing to accept that it does — then it seems to me that the assembly representation should be consistent with that choice.  That is, you should find a way to write the DeclContext for the entire function in the parsed representation instead of writing it out for individual instructions.<br></p><p>The only complication is that a debug_value that was inlined from another function will need to refer to that function as its DeclContext. Once we have a syntax for locations and inline information (this is next up on my list) we could determine an inlined instruction’s context via the location (which will point to the original function) and don’t need to store it in the instruction.<br>So, yes, attaching the DeclContext to a function would be totally adequate :-)<br></p><p>&gt; <br>&gt; Now, for the specific case of archetypes and mangling, the answer is probably that you don’t really need a DeclContext, you need a GenericParamList.<br></p><p>That would be great, as the GenericParamList is already stored in the SILFunction. Alas, for debug info (only) the mangling for an archetype is <br></p><p>  qualified-archetype ::= &#39;Qq&#39; index context<br></p><p>and contains the DeclContext.<br></p><p><br>It looks like both for locations DeclContexts it would be useful if there was a way to uniquely refer to an earlier ValueDecl in the same SIL file. I’m unsure what the best solution for this would be syntax-wise.<br></p><p>thanks,<br>adrian<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>[RFC] SIL syntax for debug information Part 1: Variables</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>December 15, 2015 at 03:00:00pm</p></header><div class="content"><p>&gt; On Dec 15, 2015, at 3:01 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt; On Dec 15, 2015, at 2:35 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 15, 2015, at 1:25 PM, Adrian Prantl &lt;aprantl at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 10:19 AM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 8:31 AM, Joe Groff via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 9, 2015, at 4:15 PM, Adrian Prantl via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In order to write textual SIL -&gt; SIL testcases that exercise the handling of debug information by SIL passes, we need to make a couple of additions to the textual SIL language. In memory, the debug information attached to SIL instructions references information from the AST. If we want to create debug info from parsing a textual .sil file, these bits need to be made explicit.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let me illustrate this with an example. The function<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func foo(x : Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return bar(x)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; is compiled to SIL as <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // main.foo (Swift.Int) -&gt; Swift.Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // %0                                             // users: %1, %2, %4<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int  // let x, argno: 1       // id: %1 line:1:10:in_prologue<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int                                // id: %5 line:2:3:return<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note that there is a bunch of information available in comments that will be lost once we parse that textual SIL again. I’d like to add syntax to SIL for the information in the comments. This proposal deals with lifting the debug variable information (the first comment) into actual SIL syntax. A similar proposal for locations will be coming soon.<br>&gt;&gt;&gt;&gt;&gt;&gt; With the proposed syntax, this could like like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sil hidden @_TF4main3fooFSiSi : $@convention(thin) (Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; bb0(%0 : $Int):<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; debug_value %0 : $Int, !dbg_var(name: &quot;x&quot;, type: &quot;_TTSi&quot;, argno: 1)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; return %4 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More formally, debug variable info may be attached to debug_value, debug_value_addr, alloc_box, and alloc_stack instructions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= &#39;alloc_stack&#39; sil-type dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; sil-instruction ::= debug_value_addr sil-operand dbg-var<br>&gt;&gt;&gt;&gt;&gt;&gt; dbg-var ::= ‘!dbg_var’ ‘(‘ var-attr (&#39;,&#39; var-attr)*) ‘)&#39;<br>&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘name:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ’type:’ string-literal<br>&gt;&gt;&gt;&gt;&gt;&gt; var-attr ::= ‘argno:’ integer-literal<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This syntax for `dbg-var` is borrowed straight from LLVM IR and thus invokes a familiar feeling. Since the primary use-case of it will be in test cases, the verbose dictionary-like syntax is really helpful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Syntax alternatives I’ve considered and rejected include:<br>&gt;&gt;&gt;&gt;&gt;&gt; 1. debug_value %0 : $Int, “x”, “_TtSi”, 1<br>&gt;&gt;&gt;&gt;&gt;&gt; Why: Hard to read, potentially ambiguous because some fields are optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 2. debug_value [name “x”] [type “_TtSi”] [argno 1] %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt; Why: Attributes in square brackets don’t typically have arguments and come before the entity they are modifying.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 3. debug_value @var(name: “x”, type: “_TtSi”, argno: 1) %0 : $Int<br>&gt;&gt;&gt;&gt;&gt;&gt; Why: The ‘@‘ sigil is used not just for attributes but also for global symbols and thus creates an ambiguity.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks for working on this, Adrian! My thoughts:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - I don&#39;t see a reason to mangle the type name at SIL time. You should reference the formal AST type directly in the instruction, and print and parse it using the normal (Swift) type parser.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In addition to all the other good reasons to do this, this means that archetypes in the type will be (1) sensibly bound in the context and (2) actually substituted by inlining and generic specialization.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By deferring the type mangling to IRGen time I’m hitting an interesting problem:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s say we have the function<br>&gt;&gt;&gt; func id&lt;T&gt;(x : T) -&gt; T { return x }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is translated to SIL as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func id&lt;T&gt;(x: T) -&gt; T // FuncDecl<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // declcontext.id &lt;A&gt; (A) -&gt; A<br>&gt;&gt;&gt;&gt; sil hidden @_TF11declcontext2idurFxx : $@convention(thin) &lt;T&gt; (@out T, @in T) -&gt; () {<br>&gt;&gt;&gt;&gt; bb0(%0 : $*T, %1 : $*T):<br>&gt;&gt;&gt;&gt; debug_value_addr %1 : $*T, let, name &quot;x&quot;, argno 1<br>&gt;&gt;&gt;&gt; copy_addr [take] %1 to [initialization] %0 : $*T<br>&gt;&gt;&gt;&gt; %4 = tuple ()                                   <br>&gt;&gt;&gt;&gt; return %4 : $()                                 <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When emitting debug info for “x” we need to determine the mangled name of “T”. Since T is an archetype, the Mangler needs its DeclContext. In a compilation from source the DeclContext is readily available and the FuncDecl itself.<br>&gt;&gt;&gt; However, when parsing this from SIL it is unclear how to match up the SILFunction with the FuncDecl to establish the DeclContext for the Mangler. It would be possible to demangle the SILFunction’s name and then look up the FuncDecl by name in the SwiftModule and then filter the lookup results by type. But this filtering would not work after function signature optimizations.<br>&gt;&gt; <br>&gt;&gt; Well, right now the in-memory representation uses a single DeclContext for the entire SILFunction.  If that choice makes sense — and I’m willing to accept that it does — then it seems to me that the assembly representation should be consistent with that choice.  That is, you should find a way to write the DeclContext for the entire function in the parsed representation instead of writing it out for individual instructions.<br>&gt; <br>&gt; The only complication is that a debug_value that was inlined from another function will need to refer to that function as its DeclContext. Once we have a syntax for locations and inline information (this is next up on my list) we could determine an inlined instruction’s context via the location (which will point to the original function) and don’t need to store it in the instruction.<br>&gt; So, yes, attaching the DeclContext to a function would be totally adequate :-)<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Now, for the specific case of archetypes and mangling, the answer is probably that you don’t really need a DeclContext, you need a GenericParamList.<br>&gt; <br>&gt; That would be great, as the GenericParamList is already stored in the SILFunction. Alas, for debug info (only) the mangling for an archetype is <br>&gt; <br>&gt;  qualified-archetype ::= &#39;Qq&#39; index context<br>&gt; <br>&gt; and contains the DeclContext.<br></p><p>Well, as a reminder, you made this mangling up for debug-info’s purposes, so it’s up to you. :)<br></p><p>&gt; It looks like both for locations DeclContexts it would be useful if there was a way to uniquely refer to an earlier ValueDecl in the same SIL file. I’m unsure what the best solution for this would be syntax-wise.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
