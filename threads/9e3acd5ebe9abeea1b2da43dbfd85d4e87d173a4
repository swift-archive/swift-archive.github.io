<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Disambiguate Return Type With Void</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>March 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Swift can resolve functions based on the return type. However, when the<br>result is unused a single function often can&#39;t be resolved without<br>explicitly specifying the type.<br></p><p>func example() { ... }<br>func example() -&gt; Int { ... }<br></p><p>example() as Void<br>example() as Int<br></p><p>This proposal disambiguates some cases:<br></p><p>   - Preferring functions with a *Void* return type when the result *is*<br>   discarded.<br>   - Preferring functions with a *non-Void* type when the result *is not*<br>   discarded.<br></p><p>These example will be unambiguous:<br></p><p>example() // will prefer a `Void` function<br>let x = example() // will prefer a non-`Void` function<br></p><p>You can read the full latest version of the proposal here:<br></p><p>https://github.com/therealbnut/swift-evolution/blob/andrew-disambiguate-return-type/proposals/0000-disambiguate-return-type.md<br></p><p>This is the original version<br>&lt;https://github.com/therealbnut/swift-evolution/blob/59d0f0b9bdabcfd675f36824232a8efa4a5f9152/proposals/0000-disambiguate-return-type.md&gt;<br>of<br>the proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/9e3a73a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Disambiguate Return Type With Void</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Hey,<br></p><p>I thought I would post another message to this thread because I think it<br>was missed when I first sent it (I made the mistake of sending it at 1am<br>San Francisco time, I&#39;m in Australia).<br></p><p>I appreciate any feedback :)<br></p><p>Thanks,<br>Andrew<br></p><p>On Mon, Mar 28, 2016 at 7:21 PM, Andrew Bennett &lt;cacoyi at gmail.com&gt; wrote:<br></p><p>&gt; Swift can resolve functions based on the return type. However, when the<br>&gt; result is unused a single function often can&#39;t be resolved without<br>&gt; explicitly specifying the type.<br>&gt;<br>&gt; func example() { ... }<br>&gt; func example() -&gt; Int { ... }<br>&gt;<br>&gt; example() as Void<br>&gt; example() as Int<br>&gt;<br>&gt; This proposal disambiguates some cases:<br>&gt;<br>&gt;    - Preferring functions with a *Void* return type when the result *is*<br>&gt;    discarded.<br>&gt;    - Preferring functions with a *non-Void* type when the result *is not*<br>&gt;    discarded.<br>&gt;<br>&gt; These example will be unambiguous:<br>&gt;<br>&gt; example() // will prefer a `Void` function<br>&gt; let x = example() // will prefer a non-`Void` function<br>&gt;<br>&gt; You can read the full latest version of the proposal here:<br>&gt;<br>&gt;<br>&gt; https://github.com/therealbnut/swift-evolution/blob/andrew-disambiguate-return-type/proposals/0000-disambiguate-return-type.md<br>&gt;<br>&gt; This is the original version<br>&gt; &lt;https://github.com/therealbnut/swift-evolution/blob/59d0f0b9bdabcfd675f36824232a8efa4a5f9152/proposals/0000-disambiguate-return-type.md&gt; of<br>&gt; the proposal.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/893fdace/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Disambiguate Return Type With Void</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>Interesting suggestion, but IMO this will produce a question about new <br>naming conversion in Swift 3.0 (noun/verb, -ing/-ed, etc) because using <br>your suggestion we could want to use:<br></p><p>array.sort(..) // mutating<br>let array2 = array.sort(..) // non-mutating, instead of array.sorted()<br></p><p>Also, technically we can assign a value to Void function(yes, compiler <br>warning will be produced, but just warning, not error):<br></p><p>var something = array.sort(..) // mutating,currently this is valid code<br>// something  == ()<br></p><p><br>On 26.04.2016 13:56, Andrew Bennett via swift-evolution wrote:<br>&gt; Hey,<br>&gt;<br>&gt; I thought I would post another message to this thread because I think it<br>&gt; was missed when I first sent it (I made the mistake of sending it at 1am<br>&gt; San Francisco time, I&#39;m in Australia).<br>&gt;<br>&gt; I appreciate any feedback :)<br>&gt;<br>&gt; Thanks,<br>&gt; Andrew<br>&gt;<br>&gt; On Mon, Mar 28, 2016 at 7:21 PM, Andrew Bennett &lt;cacoyi at gmail.com<br>&gt; &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;<br>&gt;     Swift can resolve functions based on the return type. However, when the<br>&gt;     result is unused a single function often can&#39;t be resolved without<br>&gt;     explicitly specifying the type.<br>&gt;<br>&gt;     |func example() { ... } func example() -&gt; Int { ... } example() as Void<br>&gt;     example() as Int |<br>&gt;<br>&gt;     This proposal disambiguates some cases:<br>&gt;<br>&gt;       * Preferring functions with a |*Void*| return type when the result<br>&gt;         *is* discarded.<br>&gt;       * Preferring functions with a *non-|Void|* type when the result *is<br>&gt;         not* discarded.<br>&gt;<br>&gt;     These example will be unambiguous:<br>&gt;<br>&gt;     |example() // will prefer a `Void` function let x = example() // will<br>&gt;     prefer a non-`Void` function|<br>&gt;<br>&gt;     You can read the full latest version of the proposal here:<br>&gt;<br>&gt;     https://github.com/therealbnut/swift-evolution/blob/andrew-disambiguate-return-type/proposals/0000-disambiguate-return-type.md<br>&gt;<br>&gt;     This is the original version<br>&gt;     &lt;https://github.com/therealbnut/swift-evolution/blob/59d0f0b9bdabcfd675f36824232a8efa4a5f9152/proposals/0000-disambiguate-return-type.md&gt; of<br>&gt;     the proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Disambiguate Return Type With Void</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 26, 2016 at 11:00:00pm</p></header><div class="content"><p>Hi Vladimir, thanks for your feedback, I&#39;ve put my responses inline:<br></p><p>On Tue, Apr 26, 2016 at 10:26 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Interesting suggestion, but IMO this will produce a question about new<br>&gt; naming conversion in Swift 3.0 (noun/verb, -ing/-ed, etc) because using<br>&gt; your suggestion we could want to use:<br>&gt;<br>&gt; array.sort(..) // mutating<br>&gt; let array2 = array.sort(..) // non-mutating, instead of array.sorted()<br>&gt;<br>&gt;<br>This proposal does not want to change any naming guidelines. The reasons<br>for those guidelines is good, and remains the same. One reason is that<br>method names help distinguish mutating and non-mutating methods.<br></p><p>I&#39;m happy to discuss making the proposal only apply to functions with the<br>same mutability if that alleviates your concern.<br></p><p>Also, technically we can assign a value to Void function(yes, compiler<br>&gt; warning will be produced, but just warning, not error):<br>&gt;<br>&gt; var something = array.sort(..) // mutating,currently this is valid code<br>&gt; // something  == ()<br>&gt;<br>&gt;<br>You&#39;re right, although I don&#39;t think there would be a worthwhile loss of<br>functionality if that statement chose a non-Void function, or didn&#39;t store<br>the result. I&#39;m not sure why you would want to store the Void.<br></p><p>Note that this proposal is only to resolve ambiguity *if* there is any :)<br>It won&#39;t change how functions are resolved when there is no ambiguity.<br></p><p><br>&gt; On 26.04.2016 13:56, Andrew Bennett via swift-evolution wrote:<br>&gt;<br>&gt;&gt; Hey,<br>&gt;&gt;<br>&gt;&gt; I thought I would post another message to this thread because I think it<br>&gt;&gt; was missed when I first sent it (I made the mistake of sending it at 1am<br>&gt;&gt; San Francisco time, I&#39;m in Australia).<br>&gt;&gt;<br>&gt;&gt; I appreciate any feedback :)<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Andrew<br>&gt;&gt;<br>&gt;&gt; On Mon, Mar 28, 2016 at 7:21 PM, Andrew Bennett &lt;cacoyi at gmail.com<br>&gt;&gt; &lt;mailto:cacoyi at gmail.com&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Swift can resolve functions based on the return type. However, when<br>&gt;&gt; the<br>&gt;&gt;     result is unused a single function often can&#39;t be resolved without<br>&gt;&gt;     explicitly specifying the type.<br>&gt;&gt;<br>&gt;&gt;     |func example() { ... } func example() -&gt; Int { ... } example() as<br>&gt;&gt; Void<br>&gt;&gt;     example() as Int |<br>&gt;&gt;<br>&gt;&gt;     This proposal disambiguates some cases:<br>&gt;&gt;<br>&gt;&gt;       * Preferring functions with a |*Void*| return type when the result<br>&gt;&gt;         *is* discarded.<br>&gt;&gt;       * Preferring functions with a *non-|Void|* type when the result *is<br>&gt;&gt;         not* discarded.<br>&gt;&gt;<br>&gt;&gt;     These example will be unambiguous:<br>&gt;&gt;<br>&gt;&gt;     |example() // will prefer a `Void` function let x = example() // will<br>&gt;&gt;     prefer a non-`Void` function|<br>&gt;&gt;<br>&gt;&gt;     You can read the full latest version of the proposal here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/therealbnut/swift-evolution/blob/andrew-disambiguate-return-type/proposals/0000-disambiguate-return-type.md<br>&gt;&gt;<br>&gt;&gt;     This is the original version<br>&gt;&gt;     &lt;<br>&gt;&gt; https://github.com/therealbnut/swift-evolution/blob/59d0f0b9bdabcfd675f36824232a8efa4a5f9152/proposals/0000-disambiguate-return-type.md&gt;<br>&gt;&gt; of<br>&gt;&gt;     the proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/0c3b26be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>Disambiguate Return Type With Void</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 26, 2016 at 05:00:00pm</p></header><div class="content"><p>Andrew, thanks for comments. Yes, right now I see your points : its not <br>about mutation, but about the result type of the method/function with the <br>same mutation. I fully support this idea, as Swift allows to define the <br>same methods with just different types - we need handy way to call such <br>functions and clear rules when each one will be selected.<br></p><p>&quot;method names help distinguish mutating and non-mutating methods.&quot;..<br>Just some my thoughts: I&#39;m very skeptical in general on this. Personally I <br>probably prefer some kind of explicit &quot;marker&quot; on mutating methods(like <br>foo&amp;.sort()), as I don&#39;t fully believe in idea of clear separation based on <br>naming rules. Not all, who will write open source libraries/projects, are <br>native English speakers and we&#39;ll have code where it will be hard to <br>distinguish based on names. Even in this swift-evolution list we have a lot <br>of discussions about right naming of the methods/functions in API..<br></p><p>On 26.04.2016 16:04, Andrew Bennett wrote:<br>&gt; Hi Vladimir, thanks for your feedback, I&#39;ve put my responses inline:<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 10:26 PM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     Interesting suggestion, but IMO this will produce a question about new<br>&gt;     naming conversion in Swift 3.0 (noun/verb, -ing/-ed, etc) because using<br>&gt;     your suggestion we could want to use:<br>&gt;<br>&gt;     array.sort(..) // mutating<br>&gt;     let array2 = array.sort(..) // non-mutating, instead of array.sorted()<br>&gt;<br>&gt;<br>&gt; This proposal does not want to change any naming guidelines. The reasons<br>&gt; for those guidelines is good, and remains the same. One reason is that<br>&gt; method names help distinguish mutating and non-mutating methods.<br>&gt;<br>&gt; I&#39;m happy to discuss making the proposal only apply to functions with the<br>&gt; same mutability if that alleviates your concern.<br>&gt;<br>&gt;     Also, technically we can assign a value to Void function(yes, compiler<br>&gt;     warning will be produced, but just warning, not error):<br>&gt;<br>&gt;     var something = array.sort(..) // mutating,currently this is valid code<br>&gt;     // something  == ()<br>&gt;<br>&gt;<br>&gt; You&#39;re right, although I don&#39;t think there would be a worthwhile loss of<br>&gt; functionality if that statement chose a non-Void function, or didn&#39;t store<br>&gt; the result. I&#39;m not sure why you would want to store the Void.<br>&gt;<br>&gt; Note that this proposal is only to resolve ambiguity *if* there is any :)<br>&gt; It won&#39;t change how functions are resolved when there is no ambiguity.<br>&gt;<br>&gt;<br>&gt;     On 26.04.2016 13 &lt;tel:26.04.2016%2013&gt;:56, Andrew Bennett via<br>&gt;     swift-evolution wrote:<br>&gt;<br>&gt;         Hey,<br>&gt;<br>&gt;         I thought I would post another message to this thread because I<br>&gt;         think it<br>&gt;         was missed when I first sent it (I made the mistake of sending it<br>&gt;         at 1am<br>&gt;         San Francisco time, I&#39;m in Australia).<br>&gt;<br>&gt;         I appreciate any feedback :)<br>&gt;<br>&gt;         Thanks,<br>&gt;         Andrew<br>&gt;<br>&gt;         On Mon, Mar 28, 2016 at 7:21 PM, Andrew Bennett &lt;cacoyi at gmail.com<br>&gt;         &lt;mailto:cacoyi at gmail.com&gt;<br>&gt;         &lt;mailto:cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt;&gt; wrote:<br>&gt;<br>&gt;             Swift can resolve functions based on the return type. However,<br>&gt;         when the<br>&gt;             result is unused a single function often can&#39;t be resolved without<br>&gt;             explicitly specifying the type.<br>&gt;<br>&gt;             |func example() { ... } func example() -&gt; Int { ... } example()<br>&gt;         as Void<br>&gt;             example() as Int |<br>&gt;<br>&gt;             This proposal disambiguates some cases:<br>&gt;<br>&gt;               * Preferring functions with a |*Void*| return type when the<br>&gt;         result<br>&gt;                 *is* discarded.<br>&gt;               * Preferring functions with a *non-|Void|* type when the<br>&gt;         result *is<br>&gt;                 not* discarded.<br>&gt;<br>&gt;             These example will be unambiguous:<br>&gt;<br>&gt;             |example() // will prefer a `Void` function let x = example()<br>&gt;         // will<br>&gt;             prefer a non-`Void` function|<br>&gt;<br>&gt;             You can read the full latest version of the proposal here:<br>&gt;<br>&gt;<br>&gt;         https://github.com/therealbnut/swift-evolution/blob/andrew-disambiguate-return-type/proposals/0000-disambiguate-return-type.md<br>&gt;<br>&gt;             This is the original version<br>&gt;<br>&gt;         &lt;https://github.com/therealbnut/swift-evolution/blob/59d0f0b9bdabcfd675f36824232a8efa4a5f9152/proposals/0000-disambiguate-return-type.md&gt;<br>&gt;         of<br>&gt;             the proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;         _______________________________________________<br>&gt;         swift-evolution mailing list<br>&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>Disambiguate Return Type With Void</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>April 27, 2016 at 12:00:00am</p></header><div class="content"><p>On Wednesday, 27 April 2016, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Andrew, thanks for comments. Yes, right now I see your points : its not<br>&gt; about mutation, but about the result type of the method/function with the<br>&gt; same mutation. I fully support this idea, as Swift allows to define the<br>&gt; same methods with just different types - we need handy way to call such<br>&gt; functions and clear rules when each one will be selected.<br>&gt;<br>&gt; I&#39;m glad we are on the same page, please let me know if there&#39;s some way I<br>can clarify the proposal :)<br></p><p><br>&gt; &quot;method names help distinguish mutating and non-mutating methods.&quot;..<br>&gt; Just some my thoughts: I&#39;m very skeptical in general on this. Personally I<br>&gt; probably prefer some kind of explicit &quot;marker&quot; on mutating methods(like<br>&gt; foo&amp;.sort()), as I don&#39;t fully believe in idea of clear separation based on<br>&gt; naming rules. Not all, who will write open source libraries/projects, are<br>&gt; native English speakers and we&#39;ll have code where it will be hard to<br>&gt; distinguish based on names. Even in this swift-evolution list we have a lot<br>&gt; of discussions about right naming of the methods/functions in API..<br>&gt;<br>&gt; I agree, there&#39;s room to improve that. I don&#39;t think it&#39;s in scope for<br>this proposal though, unless you feel this propasal causes issues.<br></p><p><br>&gt; On 26.04.2016 16:04, Andrew Bennett wrote:<br>&gt;<br>&gt;&gt; Hi Vladimir, thanks for your feedback, I&#39;ve put my responses inline:<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 26, 2016 at 10:26 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     Interesting suggestion, but IMO this will produce a question about new<br>&gt;&gt;     naming conversion in Swift 3.0 (noun/verb, -ing/-ed, etc) because<br>&gt;&gt; using<br>&gt;&gt;     your suggestion we could want to use:<br>&gt;&gt;<br>&gt;&gt;     array.sort(..) // mutating<br>&gt;&gt;     let array2 = array.sort(..) // non-mutating, instead of array.sorted()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This proposal does not want to change any naming guidelines. The reasons<br>&gt;&gt; for those guidelines is good, and remains the same. One reason is that<br>&gt;&gt; method names help distinguish mutating and non-mutating methods.<br>&gt;&gt;<br>&gt;&gt; I&#39;m happy to discuss making the proposal only apply to functions with the<br>&gt;&gt; same mutability if that alleviates your concern.<br>&gt;&gt;<br>&gt;&gt;     Also, technically we can assign a value to Void function(yes, compiler<br>&gt;&gt;     warning will be produced, but just warning, not error):<br>&gt;&gt;<br>&gt;&gt;     var something = array.sort(..) // mutating,currently this is valid<br>&gt;&gt; code<br>&gt;&gt;     // something  == ()<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You&#39;re right, although I don&#39;t think there would be a worthwhile loss of<br>&gt;&gt; functionality if that statement chose a non-Void function, or didn&#39;t store<br>&gt;&gt; the result. I&#39;m not sure why you would want to store the Void.<br>&gt;&gt;<br>&gt;&gt; Note that this proposal is only to resolve ambiguity *if* there is any :)<br>&gt;&gt; It won&#39;t change how functions are resolved when there is no ambiguity.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     On 26.04.2016 13 &lt;tel:26.04.2016%2013&gt;:56, Andrew Bennett via<br>&gt;&gt;     swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;         Hey,<br>&gt;&gt;<br>&gt;&gt;         I thought I would post another message to this thread because I<br>&gt;&gt;         think it<br>&gt;&gt;         was missed when I first sent it (I made the mistake of sending it<br>&gt;&gt;         at 1am<br>&gt;&gt;         San Francisco time, I&#39;m in Australia).<br>&gt;&gt;<br>&gt;&gt;         I appreciate any feedback :)<br>&gt;&gt;<br>&gt;&gt;         Thanks,<br>&gt;&gt;         Andrew<br>&gt;&gt;<br>&gt;&gt;         On Mon, Mar 28, 2016 at 7:21 PM, Andrew Bennett &lt;cacoyi at gmail.com<br>&gt;&gt;         &lt;mailto:cacoyi at gmail.com&gt;<br>&gt;&gt;         &lt;mailto:cacoyi at gmail.com &lt;mailto:cacoyi at gmail.com&gt;&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;             Swift can resolve functions based on the return type. However,<br>&gt;&gt;         when the<br>&gt;&gt;             result is unused a single function often can&#39;t be resolved<br>&gt;&gt; without<br>&gt;&gt;             explicitly specifying the type.<br>&gt;&gt;<br>&gt;&gt;             |func example() { ... } func example() -&gt; Int { ... }<br>&gt;&gt; example()<br>&gt;&gt;         as Void<br>&gt;&gt;             example() as Int |<br>&gt;&gt;<br>&gt;&gt;             This proposal disambiguates some cases:<br>&gt;&gt;<br>&gt;&gt;               * Preferring functions with a |*Void*| return type when the<br>&gt;&gt;         result<br>&gt;&gt;                 *is* discarded.<br>&gt;&gt;               * Preferring functions with a *non-|Void|* type when the<br>&gt;&gt;         result *is<br>&gt;&gt;                 not* discarded.<br>&gt;&gt;<br>&gt;&gt;             These example will be unambiguous:<br>&gt;&gt;<br>&gt;&gt;             |example() // will prefer a `Void` function let x = example()<br>&gt;&gt;         // will<br>&gt;&gt;             prefer a non-`Void` function|<br>&gt;&gt;<br>&gt;&gt;             You can read the full latest version of the proposal here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/therealbnut/swift-evolution/blob/andrew-disambiguate-return-type/proposals/0000-disambiguate-return-type.md<br>&gt;&gt;<br>&gt;&gt;             This is the original version<br>&gt;&gt;<br>&gt;&gt;         &lt;<br>&gt;&gt; https://github.com/therealbnut/swift-evolution/blob/59d0f0b9bdabcfd675f36824232a8efa4a5f9152/proposals/0000-disambiguate-return-type.md<br>&gt;&gt; &gt;<br>&gt;&gt;         of<br>&gt;&gt;             the proposal.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         _______________________________________________<br>&gt;&gt;         swift-evolution mailing list<br>&gt;&gt;         swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160427/3689fd2b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
