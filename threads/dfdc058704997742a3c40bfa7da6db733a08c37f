<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 25, 2016 at 02:00:00pm</p></header><div class="content"><p>Since we&#39;re running short on time, and the previous discussion thread diverged, here&#39;s my attempt to fix the Comparable protocol.<br></p><p>Pull request: https://github.com/apple/swift-evolution/pull/464 &lt;https://github.com/apple/swift-evolution/pull/464&gt;<br></p><p>TL;DR:<br></p><p>1. Equatable remains unchanged, while Comparable bloats a bit to support several use cases.<br>2. `a &lt;=&gt; b` is well-defined even if either value is NaN. Zero is equal to minus zero.<br>3. Types are not strictly required to become totally ordered, even if it&#39;s strongly recommended.<br></p><p>— — —<br></p><p>I simply can&#39;t see how a pure total order version of Comparable would fit the standard way floating point values are expected to behave. However, I think we can reach a satisfactory conclusion, one that involves no crashing in the standard library, which is what I previously suggested.<br></p><p>What I&#39;m trying to fix is so that all operations listed in https://dl.dropboxusercontent.com/u/217402/Comparable.pdf &lt;https://dl.dropboxusercontent.com/u/217402/Comparable.pdf&gt; abide to laws for types without incomparable values, and that types with weaker order can still work in some well-defined way outside their totally ordered range.<br></p><p>PS. Forgive me Robert, Jaden, and Harlan for not syncing with you, for time is tight. I can pull back or revise the proposal if you don&#39;t want to be involved.<br></p><p>— Pyry<br></p><p><br></p><p><br>Formalized Ordering<br></p><p>Proposal: SE-NNNN &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-filename.md&gt;<br>Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Jaden Geller &lt;https://github.com/jadengeller&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, Pyry Jahkola &lt;https://github.com/pyrtsa&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#introduction&gt;Introduction<br></p><p>This proposal cleans up the semantics of ordering relations in the standard library. Our goal is to formalize the total ordering semantics of the Comparable protocol and still provide accessible ordering definitions for types without total ordering semantics.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#motivation&gt;Motivation<br></p><p>The standard comparison operators have an intuitive meaning to programmers. Swift encourages encoding that in an implementation of Comparable that respects the rules of a total order &lt;https://en.wikipedia.org/wiki/Total_order&gt;. The standard library takes advantage of these rules to provide consistent implementations for sorting and searching generic collections of Comparable types.<br></p><p>Not all types behave so well in this framework, unfortunately. There are cases where the semantics of a total order cannot apply and still maintain the traditional definition of “comparison” over these types. Take, for example, sorting an array of Float s. Today, Float ‘s instance of Comparable follows IEEE-754 and returns false for all comparisons of NaN . In order to sort this array, NaN s are considered outside the domain of &lt; , and the order of a “sorted” array containing them is undefined.<br></p><p>In addition, generic algorithms in the Swift Standard Library that make use of the current Comparable protocol may have to make twice as many comparisons to request the ordering of values with respect to each other than they should. Having a central operation to return information about the ordering of values once should provide a speedup for these operations.<br></p><p>In the interest of cleaning up the semantics of Comparable types of all shapes and sizes and their uses in the Swift Standard Library, this proposal is going to re-arrange the requirements of the Comparable and Equatable protocols.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#proposed-solution&gt;Proposed solution<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#equatable&gt;Equatable<br></p><p>The interface of Equatable remains unchanged under this proposal. Equatable types should still respect the equivalence laws of reflexivity (a == a), symmetry (a == b iff b == a), and transitivity (if a == b and b == c, then a == c). Further, != remains a top-level binary operator for which a != b iff !(a == b).<br></p><p>Types containing properties inessential to equality, however, are allowed to retain their notion of identity. For example Array&#39;s capacity isn&#39;t considered for equality; and -0.0 == 0.0 and &quot;ä&quot; == &quot;a\u{308}&quot;, while (-0.0).sign != (0.0).sign and &quot;ä&quot;.utf8.count != &quot;a\u{308}&quot;.utf8.count.<br></p><p>IEEE-754 floating point numbers are allowed to break the reflexivity law by defining that .nan != x for any value of x, which is the standard behaviour documented in IEEE-754 and implemented the same way in other programming languages.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#comparable&gt;Comparable<br></p><p>The Comparable protocol will now require (without default implementation provided) a single operator definition: &lt;=&gt; — the comparison operator. From this, all other comparison operators will be derived so as to respect the total order semantics of Comparable:<br></p><p>To maintain compatibility with IEEE-754, the interface of Comparable also contains as customization points the operators &lt;, &lt;=, and == (derived from Equatable) as well as the static binary functions _min(_:_:) and _max(_:_:). User-defined types are recommended against overriding the default implementations.<br></p><p>The uncustomizable top-level binary comparison operators a &gt; b and a &gt;= b are implemented as synonyms to b &lt; aand b &lt;= a, respectively.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#standard-library&gt;Standard Library<br></p><p>Unlike a previous revision of this proposal, standard library algorithms specific to FloatingPoint remain unchanged.<br></p><p>Overloads of &lt;=&gt; for tuples of Comparable elements are provided up to a library-defined arity.<br></p><p>The intent of this proposal is to later augment the standard library so that functions that take an ordering predicate by: (T, T) -&gt; Bool will have an overload ordering: (T, T) -&gt; Ordering that will provide a — potentially — more efficient implementation. A list of such functions is provided in Future directions.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#detailed-design&gt;Detailed design<br></p><p>The Comparable protocol will be amended by taking away &gt; and &gt;=, adding customisation points _min(_:_:), and _max(_:_:), and introducing the ordering operator &lt;=&gt; that makes use of the Ordering enum defined below.<br></p><p>enum Ordering : Equatable {<br>  case ascending<br>  case equal<br>  case descending<br>}<br></p><p>infix operator &lt;=&gt; { associativity none precedence 130 }<br></p><p>public protocol Comparable : Equatable {<br>  // Implementation required:<br>  static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br></p><p>  // Default implementations provided:<br>  static func == (lhs: Self, rhs: Self) -&gt; Bool // derived from Equatable<br>  static func &lt;  (lhs: Self, rhs: Self) -&gt; Bool<br>  static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>  static func _min(_ lhs: Self, _ rhs: Self) -&gt; Self<br>  static func _max(_ lhs: Self, _ rhs: Self) -&gt; Self<br>}<br>The &lt;=&gt; operator defines a relationship between == and &lt;=&gt; such that a == b iff (a &lt;=&gt; b) == .equal, unless Self chooses to break the semantics in the way of IEEE-754. Likewise, it should hold that (a &lt;=&gt; b) == .ascending iff a &lt; b, and (a &lt;=&gt; b) != .descending iff a &lt;= b.<br></p><p>The _min(_:_:) and _max(_:_:) functions should return the lesser or greater of the two operands, respectively, while in case of equal arguments, _min(_:_:) should favour the left-hand side and _max(_:_:) the right-hand side to retain identity, as presently explained in this comment &lt;https://github.com/apple/swift/blob/4614adc16168d612b6fc7e7a161dd5b6b34be704/stdlib/public/core/Algorithm.swift#L17-L20&gt;. Making them customization points of Comparable, we get to fix their behaviour in the presense of unorderable values (SR-1011 &lt;https://bugs.swift.org/browse/SR-1011&gt;).<br></p><p>Most user types should only implement &lt;=&gt; and leave the other members of Equatable and Comparable to their default implementations. Note that even == has a sane default implementation if Self is made Comparable:<br></p><p>// Default implementations, which should be used for most Comparable types:<br>extension Comparable {<br>  static func == (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .equal }<br>  static func &lt;  (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .ascending }<br>  static func &lt;= (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) != .descending }<br>  static func _min(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? r : l }<br>  static func _max(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? l : r }<br>}<br></p><p>// Unoverridable top-level operators and functions for Comparable:<br>public func &gt;  &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt; l }<br>public func &gt;= &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt;= l }<br>public func min&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._min(l, r) }<br>public func max&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._max(l, r) }<br> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#handling-of-floating-point-comparisons&gt;Handling of floating point comparisons<br></p><p>The following text is written in terms of Double but other floating-point types (Float, Float80) are proposed the same treatment.<br></p><p>The IEEE-754 floating point specification has two oddities when it comes to orderability: there are two zeros (0.0 and -0.0) which are considered equal to each other, and there are multiple not-a-number values x for which x.isNaN == true and x != y with any value of y, even x itself. (Remark: the most common NaN value is obtained by the static property Double.nan.)<br></p><p>The interface of Comparable is designed so that &lt;=&gt; alone is able to produce a total order among all possible Doublevalues, sorting negative NaNs less than any other values, and positive NaNs greater than any other. Otherwise, within the range of totally ordered floating point values, -Double.infinity ... Double.infinity, the result of a &lt;=&gt; b remains in full agreement with the laws of a &lt; b, a &lt;= b, and a == b.<br></p><p>The suggested implementation of Double : Comparable makes &lt;=&gt; distinguish between every different bitPatternof NaN:<br></p><p>extension Double : Comparable {<br>  public static func &lt;=&gt; (l: Double, r: Double) -&gt; Ordering {<br>    func ordinal(_ x: UInt64) -&gt; UInt64 {<br>      return x &lt; 0x80000000_00000000 ? x + 0x7fffffff_ffffffff : ~x<br>    }<br>    return ordinal(l.bitPattern) &lt;=&gt; ordinal(r.bitPattern)<br>  }<br>  public static func == (l: Double, r: Double) -&gt; Bool { return Builtin.eq(l, r) }<br>  public static func &lt;  (l: Double, r: Double) -&gt; Bool { return Builtin.lt(l, r) }<br>  public static func &lt;= (l: Double, r: Double) -&gt; Bool { return Builtin.le(l, r) }<br>  public static func _min(l: Double, r: Double) -&gt; Double { return Builtin.fmin(l, r) }<br>  public static func _max(l: Double, r: Double) -&gt; Double { return Builtin.fmax(l, r) }<br>}<br></p><p>// Likewise:<br>extension Float : Comparable { ... }<br>extension Float80 : Comparable { ... }<br> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#tuples-and-order-reversal&gt;Tuples and order reversal<br></p><p>Due to missing language support, tuples of Comparable elements cannot be Comparable themselves, but in the spirit of SE-0015 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;, such tuples are given their overloads of &lt;=&gt; up to a standard library defined maximum arity:<br></p><p>public func &lt;=&gt; &lt;A : Comparable, B : Comparable&gt;(lhs: (A, B), rhs: (A, B)) -&gt; Ordering {<br>  let a = lhs.0 &lt;=&gt; rhs.0<br>  if a != .equal { return a }<br>  let b = lhs.1 &lt;=&gt; rhs.1<br>  if b != .equal { return b }<br>  return .equal<br>}<br></p><p>// Similarly for &lt;A : Comparable, B : Comparable, C : Comparable&gt;, etc.<br>To simplify the reversal of a given ordering operation, two members of Ordering are provided in an extension:<br></p><p>extension Ordering {<br>  public static func reversing&lt;T : Comparable&gt;(_ ordering: (T, T) -&gt; Ordering)<br>    -&gt; (T, T) -&gt; Ordering<br>  {<br>    return { l, r in ordering(r, l) }<br>  }<br></p><p>  public var reversed: Ordering {<br>    switch self {<br>    case .ascending:  return .descending<br>    case .equal:      return .equal<br>    case .descending: return .ascending<br>    }<br>  }<br>}<br> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#foundation&gt;Foundation<br></p><p>In addition, Foundation code will now bridge NSComparisonResult to Ordering allowing for a fluid, natural, and safe API.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#impact-on-existing-code&gt;Impact on existing code<br></p><p>The biggest drawback of the proposed design is the large surface area of Comparable&#39;s interface, as well as the possibility of overriding the comparison operators by mistake. On the other hand, since the required &lt;=&gt; operator is new and affects all users porting their previously Comparable data types to Swift 3, we can use documentation to suggest removing the redundant (and possibly faulty) implementations of other comparison operators.<br></p><p>Existing Equatable but not Comparable types that define an equivalence relation with == will remain unchanged.<br></p><p>Existing Comparable types that define a total ordering with &lt; will need to implement &lt;=&gt; and should remove their existing implementation of any comparison operators, including ==. All other existing Comparable types should implement &lt;=&gt; that provides a total ordering, or should drop their Comparable conformance.<br></p><p>Before:<br></p><p>struct Date: Comparable {<br>  let year: Int<br>  let month: Int<br>  let day: Int<br>}<br></p><p>func ==(lhs: Date, rhs: Date) -&gt; Bool {<br>  return lhs.year == rhs.year<br>    &amp;&amp; lhs.month == rhs.month<br>    &amp;&amp; lhs.day == rhs.day<br>}<br></p><p>func &lt;(lhs: Date, rhs: Date) -&gt; Bool {<br>  if lhs.year != rhs.year {<br>    return lhs.year &lt; rhs.year<br>  } else if lhs.month != rhs.month {<br>    return lhs.month &lt; rhs.month<br>  } else {<br>    return lhs.day &lt; rhs.day<br>  }<br>}<br>After, using the tuple overload of &lt;=&gt;:<br></p><p>struct Date: Comparable {<br>  let year: Int<br>  let month: Int<br>  let day: Int<br></p><p>  static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>    return (lhs.year, lhs.month, lhs.day)<br>       &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>  }<br></p><p>  // // Explicit version:<br>  // static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>  //   let yearResult = lhs.year &lt;=&gt; rhs.year<br>  //   guard case .equal = yearResult else { return yearResult }<br>  //   let monthResult = lhs.month &lt;=&gt; rhs.month<br>  //   guard case .equal = monthResult else { return monthResult }<br>  //   return lhs.day &lt;=&gt; rhs.day<br>  // }<br>}<br> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#alternatives-considered&gt;Alternatives considered<br></p><p>A previous design of this proposal suggested a strict total order upon Comparable. While that would make generic algorithms more correct, the definition ended up fighting against the expected behaviour of floating point numbers.<br></p><p>An alternative design that better matches the existing arithmetic-related protocols in Swift is one that uses a member function.<br></p><p>public protocol Comparable: Equatable {<br>  func compare(to: Self) -&gt; Ordering<br>}<br>However, while this API does read better than an operator, we believe that this imposes a number of artificial restrictions (especially in light of SE-0091 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;)<br></p><p>There is no way to use Comparable.compare as a higher-order function in a non-generic context.<br>If a member is desired, it can be provided in a protocol extension and defined in terms of the ordering operator; to each according to their need.<br>The existing tuple overloads cannot be expressed with a member function.<br>One other that Rust has adopted is the inclusion of PartialEquatable and PartialComparable as ancestors of their flavor of Equatable and Comparable . Having protocols to organize and catalogue types that can only guarantee partial equivalence and ordering relations is a good approach for modularity but clutters the standard library with two new protocols for which few useful algorithms could be written against.<br></p><p> &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#future-directions&gt;Future directions<br></p><p>That the default sort() compares by &lt; and not &lt;=&gt; should be considered a bug to be fixed in a future version of Swift. Using &lt;=&gt; will make sort() well-behaved in the presense of NaN. However, given that the current behaviour is to produce an unspecified order, the fix is additive and can be slipped past Swift 3.<br></p><p>With &lt;=&gt; in place, several present and future standard library algorithms involving a &lt;T : Comparable&gt; requirement will possibly benefit from knowing the total ordering of two operands at once. This is a list of possible such functions (taking Array as example), to be proposed separately as an additive change:<br></p><p>extension Array {<br>  // Sorting<br></p><p>  mutating func sort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>  func sorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>  mutating func stableSort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>  func stableSorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br></p><p>  /// Reorders the elements of the collection such that all the elements<br>  /// returning `.ascending` are moved to the start of the collection, and the<br>  /// elements returning `.descending` are moved to the end of the collection.<br>  /// - Returns: the range of elements for which `ordering(x) == .equal`.<br>  mutating func partition(ordering: @noescape (Iterator.Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br></p><p>  // Binary search<br></p><p>  func bisectedIndex(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index?<br>  func lowerBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>  func upperBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>  func equalRange(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>}<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/dfdcc37f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4e40d3058defa1eaaa61ed5aa88d2be5?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Björn Forster</string> &lt;bjoern.forster at googlemail.com&gt;<p>July 25, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Pyry,<br>thanks for all the work you have put into this!<br>Could you please explain for someone as simple minded as me why there is<br>(or has to be) a difference in the implementation of &lt;, &lt;= and &gt;, &gt;=?<br>Sorry, but I don&#39;t get into my head why there is/has to be a preference for<br>one side. Could you or someone else point out (in the proposal) why there<br>is a need/what is the reason for this?<br>I assume that this might not be obvious to some other people on the first<br>look, too.<br></p><p>Björn<br></p><p>On Mon, Jul 25, 2016 at 1:41 PM, Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Since we&#39;re running short on time, and the previous discussion thread<br>&gt; diverged, here&#39;s my attempt to fix the Comparable protocol.<br>&gt;<br>&gt; *Pull request:* https://github.com/apple/swift-evolution/pull/464<br>&gt;<br>&gt; TL;DR:<br>&gt;<br>&gt; 1. Equatable remains unchanged, while Comparable bloats a bit to support<br>&gt; several use cases.<br>&gt; 2. `a &lt;=&gt; b` is well-defined even if either value is NaN. Zero is equal to<br>&gt; minus zero.<br>&gt; 3. Types are not strictly required to become totally ordered, even if it&#39;s<br>&gt; strongly recommended.<br>&gt;<br>&gt; — — —<br>&gt;<br>&gt; I simply can&#39;t see how a pure total order version of Comparable would fit<br>&gt; the standard way floating point values are expected to behave. However, I<br>&gt; think we can reach a satisfactory conclusion, one that involves no crashing<br>&gt; in the standard library, which is what I previously suggested.<br>&gt;<br>&gt; What I&#39;m trying to fix is so that all operations listed in<br>&gt; https://dl.dropboxusercontent.com/u/217402/Comparable.pdf abide to laws<br>&gt; for types without incomparable values, and that types with weaker order can<br>&gt; still work in *some* well-defined way outside their totally ordered range.<br>&gt;<br>&gt; PS. Forgive me Robert, Jaden, and Harlan for not syncing with you, for<br>&gt; time is tight. I can pull back or revise the proposal if you don&#39;t want to<br>&gt; be involved.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Formalized Ordering<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-filename.md&gt;<br>&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Jaden Geller<br>&gt;    &lt;https://github.com/jadengeller&gt;, Harlan Haskins<br>&gt;    &lt;https://github.com/harlanhaskins&gt;, Pyry Jahkola<br>&gt;    &lt;https://github.com/pyrtsa&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal cleans up the semantics of ordering relations in the<br>&gt; standard library. Our goal is to formalize the total ordering semantics of<br>&gt; the Comparable protocol and still provide accessible ordering definitions<br>&gt; for types without total ordering semantics.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The standard comparison operators have an intuitive meaning to<br>&gt; programmers. Swift encourages encoding that in an implementation of<br>&gt; Comparable that respects the rules of a total order<br>&gt; &lt;https://en.wikipedia.org/wiki/Total_order&gt;. The standard library takes<br>&gt; advantage of these rules to provide consistent implementations for sorting<br>&gt; and searching generic collections of Comparable types.<br>&gt;<br>&gt; Not all types behave so well in this framework, unfortunately. There are<br>&gt; cases where the semantics of a total order cannot apply and still maintain<br>&gt; the traditional definition of “comparison” over these types. Take, for<br>&gt; example, sorting an array of Float s. Today, Float ‘s instance of<br>&gt; Comparable follows IEEE-754 and returns false for all comparisons of NaN .<br>&gt; In order to sort this array, NaN s are considered outside the domain of &lt; ,<br>&gt; and the order of a “sorted” array containing them is undefined.<br>&gt;<br>&gt; In addition, generic algorithms in the Swift Standard Library that make<br>&gt; use of the current Comparable protocol may have to make twice as many<br>&gt; comparisons to request the ordering of values with respect to each other<br>&gt; than they should. Having a central operation to return information about<br>&gt; the ordering of values once should provide a speedup for these operations.<br>&gt;<br>&gt; In the interest of cleaning up the semantics of Comparable types of all<br>&gt; shapes and sizes and their uses in the Swift Standard Library, this<br>&gt; proposal is going to re-arrange the requirements of the Comparable and<br>&gt; Equatable protocols.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#equatable&gt;<br>&gt; Equatable<br>&gt;<br>&gt; The interface of Equatable remains unchanged under this proposal.<br>&gt; Equatable types should still respect the equivalence laws of *reflexivity*<br>&gt;  (a == a), *symmetry* (a == b iff b == a), and *transitivity* (if a == b<br>&gt;  and b == c, then a == c). Further, != remains a top-level binary<br>&gt; operator for which a != b iff !(a == b).<br>&gt;<br>&gt; Types containing properties *inessential to equality*, however, are<br>&gt; allowed to retain their notion of identity. For example Array&#39;s capacity isn&#39;t<br>&gt; considered for equality; and -0.0 == 0.0 and &quot;ä&quot; == &quot;a\u{308}&quot;, while (-0.0).sign<br>&gt; != (0.0).sign and &quot;ä&quot;.utf8.count != &quot;a\u{308}&quot;.utf8.count.<br>&gt;<br>&gt; IEEE-754 floating point numbers are allowed to break the reflexivity law<br>&gt; by defining that .nan != x for any value of x, which is the standard<br>&gt; behaviour documented in IEEE-754 and implemented the same way in other<br>&gt; programming languages.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#comparable&gt;<br>&gt; Comparable<br>&gt;<br>&gt; The Comparable protocol will now require (without default implementation<br>&gt; provided) a single operator definition: &lt;=&gt; — the comparison operator.<br>&gt; From this, all other comparison operators will be derived so as to respect<br>&gt; the total order semantics of Comparable:<br>&gt;<br>&gt; To maintain compatibility with IEEE-754, the interface of Comparable also<br>&gt; contains as customization points the operators &lt;, &lt;=, and == (derived<br>&gt; from Equatable) as well as the static binary functions _min(_:_:) and<br>&gt; _max(_:_:). User-defined types are recommended against overriding the<br>&gt; default implementations.<br>&gt;<br>&gt; The uncustomizable top-level binary comparison operators a &gt; b and a &gt;= b are<br>&gt; implemented as synonyms to b &lt; aand b &lt;= a, respectively.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#standard-library&gt;Standard<br>&gt; Library<br>&gt;<br>&gt; Unlike a previous revision of this proposal, standard library algorithms<br>&gt; specific to FloatingPoint remain unchanged.<br>&gt;<br>&gt; Overloads of &lt;=&gt; for tuples of Comparable elements are provided up to a<br>&gt; library-defined arity.<br>&gt;<br>&gt; The intent of this proposal is to later augment the standard library so<br>&gt; that functions that take an ordering predicate by: (T, T) -&gt; Bool will<br>&gt; have an overload ordering: (T, T) -&gt; Ordering that will provide a —<br>&gt; potentially — more efficient implementation. A list of such functions is<br>&gt; provided in Future directions.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The Comparable protocol will be amended by taking away &gt; and &gt;=, adding<br>&gt; customisation points _min(_:_:), and _max(_:_:), and introducing the<br>&gt; ordering operator &lt;=&gt; that makes use of the Ordering enum defined below.<br>&gt;<br>&gt; enum Ordering : Equatable {<br>&gt;   case ascending<br>&gt;   case equal<br>&gt;   case descending<br>&gt; }<br>&gt; infix operator &lt;=&gt; { associativity none precedence 130 }<br>&gt; public protocol Comparable : Equatable {<br>&gt;   // Implementation required:<br>&gt;   static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;<br>&gt;   // Default implementations provided:<br>&gt;   static func == (lhs: Self, rhs: Self) -&gt; Bool // derived from Equatable<br>&gt;   static func &lt;  (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   static func _min(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;   static func _max(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; The &lt;=&gt; operator defines a relationship between == and &lt;=&gt; such that a ==<br>&gt; b iff (a &lt;=&gt; b) == .equal, unless Self chooses to break the semantics in<br>&gt; the way of IEEE-754. Likewise, it should hold that (a &lt;=&gt; b) == .ascending<br>&gt;  iff a &lt; b, and (a &lt;=&gt; b) != .descending iff a &lt;= b.<br>&gt;<br>&gt; The _min(_:_:) and _max(_:_:) functions should return the lesser or<br>&gt; greater of the two operands, respectively, while in case of equal<br>&gt; arguments, _min(_:_:) should favour the left-hand side and _max(_:_:) the<br>&gt; right-hand side to retain identity, as presently explained in this comment<br>&gt; &lt;https://github.com/apple/swift/blob/4614adc16168d612b6fc7e7a161dd5b6b34be704/stdlib/public/core/Algorithm.swift#L17-L20&gt;.<br>&gt; Making them customization points of Comparable, we get to fix their<br>&gt; behaviour in the presense of unorderable values (SR-1011<br>&gt; &lt;https://bugs.swift.org/browse/SR-1011&gt;).<br>&gt;<br>&gt; Most user types should only implement &lt;=&gt; and leave the other members of<br>&gt; Equatable and Comparable to their default implementations. Note that even<br>&gt; == has a sane default implementation if Self is made Comparable:<br>&gt;<br>&gt; // Default implementations, which should be used for most Comparable types:extension Comparable {<br>&gt;   static func == (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .equal }<br>&gt;   static func &lt;  (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .ascending }<br>&gt;   static func &lt;= (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) != .descending }<br>&gt;   static func _min(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? r : l }<br>&gt;   static func _max(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? l : r }<br>&gt; }<br>&gt; // Unoverridable top-level operators and functions for Comparable:public func &gt;  &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt; l }public func &gt;= &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt;= l }public func min&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._min(l, r) }public func max&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._max(l, r) }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#handling-of-floating-point-comparisons&gt;Handling<br>&gt; of floating point comparisons<br>&gt;<br>&gt; *The following text is written in terms of Double but other floating-point<br>&gt; types (Float, Float80) are proposed the same treatment.*<br>&gt;<br>&gt; The IEEE-754 floating point specification has two oddities when it comes<br>&gt; to orderability: there are two zeros (0.0 and -0.0) which are considered<br>&gt; equal to each other, and there are *multiple* not-a-number values x for<br>&gt; which x.isNaN == true and x != y with any value of y, even x itself.<br>&gt; (Remark: the most common NaN value is obtained by the static property<br>&gt; Double.nan.)<br>&gt;<br>&gt; The interface of Comparable is designed so that &lt;=&gt; alone is able to<br>&gt; produce a total order among all possible Doublevalues, sorting negative<br>&gt; NaNs less than any other values, and positive NaNs greater than any other.<br>&gt; Otherwise, within the range of totally ordered floating point values, -Double.infinity<br>&gt; ... Double.infinity, the result of a &lt;=&gt; b remains in full agreement with<br>&gt; the laws of a &lt; b, a &lt;= b, and a == b.<br>&gt;<br>&gt; The suggested implementation of Double : Comparable makes &lt;=&gt; distinguish<br>&gt; between every different bitPatternof NaN:<br>&gt;<br>&gt; extension Double : Comparable {<br>&gt;   public static func &lt;=&gt; (l: Double, r: Double) -&gt; Ordering {<br>&gt;     func ordinal(_ x: UInt64) -&gt; UInt64 {<br>&gt;       return x &lt; 0x80000000_00000000 ? x + 0x7fffffff_ffffffff : ~x<br>&gt;     }<br>&gt;     return ordinal(l.bitPattern) &lt;=&gt; ordinal(r.bitPattern)<br>&gt;   }<br>&gt;   public static func == (l: Double, r: Double) -&gt; Bool { return Builtin.eq(l, r) }<br>&gt;   public static func &lt;  (l: Double, r: Double) -&gt; Bool { return Builtin.lt(l, r) }<br>&gt;   public static func &lt;= (l: Double, r: Double) -&gt; Bool { return Builtin.le(l, r) }<br>&gt;   public static func _min(l: Double, r: Double) -&gt; Double { return Builtin.fmin(l, r) }<br>&gt;   public static func _max(l: Double, r: Double) -&gt; Double { return Builtin.fmax(l, r) }<br>&gt; }<br>&gt; // Likewise:extension Float : Comparable { ... }extension Float80 : Comparable { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#tuples-and-order-reversal&gt;Tuples<br>&gt; and order reversal<br>&gt;<br>&gt; Due to missing language support, tuples of Comparable elements cannot be<br>&gt; Comparable themselves, but in the spirit of SE-0015<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;,<br>&gt; such tuples are given their overloads of &lt;=&gt; up to a standard library<br>&gt; defined maximum arity:<br>&gt;<br>&gt; public func &lt;=&gt; &lt;A : Comparable, B : Comparable&gt;(lhs: (A, B), rhs: (A, B)) -&gt; Ordering {<br>&gt;   let a = lhs.0 &lt;=&gt; rhs.0<br>&gt;   if a != .equal { return a }<br>&gt;   let b = lhs.1 &lt;=&gt; rhs.1<br>&gt;   if b != .equal { return b }<br>&gt;   return .equal<br>&gt; }<br>&gt; // Similarly for &lt;A : Comparable, B : Comparable, C : Comparable&gt;, etc.<br>&gt;<br>&gt; To simplify the reversal of a given ordering operation, two members of<br>&gt; Ordering are provided in an extension:<br>&gt;<br>&gt; extension Ordering {<br>&gt;   public static func reversing&lt;T : Comparable&gt;(_ ordering: (T, T) -&gt; Ordering)<br>&gt;     -&gt; (T, T) -&gt; Ordering<br>&gt;   {<br>&gt;     return { l, r in ordering(r, l) }<br>&gt;   }<br>&gt;<br>&gt;   public var reversed: Ordering {<br>&gt;     switch self {<br>&gt;     case .ascending:  return .descending<br>&gt;     case .equal:      return .equal<br>&gt;     case .descending: return .ascending<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#foundation&gt;<br>&gt; Foundation<br>&gt;<br>&gt; In addition, Foundation code will now bridge NSComparisonResult to<br>&gt; Ordering allowing for a fluid, natural, and safe API.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The biggest drawback of the proposed design is the large surface area of<br>&gt; Comparable&#39;s interface, as well as the possibility of overriding the<br>&gt; comparison operators by mistake. On the other hand, since the required &lt;=&gt; operator<br>&gt; is new and affects all users porting their previously Comparable data<br>&gt; types to Swift 3, we can use documentation to suggest removing the<br>&gt; redundant (and possibly faulty) implementations of other comparison<br>&gt; operators.<br>&gt;<br>&gt; Existing Equatable but not Comparable types that define an equivalence<br>&gt; relation with == will remain unchanged.<br>&gt;<br>&gt; Existing Comparable types that define a total ordering with &lt; will need<br>&gt; to implement &lt;=&gt; and should remove their existing implementation of any<br>&gt; comparison operators, including ==. All other existing Comparable types<br>&gt; should implement &lt;=&gt; that provides a total ordering, or should drop their<br>&gt; Comparable conformance.<br>&gt;<br>&gt; Before:<br>&gt;<br>&gt; struct Date: Comparable {<br>&gt;   let year: Int<br>&gt;   let month: Int<br>&gt;   let day: Int<br>&gt; }<br>&gt; func ==(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;   return lhs.year == rhs.year<br>&gt;     &amp;&amp; lhs.month == rhs.month<br>&gt;     &amp;&amp; lhs.day == rhs.day<br>&gt; }<br>&gt; func &lt;(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;   if lhs.year != rhs.year {<br>&gt;     return lhs.year &lt; rhs.year<br>&gt;   } else if lhs.month != rhs.month {<br>&gt;     return lhs.month &lt; rhs.month<br>&gt;   } else {<br>&gt;     return lhs.day &lt; rhs.day<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; After, using the tuple overload of &lt;=&gt;:<br>&gt;<br>&gt; struct Date: Comparable {<br>&gt;   let year: Int<br>&gt;   let month: Int<br>&gt;   let day: Int<br>&gt;<br>&gt;   static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;     return (lhs.year, lhs.month, lhs.day)<br>&gt;        &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>&gt;   }<br>&gt;<br>&gt;   // // Explicit version:<br>&gt;   // static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;   //   let yearResult = lhs.year &lt;=&gt; rhs.year<br>&gt;   //   guard case .equal = yearResult else { return yearResult }<br>&gt;   //   let monthResult = lhs.month &lt;=&gt; rhs.month<br>&gt;   //   guard case .equal = monthResult else { return monthResult }<br>&gt;   //   return lhs.day &lt;=&gt; rhs.day<br>&gt;   // }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; A previous design of this proposal suggested a strict total order upon<br>&gt; Comparable. While that would make generic algorithms more correct, the<br>&gt; definition ended up fighting against the expected behaviour of floating<br>&gt; point numbers.<br>&gt;<br>&gt; An alternative design that better matches the existing arithmetic-related<br>&gt; protocols in Swift is one that uses a member function.<br>&gt;<br>&gt; public protocol Comparable: Equatable {<br>&gt;   func compare(to: Self) -&gt; Ordering<br>&gt; }<br>&gt;<br>&gt; However, while this API does read better than an operator, we believe that<br>&gt; this imposes a number of artificial restrictions (especially in light of<br>&gt; SE-0091<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;<br>&gt; )<br>&gt;<br>&gt;    1. There is no way to use Comparable.compare as a higher-order<br>&gt;    function in a non-generic context.<br>&gt;    2. If a member is desired, it can be provided in a protocol extension<br>&gt;    and defined in terms of the ordering operator; to each according to their<br>&gt;    need.<br>&gt;    3. The existing tuple overloads cannot be expressed with a member<br>&gt;    function.<br>&gt;<br>&gt; One other that Rust has adopted is the inclusion of PartialEquatable and<br>&gt; PartialComparable as ancestors of their flavor of Equatable and Comparable .<br>&gt; Having protocols to organize and catalogue types that can only guarantee<br>&gt; partial equivalence and ordering relations is a good approach for<br>&gt; modularity but clutters the standard library with two new protocols for<br>&gt; which few useful algorithms could be written against.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; That the default sort() compares by &lt; and not &lt;=&gt; should be considered a<br>&gt; bug to be fixed in a future version of Swift. Using &lt;=&gt; will make sort() well-behaved<br>&gt; in the presense of NaN. However, given that the current behaviour is to<br>&gt; produce an unspecified order, the fix is additive and can be slipped past<br>&gt; Swift 3.<br>&gt;<br>&gt; With &lt;=&gt; in place, several present and future standard library algorithms<br>&gt; involving a &lt;T : Comparable&gt; requirement will possibly benefit from<br>&gt; knowing the total ordering of two operands at once. This is a list of<br>&gt; possible such functions (taking Array as example), to be proposed<br>&gt; separately as an additive change:<br>&gt;<br>&gt; extension Array {<br>&gt;   // Sorting<br>&gt;<br>&gt;   mutating func sort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;   func sorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;   mutating func stableSort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;   func stableSorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;<br>&gt;   /// Reorders the elements of the collection such that all the elements<br>&gt;   /// returning `.ascending` are moved to the start of the collection, and the<br>&gt;   /// elements returning `.descending` are moved to the end of the collection.<br>&gt;   /// - Returns: the range of elements for which `ordering(x) == .equal`.<br>&gt;   mutating func partition(ordering: @noescape (Iterator.Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt;<br>&gt;   // Binary search<br>&gt;<br>&gt;   func bisectedIndex(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index?<br>&gt;   func lowerBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;   func upperBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;   func equalRange(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/8bef1254/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 25 Jul 2016, at 18:51, Björn Forster &lt;bjoern.forster at googlemail.com&gt; wrote:<br>&gt; <br>&gt; Could you please explain for someone as simple minded as me why there is (or has to be) a difference in the implementation of &lt;, &lt;= and &gt;, &gt;=?<br>&gt; Sorry, but I don&#39;t get into my head why there is/has to be a preference for one side. Could you or someone else point out (in the proposal) why there is a need/what is the reason for this?<br>&gt; I assume that this might not be obvious to some other people on the first look, too.<br></p><p>The reason is two-fold:<br></p><p>Firstly, and most importantly, because we want the law of antisymmetry (that `a &lt; b` iff `b &gt; a`, and likewise for ≤ and ≥) to hold even in the presence of strange types. Turning only one operator of every such pair into customisation points makes it essentially impossible to break that law.<br></p><p>Secondly, because we want to minimise the surface area of Comparable to keep the API as simple as possible. The drawback of my design is that while it manages to alleviate many subtleties of IEEE-754, it also contains many member functions (essentially all but `&lt;=&gt;`) which should not be customised for most types in practice.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/671b0168/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>July 25, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Pyry —<br></p><p>Dave and I spent some time discussing the details of how this applies to floating point earlier today.  We’re now in agreement that &lt;=&gt; should treat -0 and +0 as distinct, and treat all NaNs as .equal.  There are three motivating considerations:<br></p><p>1. Although -0 and +0 are “IEEE 754 equal”, there is no computation that can produce both of them.  In the parlance of IEEE 754, for any rounding mode, the sets of real values that round to them are disjoint.  Because of this, if -0 and +0 appear as members of a set, or as keys in a dictionary, they necessarily are the result of distinct computations or data.<br></p><p>2. Substitutability.  Adopting these semantics means that if `x &lt;=&gt; y` is `.equal`, `f(x) &lt;=&gt; f(y)` is also `.equal` for any computation `f(x)` that depends on the represented value (as opposed to the encoding) of its argument.<br></p><p>3. 754 defines four “specification levels”, or models:<br></p><p>	- Level 1: The two-point compactification of the reals, or “extended real numbers”.<br>	- Level 2: The set of representable floating-point data: {-inf … -0} union { 0 … inf } union { NaN }.<br>	- Level 3: The set of representations of floating-point data: sign-exponent-significand triples, +/-inf, qNaN, sNaN.<br>	- Level 4: Floating-point encodings (bit patterns).<br></p><p>The `&lt;=&gt;` semantics we propose constitute a total order on level 2, which is the computable model closest to the (reasonably familiar) extended real numbers.  Treating -0 and +0 as .equal would put us in a bit of a no-man’s land between levels 1 and 2.<br></p><p>Thanks,<br>– Steve<br></p><p>&gt; On Jul 25, 2016, at 7:41 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt; <br>&gt; Since we&#39;re running short on time, and the previous discussion thread diverged, here&#39;s my attempt to fix the Comparable protocol.<br>&gt; <br>&gt; Pull request: https://github.com/apple/swift-evolution/pull/464 &lt;https://github.com/apple/swift-evolution/pull/464&gt;<br>&gt; <br>&gt; TL;DR:<br>&gt; <br>&gt; 1. Equatable remains unchanged, while Comparable bloats a bit to support several use cases.<br>&gt; 2. `a &lt;=&gt; b` is well-defined even if either value is NaN. Zero is equal to minus zero.<br>&gt; 3. Types are not strictly required to become totally ordered, even if it&#39;s strongly recommended.<br>&gt; <br>&gt; — — —<br>&gt; <br>&gt; I simply can&#39;t see how a pure total order version of Comparable would fit the standard way floating point values are expected to behave. However, I think we can reach a satisfactory conclusion, one that involves no crashing in the standard library, which is what I previously suggested.<br>&gt; <br>&gt; What I&#39;m trying to fix is so that all operations listed in https://dl.dropboxusercontent.com/u/217402/Comparable.pdf &lt;https://dl.dropboxusercontent.com/u/217402/Comparable.pdf&gt; abide to laws for types without incomparable values, and that types with weaker order can still work in some well-defined way outside their totally ordered range.<br>&gt; <br>&gt; PS. Forgive me Robert, Jaden, and Harlan for not syncing with you, for time is tight. I can pull back or revise the proposal if you don&#39;t want to be involved.<br>&gt; <br>&gt; — Pyry<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; Formalized Ordering<br>&gt; <br>&gt; Proposal: SE-NNNN &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-filename.md&gt;<br>&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Jaden Geller &lt;https://github.com/jadengeller&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, Pyry Jahkola &lt;https://github.com/pyrtsa&gt;<br>&gt; Status: Awaiting review<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal cleans up the semantics of ordering relations in the standard library. Our goal is to formalize the total ordering semantics of the Comparable protocol and still provide accessible ordering definitions for types without total ordering semantics.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#motivation&gt;Motivation<br>&gt; <br>&gt; The standard comparison operators have an intuitive meaning to programmers. Swift encourages encoding that in an implementation of Comparable that respects the rules of a total order &lt;https://en.wikipedia.org/wiki/Total_order&gt;. The standard library takes advantage of these rules to provide consistent implementations for sorting and searching generic collections of Comparable types.<br>&gt; <br>&gt; Not all types behave so well in this framework, unfortunately. There are cases where the semantics of a total order cannot apply and still maintain the traditional definition of “comparison” over these types. Take, for example, sorting an array of Float s. Today, Float ‘s instance of Comparable follows IEEE-754 and returns false for all comparisons of NaN . In order to sort this array, NaN s are considered outside the domain of &lt; , and the order of a “sorted” array containing them is undefined.<br>&gt; <br>&gt; In addition, generic algorithms in the Swift Standard Library that make use of the current Comparable protocol may have to make twice as many comparisons to request the ordering of values with respect to each other than they should. Having a central operation to return information about the ordering of values once should provide a speedup for these operations.<br>&gt; <br>&gt; In the interest of cleaning up the semantics of Comparable types of all shapes and sizes and their uses in the Swift Standard Library, this proposal is going to re-arrange the requirements of the Comparable and Equatable protocols.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#proposed-solution&gt;Proposed solution<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#equatable&gt;Equatable<br>&gt; <br>&gt; The interface of Equatable remains unchanged under this proposal. Equatable types should still respect the equivalence laws of reflexivity (a == a), symmetry (a == b iff b == a), and transitivity (if a == b and b == c, then a == c). Further, != remains a top-level binary operator for which a != b iff !(a == b).<br>&gt; <br>&gt; Types containing properties inessential to equality, however, are allowed to retain their notion of identity. For example Array&#39;s capacity isn&#39;t considered for equality; and -0.0 == 0.0 and &quot;ä&quot; == &quot;a\u{308}&quot;, while (-0.0).sign != (0.0).sign and &quot;ä&quot;.utf8.count != &quot;a\u{308}&quot;.utf8.count.<br>&gt; <br>&gt; IEEE-754 floating point numbers are allowed to break the reflexivity law by defining that .nan != x for any value of x, which is the standard behaviour documented in IEEE-754 and implemented the same way in other programming languages.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#comparable&gt;Comparable<br>&gt; <br>&gt; The Comparable protocol will now require (without default implementation provided) a single operator definition: &lt;=&gt; — the comparison operator. From this, all other comparison operators will be derived so as to respect the total order semantics of Comparable:<br>&gt; <br>&gt; To maintain compatibility with IEEE-754, the interface of Comparable also contains as customization points the operators &lt;, &lt;=, and == (derived from Equatable) as well as the static binary functions _min(_:_:) and _max(_:_:). User-defined types are recommended against overriding the default implementations.<br>&gt; <br>&gt; The uncustomizable top-level binary comparison operators a &gt; b and a &gt;= b are implemented as synonyms to b &lt; aand b &lt;= a, respectively.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#standard-library&gt;Standard Library<br>&gt; <br>&gt; Unlike a previous revision of this proposal, standard library algorithms specific to FloatingPoint remain unchanged.<br>&gt; <br>&gt; Overloads of &lt;=&gt; for tuples of Comparable elements are provided up to a library-defined arity.<br>&gt; <br>&gt; The intent of this proposal is to later augment the standard library so that functions that take an ordering predicate by: (T, T) -&gt; Bool will have an overload ordering: (T, T) -&gt; Ordering that will provide a — potentially — more efficient implementation. A list of such functions is provided in Future directions.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#detailed-design&gt;Detailed design<br>&gt; <br>&gt; The Comparable protocol will be amended by taking away &gt; and &gt;=, adding customisation points _min(_:_:), and _max(_:_:), and introducing the ordering operator &lt;=&gt; that makes use of the Ordering enum defined below.<br>&gt; <br>&gt; enum Ordering : Equatable {<br>&gt;   case ascending<br>&gt;   case equal<br>&gt;   case descending<br>&gt; }<br>&gt; <br>&gt; infix operator &lt;=&gt; { associativity none precedence 130 }<br>&gt; <br>&gt; public protocol Comparable : Equatable {<br>&gt;   // Implementation required:<br>&gt;   static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt; <br>&gt;   // Default implementations provided:<br>&gt;   static func == (lhs: Self, rhs: Self) -&gt; Bool // derived from Equatable<br>&gt;   static func &lt;  (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   static func _min(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;   static func _max(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt; }<br>&gt; The &lt;=&gt; operator defines a relationship between == and &lt;=&gt; such that a == b iff (a &lt;=&gt; b) == .equal, unless Self chooses to break the semantics in the way of IEEE-754. Likewise, it should hold that (a &lt;=&gt; b) == .ascending iff a &lt; b, and (a &lt;=&gt; b) != .descending iff a &lt;= b.<br>&gt; <br>&gt; The _min(_:_:) and _max(_:_:) functions should return the lesser or greater of the two operands, respectively, while in case of equal arguments, _min(_:_:) should favour the left-hand side and _max(_:_:) the right-hand side to retain identity, as presently explained in this comment &lt;https://github.com/apple/swift/blob/4614adc16168d612b6fc7e7a161dd5b6b34be704/stdlib/public/core/Algorithm.swift#L17-L20&gt;. Making them customization points of Comparable, we get to fix their behaviour in the presense of unorderable values (SR-1011 &lt;https://bugs.swift.org/browse/SR-1011&gt;).<br>&gt; <br>&gt; Most user types should only implement &lt;=&gt; and leave the other members of Equatable and Comparable to their default implementations. Note that even == has a sane default implementation if Self is made Comparable:<br>&gt; <br>&gt; // Default implementations, which should be used for most Comparable types:<br>&gt; extension Comparable {<br>&gt;   static func == (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .equal }<br>&gt;   static func &lt;  (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .ascending }<br>&gt;   static func &lt;= (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) != .descending }<br>&gt;   static func _min(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? r : l }<br>&gt;   static func _max(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? l : r }<br>&gt; }<br>&gt; <br>&gt; // Unoverridable top-level operators and functions for Comparable:<br>&gt; public func &gt;  &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt; l }<br>&gt; public func &gt;= &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt;= l }<br>&gt; public func min&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._min(l, r) }<br>&gt; public func max&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._max(l, r) }<br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#handling-of-floating-point-comparisons&gt;Handling of floating point comparisons<br>&gt; <br>&gt; The following text is written in terms of Double but other floating-point types (Float, Float80) are proposed the same treatment.<br>&gt; <br>&gt; The IEEE-754 floating point specification has two oddities when it comes to orderability: there are two zeros (0.0 and -0.0) which are considered equal to each other, and there are multiple not-a-number values x for which x.isNaN == true and x != y with any value of y, even x itself. (Remark: the most common NaN value is obtained by the static property Double.nan.)<br>&gt; <br>&gt; The interface of Comparable is designed so that &lt;=&gt; alone is able to produce a total order among all possible Doublevalues, sorting negative NaNs less than any other values, and positive NaNs greater than any other. Otherwise, within the range of totally ordered floating point values, -Double.infinity ... Double.infinity, the result of a &lt;=&gt; b remains in full agreement with the laws of a &lt; b, a &lt;= b, and a == b.<br>&gt; <br>&gt; The suggested implementation of Double : Comparable makes &lt;=&gt; distinguish between every different bitPatternof NaN:<br>&gt; <br>&gt; extension Double : Comparable {<br>&gt;   public static func &lt;=&gt; (l: Double, r: Double) -&gt; Ordering {<br>&gt;     func ordinal(_ x: UInt64) -&gt; UInt64 {<br>&gt;       return x &lt; 0x80000000_00000000 ? x + 0x7fffffff_ffffffff : ~x<br>&gt;     }<br>&gt;     return ordinal(l.bitPattern) &lt;=&gt; ordinal(r.bitPattern)<br>&gt;   }<br>&gt;   public static func == (l: Double, r: Double) -&gt; Bool { return Builtin.eq(l, r) }<br>&gt;   public static func &lt;  (l: Double, r: Double) -&gt; Bool { return Builtin.lt(l, r) }<br>&gt;   public static func &lt;= (l: Double, r: Double) -&gt; Bool { return Builtin.le(l, r) }<br>&gt;   public static func _min(l: Double, r: Double) -&gt; Double { return Builtin.fmin(l, r) }<br>&gt;   public static func _max(l: Double, r: Double) -&gt; Double { return Builtin.fmax(l, r) }<br>&gt; }<br>&gt; <br>&gt; // Likewise:<br>&gt; extension Float : Comparable { ... }<br>&gt; extension Float80 : Comparable { ... }<br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#tuples-and-order-reversal&gt;Tuples and order reversal<br>&gt; <br>&gt; Due to missing language support, tuples of Comparable elements cannot be Comparable themselves, but in the spirit of SE-0015 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;, such tuples are given their overloads of &lt;=&gt; up to a standard library defined maximum arity:<br>&gt; <br>&gt; public func &lt;=&gt; &lt;A : Comparable, B : Comparable&gt;(lhs: (A, B), rhs: (A, B)) -&gt; Ordering {<br>&gt;   let a = lhs.0 &lt;=&gt; rhs.0<br>&gt;   if a != .equal { return a }<br>&gt;   let b = lhs.1 &lt;=&gt; rhs.1<br>&gt;   if b != .equal { return b }<br>&gt;   return .equal<br>&gt; }<br>&gt; <br>&gt; // Similarly for &lt;A : Comparable, B : Comparable, C : Comparable&gt;, etc.<br>&gt; To simplify the reversal of a given ordering operation, two members of Ordering are provided in an extension:<br>&gt; <br>&gt; extension Ordering {<br>&gt;   public static func reversing&lt;T : Comparable&gt;(_ ordering: (T, T) -&gt; Ordering)<br>&gt;     -&gt; (T, T) -&gt; Ordering<br>&gt;   {<br>&gt;     return { l, r in ordering(r, l) }<br>&gt;   }<br>&gt; <br>&gt;   public var reversed: Ordering {<br>&gt;     switch self {<br>&gt;     case .ascending:  return .descending<br>&gt;     case .equal:      return .equal<br>&gt;     case .descending: return .ascending<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#foundation&gt;Foundation<br>&gt; <br>&gt; In addition, Foundation code will now bridge NSComparisonResult to Ordering allowing for a fluid, natural, and safe API.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#impact-on-existing-code&gt;Impact on existing code<br>&gt; <br>&gt; The biggest drawback of the proposed design is the large surface area of Comparable&#39;s interface, as well as the possibility of overriding the comparison operators by mistake. On the other hand, since the required &lt;=&gt; operator is new and affects all users porting their previously Comparable data types to Swift 3, we can use documentation to suggest removing the redundant (and possibly faulty) implementations of other comparison operators.<br>&gt; <br>&gt; Existing Equatable but not Comparable types that define an equivalence relation with == will remain unchanged.<br>&gt; <br>&gt; Existing Comparable types that define a total ordering with &lt; will need to implement &lt;=&gt; and should remove their existing implementation of any comparison operators, including ==. All other existing Comparable types should implement &lt;=&gt; that provides a total ordering, or should drop their Comparable conformance.<br>&gt; <br>&gt; Before:<br>&gt; <br>&gt; struct Date: Comparable {<br>&gt;   let year: Int<br>&gt;   let month: Int<br>&gt;   let day: Int<br>&gt; }<br>&gt; <br>&gt; func ==(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;   return lhs.year == rhs.year<br>&gt;     &amp;&amp; lhs.month == rhs.month<br>&gt;     &amp;&amp; lhs.day == rhs.day<br>&gt; }<br>&gt; <br>&gt; func &lt;(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;   if lhs.year != rhs.year {<br>&gt;     return lhs.year &lt; rhs.year<br>&gt;   } else if lhs.month != rhs.month {<br>&gt;     return lhs.month &lt; rhs.month<br>&gt;   } else {<br>&gt;     return lhs.day &lt; rhs.day<br>&gt;   }<br>&gt; }<br>&gt; After, using the tuple overload of &lt;=&gt;:<br>&gt; <br>&gt; struct Date: Comparable {<br>&gt;   let year: Int<br>&gt;   let month: Int<br>&gt;   let day: Int<br>&gt; <br>&gt;   static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;     return (lhs.year, lhs.month, lhs.day)<br>&gt;        &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>&gt;   }<br>&gt; <br>&gt;   // // Explicit version:<br>&gt;   // static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;   //   let yearResult = lhs.year &lt;=&gt; rhs.year<br>&gt;   //   guard case .equal = yearResult else { return yearResult }<br>&gt;   //   let monthResult = lhs.month &lt;=&gt; rhs.month<br>&gt;   //   guard case .equal = monthResult else { return monthResult }<br>&gt;   //   return lhs.day &lt;=&gt; rhs.day<br>&gt;   // }<br>&gt; }<br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#alternatives-considered&gt;Alternatives considered<br>&gt; <br>&gt; A previous design of this proposal suggested a strict total order upon Comparable. While that would make generic algorithms more correct, the definition ended up fighting against the expected behaviour of floating point numbers.<br>&gt; <br>&gt; An alternative design that better matches the existing arithmetic-related protocols in Swift is one that uses a member function.<br>&gt; <br>&gt; public protocol Comparable: Equatable {<br>&gt;   func compare(to: Self) -&gt; Ordering<br>&gt; }<br>&gt; However, while this API does read better than an operator, we believe that this imposes a number of artificial restrictions (especially in light of SE-0091 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;)<br>&gt; <br>&gt; There is no way to use Comparable.compare as a higher-order function in a non-generic context.<br>&gt; If a member is desired, it can be provided in a protocol extension and defined in terms of the ordering operator; to each according to their need.<br>&gt; The existing tuple overloads cannot be expressed with a member function.<br>&gt; One other that Rust has adopted is the inclusion of PartialEquatable and PartialComparable as ancestors of their flavor of Equatable and Comparable . Having protocols to organize and catalogue types that can only guarantee partial equivalence and ordering relations is a good approach for modularity but clutters the standard library with two new protocols for which few useful algorithms could be written against.<br>&gt; <br>&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#future-directions&gt;Future directions<br>&gt; <br>&gt; That the default sort() compares by &lt; and not &lt;=&gt; should be considered a bug to be fixed in a future version of Swift. Using &lt;=&gt; will make sort() well-behaved in the presense of NaN. However, given that the current behaviour is to produce an unspecified order, the fix is additive and can be slipped past Swift 3.<br>&gt; <br>&gt; With &lt;=&gt; in place, several present and future standard library algorithms involving a &lt;T : Comparable&gt; requirement will possibly benefit from knowing the total ordering of two operands at once. This is a list of possible such functions (taking Array as example), to be proposed separately as an additive change:<br>&gt; <br>&gt; extension Array {<br>&gt;   // Sorting<br>&gt; <br>&gt;   mutating func sort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;   func sorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;   mutating func stableSort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;   func stableSorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt; <br>&gt;   /// Reorders the elements of the collection such that all the elements<br>&gt;   /// returning `.ascending` are moved to the start of the collection, and the<br>&gt;   /// elements returning `.descending` are moved to the end of the collection.<br>&gt;   /// - Returns: the range of elements for which `ordering(x) == .equal`.<br>&gt;   mutating func partition(ordering: @noescape (Iterator.Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt; <br>&gt;   // Binary search<br>&gt; <br>&gt;   func bisectedIndex(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index?<br>&gt;   func lowerBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;   func upperBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;   func equalRange(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt; }<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/f7a73c3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 25, 2016 at 02:00:00pm</p></header><div class="content"><p>Pyry, this proposal looks great to me. My one question is, will I be able<br>to write `someCollection.sort(.ascending)` and get the expected<br>result? (This could be an additive future direction.)<br></p><p><br>Stephen, what is your rationale for wanting `&lt;=&gt;` to identify NaN values<br>with different payloads as `.equal`?<br></p><p>I believe the IEEE 754 total order specification uses the bit-pattern just<br>as Pyry’s proposal does, and there is value is adhering to the standard.<br>Besides, if someone intentionally wishes to consider all NaN values as<br>equivalent they can use `.isNaN` (or even map them to .nan first for<br>uniformity).<br></p><p>Nevin<br></p><p><br>On Mon, Jul 25, 2016 at 1:26 PM, Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Pyry —<br>&gt;<br>&gt; Dave and I spent some time discussing the details of how this applies to<br>&gt; floating point earlier today.  We’re now in agreement that &lt;=&gt; should treat<br>&gt; -0 and +0 as distinct, and treat all NaNs as .equal.  There are three<br>&gt; motivating considerations:<br>&gt;<br>&gt; 1. Although -0 and +0 are “IEEE 754 equal”, there is no computation that<br>&gt; can produce both of them.  In the parlance of IEEE 754, for any rounding<br>&gt; mode, the sets of real values that round to them are disjoint.  Because of<br>&gt; this, if -0 and +0 appear as members of a set, or as keys in a dictionary,<br>&gt; they necessarily are the result of distinct computations or data.<br>&gt;<br>&gt; 2. Substitutability.  Adopting these semantics means that if `x &lt;=&gt; y` is<br>&gt; `.equal`, `f(x) &lt;=&gt; f(y)` is also `.equal` for any computation `f(x)` that<br>&gt; depends on the represented value (as opposed to the encoding) of its<br>&gt; argument.<br>&gt;<br>&gt; 3. 754 defines four “specification levels”, or models:<br>&gt;<br>&gt; - Level 1: The two-point compactification of the reals, or “extended real<br>&gt; numbers”.<br>&gt; - Level 2: The set of representable floating-point data: {-inf … -0} union<br>&gt; { 0 … inf } union { NaN }.<br>&gt; - Level 3: The set of representations of floating-point data:<br>&gt; sign-exponent-significand triples, +/-inf, qNaN, sNaN.<br>&gt; - Level 4: Floating-point encodings (bit patterns).<br>&gt;<br>&gt; The `&lt;=&gt;` semantics we propose constitute a total order on level 2, which<br>&gt; is the computable model closest to the (reasonably familiar) extended real<br>&gt; numbers.  Treating -0 and +0 as .equal would put us in a bit of a no-man’s<br>&gt; land between levels 1 and 2.<br>&gt;<br>&gt; Thanks,<br>&gt; – Steve<br>&gt;<br>&gt; On Jul 25, 2016, at 7:41 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;<br>&gt; Since we&#39;re running short on time, and the previous discussion thread<br>&gt; diverged, here&#39;s my attempt to fix the Comparable protocol.<br>&gt;<br>&gt; *Pull request:* https://github.com/apple/swift-evolution/pull/464<br>&gt;<br>&gt; TL;DR:<br>&gt;<br>&gt; 1. Equatable remains unchanged, while Comparable bloats a bit to support<br>&gt; several use cases.<br>&gt; 2. `a &lt;=&gt; b` is well-defined even if either value is NaN. Zero is equal to<br>&gt; minus zero.<br>&gt; 3. Types are not strictly required to become totally ordered, even if it&#39;s<br>&gt; strongly recommended.<br>&gt;<br>&gt; — — —<br>&gt;<br>&gt; I simply can&#39;t see how a pure total order version of Comparable would fit<br>&gt; the standard way floating point values are expected to behave. However, I<br>&gt; think we can reach a satisfactory conclusion, one that involves no crashing<br>&gt; in the standard library, which is what I previously suggested.<br>&gt;<br>&gt; What I&#39;m trying to fix is so that all operations listed in<br>&gt; https://dl.dropboxusercontent.com/u/217402/Comparable.pdf abide to laws<br>&gt; for types without incomparable values, and that types with weaker order can<br>&gt; still work in *some* well-defined way outside their totally ordered range.<br>&gt;<br>&gt; PS. Forgive me Robert, Jaden, and Harlan for not syncing with you, for<br>&gt; time is tight. I can pull back or revise the proposal if you don&#39;t want to<br>&gt; be involved.<br>&gt;<br>&gt; — Pyry<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Formalized Ordering<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-filename.md&gt;<br>&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Jaden Geller<br>&gt;    &lt;https://github.com/jadengeller&gt;, Harlan Haskins<br>&gt;    &lt;https://github.com/harlanhaskins&gt;, Pyry Jahkola<br>&gt;    &lt;https://github.com/pyrtsa&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal cleans up the semantics of ordering relations in the<br>&gt; standard library. Our goal is to formalize the total ordering semantics of<br>&gt; the Comparable protocol and still provide accessible ordering definitions<br>&gt; for types without total ordering semantics.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; The standard comparison operators have an intuitive meaning to<br>&gt; programmers. Swift encourages encoding that in an implementation of<br>&gt; Comparable that respects the rules of a total order<br>&gt; &lt;https://en.wikipedia.org/wiki/Total_order&gt;. The standard library takes<br>&gt; advantage of these rules to provide consistent implementations for sorting<br>&gt; and searching generic collections of Comparable types.<br>&gt;<br>&gt; Not all types behave so well in this framework, unfortunately. There are<br>&gt; cases where the semantics of a total order cannot apply and still maintain<br>&gt; the traditional definition of “comparison” over these types. Take, for<br>&gt; example, sorting an array of Float s. Today, Float ‘s instance of<br>&gt; Comparable follows IEEE-754 and returns false for all comparisons of NaN .<br>&gt; In order to sort this array, NaN s are considered outside the domain of &lt; ,<br>&gt; and the order of a “sorted” array containing them is undefined.<br>&gt;<br>&gt; In addition, generic algorithms in the Swift Standard Library that make<br>&gt; use of the current Comparable protocol may have to make twice as many<br>&gt; comparisons to request the ordering of values with respect to each other<br>&gt; than they should. Having a central operation to return information about<br>&gt; the ordering of values once should provide a speedup for these operations.<br>&gt;<br>&gt; In the interest of cleaning up the semantics of Comparable types of all<br>&gt; shapes and sizes and their uses in the Swift Standard Library, this<br>&gt; proposal is going to re-arrange the requirements of the Comparable and<br>&gt; Equatable protocols.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#equatable&gt;<br>&gt; Equatable<br>&gt;<br>&gt; The interface of Equatable remains unchanged under this proposal.<br>&gt; Equatable types should still respect the equivalence laws of *reflexivity*<br>&gt;  (a == a), *symmetry* (a == b iff b == a), and *transitivity* (if a == b<br>&gt;  and b == c, then a == c). Further, != remains a top-level binary<br>&gt; operator for which a != b iff !(a == b).<br>&gt;<br>&gt; Types containing properties *inessential to equality*, however, are<br>&gt; allowed to retain their notion of identity. For example Array&#39;s capacity isn&#39;t<br>&gt; considered for equality; and -0.0 == 0.0 and &quot;ä&quot; == &quot;a\u{308}&quot;, while (-0.0).sign<br>&gt; != (0.0).sign and &quot;ä&quot;.utf8.count != &quot;a\u{308}&quot;.utf8.count.<br>&gt;<br>&gt; IEEE-754 floating point numbers are allowed to break the reflexivity law<br>&gt; by defining that .nan != x for any value of x, which is the standard<br>&gt; behaviour documented in IEEE-754 and implemented the same way in other<br>&gt; programming languages.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#comparable&gt;<br>&gt; Comparable<br>&gt;<br>&gt; The Comparable protocol will now require (without default implementation<br>&gt; provided) a single operator definition: &lt;=&gt; — the comparison operator.<br>&gt; From this, all other comparison operators will be derived so as to respect<br>&gt; the total order semantics of Comparable:<br>&gt;<br>&gt; To maintain compatibility with IEEE-754, the interface of Comparable also<br>&gt; contains as customization points the operators &lt;, &lt;=, and == (derived<br>&gt; from Equatable) as well as the static binary functions _min(_:_:) and<br>&gt; _max(_:_:). User-defined types are recommended against overriding the<br>&gt; default implementations.<br>&gt;<br>&gt; The uncustomizable top-level binary comparison operators a &gt; b and a &gt;= b are<br>&gt; implemented as synonyms to b &lt; aand b &lt;= a, respectively.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#standard-library&gt;Standard<br>&gt; Library<br>&gt;<br>&gt; Unlike a previous revision of this proposal, standard library algorithms<br>&gt; specific to FloatingPoint remain unchanged.<br>&gt;<br>&gt; Overloads of &lt;=&gt; for tuples of Comparable elements are provided up to a<br>&gt; library-defined arity.<br>&gt;<br>&gt; The intent of this proposal is to later augment the standard library so<br>&gt; that functions that take an ordering predicate by: (T, T) -&gt; Bool will<br>&gt; have an overload ordering: (T, T) -&gt; Ordering that will provide a —<br>&gt; potentially — more efficient implementation. A list of such functions is<br>&gt; provided in Future directions.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The Comparable protocol will be amended by taking away &gt; and &gt;=, adding<br>&gt; customisation points _min(_:_:), and _max(_:_:), and introducing the<br>&gt; ordering operator &lt;=&gt; that makes use of the Ordering enum defined below.<br>&gt;<br>&gt; enum Ordering : Equatable {<br>&gt;   case ascending<br>&gt;   case equal<br>&gt;   case descending<br>&gt; }<br>&gt; infix operator &lt;=&gt; { associativity none precedence 130 }<br>&gt; public protocol Comparable : Equatable {<br>&gt;   // Implementation required:<br>&gt;   static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;<br>&gt;   // Default implementations provided:<br>&gt;   static func == (lhs: Self, rhs: Self) -&gt; Bool // derived from Equatable<br>&gt;   static func &lt;  (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;   static func _min(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;   static func _max(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt; }<br>&gt;<br>&gt; The &lt;=&gt; operator defines a relationship between == and &lt;=&gt; such that a ==<br>&gt; b iff (a &lt;=&gt; b) == .equal, unless Self chooses to break the semantics in<br>&gt; the way of IEEE-754. Likewise, it should hold that (a &lt;=&gt; b) == .ascending<br>&gt;  iff a &lt; b, and (a &lt;=&gt; b) != .descending iff a &lt;= b.<br>&gt;<br>&gt; The _min(_:_:) and _max(_:_:) functions should return the lesser or<br>&gt; greater of the two operands, respectively, while in case of equal<br>&gt; arguments, _min(_:_:) should favour the left-hand side and _max(_:_:) the<br>&gt; right-hand side to retain identity, as presently explained in this comment<br>&gt; &lt;https://github.com/apple/swift/blob/4614adc16168d612b6fc7e7a161dd5b6b34be704/stdlib/public/core/Algorithm.swift#L17-L20&gt;.<br>&gt; Making them customization points of Comparable, we get to fix their<br>&gt; behaviour in the presense of unorderable values (SR-1011<br>&gt; &lt;https://bugs.swift.org/browse/SR-1011&gt;).<br>&gt;<br>&gt; Most user types should only implement &lt;=&gt; and leave the other members of<br>&gt; Equatable and Comparable to their default implementations. Note that even<br>&gt; == has a sane default implementation if Self is made Comparable:<br>&gt;<br>&gt; // Default implementations, which should be used for most Comparable types:extension Comparable {<br>&gt;   static func == (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .equal }<br>&gt;   static func &lt;  (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .ascending }<br>&gt;   static func &lt;= (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) != .descending }<br>&gt;   static func _min(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? r : l }<br>&gt;   static func _max(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? l : r }<br>&gt; }<br>&gt; // Unoverridable top-level operators and functions for Comparable:public func &gt;  &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt; l }public func &gt;= &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt;= l }public func min&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._min(l, r) }public func max&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._max(l, r) }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#handling-of-floating-point-comparisons&gt;Handling<br>&gt; of floating point comparisons<br>&gt;<br>&gt; *The following text is written in terms of Double but other floating-point<br>&gt; types (Float, Float80) are proposed the same treatment.*<br>&gt;<br>&gt; The IEEE-754 floating point specification has two oddities when it comes<br>&gt; to orderability: there are two zeros (0.0 and -0.0) which are considered<br>&gt; equal to each other, and there are *multiple* not-a-number values x for<br>&gt; which x.isNaN == true and x != y with any value of y, even x itself.<br>&gt; (Remark: the most common NaN value is obtained by the static property<br>&gt; Double.nan.)<br>&gt;<br>&gt; The interface of Comparable is designed so that &lt;=&gt; alone is able to<br>&gt; produce a total order among all possible Doublevalues, sorting negative<br>&gt; NaNs less than any other values, and positive NaNs greater than any other.<br>&gt; Otherwise, within the range of totally ordered floating point values, -Double.infinity<br>&gt; ... Double.infinity, the result of a &lt;=&gt; b remains in full agreement with<br>&gt; the laws of a &lt; b, a &lt;= b, and a == b.<br>&gt;<br>&gt; The suggested implementation of Double : Comparable makes &lt;=&gt; distinguish<br>&gt; between every different bitPatternof NaN:<br>&gt;<br>&gt; extension Double : Comparable {<br>&gt;   public static func &lt;=&gt; (l: Double, r: Double) -&gt; Ordering {<br>&gt;     func ordinal(_ x: UInt64) -&gt; UInt64 {<br>&gt;       return x &lt; 0x80000000_00000000 ? x + 0x7fffffff_ffffffff : ~x<br>&gt;     }<br>&gt;     return ordinal(l.bitPattern) &lt;=&gt; ordinal(r.bitPattern)<br>&gt;   }<br>&gt;   public static func == (l: Double, r: Double) -&gt; Bool { return Builtin.eq(l, r) }<br>&gt;   public static func &lt;  (l: Double, r: Double) -&gt; Bool { return Builtin.lt(l, r) }<br>&gt;   public static func &lt;= (l: Double, r: Double) -&gt; Bool { return Builtin.le(l, r) }<br>&gt;   public static func _min(l: Double, r: Double) -&gt; Double { return Builtin.fmin(l, r) }<br>&gt;   public static func _max(l: Double, r: Double) -&gt; Double { return Builtin.fmax(l, r) }<br>&gt; }<br>&gt; // Likewise:extension Float : Comparable { ... }extension Float80 : Comparable { ... }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#tuples-and-order-reversal&gt;Tuples<br>&gt; and order reversal<br>&gt;<br>&gt; Due to missing language support, tuples of Comparable elements cannot be<br>&gt; Comparable themselves, but in the spirit of SE-0015<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;,<br>&gt; such tuples are given their overloads of &lt;=&gt; up to a standard library<br>&gt; defined maximum arity:<br>&gt;<br>&gt; public func &lt;=&gt; &lt;A : Comparable, B : Comparable&gt;(lhs: (A, B), rhs: (A, B)) -&gt; Ordering {<br>&gt;   let a = lhs.0 &lt;=&gt; rhs.0<br>&gt;   if a != .equal { return a }<br>&gt;   let b = lhs.1 &lt;=&gt; rhs.1<br>&gt;   if b != .equal { return b }<br>&gt;   return .equal<br>&gt; }<br>&gt; // Similarly for &lt;A : Comparable, B : Comparable, C : Comparable&gt;, etc.<br>&gt;<br>&gt; To simplify the reversal of a given ordering operation, two members of<br>&gt; Ordering are provided in an extension:<br>&gt;<br>&gt; extension Ordering {<br>&gt;   public static func reversing&lt;T : Comparable&gt;(_ ordering: (T, T) -&gt; Ordering)<br>&gt;     -&gt; (T, T) -&gt; Ordering<br>&gt;   {<br>&gt;     return { l, r in ordering(r, l) }<br>&gt;   }<br>&gt;<br>&gt;   public var reversed: Ordering {<br>&gt;     switch self {<br>&gt;     case .ascending:  return .descending<br>&gt;     case .equal:      return .equal<br>&gt;     case .descending: return .ascending<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#foundation&gt;<br>&gt; Foundation<br>&gt;<br>&gt; In addition, Foundation code will now bridge NSComparisonResult to<br>&gt; Ordering allowing for a fluid, natural, and safe API.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; The biggest drawback of the proposed design is the large surface area of<br>&gt; Comparable&#39;s interface, as well as the possibility of overriding the<br>&gt; comparison operators by mistake. On the other hand, since the required &lt;=&gt; operator<br>&gt; is new and affects all users porting their previously Comparable data<br>&gt; types to Swift 3, we can use documentation to suggest removing the<br>&gt; redundant (and possibly faulty) implementations of other comparison<br>&gt; operators.<br>&gt;<br>&gt; Existing Equatable but not Comparable types that define an equivalence<br>&gt; relation with == will remain unchanged.<br>&gt;<br>&gt; Existing Comparable types that define a total ordering with &lt; will need<br>&gt; to implement &lt;=&gt; and should remove their existing implementation of any<br>&gt; comparison operators, including ==. All other existing Comparable types<br>&gt; should implement &lt;=&gt; that provides a total ordering, or should drop their<br>&gt; Comparable conformance.<br>&gt;<br>&gt; Before:<br>&gt;<br>&gt; struct Date: Comparable {<br>&gt;   let year: Int<br>&gt;   let month: Int<br>&gt;   let day: Int<br>&gt; }<br>&gt; func ==(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;   return lhs.year == rhs.year<br>&gt;     &amp;&amp; lhs.month == rhs.month<br>&gt;     &amp;&amp; lhs.day == rhs.day<br>&gt; }<br>&gt; func &lt;(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;   if lhs.year != rhs.year {<br>&gt;     return lhs.year &lt; rhs.year<br>&gt;   } else if lhs.month != rhs.month {<br>&gt;     return lhs.month &lt; rhs.month<br>&gt;   } else {<br>&gt;     return lhs.day &lt; rhs.day<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; After, using the tuple overload of &lt;=&gt;:<br>&gt;<br>&gt; struct Date: Comparable {<br>&gt;   let year: Int<br>&gt;   let month: Int<br>&gt;   let day: Int<br>&gt;<br>&gt;   static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;     return (lhs.year, lhs.month, lhs.day)<br>&gt;        &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>&gt;   }<br>&gt;<br>&gt;   // // Explicit version:<br>&gt;   // static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;   //   let yearResult = lhs.year &lt;=&gt; rhs.year<br>&gt;   //   guard case .equal = yearResult else { return yearResult }<br>&gt;   //   let monthResult = lhs.month &lt;=&gt; rhs.month<br>&gt;   //   guard case .equal = monthResult else { return monthResult }<br>&gt;   //   return lhs.day &lt;=&gt; rhs.day<br>&gt;   // }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt;<br>&gt; A previous design of this proposal suggested a strict total order upon<br>&gt; Comparable. While that would make generic algorithms more correct, the<br>&gt; definition ended up fighting against the expected behaviour of floating<br>&gt; point numbers.<br>&gt;<br>&gt; An alternative design that better matches the existing arithmetic-related<br>&gt; protocols in Swift is one that uses a member function.<br>&gt;<br>&gt; public protocol Comparable: Equatable {<br>&gt;   func compare(to: Self) -&gt; Ordering<br>&gt; }<br>&gt;<br>&gt; However, while this API does read better than an operator, we believe that<br>&gt; this imposes a number of artificial restrictions (especially in light of<br>&gt; SE-0091<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;<br>&gt; )<br>&gt;<br>&gt;    1. There is no way to use Comparable.compare as a higher-order<br>&gt;    function in a non-generic context.<br>&gt;    2. If a member is desired, it can be provided in a protocol extension<br>&gt;    and defined in terms of the ordering operator; to each according to their<br>&gt;    need.<br>&gt;    3. The existing tuple overloads cannot be expressed with a member<br>&gt;    function.<br>&gt;<br>&gt; One other that Rust has adopted is the inclusion of PartialEquatable and<br>&gt; PartialComparable as ancestors of their flavor of Equatable and Comparable .<br>&gt; Having protocols to organize and catalogue types that can only guarantee<br>&gt; partial equivalence and ordering relations is a good approach for<br>&gt; modularity but clutters the standard library with two new protocols for<br>&gt; which few useful algorithms could be written against.<br>&gt;<br>&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#future-directions&gt;Future<br>&gt; directions<br>&gt;<br>&gt; That the default sort() compares by &lt; and not &lt;=&gt; should be considered a<br>&gt; bug to be fixed in a future version of Swift. Using &lt;=&gt; will make sort() well-behaved<br>&gt; in the presense of NaN. However, given that the current behaviour is to<br>&gt; produce an unspecified order, the fix is additive and can be slipped past<br>&gt; Swift 3.<br>&gt;<br>&gt; With &lt;=&gt; in place, several present and future standard library algorithms<br>&gt; involving a &lt;T : Comparable&gt; requirement will possibly benefit from<br>&gt; knowing the total ordering of two operands at once. This is a list of<br>&gt; possible such functions (taking Array as example), to be proposed<br>&gt; separately as an additive change:<br>&gt;<br>&gt; extension Array {<br>&gt;   // Sorting<br>&gt;<br>&gt;   mutating func sort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;   func sorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;   mutating func stableSort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;   func stableSorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;<br>&gt;   /// Reorders the elements of the collection such that all the elements<br>&gt;   /// returning `.ascending` are moved to the start of the collection, and the<br>&gt;   /// elements returning `.descending` are moved to the end of the collection.<br>&gt;   /// - Returns: the range of elements for which `ordering(x) == .equal`.<br>&gt;   mutating func partition(ordering: @noescape (Iterator.Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt;<br>&gt;   // Binary search<br>&gt;<br>&gt;   func bisectedIndex(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index?<br>&gt;   func lowerBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;   func upperBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;   func equalRange(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/dbca53aa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>July 25, 2016 at 02:00:00pm</p></header><div class="content"><p>First, this is orthogonal to &quot;adhering to the standard&quot;.  isTotallyOrdered( ) provides the total order predicate required by IEEE 754.  The standard has no opinion about whether or not `&lt;=&gt;` is bound to that predicate.<br></p><p>Personally, I would be OK with using the `isTotallyOrdered` semantics for `&lt;=&gt;`.  However, it leads to some behavior that would be surprising for novices: x is NaN, and a set S is { 1, 2, NaN }, but S does not contain x.  I am skeptical that the distinction between NaN payloads is salient *for generic code written on Comparable types*.  It *is* salient for some (rare!) floating-point specific code, but `isTotallyOrdered` is available for floating-point types.<br></p><p>There’s also the issue that if we want to be able to point at IEEE 754 and say “&lt;=&gt; implements a total order on Level N”, distinguishing distinct NaNs has consequences for other values.  In particular, it means that a decimal type should distinguish between 1e0 and 10e-1, because it would necessarily be an ordering on level 3 or 4.  For { 1, 20 } to not contain 2e1 seems highly dubious to me.<br></p><p>– Steve<br></p><p>&gt; On Jul 25, 2016, at 2:23 PM, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; Pyry, this proposal looks great to me. My one question is, will I be able to write `someCollection.sort(.ascending)` and get the expected result? (This could be an additive future direction.)<br>&gt; <br>&gt; Stephen, what is your rationale for wanting `&lt;=&gt;` to identify NaN values with different payloads as `.equal`?<br>&gt; <br>&gt; I believe the IEEE 754 total order specification uses the bit-pattern just as Pyry’s proposal does, and there is value is adhering to the standard. Besides, if someone intentionally wishes to consider all NaN values as equivalent they can use `.isNaN` (or even map them to .nan first for uniformity).<br>&gt; <br>&gt; Nevin<br>&gt; <br>&gt; <br>&gt; On Mon, Jul 25, 2016 at 1:26 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi Pyry —<br>&gt; <br>&gt; Dave and I spent some time discussing the details of how this applies to floating point earlier today.  We’re now in agreement that &lt;=&gt; should treat -0 and +0 as distinct, and treat all NaNs as .equal.  There are three motivating considerations:<br>&gt; <br>&gt; 1. Although -0 and +0 are “IEEE 754 equal”, there is no computation that can produce both of them.  In the parlance of IEEE 754, for any rounding mode, the sets of real values that round to them are disjoint.  Because of this, if -0 and +0 appear as members of a set, or as keys in a dictionary, they necessarily are the result of distinct computations or data.<br>&gt; <br>&gt; 2. Substitutability.  Adopting these semantics means that if `x &lt;=&gt; y` is `.equal`, `f(x) &lt;=&gt; f(y)` is also `.equal` for any computation `f(x)` that depends on the represented value (as opposed to the encoding) of its argument.<br>&gt; <br>&gt; 3. 754 defines four “specification levels”, or models:<br>&gt; <br>&gt; 	- Level 1: The two-point compactification of the reals, or “extended real numbers”.<br>&gt; 	- Level 2: The set of representable floating-point data: {-inf … -0} union { 0 … inf } union { NaN }.<br>&gt; 	- Level 3: The set of representations of floating-point data: sign-exponent-significand triples, +/-inf, qNaN, sNaN.<br>&gt; 	- Level 4: Floating-point encodings (bit patterns).<br>&gt; <br>&gt; The `&lt;=&gt;` semantics we propose constitute a total order on level 2, which is the computable model closest to the (reasonably familiar) extended real numbers.  Treating -0 and +0 as .equal would put us in a bit of a no-man’s land between levels 1 and 2.<br>&gt; <br>&gt; Thanks,<br>&gt; – Steve<br>&gt; <br>&gt;&gt; On Jul 25, 2016, at 7:41 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi &lt;mailto:pyry.jahkola at iki.fi&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since we&#39;re running short on time, and the previous discussion thread diverged, here&#39;s my attempt to fix the Comparable protocol.<br>&gt;&gt; <br>&gt;&gt; Pull request: https://github.com/apple/swift-evolution/pull/464 &lt;https://github.com/apple/swift-evolution/pull/464&gt;<br>&gt;&gt; <br>&gt;&gt; TL;DR:<br>&gt;&gt; <br>&gt;&gt; 1. Equatable remains unchanged, while Comparable bloats a bit to support several use cases.<br>&gt;&gt; 2. `a &lt;=&gt; b` is well-defined even if either value is NaN. Zero is equal to minus zero.<br>&gt;&gt; 3. Types are not strictly required to become totally ordered, even if it&#39;s strongly recommended.<br>&gt;&gt; <br>&gt;&gt; — — —<br>&gt;&gt; <br>&gt;&gt; I simply can&#39;t see how a pure total order version of Comparable would fit the standard way floating point values are expected to behave. However, I think we can reach a satisfactory conclusion, one that involves no crashing in the standard library, which is what I previously suggested.<br>&gt;&gt; <br>&gt;&gt; What I&#39;m trying to fix is so that all operations listed in https://dl.dropboxusercontent.com/u/217402/Comparable.pdf &lt;https://dl.dropboxusercontent.com/u/217402/Comparable.pdf&gt; abide to laws for types without incomparable values, and that types with weaker order can still work in some well-defined way outside their totally ordered range.<br>&gt;&gt; <br>&gt;&gt; PS. Forgive me Robert, Jaden, and Harlan for not syncing with you, for time is tight. I can pull back or revise the proposal if you don&#39;t want to be involved.<br>&gt;&gt; <br>&gt;&gt; — Pyry<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Formalized Ordering<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-filename.md&gt;<br>&gt;&gt; Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Jaden Geller &lt;https://github.com/jadengeller&gt;, Harlan Haskins &lt;https://github.com/harlanhaskins&gt;, Pyry Jahkola &lt;https://github.com/pyrtsa&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal cleans up the semantics of ordering relations in the standard library. Our goal is to formalize the total ordering semantics of the Comparable protocol and still provide accessible ordering definitions for types without total ordering semantics.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; The standard comparison operators have an intuitive meaning to programmers. Swift encourages encoding that in an implementation of Comparable that respects the rules of a total order &lt;https://en.wikipedia.org/wiki/Total_order&gt;. The standard library takes advantage of these rules to provide consistent implementations for sorting and searching generic collections of Comparable types.<br>&gt;&gt; <br>&gt;&gt; Not all types behave so well in this framework, unfortunately. There are cases where the semantics of a total order cannot apply and still maintain the traditional definition of “comparison” over these types. Take, for example, sorting an array of Float s. Today, Float ‘s instance of Comparable follows IEEE-754 and returns false for all comparisons of NaN . In order to sort this array, NaN s are considered outside the domain of &lt; , and the order of a “sorted” array containing them is undefined.<br>&gt;&gt; <br>&gt;&gt; In addition, generic algorithms in the Swift Standard Library that make use of the current Comparable protocol may have to make twice as many comparisons to request the ordering of values with respect to each other than they should. Having a central operation to return information about the ordering of values once should provide a speedup for these operations.<br>&gt;&gt; <br>&gt;&gt; In the interest of cleaning up the semantics of Comparable types of all shapes and sizes and their uses in the Swift Standard Library, this proposal is going to re-arrange the requirements of the Comparable and Equatable protocols.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#equatable&gt;Equatable<br>&gt;&gt; <br>&gt;&gt; The interface of Equatable remains unchanged under this proposal. Equatable types should still respect the equivalence laws of reflexivity (a == a), symmetry (a == b iff b == a), and transitivity (if a == b and b == c, then a == c). Further, != remains a top-level binary operator for which a != b iff !(a == b).<br>&gt;&gt; <br>&gt;&gt; Types containing properties inessential to equality, however, are allowed to retain their notion of identity. For example Array&#39;s capacity isn&#39;t considered for equality; and -0.0 == 0.0 and &quot;ä&quot; == &quot;a\u{308}&quot;, while (-0.0).sign != (0.0).sign and &quot;ä&quot;.utf8.count != &quot;a\u{308}&quot;.utf8.count.<br>&gt;&gt; <br>&gt;&gt; IEEE-754 floating point numbers are allowed to break the reflexivity law by defining that .nan != x for any value of x, which is the standard behaviour documented in IEEE-754 and implemented the same way in other programming languages.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#comparable&gt;Comparable<br>&gt;&gt; <br>&gt;&gt; The Comparable protocol will now require (without default implementation provided) a single operator definition: &lt;=&gt; — the comparison operator. From this, all other comparison operators will be derived so as to respect the total order semantics of Comparable:<br>&gt;&gt; <br>&gt;&gt; To maintain compatibility with IEEE-754, the interface of Comparable also contains as customization points the operators &lt;, &lt;=, and == (derived from Equatable) as well as the static binary functions _min(_:_:) and _max(_:_:). User-defined types are recommended against overriding the default implementations.<br>&gt;&gt; <br>&gt;&gt; The uncustomizable top-level binary comparison operators a &gt; b and a &gt;= b are implemented as synonyms to b &lt; aand b &lt;= a, respectively.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#standard-library&gt;Standard Library<br>&gt;&gt; <br>&gt;&gt; Unlike a previous revision of this proposal, standard library algorithms specific to FloatingPoint remain unchanged.<br>&gt;&gt; <br>&gt;&gt; Overloads of &lt;=&gt; for tuples of Comparable elements are provided up to a library-defined arity.<br>&gt;&gt; <br>&gt;&gt; The intent of this proposal is to later augment the standard library so that functions that take an ordering predicate by: (T, T) -&gt; Bool will have an overload ordering: (T, T) -&gt; Ordering that will provide a — potentially — more efficient implementation. A list of such functions is provided in Future directions.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The Comparable protocol will be amended by taking away &gt; and &gt;=, adding customisation points _min(_:_:), and _max(_:_:), and introducing the ordering operator &lt;=&gt; that makes use of the Ordering enum defined below.<br>&gt;&gt; <br>&gt;&gt; enum Ordering : Equatable {<br>&gt;&gt;   case ascending<br>&gt;&gt;   case equal<br>&gt;&gt;   case descending<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; infix operator &lt;=&gt; { associativity none precedence 130 }<br>&gt;&gt; <br>&gt;&gt; public protocol Comparable : Equatable {<br>&gt;&gt;   // Implementation required:<br>&gt;&gt;   static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt; <br>&gt;&gt;   // Default implementations provided:<br>&gt;&gt;   static func == (lhs: Self, rhs: Self) -&gt; Bool // derived from Equatable<br>&gt;&gt;   static func &lt;  (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   static func _min(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;&gt;   static func _max(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; The &lt;=&gt; operator defines a relationship between == and &lt;=&gt; such that a == b iff (a &lt;=&gt; b) == .equal, unless Self chooses to break the semantics in the way of IEEE-754. Likewise, it should hold that (a &lt;=&gt; b) == .ascending iff a &lt; b, and (a &lt;=&gt; b) != .descending iff a &lt;= b.<br>&gt;&gt; <br>&gt;&gt; The _min(_:_:) and _max(_:_:) functions should return the lesser or greater of the two operands, respectively, while in case of equal arguments, _min(_:_:) should favour the left-hand side and _max(_:_:) the right-hand side to retain identity, as presently explained in this comment &lt;https://github.com/apple/swift/blob/4614adc16168d612b6fc7e7a161dd5b6b34be704/stdlib/public/core/Algorithm.swift#L17-L20&gt;. Making them customization points of Comparable, we get to fix their behaviour in the presense of unorderable values (SR-1011 &lt;https://bugs.swift.org/browse/SR-1011&gt;).<br>&gt;&gt; <br>&gt;&gt; Most user types should only implement &lt;=&gt; and leave the other members of Equatable and Comparable to their default implementations. Note that even == has a sane default implementation if Self is made Comparable:<br>&gt;&gt; <br>&gt;&gt; // Default implementations, which should be used for most Comparable types:<br>&gt;&gt; extension Comparable {<br>&gt;&gt;   static func == (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .equal }<br>&gt;&gt;   static func &lt;  (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .ascending }<br>&gt;&gt;   static func &lt;= (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) != .descending }<br>&gt;&gt;   static func _min(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? r : l }<br>&gt;&gt;   static func _max(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? l : r }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Unoverridable top-level operators and functions for Comparable:<br>&gt;&gt; public func &gt;  &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt; l }<br>&gt;&gt; public func &gt;= &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt;= l }<br>&gt;&gt; public func min&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._min(l, r) }<br>&gt;&gt; public func max&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._max(l, r) }<br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#handling-of-floating-point-comparisons&gt;Handling of floating point comparisons<br>&gt;&gt; <br>&gt;&gt; The following text is written in terms of Double but other floating-point types (Float, Float80) are proposed the same treatment.<br>&gt;&gt; <br>&gt;&gt; The IEEE-754 floating point specification has two oddities when it comes to orderability: there are two zeros (0.0 and -0.0) which are considered equal to each other, and there are multiple not-a-number values x for which x.isNaN == true and x != y with any value of y, even x itself. (Remark: the most common NaN value is obtained by the static property Double.nan.)<br>&gt;&gt; <br>&gt;&gt; The interface of Comparable is designed so that &lt;=&gt; alone is able to produce a total order among all possible Doublevalues, sorting negative NaNs less than any other values, and positive NaNs greater than any other. Otherwise, within the range of totally ordered floating point values, -Double.infinity ... Double.infinity, the result of a &lt;=&gt; b remains in full agreement with the laws of a &lt; b, a &lt;= b, and a == b.<br>&gt;&gt; <br>&gt;&gt; The suggested implementation of Double : Comparable makes &lt;=&gt; distinguish between every different bitPatternof NaN:<br>&gt;&gt; <br>&gt;&gt; extension Double : Comparable {<br>&gt;&gt;   public static func &lt;=&gt; (l: Double, r: Double) -&gt; Ordering {<br>&gt;&gt;     func ordinal(_ x: UInt64) -&gt; UInt64 {<br>&gt;&gt;       return x &lt; 0x80000000_00000000 ? x + 0x7fffffff_ffffffff : ~x<br>&gt;&gt;     }<br>&gt;&gt;     return ordinal(l.bitPattern) &lt;=&gt; ordinal(r.bitPattern)<br>&gt;&gt;   }<br>&gt;&gt;   public static func == (l: Double, r: Double) -&gt; Bool { return Builtin.eq(l, r) }<br>&gt;&gt;   public static func &lt;  (l: Double, r: Double) -&gt; Bool { return Builtin.lt(l, r) }<br>&gt;&gt;   public static func &lt;= (l: Double, r: Double) -&gt; Bool { return Builtin.le(l, r) }<br>&gt;&gt;   public static func _min(l: Double, r: Double) -&gt; Double { return Builtin.fmin(l, r) }<br>&gt;&gt;   public static func _max(l: Double, r: Double) -&gt; Double { return Builtin.fmax(l, r) }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Likewise:<br>&gt;&gt; extension Float : Comparable { ... }<br>&gt;&gt; extension Float80 : Comparable { ... }<br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#tuples-and-order-reversal&gt;Tuples and order reversal<br>&gt;&gt; <br>&gt;&gt; Due to missing language support, tuples of Comparable elements cannot be Comparable themselves, but in the spirit of SE-0015 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;, such tuples are given their overloads of &lt;=&gt; up to a standard library defined maximum arity:<br>&gt;&gt; <br>&gt;&gt; public func &lt;=&gt; &lt;A : Comparable, B : Comparable&gt;(lhs: (A, B), rhs: (A, B)) -&gt; Ordering {<br>&gt;&gt;   let a = lhs.0 &lt;=&gt; rhs.0<br>&gt;&gt;   if a != .equal { return a }<br>&gt;&gt;   let b = lhs.1 &lt;=&gt; rhs.1<br>&gt;&gt;   if b != .equal { return b }<br>&gt;&gt;   return .equal<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // Similarly for &lt;A : Comparable, B : Comparable, C : Comparable&gt;, etc.<br>&gt;&gt; To simplify the reversal of a given ordering operation, two members of Ordering are provided in an extension:<br>&gt;&gt; <br>&gt;&gt; extension Ordering {<br>&gt;&gt;   public static func reversing&lt;T : Comparable&gt;(_ ordering: (T, T) -&gt; Ordering)<br>&gt;&gt;     -&gt; (T, T) -&gt; Ordering<br>&gt;&gt;   {<br>&gt;&gt;     return { l, r in ordering(r, l) }<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   public var reversed: Ordering {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case .ascending:  return .descending<br>&gt;&gt;     case .equal:      return .equal<br>&gt;&gt;     case .descending: return .ascending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#foundation&gt;Foundation<br>&gt;&gt; <br>&gt;&gt; In addition, Foundation code will now bridge NSComparisonResult to Ordering allowing for a fluid, natural, and safe API.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; The biggest drawback of the proposed design is the large surface area of Comparable&#39;s interface, as well as the possibility of overriding the comparison operators by mistake. On the other hand, since the required &lt;=&gt; operator is new and affects all users porting their previously Comparable data types to Swift 3, we can use documentation to suggest removing the redundant (and possibly faulty) implementations of other comparison operators.<br>&gt;&gt; <br>&gt;&gt; Existing Equatable but not Comparable types that define an equivalence relation with == will remain unchanged.<br>&gt;&gt; <br>&gt;&gt; Existing Comparable types that define a total ordering with &lt; will need to implement &lt;=&gt; and should remove their existing implementation of any comparison operators, including ==. All other existing Comparable types should implement &lt;=&gt; that provides a total ordering, or should drop their Comparable conformance.<br>&gt;&gt; <br>&gt;&gt; Before:<br>&gt;&gt; <br>&gt;&gt; struct Date: Comparable {<br>&gt;&gt;   let year: Int<br>&gt;&gt;   let month: Int<br>&gt;&gt;   let day: Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func ==(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;&gt;   return lhs.year == rhs.year<br>&gt;&gt;     &amp;&amp; lhs.month == rhs.month<br>&gt;&gt;     &amp;&amp; lhs.day == rhs.day<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func &lt;(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;&gt;   if lhs.year != rhs.year {<br>&gt;&gt;     return lhs.year &lt; rhs.year<br>&gt;&gt;   } else if lhs.month != rhs.month {<br>&gt;&gt;     return lhs.month &lt; rhs.month<br>&gt;&gt;   } else {<br>&gt;&gt;     return lhs.day &lt; rhs.day<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt; After, using the tuple overload of &lt;=&gt;:<br>&gt;&gt; <br>&gt;&gt; struct Date: Comparable {<br>&gt;&gt;   let year: Int<br>&gt;&gt;   let month: Int<br>&gt;&gt;   let day: Int<br>&gt;&gt; <br>&gt;&gt;   static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;&gt;     return (lhs.year, lhs.month, lhs.day)<br>&gt;&gt;        &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>&gt;&gt;   }<br>&gt;&gt; <br>&gt;&gt;   // // Explicit version:<br>&gt;&gt;   // static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;&gt;   //   let yearResult = lhs.year &lt;=&gt; rhs.year<br>&gt;&gt;   //   guard case .equal = yearResult else { return yearResult }<br>&gt;&gt;   //   let monthResult = lhs.month &lt;=&gt; rhs.month<br>&gt;&gt;   //   guard case .equal = monthResult else { return monthResult }<br>&gt;&gt;   //   return lhs.day &lt;=&gt; rhs.day<br>&gt;&gt;   // }<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; A previous design of this proposal suggested a strict total order upon Comparable. While that would make generic algorithms more correct, the definition ended up fighting against the expected behaviour of floating point numbers.<br>&gt;&gt; <br>&gt;&gt; An alternative design that better matches the existing arithmetic-related protocols in Swift is one that uses a member function.<br>&gt;&gt; <br>&gt;&gt; public protocol Comparable: Equatable {<br>&gt;&gt;   func compare(to: Self) -&gt; Ordering<br>&gt;&gt; }<br>&gt;&gt; However, while this API does read better than an operator, we believe that this imposes a number of artificial restrictions (especially in light of SE-0091 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;)<br>&gt;&gt; <br>&gt;&gt; There is no way to use Comparable.compare as a higher-order function in a non-generic context.<br>&gt;&gt; If a member is desired, it can be provided in a protocol extension and defined in terms of the ordering operator; to each according to their need.<br>&gt;&gt; The existing tuple overloads cannot be expressed with a member function.<br>&gt;&gt; One other that Rust has adopted is the inclusion of PartialEquatable and PartialComparable as ancestors of their flavor of Equatable and Comparable . Having protocols to organize and catalogue types that can only guarantee partial equivalence and ordering relations is a good approach for modularity but clutters the standard library with two new protocols for which few useful algorithms could be written against.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#future-directions&gt;Future directions<br>&gt;&gt; <br>&gt;&gt; That the default sort() compares by &lt; and not &lt;=&gt; should be considered a bug to be fixed in a future version of Swift. Using &lt;=&gt; will make sort() well-behaved in the presense of NaN. However, given that the current behaviour is to produce an unspecified order, the fix is additive and can be slipped past Swift 3.<br>&gt;&gt; <br>&gt;&gt; With &lt;=&gt; in place, several present and future standard library algorithms involving a &lt;T : Comparable&gt; requirement will possibly benefit from knowing the total ordering of two operands at once. This is a list of possible such functions (taking Array as example), to be proposed separately as an additive change:<br>&gt;&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;   // Sorting<br>&gt;&gt; <br>&gt;&gt;   mutating func sort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;&gt;   func sorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;&gt;   mutating func stableSort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;&gt;   func stableSorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;&gt; <br>&gt;&gt;   /// Reorders the elements of the collection such that all the elements<br>&gt;&gt;   /// returning `.ascending` are moved to the start of the collection, and the<br>&gt;&gt;   /// elements returning `.descending` are moved to the end of the collection.<br>&gt;&gt;   /// - Returns: the range of elements for which `ordering(x) == .equal`.<br>&gt;&gt;   mutating func partition(ordering: @noescape (Iterator.Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt;&gt; <br>&gt;&gt;   // Binary search<br>&gt;&gt; <br>&gt;&gt;   func bisectedIndex(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index?<br>&gt;&gt;   func lowerBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;&gt;   func upperBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;&gt;   func equalRange(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/7a7e2f43/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 25, 2016 at 02:00:00pm</p></header><div class="content"><p>On Mon, Jul 25, 2016 at 1:52 PM, Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; First, this is orthogonal to &quot;adhering to the standard&quot;.<br>&gt;  isTotallyOrdered( ) provides the total order predicate required by IEEE<br>&gt; 754.  The standard has no opinion about whether or not `&lt;=&gt;` is bound to<br>&gt; that predicate.<br>&gt;<br>&gt; Personally, I would be OK with using the `isTotallyOrdered` semantics for<br>&gt; `&lt;=&gt;`.  However, it leads to some behavior that would be surprising for<br>&gt; novices: x is NaN, and a set S is { 1, 2, NaN }, but S does not contain x.<br>&gt; I am skeptical that the distinction between NaN payloads is salient *for<br>&gt; generic code written on Comparable types*.  It *is* salient for some<br>&gt; (rare!) floating-point specific code, but `isTotallyOrdered` is available<br>&gt; for floating-point types.<br>&gt;<br>&gt; There’s also the issue that if we want to be able to point at IEEE 754 and<br>&gt; say “&lt;=&gt; implements a total order on Level N”, distinguishing distinct NaNs<br>&gt; has consequences for other values.  In particular, it means that a decimal<br>&gt; type should distinguish between 1e0 and 10e-1, because it would necessarily<br>&gt; be an ordering on level 3 or 4.  For { 1, 20 } to not contain 2e1 seems<br>&gt; highly dubious to me.<br>&gt;<br></p><p>Given your reasoning, I have to agree that ordering on level 2 is the only<br>sensible option for generic code written on Comparable types.<br></p><p>With this resolution, I think Dave has largely convinced me that the design<br>as originally proposed (shadowable but not overridable `==` forwards to<br>`===`, etc.) should be workable for wisely chosen implementations of `===`<br>and `&lt;=&gt;`.<br></p><p>– Steve<br>&gt;<br>&gt; On Jul 25, 2016, at 2:23 PM, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt;<br>&gt; Pyry, this proposal looks great to me. My one question is, will I be able<br>&gt; to write `someCollection.sort(.ascending)` and get the expected<br>&gt; result? (This could be an additive future direction.)<br>&gt;<br>&gt; Stephen, what is your rationale for wanting `&lt;=&gt;` to identify NaN values<br>&gt; with different payloads as `.equal`?<br>&gt;<br>&gt; I believe the IEEE 754 total order specification uses the bit-pattern just<br>&gt; as Pyry’s proposal does, and there is value is adhering to the standard.<br>&gt; Besides, if someone intentionally wishes to consider all NaN values as<br>&gt; equivalent they can use `.isNaN` (or even map them to .nan first for<br>&gt; uniformity).<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Mon, Jul 25, 2016 at 1:26 PM, Stephen Canon via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi Pyry —<br>&gt;&gt;<br>&gt;&gt; Dave and I spent some time discussing the details of how this applies to<br>&gt;&gt; floating point earlier today.  We’re now in agreement that &lt;=&gt; should treat<br>&gt;&gt; -0 and +0 as distinct, and treat all NaNs as .equal.  There are three<br>&gt;&gt; motivating considerations:<br>&gt;&gt;<br>&gt;&gt; 1. Although -0 and +0 are “IEEE 754 equal”, there is no computation that<br>&gt;&gt; can produce both of them.  In the parlance of IEEE 754, for any rounding<br>&gt;&gt; mode, the sets of real values that round to them are disjoint.  Because of<br>&gt;&gt; this, if -0 and +0 appear as members of a set, or as keys in a dictionary,<br>&gt;&gt; they necessarily are the result of distinct computations or data.<br>&gt;&gt;<br>&gt;&gt; 2. Substitutability.  Adopting these semantics means that if `x &lt;=&gt; y` is<br>&gt;&gt; `.equal`, `f(x) &lt;=&gt; f(y)` is also `.equal` for any computation `f(x)` that<br>&gt;&gt; depends on the represented value (as opposed to the encoding) of its<br>&gt;&gt; argument.<br>&gt;&gt;<br>&gt;&gt; 3. 754 defines four “specification levels”, or models:<br>&gt;&gt;<br>&gt;&gt; - Level 1: The two-point compactification of the reals, or “extended real<br>&gt;&gt; numbers”.<br>&gt;&gt; - Level 2: The set of representable floating-point data: {-inf … -0}<br>&gt;&gt; union { 0 … inf } union { NaN }.<br>&gt;&gt; - Level 3: The set of representations of floating-point data:<br>&gt;&gt; sign-exponent-significand triples, +/-inf, qNaN, sNaN.<br>&gt;&gt; - Level 4: Floating-point encodings (bit patterns).<br>&gt;&gt;<br>&gt;&gt; The `&lt;=&gt;` semantics we propose constitute a total order on level 2, which<br>&gt;&gt; is the computable model closest to the (reasonably familiar) extended real<br>&gt;&gt; numbers.  Treating -0 and +0 as .equal would put us in a bit of a no-man’s<br>&gt;&gt; land between levels 1 and 2.<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; – Steve<br>&gt;&gt;<br>&gt;&gt; On Jul 25, 2016, at 7:41 AM, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Since we&#39;re running short on time, and the previous discussion thread<br>&gt;&gt; diverged, here&#39;s my attempt to fix the Comparable protocol.<br>&gt;&gt;<br>&gt;&gt; *Pull request:* https://github.com/apple/swift-evolution/pull/464<br>&gt;&gt;<br>&gt;&gt; TL;DR:<br>&gt;&gt;<br>&gt;&gt; 1. Equatable remains unchanged, while Comparable bloats a bit to support<br>&gt;&gt; several use cases.<br>&gt;&gt; 2. `a &lt;=&gt; b` is well-defined even if either value is NaN. Zero is equal<br>&gt;&gt; to minus zero.<br>&gt;&gt; 3. Types are not strictly required to become totally ordered, even if<br>&gt;&gt; it&#39;s strongly recommended.<br>&gt;&gt;<br>&gt;&gt; — — —<br>&gt;&gt;<br>&gt;&gt; I simply can&#39;t see how a pure total order version of Comparable would fit<br>&gt;&gt; the standard way floating point values are expected to behave. However, I<br>&gt;&gt; think we can reach a satisfactory conclusion, one that involves no crashing<br>&gt;&gt; in the standard library, which is what I previously suggested.<br>&gt;&gt;<br>&gt;&gt; What I&#39;m trying to fix is so that all operations listed in<br>&gt;&gt; https://dl.dropboxusercontent.com/u/217402/Comparable.pdf abide to laws<br>&gt;&gt; for types without incomparable values, and that types with weaker order can<br>&gt;&gt; still work in *some* well-defined way outside their totally ordered<br>&gt;&gt; range.<br>&gt;&gt;<br>&gt;&gt; PS. Forgive me Robert, Jaden, and Harlan for not syncing with you, for<br>&gt;&gt; time is tight. I can pull back or revise the proposal if you don&#39;t want to<br>&gt;&gt; be involved.<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Formalized Ordering<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-filename.md&gt;<br>&gt;&gt;    - Authors: Robert Widmann &lt;https://github.com/codafi&gt;, Jaden Geller<br>&gt;&gt;    &lt;https://github.com/jadengeller&gt;, Harlan Haskins<br>&gt;&gt;    &lt;https://github.com/harlanhaskins&gt;, Pyry Jahkola<br>&gt;&gt;    &lt;https://github.com/pyrtsa&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal cleans up the semantics of ordering relations in the<br>&gt;&gt; standard library. Our goal is to formalize the total ordering semantics of<br>&gt;&gt; the Comparable protocol and still provide accessible ordering<br>&gt;&gt; definitions for types without total ordering semantics.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; The standard comparison operators have an intuitive meaning to<br>&gt;&gt; programmers. Swift encourages encoding that in an implementation of<br>&gt;&gt; Comparable that respects the rules of a total order<br>&gt;&gt; &lt;https://en.wikipedia.org/wiki/Total_order&gt;. The standard library takes<br>&gt;&gt; advantage of these rules to provide consistent implementations for sorting<br>&gt;&gt; and searching generic collections of Comparable types.<br>&gt;&gt;<br>&gt;&gt; Not all types behave so well in this framework, unfortunately. There are<br>&gt;&gt; cases where the semantics of a total order cannot apply and still maintain<br>&gt;&gt; the traditional definition of “comparison” over these types. Take, for<br>&gt;&gt; example, sorting an array of Float s. Today, Float ‘s instance of<br>&gt;&gt; Comparable follows IEEE-754 and returns false for all comparisons of NaN .<br>&gt;&gt; In order to sort this array, NaN s are considered outside the domain of &lt; ,<br>&gt;&gt; and the order of a “sorted” array containing them is undefined.<br>&gt;&gt;<br>&gt;&gt; In addition, generic algorithms in the Swift Standard Library that make<br>&gt;&gt; use of the current Comparable protocol may have to make twice as many<br>&gt;&gt; comparisons to request the ordering of values with respect to each other<br>&gt;&gt; than they should. Having a central operation to return information about<br>&gt;&gt; the ordering of values once should provide a speedup for these operations.<br>&gt;&gt;<br>&gt;&gt; In the interest of cleaning up the semantics of Comparable types of all<br>&gt;&gt; shapes and sizes and their uses in the Swift Standard Library, this<br>&gt;&gt; proposal is going to re-arrange the requirements of the Comparable and<br>&gt;&gt; Equatable protocols.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#equatable&gt;<br>&gt;&gt; Equatable<br>&gt;&gt;<br>&gt;&gt; The interface of Equatable remains unchanged under this proposal.<br>&gt;&gt; Equatable types should still respect the equivalence laws of<br>&gt;&gt; *reflexivity* (a == a), *symmetry* (a == b iff b == a), and<br>&gt;&gt; *transitivity* (if a == b and b == c, then a == c). Further, != remains<br>&gt;&gt; a top-level binary operator for which a != b iff !(a == b).<br>&gt;&gt;<br>&gt;&gt; Types containing properties *inessential to equality*, however, are<br>&gt;&gt; allowed to retain their notion of identity. For example Array&#39;s capacity isn&#39;t<br>&gt;&gt; considered for equality; and -0.0 == 0.0 and &quot;ä&quot; == &quot;a\u{308}&quot;, while (-0.0).sign<br>&gt;&gt; != (0.0).sign and &quot;ä&quot;.utf8.count != &quot;a\u{308}&quot;.utf8.count.<br>&gt;&gt;<br>&gt;&gt; IEEE-754 floating point numbers are allowed to break the reflexivity law<br>&gt;&gt; by defining that .nan != x for any value of x, which is the standard<br>&gt;&gt; behaviour documented in IEEE-754 and implemented the same way in other<br>&gt;&gt; programming languages.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#comparable&gt;<br>&gt;&gt; Comparable<br>&gt;&gt;<br>&gt;&gt; The Comparable protocol will now require (without default implementation<br>&gt;&gt; provided) a single operator definition: &lt;=&gt; — the comparison operator.<br>&gt;&gt; From this, all other comparison operators will be derived so as to respect<br>&gt;&gt; the total order semantics of Comparable:<br>&gt;&gt;<br>&gt;&gt; To maintain compatibility with IEEE-754, the interface of Comparable also<br>&gt;&gt; contains as customization points the operators &lt;, &lt;=, and == (derived<br>&gt;&gt; from Equatable) as well as the static binary functions _min(_:_:) and<br>&gt;&gt; _max(_:_:). User-defined types are recommended against overriding the<br>&gt;&gt; default implementations.<br>&gt;&gt;<br>&gt;&gt; The uncustomizable top-level binary comparison operators a &gt; b and a &gt;= b are<br>&gt;&gt; implemented as synonyms to b &lt; aand b &lt;= a, respectively.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#standard-library&gt;Standard<br>&gt;&gt; Library<br>&gt;&gt;<br>&gt;&gt; Unlike a previous revision of this proposal, standard library algorithms<br>&gt;&gt; specific to FloatingPoint remain unchanged.<br>&gt;&gt;<br>&gt;&gt; Overloads of &lt;=&gt; for tuples of Comparable elements are provided up to a<br>&gt;&gt; library-defined arity.<br>&gt;&gt;<br>&gt;&gt; The intent of this proposal is to later augment the standard library so<br>&gt;&gt; that functions that take an ordering predicate by: (T, T) -&gt; Bool will<br>&gt;&gt; have an overload ordering: (T, T) -&gt; Ordering that will provide a —<br>&gt;&gt; potentially — more efficient implementation. A list of such functions is<br>&gt;&gt; provided in Future directions.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; The Comparable protocol will be amended by taking away &gt; and &gt;=, adding<br>&gt;&gt; customisation points _min(_:_:), and _max(_:_:), and introducing the<br>&gt;&gt; ordering operator &lt;=&gt; that makes use of the Ordering enum defined below.<br>&gt;&gt;<br>&gt;&gt; enum Ordering : Equatable {<br>&gt;&gt;   case ascending<br>&gt;&gt;   case equal<br>&gt;&gt;   case descending<br>&gt;&gt; }<br>&gt;&gt; infix operator &lt;=&gt; { associativity none precedence 130 }<br>&gt;&gt; public protocol Comparable : Equatable {<br>&gt;&gt;   // Implementation required:<br>&gt;&gt;   static func &lt;=&gt;(lhs: Self, rhs: Self) -&gt; Ordering<br>&gt;&gt;<br>&gt;&gt;   // Default implementations provided:<br>&gt;&gt;   static func == (lhs: Self, rhs: Self) -&gt; Bool // derived from Equatable<br>&gt;&gt;   static func &lt;  (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   static func &lt;= (lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;   static func _min(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;&gt;   static func _max(_ lhs: Self, _ rhs: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The &lt;=&gt; operator defines a relationship between == and &lt;=&gt; such that a<br>&gt;&gt; == b iff (a &lt;=&gt; b) == .equal, unless Self chooses to break the semantics<br>&gt;&gt; in the way of IEEE-754. Likewise, it should hold that (a &lt;=&gt; b) ==<br>&gt;&gt; .ascending iff a &lt; b, and (a &lt;=&gt; b) != .descending iff a &lt;= b.<br>&gt;&gt;<br>&gt;&gt; The _min(_:_:) and _max(_:_:) functions should return the lesser or<br>&gt;&gt; greater of the two operands, respectively, while in case of equal<br>&gt;&gt; arguments, _min(_:_:) should favour the left-hand side and _max(_:_:) the<br>&gt;&gt; right-hand side to retain identity, as presently explained in this<br>&gt;&gt; comment<br>&gt;&gt; &lt;https://github.com/apple/swift/blob/4614adc16168d612b6fc7e7a161dd5b6b34be704/stdlib/public/core/Algorithm.swift#L17-L20&gt;.<br>&gt;&gt; Making them customization points of Comparable, we get to fix their<br>&gt;&gt; behaviour in the presense of unorderable values (SR-1011<br>&gt;&gt; &lt;https://bugs.swift.org/browse/SR-1011&gt;).<br>&gt;&gt;<br>&gt;&gt; Most user types should only implement &lt;=&gt; and leave the other members of<br>&gt;&gt; Equatable and Comparable to their default implementations. Note that<br>&gt;&gt; even == has a sane default implementation if Self is made Comparable:<br>&gt;&gt;<br>&gt;&gt; // Default implementations, which should be used for most Comparable types:extension Comparable {<br>&gt;&gt;   static func == (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .equal }<br>&gt;&gt;   static func &lt;  (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) == .ascending }<br>&gt;&gt;   static func &lt;= (l: Self, r: Self) -&gt; Bool { return (l &lt;=&gt; r) != .descending }<br>&gt;&gt;   static func _min(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? r : l }<br>&gt;&gt;   static func _max(_ l: Self, _ r: Self) -&gt; Self { return r &lt; l ? l : r }<br>&gt;&gt; }<br>&gt;&gt; // Unoverridable top-level operators and functions for Comparable:public func &gt;  &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt; l }public func &gt;= &lt;T : Comparable&gt;(l: T, r: T) -&gt; Bool { return r &lt;= l }public func min&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._min(l, r) }public func max&lt;T : Comparable&gt;(_ l: T, _ r: T) -&gt; T { return T._max(l, r) }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#handling-of-floating-point-comparisons&gt;Handling<br>&gt;&gt; of floating point comparisons<br>&gt;&gt;<br>&gt;&gt; *The following text is written in terms of Double but other<br>&gt;&gt; floating-point types (Float, Float80) are proposed the same treatment.*<br>&gt;&gt;<br>&gt;&gt; The IEEE-754 floating point specification has two oddities when it comes<br>&gt;&gt; to orderability: there are two zeros (0.0 and -0.0) which are considered<br>&gt;&gt; equal to each other, and there are *multiple* not-a-number values x for<br>&gt;&gt; which x.isNaN == true and x != y with any value of y, even x itself.<br>&gt;&gt; (Remark: the most common NaN value is obtained by the static property<br>&gt;&gt; Double.nan.)<br>&gt;&gt;<br>&gt;&gt; The interface of Comparable is designed so that &lt;=&gt; alone is able to<br>&gt;&gt; produce a total order among all possible Doublevalues, sorting negative<br>&gt;&gt; NaNs less than any other values, and positive NaNs greater than any other.<br>&gt;&gt; Otherwise, within the range of totally ordered floating point values, -Double.infinity<br>&gt;&gt; ... Double.infinity, the result of a &lt;=&gt; b remains in full agreement<br>&gt;&gt; with the laws of a &lt; b, a &lt;= b, and a == b.<br>&gt;&gt;<br>&gt;&gt; The suggested implementation of Double : Comparable makes &lt;=&gt; distinguish<br>&gt;&gt; between every different bitPatternof NaN:<br>&gt;&gt;<br>&gt;&gt; extension Double : Comparable {<br>&gt;&gt;   public static func &lt;=&gt; (l: Double, r: Double) -&gt; Ordering {<br>&gt;&gt;     func ordinal(_ x: UInt64) -&gt; UInt64 {<br>&gt;&gt;       return x &lt; 0x80000000_00000000 ? x + 0x7fffffff_ffffffff : ~x<br>&gt;&gt;     }<br>&gt;&gt;     return ordinal(l.bitPattern) &lt;=&gt; ordinal(r.bitPattern)<br>&gt;&gt;   }<br>&gt;&gt;   public static func == (l: Double, r: Double) -&gt; Bool { return Builtin.eq(l, r) }<br>&gt;&gt;   public static func &lt;  (l: Double, r: Double) -&gt; Bool { return Builtin.lt(l, r) }<br>&gt;&gt;   public static func &lt;= (l: Double, r: Double) -&gt; Bool { return Builtin.le(l, r) }<br>&gt;&gt;   public static func _min(l: Double, r: Double) -&gt; Double { return Builtin.fmin(l, r) }<br>&gt;&gt;   public static func _max(l: Double, r: Double) -&gt; Double { return Builtin.fmax(l, r) }<br>&gt;&gt; }<br>&gt;&gt; // Likewise:extension Float : Comparable { ... }extension Float80 : Comparable { ... }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#tuples-and-order-reversal&gt;Tuples<br>&gt;&gt; and order reversal<br>&gt;&gt;<br>&gt;&gt; Due to missing language support, tuples of Comparable elements cannot be<br>&gt;&gt; Comparable themselves, but in the spirit of SE-0015<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0015-tuple-comparison-operators.md&gt;,<br>&gt;&gt; such tuples are given their overloads of &lt;=&gt; up to a standard library<br>&gt;&gt; defined maximum arity:<br>&gt;&gt;<br>&gt;&gt; public func &lt;=&gt; &lt;A : Comparable, B : Comparable&gt;(lhs: (A, B), rhs: (A, B)) -&gt; Ordering {<br>&gt;&gt;   let a = lhs.0 &lt;=&gt; rhs.0<br>&gt;&gt;   if a != .equal { return a }<br>&gt;&gt;   let b = lhs.1 &lt;=&gt; rhs.1<br>&gt;&gt;   if b != .equal { return b }<br>&gt;&gt;   return .equal<br>&gt;&gt; }<br>&gt;&gt; // Similarly for &lt;A : Comparable, B : Comparable, C : Comparable&gt;, etc.<br>&gt;&gt;<br>&gt;&gt; To simplify the reversal of a given ordering operation, two members of<br>&gt;&gt; Ordering are provided in an extension:<br>&gt;&gt;<br>&gt;&gt; extension Ordering {<br>&gt;&gt;   public static func reversing&lt;T : Comparable&gt;(_ ordering: (T, T) -&gt; Ordering)<br>&gt;&gt;     -&gt; (T, T) -&gt; Ordering<br>&gt;&gt;   {<br>&gt;&gt;     return { l, r in ordering(r, l) }<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   public var reversed: Ordering {<br>&gt;&gt;     switch self {<br>&gt;&gt;     case .ascending:  return .descending<br>&gt;&gt;     case .equal:      return .equal<br>&gt;&gt;     case .descending: return .ascending<br>&gt;&gt;     }<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#foundation&gt;<br>&gt;&gt; Foundation<br>&gt;&gt;<br>&gt;&gt; In addition, Foundation code will now bridge NSComparisonResult to<br>&gt;&gt; Ordering allowing for a fluid, natural, and safe API.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; The biggest drawback of the proposed design is the large surface area of<br>&gt;&gt; Comparable&#39;s interface, as well as the possibility of overriding the<br>&gt;&gt; comparison operators by mistake. On the other hand, since the required<br>&gt;&gt; &lt;=&gt; operator is new and affects all users porting their previously<br>&gt;&gt; Comparable data types to Swift 3, we can use documentation to suggest<br>&gt;&gt; removing the redundant (and possibly faulty) implementations of other<br>&gt;&gt; comparison operators.<br>&gt;&gt;<br>&gt;&gt; Existing Equatable but not Comparable types that define an equivalence<br>&gt;&gt; relation with == will remain unchanged.<br>&gt;&gt;<br>&gt;&gt; Existing Comparable types that define a total ordering with &lt; will need<br>&gt;&gt; to implement &lt;=&gt; and should remove their existing implementation of any<br>&gt;&gt; comparison operators, including ==. All other existing Comparable types<br>&gt;&gt; should implement &lt;=&gt; that provides a total ordering, or should drop<br>&gt;&gt; their Comparable conformance.<br>&gt;&gt;<br>&gt;&gt; Before:<br>&gt;&gt;<br>&gt;&gt; struct Date: Comparable {<br>&gt;&gt;   let year: Int<br>&gt;&gt;   let month: Int<br>&gt;&gt;   let day: Int<br>&gt;&gt; }<br>&gt;&gt; func ==(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;&gt;   return lhs.year == rhs.year<br>&gt;&gt;     &amp;&amp; lhs.month == rhs.month<br>&gt;&gt;     &amp;&amp; lhs.day == rhs.day<br>&gt;&gt; }<br>&gt;&gt; func &lt;(lhs: Date, rhs: Date) -&gt; Bool {<br>&gt;&gt;   if lhs.year != rhs.year {<br>&gt;&gt;     return lhs.year &lt; rhs.year<br>&gt;&gt;   } else if lhs.month != rhs.month {<br>&gt;&gt;     return lhs.month &lt; rhs.month<br>&gt;&gt;   } else {<br>&gt;&gt;     return lhs.day &lt; rhs.day<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; After, using the tuple overload of &lt;=&gt;:<br>&gt;&gt;<br>&gt;&gt; struct Date: Comparable {<br>&gt;&gt;   let year: Int<br>&gt;&gt;   let month: Int<br>&gt;&gt;   let day: Int<br>&gt;&gt;<br>&gt;&gt;   static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;&gt;     return (lhs.year, lhs.month, lhs.day)<br>&gt;&gt;        &lt;=&gt; (rhs.year, rhs.month, rhs.day)<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   // // Explicit version:<br>&gt;&gt;   // static func &lt;=&gt; (lhs: Date, rhs: Date) -&gt; Ordering {<br>&gt;&gt;   //   let yearResult = lhs.year &lt;=&gt; rhs.year<br>&gt;&gt;   //   guard case .equal = yearResult else { return yearResult }<br>&gt;&gt;   //   let monthResult = lhs.month &lt;=&gt; rhs.month<br>&gt;&gt;   //   guard case .equal = monthResult else { return monthResult }<br>&gt;&gt;   //   return lhs.day &lt;=&gt; rhs.day<br>&gt;&gt;   // }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt;<br>&gt;&gt; A previous design of this proposal suggested a strict total order upon<br>&gt;&gt; Comparable. While that would make generic algorithms more correct, the<br>&gt;&gt; definition ended up fighting against the expected behaviour of floating<br>&gt;&gt; point numbers.<br>&gt;&gt;<br>&gt;&gt; An alternative design that better matches the existing arithmetic-related<br>&gt;&gt; protocols in Swift is one that uses a member function.<br>&gt;&gt;<br>&gt;&gt; public protocol Comparable: Equatable {<br>&gt;&gt;   func compare(to: Self) -&gt; Ordering<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; However, while this API does read better than an operator, we believe<br>&gt;&gt; that this imposes a number of artificial restrictions (especially in light<br>&gt;&gt; of SE-0091<br>&gt;&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0091-improving-operators-in-protocols.md&gt;<br>&gt;&gt; )<br>&gt;&gt;<br>&gt;&gt;    1. There is no way to use Comparable.compare as a higher-order<br>&gt;&gt;    function in a non-generic context.<br>&gt;&gt;    2. If a member is desired, it can be provided in a protocol extension<br>&gt;&gt;    and defined in terms of the ordering operator; to each according to their<br>&gt;&gt;    need.<br>&gt;&gt;    3. The existing tuple overloads cannot be expressed with a member<br>&gt;&gt;    function.<br>&gt;&gt;<br>&gt;&gt; One other that Rust has adopted is the inclusion of PartialEquatable and<br>&gt;&gt; PartialComparable as ancestors of their flavor of Equatable and<br>&gt;&gt; Comparable . Having protocols to organize and catalogue types that can<br>&gt;&gt; only guarantee partial equivalence and ordering relations is a good<br>&gt;&gt; approach for modularity but clutters the standard library with two new<br>&gt;&gt; protocols for which few useful algorithms could be written against.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/pyrtsa/swift-evolution/blob/ca89e7b3a1dffc99baa695a03544fcba75afd0f3/proposals/NNNN-formalized-ordering.md#future-directions&gt;Future<br>&gt;&gt; directions<br>&gt;&gt;<br>&gt;&gt; That the default sort() compares by &lt; and not &lt;=&gt; should be considered a<br>&gt;&gt; bug to be fixed in a future version of Swift. Using &lt;=&gt; will make sort() well-behaved<br>&gt;&gt; in the presense of NaN. However, given that the current behaviour is to<br>&gt;&gt; produce an unspecified order, the fix is additive and can be slipped past<br>&gt;&gt; Swift 3.<br>&gt;&gt;<br>&gt;&gt; With &lt;=&gt; in place, several present and future standard library<br>&gt;&gt; algorithms involving a &lt;T : Comparable&gt; requirement will possibly<br>&gt;&gt; benefit from knowing the total ordering of two operands at once. This is a<br>&gt;&gt; list of possible such functions (taking Array as example), to be<br>&gt;&gt; proposed separately as an additive change:<br>&gt;&gt;<br>&gt;&gt; extension Array {<br>&gt;&gt;   // Sorting<br>&gt;&gt;<br>&gt;&gt;   mutating func sort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;&gt;   func sorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;&gt;   mutating func stableSort(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows<br>&gt;&gt;   func stableSorted(ordering: @noescape (Element, Element) throws -&gt; Ordering) rethrows -&gt; [Element]<br>&gt;&gt;<br>&gt;&gt;   /// Reorders the elements of the collection such that all the elements<br>&gt;&gt;   /// returning `.ascending` are moved to the start of the collection, and the<br>&gt;&gt;   /// elements returning `.descending` are moved to the end of the collection.<br>&gt;&gt;   /// - Returns: the range of elements for which `ordering(x) == .equal`.<br>&gt;&gt;   mutating func partition(ordering: @noescape (Iterator.Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt;&gt;<br>&gt;&gt;   // Binary search<br>&gt;&gt;<br>&gt;&gt;   func bisectedIndex(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index?<br>&gt;&gt;   func lowerBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;&gt;   func upperBound(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Index<br>&gt;&gt;   func equalRange(ordering: @noescape (Element) throws -&gt; Ordering) rethrows -&gt; Range&lt;Index&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/3f953874/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On 25 Jul 2016, at 21:23, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; My one question is, will I be able to write `someCollection.sort(.ascending)` and get the expected result? (This could be an additive future direction.)<br></p><p><br>To sort to ascending order, you&#39;d still just call `.sort()` with no arguments.<br></p><p>To limit the scope of this proposal somewhat, I moved the introduction of new sorting functions into the Future directions section. All of those changes are additive in a way or another:<br></p><p>1. The default .sort() function would use `&lt;=&gt;` instead of `&lt;`.<br></p><p>(a) On the one hand, we&#39;d get improved performance in cases like Array&lt;String&gt;.sort() where doing another `&lt;` comparison would be more costly.<br>(b) On the other hand, we&#39;d get well-defined behaviour when sorting Double arrays containing NaNs, because all non-NaN values would be sorted into one contiguous subrange of the result.<br></p><p>That&#39;s an additive change because (a) types implementing total order will still sort according to the same spec as `.sort(by: &lt;)`.<br></p><p>2. If I had it my way, the default .sort() would also become stable, and the programmer could opt in to using a faster unstable sort variant. There are cases where an unstable sort performs better, but a stable sort is a better default, not least because it&#39;s usually what people want when sorting a table by a given column.<br></p><p>3. Several functions (e.g. `.sort(by:)`) would be paired with a `frobnicate(ordering:)` variant where the block returns `Ordering` instead of `Bool`. For sorting to descending order, you&#39;d call something like `someCollection.sort(ordering: Ordering.reversing(&lt;=&gt;))`. Or whatever naming we&#39;ll end up with.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/c087fb18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Formalized Ordering, take 2</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 2:28 PM, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Jul 2016, at 21:23, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com &lt;mailto:nevin.brackettrozinsky at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My one question is, will I be able to write `someCollection.sort(.ascending)` and get the expected result? (This could be an additive future direction.)<br>&gt; <br>&gt; <br>&gt; To sort to ascending order, you&#39;d still just call `.sort()` with no arguments.<br>&gt; <br>&gt; To limit the scope of this proposal somewhat, I moved the introduction of new sorting functions into the Future directions section. All of those changes are additive in a way or another:<br>&gt; <br>&gt; 1. The default .sort() function would use `&lt;=&gt;` instead of `&lt;`.<br>&gt; <br>&gt; (a) On the one hand, we&#39;d get improved performance in cases like Array&lt;String&gt;.sort() where doing another `&lt;` comparison would be more costly.<br>&gt; (b) On the other hand, we&#39;d get well-defined behaviour when sorting Double arrays containing NaNs, because all non-NaN values would be sorted into one contiguous subrange of the result.<br></p><p>Two quick questions… <br>1) What about adding an `isInvalid` case? That way types (such as Double/Float) which have “unordered” values can check for an invalid comparison.<br>2) What about making `Ordering` a tuple instead of an enum? “typealias Ordering = (isLessThan: Bool, isEqual: Bool, isGreaterThan: Bool, isInvalid: Bool)”? It’d take up more space on the stack, but I think this:<br>func &lt; (lhs: Int, rhs: Int) -&gt; Bool {<br>    return (lhs &lt;=&gt; rhs).isLessThan<br>}<br>or even this:<br>func &lt; (lhs: Int, rhs: Int) -&gt; Bool {<br>    let ord =  (lhs &lt;=&gt; rhs).isLessThan<br>    return ord.isLessThan &amp;&amp; !ord.isInvalid<br>}<br></p><p>would execute faster than this:<br>func &lt; (lhs: Int, rhs: Int) -&gt; Bool {<br>    switch (lhs &lt;=&gt; rhs) {<br>    case lessThan: return true<br>    default: return false<br>}<br></p><p>because there wouldn’t be any branching beyond what’s necessary to do the actual comparison.<br></p><p>- Dave Sweeris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/57e4b4fc/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
