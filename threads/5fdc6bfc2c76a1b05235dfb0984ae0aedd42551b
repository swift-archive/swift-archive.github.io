<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/92986d4d0e7edc94494b2e1478228204?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Florian Reinhart</string> &lt;florian at bottledsoftware.de&gt;<p>December 11, 2015 at 01:00:00pm</p></header><div class="content"><p>Hi all,<br></p><p>Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br></p><p>I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>What do you think?<br></p><p>Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br></p><p>—Florian<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/5fdc551b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>December 11, 2015 at 07:00:00am</p></header><div class="content"><p>NSDecimalNumber is mostly just a simple object wrapper for NSDecimal that interoperates with NSNumber so that seems like a pretty sensible approach ordering.<br></p><p>Since the goal of the swift-corelibs-foundation is to as closely match the current APIs of Foundation as possible (exclusions have been made where it just isn’t possible); so I would say that option 1 would be the more appropriate way to start off. <br></p><p>https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NumbersandValues/Articles/DecimalNumbers.html might be a decent place to get a little bit of background; my suggestion however would be to write some really good unit tests to verify it’s behavior. <br></p><p>Eventually we would like to archive these things so keeping it the same structure is probably a good idea.<br></p><p>That all being said - NSDecimal itself seems reasonably suitable for a re-look from a swift perspective. NSDecimalAdd, NSDecimalSubtract etc all really would be more wonderful with operators and some instance methods/properties would be really useful as well. The implementation of NSDecimal and these additions are two different pieces and should be considered separately as well. In that any change that we make to diverge from usage immediately will not be directly usable on Mac OS X/iOS since we will have to work that into the foundation overlay and/or make modifications to the Foundation implementation for supporting any changes like that. <br></p><p>So in short: #1 is the suggested route for a pull request onto Foundation and #2 is a better route for a proposal for swift-evolution (specifically targeted at Foundation).<br></p><p>&gt; On Dec 11, 2015, at 4:32 AM, Florian Reinhart via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br>&gt; <br>&gt; I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>&gt; We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>&gt; We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>&gt; What do you think?<br>&gt; <br>&gt; Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br>&gt; <br>&gt; —Florian<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/ab180f47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December 11, 2015 at 10:00:00am</p></header><div class="content"><p>This thread is related to the thread I started last night about Foundation and value types. <br></p><p>Ideally all Foundation types that are already structs would expose a more Swifty interface and those that are naturally value types but currently implemented as classes would be bridged and exposed in Swift as value types.  <br></p><p>Responses last night seem to indicate at least some appetite for doing this if an acceptable bridging strategy can be identified even though it increases scope a bit as it is not directly related to portability.  <br></p><p>I would be extremely pleased if we are able to pull this off as it should be possible to design value types by composing Date, URL, Decimal, etc without needing to create our own value type wrappers for them.<br></p><p>Matthew<br></p><p>Sent from my iPhone<br></p><p>&gt; On Dec 11, 2015, at 9:45 AM, Philippe Hausler via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; NSDecimalNumber is mostly just a simple object wrapper for NSDecimal that interoperates with NSNumber so that seems like a pretty sensible approach ordering.<br>&gt; <br>&gt; Since the goal of the swift-corelibs-foundation is to as closely match the current APIs of Foundation as possible (exclusions have been made where it just isn’t possible); so I would say that option 1 would be the more appropriate way to start off. <br>&gt; <br>&gt; https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/NumbersandValues/Articles/DecimalNumbers.html might be a decent place to get a little bit of background; my suggestion however would be to write some really good unit tests to verify it’s behavior. <br>&gt; <br>&gt; Eventually we would like to archive these things so keeping it the same structure is probably a good idea.<br>&gt; <br>&gt; That all being said - NSDecimal itself seems reasonably suitable for a re-look from a swift perspective. NSDecimalAdd, NSDecimalSubtract etc all really would be more wonderful with operators and some instance methods/properties would be really useful as well. The implementation of NSDecimal and these additions are two different pieces and should be considered separately as well. In that any change that we make to diverge from usage immediately will not be directly usable on Mac OS X/iOS since we will have to work that into the foundation overlay and/or make modifications to the Foundation implementation for supporting any changes like that. <br>&gt; <br>&gt; So in short: #1 is the suggested route for a pull request onto Foundation and #2 is a better route for a proposal for swift-evolution (specifically targeted at Foundation).<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 4:32 AM, Florian Reinhart via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br>&gt;&gt; <br>&gt;&gt; I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>&gt;&gt; We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>&gt;&gt; We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br>&gt;&gt; <br>&gt;&gt; —Florian<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/b867e0b4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/864e2a768b89d0a553043c6a149502a2?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Dan Thorpe</string> &lt;dan at blindingskies.com&gt;<p>December 11, 2015 at 12:00:00pm</p></header><div class="content"><p>I’d be really interested in working on a Swift decimal number type. I’ve done some work on this for a Money type here: https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal<br></p><p>I agree that it’s best to start with NSDecimal, and that approach 2 would offer the most flexibility.<br></p><p>I have a few other thoughts regarding the number behaviors.<br></p><p>NSDecimal’s functions accept rounding mode parameters and return NSCalculationError but NSDecimalNumber accepts NSDecimalNumberBehavior parameter and throws NSExceptions. I’m not really sure what the reason for this discrepancy is and should a new Swift NSDecimal use NSDecimalNumberBehavior, but maintain backwards compatibility with default behaviors and defined rounding mode? <br></p><p>Also, should a Swift NSDecimal continues with raising NSException, or adopt Swift style error handling? I don’t think we would want to introduce try/throw/catch semantics into the publicly exposed methods - but we could have an internal API layer which does. Backwards compatible functions would then have to convert between Swift ErrorType and NSException or NSCalculationError.<br></p><p>Cheers,<br>Dan<br></p><p>p.s. in the linked project, I made a DecimalNumberType protocol generic over the Behavior, which I’m not entire sure was a good decision or not.<br></p><p><br>&gt; On 11 Dec 2015, at 12:32, Florian Reinhart via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi all,<br>&gt; <br>&gt; Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br>&gt; <br>&gt; I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>&gt; We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>&gt; We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>&gt; What do you think?<br>&gt; <br>&gt; Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br>&gt; <br>&gt; —Florian<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/9adbebda/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December 11, 2015 at 11:00:00am</p></header><div class="content"><p>Hi Dan, Florian,<br></p><p>I agree with Philippe that NSDecimal is a particularly troublesome area in terms of how poorly the API is imported into Swift.<br></p><p>Since NSDecimal is already a value type, it may be possible to do something better here ourselves without worrying about the bridging problem. It would be an API change, however, so we should follow the swift-evolution process.<br></p><p>NSDecimalNumber would be more complicated, since it’s a class (and furthermore, a subclass of NSNumber).<br></p><p>&gt; On Dec 11, 2015, at 4:58 AM, Dan Thorpe via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I’d be really interested in working on a Swift decimal number type. I’ve done some work on this for a Money type here: https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal &lt;https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal&gt;<br>&gt; <br>&gt; I agree that it’s best to start with NSDecimal, and that approach 2 would offer the most flexibility.<br>&gt; <br>&gt; I have a few other thoughts regarding the number behaviors.<br>&gt; <br>&gt; NSDecimal’s functions accept rounding mode parameters and return NSCalculationError but NSDecimalNumber accepts NSDecimalNumberBehavior parameter and throws NSExceptions. I’m not really sure what the reason for this discrepancy is and should a new Swift NSDecimal use NSDecimalNumberBehavior, but maintain backwards compatibility with default behaviors and defined rounding mode? <br>&gt; <br></p><p>Our primary goal is API compatibility across platforms. It would be really unfortunate if a client of Foundation had to #ifdef their code to account for a platform difference.<br></p><p>That’s not to say we can’t improve things (as we do with every release), but compatibility requirements are a fact of life for a low level library like ours. Our clients appreciate it. =)<br></p><p>&gt; Also, should a Swift NSDecimal continues with raising NSException, or adopt Swift style error handling? I don’t think we would want to introduce try/throw/catch semantics into the publicly exposed methods - but we could have an internal API layer which does. Backwards compatible functions would then have to convert between Swift ErrorType and NSException or NSCalculationError.<br>&gt; <br></p><p>Anywhere that Darwin Foundation raises an NSException, we are replacing with fatalError, precondition, or similar. The root cause of either is the same (a programmer error). The try/catch/throws mechanism is for errors that we may want to present to a user at some point.<br></p><p>Hope this helps,<br>- Tony<br></p><p>&gt; Cheers,<br>&gt; Dan<br>&gt; <br>&gt; p.s. in the linked project, I made a DecimalNumberType protocol generic over the Behavior, which I’m not entire sure was a good decision or not.<br>&gt; <br>&gt; <br>&gt;&gt; On 11 Dec 2015, at 12:32, Florian Reinhart via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi all,<br>&gt;&gt; <br>&gt;&gt; Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br>&gt;&gt; <br>&gt;&gt; I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>&gt;&gt; We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>&gt;&gt; We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>&gt;&gt; What do you think?<br>&gt;&gt; <br>&gt;&gt; Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br>&gt;&gt; <br>&gt;&gt; —Florian<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/25f03119/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/864e2a768b89d0a553043c6a149502a2?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Dan Thorpe</string> &lt;dan at blindingskies.com&gt;<p>December 11, 2015 at 09:00:00pm</p></header><div class="content"><p>Thanks for the clarification Tony - and for reminding me of the primary goal r.e. API compatibility. :)<br></p><p>This may be better suited to swift-evolution or users list, but regarding fatalError do you have any techniques for testing this behavior? I was thinking about an internal try/throw/ layer (which would then be caught and trampolined to fatalError for the public APIs) so that it would be possible to write unit tests for the edge cases where there is a calculation error.<br></p><p>Cheers,<br>Dan <br></p><p>&gt; On 11 Dec 2015, at 19:00, Tony Parker &lt;anthony.parker at apple.com&gt; wrote:<br>&gt; <br>&gt; Hi Dan, Florian,<br>&gt; <br>&gt; I agree with Philippe that NSDecimal is a particularly troublesome area in terms of how poorly the API is imported into Swift.<br>&gt; <br>&gt; Since NSDecimal is already a value type, it may be possible to do something better here ourselves without worrying about the bridging problem. It would be an API change, however, so we should follow the swift-evolution process.<br>&gt; <br>&gt; NSDecimalNumber would be more complicated, since it’s a class (and furthermore, a subclass of NSNumber).<br>&gt; <br>&gt;&gt; On Dec 11, 2015, at 4:58 AM, Dan Thorpe via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’d be really interested in working on a Swift decimal number type. I’ve done some work on this for a Money type here: https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal &lt;https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal&gt;<br>&gt;&gt; <br>&gt;&gt; I agree that it’s best to start with NSDecimal, and that approach 2 would offer the most flexibility.<br>&gt;&gt; <br>&gt;&gt; I have a few other thoughts regarding the number behaviors.<br>&gt;&gt; <br>&gt;&gt; NSDecimal’s functions accept rounding mode parameters and return NSCalculationError but NSDecimalNumber accepts NSDecimalNumberBehavior parameter and throws NSExceptions. I’m not really sure what the reason for this discrepancy is and should a new Swift NSDecimal use NSDecimalNumberBehavior, but maintain backwards compatibility with default behaviors and defined rounding mode? <br>&gt;&gt; <br>&gt; <br>&gt; Our primary goal is API compatibility across platforms. It would be really unfortunate if a client of Foundation had to #ifdef their code to account for a platform difference.<br>&gt; <br>&gt; That’s not to say we can’t improve things (as we do with every release), but compatibility requirements are a fact of life for a low level library like ours. Our clients appreciate it. =)<br>&gt; <br>&gt;&gt; Also, should a Swift NSDecimal continues with raising NSException, or adopt Swift style error handling? I don’t think we would want to introduce try/throw/catch semantics into the publicly exposed methods - but we could have an internal API layer which does. Backwards compatible functions would then have to convert between Swift ErrorType and NSException or NSCalculationError.<br>&gt;&gt; <br>&gt; <br>&gt; Anywhere that Darwin Foundation raises an NSException, we are replacing with fatalError, precondition, or similar. The root cause of either is the same (a programmer error). The try/catch/throws mechanism is for errors that we may want to present to a user at some point.<br>&gt; <br>&gt; Hope this helps,<br>&gt; - Tony<br>&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; Dan<br>&gt;&gt; <br>&gt;&gt; p.s. in the linked project, I made a DecimalNumberType protocol generic over the Behavior, which I’m not entire sure was a good decision or not.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Dec 2015, at 12:32, Florian Reinhart via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>&gt;&gt;&gt; We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>&gt;&gt;&gt; We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —Florian<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/b9e59fc3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December 11, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 11, 2015, at 1:02 PM, Dan Thorpe &lt;dan at blindingskies.com&gt; wrote:<br>&gt; <br>&gt; Thanks for the clarification Tony - and for reminding me of the primary goal r.e. API compatibility. :)<br>&gt; <br>&gt; This may be better suited to swift-evolution or users list, but regarding fatalError do you have any techniques for testing this behavior? I was thinking about an internal try/throw/ layer (which would then be caught and trampolined to fatalError for the public APIs) so that it would be possible to write unit tests for the edge cases where there is a calculation error.<br>&gt; <br>&gt; Cheers,<br>&gt; Dan <br></p><p>It’s a good question regarding the testability of fatalError paths. I think it would be really unfortunate if we had to write our own trampolines every place that we wanted to use it, but I’m not sure how else to verify the behavior if we don’t want to allow every test case to crash. Let’s raise the issue on the more general swift-users list and see if anyone has any ideas.<br></p><p>- Tony<br></p><p>&gt; <br>&gt;&gt; On 11 Dec 2015, at 19:00, Tony Parker &lt;anthony.parker at apple.com &lt;mailto:anthony.parker at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dan, Florian,<br>&gt;&gt; <br>&gt;&gt; I agree with Philippe that NSDecimal is a particularly troublesome area in terms of how poorly the API is imported into Swift.<br>&gt;&gt; <br>&gt;&gt; Since NSDecimal is already a value type, it may be possible to do something better here ourselves without worrying about the bridging problem. It would be an API change, however, so we should follow the swift-evolution process.<br>&gt;&gt; <br>&gt;&gt; NSDecimalNumber would be more complicated, since it’s a class (and furthermore, a subclass of NSNumber).<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 11, 2015, at 4:58 AM, Dan Thorpe via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d be really interested in working on a Swift decimal number type. I’ve done some work on this for a Money type here: https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal &lt;https://github.com/danthorpe/Money/tree/development/Money/Shared/Decimal&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that it’s best to start with NSDecimal, and that approach 2 would offer the most flexibility.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a few other thoughts regarding the number behaviors.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSDecimal’s functions accept rounding mode parameters and return NSCalculationError but NSDecimalNumber accepts NSDecimalNumberBehavior parameter and throws NSExceptions. I’m not really sure what the reason for this discrepancy is and should a new Swift NSDecimal use NSDecimalNumberBehavior, but maintain backwards compatibility with default behaviors and defined rounding mode? <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Our primary goal is API compatibility across platforms. It would be really unfortunate if a client of Foundation had to #ifdef their code to account for a platform difference.<br>&gt;&gt; <br>&gt;&gt; That’s not to say we can’t improve things (as we do with every release), but compatibility requirements are a fact of life for a low level library like ours. Our clients appreciate it. =)<br>&gt;&gt; <br>&gt;&gt;&gt; Also, should a Swift NSDecimal continues with raising NSException, or adopt Swift style error handling? I don’t think we would want to introduce try/throw/catch semantics into the publicly exposed methods - but we could have an internal API layer which does. Backwards compatible functions would then have to convert between Swift ErrorType and NSException or NSCalculationError.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Anywhere that Darwin Foundation raises an NSException, we are replacing with fatalError, precondition, or similar. The root cause of either is the same (a programmer error). The try/catch/throws mechanism is for errors that we may want to present to a user at some point.<br>&gt;&gt; <br>&gt;&gt; Hope this helps,<br>&gt;&gt; - Tony<br>&gt;&gt; <br>&gt;&gt;&gt; Cheers,<br>&gt;&gt;&gt; Dan<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; p.s. in the linked project, I made a DecimalNumberType protocol generic over the Behavior, which I’m not entire sure was a good decision or not.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 11 Dec 2015, at 12:32, Florian Reinhart via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi all,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is someone already working on NSDecimal and/or NSDecimalNumber? If not I would like to help and have a few questions on how to best tackle this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it’s best to start with NSDecimal and then use NSDecimal to create NSDecimalNumber. That’s why I want to concentrate on NSDecimal first. As far as I know there is no CF type we can utilize for NSDecimal and the existing interface is not Swift-like. I see two possible approaches here:<br>&gt;&gt;&gt;&gt; We try to match the existing interface of NSDecimal as close as possible and only provide the same function interface with UnsafePointers all over the place<br>&gt;&gt;&gt;&gt; We create a Swift-like version of the NSDecimal struct. This struct stores its data in private properties and exposes methods (add, multiply, etc.) and computed properties (isNaN, etc.). Additionally, to achieve compatibility with the existing Foundation NSDecimal, we provide the same functions that take NSDecimal pointers and internally use the methods of the Swift struct.<br>&gt;&gt;&gt;&gt; What do you think?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Unfortunately, I haven’t found a lot of documentation for NSDecimal, yet. Is there any documentation, which describes the NSDecimal functions?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; —Florian<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-corelibs-dev mailing list<br>&gt;&gt;&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151211/ac3de0f4/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>NSDecimal &amp; NSDecimalNumber</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; This may be better suited to swift-evolution or users list, but regarding fatalError do you have any techniques for testing this behavior?<br></p><p>I believe the Swift compiler’s tests run code it expects to trap in a separate process and verify that the other process trapped. We may want to think about extending XCTest in some way to offer this behavior.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
