<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>September 21, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>For complex statements in C++ any temporary instances created in the course<br>of an expression have their lifetime extended to the completion of the current<br>statement after which they are all deallocated en masse. This makes certain<br>types of language usage possible and easier to reason with.<br></p><p>I’m bringing this up as I had a problem with some code crashing only when<br>compiled with release configuration and the problem could have been avoided<br>if Swift deferred deallocation to the end of a statement. While Swift’s ARC policy<br>is consistent in itself this seems to be a particular problem interfacing between<br>language/reference counting systems. My problem code was a Java-Swift Bridge.<br></p><p>A contrived example:<br></p><p>import Foundation<br></p><p>protocol Storage {<br>    var fp: UnsafeMutablePointer&lt;FILE&gt; { get }<br>}<br></p><p>class FileStorage: Storage {<br></p><p>    let fp: UnsafeMutablePointer&lt;FILE&gt;<br></p><p>    init?(path: String, mode: String = &quot;w&quot;) {<br>        print(&quot;Opening&quot;)<br>        let fp = fopen(path, mode)<br>        if fp == nil {<br>            return nil<br>        }<br>        self.fp = fp!<br>    }<br></p><p>    deinit {<br>        print(&quot;Closing&quot;)<br>        fclose(fp)<br>    }<br>}<br></p><p>func save(string: String, to: Storage?) {<br>    if let data = string.data(using: String.Encoding.utf8) {<br>        print(&quot;Saving1&quot;)<br>        if let fp = to?.fp {<br>            print(&quot;Saving2&quot;)<br>            data.withUnsafeBytes {<br>                _ = fwrite($0, 1, data.count, fp)<br>            }<br>            print(&quot;Saving3&quot;)<br>        }<br>    }<br>}<br></p><p>save(string: &quot;Hello World\n&quot;, to: FileStorage(path: &quot;/tmp/a.txt&quot;))<br></p><p><br>In debug configuration is prints:<br>Opening<br>Saving1<br>Saving2<br>Saving3<br>Closing<br></p><p>Whereas in release configuration it prints:<br>Opening<br>Saving1<br>Closing &lt;!!!<br>Saving2<br>Saving3<br></p><p>The optimiser is vigorously deallocating objects when they are no longer referenced regardless<br>of whether an variable referencing it is still in scope (In fairness this particular problem only occurs<br>for Optional augments of Protocols) but this behaviour seems to be implicit in the current language<br>spec. The alternative is to retain arguments themselves as I believe they are in Objective-C ARC.<br></p><p>This would have been avoided if the temporary FileStorage instance has been considered to have<br>a lifetime up to the end of the statement calling function save() and hence the duration of the call.<br>This needed increase ARC overhead in any way. Just alter the timing of it to be more conservative.<br></p><p>John<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/0a1fdee7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>September 21, 2016 at 10:00:00pm</p></header><div class="content"><p>I haven&#39;t used it myself, but is this the use case addressed by<br>`withExtendedLifetime(_:_:)`?<br></p><p>On Wed, Sep 21, 2016 at 16:54 John Holdsworth via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; For complex statements in C++ any temporary instances created in the course<br>&gt; of an expression have their lifetime extended to the completion of the<br>&gt; current<br>&gt; statement after which they are all deallocated en masse. This makes certain<br>&gt; types of language usage possible and easier to reason with.<br>&gt;<br>&gt; I’m bringing this up as I had a problem with some code crashing only when<br>&gt; compiled with release configuration and the problem could have been avoided<br>&gt; if Swift deferred deallocation to the end of a statement. While Swift’s<br>&gt; ARC policy<br>&gt; is consistent in itself this seems to be a particular problem interfacing<br>&gt; between<br>&gt; language/reference counting systems. My problem code was a Java-Swift<br>&gt; Bridge.<br>&gt;<br>&gt; A contrived example:<br>&gt;<br>&gt; import Foundation<br>&gt;<br>&gt; protocol Storage {<br>&gt;     var fp: UnsafeMutablePointer&lt;FILE&gt; { get }<br>&gt; }<br>&gt;<br>&gt; class FileStorage: Storage {<br>&gt;<br>&gt;     let fp: UnsafeMutablePointer&lt;FILE&gt;<br>&gt;<br>&gt;     init?(path: String, mode: String = &quot;w&quot;) {<br>&gt;         print(&quot;Opening&quot;)<br>&gt;         let fp = fopen(path, mode)<br>&gt;         if fp == nil {<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.fp = fp!<br>&gt;     }<br>&gt;<br>&gt;     deinit {<br>&gt;         print(&quot;Closing&quot;)<br>&gt;         fclose(fp)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; func save(string: String, to: Storage?) {<br>&gt;     if let data = string.data(using: String.Encoding.utf8) {<br>&gt;         print(&quot;Saving1&quot;)<br>&gt;         if let fp = to?.fp {<br>&gt;             print(&quot;Saving2&quot;)<br>&gt;             data.withUnsafeBytes {<br>&gt;                 _ = fwrite($0, 1, data.count, fp)<br>&gt;             }<br>&gt;             print(&quot;Saving3&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; save(string: &quot;Hello World\n&quot;, to: FileStorage(path: &quot;/tmp/a.txt&quot;))<br>&gt;<br>&gt;<br>&gt; In debug configuration is prints:<br>&gt; *Opening*<br>&gt; *Saving1*<br>&gt; *Saving2*<br>&gt; *Saving3*<br>&gt; *Closing*<br>&gt;<br>&gt; Whereas in release configuration it prints:<br>&gt; *Opening*<br>&gt; *Saving1*<br>&gt; *Closing &lt;!!!*<br>&gt; *Saving2*<br>&gt; *Saving3*<br>&gt;<br>&gt; The optimiser is vigorously deallocating objects when they are no longer<br>&gt; referenced regardless<br>&gt; of whether an variable referencing it is still in scope (In fairness this<br>&gt; particular problem only occurs<br>&gt; for Optional augments of Protocols) but this behaviour seems to be<br>&gt; implicit in the current language<br>&gt; spec. The alternative is to retain arguments themselves as I believe they<br>&gt; are in Objective-C ARC.<br>&gt;<br>&gt; This would have been avoided if the temporary FileStorage instance has<br>&gt; been considered to have<br>&gt; a lifetime up to the end of the statement calling function save() and<br>&gt; hence the duration of the call.<br>&gt; This needed increase ARC overhead in any way. Just alter the timing of it<br>&gt; to be more conservative.<br>&gt;<br>&gt; John<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160921/8d09f0f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 21, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 21, 2016, at 3:14 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I haven&#39;t used it myself, but is this the use case addressed by `withExtendedLifetime(_:_:)`?<br></p><p>Yeah, if you want to vend resources managed by an object to consumers outside of that object like this, you need to use withExtendedLifetime to keep the object alive for as long as you&#39;re using the resources. A cleaner way to model this might be to put the class or protocol in control of handling the I/O to the file handle, instead of vending the file handle itself, so that the ownership semantics fall out more naturally:<br></p><p>protocol Storage {<br>  func write(bytes: UnsafeRawPointer, count: Int)<br>}<br></p><p>func save(string: String, to: Storage?) {<br>    if let data = string.data(using: String.Encoding.utf8) {<br>        data.withUnsafeBytes {<br>            _ = to?.write(bytes: $0, count: data.count)<br>        }<br>    }<br>}<br></p><p>-Joe<br></p><p>&gt; On Wed, Sep 21, 2016 at 16:54 John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; For complex statements in C++ any temporary instances created in the course<br>&gt; of an expression have their lifetime extended to the completion of the current<br>&gt; statement after which they are all deallocated en masse. This makes certain<br>&gt; types of language usage possible and easier to reason with.<br>&gt; <br>&gt; I’m bringing this up as I had a problem with some code crashing only when<br>&gt; compiled with release configuration and the problem could have been avoided<br>&gt; if Swift deferred deallocation to the end of a statement. While Swift’s ARC policy<br>&gt; is consistent in itself this seems to be a particular problem interfacing between<br>&gt; language/reference counting systems. My problem code was a Java-Swift Bridge.<br>&gt; <br>&gt; A contrived example:<br>&gt; <br>&gt; import Foundation<br>&gt; <br>&gt; protocol Storage {<br>&gt;     var fp: UnsafeMutablePointer&lt;FILE&gt; { get }<br>&gt; }<br>&gt; <br>&gt; class FileStorage: Storage {<br>&gt; <br>&gt;     let fp: UnsafeMutablePointer&lt;FILE&gt;<br>&gt; <br>&gt;     init?(path: String, mode: String = &quot;w&quot;) {<br>&gt;         print(&quot;Opening&quot;)<br>&gt;         let fp = fopen(path, mode)<br>&gt;         if fp == nil {<br>&gt;             return nil<br>&gt;         }<br>&gt;         self.fp = fp!<br>&gt;     }<br>&gt; <br>&gt;     deinit {<br>&gt;         print(&quot;Closing&quot;)<br>&gt;         fclose(fp)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; func save(string: String, to: Storage?) {<br>&gt;     if let data = string.data(using: String.Encoding.utf8) {<br>&gt;         print(&quot;Saving1&quot;)<br>&gt;         if let fp = to?.fp {<br>&gt;             print(&quot;Saving2&quot;)<br>&gt;             data.withUnsafeBytes {<br>&gt;                 _ = fwrite($0, 1, data.count, fp)<br>&gt;             }<br>&gt;             print(&quot;Saving3&quot;)<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; save(string: &quot;Hello World\n&quot;, to: FileStorage(path: &quot;/tmp/a.txt&quot;))<br>&gt; <br>&gt; <br>&gt; In debug configuration is prints:<br>&gt; Opening<br>&gt; Saving1<br>&gt; Saving2<br>&gt; Saving3<br>&gt; Closing<br>&gt; <br>&gt; Whereas in release configuration it prints:<br>&gt; Opening<br>&gt; Saving1<br>&gt; Closing &lt;!!!<br>&gt; Saving2<br>&gt; Saving3<br>&gt; <br>&gt; The optimiser is vigorously deallocating objects when they are no longer referenced regardless<br>&gt; of whether an variable referencing it is still in scope (In fairness this particular problem only occurs<br>&gt; for Optional augments of Protocols) but this behaviour seems to be implicit in the current language<br>&gt; spec. The alternative is to retain arguments themselves as I believe they are in Objective-C ARC.<br>&gt; <br>&gt; This would have been avoided if the temporary FileStorage instance has been considered to have<br>&gt; a lifetime up to the end of the statement calling function save() and hence the duration of the call.<br>&gt; This needed increase ARC overhead in any way. Just alter the timing of it to be more conservative.<br>&gt; <br>&gt; John<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>September 22, 2016 at 12:00:00am</p></header><div class="content"><p>My contrived example was a bit flimsy. I’d better unpack the full story. The real<br>code I had problems with was based around the following Java instance wrapper:<br></p><p>open class JNIObject: JNIObjectProtocol {<br></p><p>    var _javaObject: jobject?<br></p><p>    open var javaObject: jobject? {<br>        get {<br>            return _javaObject<br>        }<br>        set(newValue) {<br>            if newValue != _javaObject {<br>                let oldValue = _javaObject<br>                if newValue != nil {<br>                    _javaObject = JNI.api.NewGlobalRef( JNI.env, newValue )<br>                }<br>                else {<br>                    _javaObject = nil<br>                }<br>                if oldValue != nil {<br>                    JNI.api.DeleteGlobalRef( JNI.env, oldValue )<br>                }<br>            }<br>        }<br>    }<br></p><p>    deinit {<br>        javaObject = nil<br>    }<br></p><p>As a result the following transfer of a Java instance always worked:<br></p><p>    init(imageProducer:ImageProducer) {<br>        let supr = CanvasBase()<br>        super.init( javaObject: supr.javaObject )<br>        image = createImage(imageProducer)<br>    }<br></p><p>But the following only worked for debug compiles:<br></p><p>    init(imageProducer:ImageProducer) {<br>        super.init( javaObject: CanvasBase().javaObject )<br>        image = createImage(imageProducer)<br>    }<br></p><p>Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br></p><p>John<br></p><p><br>&gt; On 21 Sep 2016, at 23:34, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 21, 2016, at 3:14 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I haven&#39;t used it myself, but is this the use case addressed by `withExtendedLifetime(_:_:)`?<br>&gt; <br>&gt; Yeah, if you want to vend resources managed by an object to consumers outside of that object like this, you need to use withExtendedLifetime to keep the object alive for as long as you&#39;re using the resources. A cleaner way to model this might be to put the class or protocol in control of handling the I/O to the file handle, instead of vending the file handle itself, so that the ownership semantics fall out more naturally:<br>&gt; <br>&gt; protocol Storage {<br>&gt;  func write(bytes: UnsafeRawPointer, count: Int)<br>&gt; }<br>&gt; <br>&gt; func save(string: String, to: Storage?) {<br>&gt;    if let data = string.data(using: String.Encoding.utf8) {<br>&gt;        data.withUnsafeBytes {<br>&gt;            _ = to?.write(bytes: $0, count: data.count)<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Wed, Sep 21, 2016 at 16:54 John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hi,<br>&gt;&gt; <br>&gt;&gt; For complex statements in C++ any temporary instances created in the course<br>&gt;&gt; of an expression have their lifetime extended to the completion of the current<br>&gt;&gt; statement after which they are all deallocated en masse. This makes certain<br>&gt;&gt; types of language usage possible and easier to reason with.<br>&gt;&gt; <br>&gt;&gt; I’m bringing this up as I had a problem with some code crashing only when<br>&gt;&gt; compiled with release configuration and the problem could have been avoided<br>&gt;&gt; if Swift deferred deallocation to the end of a statement. While Swift’s ARC policy<br>&gt;&gt; is consistent in itself this seems to be a particular problem interfacing between<br>&gt;&gt; language/reference counting systems. My problem code was a Java-Swift Bridge.<br>&gt;&gt; <br>&gt;&gt; A contrived example:<br>&gt;&gt; <br>&gt;&gt; import Foundation<br>&gt;&gt; <br>&gt;&gt; protocol Storage {<br>&gt;&gt;    var fp: UnsafeMutablePointer&lt;FILE&gt; { get }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class FileStorage: Storage {<br>&gt;&gt; <br>&gt;&gt;    let fp: UnsafeMutablePointer&lt;FILE&gt;<br>&gt;&gt; <br>&gt;&gt;    init?(path: String, mode: String = &quot;w&quot;) {<br>&gt;&gt;        print(&quot;Opening&quot;)<br>&gt;&gt;        let fp = fopen(path, mode)<br>&gt;&gt;        if fp == nil {<br>&gt;&gt;            return nil<br>&gt;&gt;        }<br>&gt;&gt;        self.fp = fp!<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    deinit {<br>&gt;&gt;        print(&quot;Closing&quot;)<br>&gt;&gt;        fclose(fp)<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func save(string: String, to: Storage?) {<br>&gt;&gt;    if let data = string.data(using: String.Encoding.utf8) {<br>&gt;&gt;        print(&quot;Saving1&quot;)<br>&gt;&gt;        if let fp = to?.fp {<br>&gt;&gt;            print(&quot;Saving2&quot;)<br>&gt;&gt;            data.withUnsafeBytes {<br>&gt;&gt;                _ = fwrite($0, 1, data.count, fp)<br>&gt;&gt;            }<br>&gt;&gt;            print(&quot;Saving3&quot;)<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; save(string: &quot;Hello World\n&quot;, to: FileStorage(path: &quot;/tmp/a.txt&quot;))<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In debug configuration is prints:<br>&gt;&gt; Opening<br>&gt;&gt; Saving1<br>&gt;&gt; Saving2<br>&gt;&gt; Saving3<br>&gt;&gt; Closing<br>&gt;&gt; <br>&gt;&gt; Whereas in release configuration it prints:<br>&gt;&gt; Opening<br>&gt;&gt; Saving1<br>&gt;&gt; Closing &lt;!!!<br>&gt;&gt; Saving2<br>&gt;&gt; Saving3<br>&gt;&gt; <br>&gt;&gt; The optimiser is vigorously deallocating objects when they are no longer referenced regardless<br>&gt;&gt; of whether an variable referencing it is still in scope (In fairness this particular problem only occurs<br>&gt;&gt; for Optional augments of Protocols) but this behaviour seems to be implicit in the current language<br>&gt;&gt; spec. The alternative is to retain arguments themselves as I believe they are in Objective-C ARC.<br>&gt;&gt; <br>&gt;&gt; This would have been avoided if the temporary FileStorage instance has been considered to have<br>&gt;&gt; a lifetime up to the end of the statement calling function save() and hence the duration of the call.<br>&gt;&gt; This needed increase ARC overhead in any way. Just alter the timing of it to be more conservative.<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/e6e3e2e5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 21, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Sep 21, 2016, at 4:01 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; My contrived example was a bit flimsy. I’d better unpack the full story. The real<br>&gt; code I had problems with was based around the following Java instance wrapper:<br>&gt; <br>&gt; open class JNIObject: JNIObjectProtocol {<br>&gt; <br>&gt;     var _javaObject: jobject?<br>&gt; <br>&gt;     open var javaObject: jobject? {<br>&gt;         get {<br>&gt;             return _javaObject<br>&gt;         }<br>&gt;         set(newValue) {<br>&gt;             if newValue != _javaObject {<br>&gt;                 let oldValue = _javaObject<br>&gt;                 if newValue != nil {<br>&gt;                     _javaObject = JNI.api.NewGlobalRef( JNI.env, newValue )<br>&gt;                 }<br>&gt;                 else {<br>&gt;                     _javaObject = nil<br>&gt;                 }<br>&gt;                 if oldValue != nil {<br>&gt;                     JNI.api.DeleteGlobalRef( JNI.env, oldValue )<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     deinit {<br>&gt;         javaObject = nil<br>&gt;     }<br>&gt; <br>&gt; As a result the following transfer of a Java instance always worked:<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         let supr = CanvasBase()<br>&gt;         super.init( javaObject: supr.javaObject )<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; But the following only worked for debug compiles:<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         super.init( javaObject: CanvasBase().javaObject )<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br></p><p>True, though statement scope is also a pretty massive barrier that would prevent important optimizations that are valid for most classes. You might be able to avoid the bear trap by changing the `javaObject` interface into a callback-based interface, that ensures the object remains alive while you have access to it. Instead of:<br></p><p>protocol JNIObjectProtocol {<br>  var javaObject: jobject { get }<br>}<br></p><p>would it work to have something like this?<br></p><p>protocol JNIObjectProtocol {<br>  func withJavaObject(_ body: (jobject) -&gt; ())<br>}<br></p><p>-Joe<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 22, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Sep 21, 2016, at 4:01 PM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My contrived example was a bit flimsy. I’d better unpack the full story. The real<br>&gt; code I had problems with was based around the following Java instance wrapper:<br>&gt; <br>&gt; open class JNIObject: JNIObjectProtocol {<br>&gt; <br>&gt;     var _javaObject: jobject?<br>&gt; <br>&gt;     open var javaObject: jobject? {<br>&gt;         get {<br>&gt;             return _javaObject<br>&gt;         }<br>&gt;         set(newValue) {<br>&gt;             if newValue != _javaObject {<br>&gt;                 let oldValue = _javaObject<br>&gt;                 if newValue != nil {<br>&gt;                     _javaObject = JNI.api.NewGlobalRef( JNI.env, newValue )<br>&gt;                 }<br>&gt;                 else {<br>&gt;                     _javaObject = nil<br>&gt;                 }<br>&gt;                 if oldValue != nil {<br>&gt;                     JNI.api.DeleteGlobalRef( JNI.env, oldValue )<br>&gt;                 }<br>&gt;             }<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     deinit {<br>&gt;         javaObject = nil<br>&gt;     }<br>&gt; <br>&gt; As a result the following transfer of a Java instance always worked:<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         let supr = CanvasBase()<br>&gt;         super.init( javaObject: supr.javaObject )<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; But the following only worked for debug compiles:<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         super.init( javaObject: CanvasBase().javaObject )<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br></p><p>You are thinking about this the inverse way. That the first case works is an artifact of the optimizer failing to do a good enough job. Future improved ARC optimization can cause both to fail.<br></p><p>&gt; <br>&gt; John<br>&gt; <br>&gt; <br>&gt;&gt; On 21 Sep 2016, at 23:34, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 21, 2016, at 3:14 PM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I haven&#39;t used it myself, but is this the use case addressed by `withExtendedLifetime(_:_:)`?<br>&gt;&gt; <br>&gt;&gt; Yeah, if you want to vend resources managed by an object to consumers outside of that object like this, you need to use withExtendedLifetime to keep the object alive for as long as you&#39;re using the resources. A cleaner way to model this might be to put the class or protocol in control of handling the I/O to the file handle, instead of vending the file handle itself, so that the ownership semantics fall out more naturally:<br>&gt;&gt; <br>&gt;&gt; protocol Storage {<br>&gt;&gt;  func write(bytes: UnsafeRawPointer, count: Int)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; func save(string: String, to: Storage?) {<br>&gt;&gt;    if let data = string.data(using: String.Encoding.utf8) {<br>&gt;&gt;        data.withUnsafeBytes {<br>&gt;&gt;            _ = to?.write(bytes: $0, count: data.count)<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Sep 21, 2016 at 16:54 John Holdsworth via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Hi,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For complex statements in C++ any temporary instances created in the course<br>&gt;&gt;&gt; of an expression have their lifetime extended to the completion of the current<br>&gt;&gt;&gt; statement after which they are all deallocated en masse. This makes certain<br>&gt;&gt;&gt; types of language usage possible and easier to reason with.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m bringing this up as I had a problem with some code crashing only when<br>&gt;&gt;&gt; compiled with release configuration and the problem could have been avoided<br>&gt;&gt;&gt; if Swift deferred deallocation to the end of a statement. While Swift’s ARC policy<br>&gt;&gt;&gt; is consistent in itself this seems to be a particular problem interfacing between<br>&gt;&gt;&gt; language/reference counting systems. My problem code was a Java-Swift Bridge.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A contrived example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; import Foundation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Storage {<br>&gt;&gt;&gt;    var fp: UnsafeMutablePointer&lt;FILE&gt; { get }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class FileStorage: Storage {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    let fp: UnsafeMutablePointer&lt;FILE&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    init?(path: String, mode: String = &quot;w&quot;) {<br>&gt;&gt;&gt;        print(&quot;Opening&quot;)<br>&gt;&gt;&gt;        let fp = fopen(path, mode)<br>&gt;&gt;&gt;        if fp == nil {<br>&gt;&gt;&gt;            return nil<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;        self.fp = fp!<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    deinit {<br>&gt;&gt;&gt;        print(&quot;Closing&quot;)<br>&gt;&gt;&gt;        fclose(fp)<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func save(string: String, to: Storage?) {<br>&gt;&gt;&gt;    if let data = string.data(using: String.Encoding.utf8) {<br>&gt;&gt;&gt;        print(&quot;Saving1&quot;)<br>&gt;&gt;&gt;        if let fp = to?.fp {<br>&gt;&gt;&gt;            print(&quot;Saving2&quot;)<br>&gt;&gt;&gt;            data.withUnsafeBytes {<br>&gt;&gt;&gt;                _ = fwrite($0, 1, data.count, fp)<br>&gt;&gt;&gt;            }<br>&gt;&gt;&gt;            print(&quot;Saving3&quot;)<br>&gt;&gt;&gt;        }<br>&gt;&gt;&gt;    }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; save(string: &quot;Hello World\n&quot;, to: FileStorage(path: &quot;/tmp/a.txt&quot;))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In debug configuration is prints:<br>&gt;&gt;&gt; Opening<br>&gt;&gt;&gt; Saving1<br>&gt;&gt;&gt; Saving2<br>&gt;&gt;&gt; Saving3<br>&gt;&gt;&gt; Closing<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whereas in release configuration it prints:<br>&gt;&gt;&gt; Opening<br>&gt;&gt;&gt; Saving1<br>&gt;&gt;&gt; Closing &lt;!!!<br>&gt;&gt;&gt; Saving2<br>&gt;&gt;&gt; Saving3<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The optimiser is vigorously deallocating objects when they are no longer referenced regardless<br>&gt;&gt;&gt; of whether an variable referencing it is still in scope (In fairness this particular problem only occurs<br>&gt;&gt;&gt; for Optional augments of Protocols) but this behaviour seems to be implicit in the current language<br>&gt;&gt;&gt; spec. The alternative is to retain arguments themselves as I believe they are in Objective-C ARC.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would have been avoided if the temporary FileStorage instance has been considered to have<br>&gt;&gt;&gt; a lifetime up to the end of the statement calling function save() and hence the duration of the call.<br>&gt;&gt;&gt; This needed increase ARC overhead in any way. Just alter the timing of it to be more conservative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; John<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160922/ed057757/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>September 23, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On 22 Sep 2016, at 23:57, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; As a result the following transfer of a Java instance always worked:<br>&gt;&gt; <br>&gt;&gt;     init(imageProducer:ImageProducer) {<br>&gt;&gt;         let supr = CanvasBase()<br>&gt;&gt;         super.init( javaObject: supr.javaObject )<br>&gt;&gt;         image = createImage(imageProducer)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; But the following only worked for debug compiles:<br>&gt;&gt; <br>&gt;&gt;     init(imageProducer:ImageProducer) {<br>&gt;&gt;         super.init( javaObject: CanvasBase().javaObject )<br>&gt;&gt;         image = createImage(imageProducer)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br>&gt; <br>&gt; You are thinking about this the inverse way. That the first case works is an artifact of the optimizer failing to do a good enough job. Future improved ARC optimization can cause both to fail.<br></p><p>Were this the case I think it would be a step in the wrong direction. Swift is getting<br>very eager at deallocating objects hence all the &quot;withXYZ()&quot; methods of late which<br>seem like noise to me. Certainly, having something perform differently from debug<br>to release builds was not a feature! Viva la Statement Scope which solves all this.<br></p><p>John<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/f79db0d7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 22, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Sep 22, 2016, at 5:13 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 22 Sep 2016, at 23:57, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; As a result the following transfer of a Java instance always worked:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;         let supr = CanvasBase()<br>&gt;&gt;&gt;         super.init( javaObject: supr.javaObject )<br>&gt;&gt;&gt;         image = createImage(imageProducer)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But the following only worked for debug compiles:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;         super.init( javaObject: CanvasBase().javaObject )<br>&gt;&gt;&gt;         image = createImage(imageProducer)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br>&gt;&gt; <br>&gt;&gt; You are thinking about this the inverse way. That the first case works is an artifact of the optimizer failing to do a good enough job. Future improved ARC optimization can cause both to fail.<br>&gt; <br>&gt; Were this the case I think it would be a step in the wrong direction. Swift is getting<br>&gt; very eager at deallocating objects hence all the &quot;withXYZ()&quot; methods of late which<br>&gt; seem like noise to me. Certainly, having something perform differently from debug<br>&gt; to release builds was not a feature! Viva la Statement Scope which solves all this.<br></p><p>Statement scope is a brittle solution these problems. There&#39;s no shortage of C++ code that ends up subtly broken when it&#39;s refactored and ends up breaking due to hidden dependencies on statement scope. The precise lifetime semantics of C++ also prevent practically any optimization of nontrivial types without the explicit blessing of a handful of special cases like NRVO.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>September 23, 2016 at 11:00:00pm</p></header><div class="content"><p>Sorry, I’m being a little slow on the uptake here. So in future optimised Swift the<br>scope of a variable continuing an object doesn&#39;t determine it’s lifetime at all!<br>That seems quite a departure.<br></p><p>This means you have to be very careful with contained UnsafePointers indeed.<br>I got as far as needing to do:<br></p><p>    init(imageProducer:ImageProducer) {<br>        withExtendedLifetime(CanvasBase()) {<br>            super.init(javaObject: $0.javaObject)<br>        }<br>        image = createImage(imageProducer)<br>    }<br></p><p>..but the compiler was having none of it. For now the rigorous alternative is:<br></p><p>    init(imageProducer:ImageProducer) {<br>        var locals = [jobject]()<br>        super.init(javaObject: CanvasBase().localJavaObject(&amp;locals))<br>        JNI.DeleteLocalRef(locals[0])<br>        image = createImage(imageProducer)<br>    }<br></p><p>Some option to reinstate &quot;strong-ness&quot; of a var could be a more flexible alternative to<br>“withExtendedLifetime” for my particular use case.<br></p><p>    init(imageProducer:ImageProducer) {<br>        @strong var canvas = CanvasBase()<br>        super.init(javaObject: canvas.javaObject)<br>        image = createImage(imageProducer)<br>    }<br></p><p>John<br>  <br>&gt; On 23 Sep 2016, at 02:45, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Sep 22, 2016, at 5:13 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 22 Sep 2016, at 23:57, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As a result the following transfer of a Java instance always worked:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;&gt;        let supr = CanvasBase()<br>&gt;&gt;&gt;&gt;        super.init( javaObject: supr.javaObject )<br>&gt;&gt;&gt;&gt;        image = createImage(imageProducer)<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But the following only worked for debug compiles:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;&gt;        super.init( javaObject: CanvasBase().javaObject )<br>&gt;&gt;&gt;&gt;        image = createImage(imageProducer)<br>&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You are thinking about this the inverse way. That the first case works is an artifact of the optimizer failing to do a good enough job. Future improved ARC optimization can cause both to fail.<br>&gt;&gt; <br>&gt;&gt; Were this the case I think it would be a step in the wrong direction. Swift is getting<br>&gt;&gt; very eager at deallocating objects hence all the &quot;withXYZ()&quot; methods of late which<br>&gt;&gt; seem like noise to me. Certainly, having something perform differently from debug<br>&gt;&gt; to release builds was not a feature! Viva la Statement Scope which solves all this.<br>&gt; <br>&gt; Statement scope is a brittle solution these problems. There&#39;s no shortage of C++ code that ends up subtly broken when it&#39;s refactored and ends up breaking due to hidden dependencies on statement scope. The precise lifetime semantics of C++ also prevent practically any optimization of nontrivial types without the explicit blessing of a handful of special cases like NRVO.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160923/8e1d0dca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>September 24, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Sep 23, 2016, at 3:29 PM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I’m being a little slow on the uptake here. So in future optimised Swift the<br>&gt; scope of a variable continuing an object doesn&#39;t determine it’s lifetime at all!<br>&gt; That seems quite a departure.<br>&gt; <br>&gt; This means you have to be very careful with contained UnsafePointers indeed.<br>&gt; I got as far as needing to do:<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         withExtendedLifetime(CanvasBase()) {<br>&gt;             super.init(javaObject: $0.javaObject)<br>&gt;         }<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; ..but the compiler was having none of it.<br></p><p>What was the error? I am assuming that super.init was not in the same function?<br></p><p>&gt; For now the rigorous alternative is:<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         var locals = [jobject]()<br>&gt;         super.init(javaObject: CanvasBase().localJavaObject(&amp;locals))<br>&gt;         JNI.DeleteLocalRef(locals[0])<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; Some option to reinstate &quot;strong-ness&quot; of a var could be a more flexible alternative to<br>&gt; “withExtendedLifetime” for my particular use case.<br>&gt; <br>&gt;     init(imageProducer:ImageProducer) {<br>&gt;         @strong var canvas = CanvasBase()<br>&gt;         super.init(javaObject: canvas.javaObject)<br>&gt;         image = createImage(imageProducer)<br>&gt;     }<br>&gt; <br>&gt; John<br>&gt;   <br>&gt;&gt; On 23 Sep 2016, at 02:45, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sep 22, 2016, at 5:13 PM, John Holdsworth &lt;mac at johnholdsworth.com &lt;mailto:mac at johnholdsworth.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 Sep 2016, at 23:57, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As a result the following transfer of a Java instance always worked:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;&gt;&gt;        let supr = CanvasBase()<br>&gt;&gt;&gt;&gt;&gt;        super.init( javaObject: supr.javaObject )<br>&gt;&gt;&gt;&gt;&gt;        image = createImage(imageProducer)<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But the following only worked for debug compiles:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;    init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;&gt;&gt;        super.init( javaObject: CanvasBase().javaObject )<br>&gt;&gt;&gt;&gt;&gt;        image = createImage(imageProducer)<br>&gt;&gt;&gt;&gt;&gt;    }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Felt like a bit of a bear trap is all. Statement scope would avoid problems like this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You are thinking about this the inverse way. That the first case works is an artifact of the optimizer failing to do a good enough job. Future improved ARC optimization can cause both to fail.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Were this the case I think it would be a step in the wrong direction. Swift is getting<br>&gt;&gt;&gt; very eager at deallocating objects hence all the &quot;withXYZ()&quot; methods of late which<br>&gt;&gt;&gt; seem like noise to me. Certainly, having something perform differently from debug<br>&gt;&gt;&gt; to release builds was not a feature! Viva la Statement Scope which solves all this.<br>&gt;&gt; <br>&gt;&gt; Statement scope is a brittle solution these problems. There&#39;s no shortage of C++ code that ends up subtly broken when it&#39;s refactored and ends up breaking due to hidden dependencies on statement scope. The precise lifetime semantics of C++ also prevent practically any optimization of nontrivial types without the explicit blessing of a handful of special cases like NRVO.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160924/badd20f7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>September 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 25 Sep 2016, at 04:07, Michael Gottesman &lt;mgottesman at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;     init(imageProducer:ImageProducer) {<br>&gt;&gt;         withExtendedLifetime(CanvasBase()) {<br>&gt;&gt;             super.init(javaObject: $0.javaObject)<br>&gt;&gt;         }<br>&gt;&gt;         image = createImage(imageProducer)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; ..but the compiler was having none of it.<br>&gt; <br>&gt; What was the error? I am assuming that super.init was not in the same function?<br></p><p>Sorry, I should have included that in the email. The error was:<br></p><p>error: initializer chaining (&#39;super.init&#39;) cannot be nested in another expression<br></p><p>Is it possible to build in an exception for withExtendedLifetime?<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160925/feab26d9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Should Swift apply &quot;statement scope&quot; for ARC</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>September 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Sep 25, 2016, at 3:19 AM, John Holdsworth &lt;mac at johnholdsworth.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Sep 2016, at 04:07, Michael Gottesman &lt;mgottesman at apple.com &lt;mailto:mgottesman at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;     init(imageProducer:ImageProducer) {<br>&gt;&gt;&gt;         withExtendedLifetime(CanvasBase()) {<br>&gt;&gt;&gt;             super.init(javaObject: $0.javaObject)<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         image = createImage(imageProducer)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ..but the compiler was having none of it.<br>&gt;&gt; <br>&gt;&gt; What was the error? I am assuming that super.init was not in the same function?<br>&gt; <br>&gt; Sorry, I should have included that in the email. The error was:<br>&gt; <br>&gt; error: initializer chaining (&#39;super.init&#39;) cannot be nested in another expression<br>&gt; <br>&gt; Is it possible to build in an exception for withExtendedLifetime?<br></p><p>The block structure of `withExtendedLifetime` is a bit of a lie. It looks a bit goofy, but it&#39;s just as good to have an empty `withExtendedLifetime` call after the super.init:<br></p><p>init(imageProducer: ImageProducer) {<br>  let canvasBase = CanvasBase()<br>  super.init(javaObject: CanvasBase())<br>  withExtendedLifetime(canvasBase) {}<br>  image = createImage(imageProducer)<br>}<br></p><p>If you look at the standard library implementation of `withExtendedLifetime`, you&#39;ll see that all it does is `defer` a call to the underlying internal `_fixLifetime` operation:<br></p><p>https://github.com/apple/swift/blob/master/stdlib/public/core/LifetimeManager.swift#L15 &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/LifetimeManager.swift#L15&gt;<br></p><p>It may be a better design to just expose `fixLifetime` directly instead of trying to tie it to a scope.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160926/d034b67d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
