<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July 30, 2016 at 11:00:00am</p></header><div class="content"><p>I&#39;d like an *opt-in* way to verify and prevent *unintentional strong<br>references* in Swift.<br></p><p>This can be used to verify ownership structures, and ultimately avoid<br>retain cycles.<br></p><p>Read a draft proposal here:<br>https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md<br></p><p>TL;DR:<br></p><p>If you have any questions please read the proposal before asking here.<br></p><p>It&#39;s an opt-in attribute that defines a whitelist of types something can<br>own. For example:<br></p><p><br>@owns(TypeA, TypeB) struct TypeC { ... }<br></p><p><br>I wrote this a few months ago, but we weren&#39;t accepting additive proposals.<br>Now we&#39;re explicitly looking for something like this:<br></p><p>Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory<br>&gt; ownership model to Swift is highly desired by systems programmers and folks<br>&gt; who want predictable and deterministic performance (for example, in real<br>&gt; time audio processing code). More pertinent to the goals of Swift 4, this<br>&gt; feature is important because it fundamentally shapes the ABI. It informs<br>&gt; code generation for “inout&quot;, how low-level “addressors” work in the ABI,<br>&gt; impacts the Swift runtime, and will have a significant impact on the type<br>&gt; system and name mangling.<br></p><p><br>&gt;  - Chris<br>&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html&gt;<br></p><p><br>----<br></p><p>Here&#39;s a link to the version of the proposal<br>&lt;https://github.com/therealbnut/swift-evolution/commit/6ab167825d802c7826804e1957eb515d3009743a&gt;<br>when<br>I sent this email.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/ae9c98a5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>July 29, 2016 at 09:00:00pm</p></header><div class="content"><p>Seems to me that we can find similar information just from walking over a class&#39;s fields to build an ownership graph, and cause warnings/errors when you find a strong cycle.<br></p><p>How do you deal with type erasure?<br></p><p>&gt; protocol Foo {}<br>&gt; class A {<br>&gt; 	var foo: Foo<br>&gt; }<br>&gt; class B: Foo {<br>&gt; 	var a: A<br>&gt; }<br>&gt; // A and B can have a cycle through the Foo protocol<br></p><p>Also, how do you encode that your example&#39;s &quot;addCallback&quot; closure parameter can&#39;t have a strong reference to `self`?<br></p><p>Félix<br></p><p>&gt; Le 29 juil. 2016 à 18:42:11, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; I&#39;d like an opt-in way to verify and prevent unintentional strong references in Swift.<br>&gt; <br>&gt; This can be used to verify ownership structures, and ultimately avoid retain cycles.<br>&gt; <br>&gt; Read a draft proposal here:<br>&gt; https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md &lt;https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md&gt;<br>&gt; <br>&gt; TL;DR:<br>&gt; <br>&gt; If you have any questions please read the proposal before asking here.<br>&gt; <br>&gt; It&#39;s an opt-in attribute that defines a whitelist of types something can own. For example:<br>&gt; <br>&gt; @owns(TypeA, TypeB) struct TypeC { ... }<br>&gt; <br>&gt; I wrote this a few months ago, but we weren&#39;t accepting additive proposals. Now we&#39;re explicitly looking for something like this:<br>&gt; <br>&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory ownership model to Swift is highly desired by systems programmers and folks who want predictable and deterministic performance (for example, in real time audio processing code).  More pertinent to the goals of Swift 4, this feature is important because it fundamentally shapes the ABI.  It informs code generation for “inout&quot;, how low-level “addressors” work in the ABI, impacts the Swift runtime, and will have a significant impact on the type system and name mangling. <br>&gt; <br>&gt;  - Chris &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html&gt;<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; Here&#39;s a link to the version of the proposal &lt;https://github.com/therealbnut/swift-evolution/commit/6ab167825d802c7826804e1957eb515d3009743a&gt; when I sent this email.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160729/77386445/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Answers inline:<br></p><p>On Sat, Jul 30, 2016 at 2:17 PM, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br></p><p>&gt; Seems to me that we can find similar information just from walking over a<br>&gt; class&#39;s fields to build an ownership graph, and cause warnings/errors when<br>&gt; you find a strong cycle.<br>&gt;<br></p><p>This is true, but the intent is a whitelist, which is explicit and cannot<br>be automated. The intent is to catch as many unintentional strong<br>references as possible. If you walked the fields, methods, and all uses you<br>could get the same information, but you wouldn&#39;t know if they&#39;re<br>intentional.<br></p><p>It may be possible to imply that something owns fields, but the annotation<br>may need to be more specific than what that produces. For example:<br>closures, or collections.<br></p><p><br>&gt; How do you deal with type erasure?<br>&gt;<br></p><p>That&#39;s an interesting point. Currently it will behave much the same as<br>other collection types. The collection must designate ownership of its<br>associatedtypes. If that&#39;s a protocol then the ownership should be<br>inherited from the protocol.<br></p><p><br>&gt; protocol Foo {}<br>&gt; class A {<br>&gt; var foo: Foo<br>&gt; }<br>&gt; class B: Foo {<br>&gt; var a: A<br>&gt; }<br>&gt;<br>&gt; // A and B can have a cycle through the Foo protocol<br>&gt;<br>&gt;<br>&gt; Also, how do you encode that your example&#39;s &quot;addCallback&quot; closure<br>&gt; parameter can&#39;t have a strong reference to `self`?<br>&gt;<br></p><p>You encode it by not including it in the list of owned types. If you want<br>to be able to have a strong reference to self you&#39;d need `@owns(self)`.<br></p><p><br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 29 juil. 2016 à 18:42:11, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; I&#39;d like an *opt-in* way to verify and prevent *unintentional strong<br>&gt; references* in Swift.<br>&gt;<br>&gt; This can be used to verify ownership structures, and ultimately avoid<br>&gt; retain cycles.<br>&gt;<br>&gt; Read a draft proposal here:<br>&gt;<br>&gt; https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md<br>&gt;<br>&gt; TL;DR:<br>&gt;<br>&gt; If you have any questions please read the proposal before asking here.<br>&gt;<br>&gt; It&#39;s an opt-in attribute that defines a whitelist of types something can<br>&gt; own. For example:<br>&gt;<br>&gt; @owns(TypeA, TypeB) struct TypeC { ... }<br>&gt;<br>&gt; I wrote this a few months ago, but we weren&#39;t accepting additive<br>&gt; proposals. Now we&#39;re explicitly looking for something like this:<br>&gt;<br>&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory<br>&gt;&gt; ownership model to Swift is highly desired by systems programmers and folks<br>&gt;&gt; who want predictable and deterministic performance (for example, in real<br>&gt;&gt; time audio processing code). More pertinent to the goals of Swift 4, this<br>&gt;&gt; feature is important because it fundamentally shapes the ABI. It informs<br>&gt;&gt; code generation for “inout&quot;, how low-level “addressors” work in the ABI,<br>&gt;&gt; impacts the Swift runtime, and will have a significant impact on the type<br>&gt;&gt; system and name mangling.<br>&gt;<br>&gt;<br>&gt;&gt;  - Chris<br>&gt;&gt; &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html&gt;<br>&gt;<br>&gt;<br>&gt; ----<br>&gt;<br>&gt; Here&#39;s a link to the version of the proposal<br>&gt; &lt;https://github.com/therealbnut/swift-evolution/commit/6ab167825d802c7826804e1957eb515d3009743a&gt; when<br>&gt; I sent this email.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/21f00130/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 29, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jul 29, 2016, at 6:42 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I wrote this a few months ago, but we weren&#39;t accepting additive proposals. Now we&#39;re explicitly looking for something like this:<br>&gt; <br>&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory ownership model to Swift is highly desired by systems programmers and folks who want predictable and deterministic performance (for example, in real time audio processing code).  More pertinent to the goals of Swift 4, this feature is important because it fundamentally shapes the ABI.  It informs code generation for “inout&quot;, how low-level “addressors” work in the ABI, impacts the Swift runtime, and will have a significant impact on the type system and name mangling. <br></p><p>Memory ownership is about something slightly different than this.  In the context of Swift, the model we’re looking for is:<br></p><p>- You can completely ignore memory ownership features of the language, and get very far into development with Swift.  This is in stark contrast with Rust and Cyclone, which require you to grapple with it up front.  This means that in the Swift context, this will be more of a “power user” feature, instead of essential part of the model.<br></p><p>- You can choose to use the memory ownership features by adding extra annotations, giving better performance and control over ARC.  Right now we have very limited options for avoiding ARC overhead in critical loops, largely forcing you to drop down to unsafe constructs.  We’d prefer the model to be “you can add more annotations to your code to get better performance, allowing the compiler statically verify correctness instead of dynamically”.<br></p><p>- Memory ownership control is an extremely non-trivial feature, which will probably drive us to add first class move semantics and region types to the language.  This will also call for significant standard library extensions.  It will pay for this complexity by making it easy to ignore the complexity if you don’t want it, and by the fact that the standard library and other stuff can go much faster.<br></p><p>- As a Stage 2 feature, I can imagine an opt-in mode that “forces” the use of these features, for code that wants to guarantee deterministic performance.  This is what enables the use of swift in realtime audio applications, for example.<br></p><p>While some initial brainstorming and scoping has been done in this area, we’re far from having a concrete design.  We have a few folks who are experts at Rust that are helping contribute ideas and experience to this though.  <br></p><p>If you have more specific questions, feel free to ask about it.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160729/855433c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>July 30, 2016 at 02:00:00pm</p></header><div class="content"><p>Thanks for the detailed response :)<br></p><p>My mistake, I was thinking more in terms of managing a user&#39;s expectations<br>regarding ownership and avoiding retain cycles.<br></p><p>What you&#39;ve described sounds great. I imagine it should only affect this<br>proposal if the solution it provides adds additional checks for users<br>accidentally taking strong references.<br></p><p><br>On Sat, Jul 30, 2016 at 2:21 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jul 29, 2016, at 6:42 PM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I wrote this a few months ago, but we weren&#39;t accepting additive<br>&gt; proposals. Now we&#39;re explicitly looking for something like this:<br>&gt;<br>&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory<br>&gt;&gt; ownership model to Swift is highly desired by systems programmers and folks<br>&gt;&gt; who want predictable and deterministic performance (for example, in real<br>&gt;&gt; time audio processing code). More pertinent to the goals of Swift 4, this<br>&gt;&gt; feature is important because it fundamentally shapes the ABI. It informs<br>&gt;&gt; code generation for “inout&quot;, how low-level “addressors” work in the ABI,<br>&gt;&gt; impacts the Swift runtime, and will have a significant impact on the type<br>&gt;&gt; system and name mangling.<br>&gt;<br>&gt;<br>&gt; Memory ownership is about something slightly different than this.  In the<br>&gt; context of Swift, the model we’re looking for is:<br>&gt;<br>&gt; - You can completely ignore memory ownership features of the language, and<br>&gt; get very far into development with Swift.  This is in stark contrast with<br>&gt; Rust and Cyclone, which require you to grapple with it up front.  This<br>&gt; means that in the Swift context, this will be more of a “power user”<br>&gt; feature, instead of essential part of the model.<br>&gt;<br>&gt; - You can choose to use the memory ownership features by adding extra<br>&gt; annotations, giving better performance and control over ARC.  Right now we<br>&gt; have very limited options for avoiding ARC overhead in critical loops,<br>&gt; largely forcing you to drop down to unsafe constructs.  We’d prefer the<br>&gt; model to be “you can add more annotations to your code to get better<br>&gt; performance, allowing the compiler statically verify correctness instead of<br>&gt; dynamically”.<br>&gt;<br>&gt; - Memory ownership control is an extremely non-trivial feature, which will<br>&gt; probably drive us to add first class move semantics and region types to the<br>&gt; language.  This will also call for significant standard library<br>&gt; extensions.  It will pay for this complexity by making it easy to ignore<br>&gt; the complexity if you don’t want it, and by the fact that the standard<br>&gt; library and other stuff can go much faster.<br>&gt;<br>&gt; - As a Stage 2 feature, I can imagine an opt-in mode that “forces” the use<br>&gt; of these features, for code that wants to guarantee deterministic<br>&gt; performance.  This is what enables the use of swift in realtime audio<br>&gt; applications, for example.<br>&gt;<br>&gt; While some initial brainstorming and scoping has been done in this area,<br>&gt; we’re far from having a concrete design.  We have a few folks who are<br>&gt; experts at Rust that are helping contribute ideas and experience to this<br>&gt; though.<br>&gt;<br>&gt; If you have more specific questions, feel free to ask about it.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/81672e27/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/268d9a6a10ecdf70a24fdf96d03cec1c?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Colin Barrett</string> &lt;colin at springsandstruts.com&gt;<p>July 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jul 30, 2016, at 12:21 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Jul 29, 2016, at 6:42 PM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I wrote this a few months ago, but we weren&#39;t accepting additive proposals. Now we&#39;re explicitly looking for something like this:<br>&gt;&gt; <br>&gt;&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory ownership model to Swift is highly desired by systems programmers and folks who want predictable and deterministic performance (for example, in real time audio processing code).  More pertinent to the goals of Swift 4, this feature is important because it fundamentally shapes the ABI.  It informs code generation for “inout&quot;, how low-level “addressors” work in the ABI, impacts the Swift runtime, and will have a significant impact on the type system and name mangling. <br>&gt; <br>&gt; Memory ownership is about something slightly different than this.  In the context of Swift, the model we’re looking for is:<br>&gt; <br>&gt; - You can completely ignore memory ownership features of the language, and get very far into development with Swift.  This is in stark contrast with Rust and Cyclone, which require you to grapple with it up front.  This means that in the Swift context, this will be more of a “power user” feature, instead of essential part of the model.<br>&gt; <br>&gt; - You can choose to use the memory ownership features by adding extra annotations, giving better performance and control over ARC.  Right now we have very limited options for avoiding ARC overhead in critical loops, largely forcing you to drop down to unsafe constructs.  We’d prefer the model to be “you can add more annotations to your code to get better performance, allowing the compiler statically verify correctness instead of dynamically”.<br></p><p>Has any thought been giving to opting in something analogous in the other direction—i.e. less performant, but less work for the programer? Specifically, I’ve long thought that an annotation opting into a runtime cycle collector (a la http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf &lt;http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf&gt;) would be very helpful for situations where, as you mention, performance is not (currently) critical.<br></p><p>-Colin<br></p><p>&gt; - Memory ownership control is an extremely non-trivial feature, which will probably drive us to add first class move semantics and region types to the language.  This will also call for significant standard library extensions.  It will pay for this complexity by making it easy to ignore the complexity if you don’t want it, and by the fact that the standard library and other stuff can go much faster.<br>&gt; <br>&gt; - As a Stage 2 feature, I can imagine an opt-in mode that “forces” the use of these features, for code that wants to guarantee deterministic performance.  This is what enables the use of swift in realtime audio applications, for example.<br>&gt; <br>&gt; While some initial brainstorming and scoping has been done in this area, we’re far from having a concrete design.  We have a few folks who are experts at Rust that are helping contribute ideas and experience to this though.  <br>&gt; <br>&gt; If you have more specific questions, feel free to ask about it.<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/53617cc5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 30, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jul 30, 2016, at 3:21 PM, Colin Barrett &lt;colin at springsandstruts.com&gt; wrote:<br>&gt; <br>&gt;&gt; - You can choose to use the memory ownership features by adding extra annotations, giving better performance and control over ARC.  Right now we have very limited options for avoiding ARC overhead in critical loops, largely forcing you to drop down to unsafe constructs.  We’d prefer the model to be “you can add more annotations to your code to get better performance, allowing the compiler statically verify correctness instead of dynamically”.<br>&gt; <br>&gt; Has any thought been giving to opting in something analogous in the other direction—i.e. less performant, but less work for the programer? Specifically, I’ve long thought that an annotation opting into a runtime cycle collector (a la http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf &lt;http://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon01Concurrent.pdf&gt;) would be very helpful for situations where, as you mention, performance is not (currently) critical.<br></p><p>We have certainly discussed cycle collectors in the past, even in the context of Objective-C, and have concluded that it would be a bad idea for several reasons.  If you’d like to discuss that, please start a new thread, thanks!<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/9b4371dc/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>RFC: Preventing Retain Cycles (Memory Ownership Model)</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July 30, 2016 at 11:00:00am</p></header><div class="content"><p>This is very interesting, but it&#39;ll probably be a little while before I can fully get my head around it.<br></p><p>One query though; an example mentioned is adding @owns(Element) to the Generator protocol, but associated types feel a little different to me; you mention using the strong keyword as an alternative, but I wonder if that might actually be a better fit for the associated type case, while @owns works elsewhere, or perhaps strong could even be made a shorthand for simpler cases? Just thinking out loud I guess, it would be nice to hear the thought process around associated types; most (possibly all I don&#39;t remember) cases in which I&#39;ve used associated types it has been for strong references, so it seems like that should be as easy as possible to do under the new opt-in approach.<br></p><p>But yeah, I generally agree that this ought to be opt-in, as it&#39;s an area I do stumble upon quite a bit myself (in many languages).<br></p><p>&gt; On 30 Jul 2016, at 02:42, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;d like an opt-in way to verify and prevent unintentional strong references in Swift.<br>&gt; <br>&gt; This can be used to verify ownership structures, and ultimately avoid retain cycles.<br>&gt; <br>&gt; Read a draft proposal here:<br>&gt; https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md &lt;https://github.com/therealbnut/swift-evolution/blob/therealbnut-explicit-ownership/proposals/NNNN-explicit-ownership-type-attribute.md&gt;<br>&gt; <br>&gt; TL;DR:<br>&gt; <br>&gt; If you have any questions please read the proposal before asking here.<br>&gt; <br>&gt; It&#39;s an opt-in attribute that defines a whitelist of types something can own. For example:<br>&gt; <br>&gt; @owns(TypeA, TypeB) struct TypeC { ... }<br>&gt; <br>&gt; I wrote this a few months ago, but we weren&#39;t accepting additive proposals. Now we&#39;re explicitly looking for something like this:<br>&gt; <br>&gt; Memory ownership model: Adding an (opt-in) Cyclone/Rust inspired memory ownership model to Swift is highly desired by systems programmers and folks who want predictable and deterministic performance (for example, in real time audio processing code).  More pertinent to the goals of Swift 4, this feature is important because it fundamentally shapes the ABI.  It informs code generation for “inout&quot;, how low-level “addressors” work in the ABI, impacts the Swift runtime, and will have a significant impact on the type system and name mangling. <br>&gt; <br>&gt;  - Chris &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160725/025676.html&gt;<br>&gt; <br>&gt; ----<br>&gt; <br>&gt; Here&#39;s a link to the version of the proposal &lt;https://github.com/therealbnut/swift-evolution/commit/6ab167825d802c7826804e1957eb515d3009743a&gt; when I sent this email.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160730/2075016d/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
