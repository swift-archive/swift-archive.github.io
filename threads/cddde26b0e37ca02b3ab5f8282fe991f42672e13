<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 01:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Many times, I came across a scenario where I had to filter an array with a<br>&gt;&gt; condition and filter the same array with opposite of that condition. For<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt;<br>&gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt;<br>&gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt; based on a condition?<br>&gt;<br>&gt; Well, you need a stable partition for this if you care about ordering<br>&gt; (see<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299)<br>&gt; but then you can do <br>&gt;<br>&gt; var parts = values<br>&gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;<br>&gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt; prototype that would let you write:<br>&gt;<br>&gt;   let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;   let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;   let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br></p><p>Hmm, come to think of it, Nate, maybe there should also be a more<br>convenient way to get the two partitions from the result.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb88fb44326d382e397bcd39a1282fba?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>gadiraju praneeth</string> &lt;praneethgadiraju at gmail.com&gt;<p>June  8, 2016 at 03:00:00pm</p></header><div class="content"><p>I added an extension to do this, something like this:<br></p><p>extension Array {<br></p><p>    func filterSplit(includeElement: (Element) -&gt; Bool) -&gt; ([Element],<br>[Element]) {<br></p><p>        var elementsSatisfyingCondition = [Element]()<br></p><p>        var elementsNotSatisfyingCondition = [Element]()<br></p><p><br></p><p>        self.forEach { element in<br></p><p>            if includeElement(element)<br>{ elementsSatisfyingCondition.append(element) }<br></p><p>            else { elementsNotSatisfyingCondition.append(element) }<br></p><p>        }<br></p><p><br></p><p>        return (elementsSatisfyingCondition, elementsNotSatisfyingCondition)<br></p><p>    }<br></p><p>}<br></p><p><br>that way you can right away do: values.filterSplit { &lt;yourPredicateBlock&gt; }<br></p><p><br></p><p>On Wed, Jun 8, 2016 at 3:40 PM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; Many times, I came across a scenario where I had to filter an array<br>&gt; with a<br>&gt; &gt;&gt; condition and filter the same array with opposite of that condition. For<br>&gt; &gt;&gt; example:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt; &gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt; &gt;&gt; based on a condition?<br>&gt; &gt;<br>&gt; &gt; Well, you need a stable partition for this if you care about ordering<br>&gt; &gt; (see<br>&gt; &gt;<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299<br>&gt; )<br>&gt; &gt; but then you can do<br>&gt; &gt;<br>&gt; &gt; var parts = values<br>&gt; &gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt; &gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt; &gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt; &gt;<br>&gt; &gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt; &gt; prototype that would let you write:<br>&gt; &gt;<br>&gt; &gt;   let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt; &gt;   let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt; &gt;   let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt;<br>&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt; convenient way to get the two partitions from the result.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/4d99da9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb88fb44326d382e397bcd39a1282fba?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>gadiraju praneeth</string> &lt;praneethgadiraju at gmail.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>Its values.filterSplit { $0 % 2 == 0 } in this case<br></p><p>On Wed, Jun 8, 2016 at 3:59 PM, gadiraju praneeth &lt;<br>praneethgadiraju at gmail.com&gt; wrote:<br></p><p>&gt; I added an extension to do this, something like this:<br>&gt;<br>&gt; extension Array {<br>&gt;<br>&gt;     func filterSplit(includeElement: (Element) -&gt; Bool) -&gt; ([Element],<br>&gt; [Element]) {<br>&gt;<br>&gt;         var elementsSatisfyingCondition = [Element]()<br>&gt;<br>&gt;         var elementsNotSatisfyingCondition = [Element]()<br>&gt;<br>&gt;<br>&gt;<br>&gt;         self.forEach { element in<br>&gt;<br>&gt;             if includeElement(element)<br>&gt; { elementsSatisfyingCondition.append(element) }<br>&gt;<br>&gt;             else { elementsNotSatisfyingCondition.append(element) }<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;<br>&gt;         return<br>&gt; (elementsSatisfyingCondition, elementsNotSatisfyingCondition)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; that way you can right away do: values.filterSplit { &lt;yourPredicateBlock&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 3:40 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Many times, I came across a scenario where I had to filter an array<br>&gt;&gt; with a<br>&gt;&gt; &gt;&gt; condition and filter the same array with opposite of that condition.<br>&gt;&gt; For<br>&gt;&gt; &gt;&gt; example:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt; &gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt; &gt;&gt; based on a condition?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, you need a stable partition for this if you care about ordering<br>&gt;&gt; &gt; (see<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299<br>&gt;&gt; )<br>&gt;&gt; &gt; but then you can do<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var parts = values<br>&gt;&gt; &gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt;&gt; &gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt;&gt; &gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt;&gt; &gt; prototype that would let you write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;&gt; &gt;   let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;&gt; &gt;   let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt;&gt;<br>&gt;&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt;&gt; convenient way to get the two partitions from the result.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/12538ff6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, gadiraju praneeth &lt;praneethgadiraju-AT-gmail.com&gt; wrote:<br></p><p>&gt; I added an extension to do this, something like this:<br>&gt;<br>&gt; extension Array {<br>&gt;<br>&gt;     func filterSplit(includeElement: (Element) -&gt; Bool) -&gt; ([Element],<br>&gt; [Element]) {<br>&gt;<br>&gt;         var elementsSatisfyingCondition = [Element]()<br>&gt;<br>&gt;         var elementsNotSatisfyingCondition = [Element]()<br>&gt;<br>&gt;         self.forEach { element in<br>&gt;<br>&gt;             if includeElement(element)<br>&gt; { elementsSatisfyingCondition.append(element) }<br>&gt;<br>&gt;             else { elementsNotSatisfyingCondition.append(element) }<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;         return (elementsSatisfyingCondition, elementsNotSatisfyingCondition)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt; that way you can right away do: values.filterSplit {<br>&gt; &lt;yourPredicateBlock&gt; }<br></p><p>Yes, it&#39;s convenient.  Its efficiency is suboptimal, though, unless you<br>really need the results to be Arrays (rather than, say ArraySlices).<br></p><p>&gt;<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 3:40 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Many times, I came across a scenario where I had to filter an array<br>&gt;&gt; with a<br>&gt;&gt; &gt;&gt; condition and filter the same array with opposite of that condition. For<br>&gt;&gt; &gt;&gt; example:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt; &gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt; &gt;&gt; based on a condition?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, you need a stable partition for this if you care about ordering<br>&gt;&gt; &gt; (see<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299<br>&gt;&gt; )<br>&gt;&gt; &gt; but then you can do<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var parts = values<br>&gt;&gt; &gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt;&gt; &gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt;&gt; &gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt;&gt; &gt; prototype that would let you write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;&gt; &gt;   let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;&gt; &gt;   let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt;&gt;<br>&gt;&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt;&gt; convenient way to get the two partitions from the result.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>June  9, 2016 at 06:00:00am</p></header><div class="content"><p>+1 from me for adding this method to the standard library.<br>I would prefer the name `partition(by:)` for it, though, under which I know it from other languages and which is quite fitting, I think.<br></p><p>-Thorsten <br></p><p>&gt; Am 08.06.2016 um 22:59 schrieb gadiraju praneeth via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I added an extension to do this, something like this:<br>&gt; extension Array {<br>&gt;     func filterSplit(includeElement: (Element) -&gt; Bool) -&gt; ([Element], [Element]) {<br>&gt;         var elementsSatisfyingCondition = [Element]()<br>&gt;         var elementsNotSatisfyingCondition = [Element]()<br>&gt;         <br>&gt;         self.forEach { element in<br>&gt;             if includeElement(element) { elementsSatisfyingCondition.append(element) }<br>&gt;             else { elementsNotSatisfyingCondition.append(element) }<br>&gt;         }<br>&gt;         <br>&gt;         return (elementsSatisfyingCondition, elementsNotSatisfyingCondition)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; that way you can right away do: values.filterSplit { &lt;yourPredicateBlock&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Jun 8, 2016 at 3:40 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Many times, I came across a scenario where I had to filter an array with a<br>&gt;&gt; &gt;&gt; condition and filter the same array with opposite of that condition. For<br>&gt;&gt; &gt;&gt; example:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt; &gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt; &gt;&gt; based on a condition?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, you need a stable partition for this if you care about ordering<br>&gt;&gt; &gt; (see<br>&gt;&gt; &gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299)<br>&gt;&gt; &gt; but then you can do<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var parts = values<br>&gt;&gt; &gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt;&gt; &gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt;&gt; &gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt;&gt; &gt; prototype that would let you write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;&gt; &gt;   let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;&gt; &gt;   let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt;&gt; <br>&gt;&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt;&gt; convenient way to get the two partitions from the result.<br>&gt;&gt; <br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/5c6cedd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb88fb44326d382e397bcd39a1282fba?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>gadiraju praneeth</string> &lt;praneethgadiraju at gmail.com&gt;<p>June  9, 2016 at 06:00:00am</p></header><div class="content"><p>Agree with the name. Also, the implementation could be better at Sequence<br>level rather than specific to Array, just like filter<br></p><p>On Wed, Jun 8, 2016 at 11:54 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt; +1 from me for adding this method to the standard library.<br>&gt; I would prefer the name `partition(by:)` for it, though, under which I<br>&gt; know it from other languages and which is quite fitting, I think.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 08.06.2016 um 22:59 schrieb gadiraju praneeth via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I added an extension to do this, something like this:<br>&gt;<br>&gt; extension Array {<br>&gt;<br>&gt;     func filterSplit(includeElement: (Element) -&gt; Bool) -&gt; ([Element],<br>&gt; [Element]) {<br>&gt;<br>&gt;         var elementsSatisfyingCondition = [Element]()<br>&gt;<br>&gt;         var elementsNotSatisfyingCondition = [Element]()<br>&gt;<br>&gt;<br>&gt;<br>&gt;         self.forEach { element in<br>&gt;<br>&gt;             if includeElement(element)<br>&gt; { elementsSatisfyingCondition.append(element) }<br>&gt;<br>&gt;             else { elementsNotSatisfyingCondition.append(element) }<br>&gt;<br>&gt;         }<br>&gt;<br>&gt;<br>&gt;<br>&gt;         return<br>&gt; (elementsSatisfyingCondition, elementsNotSatisfyingCondition)<br>&gt;<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt;<br>&gt;<br>&gt; that way you can right away do: values.filterSplit { &lt;yourPredicateBlock&gt; }<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Wed, Jun 8, 2016 at 3:40 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Many times, I came across a scenario where I had to filter an array<br>&gt;&gt; with a<br>&gt;&gt; &gt;&gt; condition and filter the same array with opposite of that condition.<br>&gt;&gt; For<br>&gt;&gt; &gt;&gt; example:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt; &gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt; &gt;&gt; based on a condition?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Well, you need a stable partition for this if you care about ordering<br>&gt;&gt; &gt; (see<br>&gt;&gt; &gt;<br>&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299<br>&gt;&gt; )<br>&gt;&gt; &gt; but then you can do<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var parts = values<br>&gt;&gt; &gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt;&gt; &gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt;&gt; &gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt;&gt; &gt; prototype that would let you write:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;   let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;&gt; &gt;   let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;&gt; &gt;   let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt;&gt;<br>&gt;&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt;&gt; convenient way to get the two partitions from the result.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160609/64ece822/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5f463dd4e7af28b64ad8f0e032ee82dc?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>Nate Cook</string> &lt;natecook at gmail.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 8, 2016, at 3:40 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Many times, I came across a scenario where I had to filter an array with a<br>&gt;&gt;&gt; condition and filter the same array with opposite of that condition. For<br>&gt;&gt;&gt; example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt;&gt; based on a condition?<br>&gt;&gt; <br>&gt;&gt; Well, you need a stable partition for this if you care about ordering<br>&gt;&gt; (see<br>&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299)<br>&gt;&gt; but then you can do <br>&gt;&gt; <br>&gt;&gt; var parts = values<br>&gt;&gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt;&gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt;&gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;&gt; <br>&gt;&gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt;&gt; prototype that would let you write:<br>&gt;&gt; <br>&gt;&gt;  let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;&gt;  let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;&gt;  let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br></p><p>Mine was for the result of the &#39;rotated&#39; methods, but should work for the partitioning ones, too. It&#39;s not as clear to me what the benefit of the &quot;lazy&quot; partitioning in that Algorithm.swift is—wouldn&#39;t it be better to wrap a collection around two lazy filter sequences?<br></p><p>Here is a quick proof of concept of &#39;divided&#39; and &#39;partitioned&#39; methods: http://swiftlang.ng.bluemix.net/#/repl/57588cbda79b317716f02e04 <br></p><p>&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt; convenient way to get the two partitions from the result.<br></p><p>Definitely!<br></p><p>Nate<br></p><p>&gt; -- <br>&gt; Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June  8, 2016 at 02:00:00pm</p></header><div class="content"><p>on Wed Jun 08 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 8, 2016, at 3:40 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Many times, I came across a scenario where I had to filter an array with a<br>&gt;&gt;&gt;&gt; condition and filter the same array with opposite of that condition. For<br>&gt;&gt;&gt;&gt; example:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt;&gt;&gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt;&gt;&gt;&gt; based on a condition?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, you need a stable partition for this if you care about ordering<br>&gt;&gt;&gt; (see<br>&gt;&gt;&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299)<br>&gt;&gt;&gt; but then you can do <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; var parts = values<br>&gt;&gt;&gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt;&gt;&gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt;&gt;&gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt;&gt;&gt; prototype that would let you write:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt;&gt;&gt;  let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt;&gt;&gt;  let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt;<br>&gt; Mine was for the result of the &#39;rotated&#39; methods, but should work for<br>&gt; the partitioning ones, too. It&#39;s not as clear to me what the benefit<br>&gt; of the &quot;lazy&quot; partitioning in that Algorithm.swift is<br></p><p>Just to pass “laziness” on from the result, so further computations can<br>also be lazy.<br></p><p>&gt; —wouldn&#39;t it be better to wrap a collection around two lazy filter<br>&gt; sequences?<br></p><p>Perhaps something like a<br>LazyFlatMap&lt;CollectionOfTwo&lt;LazyFilterCollection&gt;&gt; would be better, but<br>I have the concern that this would evaluate the predicate 2N times for<br>each traversal.<br></p><p>&gt; Here is a quick proof of concept of &#39;divided&#39; and &#39;partitioned&#39;<br>&gt; methods:<br>&gt; http://swiftlang.ng.bluemix.net/#/repl/57588cbda79b317716f02e04<br>&gt;<br>&gt;&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt;&gt; convenient way to get the two partitions from the result.<br>&gt;<br>&gt; Definitely!<br>&gt;<br>&gt; Nate<br>&gt;<br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bb88fb44326d382e397bcd39a1282fba?s=50"></div><header><strong>Proposal: Filter split extension on Sequence to return tuple of sequences that meet criteria and that do not</strong> from <string>gadiraju praneeth</string> &lt;praneethgadiraju at gmail.com&gt;<p>June  8, 2016 at 04:00:00pm</p></header><div class="content"><p>I implemented something similar with two filters initially, but because of<br>2N vs N I changed it<br></p><p>On Wednesday, June 8, 2016, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jun 08 2016, Nate Cook &lt;natecook-AT-gmail.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Jun 8, 2016, at 3:40 PM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Wed Jun 08 2016, Dave Abrahams &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; on Wed Jun 08 2016, gadiraju praneeth &lt;swift-evolution at swift.org<br>&gt; &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Many times, I came across a scenario where I had to filter an array<br>&gt; with a<br>&gt; &gt;&gt;&gt;&gt; condition and filter the same array with opposite of that condition.<br>&gt; For<br>&gt; &gt;&gt;&gt;&gt; example:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; let values = [2, 4, 3, 5, 6, 9]<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; let divisibleByTwo = values.filter { $0 % 2 == 0 }<br>&gt; &gt;&gt;&gt;&gt; let notDivisibleByTwo = values.filter { $0 % 2 != 0 }<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Is there a way currently where we can filter the array into two arrays<br>&gt; &gt;&gt;&gt;&gt; based on a condition?<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Well, you need a stable partition for this if you care about ordering<br>&gt; &gt;&gt;&gt; (see<br>&gt; &gt;&gt;&gt;<br>&gt; https://github.com/apple/swift/blob/master/test/Prototypes/Algorithms.swift#L299<br>&gt; )<br>&gt; &gt;&gt;&gt; but then you can do<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; var parts = values<br>&gt; &gt;&gt;&gt; let mid = values.stablePartition { $0 % 2 == 0 }<br>&gt; &gt;&gt;&gt; let divisibleByTwo = parts.prefix(upTo: mid)<br>&gt; &gt;&gt;&gt; let notDivisibleByTwo = parts.suffix(from: mid)<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; Nate Cook has an enhancement to the result of stablyPartitioned in that<br>&gt; &gt;&gt;&gt; prototype that would let you write:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;  let parts = values.stablyPartitioned { $0 % 2 == 0 }<br>&gt; &gt;&gt;&gt;  let divisibleByTwo = parts.prefix(upTo: parts.partitionPoint)<br>&gt; &gt;&gt;&gt;  let notDivisibleByTwo = parts.suffix(from: parts.partitionPoint)<br>&gt; &gt;<br>&gt; &gt; Mine was for the result of the &#39;rotated&#39; methods, but should work for<br>&gt; &gt; the partitioning ones, too. It&#39;s not as clear to me what the benefit<br>&gt; &gt; of the &quot;lazy&quot; partitioning in that Algorithm.swift is<br>&gt;<br>&gt; Just to pass “laziness” on from the result, so further computations can<br>&gt; also be lazy.<br>&gt;<br>&gt; &gt; —wouldn&#39;t it be better to wrap a collection around two lazy filter<br>&gt; &gt; sequences?<br>&gt;<br>&gt; Perhaps something like a<br>&gt; LazyFlatMap&lt;CollectionOfTwo&lt;LazyFilterCollection&gt;&gt; would be better, but<br>&gt; I have the concern that this would evaluate the predicate 2N times for<br>&gt; each traversal.<br>&gt;<br>&gt; &gt; Here is a quick proof of concept of &#39;divided&#39; and &#39;partitioned&#39;<br>&gt; &gt; methods:<br>&gt; &gt; http://swiftlang.ng.bluemix.net/#/repl/57588cbda79b317716f02e04<br>&gt; &gt;<br>&gt; &gt;&gt; Hmm, come to think of it, Nate, maybe there should also be a more<br>&gt; &gt;&gt; convenient way to get the two partitions from the result.<br>&gt; &gt;<br>&gt; &gt; Definitely!<br>&gt; &gt;<br>&gt; &gt; Nate<br>&gt; &gt;<br>&gt; &gt;&gt; --<br>&gt; &gt;&gt; Dave<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160608/5b690dd8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
