<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/58f35424e978e5dd5dd8ee2200867f3b?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Dzianis Fedarenka</string> &lt;f.dz.v.gh at gmail.com&gt;<p>December 17, 2015 at 11:00:00pm</p></header><div class="content"><p>&gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote: <br>&gt;&gt;  <br>&gt;&gt; Hi, <br>&gt;&gt;  <br>&gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote: <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple. <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well. <br>&gt;&gt; <br>&gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue). <br>&gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br></p><p>I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br></p><p>1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br>2) Does anyone have long term vision about how to inject platform specific code into current implementation of dispatch_source? As far as I’ve read the source it’s heavily bound with kqueue semantics and «#ifdef»-way seems to be completely messy..(<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be4c3c3b76631a155e1358db48066692?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Tony Parker</string> &lt;anthony.parker at apple.com&gt;<p>December 17, 2015 at 12:00:00pm</p></header><div class="content"><p>Hi Dzianis,<br></p><p>&gt; On Dec 17, 2015, at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi, <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue). <br>&gt;&gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br>&gt; <br>&gt; I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br>&gt; <br>&gt; 1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br></p><p>For what it’s worth, we went ahead and based CFRunLoop.c on Linux on top of epoll: <br></p><p>https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/RunLoop.subproj/CFRunLoop.c &lt;https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/RunLoop.subproj/CFRunLoop.c&gt;<br></p><p>https://github.com/apple/swift-corelibs-foundation/commit/d594de1bdd7f10a558e30b92809420303ded0a6a#diff-9739b4f43fc59b19e677f9e3f835d159 &lt;https://github.com/apple/swift-corelibs-foundation/commit/d594de1bdd7f10a558e30b92809420303ded0a6a#diff-9739b4f43fc59b19e677f9e3f835d159&gt;<br></p><p>I think it makes total sense for dispatch’s SPI for CF to simply return an eventfd.<br></p><p>- Tony<br></p><p>&gt; 2) Does anyone have long term vision about how to inject platform specific code into current implementation of dispatch_source? As far as I’ve read the source it’s heavily bound with kqueue semantics and «#ifdef»-way seems to be completely messy..(<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151217/ccce14d4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/562c2299436b75df013fb428ddf90ce6?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Pierre Habouzit</string> &lt;pierre at habouzit.net&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 12:40 PM, Tony Parker via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Dzianis,<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi, <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue). <br>&gt;&gt;&gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br>&gt;&gt; <br>&gt;&gt; I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br>&gt;&gt; <br>&gt;&gt; 1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br>&gt; <br>&gt; For what it’s worth, we went ahead and based CFRunLoop.c on Linux on top of epoll: <br>&gt; <br>&gt; https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/RunLoop.subproj/CFRunLoop.c<br>&gt; <br>&gt; https://github.com/apple/swift-corelibs-foundation/commit/d594de1bdd7f10a558e30b92809420303ded0a6a#diff-9739b4f43fc59b19e677f9e3f835d159<br>&gt; <br>&gt; I think it makes total sense for dispatch’s SPI for CF to simply return an eventfd.<br></p><p>it’s exactly what we want for runloop tied queues. The mach port that is used for this on Darwin receives messages only to break out of the mach_msg() call, but the handler of the message is a void function: _dispatch_wakeup_runloop_thread().<br></p><p>The good news is that a mach_port is an uint32_t and eventfd would be an int, so as far as storage is concerned, everything is fine.<br></p><p>I would have the _dispatch_get_main_queue_port_4CF / _dispatch_runloop_root_queue_get_port_4CF return an eventfd, and adapt the code that disposes of it. This is a IMO straightforward patch that should be written e.g. that way:<br></p><p>#if HAVE_MACH<br>// current OS X Code<br>#elif HAVE_EVENTFD<br>// linux port<br>#else<br>#error should not happen<br>#endif<br></p><p>And also have:<br></p><p>DISPATCH_COCOA_COMPAT be set to one on linux (until it is, you don’t get the main queue and runloop tied queues).<br></p><p><br>The one murky thing is that someone has to *consume* what’s in that eventfd, today, it’s implicit with mach because MiG will call dispatch’s _dispatch_wakeup_runloop_thread() for it (corresponding to the wakeup_runloop_thread routine in protocol.defs), but for linux, it’s probably best if CF knows that it’s an eventfd and it has to eventfd_read() from it to consume the event before it’s calling _dispatch_runloop_root_queue_perform_4CF(). The alternative is for _dispatch_runloop_root_queue_perform_4CF() to do that read in a non blocking way, but for the cases when several things have been queued on the runloop queue and have been coalesced in a single eventfd delivery, it’s a bit dumb to pay a syscall per dequeue.<br></p><p>On Mach the coalescing happens because the port has a queue width of 1 and incoming messages are dropped when the port is full.<br></p><p><br>-Pierre<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/562c2299436b75df013fb428ddf90ce6?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Pierre Habouzit</string> &lt;pierre at habouzit.net&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>-Pierre<br></p><p>&gt; On Dec 17, 2015, at 1:35 PM, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 12:40 PM, Tony Parker via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Dzianis,<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue). <br>&gt;&gt;&gt;&gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br>&gt;&gt; <br>&gt;&gt; For what it’s worth, we went ahead and based CFRunLoop.c on Linux on top of epoll: <br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/RunLoop.subproj/CFRunLoop.c<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-corelibs-foundation/commit/d594de1bdd7f10a558e30b92809420303ded0a6a#diff-9739b4f43fc59b19e677f9e3f835d159<br>&gt;&gt; <br>&gt;&gt; I think it makes total sense for dispatch’s SPI for CF to simply return an eventfd.<br>&gt; <br>&gt; it’s exactly what we want for runloop tied queues. The mach port that is used for this on Darwin receives messages only to break out of the mach_msg() call, but the handler of the message is a void function: _dispatch_wakeup_runloop_thread().<br>&gt; <br>&gt; The good news is that a mach_port is an uint32_t and eventfd would be an int, so as far as storage is concerned, everything is fine.<br>&gt; <br>&gt; I would have the _dispatch_get_main_queue_port_4CF / _dispatch_runloop_root_queue_get_port_4CF return an eventfd, and adapt the code that disposes of it. This is a IMO straightforward patch that should be written e.g. that way:<br>&gt; <br>&gt; #if HAVE_MACH<br>&gt; // current OS X Code<br>&gt; #elif HAVE_EVENTFD<br>&gt; // linux port<br>&gt; #else<br>&gt; #error should not happen<br>&gt; #endif<br>&gt; <br>&gt; And also have:<br>&gt; <br>&gt; DISPATCH_COCOA_COMPAT be set to one on linux (until it is, you don’t get the main queue and runloop tied queues).<br>&gt; <br>&gt; <br>&gt; The one murky thing is that someone has to *consume* what’s in that eventfd, today, it’s implicit with mach because MiG will call dispatch’s _dispatch_wakeup_runloop_thread() for it (corresponding to the wakeup_runloop_thread routine in protocol.defs), but for linux, it’s probably best if CF knows that it’s an eventfd and it has to eventfd_read() from it to consume the event before it’s calling _dispatch_runloop_root_queue_perform_4CF(). The alternative is for _dispatch_runloop_root_queue_perform_4CF() to do that read in a non blocking way, but for the cases when several things have been queued on the runloop queue and have been coalesced in a single eventfd delivery, it’s a bit dumb to pay a syscall per dequeue.<br>&gt; <br>&gt; On Mach the coalescing happens because the port has a queue width of 1 and incoming messages are dropped when the port is full.<br></p><p>Actually alternatively this could be done (no error handling for clarity, but it should have some!):<br></p><p><br>static bool<br>_dispatch_runloop_queue_drain_one(dispatch_queue_t dq)<br>{<br>	if (!dq-&gt;dq_items_tail) {<br>#ifdef __linux__<br>		eventfd_read((int)dq-&gt;do_ctxt, &amp;(eventfd_t)0);<br>		if (!dq-&gt;dq_items_tail) {<br>			return false;<br>		}<br>#else<br>		return false;<br>#endif<br>	}<br>	...<br>}<br></p><p>IOW: consume the eventfd when we think the queue is empty, and check again it really is, that way you even have the eventfd break you out of the epoll while the queue is full which is probably nice (even if CF is supposed to already track this anyway, but I don’t know CFRunloop well so Tony should tell which alternative is better between my former mail or that one).<br></p><p>-Pierre<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fd76948bee17f4c4065776a13f74e35?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Daniel A. Steffen</string> &lt;dsteffen at apple.com&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 13:41, Pierre Habouzit via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; -Pierre<br>&gt; <br>&gt;&gt; On Dec 17, 2015, at 1:35 PM, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 12:40 PM, Tony Parker via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Dzianis,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 17, 2015, at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi, <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well. <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue). <br>&gt;&gt;&gt;&gt;&gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For what it’s worth, we went ahead and based CFRunLoop.c on Linux on top of epoll: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/RunLoop.subproj/CFRunLoop.c<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/commit/d594de1bdd7f10a558e30b92809420303ded0a6a#diff-9739b4f43fc59b19e677f9e3f835d159<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it makes total sense for dispatch’s SPI for CF to simply return an eventfd.<br>&gt;&gt; <br>&gt;&gt; it’s exactly what we want for runloop tied queues. The mach port that is used for this on Darwin receives messages only to break out of the mach_msg() call, but the handler of the message is a void function: _dispatch_wakeup_runloop_thread().<br>&gt;&gt; <br>&gt;&gt; The good news is that a mach_port is an uint32_t and eventfd would be an int, so as far as storage is concerned, everything is fine.<br>&gt;&gt; <br>&gt;&gt; I would have the _dispatch_get_main_queue_port_4CF / _dispatch_runloop_root_queue_get_port_4CF return an eventfd, and adapt the code that disposes of it. This is a IMO straightforward patch that should be written e.g. that way:<br>&gt;&gt; <br>&gt;&gt; #if HAVE_MACH<br>&gt;&gt; // current OS X Code<br>&gt;&gt; #elif HAVE_EVENTFD<br>&gt;&gt; // linux port<br>&gt;&gt; #else<br>&gt;&gt; #error should not happen<br>&gt;&gt; #endif<br>&gt;&gt; <br>&gt;&gt; And also have:<br>&gt;&gt; <br>&gt;&gt; DISPATCH_COCOA_COMPAT be set to one on linux (until it is, you don’t get the main queue and runloop tied queues).<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; The one murky thing is that someone has to *consume* what’s in that eventfd, today, it’s implicit with mach because MiG will call dispatch’s _dispatch_wakeup_runloop_thread() for it (corresponding to the wakeup_runloop_thread routine in protocol.defs)<br></p><p>actually that is never called, the only thing that is used is the mig server routine _dispatch_send_wakeup_runloop_thread, the client routine is just there so that the mig client code links…<br></p><p>&gt;&gt; , but for linux, it’s probably best if CF knows that it’s an eventfd and it has to eventfd_read() from it to consume the event before it’s calling _dispatch_runloop_root_queue_perform_4CF(). The alternative is for _dispatch_runloop_root_queue_perform_4CF() to do that read in a non blocking way, but for the cases when several things have been queued on the runloop queue and have been coalesced in a single eventfd delivery, it’s a bit dumb to pay a syscall per dequeue.<br>&gt;&gt; <br>&gt;&gt; On Mach the coalescing happens because the port has a queue width of 1 and incoming messages are dropped when the port is full.<br>&gt; <br>&gt; Actually alternatively this could be done (no error handling for clarity, but it should have some!):<br>&gt; <br>&gt; <br>&gt; static bool<br>&gt; _dispatch_runloop_queue_drain_one(dispatch_queue_t dq)<br>&gt; {<br>&gt; 	if (!dq-&gt;dq_items_tail) {<br>&gt; #ifdef __linux__<br>&gt; 		eventfd_read((int)dq-&gt;do_ctxt, &amp;(eventfd_t)0);<br>&gt; 		if (!dq-&gt;dq_items_tail) {<br>&gt; 			return false;<br>&gt; 		}<br>&gt; #else<br>&gt; 		return false;<br>&gt; #endif<br>&gt; 	}<br>&gt; 	...<br>&gt; }<br>&gt; <br>&gt; IOW: consume the eventfd when we think the queue is empty, and check again it really is, that way you even have the eventfd break you out of the epoll while the queue is full which is probably nice (even if CF is supposed to already track this anyway, but I don’t know CFRunloop well so Tony should tell which alternative is better between my former mail or that one).<br></p><p>for the main queue, the current runloop / libdispatch interaction model is that __CFRunLoopRun() dequeues the message from the port obtained from _dispatch_get_main_queue_port_4CF(), and that _dispatch_main_queue_callback_4CF() consumes the message in question (aside from its storage).<br>If we wanted to call the mig client function mentioned above, this is where we would do it.<br>The main queue is then drained partially or completely, with another wakeup message generated in the partial case.<br></p><p>It seems that this model would make sense for eventfd as well and would keep the divergence to a minimum, though you’d likely need to emulate the coalescing behavior of the qlimit 1 wakeup port by dequeueing all additional wakeup messages on the eventfd, probably in _dispatch_main_queue_callback_4CF<br></p><p>for the runloop queues, the model is slightly different, the wakeup messages are supposed to be consumed by __CFRunLoopRun() and _dispatch_runloop_queue_drain_one called in a loop until it returns false, without any additional wakeup messages being generated.<br></p><p>Daniel<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fd76948bee17f4c4065776a13f74e35?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Daniel A. Steffen</string> &lt;dsteffen at apple.com&gt;<p>December 17, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 17, 2015, at 21:16, Daniel A. Steffen via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 17, 2015, at 13:41, Pierre Habouzit via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -Pierre<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 17, 2015, at 1:35 PM, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 17, 2015, at 12:40 PM, Tony Parker via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Dzianis,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 17, 2015, at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hi, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue). <br>&gt;&gt;&gt;&gt;&gt;&gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; For what it’s worth, we went ahead and based CFRunLoop.c on Linux on top of epoll: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/blob/master/CoreFoundation/RunLoop.subproj/CFRunLoop.c<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-corelibs-foundation/commit/d594de1bdd7f10a558e30b92809420303ded0a6a#diff-9739b4f43fc59b19e677f9e3f835d159<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it makes total sense for dispatch’s SPI for CF to simply return an eventfd.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it’s exactly what we want for runloop tied queues. The mach port that is used for this on Darwin receives messages only to break out of the mach_msg() call, but the handler of the message is a void function: _dispatch_wakeup_runloop_thread().<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The good news is that a mach_port is an uint32_t and eventfd would be an int, so as far as storage is concerned, everything is fine.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would have the _dispatch_get_main_queue_port_4CF / _dispatch_runloop_root_queue_get_port_4CF return an eventfd, and adapt the code that disposes of it. This is a IMO straightforward patch that should be written e.g. that way:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #if HAVE_MACH<br>&gt;&gt;&gt; // current OS X Code<br>&gt;&gt;&gt; #elif HAVE_EVENTFD<br>&gt;&gt;&gt; // linux port<br>&gt;&gt;&gt; #else<br>&gt;&gt;&gt; #error should not happen<br>&gt;&gt;&gt; #endif<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; And also have:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; DISPATCH_COCOA_COMPAT be set to one on linux (until it is, you don’t get the main queue and runloop tied queues).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The one murky thing is that someone has to *consume* what’s in that eventfd, today, it’s implicit with mach because MiG will call dispatch’s _dispatch_wakeup_runloop_thread() for it (corresponding to the wakeup_runloop_thread routine in protocol.defs)<br>&gt; <br>&gt; actually that is never called, the only thing that is used is the mig server routine _dispatch_send_wakeup_runloop_thread, the client routine is just there so that the mig client code links…<br>&gt; <br>&gt;&gt;&gt; , but for linux, it’s probably best if CF knows that it’s an eventfd and it has to eventfd_read() from it to consume the event before it’s calling _dispatch_runloop_root_queue_perform_4CF(). The alternative is for _dispatch_runloop_root_queue_perform_4CF() to do that read in a non blocking way, but for the cases when several things have been queued on the runloop queue and have been coalesced in a single eventfd delivery, it’s a bit dumb to pay a syscall per dequeue.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Mach the coalescing happens because the port has a queue width of 1 and incoming messages are dropped when the port is full.<br>&gt;&gt; <br>&gt;&gt; Actually alternatively this could be done (no error handling for clarity, but it should have some!):<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; static bool<br>&gt;&gt; _dispatch_runloop_queue_drain_one(dispatch_queue_t dq)<br>&gt;&gt; {<br>&gt;&gt; 	if (!dq-&gt;dq_items_tail) {<br>&gt;&gt; #ifdef __linux__<br>&gt;&gt; 		eventfd_read((int)dq-&gt;do_ctxt, &amp;(eventfd_t)0);<br>&gt;&gt; 		if (!dq-&gt;dq_items_tail) {<br>&gt;&gt; 			return false;<br>&gt;&gt; 		}<br>&gt;&gt; #else<br>&gt;&gt; 		return false;<br>&gt;&gt; #endif<br>&gt;&gt; 	}<br>&gt;&gt; 	...<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; IOW: consume the eventfd when we think the queue is empty, and check again it really is, that way you even have the eventfd break you out of the epoll while the queue is full which is probably nice (even if CF is supposed to already track this anyway, but I don’t know CFRunloop well so Tony should tell which alternative is better between my former mail or that one).<br>&gt; <br>&gt; for the main queue, the current runloop / libdispatch interaction model is that __CFRunLoopRun() dequeues the message from the port obtained from _dispatch_get_main_queue_port_4CF(), and that _dispatch_main_queue_callback_4CF() consumes the message in question (aside from its storage).<br>&gt; If we wanted to call the mig client function mentioned above, this is where we would do it.<br>&gt; The main queue is then drained partially or completely, with another wakeup message generated in the partial case.<br>&gt; <br>&gt; It seems that this model would make sense for eventfd as well and would keep the divergence to a minimum, though you’d likely need to emulate the coalescing behavior of the qlimit 1 wakeup port by dequeueing all additional wakeup messages on the eventfd, probably in _dispatch_main_queue_callback_4CF<br>&gt; <br>&gt; for the runloop queues, the model is slightly different, the wakeup messages are supposed to be consumed by __CFRunLoopRun() and _dispatch_runloop_queue_drain_one<br></p><p>err, s/_dispatch_runloop_queue_drain_one/_dispatch_runloop_root_queue_perform_4CF/ of course<br></p><p>&gt; called in a loop until it returns false, without any additional wakeup messages being generated.<br>&gt; <br>&gt; Daniel<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/25218789c45e2fa6bd09d31cef89c1d5?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Thomas Greany</string> &lt;tfg at google.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>What about libev? http://software.schmorp.de/pkg/libev.html<br></p><p>On Thu, Dec 17, 2015 at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;<br>swift-corelibs-dev at swift.org&gt; wrote:<br></p><p>&gt; &gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev<br>&gt; &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hi,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based<br>&gt; on my knowledge of dispatch and my past extensive system programming<br>&gt; experience with Linux before I joined Apple.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch<br>&gt; port is to go away from the libkqueue that tries to emulate kqueue fully,<br>&gt; where dispatch only needs a small subset of the surface of kqueue. Given<br>&gt; how source.c is written today, this is not a very small undertaking, but<br>&gt; eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That makes sense, could simplify the implementation (and keep thing<br>&gt; cleaner). Then the follow up question is of course how to split/manage<br>&gt; source.c (as Daniel pointed out there is the merging issue).<br>&gt; &gt; we can decide when/if someone tries to tackle it. I humbly recognize<br>&gt; that I have no great idea of how to do so.<br>&gt;<br>&gt; I have some experience in event multiplexing programming for linux. So it<br>&gt; looks like interesting project for me. There is some conceptual questions<br>&gt; which I think should be discussed:<br>&gt;<br>&gt; 1) Obviously, kqueue and epoll have a little different semantics. For<br>&gt; example: in linux timers, signals and socket can be presented as file<br>&gt; descriptor and processed uniformly. Is there any chance that community will<br>&gt; agree to develop separate API for linux?<br>&gt; 2) Does anyone have long term vision about how to inject platform specific<br>&gt; code into current implementation of dispatch_source? As far as I’ve read<br>&gt; the source it’s heavily bound with kqueue semantics and «#ifdef»-way seems<br>&gt; to be completely messy..(<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151217/3e406ab5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>libdispatch epoll port</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>December 17, 2015 at 01:00:00pm</p></header><div class="content"><p>libev model isn’t compatible with dispatch model, and retrofiting one on top of the other will put you in a world of hurt, and would diverge from the OS X port greatly, which we’d like to avoid.<br></p><p>I originally thought you were replying to the thread about having the Runloop queues code in dispatch ported (for some reason your reply wasn’t attached to a mail thread for me and I got confused), and that one needs a raw interface with epoll to interact with CFRunlopp and that’s what I “replied” to.<br></p><p>I don’t think that moving away from likqueue is a good idea yet. Technically, dispatch is really interleaved with kqueue code, and libkqueue overhead is smaller than I originally thought, so I’ve kind of revisited that argument.<br></p><p>The one thing that will be painful for the port to an extent, is that kevents are now uniquified in kernel based on the ident + udata, said another way, if you watch the same file descriptor twice with two different udata’s, then it’s two different kevents in kernel. That is *NOT* the case with epoll, where uniquing is only based on the file-descriptor: if you EPOLL_CTL_ADD two different “udata” for the same fd, you get EEXIST, which means that you need to do multiplexing in userland (which dispatch used to do before kevent started taking udata into account).<br></p><p>That has impacts on the userland parallelism as all source registering and deregistering have to be serialized wrt each other. This is the hard part, not abstracting epoll.<br></p><p>-Pierre<br></p><p>&gt; On Dec 17, 2015, at 1:44 PM, Thomas Greany via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; What about libev? http://software.schmorp.de/pkg/libev.html &lt;http://software.schmorp.de/pkg/libev.html&gt;<br>&gt; <br>&gt; On Thu, Dec 17, 2015 at 12:36 PM, Dzianis Fedarenka via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt; On Dec 10, 2015, at 12:42 AM, Joakim Hassila via swift-corelibs-dev &lt;swift-corelibs-dev at swift.org &lt;http://swift.org/&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hi,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 8 dec. 2015, at 16:56, Pierre Habouzit &lt;pierre at habouzit.net &lt;http://habouzit.net/&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; FWIW, this is my personal, let’s call it enlightened, opinion, based on my knowledge of dispatch and my past extensive system programming experience with Linux before I joined Apple.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I think that long term, the best way to maintain a Linux libdispatch port is to go away from the libkqueue that tries to emulate kqueue fully, where dispatch only needs a small subset of the surface of kqueue. Given how source.c is written today, this is not a very small undertaking, but eventually dispatch source map to epoll_ctl(EPOLLONESHOT) very very well.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; That makes sense, could simplify the implementation (and keep thing cleaner). Then the follow up question is of course how to split/manage source.c (as Daniel pointed out there is the merging issue).<br>&gt; &gt; we can decide when/if someone tries to tackle it. I humbly recognize that I have no great idea of how to do so.<br>&gt; <br>&gt; I have some experience in event multiplexing programming for linux. So it looks like interesting project for me. There is some conceptual questions which I think should be discussed:<br>&gt; <br>&gt; 1) Obviously, kqueue and epoll have a little different semantics. For example: in linux timers, signals and socket can be presented as file descriptor and processed uniformly. Is there any chance that community will agree to develop separate API for linux?<br>&gt; 2) Does anyone have long term vision about how to inject platform specific code into current implementation of dispatch_source? As far as I’ve read the source it’s heavily bound with kqueue semantics and «#ifdef»-way seems to be completely messy..(<br>&gt; _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org &lt;mailto:swift-corelibs-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev &lt;https://lists.swift.org/mailman/listinfo/swift-corelibs-dev&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-corelibs-dev mailing list<br>&gt; swift-corelibs-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-corelibs-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-corelibs-dev/attachments/20151217/86476633/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
