<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>August 14, 2016 at 10:00:00am</p></header><div class="content"><p>Hi folks,<br></p><p>I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>doesn’t quite seem enough validation for such a significant change to me. Of those that expressed an<br>opinion on the thread many were against sealing classes outside the module. <br></p><p>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022364.html<br></p><p>I personally feel it&#39;s a huge mistake for the following reasons:<br></p><p>1) it “breaks open source” reducing the reusability of third party software by default.<br></p><p>2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is<br>likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers<br>of function pointers for most method calls (itself an expensive operation) whether a call is even made.<br></p><p>On the first point it&#39;s an established technique in OOP to be able to subclass and override to adapt a class<br>for a role perhaps it’s author never considered. Call this “monkey-patching” if you like but it is a part of being<br>able to use open source libraries without having to make a fork as would be the case if sealed by default.<br>Are we expecting developers to remember to leave their classes (and methods?) &quot;open”? If they do feel<br>that others shouldn’t subclass or override there was always “final&quot;. Distinctions about whether this is possible<br>inside or outside a module seem a mute point to me.<br></p><p>The second point is more of an engineering one. “Virtual” dispatch on Swift is not a significant overhead<br>compared to fully dynamic dispatch on Objective-C which even then was seldom a problem. There is a<br>cost however to de-virtualisation and resolving to a direct call to a method address in that the dynamic<br>linker has to resolve and slide the pointer on load. This type of concern is a bad argument to use in <br>designing a language anyway even if it is called Swift.<br></p><p>Well, I know the boat has left on this one and I’ll likely have to live with it but this is the proposal I<br>most disagree with on evolution this far. Programmers have morals and just because you shouldn’t<br>do something doesn’t mean the language needs to turn that into can’t by default when the need arises.<br>If this change does go ahead please try to get it into the next Xcode beta as it is a very incompatible one.<br></p><p>Cheers,<br></p><p>John<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>August 14, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Le 14 août 2016 à 11:17, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt; doesn’t quite seem enough validation for such a significant change to me.<br></p><p>60 emails ?  You’re joking. It is more 600 emails than 60 that was send about that proposal, and I’m pretty sure nobody want to see that discussion start again.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>August 14, 2016 at 12:00:00pm</p></header><div class="content"><p>You are not familiar with us Italians and our love for (hopefully reasonable) arguing I see ;). I  commit to and accept the decision taken, but it remains a decision I disagree with and something that will probably birth a painful fork once say Android and/or other big corporations moved to Swift and decided for example that they wanted a new set of rules.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 14 Aug 2016, at 11:14, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Le 14 août 2016 à 11:17, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Hi folks,<br>&gt;&gt; <br>&gt;&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt;&gt; doesn’t quite seem enough validation for such a significant change to me.<br>&gt; <br>&gt; 60 emails ?  You’re joking. It is more 600 emails than 60 that was send about that proposal, and I’m pretty sure nobody want to see that discussion start again.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/30507588/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>August 14, 2016 at 03:00:00pm</p></header><div class="content"><p>I for one would very much like this discussion to start again.<br></p><p>Yes it was discussed. Unfortunately, it was discussed in a summer time when in my country at least, many of us are off the grid for vacation. This is not a criticism of the process of course, just an indication that not everyone may have had the chance to voice their concerns.<br></p><p>As I expressed it already, even after reading all the arguments for the decision, I stand convinced that this decision is a tragic mistake. Note that I agree with many of the given rationales. I just think that the decision doesn&#39;t follow.<br></p><p>I will not rehash everything, but I will make a couple of points that may not have been expressed stridently enough:<br></p><p>- many many many people expressed contrary voices, and where shut up by the core team&#39;s expressing their opinion in favor of preventing subclassability by default. See a small sample at http://mjtsai.com/blog/2016/07/17/swift-classes-to-be-non-publicly-subclassable-by-default/<br></p><p>- One reason I (and others) gave is that I would not trust any programmer (least of which myself) to have the double sight ability to foresee every use of their classes/libraries. One disingenuous answer to that was &quot;if you don&#39;t trust the programmer, why do you use their code to begin with?&quot;. Well, I don&#39;t trust my spouse&#39;s ability to forecast the time it takes to drive from place A to place B. Yet I will not break up over that. Time and time again, I have heard Apple executives praise us developers for the use of Apple&#39;s technology that they would never have foreseen. This decision goes totally contrary to those praises.<br></p><p>This decision is bad, not because it makes the default for classes to be unsubclassable, but because it puts the power of final decision into the wrong hands: the library author&#39;s. <br></p><p>As a result, guidelines everywhere will eventually mandate for library authors to make everything &quot;open&quot;, exactly as the guidelines for public C++ classes is often to make methods virtual. This will nullify much of the benefits of the decision.<br></p><p>The final programmer, the client programmer who uses the class should have the final say. The class author is entitled to express &quot;beware, you will likely shoot yourself in the foot&quot;. But the final programmer should have the power to answer &quot;thanks for saying. Now give me that gun.&quot;<br></p><p>My hope is that we can give back the final say to the final programmer through an additive Swift evolution proposal down the line, which would explicitly allow her to &quot;force open&quot; a closed class. I believe that such an addition would right the wrong while still keeping he benefits of the decision.<br></p><p>I don&#39;t think that such a proposal would affect the ABI, so it seems to me this is not yet the time to come up with such a proposal. I may be wrong on that though: I am quite unclear on what does or does not affect the ABI. <br></p><p>To conclude let me give you an anecdote: I was writing this in-house iPhone app for a client, that used the common UITabViewController UI model. We had 5 tabs and 5 icons and all was good. Then the client asked for a new feature into a new 6th tab and wanted a 6th icon to be squeezed in the tab bar. The Apple&#39;s UI guidelines the, and the UITabViewController class precluded that (it may have changed since, I haven&#39;t developed for iOS in quite a while). However user testing showed that it was quite OK to put 6 icons there. I was able to subclass UITabViewController to accommodate for that, despite the fact the it was not only not designed for that, but also actively designed to prevent that.<br></p><p>Now there are many reasons why it could be claimed that what I did was wrong. And I would agree with those I suspect. However, that I could do it (pondering all factors) was actually the difference between &quot;yes but&quot; and &quot;no way&quot;. As a result, my customer was another happy Apple user.<br></p><p>With Swift and that decision, this would not have happened, and we would all have been the poorer for it.<br></p><p>I hope I that this additive proposal I mentioned above can see the light of day in due time.<br></p><p>Best regards,<br></p><p>Jean-Denis<br></p><p><br>&gt; On Aug 14, 2016, at 14:26, Goffredo Marocchi via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You are not familiar with us Italians and our love for (hopefully reasonable) arguing I see ;). I  commit to and accept the decision taken, but it remains a decision I disagree with and something that will probably birth a painful fork once say Android and/or other big corporations moved to Swift and decided for example that they wanted a new set of rules.<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 14 Aug 2016, at 11:14, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Le 14 août 2016 à 11:17, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi folks,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt;&gt;&gt; doesn’t quite seem enough validation for such a significant change to me.<br>&gt;&gt; <br>&gt;&gt; 60 emails ?  You’re joking. It is more 600 emails than 60 that was send about that proposal, and I’m pretty sure nobody want to see that discussion start again.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/f3816d5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>August 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 5:59 AM, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I for one would very much like this discussion to start again.<br></p><p>To set expectations here, we are beyond the end of source breaking changes for Swift 3, so they cannot be changed for Swift 3.  We plan to have ways to take limited source breaking changes in Swift 4, but don&#39;t know the scope of them because we haven’t designed the mechanism, and don’t know what scope it will allow.<br></p><p>This is all a way of saying that we *cannot* change this right now, and that discussing it is pointless.<br></p><p>From another perspective, I will point out that this was a carefully considered decision with much active debate, so unless there is *new* information that comes to light, it won’t be reopened.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/b0adab37/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>August 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Am 14.08.2016 um 14:59 schrieb Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; This decision is bad, not because it makes the default for classes to be unsubclassable<br></p><p>Seems that the prediction of the grief caused by SE-0117 in the long run was right ;-) — but be careful, the title doesn&#39;t reflect reality anymore:<br>As far as I understand, the default won&#39;t be changed at all.<br>It has been internal, and it will be internal.<br>The change is that changing the default to &quot;public&quot; will only make a class/method visible outside the current module, without the right to subclass/override.<br>So, basically, &quot;public&quot; is renamed to &quot;open&quot;.<br>Imho this is still causing unnecessary trouble, as it breaks most libraries out there (more precisely: Third party code that relies on the old behavior), but in the future, you can just use &quot;open&quot; instead of &quot;public&quot;, and little else will change — except that users of your framework may assume that &quot;open&quot; is an extension of &quot;public&quot;, whereas you may follow the notion that &quot;public&quot; is an restriction of &quot;open&quot;.<br></p><p>In the end, imho the whole topic has been decided in a very Solomonic way that disappoints both parties ;-), so I don&#39;t think it will be a reason for someone to fork Swift.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/32fd572b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d90466f6a63f45386adb0f33d3879e52?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>John Holdsworth</string> &lt;mac at johnholdsworth.com&gt;<p>August 15, 2016 at 11:00:00am</p></header><div class="content"><p>Well, I walked into that one :( Sorry to trawl all that up on a Sunday.<br></p><p>I get it now.  “open” is the new “public”, “public, the new “final” at<br>least as far as classes outside the module are concerned.<br></p><p>John<br></p><p>&gt; On 15 Aug 2016, at 10:51, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 14.08.2016 um 14:59 schrieb Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; This decision is bad, not because it makes the default for classes to be unsubclassable<br>&gt; <br>&gt; Seems that the prediction of the grief caused by SE-0117 in the long run was right ;-) — but be careful, the title doesn&#39;t reflect reality anymore:<br>&gt; As far as I understand, the default won&#39;t be changed at all.<br>&gt; It has been internal, and it will be internal.<br>&gt; The change is that changing the default to &quot;public&quot; will only make a class/method visible outside the current module, without the right to subclass/override.<br>&gt; So, basically, &quot;public&quot; is renamed to &quot;open&quot;.<br>&gt; Imho this is still causing unnecessary trouble, as it breaks most libraries out there (more precisely: Third party code that relies on the old behavior), but in the future, you can just use &quot;open&quot; instead of &quot;public&quot;, and little else will change — except that users of your framework may assume that &quot;open&quot; is an extension of &quot;public&quot;, whereas you may follow the notion that &quot;public&quot; is an restriction of &quot;open&quot;.<br>&gt; <br>&gt; In the end, imho the whole topic has been decided in a very Solomonic way that disappoints both parties ;-), so I don&#39;t think it will be a reason for someone to fork Swift.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/1fa8d18a/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>August 14, 2016 at 10:00:00am</p></header><div class="content"><p>There was an order of magnitude more than 60 emails about this. In my inbox, I count 452 emails that have 0117 in the title. Discussion had already started before the proposal and I&#39;m not counting these.<br></p><p>Félix<br></p><p>&gt; Le 14 août 2016 à 02:17:36, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt; doesn’t quite seem enough validation for such a significant change to me. Of those that expressed an<br>&gt; opinion on the thread many were against sealing classes outside the module. <br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022364.html<br>&gt; <br>&gt; I personally feel it&#39;s a huge mistake for the following reasons:<br>&gt; <br>&gt; 1) it “breaks open source” reducing the reusability of third party software by default.<br>&gt; <br>&gt; 2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is<br>&gt; likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers<br>&gt; of function pointers for most method calls (itself an expensive operation) whether a call is even made.<br>&gt; <br>&gt; On the first point it&#39;s an established technique in OOP to be able to subclass and override to adapt a class<br>&gt; for a role perhaps it’s author never considered. Call this “monkey-patching” if you like but it is a part of being<br>&gt; able to use open source libraries without having to make a fork as would be the case if sealed by default.<br>&gt; Are we expecting developers to remember to leave their classes (and methods?) &quot;open”? If they do feel<br>&gt; that others shouldn’t subclass or override there was always “final&quot;. Distinctions about whether this is possible<br>&gt; inside or outside a module seem a mute point to me.<br>&gt; <br>&gt; The second point is more of an engineering one. “Virtual” dispatch on Swift is not a significant overhead<br>&gt; compared to fully dynamic dispatch on Objective-C which even then was seldom a problem. There is a<br>&gt; cost however to de-virtualisation and resolving to a direct call to a method address in that the dynamic<br>&gt; linker has to resolve and slide the pointer on load. This type of concern is a bad argument to use in <br>&gt; designing a language anyway even if it is called Swift.<br>&gt; <br>&gt; Well, I know the boat has left on this one and I’ll likely have to live with it but this is the proposal I<br>&gt; most disagree with on evolution this far. Programmers have morals and just because you shouldn’t<br>&gt; do something doesn’t mean the language needs to turn that into can’t by default when the need arises.<br>&gt; If this change does go ahead please try to get it into the next Xcode beta as it is a very incompatible one.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; John<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160814/db484bc7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 14, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 14 Aug 2016, at 11:17, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi folks,<br>&gt; <br>&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt; <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt; doesn’t quite seem enough validation for such a significant change to me. Of those that expressed an<br>&gt; opinion on the thread many were against sealing classes outside the module. <br>&gt; <br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022364.html<br>&gt; <br>&gt; I personally feel it&#39;s a huge mistake for the following reasons:<br>&gt; <br>&gt; 1) it “breaks open source” reducing the reusability of third party software by default.<br>&gt; <br>&gt; 2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is<br>&gt; likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers<br>&gt; of function pointers for most method calls (itself an expensive operation) whether a call is even made.<br>&gt; <br>&gt; On the first point it&#39;s an established technique in OOP to be able to subclass and override to adapt a class<br>&gt; for a role perhaps it’s author never considered. Call this “monkey-patching” if you like but it is a part of being<br>&gt; able to use open source libraries without having to make a fork as would be the case if sealed by default.<br>&gt; Are we expecting developers to remember to leave their classes (and methods?) &quot;open”? If they do feel<br>&gt; that others shouldn’t subclass or override there was always “final&quot;. Distinctions about whether this is possible<br>&gt; inside or outside a module seem a mute point to me.<br>&gt; <br>&gt; The second point is more of an engineering one. “Virtual” dispatch on Swift is not a significant overhead<br>&gt; compared to fully dynamic dispatch on Objective-C which even then was seldom a problem. There is a<br>&gt; cost however to de-virtualisation and resolving to a direct call to a method address in that the dynamic<br>&gt; linker has to resolve and slide the pointer on load. This type of concern is a bad argument to use in <br>&gt; designing a language anyway even if it is called Swift.<br>&gt; <br>&gt; Well, I know the boat has left on this one and I’ll likely have to live with it but this is the proposal I<br>&gt; most disagree with on evolution this far. Programmers have morals and just because you shouldn’t<br>&gt; do something doesn’t mean the language needs to turn that into can’t by default when the need arises.<br>&gt; If this change does go ahead please try to get it into the next Xcode beta as it is a very incompatible one.<br>&gt; <br>&gt; Cheers,<br>&gt; <br>&gt; John<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>It we are happy with non-open != final, I would be in favour of some kind of monkey-patching import attribute, similar to @testable, which allows you to subclass non-open classes at your own risk.<br></p><p>I would be doubly-happy if we were to call it &quot;@monkey-patched import UIKit&quot;<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>August 15, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Le 14 août 2016 à 20:43, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 14 Aug 2016, at 11:17, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi folks,<br>&gt;&gt; <br>&gt;&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;&gt; <br>&gt;&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt;&gt; doesn’t quite seem enough validation for such a significant change to me. Of those that expressed an<br>&gt;&gt; opinion on the thread many were against sealing classes outside the module. <br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022364.html<br>&gt;&gt; <br>&gt;&gt; I personally feel it&#39;s a huge mistake for the following reasons:<br>&gt;&gt; <br>&gt;&gt; 1) it “breaks open source” reducing the reusability of third party software by default.<br>&gt;&gt; <br>&gt;&gt; 2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is<br>&gt;&gt; likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers<br>&gt;&gt; of function pointers for most method calls (itself an expensive operation) whether a call is even made.<br>&gt;&gt; <br>&gt;&gt; On the first point it&#39;s an established technique in OOP to be able to subclass and override to adapt a class<br>&gt;&gt; for a role perhaps it’s author never considered. Call this “monkey-patching” if you like but it is a part of being<br>&gt;&gt; able to use open source libraries without having to make a fork as would be the case if sealed by default.<br>&gt;&gt; Are we expecting developers to remember to leave their classes (and methods?) &quot;open”? If they do feel<br>&gt;&gt; that others shouldn’t subclass or override there was always “final&quot;. Distinctions about whether this is possible<br>&gt;&gt; inside or outside a module seem a mute point to me.<br>&gt;&gt; <br>&gt;&gt; The second point is more of an engineering one. “Virtual” dispatch on Swift is not a significant overhead<br>&gt;&gt; compared to fully dynamic dispatch on Objective-C which even then was seldom a problem. There is a<br>&gt;&gt; cost however to de-virtualisation and resolving to a direct call to a method address in that the dynamic<br>&gt;&gt; linker has to resolve and slide the pointer on load. This type of concern is a bad argument to use in <br>&gt;&gt; designing a language anyway even if it is called Swift.<br>&gt;&gt; <br>&gt;&gt; Well, I know the boat has left on this one and I’ll likely have to live with it but this is the proposal I<br>&gt;&gt; most disagree with on evolution this far. Programmers have morals and just because you shouldn’t<br>&gt;&gt; do something doesn’t mean the language needs to turn that into can’t by default when the need arises.<br>&gt;&gt; If this change does go ahead please try to get it into the next Xcode beta as it is a very incompatible one.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; John<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; It we are happy with non-open != final, I would be in favour of some kind of monkey-patching import attribute, similar to @testable, which allows you to subclass non-open classes at your own risk.<br>&gt; <br></p><p>The non subclassable across module boundary is not just a compiler enforced limitation. Once you compile a module with classes that are ‘final’ in the module, the compiler may devirtualize all call sites in the module, or even inlining some calls, making subclassing unpredictable and pointless.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>August 15, 2016 at 10:00:00am</p></header><div class="content"><p>This is a detail of implementation and doesn&#39;t have to be. You might even imagine the compiler emitting two versions of the code, one assuming the class will not be subclassed, the other not assuming that, and a smart linker linking the right version depending on the case. <br></p><p>So for me, in the long run, this argument is not an argument at all.<br></p><p>Even then, is it really appropriate to sacrifice expressivity on the altar of (marginally) better performance?<br></p><p>Jean-Denis<br></p><p>&gt; On 15 Aug 2016, at 09:50, Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The non subclassable across module boundary is not just a compiler enforced limitation. Once you compile a module with classes that are ‘final’ in the module, the compiler may devirtualize all call sites in the module, or even inlining some calls, making subclassing unpredictable and pointless.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/26e0e19d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>August 15, 2016 at 06:00:00pm</p></header><div class="content"><p>Yeah I know - that&#39;s why I said it would only work if we are okay with saying non-open != final, as a long-term decision. So the compiler won&#39;t devirtualize those calls.<br>  <br></p><p>  <br>As I understand it, that is how it works today - calls to non-open, non-final classes are still dynamically dispatched. There was a suggestion to make non-open == final, but that was expressly rejected.<br>  <br></p><p>  <br>Karl<br>  <br>  <br> Sent from my new   Email (https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=my_new_email)<br>  <br>  <br>  <br>  <br></p><p>  <br>  <br>&gt;   <br>&gt; On Aug 15, 2016 at 9:50 am,  &lt;Jean-Daniel Dupas (mailto:mailing at xenonium.com)&gt;  wrote:<br>&gt;   <br>&gt;   <br>&gt;   <br>&gt;   <br>&gt; &gt;  Le 14 août 2016 à 20:43, Karl via swift-evolution  &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  a écrit :  <br>&gt; &gt;   <br>&gt; &gt;   <br>&gt; &gt;&gt;  On 14 Aug 2016, at 11:17, John Holdsworth via swift-evolution  &lt;swift-evolution at swift.org (mailto:swift-evolution at swift.org)&gt;  wrote:  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  Hi folks,  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;   https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md   <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community  <br>&gt; &gt;&gt;  doesn’t quite seem enough validation for such a significant change to me. Of those that expressed an  <br>&gt; &gt;&gt;  opinion on the thread many were against sealing classes outside the module.  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;   https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022364.html   <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  I personally feel it&#39;s a huge mistake for the following reasons:  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  1) it “breaks open source” reducing the reusability of third party software by default.  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is  <br>&gt; &gt;&gt;  likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers  <br>&gt; &gt;&gt;  of function pointers for most method calls (itself an expensive operation) whether a call is even made.  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  On the first point it&#39;s an established technique in OOP to be able to subclass and override to adapt a class  <br>&gt; &gt;&gt;  for a role perhaps it’s author never considered. Call this “monkey-patching” if you like but it is a part of being  <br>&gt; &gt;&gt;  able to use open source libraries without having to make a fork as would be the case if sealed by default.  <br>&gt; &gt;&gt;  Are we expecting developers to remember to leave their classes (and methods?) &quot;open”? If they do feel  <br>&gt; &gt;&gt;  that others shouldn’t subclass or override there was always “final&quot;. Distinctions about whether this is possible  <br>&gt; &gt;&gt;  inside or outside a module seem a mute point to me.  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  The second point is more of an engineering one. “Virtual” dispatch on Swift is not a significant overhead  <br>&gt; &gt;&gt;  compared to fully dynamic dispatch on Objective-C which even then was seldom a problem. There is a  <br>&gt; &gt;&gt;  cost however to de-virtualisation and resolving to a direct call to a method address in that the dynamic  <br>&gt; &gt;&gt;  linker has to resolve and slide the pointer on load. This type of concern is a bad argument to use in  <br>&gt; &gt;&gt;  designing a language anyway even if it is called Swift.  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  Well, I know the boat has left on this one and I’ll likely have to live with it but this is the proposal I  <br>&gt; &gt;&gt;  most disagree with on evolution this far. Programmers have morals and just because you shouldn’t  <br>&gt; &gt;&gt;  do something doesn’t mean the language needs to turn that into can’t by default when the need arises.  <br>&gt; &gt;&gt;  If this change does go ahead please try to get it into the next Xcode beta as it is a very incompatible one.  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  Cheers,  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  John  <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;   <br>&gt; &gt;&gt;  _______________________________________________  <br>&gt; &gt;&gt;  swift-evolution mailing list  <br>&gt; &gt;&gt;   swift-evolution at swift.org (mailto:swift-evolution at swift.org)   <br>&gt; &gt;&gt;   https://lists.swift.org/mailman/listinfo/swift-evolution   <br>&gt; &gt;   <br>&gt; &gt;  It we are happy with non-open != final, I would be in favour of some kind of monkey-patching import attribute, similar to @testable, which allows you to subclass non-open classes at your own risk.  <br>&gt; &gt;   <br>&gt;<br>&gt; The non subclassable across module boundary is not just a compiler enforced limitation. Once you compile a module with classes that are ‘final’ in the module, the compiler may devirtualize all call sites in the module, or even inlining some calls, making subclassing unpredictable and pointless.  <br>&gt;<br>&gt;<br>&gt;          <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/60a34939/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>August 15, 2016 at 04:00:00pm</p></header><div class="content"><p>Yeah I am fairly sure at this point in time &quot;open&quot; is purely about a<br>statement of API contract (defaulted such to favor being explicit) which<br>IMHO is a very good tool to have in the toolbox for module/framework<br>developers. If it proves out to work well then I believe compiler<br>optimizations could start to leverage it but I don&#39;t think any of those are<br>in place currently. By that same token if &quot;monkey&quot; patch is seen to be<br>important that could be proposed in the future as well. (on the later the<br>core team – and myself included (not a core member) – don&#39;t favor the<br>monkey patching view of things, especially in the face of all of the other<br>Swift things aren&#39;t sub-classible).<br></p><p>-Shawn<br></p><p>On Mon, Aug 15, 2016 at 9:09 AM Karl Wagner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yeah I know - that&#39;s why I said it would only work if we are okay with<br>&gt; saying non-open != final, as a long-term decision. So the compiler won&#39;t<br>&gt; devirtualize those calls.<br>&gt;<br>&gt; As I understand it, that is how it works today - calls to non-open,<br>&gt; non-final classes are still dynamically dispatched. There was a suggestion<br>&gt; to make non-open == final, but that was expressly rejected.<br>&gt;<br>&gt; Karl<br>&gt;<br>&gt; Sent from my new Email<br>&gt; &lt;https://itunes.apple.com/app/apple-store/id922793622?pt=814382&amp;mt=8&amp;ct=my_new_email&gt;<br>&gt;<br>&gt;<br>&gt; On Aug 15, 2016 at 9:50 am, &lt;Jean-Daniel Dupas &lt;mailing at xenonium.com&gt;&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; &gt; Le 14 août 2016 à 20:43, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On 14 Aug 2016, at 11:17, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Hi folks,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I see from building the latest Swift-3.0 branch that I’m a little behind the times and this proposal has been accepted :(<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Is there no way we can revisit this decision? 60 emails on a mail group not read by the whole community<br>&gt; &gt;&gt; doesn’t quite seem enough validation for such a significant change to me. Of those that expressed an<br>&gt; &gt;&gt; opinion on the thread many were against sealing classes outside the module.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/022364.html<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I personally feel it&#39;s a huge mistake for the following reasons:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1) it “breaks open source” reducing the reusability of third party software by default.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is<br>&gt; &gt;&gt; likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers<br>&gt; &gt;&gt; of function pointers for most method calls (itself an expensive operation) whether a call is even made.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; On the first point it&#39;s an established technique in OOP to be able to subclass and override to adapt a class<br>&gt; &gt;&gt; for a role perhaps it’s author never considered. Call this “monkey-patching” if you like but it is a part of being<br>&gt; &gt;&gt; able to use open source libraries without having to make a fork as would be the case if sealed by default.<br>&gt; &gt;&gt; Are we expecting developers to remember to leave their classes (and methods?) &quot;open”? If they do feel<br>&gt; &gt;&gt; that others shouldn’t subclass or override there was always “final&quot;. Distinctions about whether this is possible<br>&gt; &gt;&gt; inside or outside a module seem a mute point to me.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The second point is more of an engineering one. “Virtual” dispatch on Swift is not a significant overhead<br>&gt; &gt;&gt; compared to fully dynamic dispatch on Objective-C which even then was seldom a problem. There is a<br>&gt; &gt;&gt; cost however to de-virtualisation and resolving to a direct call to a method address in that the dynamic<br>&gt; &gt;&gt; linker has to resolve and slide the pointer on load. This type of concern is a bad argument to use in<br>&gt; &gt;&gt; designing a language anyway even if it is called Swift.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Well, I know the boat has left on this one and I’ll likely have to live with it but this is the proposal I<br>&gt; &gt;&gt; most disagree with on evolution this far. Programmers have morals and just because you shouldn’t<br>&gt; &gt;&gt; do something doesn’t mean the language needs to turn that into can’t by default when the need arises.<br>&gt; &gt;&gt; If this change does go ahead please try to get it into the next Xcode beta as it is a very incompatible one.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Cheers,<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; John<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; It we are happy with non-open != final, I would be in favour of some kind of monkey-patching import attribute, similar to @testable, which allows you to subclass non-open classes at your own risk.<br>&gt; &gt;<br>&gt;<br>&gt; The non subclassable across module boundary is not just a compiler enforced limitation. Once you compile a module with classes that are ‘final’ in the module, the compiler may devirtualize all call sites in the module, or even inlining some calls, making subclassing unpredictable and pointless.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160815/66f7f257/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>[Proposal] Sealed classes by default</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>August 22, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 14, 2016, at 2:17 AM, John Holdsworth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 2) Contrary to arguments about the likely performance benefits of de-virtualisation of method dispatch it is<br>&gt; likely to make Swift programs launch more slowly due to the dynamic linker having to slide large numbers<br>&gt; of function pointers for most method calls (itself an expensive operation) whether a call is even made.<br>&gt; <br></p><p>The proposal is independent of any specific implementation strategy or ABI. If vtable dispatch is faster across module boundaries than function calls, we can continue using vtable dispatch.<br></p><p>We need to have a separate discussion about the implementation of open, public and final classes for ABI and resilience reasons anyway.<br></p><p>Slava<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
