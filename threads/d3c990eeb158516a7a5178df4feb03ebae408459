<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18bf9a0c7bfa962aa136a3e8f18edb0?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Mike Kasianowicz</string> &lt;mike at ap14.com&gt;<p>October 21, 2016 at 01:00:00am</p></header><div class="content"><p>Currently protocols can have the class constraint:<br>protocol MyProtocol : class {}<br></p><p>It would be (a) intuitive and (b) useful to allow such things as:<br>protocol Model : struct {} or protocol Event : enum {}<br></p><p>These types of restrictions can help prevent accidental anti-patterns or<br>misuse of APIs.<br></p><p>Seems simple and non-controversial... right?<br></p><p>[Note: I&#39;d like to see even more heavy-handed protocol restrictions in the<br>future.  For example, a protocol describing an enum with a common case, or<br>a struct with no reference members. Great stuff for defensively coding<br>APIs.]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/d3c98459/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>October 21, 2016 at 06:00:00am</p></header><div class="content"><p>What&#39;s your use case for distinguishing structs and enums?<br>On Fri, Oct 21, 2016 at 1:40 AM Mike Kasianowicz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Currently protocols can have the class constraint:<br>&gt; protocol MyProtocol : class {}<br>&gt;<br>&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;<br>&gt; These types of restrictions can help prevent accidental anti-patterns or<br>&gt; misuse of APIs.<br>&gt;<br>&gt; Seems simple and non-controversial... right?<br>&gt;<br>&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in the<br>&gt; future.  For example, a protocol describing an enum with a common case, or<br>&gt; a struct with no reference members. Great stuff for defensively coding<br>&gt; APIs.]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/f672170f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 21, 2016 at 10:00:00am</p></header><div class="content"><p>We had similar talks about that topic before. There is a thread somewhere on this, but it’s mainly focused on value type semantics.<br></p><p>If I remember correctly we might even discussed to remove the class constraint completely from the language and introduce a protocol solution to this problem.<br></p><p>There are also some words about the class constraint in the GenericsManifesto.md<br></p><p>Generalized class constraints<br></p><p>The class constraint can currently only be used for defining protocols. We could generalize it to associated type and type parameter declarations, e.g.,<br></p><p>protocol P {<br> associatedtype A : class<br>}<br></p><p>func foo&lt;T : class&gt;(t: T) { }<br>As part of this, the magical AnyObject protocol could be replaced with an existential with a class bound, so that it becomes a typealias:<br></p><p>typealias AnyObject = protocol&lt;class&gt;<br>See the “Existentials” section, particularly “Generalized existentials”, for more information.<br>Instead of : class we might use : AnyObject as a constraint (or : AnyReference?).<br></p><p>Instead of : struct/enum we should have something like : value or even better : AnyValue.<br></p><p>I believe we should focus on existential types first before fixing this gap in Swift. Any&lt;T&gt; might receive the mentioned constraints and could create something like this:<br></p><p>typealias AnyObject = Any&lt;class&gt;<br>typealias AnyValue = Any&lt;value&gt;<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 21. Oktober 2016 um 08:55:40, Xiaodi Wu via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>What&#39;s your use case for distinguishing structs and enums?<br>On Fri, Oct 21, 2016 at 1:40 AM Mike Kasianowicz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>Currently protocols can have the class constraint:<br>protocol MyProtocol : class {}<br></p><p>It would be (a) intuitive and (b) useful to allow such things as:<br>protocol Model : struct {} or protocol Event : enum {}<br></p><p>These types of restrictions can help prevent accidental anti-patterns or misuse of APIs.<br></p><p>Seems simple and non-controversial... right?<br></p><p>[Note: I&#39;d like to see even more heavy-handed protocol restrictions in the future.  For example, a protocol describing an enum with a common case, or a struct with no reference members. Great stuff for defensively coding APIs.]<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/70672dd6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18bf9a0c7bfa962aa136a3e8f18edb0?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Mike Kasianowicz</string> &lt;mike at ap14.com&gt;<p>October 21, 2016 at 08:00:00am</p></header><div class="content"><p>Apologies- I did try finding existing documentation or discussion, but all<br>I found was a stack overflow question asking how to do this.<br></p><p>The way I see it, it would be as simple as implicitly declaring protocols<br>on a type when a type is declared: class implies ReferenceType, struct<br>implies ValueType, etc.<br></p><p>In my opinion, this is very similar to the open/sealed argument about class<br>inheritance.  The API should be able to more strictly communicate the<br>protocol usage, so it can provide more built-in functionality and better<br>establish its contract with the consuming code.<br></p><p>I can see some interesting scenarios like-<br></p><p>// API can return success, but relies on dependency injection to<br>communicate other results<br>protocol Result : EnumType {<br>    case success<br>}<br></p><p>---<br>// serialization/communication frameworks<br>protocol Payload : ValueType, OnlyDataType {<br>}<br></p><p>class MyPayload : Payload { } // error<br></p><p>---<br></p><p>// this type is a collection of types and not a concrete type. it better<br>indicates intent.<br>protocol ModuleDefinition : ProtocolType {<br>    associatedtype View<br>    associatedtype Model<br>    // etc<br>}<br></p><p><br></p><p><br>On Fri, Oct 21, 2016 at 3:25 AM, Adrian Zubarev via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; We had similar talks about that topic before. There is a thread somewhere<br>&gt; on this, but it’s mainly focused on value type semantics.<br>&gt;<br>&gt; If I remember correctly we might even discussed to remove the class<br>&gt; constraint completely from the language and introduce a protocol solution<br>&gt; to this problem.<br>&gt;<br>&gt; There are also some words about the class constraint in the<br>&gt; GenericsManifesto.md<br>&gt; &lt;https://github.com/apple/swift/blob/611fc78d28a5da97dd1bea40761b913b1077aef5/docs/GenericsManifesto.md#generalized-class-constraints&gt;<br>&gt;<br>&gt; Generalized class constraints<br>&gt;<br>&gt; The class constraint can currently only be used for defining protocols.<br>&gt; We could generalize it to associated type and type parameter declarations,<br>&gt; e.g.,<br>&gt;<br>&gt; protocol P {<br>&gt;  associatedtype A : class<br>&gt; }<br>&gt;<br>&gt; func foo&lt;T : class&gt;(t: T) { }<br>&gt;<br>&gt; As part of this, the magical AnyObject protocol could be replaced with an<br>&gt; existential with a class bound, so that it becomes a typealias:<br>&gt;<br>&gt; typealias AnyObject = protocol&lt;class&gt;<br>&gt;<br>&gt; See the “Existentials” section, particularly “Generalized existentials”,<br>&gt; for more information.<br>&gt;<br>&gt;<br>&gt;    -<br>&gt;<br>&gt;    Instead of : class we might use : AnyObject as a constraint (or :<br>&gt;    AnyReference?).<br>&gt;    -<br>&gt;<br>&gt;    Instead of : struct/enum we should have something like : value or even<br>&gt;    better : AnyValue.<br>&gt;<br>&gt; ------------------------------<br>&gt;<br>&gt; I believe we should focus on existential types first before fixing this<br>&gt; gap in Swift. Any&lt;T&gt; might receive the mentioned constraints and could<br>&gt; create something like this:<br>&gt;<br>&gt; typealias AnyObject = Any&lt;class&gt;<br>&gt; typealias AnyValue = Any&lt;value&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt;<br>&gt; Am 21. Oktober 2016 um 08:55:40, Xiaodi Wu via swift-evolution (<br>&gt; swift-evolution at swift.org) schrieb:<br>&gt;<br>&gt; What&#39;s your use case for distinguishing structs and enums?<br>&gt; On Fri, Oct 21, 2016 at 1:40 AM Mike Kasianowicz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Currently protocols can have the class constraint:<br>&gt;&gt; protocol MyProtocol : class {}<br>&gt;&gt;<br>&gt;&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt;&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;&gt;<br>&gt;&gt; These types of restrictions can help prevent accidental anti-patterns or<br>&gt;&gt; misuse of APIs.<br>&gt;&gt;<br>&gt;&gt; Seems simple and non-controversial... right?<br>&gt;&gt;<br>&gt;&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in<br>&gt;&gt; the future.  For example, a protocol describing an enum with a common case,<br>&gt;&gt; or a struct with no reference members. Great stuff for defensively coding<br>&gt;&gt; APIs.]<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/73961e61/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 21, 2016 at 04:00:00pm</p></header><div class="content"><p>IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can optimise for the protocol being satisfied by a reference-counted type. Classes are semantically unique from values because they have identity, which is also something a protocol might want to codify.<br> <br></p><p> <br>There may be some optimisation gains by requiring all conformers to be values, but   I struggle to think of why you might want to codify that a conformer should not have identity.<br> <br> <br> <br>Personally I don&#39;t really like this asymmetry in the language either, and would support changes to make these two elements more explicit. For example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied only by classes, and moving the optimisation guides to usage site (e.g. when declaring a variable of type MyProto, I could declare it of type AnyClass&lt;MyProto&gt;  or AnyValue&lt;MyProto&gt;  instead, to annotate this specific instance as being refcountable or not, without making such optimisation hints part of the MyProto definition)<br> <br> <br> <br> <br> <br></p><p> <br> <br>- Karl<br> <br> <br> <br></p><p> <br> <br>&gt;  <br>&gt; On Oct 21, 2016 at 8:39 am,  &lt;Mike Kasianowicz via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt;  <br>&gt;  <br>&gt;  <br>&gt; Currently protocols can have the class constraint: <br>&gt; protocol MyProtocol : class {}<br>&gt;  <br>&gt;<br>&gt;  <br>&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt;  <br>&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;  <br>&gt;<br>&gt;  <br>&gt; These types of restrictions can help prevent accidental anti-patterns or misuse of APIs.<br>&gt;  <br>&gt;<br>&gt;  <br>&gt; Seems simple and non-controversial... right?<br>&gt;  <br>&gt;<br>&gt;  <br>&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in the future.    For example, a protocol describing an enum with a common case, or a struct with no reference members. Great stuff for defensively coding APIs.]<br>&gt;  <br>&gt;  _______________________________________________ swift-evolution mailing list  swift-evolution at swift.org (mailto:swift-evolution at swift.org)   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;  <br> <br> <br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/b6bd85f2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18bf9a0c7bfa962aa136a3e8f18edb0?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Mike Kasianowicz</string> &lt;mike at ap14.com&gt;<p>October 21, 2016 at 10:00:00am</p></header><div class="content"><p>Just from an outside perspective, the class restriction seems to be there<br>as a kludge for technical reasons... but that&#39;s neither here nor there.<br></p><p>It is not so much to enforce a lack of identity - in the struct case, it<br>would be to enforce copy-by-value semantics.  I think the strongest<br>argument I&#39;ve got is, say, a serialization or caching framework where you<br>want to enforce that something is entirely writeable via memory pointer or<br>copyable.  A value-type restriction would get us mostly there, albeit there<br>would still be ways to break the contract.  However, as noted in my<br>previous email, I see a lot of possibilities for enums too - in that case<br>the protocol somewhat acts as &#39;base type&#39; without adding the complexity of<br>a base type.<br></p><p>I listed some of my examples in my previous email - I could elaborate if it<br>helps.<br></p><p>On Fri, Oct 21, 2016 at 9:51 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br></p><p>&gt; IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can<br>&gt; optimise for the protocol being satisfied by a reference-counted type.<br>&gt; Classes are semantically unique from values because they have identity,<br>&gt; which is also something a protocol might want to codify.<br>&gt;<br>&gt; There may be some optimisation gains by requiring all conformers to be<br>&gt; values, but I struggle to think of why you might want to codify that a<br>&gt; conformer should not have identity.<br>&gt;<br>&gt; Personally I don&#39;t really like this asymmetry in the language either, and<br>&gt; would support changes to make these two elements more explicit. For<br>&gt; example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied<br>&gt; only by classes, and moving the optimisation guides to usage site (e.g.<br>&gt; when declaring a variable of type MyProto, I could declare it of type<br>&gt; AnyClass&lt;MyProto&gt; or AnyValue&lt;MyProto&gt; instead, to annotate this specific<br>&gt; instance as being refcountable or not, without making such optimisation<br>&gt; hints part of the MyProto definition)<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt; On Oct 21, 2016 at 8:39 am, &lt;Mike Kasianowicz via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt; Currently protocols can have the class constraint:<br>&gt; protocol MyProtocol : class {}<br>&gt;<br>&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;<br>&gt; These types of restrictions can help prevent accidental anti-patterns or<br>&gt; misuse of APIs.<br>&gt;<br>&gt; Seems simple and non-controversial... right?<br>&gt;<br>&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in the<br>&gt; future.  For example, a protocol describing an enum with a common case, or<br>&gt; a struct with no reference members. Great stuff for defensively coding<br>&gt; APIs.]<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org https://lists.swift.org/<br>&gt; mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/d5f178ff/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>October 21, 2016 at 06:00:00pm</p></header><div class="content"><p>This is the thread that I mentioned before: Should we rename “class” when referring to protocol conformance?<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 21. Oktober 2016 um 17:12:37, Mike Kasianowicz via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Just from an outside perspective, the class restriction seems to be there as a kludge for technical reasons... but that&#39;s neither here nor there.<br></p><p>It is not so much to enforce a lack of identity - in the struct case, it would be to enforce copy-by-value semantics.  I think the strongest argument I&#39;ve got is, say, a serialization or caching framework where you want to enforce that something is entirely writeable via memory pointer or copyable.  A value-type restriction would get us mostly there, albeit there would still be ways to break the contract.  However, as noted in my previous email, I see a lot of possibilities for enums too - in that case the protocol somewhat acts as &#39;base type&#39; without adding the complexity of a base type.<br></p><p>I listed some of my examples in my previous email - I could elaborate if it helps.<br></p><p>On Fri, Oct 21, 2016 at 9:51 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can optimise for the protocol being satisfied by a reference-counted type. Classes are semantically unique from values because they have identity, which is also something a protocol might want to codify.<br></p><p>There may be some optimisation gains by requiring all conformers to be values, but I struggle to think of why you might want to codify that a conformer should not have identity.<br></p><p>Personally I don&#39;t really like this asymmetry in the language either, and would support changes to make these two elements more explicit. For example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied only by classes, and moving the optimisation guides to usage site (e.g. when declaring a variable of type MyProto, I could declare it of type AnyClass&lt;MyProto&gt; or AnyValue&lt;MyProto&gt; instead, to annotate this specific instance as being refcountable or not, without making such optimisation hints part of the MyProto definition)<br></p><p>- Karl<br></p><p><br>On Oct 21, 2016 at 8:39 am, &lt;Mike Kasianowicz via swift-evolution&gt; wrote:<br></p><p>Currently protocols can have the class constraint:<br>protocol MyProtocol : class {}<br></p><p>It would be (a) intuitive and (b) useful to allow such things as:<br>protocol Model : struct {} or protocol Event : enum {}<br></p><p>These types of restrictions can help prevent accidental anti-patterns or misuse of APIs.<br></p><p>Seems simple and non-controversial... right?<br></p><p>[Note: I&#39;d like to see even more heavy-handed protocol restrictions in the future.  For example, a protocol describing an enum with a common case, or a struct with no reference members. Great stuff for defensively coding APIs.]<br>_______________________________________________ swift-evolution mailing list swift-evolution at swift.org https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/30cff506/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>October 21, 2016 at 06:00:00pm</p></header><div class="content"><p>Copying is a much more nuanced issue than just reference-or-value though. I would also support some good copying protocols in the standard library, but that&#39;s additive.<br> <br>   <br> <br> <br> <br></p><p> <br> <br> <br> <br></p><p> <br> <br>&gt;  <br>&gt; On Oct 21, 2016 at 5:11 pm,  &lt;Mike Kasianowicz (mailto:mike at ap14.com)&gt;  wrote:<br>&gt;  <br>&gt;  <br>&gt;  <br>&gt; Just from an outside perspective, the class restriction seems to be there as a kludge for technical reasons... but that&#39;s neither here nor there. <br>&gt;<br>&gt;  <br>&gt; It is not so much to enforce a lack of identity - in the struct case, it would be to enforce copy-by-value semantics.    I think the strongest argument I&#39;ve got is, say, a serialization or caching framework where you want to enforce that something is entirely writeable via memory pointer or copyable.    A value-type restriction would get us mostly there, albeit there would still be ways to break the contract.    However, as noted in my previous email, I see a lot of possibilities for enums too - in that case the protocol somewhat acts as &#39;base type&#39; without adding the complexity of a base type.<br>&gt;  <br>&gt;<br>&gt;  <br>&gt; I listed some of my examples in my previous email - I could elaborate if it helps.<br>&gt;    <br>&gt;<br>&gt;  <br>&gt; On Fri, Oct 21, 2016 at 9:51 AM, Karl Wagner  &lt;razielim at gmail.com (mailto:razielim at gmail.com)&gt;  wrote:<br>&gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can optimise for the protocol being satisfied by a reference-counted type. Classes are semantically unique from values because they have identity, which is also something a protocol might want to codify.<br>&gt; &gt;  <br>&gt; &gt;<br>&gt; &gt;  <br>&gt; &gt; There may be some optimisation gains by requiring all conformers to be values, but   I struggle to think of why you might want to codify that a conformer should not have identity.<br>&gt; &gt;  <br>&gt; &gt;<br>&gt; &gt;  <br>&gt; &gt; Personally I don&#39;t really like this asymmetry in the language either, and would support changes to make these two elements more explicit. For example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied only by classes, and moving the optimisation guides to usage site (e.g. when declaring a variable of type MyProto, I could declare it of type AnyClass&lt;MyProto&gt;  or AnyValue&lt;MyProto&gt;  instead, to annotate this specific instance as being refcountable or not, without making such optimisation hints part of the MyProto definition)<br>&gt; &gt;    <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; - Karl<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;<br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; On Oct 21, 2016 at 8:39 am,  &lt;Mike Kasianowicz via swift-evolution (mailto:swift-evolution at swift.org)&gt;  wrote:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;      <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Currently protocols can have the class constraint: <br>&gt; &gt; &gt; protocol MyProtocol : class {}<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; These types of restrictions can help prevent accidental anti-patterns or misuse of APIs.<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; Seems simple and non-controversial... right?<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in the future.    For example, a protocol describing an enum with a common case, or a struct with no reference members. Great stuff for defensively coding APIs.]<br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;  <br>&gt; &gt; &gt;   _______________________________________________ swift-evolution mailing list  swift-evolution at swift.org (mailto:swift-evolution at swift.org)   https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt; &gt;  <br>&gt;  <br>&gt;  <br>&gt;          <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/fc021e52/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>October 21, 2016 at 12:00:00pm</p></header><div class="content"><p>I would like the ability to specify that something is an enum so that I<br>could model a generic `Result` type.<br></p><p>```<br>protocol Result : enum {<br>    associatedtype Payload<br>    case success(Payload)<br>    case failure(Error)<br>}<br>```<br></p><p>the basic idea being that I could then, while conforming, state which cases<br>in the concrete type serve as the protocol&#39;s case.  I don&#39;t have a great<br>vision for the syntax of spelling this conformance so I will make this<br>painfully verbose to be clear<br></p><p>```<br>enum UserParseResult {<br>    case success(User)<br>    case failure(Error)<br>}<br></p><p>extension UserParseResult : Result {<br>    protocol(Result) case success = UserParseResult.success<br>    protocol(Result) case failure = UserParseResult.failure<br>}<br>```<br></p><p><br>The benefit of this, in my opinion, is that we could have code commonly<br>used on results everywhere written once on the protocol without sacrificing<br>the ability to switch with guarantees. I can see that this suggestion has<br>some rough points so all I will finish by restating the problem that I want<br>to solve.<br></p><p>There is code that is fairly common to enum types that have shared<br>characteristics and/or purpose. I would find it useful to have a way to<br>implement shared algorithms in a generic way while retaining core features<br>of enums.<br></p><p>On Fri, Oct 21, 2016 at 11:11 AM, Mike Kasianowicz via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Just from an outside perspective, the class restriction seems to be there<br>&gt; as a kludge for technical reasons... but that&#39;s neither here nor there.<br>&gt;<br>&gt; It is not so much to enforce a lack of identity - in the struct case, it<br>&gt; would be to enforce copy-by-value semantics.  I think the strongest<br>&gt; argument I&#39;ve got is, say, a serialization or caching framework where you<br>&gt; want to enforce that something is entirely writeable via memory pointer or<br>&gt; copyable.  A value-type restriction would get us mostly there, albeit there<br>&gt; would still be ways to break the contract.  However, as noted in my<br>&gt; previous email, I see a lot of possibilities for enums too - in that case<br>&gt; the protocol somewhat acts as &#39;base type&#39; without adding the complexity of<br>&gt; a base type.<br>&gt;<br>&gt; I listed some of my examples in my previous email - I could elaborate if<br>&gt; it helps.<br>&gt;<br>&gt; On Fri, Oct 21, 2016 at 9:51 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can<br>&gt;&gt; optimise for the protocol being satisfied by a reference-counted type.<br>&gt;&gt; Classes are semantically unique from values because they have identity,<br>&gt;&gt; which is also something a protocol might want to codify.<br>&gt;&gt;<br>&gt;&gt; There may be some optimisation gains by requiring all conformers to be<br>&gt;&gt; values, but I struggle to think of why you might want to codify that a<br>&gt;&gt; conformer should not have identity.<br>&gt;&gt;<br>&gt;&gt; Personally I don&#39;t really like this asymmetry in the language either, and<br>&gt;&gt; would support changes to make these two elements more explicit. For<br>&gt;&gt; example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied<br>&gt;&gt; only by classes, and moving the optimisation guides to usage site (e.g.<br>&gt;&gt; when declaring a variable of type MyProto, I could declare it of type<br>&gt;&gt; AnyClass&lt;MyProto&gt; or AnyValue&lt;MyProto&gt; instead, to annotate this specific<br>&gt;&gt; instance as being refcountable or not, without making such optimisation<br>&gt;&gt; hints part of the MyProto definition)<br>&gt;&gt;<br>&gt;&gt; - Karl<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Oct 21, 2016 at 8:39 am, &lt;Mike Kasianowicz via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Currently protocols can have the class constraint:<br>&gt;&gt; protocol MyProtocol : class {}<br>&gt;&gt;<br>&gt;&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt;&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;&gt;<br>&gt;&gt; These types of restrictions can help prevent accidental anti-patterns or<br>&gt;&gt; misuse of APIs.<br>&gt;&gt;<br>&gt;&gt; Seems simple and non-controversial... right?<br>&gt;&gt;<br>&gt;&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in<br>&gt;&gt; the future.  For example, a protocol describing an enum with a common case,<br>&gt;&gt; or a struct with no reference members. Great stuff for defensively coding<br>&gt;&gt; APIs.]<br>&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt; list swift-evolution at swift.org https://lists.swift.org/mailma<br>&gt;&gt; n/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/98736f3a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>October 21, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;d like to spin this a slightly different way.<br></p><p>While they&#39;re not exactly the same as structs because the compiler has<br>separate logic for exhaustiveness checking, enum cases have some<br>interesting properties that make them relatable:<br></p><p>* A case without a payload is like a static read-only property on the enum<br>type that is equal to a value of that type.<br>* A case with a payload is like a static function on the enum type that<br>creates and returns a value of that type.<br></p><p>The second point is interesting because if you have:<br></p><p>```<br>enum Foo {<br>  case bar(Int)<br>}<br>```<br></p><p>and you reference &quot;Foo.bar&quot; without a payload, what you get back is a<br>function of type (Int) -&gt; Foo.<br></p><p>So instead of casting your example as &quot;a protocol can be enum-constrained<br>and must contain certain cases&quot;, what if enums could just have their<br>conformance fall out naturally from the bullet point observations above?<br></p><p>In other words, your example protocol could be:<br></p><p>```<br>protocol Result {<br>  associatedtype Payload<br>  static func success(_ p: Payload) -&gt; Self<br>  static func failure(_ e: Error) -&gt; Self<br>}<br>```<br></p><p>and the cases provide the conformance without having to do anything extra:<br></p><p>```<br>enum UserParseResult: Result {<br>  typealias Payload = User  // can be omitted if it&#39;s inferred<br>  case success(User)<br>  case failure(Error)<br>}<br>```<br></p><p>Now there&#39;s a caveat here worth discussing: would the intention of an<br>&quot;enum-constrained protocol&quot; be to define the *only* cases it can have, or<br>just the minimal set? The former would let you do some interesting generic<br>protocol-constrained exhaustive pattern matching. However, given that no<br>other use of protocols defines an *exact* set (you don&#39;t say these are the<br>*only* methods/properties that a conforming type can implement), I think it<br>would be a hard sell to apply a stronger restriction specifically to enums.<br>In any case, it feels to me like an enum restricted to &quot;only these exact<br>cases&quot; calls more for a generic enum rather than a protocol-based solution.<br></p><p><br>On Fri, Oct 21, 2016 at 9:39 AM T.J. Usiyan via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I would like the ability to specify that something is an enum so that I<br>&gt; could model a generic `Result` type.<br>&gt;<br>&gt; ```<br>&gt; protocol Result : enum {<br>&gt;     associatedtype Payload<br>&gt;     case success(Payload)<br>&gt;     case failure(Error)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; the basic idea being that I could then, while conforming, state which<br>&gt; cases in the concrete type serve as the protocol&#39;s case.  I don&#39;t have a<br>&gt; great vision for the syntax of spelling this conformance so I will make<br>&gt; this painfully verbose to be clear<br>&gt;<br>&gt; ```<br>&gt; enum UserParseResult {<br>&gt;     case success(User)<br>&gt;     case failure(Error)<br>&gt; }<br>&gt;<br>&gt; extension UserParseResult : Result {<br>&gt;     protocol(Result) case success = UserParseResult.success<br>&gt;     protocol(Result) case failure = UserParseResult.failure<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; The benefit of this, in my opinion, is that we could have code commonly<br>&gt; used on results everywhere written once on the protocol without sacrificing<br>&gt; the ability to switch with guarantees. I can see that this suggestion has<br>&gt; some rough points so all I will finish by restating the problem that I want<br>&gt; to solve.<br>&gt;<br>&gt; There is code that is fairly common to enum types that have shared<br>&gt; characteristics and/or purpose. I would find it useful to have a way to<br>&gt; implement shared algorithms in a generic way while retaining core features<br>&gt; of enums.<br>&gt;<br>&gt; On Fri, Oct 21, 2016 at 11:11 AM, Mike Kasianowicz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Just from an outside perspective, the class restriction seems to be there<br>&gt; as a kludge for technical reasons... but that&#39;s neither here nor there.<br>&gt;<br>&gt; It is not so much to enforce a lack of identity - in the struct case, it<br>&gt; would be to enforce copy-by-value semantics.  I think the strongest<br>&gt; argument I&#39;ve got is, say, a serialization or caching framework where you<br>&gt; want to enforce that something is entirely writeable via memory pointer or<br>&gt; copyable.  A value-type restriction would get us mostly there, albeit there<br>&gt; would still be ways to break the contract.  However, as noted in my<br>&gt; previous email, I see a lot of possibilities for enums too - in that case<br>&gt; the protocol somewhat acts as &#39;base type&#39; without adding the complexity of<br>&gt; a base type.<br>&gt;<br>&gt; I listed some of my examples in my previous email - I could elaborate if<br>&gt; it helps.<br>&gt;<br>&gt; On Fri, Oct 21, 2016 at 9:51 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt; IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can<br>&gt; optimise for the protocol being satisfied by a reference-counted type.<br>&gt; Classes are semantically unique from values because they have identity,<br>&gt; which is also something a protocol might want to codify.<br>&gt;<br>&gt; There may be some optimisation gains by requiring all conformers to be<br>&gt; values, but I struggle to think of why you might want to codify that a<br>&gt; conformer should not have identity.<br>&gt;<br>&gt; Personally I don&#39;t really like this asymmetry in the language either, and<br>&gt; would support changes to make these two elements more explicit. For<br>&gt; example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied<br>&gt; only by classes, and moving the optimisation guides to usage site (e.g.<br>&gt; when declaring a variable of type MyProto, I could declare it of type<br>&gt; AnyClass&lt;MyProto&gt; or AnyValue&lt;MyProto&gt; instead, to annotate this specific<br>&gt; instance as being refcountable or not, without making such optimisation<br>&gt; hints part of the MyProto definition)<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt; On Oct 21, 2016 at 8:39 am, &lt;Mike Kasianowicz via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt; Currently protocols can have the class constraint:<br>&gt; protocol MyProtocol : class {}<br>&gt;<br>&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;<br>&gt; These types of restrictions can help prevent accidental anti-patterns or<br>&gt; misuse of APIs.<br>&gt;<br>&gt; Seems simple and non-controversial... right?<br>&gt;<br>&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in the<br>&gt; future.  For example, a protocol describing an enum with a common case, or<br>&gt; a struct with no reference members. Great stuff for defensively coding<br>&gt; APIs.]<br>&gt; _______________________________________________ swift-evolution mailing<br>&gt; list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/2d2d904d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>October 22, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 21, 2016, at 12:23 PM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Now there&#39;s a caveat here worth discussing: would the intention of an &quot;enum-constrained protocol&quot; be to define the *only* cases it can have, or just the minimal set? The former would let you do some interesting generic protocol-constrained exhaustive pattern matching. However, given that no other use of protocols defines an *exact* set (you don&#39;t say these are the *only* methods/properties that a conforming type can implement), I think it would be a hard sell to apply a stronger restriction specifically to enums. In any case, it feels to me like an enum restricted to &quot;only these exact cases&quot; calls more for a generic enum rather than a protocol-based solution.<br></p><p>I would say it should define the minimal set, and any switching over the generic protocol type needs either a `default` or a `case _` clause to handle concrete types which have more cases than the protocol requires.<br></p><p>- Dave Sweeris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b18bf9a0c7bfa962aa136a3e8f18edb0?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Mike Kasianowicz</string> &lt;mike at ap14.com&gt;<p>October 21, 2016 at 12:00:00pm</p></header><div class="content"><p>Hooray, I&#39;m not the only one.<br></p><p>I agree copying is a much more nuanced issue- but sometimes struct is close<br>enough.<br></p><p>What I would really like is &quot;this is a data-only type&quot; rather than<br>&quot;struct&quot;.  But short-term, I&#39;d take the struct restriction if it&#39;s a simple<br>change. If we ever had a more specific constraint like that, my<br>hypothetical API will break many more clients if people have implemented my<br>protocol as a class.  I&#39;m considering runtime enforcement, but this is<br>clearly something that the compiler can do, and the question is whether it<br>should.  I would argue yes - one of the great things about Swift is getting<br>your head out of the technical weeds and thinking at a higher level.<br></p><p>Protocol-oriented programming could be much more concise and allow for some<br>really awesome high-level things to be done and enforced - ex: MVC, MVVM,<br>MVP, VIPER whatever your UI approach is today - you could codify the<br>infrastructural paradigm and then require data-only types for the models,<br>or enum-only types for the events, to prevent dependency violations.  Great<br>for making frameworks safer, enforcing coding standards, etc.<br></p><p>Maybe long-term there could be user-defined constraints similar to the<br>proposed property decorator/annotation notation?<br></p><p>On Fri, Oct 21, 2016 at 11:38 AM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br></p><p>&gt; I would like the ability to specify that something is an enum so that I<br>&gt; could model a generic `Result` type.<br>&gt;<br>&gt; ```<br>&gt; protocol Result : enum {<br>&gt;     associatedtype Payload<br>&gt;     case success(Payload)<br>&gt;     case failure(Error)<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; the basic idea being that I could then, while conforming, state which<br>&gt; cases in the concrete type serve as the protocol&#39;s case.  I don&#39;t have a<br>&gt; great vision for the syntax of spelling this conformance so I will make<br>&gt; this painfully verbose to be clear<br>&gt;<br>&gt; ```<br>&gt; enum UserParseResult {<br>&gt;     case success(User)<br>&gt;     case failure(Error)<br>&gt; }<br>&gt;<br>&gt; extension UserParseResult : Result {<br>&gt;     protocol(Result) case success = UserParseResult.success<br>&gt;     protocol(Result) case failure = UserParseResult.failure<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt;<br>&gt; The benefit of this, in my opinion, is that we could have code commonly<br>&gt; used on results everywhere written once on the protocol without sacrificing<br>&gt; the ability to switch with guarantees. I can see that this suggestion has<br>&gt; some rough points so all I will finish by restating the problem that I want<br>&gt; to solve.<br>&gt;<br>&gt; There is code that is fairly common to enum types that have shared<br>&gt; characteristics and/or purpose. I would find it useful to have a way to<br>&gt; implement shared algorithms in a generic way while retaining core features<br>&gt; of enums.<br>&gt;<br>&gt; On Fri, Oct 21, 2016 at 11:11 AM, Mike Kasianowicz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Just from an outside perspective, the class restriction seems to be there<br>&gt;&gt; as a kludge for technical reasons... but that&#39;s neither here nor there.<br>&gt;&gt;<br>&gt;&gt; It is not so much to enforce a lack of identity - in the struct case, it<br>&gt;&gt; would be to enforce copy-by-value semantics.  I think the strongest<br>&gt;&gt; argument I&#39;ve got is, say, a serialization or caching framework where you<br>&gt;&gt; want to enforce that something is entirely writeable via memory pointer or<br>&gt;&gt; copyable.  A value-type restriction would get us mostly there, albeit there<br>&gt;&gt; would still be ways to break the contract.  However, as noted in my<br>&gt;&gt; previous email, I see a lot of possibilities for enums too - in that case<br>&gt;&gt; the protocol somewhat acts as &#39;base type&#39; without adding the complexity of<br>&gt;&gt; a base type.<br>&gt;&gt;<br>&gt;&gt; I listed some of my examples in my previous email - I could elaborate if<br>&gt;&gt; it helps.<br>&gt;&gt;<br>&gt;&gt; On Fri, Oct 21, 2016 at 9:51 AM, Karl Wagner &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; IIRC, the reason we have &quot;class&quot; there is for the optimiser, so it can<br>&gt;&gt;&gt; optimise for the protocol being satisfied by a reference-counted type.<br>&gt;&gt;&gt; Classes are semantically unique from values because they have identity,<br>&gt;&gt;&gt; which is also something a protocol might want to codify.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There may be some optimisation gains by requiring all conformers to be<br>&gt;&gt;&gt; values, but I struggle to think of why you might want to codify that a<br>&gt;&gt;&gt; conformer should not have identity.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Personally I don&#39;t really like this asymmetry in the language either,<br>&gt;&gt;&gt; and would support changes to make these two elements more explicit. For<br>&gt;&gt;&gt; example, a magic &quot;hasIdentity&quot; protocol which is automatically satisfied<br>&gt;&gt;&gt; only by classes, and moving the optimisation guides to usage site (e.g.<br>&gt;&gt;&gt; when declaring a variable of type MyProto, I could declare it of type<br>&gt;&gt;&gt; AnyClass&lt;MyProto&gt; or AnyValue&lt;MyProto&gt; instead, to annotate this specific<br>&gt;&gt;&gt; instance as being refcountable or not, without making such optimisation<br>&gt;&gt;&gt; hints part of the MyProto definition)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - Karl<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Oct 21, 2016 at 8:39 am, &lt;Mike Kasianowicz via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Currently protocols can have the class constraint:<br>&gt;&gt;&gt; protocol MyProtocol : class {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It would be (a) intuitive and (b) useful to allow such things as:<br>&gt;&gt;&gt; protocol Model : struct {} or protocol Event : enum {}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These types of restrictions can help prevent accidental anti-patterns or<br>&gt;&gt;&gt; misuse of APIs.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Seems simple and non-controversial... right?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; [Note: I&#39;d like to see even more heavy-handed protocol restrictions in<br>&gt;&gt;&gt; the future.  For example, a protocol describing an enum with a common case,<br>&gt;&gt;&gt; or a struct with no reference members. Great stuff for defensively coding<br>&gt;&gt;&gt; APIs.]<br>&gt;&gt;&gt; _______________________________________________ swift-evolution mailing<br>&gt;&gt;&gt; list swift-evolution at swift.org https://lists.swift.org/mailma<br>&gt;&gt;&gt; n/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161021/7e6fb624/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Pitch] Non-class type requirements on protocols (eg : struct, : enum)</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>October 23, 2016 at 01:00:00pm</p></header><div class="content"><p>As this discussion pops up again:<br>Am I the only one who dislikes the missing capitalization?<br>I don&#39;t see any value in recycling a keyword (and breaking with convention).<br></p><p>Imho it should be<br>protocol StructOnlyProtocol: Struct {<br>and<br>protocol ClassOnlyProtocol: Class {<br></p><p>- Tino<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
