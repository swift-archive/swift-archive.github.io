<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>C API Annotations outside of original header?</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>July 17, 2016 at 10:00:00pm</p></header><div class="content"><p>Hi, I’m hoping to add CF_SWIFT_NAME annotations to an imported Clang module (JNI) without editing the original header file itself. Is this possible, or is there a working alternative other than creating a Swift wrapper? Maybe this is trivial but C is not my strong point.<br></p><p>Specifically, there are a bunch of type names in the Android JNI that I’d rather just keep „Swifty“ (the CF_SWIFT_NAME additions are my own of course, working with a copy of the original file for now):<br></p><p>typedef unsigned char   		jboolean; // can be 0 or 1 - is this the same as CFBoolean?<br>typedef signed char     		jbyte CF_SWIFT_NAME(Int8);<br>typedef unsigned short  		jchar CF_SWIFT_NAME(UInt8);<br>typedef short           		jshort CF_SWIFT_NAME(Int16);<br>typedef int             			jint CF_SWIFT_NAME(Int32);<br>typedef long long       		jlong CF_SWIFT_NAME(Int);<br>typedef float           			jfloat CF_SWIFT_NAME(Float);<br>typedef double          		jdouble CF_SWIFT_NAME(Double);<br></p><p><br>Note that there’s no good way of wrapping these in pure Swift, as far as I can see (they show up throughout the rest of the APIs). Also, it’d be great if the following was possible from outside the header. Instead of:<br></p><p>typedef enum jobjectRefType {<br>    JNIInvalidRefType = 0,<br>    JNILocalRefType = 1,<br>    JNIGlobalRefType = 2,<br>    JNIWeakGlobalRefType = 3<br>} jobjectRefType;<br></p><p>… to use:<br></p><p>typedef NS_ENUM(NSInteger, jobjectRefType) {<br>    JNIInvalidRefType CF_SWIFT_NAME(invalid) = 0,<br>    JNILocalRefType CF_SWIFT_NAME(local) = 1,<br>    JNIGlobalRefType CF_SWIFT_NAME(global) = 2,<br>    JNIWeakGlobalRefType CF_SWIFT_NAME(weakGlobal) = 3<br>};<br></p><p><br>The final question is whether it’s at all possible to annotate this kind of API:<br></p><p>struct JNINativeInterface {<br>    jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,<br>                        jsize);<br>    // and about 100 more of these ...<br>}<br></p><p>This imports into Swift as jni.DefineClass(env, string, obj, bytes, size). Attempting to put a type annotation into the header results like this:<br></p><p>jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, size)<br>        CF_SWIFT_NAME(defineClass(env:name:object:byteContents:size:));<br></p><p>results in a strange warning: &quot;‚swift_name‘ attribute has invalid identifier for base name“. It is possible to just rename DefineClass to e.g. defineClass, via CF_SWIFT_NAME(defineClass); I assume this is because this is a function pointer on a struct rather than a global function.<br></p><p>Any help regarding the above would be much appreciated. Playing around with those changes locally has made huge improvements to the readability of Android/JNI-specific Swift code. If I can find a clean solution to this I’d like to finally clean up and upstream the SwiftJNI module I started here: https://github.com/SwiftAndroid/swift-jni &lt;https://github.com/SwiftAndroid/swift-jni&gt;<br></p><p>Thanks,<br>Geordie<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160717/8438da24/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: signature.asc<br>Type: application/pgp-signature<br>Size: 455 bytes<br>Desc: Message signed with OpenPGP using GPGMail<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160717/8438da24/attachment.sig&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>C API Annotations outside of original header?</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>July 17, 2016 at 03:00:00pm</p></header><div class="content"><p>On Sun, Jul 17, 2016 at 1:39 PM, Geordie J via swift-dev &lt;<br>swift-dev at swift.org&gt; wrote:<br></p><p>&gt; Hi, I’m hoping to add CF_SWIFT_NAME annotations to an imported Clang<br>&gt; module (JNI) without editing the original header file itself. Is this<br>&gt; possible, or is there a working alternative other than creating a Swift<br>&gt; wrapper? Maybe this is trivial but C is not my strong point.<br>&gt;<br></p><p>AIUI, apinotes were designed specifically to address this need.  You should<br>be able to augment the header with an apinotes set for that header.<br></p><p><br>&gt; Specifically, there are a bunch of type names in the Android JNI that I’d<br>&gt; rather just keep „Swifty“ (the CF_SWIFT_NAME additions are my own of<br>&gt; course, working with a copy of the original file for now):<br>&gt;<br>&gt; typedef unsigned char   jboolean; // can be 0 or 1 - is this the same as<br>&gt; CFBoolean?<br>&gt; typedef signed char     jbyte CF_SWIFT_NAME(Int8);<br>&gt; typedef unsigned short   jchar CF_SWIFT_NAME(UInt8);<br>&gt; typedef short           jshort CF_SWIFT_NAME(Int16);<br>&gt; typedef int             jint CF_SWIFT_NAME(Int32);<br>&gt; typedef long long       jlong CF_SWIFT_NAME(Int);<br>&gt; typedef float           jfloat CF_SWIFT_NAME(Float);<br>&gt; typedef double           jdouble CF_SWIFT_NAME(Double);<br>&gt;<br>&gt;<br>&gt; Note that there’s no good way of wrapping these in pure Swift, as far as I<br>&gt; can see (they show up throughout the rest of the APIs). Also, it’d be great<br>&gt; if the following was possible from outside the header. Instead of:<br>&gt;<br>&gt; typedef enum jobjectRefType {<br>&gt;     JNIInvalidRefType = 0,<br>&gt;     JNILocalRefType = 1,<br>&gt;     JNIGlobalRefType = 2,<br>&gt;     JNIWeakGlobalRefType = 3<br>&gt; } jobjectRefType;<br>&gt;<br>&gt; … to use:<br>&gt;<br>&gt; typedef NS_ENUM(NSInteger, jobjectRefType) {<br>&gt;     JNIInvalidRefType CF_SWIFT_NAME(invalid) = 0,<br>&gt;     JNILocalRefType CF_SWIFT_NAME(local) = 1,<br>&gt;     JNIGlobalRefType CF_SWIFT_NAME(global) = 2,<br>&gt;     JNIWeakGlobalRefType CF_SWIFT_NAME(weakGlobal) = 3<br>&gt; };<br>&gt;<br>&gt;<br>&gt; The final question is whether it’s at all possible to annotate this kind<br>&gt; of API:<br>&gt;<br>&gt; struct JNINativeInterface {<br>&gt;     jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const<br>&gt; jbyte*,<br>&gt;                         jsize);<br>&gt;     // and about 100 more of these ...<br>&gt; }<br>&gt;<br>&gt; This imports into Swift as *jni.DefineClass(env, string, obj, bytes,<br>&gt; size)*. Attempting to put a type annotation into the header results like<br>&gt; this:<br>&gt;<br>&gt; jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, size)<br>&gt;         CF_SWIFT_NAME(defineClass(env:name:object:byteContents:size:));<br>&gt;<br>&gt; results in a strange warning: &quot;‚swift_name‘ attribute has invalid<br>&gt; identifier for base name“. It *is* possible to just rename *DefineClass* to<br>&gt; e.g. *defineClass*, via CF_SWIFT_NAME(defineClass); I assume this is<br>&gt; because this is a function pointer on a struct rather than a global<br>&gt; function.<br>&gt;<br>&gt; Any help regarding the above would be much appreciated. Playing around<br>&gt; with those changes locally has made huge improvements to the readability of<br>&gt; Android/JNI-specific Swift code. If I can find a clean solution to this I’d<br>&gt; like to finally clean up and upstream the SwiftJNI module I started here:<br>&gt; https://github.com/SwiftAndroid/swift-jni<br>&gt;<br>&gt; Thanks,<br>&gt; Geordie<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;<br>&gt;<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160717/9d713c13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>C API Annotations outside of original header?</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>July 17, 2016 at 11:00:00pm</p></header><div class="content"><p>Is it possible that apinotes only works for Objective C? The only docs I&#39;ve<br>seen regarding them explicitly mention ObjC repeatedly<br>Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; schrieb am Mo., 18. Juli 2016 um<br>00:43:<br></p><p>&gt; On Sun, Jul 17, 2016 at 1:39 PM, Geordie J via swift-dev &lt;<br>&gt; swift-dev at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi, I’m hoping to add CF_SWIFT_NAME annotations to an imported Clang<br>&gt;&gt; module (JNI) without editing the original header file itself. Is this<br>&gt;&gt; possible, or is there a working alternative other than creating a Swift<br>&gt;&gt; wrapper? Maybe this is trivial but C is not my strong point.<br>&gt;&gt;<br>&gt;<br>&gt; AIUI, apinotes were designed specifically to address this need.  You<br>&gt; should be able to augment the header with an apinotes set for that header.<br>&gt;<br>&gt;<br>&gt;&gt; Specifically, there are a bunch of type names in the Android JNI that I’d<br>&gt;&gt; rather just keep „Swifty“ (the CF_SWIFT_NAME additions are my own of<br>&gt;&gt; course, working with a copy of the original file for now):<br>&gt;&gt;<br>&gt;&gt; typedef unsigned char   jboolean; // can be 0 or 1 - is this the same as<br>&gt;&gt; CFBoolean?<br>&gt;&gt; typedef signed char     jbyte CF_SWIFT_NAME(Int8);<br>&gt;&gt; typedef unsigned short   jchar CF_SWIFT_NAME(UInt8);<br>&gt;&gt; typedef short           jshort CF_SWIFT_NAME(Int16);<br>&gt;&gt; typedef int             jint CF_SWIFT_NAME(Int32);<br>&gt;&gt; typedef long long       jlong CF_SWIFT_NAME(Int);<br>&gt;&gt; typedef float           jfloat CF_SWIFT_NAME(Float);<br>&gt;&gt; typedef double           jdouble CF_SWIFT_NAME(Double);<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Note that there’s no good way of wrapping these in pure Swift, as far as<br>&gt;&gt; I can see (they show up throughout the rest of the APIs). Also, it’d be<br>&gt;&gt; great if the following was possible from outside the header. Instead of:<br>&gt;&gt;<br>&gt;&gt; typedef enum jobjectRefType {<br>&gt;&gt;     JNIInvalidRefType = 0,<br>&gt;&gt;     JNILocalRefType = 1,<br>&gt;&gt;     JNIGlobalRefType = 2,<br>&gt;&gt;     JNIWeakGlobalRefType = 3<br>&gt;&gt; } jobjectRefType;<br>&gt;&gt;<br>&gt;&gt; … to use:<br>&gt;&gt;<br>&gt;&gt; typedef NS_ENUM(NSInteger, jobjectRefType) {<br>&gt;&gt;     JNIInvalidRefType CF_SWIFT_NAME(invalid) = 0,<br>&gt;&gt;     JNILocalRefType CF_SWIFT_NAME(local) = 1,<br>&gt;&gt;     JNIGlobalRefType CF_SWIFT_NAME(global) = 2,<br>&gt;&gt;     JNIWeakGlobalRefType CF_SWIFT_NAME(weakGlobal) = 3<br>&gt;&gt; };<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The final question is whether it’s at all possible to annotate this kind<br>&gt;&gt; of API:<br>&gt;&gt;<br>&gt;&gt; struct JNINativeInterface {<br>&gt;&gt;     jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const<br>&gt;&gt; jbyte*,<br>&gt;&gt;                         jsize);<br>&gt;&gt;     // and about 100 more of these ...<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; This imports into Swift as *jni.DefineClass(env, string, obj, bytes,<br>&gt;&gt; size)*. Attempting to put a type annotation into the header results like<br>&gt;&gt; this:<br>&gt;&gt;<br>&gt;&gt; jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, size)<br>&gt;&gt;         CF_SWIFT_NAME(defineClass(env:name:object:byteContents:size:));<br>&gt;&gt;<br>&gt;&gt; results in a strange warning: &quot;‚swift_name‘ attribute has invalid<br>&gt;&gt; identifier for base name“. It *is* possible to just rename *DefineClass* to<br>&gt;&gt; e.g. *defineClass*, via CF_SWIFT_NAME(defineClass); I assume this is<br>&gt;&gt; because this is a function pointer on a struct rather than a global<br>&gt;&gt; function.<br>&gt;&gt;<br>&gt;&gt; Any help regarding the above would be much appreciated. Playing around<br>&gt;&gt; with those changes locally has made huge improvements to the readability of<br>&gt;&gt; Android/JNI-specific Swift code. If I can find a clean solution to this I’d<br>&gt;&gt; like to finally clean up and upstream the SwiftJNI module I started here:<br>&gt;&gt; https://github.com/SwiftAndroid/swift-jni<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; Geordie<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-dev mailing list<br>&gt;&gt; swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160717/7e5af5f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/537cdf5303cfb8f536e251c89042cbfd?s=50"></div><header><strong>C API Annotations outside of original header?</strong> from <string>Saleem Abdulrasool</string> &lt;compnerd at compnerd.org&gt;<p>July 17, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sun, Jul 17, 2016 at 4:10 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br></p><p>&gt; Is it possible that apinotes only works for Objective C? The only docs<br>&gt; I&#39;ve seen regarding them explicitly mention ObjC repeatedly<br></p><p><br>I would find that hard to believe given that it is used for importing<br>libdispatch (C) into Swift.<br></p><p><br>&gt; Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; schrieb am Mo., 18. Juli 2016<br>&gt; um 00:43:<br>&gt;<br>&gt;&gt; On Sun, Jul 17, 2016 at 1:39 PM, Geordie J via swift-dev &lt;<br>&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hi, I’m hoping to add CF_SWIFT_NAME annotations to an imported Clang<br>&gt;&gt;&gt; module (JNI) without editing the original header file itself. Is this<br>&gt;&gt;&gt; possible, or is there a working alternative other than creating a Swift<br>&gt;&gt;&gt; wrapper? Maybe this is trivial but C is not my strong point.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; AIUI, apinotes were designed specifically to address this need.  You<br>&gt;&gt; should be able to augment the header with an apinotes set for that header.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Specifically, there are a bunch of type names in the Android JNI that<br>&gt;&gt;&gt; I’d rather just keep „Swifty“ (the CF_SWIFT_NAME additions are my own of<br>&gt;&gt;&gt; course, working with a copy of the original file for now):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typedef unsigned char   jboolean; // can be 0 or 1 - is this the same<br>&gt;&gt;&gt; as CFBoolean?<br>&gt;&gt;&gt; typedef signed char     jbyte CF_SWIFT_NAME(Int8);<br>&gt;&gt;&gt; typedef unsigned short   jchar CF_SWIFT_NAME(UInt8);<br>&gt;&gt;&gt; typedef short           jshort CF_SWIFT_NAME(Int16);<br>&gt;&gt;&gt; typedef int             jint CF_SWIFT_NAME(Int32);<br>&gt;&gt;&gt; typedef long long       jlong CF_SWIFT_NAME(Int);<br>&gt;&gt;&gt; typedef float           jfloat CF_SWIFT_NAME(Float);<br>&gt;&gt;&gt; typedef double           jdouble CF_SWIFT_NAME(Double);<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Note that there’s no good way of wrapping these in pure Swift, as far as<br>&gt;&gt;&gt; I can see (they show up throughout the rest of the APIs). Also, it’d be<br>&gt;&gt;&gt; great if the following was possible from outside the header. Instead of:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typedef enum jobjectRefType {<br>&gt;&gt;&gt;     JNIInvalidRefType = 0,<br>&gt;&gt;&gt;     JNILocalRefType = 1,<br>&gt;&gt;&gt;     JNIGlobalRefType = 2,<br>&gt;&gt;&gt;     JNIWeakGlobalRefType = 3<br>&gt;&gt;&gt; } jobjectRefType;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; … to use:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; typedef NS_ENUM(NSInteger, jobjectRefType) {<br>&gt;&gt;&gt;     JNIInvalidRefType CF_SWIFT_NAME(invalid) = 0,<br>&gt;&gt;&gt;     JNILocalRefType CF_SWIFT_NAME(local) = 1,<br>&gt;&gt;&gt;     JNIGlobalRefType CF_SWIFT_NAME(global) = 2,<br>&gt;&gt;&gt;     JNIWeakGlobalRefType CF_SWIFT_NAME(weakGlobal) = 3<br>&gt;&gt;&gt; };<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The final question is whether it’s at all possible to annotate this kind<br>&gt;&gt;&gt; of API:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; struct JNINativeInterface {<br>&gt;&gt;&gt;     jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const<br>&gt;&gt;&gt; jbyte*,<br>&gt;&gt;&gt;                         jsize);<br>&gt;&gt;&gt;     // and about 100 more of these ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This imports into Swift as *jni.DefineClass(env, string, obj, bytes,<br>&gt;&gt;&gt; size)*. Attempting to put a type annotation into the header results<br>&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*, size)<br>&gt;&gt;&gt;         CF_SWIFT_NAME(defineClass(env:name:object:byteContents:size:));<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; results in a strange warning: &quot;‚swift_name‘ attribute has invalid<br>&gt;&gt;&gt; identifier for base name“. It *is* possible to just rename *DefineClass* to<br>&gt;&gt;&gt; e.g. *defineClass*, via CF_SWIFT_NAME(defineClass); I assume this is<br>&gt;&gt;&gt; because this is a function pointer on a struct rather than a global<br>&gt;&gt;&gt; function.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Any help regarding the above would be much appreciated. Playing around<br>&gt;&gt;&gt; with those changes locally has made huge improvements to the readability of<br>&gt;&gt;&gt; Android/JNI-specific Swift code. If I can find a clean solution to this I’d<br>&gt;&gt;&gt; like to finally clean up and upstream the SwiftJNI module I started here:<br>&gt;&gt;&gt; https://github.com/SwiftAndroid/swift-jni<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Geordie<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Saleem Abdulrasool<br>&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br>Saleem Abdulrasool<br>compnerd (at) compnerd (dot) org<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160717/1cc24fdd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4db4fede2f4e473341b873406b68e4e1?s=50"></div><header><strong>C API Annotations outside of original header?</strong> from <string>Geordie Jay</string> &lt;geojay at gmail.com&gt;<p>July 17, 2016 at 11:00:00pm</p></header><div class="content"><p>I see they&#39;re also used for CoreGraphics, which was the example they showed<br>at WWDC that put me onto the idea of using the annotations in the first<br>place. I&#39;ll look into it, thanks for the idea!<br>Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; schrieb am Mo., 18. Juli 2016 um<br>01:23:<br></p><p>&gt; On Sun, Jul 17, 2016 at 4:10 PM, Geordie Jay &lt;geojay at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; Is it possible that apinotes only works for Objective C? The only docs<br>&gt;&gt; I&#39;ve seen regarding them explicitly mention ObjC repeatedly<br>&gt;<br>&gt;<br>&gt; I would find that hard to believe given that it is used for importing<br>&gt; libdispatch (C) into Swift.<br>&gt;<br>&gt;<br>&gt;&gt; Saleem Abdulrasool &lt;compnerd at compnerd.org&gt; schrieb am Mo., 18. Juli 2016<br>&gt;&gt; um 00:43:<br>&gt;&gt;<br>&gt;&gt;&gt; On Sun, Jul 17, 2016 at 1:39 PM, Geordie J via swift-dev &lt;<br>&gt;&gt;&gt; swift-dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Hi, I’m hoping to add CF_SWIFT_NAME annotations to an imported Clang<br>&gt;&gt;&gt;&gt; module (JNI) without editing the original header file itself. Is this<br>&gt;&gt;&gt;&gt; possible, or is there a working alternative other than creating a Swift<br>&gt;&gt;&gt;&gt; wrapper? Maybe this is trivial but C is not my strong point.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; AIUI, apinotes were designed specifically to address this need.  You<br>&gt;&gt;&gt; should be able to augment the header with an apinotes set for that header.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Specifically, there are a bunch of type names in the Android JNI that<br>&gt;&gt;&gt;&gt; I’d rather just keep „Swifty“ (the CF_SWIFT_NAME additions are my own of<br>&gt;&gt;&gt;&gt; course, working with a copy of the original file for now):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typedef unsigned char   jboolean; // can be 0 or 1 - is this the same<br>&gt;&gt;&gt;&gt; as CFBoolean?<br>&gt;&gt;&gt;&gt; typedef signed char     jbyte CF_SWIFT_NAME(Int8);<br>&gt;&gt;&gt;&gt; typedef unsigned short   jchar CF_SWIFT_NAME(UInt8);<br>&gt;&gt;&gt;&gt; typedef short           jshort CF_SWIFT_NAME(Int16);<br>&gt;&gt;&gt;&gt; typedef int             jint CF_SWIFT_NAME(Int32);<br>&gt;&gt;&gt;&gt; typedef long long       jlong CF_SWIFT_NAME(Int);<br>&gt;&gt;&gt;&gt; typedef float           jfloat CF_SWIFT_NAME(Float);<br>&gt;&gt;&gt;&gt; typedef double           jdouble CF_SWIFT_NAME(Double);<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Note that there’s no good way of wrapping these in pure Swift, as far<br>&gt;&gt;&gt;&gt; as I can see (they show up throughout the rest of the APIs). Also, it’d be<br>&gt;&gt;&gt;&gt; great if the following was possible from outside the header. Instead of:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typedef enum jobjectRefType {<br>&gt;&gt;&gt;&gt;     JNIInvalidRefType = 0,<br>&gt;&gt;&gt;&gt;     JNILocalRefType = 1,<br>&gt;&gt;&gt;&gt;     JNIGlobalRefType = 2,<br>&gt;&gt;&gt;&gt;     JNIWeakGlobalRefType = 3<br>&gt;&gt;&gt;&gt; } jobjectRefType;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; … to use:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; typedef NS_ENUM(NSInteger, jobjectRefType) {<br>&gt;&gt;&gt;&gt;     JNIInvalidRefType CF_SWIFT_NAME(invalid) = 0,<br>&gt;&gt;&gt;&gt;     JNILocalRefType CF_SWIFT_NAME(local) = 1,<br>&gt;&gt;&gt;&gt;     JNIGlobalRefType CF_SWIFT_NAME(global) = 2,<br>&gt;&gt;&gt;&gt;     JNIWeakGlobalRefType CF_SWIFT_NAME(weakGlobal) = 3<br>&gt;&gt;&gt;&gt; };<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; The final question is whether it’s at all possible to annotate this<br>&gt;&gt;&gt;&gt; kind of API:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; struct JNINativeInterface {<br>&gt;&gt;&gt;&gt;     jclass      (*DefineClass)(JNIEnv*, const char*, jobject, const<br>&gt;&gt;&gt;&gt; jbyte*,<br>&gt;&gt;&gt;&gt;                         jsize);<br>&gt;&gt;&gt;&gt;     // and about 100 more of these ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; This imports into Swift as *jni.DefineClass(env, string, obj, bytes,<br>&gt;&gt;&gt;&gt; size)*. Attempting to put a type annotation into the header results<br>&gt;&gt;&gt;&gt; like this:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; jclass (*DefineClass)(JNIEnv*, const char*, jobject, const jbyte*,<br>&gt;&gt;&gt;&gt; size)<br>&gt;&gt;&gt;&gt;         CF_SWIFT_NAME(defineClass(env:name:object:byteContents:size:));<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; results in a strange warning: &quot;‚swift_name‘ attribute has invalid<br>&gt;&gt;&gt;&gt; identifier for base name“. It *is* possible to just rename<br>&gt;&gt;&gt;&gt; *DefineClass* to e.g. *defineClass*, via CF_SWIFT_NAME(defineClass); I<br>&gt;&gt;&gt;&gt; assume this is because this is a function pointer on a struct rather than a<br>&gt;&gt;&gt;&gt; global function.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Any help regarding the above would be much appreciated. Playing around<br>&gt;&gt;&gt;&gt; with those changes locally has made huge improvements to the readability of<br>&gt;&gt;&gt;&gt; Android/JNI-specific Swift code. If I can find a clean solution to this I’d<br>&gt;&gt;&gt;&gt; like to finally clean up and upstream the SwiftJNI module I started here:<br>&gt;&gt;&gt;&gt; https://github.com/SwiftAndroid/swift-jni<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Geordie<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt; swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Saleem Abdulrasool<br>&gt;&gt;&gt; compnerd (at) compnerd (dot) org<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Saleem Abdulrasool<br>&gt; compnerd (at) compnerd (dot) org<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160717/9a48eae7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
