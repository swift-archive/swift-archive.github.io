<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Deferred] SE-0026 Abstract classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  7, 2016 at 10:00:00am</p></header><div class="content"><p>The review of SE-0026 &quot;Abstract classes and methods&quot; ran from February 26...March 4, 2016. The proposal has been deferred from Swift 3. Discussion centered around whether abstract classes fit in the direction of Swift as a &quot;protocol-oriented&quot; language. Beyond any religious dogmas, Swift intends to be a *pragmatic* language that lets users get work done. The fact of the matter today is that one of Swift&#39;s primary target platforms is the inheritance-heavy Cocoa framework, and that Swift 2&#39;s protocols fall short of abstract classes in several respects, including:<br></p><p>- Protocols can require conforming types to provide properties, but extensions cannot instantiate storage into conforming types. Every conforming type must today satisfy a protocol&#39;s storage requirements itself.<br>- Type erasure is easier to accomplish using abstract base classes with generic subclasses. Protocol existentials today only support all-or-nothing type erasure, and don&#39;t support protocols with associated type or Self constraints at all.<br>- Protocols don&#39;t support language enforcement of separate implementor and user interfaces, since all of a protocol&#39;s requirements must be as visible as the conformance. An abstract base class can expose private or internal abstract requirements to its implementation subclasses while exporting a different interface for external users.<br>- Protocol extensions can provide default implementations, but there&#39;s no equivalent to &#39;super.&#39; today for a concrete implementation to be able to chain up to a default implementation.<br></p><p>Unfortunately, the core team is currently bandwidth-constrained and can&#39;t immediately participate to the degree we&#39;d like in the design of this important feature. Furthermore, &quot;completing generics&quot; is one of our primary goals for Swift 3, and proposals for addressing many of the above limitations with protocols are in various stages of discussion and design. We&#39;d like to revisit this feature once the core goals of Swift 3 have been addressed, so we can more accurately consider its value in the context of a more complete generics implementation, and so we can address the finer points of its design.<br></p><p>Some things to consider for future revision:<br></p><p>&gt; An abstract class cannot be instanciated. <br>&gt; <br></p><p>This can be prevented in cases when `AbstractClass(...)` is statically spelled, but the behavior of abstract class metatypes must be specified. Is `let classObject: AbstractClass.Type = AbstractClass.self` allowed? Does `let classObject = _typeByName(&quot;Module.AbstractClass&quot;)` work? If not, then the abstract class object cannot be used for metaprogramming or generic argument binding purposes. If it can be, then there&#39;s a static safety hole, since `classObject.init(requiredInitializer:)` would have to dynamically fail if `classObject` refers to an abstract class metatype.<br>&gt; When declaring an abstract property, you must specify which methods must be implemented : get, set, didSet, willSet. <br>&gt; <br>&gt; If you do not specify anything, only setter and getter are made abstract as below : <br>&gt; <br>&gt;     abstract var url : String<br></p><p>Only &#39;get&#39; and &#39;set&#39; are of interest for a property&#39;s interface. For consistency with protocol requirements, abstract properties should probably require an explicit &#39;{ get }&#39; or &#39;{ get set }&#39; declaration to indicate whether mutation is expected.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution-announce/attachments/20160307/95739e6a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Deferred] SE-0026 Abstract classes and methods</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March  7, 2016 at 06:00:00pm</p></header><div class="content"><p>Hello Joe,<br></p><p>A few quick questions came to mind after reading your answer, if you do not mind. You mention protocols falling short in some areas to provide part of the functionality that abstract classes provide, but is the concern that we may be making protocols harder and harder to pickup and use correctly by giving them so much responsibility?l<br></p><p>Also, do you think the lines between structs, protocols, and classes going to blend even more with these and other similar changes? <br></p><p>(Although only tangentially related perhaps...) Did the core team stated what they planned to do about pitfalls with dispatching and protocol extensions with default method in extensions being statically dispatched and actual method resolution then being dependent on the type of the reference rather than the instance the reference is pointing at? Is this area being addressed in Swift 3 at all?<br></p><p>Thank you in advance for your answers :).<br></p><p>Kind Regards,<br></p><p>Goffredo<br></p><p>Sent from my iPhone<br></p><p>&gt; On 7 Mar 2016, at 18:00, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The review of SE-0026 &quot;Abstract classes and methods&quot; ran from February 26...March 4, 2016. The proposal has been deferred from Swift 3. Discussion centered around whether abstract classes fit in the direction of Swift as a &quot;protocol-oriented&quot; language. Beyond any religious dogmas, Swift intends to be a *pragmatic* language that lets users get work done. The fact of the matter today is that one of Swift&#39;s primary target platforms is the inheritance-heavy Cocoa framework, and that Swift 2&#39;s protocols fall short of abstract classes in several respects, including:<br>&gt; <br>&gt; - Protocols can require conforming types to provide properties, but extensions cannot instantiate storage into conforming types. Every conforming type must today satisfy a protocol&#39;s storage requirements itself.<br>&gt; - Type erasure is easier to accomplish using abstract base classes with generic subclasses. Protocol existentials today only support all-or-nothing type erasure, and don&#39;t support protocols with associated type or Self constraints at all.<br>&gt; - Protocols don&#39;t support language enforcement of separate implementor and user interfaces, since all of a protocol&#39;s requirements must be as visible as the conformance. An abstract base class can expose private or internal abstract requirements to its implementation subclasses while exporting a different interface for external users.<br>&gt; - Protocol extensions can provide default implementations, but there&#39;s no equivalent to &#39;super.&#39; today for a concrete implementation to be able to chain up to a default implementation.<br>&gt; <br>&gt; Unfortunately, the core team is currently bandwidth-constrained and can&#39;t immediately participate to the degree we&#39;d like in the design of this important feature. Furthermore, &quot;completing generics&quot; is one of our primary goals for Swift 3, and proposals for addressing many of the above limitations with protocols are in various stages of discussion and design. We&#39;d like to revisit this feature once the core goals of Swift 3 have been addressed, so we can more accurately consider its value in the context of a more complete generics implementation, and so we can address the finer points of its design.<br>&gt; <br>&gt; Some things to consider for future revision:<br>&gt; <br>&gt;&gt; An abstract class cannot be instanciated. <br>&gt; <br>&gt; This can be prevented in cases when `AbstractClass(...)` is statically spelled, but the behavior of abstract class metatypes must be specified. Is `let classObject: AbstractClass.Type = AbstractClass.self` allowed? Does `let classObject = _typeByName(&quot;Module.AbstractClass&quot;)` work? If not, then the abstract class object cannot be used for metaprogramming or generic argument binding purposes. If it can be, then there&#39;s a static safety hole, since `classObject.init(requiredInitializer:)` would have to dynamically fail if `classObject` refers to an abstract class metatype.<br>&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : get, set, didSet, willSet. <br>&gt;&gt; <br>&gt;&gt; If you do not specify anything, only setter and getter are made abstract as below : <br>&gt;&gt; <br>&gt;&gt;     abstract var url : String<br>&gt; <br>&gt; Only &#39;get&#39; and &#39;set&#39; are of interest for a property&#39;s interface. For consistency with protocol requirements, abstract properties should probably require an explicit &#39;{ get }&#39; or &#39;{ get set }&#39; declaration to indicate whether mutation is expected.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/80569487/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Deferred] SE-0026 Abstract classes and methods</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  7, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 7, 2016, at 10:10 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hello Joe,<br>&gt; <br>&gt; A few quick questions came to mind after reading your answer, if you do not mind. You mention protocols falling short in some areas to provide part of the functionality that abstract classes provide, but is the concern that we may be making protocols harder and harder to pickup and use correctly by giving them so much responsibility?l<br></p><p>There&#39;s always a tradeoff between power and complexity. Some discussions have proposed separating &quot;mixins&quot; from protocol extensions as a more clearly delineated feature for composing storage and associated functionality into objects, which would offload some of the responsibility from protocols.<br></p><p>&gt; Also, do you think the lines between structs, protocols, and classes going to blend even more with these and other similar changes? <br>&gt; <br>&gt; (Although only tangentially related perhaps...) Did the core team stated what they planned to do about pitfalls with dispatching and protocol extensions with default method in extensions being statically dispatched and actual method resolution then being dependent on the type of the reference rather than the instance the reference is pointing at? Is this area being addressed in Swift 3 at all?<br></p><p>It&#39;s something we&#39;d like to address, yes. Two options that have been discussed are to provide better diagnostics for the current behavior, or to make extension methods dynamically dispatched themselves.<br></p><p>-Joe<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a83279e420d8a16da6441b8333b93775?s=50"></div><header><strong>[Deferred] SE-0026 Abstract classes and methods</strong> from <string>David Scrève</string> &lt;david.screve at dlta-studio.com&gt;<p>March  7, 2016 at 07:00:00pm</p></header><div class="content"><p>Regarding the whole discussion about this topic, I think this decision is really a good one.<br></p><p>	Actually, even Swift source code use abstract classes.<br></p><p>	Thanks to all for this really interesting discussion about this proposal.<br></p><p>--<br>David Scrève - DLTA Studio<br>Gérant - 06 27 69 58 14<br>david.screve at dlta-studio.com<br></p><p>&gt; Le 7 mars 2016 à 19:00, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; The review of SE-0026 &quot;Abstract classes and methods&quot; ran from February 26...March 4, 2016. The proposal has been deferred from Swift 3. Discussion centered around whether abstract classes fit in the direction of Swift as a &quot;protocol-oriented&quot; language. Beyond any religious dogmas, Swift intends to be a *pragmatic* language that lets users get work done. The fact of the matter today is that one of Swift&#39;s primary target platforms is the inheritance-heavy Cocoa framework, and that Swift 2&#39;s protocols fall short of abstract classes in several respects, including:<br>&gt; <br>&gt; - Protocols can require conforming types to provide properties, but extensions cannot instantiate storage into conforming types. Every conforming type must today satisfy a protocol&#39;s storage requirements itself.<br>&gt; - Type erasure is easier to accomplish using abstract base classes with generic subclasses. Protocol existentials today only support all-or-nothing type erasure, and don&#39;t support protocols with associated type or Self constraints at all.<br>&gt; - Protocols don&#39;t support language enforcement of separate implementor and user interfaces, since all of a protocol&#39;s requirements must be as visible as the conformance. An abstract base class can expose private or internal abstract requirements to its implementation subclasses while exporting a different interface for external users.<br>&gt; - Protocol extensions can provide default implementations, but there&#39;s no equivalent to &#39;super.&#39; today for a concrete implementation to be able to chain up to a default implementation.<br>&gt; <br>&gt; Unfortunately, the core team is currently bandwidth-constrained and can&#39;t immediately participate to the degree we&#39;d like in the design of this important feature. Furthermore, &quot;completing generics&quot; is one of our primary goals for Swift 3, and proposals for addressing many of the above limitations with protocols are in various stages of discussion and design. We&#39;d like to revisit this feature once the core goals of Swift 3 have been addressed, so we can more accurately consider its value in the context of a more complete generics implementation, and so we can address the finer points of its design.<br>&gt; <br>&gt; Some things to consider for future revision:<br>&gt; <br>&gt; <br>&gt;&gt; An abstract class cannot be instanciated. <br>&gt; <br>&gt; This can be prevented in cases when `AbstractClass(...)` is statically spelled, but the behavior of abstract class metatypes must be specified. Is `let classObject: AbstractClass.Type = AbstractClass.self` allowed? Does `let classObject = _typeByName(&quot;Module.AbstractClass&quot;)` work? If not, then the abstract class object cannot be used for metaprogramming or generic argument binding purposes. If it can be, then there&#39;s a static safety hole, since `classObject.init(requiredInitializer:)` would have to dynamically fail if `classObject` refers to an abstract class metatype.<br>&gt; <br>&gt;&gt; When declaring an abstract property, you must specify which methods must be implemented : get, set, didSet, willSet. <br>&gt;&gt; <br>&gt;&gt; If you do not specify anything, only setter and getter are made abstract as below : <br>&gt;&gt; <br>&gt;&gt;     abstract var url : String<br>&gt; <br>&gt; Only &#39;get&#39; and &#39;set&#39; are of interest for a property&#39;s interface. For consistency with protocol requirements, abstract properties should probably require an explicit &#39;{ get }&#39; or &#39;{ get set }&#39; declaration to indicate whether mutation is expected.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/319b2dcc/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4233 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160307/319b2dcc/attachment.p7s&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
