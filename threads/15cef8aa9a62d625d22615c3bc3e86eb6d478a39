<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 17, 2016 at 10:00:00pm</p></header><div class="content"><p>A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br></p><p>Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br></p><p>&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br></p><p><br>turn into this in the Swift interface:<br></p><p>&gt; public let NSCocoaErrorDomain: String<br>&gt; public let NSPOSIXErrorDomain: String<br>&gt; public let NSOSStatusErrorDomain: String<br>&gt; public let NSMachErrorDomain: String<br></p><p>What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br></p><p>&gt; NS_CASE_LIST_BEGIN;<br>&gt; <br>&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt; <br>&gt; NS_CASE_LIST_END;<br></p><p>would be imported as follows:<br></p><p>&gt; enum ErrorDomain : String {<br>&gt;     case Cocoa<br>&gt;     case POSIX<br>&gt;     case OSStatus<br>&gt;     case Mach<br>&gt; }<br></p><p>I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/15ce8a39/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 17, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt; <br>&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt; <br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt; <br>&gt; <br>&gt; turn into this in the Swift interface:<br>&gt; <br>&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt; public let NSMachErrorDomain: String<br>&gt; <br>&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt; <br>&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt; <br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt; <br>&gt;&gt; NS_CASE_LIST_END;<br>&gt; <br>&gt; would be imported as follows:<br>&gt; <br>&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;     case Cocoa<br>&gt;&gt;     case POSIX<br>&gt;&gt;     case OSStatus<br>&gt;&gt;     case Mach<br>&gt;&gt; }<br>&gt; <br>&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br></p><p>FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br></p><p>  typedef NSString * NSErrorDomain __attribute__((enum(string)));<br></p><p>  FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>  FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>  FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>  FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br></p><p>The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br></p><p>Call that a +1 from me on your idea :)<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160117/fa953823/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 18, 2016 at 09:00:00am</p></header><div class="content"><p>Oh, that’s nice! Using the typedef would also allow Objective-C methods to be annotated with the type they expect while still allowing arbitrary strings for APIs where that’s necessary. Not only does that help in Swift—you wouldn’t have to use rawValue to pull the string values out when vending to the platform API—but it would give new developers to Apple platforms a head start on finding where those constants are defined in the headers.<br></p><p>I’ll write this up as a formal proposal using the typedef method, though I’m still all ears for any other comments/suggestions.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Jan 18, 2016, at 1:10 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt; <br>&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt; <br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt; <br>&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt; <br>&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt; <br>&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt; <br>&gt;&gt; would be imported as follows:<br>&gt;&gt; <br>&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt; <br>&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt; <br>&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt; <br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt; <br>&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt; <br>&gt; Call that a +1 from me on your idea :)<br>&gt; <br>&gt; 	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/29a5b209/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 18, 2016 at 12:00:00pm</p></header><div class="content"><p>I’ve got an in-progress proposal written up here:<br></p><p>https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md<br></p><p>I’ll leave it there for any additional comments/feedback, then submit later today.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Jan 18, 2016, at 9:52 AM, Jeff Kelley &lt;SlaunchaMan at gmail.com&gt; wrote:<br>&gt; <br>&gt; Oh, that’s nice! Using the typedef would also allow Objective-C methods to be annotated with the type they expect while still allowing arbitrary strings for APIs where that’s necessary. Not only does that help in Swift—you wouldn’t have to use rawValue to pull the string values out when vending to the platform API—but it would give new developers to Apple platforms a head start on finding where those constants are defined in the headers.<br>&gt; <br>&gt; I’ll write this up as a formal proposal using the typedef method, though I’m still all ears for any other comments/suggestions.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; On Jan 18, 2016, at 1:10 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be imported as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt;&gt; <br>&gt;&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt;&gt; <br>&gt;&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt;&gt; <br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt;&gt; <br>&gt;&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt;&gt; <br>&gt;&gt; Call that a +1 from me on your idea :)<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/30a6bce9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/00f9939846257c9db8ddc42ce61ec6d1?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Philippe Hausler</string> &lt;phausler at apple.com&gt;<p>January 18, 2016 at 09:00:00am</p></header><div class="content"><p>One note to those constants; there are a number of them (NSError domains in particular) that are intended to be a complement to the application space defines; such that your app could define a “MyGreatAppErrorDomain” and a “MyGreatFrameworkErrorDomain” in addition to the NSCocoaErrorDomain. So this isn’t exactly an enum but more so a non closed set of values. Enums are usually closed sets so that they can be switched upon exhaustively. Others would definitely improve the state of affairs for both objc and swift in that technically you could get a warning/error in objc if the type was not correct and there would be the swift ramifications you mentioned as well.<br></p><p>Examples:<br></p><p>@interface NSError : NSObject &lt;NSCopying, NSSecureCoding&gt;<br>…<br>- (instancetype)initWithDomain:(NSErrorDomain)domain code:(NSInteger)code userInfo:(nullable NSDictionary *)dict<br>…<br>@end<br></p><p>this would mean that the following code would not work (or should produce a warning)<br>[[NSError alloc] initWithDomain:@“MyAppDomain” code:42 userInfo:nil];<br></p><p>moreover in swift:<br>NSError(“MyAppDomain”, code:42, userInfo:nil) // would this even work?<br></p><p>On the other hand it might be useful for the (desperately in need of some updating) NSLocale method<br></p><p>@interface NSLocale : NSObject &lt;NSCopying, NSSecureCoding&gt;<br>...<br>- (nullable id)objectForKey:(NSLocaleKey)key; // we could limit the keys accepted here to just the appropriate values in the “enum&quot;<br>...<br>@end<br></p><p><br>From a brief survey of the APIs this would be useful for they mostly seem to be “dictionary based programming” cases which expose poorly in swift because they don’t have type safe return values. Adding more swift-friendly interfaces to those APIs is not off the table; because it is not just the keys that are the issue here but the return values too (see NSLocale’s example). Not to say we couldn’t do both, but would it be the case that if the un-typed return values that access by keys are replaced with better, more safe interfaces, this still be needed?<br></p><p><br>&gt; On Jan 18, 2016, at 9:13 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’ve got an in-progress proposal written up here:<br>&gt; <br>&gt; https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;<br>&gt; <br>&gt; I’ll leave it there for any additional comments/feedback, then submit later today.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; On Jan 18, 2016, at 9:52 AM, Jeff Kelley &lt;SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Oh, that’s nice! Using the typedef would also allow Objective-C methods to be annotated with the type they expect while still allowing arbitrary strings for APIs where that’s necessary. Not only does that help in Swift—you wouldn’t have to use rawValue to pull the string values out when vending to the platform API—but it would give new developers to Apple platforms a head start on finding where those constants are defined in the headers.<br>&gt;&gt; <br>&gt;&gt; I’ll write this up as a formal proposal using the typedef method, though I’m still all ears for any other comments/suggestions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jeff Kelley<br>&gt;&gt; <br>&gt;&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt;&gt; On Jan 18, 2016, at 1:10 AM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be imported as follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Call that a +1 from me on your idea :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/75fd8e67/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 18, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jan 18, 2016, at 12:41 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt; <br>&gt; One note to those constants; there are a number of them (NSError domains in particular) that are intended to be a complement to the application space defines; such that your app could define a “MyGreatAppErrorDomain” and a “MyGreatFrameworkErrorDomain” in addition to the NSCocoaErrorDomain. So this isn’t exactly an enum but more so a non closed set of values. Enums are usually closed sets so that they can be switched upon exhaustively. Others would definitely improve the state of affairs for both objc and swift in that technically you could get a warning/error in objc if the type was not correct and there would be the swift ramifications you mentioned as well.<br></p><p>Great point, and for that reason I switched away from NSError domains in my proposal. It’s a much more clear win to use this for something like HealthKit constants where values outside of the constants may not be used. For NSError domains, leaving the type as NSString is probably best to indicate that custom strings are supported.<br></p><p>&gt; On the other hand it might be useful for the (desperately in need of some updating) NSLocale method<br>&gt; <br>&gt; @interface NSLocale : NSObject &lt;NSCopying, NSSecureCoding&gt;<br>&gt; ...<br>&gt; - (nullable id)objectForKey:(NSLocaleKey)key; // we could limit the keys accepted here to just the appropriate values in the “enum&quot;<br>&gt; ...<br>&gt; @end<br>&gt; <br>&gt; <br>&gt; From a brief survey of the APIs this would be useful for they mostly seem to be “dictionary based programming” cases which expose poorly in swift because they don’t have type safe return values. Adding more swift-friendly interfaces to those APIs is not off the table; because it is not just the keys that are the issue here but the return values too (see NSLocale’s example). Not to say we couldn’t do both, but would it be the case that if the un-typed return values that access by keys are replaced with better, more safe interfaces, this still be needed?<br></p><p>The “dictionary based programming” examples could definitely use a bit of an API refresh, as you’ve noticed with the return types. This proposal’s real aim is APIs that use strings to mean one of a finite set of values. Take HealthKit:<br></p><p>&gt; + (nullable HKQuantityType *)quantityTypeForIdentifier:(NSString *)identifier;<br></p><p><br>The return value here is typesafe, but the identifier is a string. HKTypeIdentifiers.h defines these identifiers. Here’s one set:<br></p><p>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyMassIndex;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyFatPercentage;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierHeight;<br>&gt; HK_EXTERN NSString * const  HKQuantityTypeIdentifierBodyMass;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierLeanBodyMass;<br></p><p>Since the user isn’t permitted to use their own identifiers here, this is an ideal case for replacement. It also gives the user a better hint as to where to find these constants. Rewriting the Objective-C method along these lines:<br></p><p>&gt; + (nullable HKQuantityType *)quantityTypeForIdentifier:(HKQuantityTypeIdentifier)identifier;<br></p><p>Would give the user a hint in the name of the type for where to look in the documentation for these identifiers.<br></p><p>I think frameworks like HealthKit with constant string identifiers would benefit greatly from this change, as would other frameworks like CoreText with opaque keys and values used to construct dictionaries.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/c4567f57/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 18, 2016 at 10:00:00am</p></header><div class="content"><p>If the method param is annotated, not only does the user get a hint for<br>where to look in the docs, but you can omit the type name qualification,<br>saying quantityForTypeIdentifier(.BodyMass).<br></p><p>Sounds great to me.<br></p><p>Jacob<br></p><p>On Mon, Jan 18, 2016 at 10:20 AM, Jeff Kelley via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Jan 18, 2016, at 12:41 PM, Philippe Hausler &lt;phausler at apple.com&gt; wrote:<br>&gt;<br>&gt; One note to those constants; there are a number of them (NSError domains<br>&gt; in particular) that are intended to be a complement to the application<br>&gt; space defines; such that your app could define a “MyGreatAppErrorDomain”<br>&gt; and a “MyGreatFrameworkErrorDomain” in addition to the NSCocoaErrorDomain.<br>&gt; So this isn’t exactly an enum but more so a non closed set of values. Enums<br>&gt; are usually closed sets so that they can be switched upon exhaustively.<br>&gt; Others would definitely improve the state of affairs for both objc and<br>&gt; swift in that technically you could get a warning/error in objc if the type<br>&gt; was not correct and there would be the swift ramifications you mentioned as<br>&gt; well.<br>&gt;<br>&gt;<br>&gt; Great point, and for that reason I switched away from NSError domains in<br>&gt; my proposal. It’s a much more clear win to use this for something like<br>&gt; HealthKit constants where values outside of the constants may not be used.<br>&gt; For NSError domains, leaving the type as NSString is probably best to<br>&gt; indicate that custom strings are supported.<br>&gt;<br>&gt; On the other hand it might be useful for the (desperately in need of some<br>&gt; updating) NSLocale method<br>&gt;<br>&gt; @interface NSLocale : NSObject &lt;NSCopying, NSSecureCoding&gt;<br>&gt; ...<br>&gt; - (nullable id)objectForKey:(NSLocaleKey)key; // we could limit the keys<br>&gt; accepted here to just the appropriate values in the “enum&quot;<br>&gt; ...<br>&gt; @end<br>&gt;<br>&gt;<br>&gt; From a brief survey of the APIs this would be useful for they mostly seem<br>&gt; to be “dictionary based programming” cases which expose poorly in swift<br>&gt; because they don’t have type safe return values. Adding more swift-friendly<br>&gt; interfaces to those APIs is not off the table; because it is not just the<br>&gt; keys that are the issue here but the return values too (see NSLocale’s<br>&gt; example). Not to say we couldn’t do both, but would it be the case that if<br>&gt; the un-typed return values that access by keys are replaced with better,<br>&gt; more safe interfaces, this still be needed?<br>&gt;<br>&gt;<br>&gt; The “dictionary based programming” examples could definitely use a bit of<br>&gt; an API refresh, as you’ve noticed with the return types. This proposal’s<br>&gt; real aim is APIs that use strings to mean one of a finite set of values.<br>&gt; Take HealthKit:<br>&gt;<br>&gt; + (nullable HKQuantityType *)quantityTypeForIdentifier:(NSString<br>&gt; *)identifier;<br>&gt;<br>&gt;<br>&gt; The return value here is typesafe, but the identifier is a string.<br>&gt; HKTypeIdentifiers.h defines these identifiers. Here’s one set:<br>&gt;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyMassIndex;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierBodyFatPercentage;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierHeight;<br>&gt; HK_EXTERN NSString * const  HKQuantityTypeIdentifierBodyMass;<br>&gt; HK_EXTERN NSString * const HKQuantityTypeIdentifierLeanBodyMass;<br>&gt;<br>&gt;<br>&gt; Since the user isn’t permitted to use their own identifiers here, this is<br>&gt; an ideal case for replacement. It also gives the user a better hint as to<br>&gt; where to find these constants. Rewriting the Objective-C method along these<br>&gt; lines:<br>&gt;<br>&gt; + (nullable HKQuantityType<br>&gt; *)quantityTypeForIdentifier:(HKQuantityTypeIdentifier)identifier;<br>&gt;<br>&gt;<br>&gt; Would give the user a hint in the name of the type for where to look in<br>&gt; the documentation for these identifiers.<br>&gt;<br>&gt; I think frameworks like HealthKit with constant string identifiers would<br>&gt; benefit greatly from this change, as would other frameworks like CoreText<br>&gt; with opaque keys and values used to construct dictionaries.<br>&gt;<br>&gt;<br>&gt; Jeff Kelley<br>&gt;<br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; |<br>&gt; jeffkelley.org<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/5e8bbd70/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 18, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Jan 18, 2016, at 9:41 AM, Philippe Hausler via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One note to those constants; there are a number of them (NSError domains in particular) that are intended to be a complement to the application space defines; such that your app could define a “MyGreatAppErrorDomain” and a “MyGreatFrameworkErrorDomain” in addition to the NSCocoaErrorDomain. So this isn’t exactly an enum but more so a non closed set of values. Enums are usually closed sets so that they can be switched upon exhaustively. Others would definitely improve the state of affairs for both objc and swift in that technically you could get a warning/error in objc if the type was not correct and there would be the swift ramifications you mentioned as well.<br></p><p>Enums imported from C are effectively open, because C APIs frequently have both internal constants and add new constants with subsequent releases. So string-backed enum a aren&#39;t all that different in many cases. <br></p><p>I don&#39;t think error domains are a great example of this, though. For one, they&#39;re something that&#39;s tied in with the error handling model, and should be somewhat invisible. My favorite example is the set of text styles one can provide then getting a UIFont, such as UIFontTextStyleHeadline. It&#39;s more enum-like and benefits greatly from the leading dot syntax enum a provide. <br></p><p><br></p><p>&gt; Examples:<br>&gt; <br>&gt; @interface NSError : NSObject &lt;NSCopying, NSSecureCoding&gt;<br>&gt; …<br>&gt; - (instancetype)initWithDomain:(NSErrorDomain)domain code:(NSInteger)code userInfo:(nullable NSDictionary *)dict<br>&gt; …<br>&gt; @end<br>&gt; <br>&gt; this would mean that the following code would not work (or should produce a warning)<br>&gt; [[NSError alloc] initWithDomain:@“MyAppDomain” code:42 userInfo:nil];<br>&gt; <br>&gt; moreover in swift:<br>&gt; NSError(“MyAppDomain”, code:42, userInfo:nil) // would this even work?<br>&gt; <br>&gt; On the other hand it might be useful for the (desperately in need of some updating) NSLocale method<br>&gt; <br>&gt; @interface NSLocale : NSObject &lt;NSCopying, NSSecureCoding&gt;<br>&gt; ...<br>&gt; - (nullable id)objectForKey:(NSLocaleKey)key; // we could limit the keys accepted here to just the appropriate values in the “enum&quot;<br>&gt; ...<br>&gt; @end<br>&gt; <br>&gt; <br>&gt; From a brief survey of the APIs this would be useful for they mostly seem to be “dictionary based programming” cases which expose poorly in swift because they don’t have type safe return values. Adding more swift-friendly interfaces to those APIs is not off the table; because it is not just the keys that are the issue here but the return values too (see NSLocale’s example). Not to say we couldn’t do both, but would it be the case that if the un-typed return values that access by keys are replaced with better, more safe interfaces, this still be needed?<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 18, 2016, at 9:13 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’ve got an in-progress proposal written up here:<br>&gt;&gt; <br>&gt;&gt; https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md<br>&gt;&gt; <br>&gt;&gt; I’ll leave it there for any additional comments/feedback, then submit later today.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jeff Kelley<br>&gt;&gt; <br>&gt;&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 18, 2016, at 9:52 AM, Jeff Kelley &lt;SlaunchaMan at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, that’s nice! Using the typedef would also allow Objective-C methods to be annotated with the type they expect while still allowing arbitrary strings for APIs where that’s necessary. Not only does that help in Swift—you wouldn’t have to use rawValue to pull the string values out when vending to the platform API—but it would give new developers to Apple platforms a head start on finding where those constants are defined in the headers.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’ll write this up as a formal proposal using the typedef method, though I’m still all ears for any other comments/suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jeff Kelley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SlaunchaMan at gmail.com | @SlaunchaMan | jeffkelley.org<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 18, 2016, at 1:10 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be imported as follows:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Call that a +1 from me on your idea :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160118/7546abc9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jan 17, 2016, at 22:10 , Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt; <br>&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt; <br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt; <br>&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt; <br>&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt; <br>&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt; <br>&gt;&gt; would be imported as follows:<br>&gt;&gt; <br>&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt; <br>&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt; <br>&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt; <br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt; <br>&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt; <br>&gt; Call that a +1 from me on your idea :)<br></p><p>I still have reservations about this:<br></p><p>- Most of these strings are not things you switch on, making the enum-ness not particularly interesting. I&#39;d be happier with a RawRepresentable struct.<br>- Our current prefix-stripping logic relies on being able to see all the cases. You can do this with an enum because they&#39;re all declared in one block, but string constants they may cross multiple files. This isn&#39;t impossible to deal with, but I think it&#39;s counterintuitive. (An alternative would be to only use the type name for stripping each value individually.)<br>- I&#39;m not sure where the line is between &quot;an open set of choices represented as strings&quot; and &quot;strings with some defaults defined&quot;. (Very few of these are truly closed sets; if we add a new UIFont attribute next year, it should prefix-strip like everything else.)<br>- As a nitpick, I think a typedef for &#39;NSString&#39; rather than &#39;NSString *&#39; would be preferred, so that the &#39;*&#39; still shows up in the declaration in Objective-C. This is just a feeling though, and maybe it&#39;s just clinging to the way things are done now.<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/19fe4ae3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 2:11 PM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 17, 2016, at 22:10 , Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would be imported as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt;&gt; <br>&gt;&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt;&gt; <br>&gt;&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt;&gt; <br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt;&gt; <br>&gt;&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt;&gt; <br>&gt;&gt; Call that a +1 from me on your idea :)<br>&gt; <br>&gt; I still have reservations about this:<br>&gt; <br>&gt; - Most of these strings are not things you switch on, making the enum-ness not particularly interesting. I&#39;d be happier with a RawRepresentable struct.<br></p><p>I think a RawRepresentable struct captures the intended semantics well. Jeff, what do you think?<br></p><p>&gt; - Our current prefix-stripping logic relies on being able to see all the cases. You can do this with an enum because they&#39;re all declared in one block, but string constants they may cross multiple files. This isn&#39;t impossible to deal with, but I think it&#39;s counterintuitive. (An alternative would be to only use the type name for stripping each value individually.)<br></p><p>Our two options are to compare against just the type name or to compare against just the set of cases that come from the module that defines the typedef… except the latter might not be unique because typedefs can be redeclared in Objective-C and C++. I think that says we should just compare against the type name.<br></p><p>&gt; - I&#39;m not sure where the line is between &quot;an open set of choices represented as strings&quot; and &quot;strings with some defaults defined&quot;. (Very few of these are truly closed sets; if we add a new UIFont attribute next year, it should prefix-strip like everything else.)<br></p><p>Perhaps the line is a somewhat squishy “it is rare or impossible for a client of the API to define new values”?<br></p><p>&gt; - As a nitpick, I think a typedef for &#39;NSString&#39; rather than &#39;NSString *&#39; would be preferred, so that the &#39;*&#39; still shows up in the declaration in Objective-C. This is just a feeling though, and maybe it&#39;s just clinging to the way things are done now.’<br></p><p>WFM.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/e5ce2aae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 7:41 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 2:11 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 17, 2016, at 22:10 , Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would be imported as follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Call that a +1 from me on your idea :)<br>&gt;&gt; <br>&gt;&gt; I still have reservations about this:<br>&gt;&gt; <br>&gt;&gt; - Most of these strings are not things you switch on, making the enum-ness not particularly interesting. I&#39;d be happier with a RawRepresentable struct.<br>&gt; <br>&gt; I think a RawRepresentable struct captures the intended semantics well. Jeff, what do you think?<br></p><p>I haven’t used RawRepresentable by itself before. Is this the kind of result we’d get?<br></p><p>struct NSErrorDomain: RawRepresentable {<br>    <br>    static let Cocoa: MyRelatedValue<br>    static let POSIX: MyRelatedValue<br>    static let OSStatus: MyRelatedValue<br>    static let Mach: MyRelatedValue<br>    <br>    typealias RawValue = String<br>    <br>    init?(rawValue: RawValue)<br>    <br>    var rawValue: String  { get }<br></p><p>}<br></p><p>If so, I think that has the same benefits of an enum without the added baggage. We get a type for the values, a list of the public instances of the value, and the typedef in Objective-C even makes that language more readable. As long as we can still get to an instance of the value using the short dot syntax:<br></p><p>	let foo: NSErrorDomain = .Cocoa<br></p><p>Then I see no downside to a struct vs. an enum. The only reason I’d thought of an enum in the first place was that I’ve seen existing Swift code use enums to group related strings—user defaults keys, etc.<br></p><p><br>&gt;&gt; - Our current prefix-stripping logic relies on being able to see all the cases. You can do this with an enum because they&#39;re all declared in one block, but string constants they may cross multiple files. This isn&#39;t impossible to deal with, but I think it&#39;s counterintuitive. (An alternative would be to only use the type name for stripping each value individually.)<br>&gt; <br>&gt; Our two options are to compare against just the type name or to compare against just the set of cases that come from the module that defines the typedef… except the latter might not be unique because typedefs can be redeclared in Objective-C and C++. I think that says we should just compare against the type name.<br></p><p>Using the type name for stripping seems acceptable to me.<br></p><p>&gt;&gt; - I&#39;m not sure where the line is between &quot;an open set of choices represented as strings&quot; and &quot;strings with some defaults defined&quot;. (Very few of these are truly closed sets; if we add a new UIFont attribute next year, it should prefix-strip like everything else.)<br>&gt; <br>&gt; Perhaps the line is a somewhat squishy “it is rare or impossible for a client of the API to define new values”?<br></p><p>I agree. NSErrorDomain wasn’t a great example because you can define your own. My pull request used HealthKit identifiers, which are a better example as the user of the API can’t define their own.<br></p><p>Adding a new value in the future should definitely be as straightforward as possible, but I’m not sure what about this approach makes that more difficult.<br></p><p>&gt;&gt; - As a nitpick, I think a typedef for &#39;NSString&#39; rather than &#39;NSString *&#39; would be preferred, so that the &#39;*&#39; still shows up in the declaration in Objective-C. This is just a feeling though, and maybe it&#39;s just clinging to the way things are done now.’<br>&gt; <br>&gt; WFM.<br></p><p>Yep, that seems reasonable. Thanks for your feedback, Jordan and Doug!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/1a63033a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 20, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jan 20, 2016, at 6:39 PM, Jeff Kelley &lt;slaunchaman at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 7:41 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 2:11 PM, Jordan Rose &lt;jordan_rose at apple.com &lt;mailto:jordan_rose at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 17, 2016, at 22:10 , Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 17, 2016, at 7:13 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A lot of Cocoa APIs have long lists of constant values, typically NSStrings. I’d like to pitch a way to import them as enums with associated types. I can write up a full proposal if people think this is a good idea, but here’s my thinking:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s take the error domains in NSError.h for a quick example. These entries in the header:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; turn into this in the Swift interface:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSCocoaErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSPOSIXErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSOSStatusErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt;&gt; public let NSMachErrorDomain: String<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What I’m proposing is a way to import those as an enum instead. Similar to how we mark sections of Objective-C code with NS_ASSUME_NONNULL_BEGIN, we could mark it with something like NS_CASE_LIST_BEGIN. Then, this code:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_BEGIN;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; FOUNDATION_EXPORT NSString *const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; NS_CASE_LIST_END;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be imported as follows:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum ErrorDomain : String {<br>&gt;&gt;&gt;&gt;&gt;&gt;     case Cocoa<br>&gt;&gt;&gt;&gt;&gt;&gt;     case POSIX<br>&gt;&gt;&gt;&gt;&gt;&gt;     case OSStatus<br>&gt;&gt;&gt;&gt;&gt;&gt;     case Mach<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I can think of a lot of areas in Cocoa where these APIs could make things much more type-safe in Swift. Is this a good idea? Would people use this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, this has come up a number of times in discussions among Swift developers (although not, IIRC, on swift-evolution). Our current favored way to write this in (Objective-)C would be with a new typedef of NSString * that has some special attribute on it, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   typedef NSString * NSErrorDomain __attribute__((enum(string)));<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSCocoaErrorDomain;<br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSPOSIXErrorDomain;<br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSOSStatusErrorDomain;<br>&gt;&gt;&gt;&gt;   FOUNDATION_EXPORT NSErrorDomain const NSMachErrorDomain;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The typedef would import as a String-backed enum and all of the string constants declared with that typedef within the same module as the typedef would become cases of that enum. String constants declared with that typedef in a *different* module would become “static lets” within extensions of the String-backed enum.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Call that a +1 from me on your idea :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I still have reservations about this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Most of these strings are not things you switch on, making the enum-ness not particularly interesting. I&#39;d be happier with a RawRepresentable struct.<br>&gt;&gt; <br>&gt;&gt; I think a RawRepresentable struct captures the intended semantics well. Jeff, what do you think?<br>&gt; <br>&gt; I haven’t used RawRepresentable by itself before. Is this the kind of result we’d get?<br>&gt; <br>&gt; struct NSErrorDomain: RawRepresentable {<br>&gt;     <br>&gt;     static let Cocoa: MyRelatedValue<br>&gt;     static let POSIX: MyRelatedValue<br>&gt;     static let OSStatus: MyRelatedValue<br>&gt;     static let Mach: MyRelatedValue<br>&gt;     <br>&gt;     typealias RawValue = String<br>&gt;     <br>&gt;     init?(rawValue: RawValue)<br></p><p>This initializer should be non-failable; we’ll accept any raw value.<br></p><p>&gt;     var rawValue: String  { get }<br></p><p>Otherwise, yes, this is it.<br></p><p>&gt; If so, I think that has the same benefits of an enum without the added baggage. We get a type for the values, a list of the public instances of the value, and the typedef in Objective-C even makes that language more readable. As long as we can still get to an instance of the value using the short dot syntax:<br>&gt; <br>&gt; 	let foo: NSErrorDomain = .Cocoa<br></p><p>Yes, that works with static lets.<br></p><p>&gt; Then I see no downside to a struct vs. an enum. The only reason I’d thought of an enum in the first place was that I’ve seen existing Swift code use enums to group related strings—user defaults keys, etc.<br></p><p>Right. struct seems to model the uses of these string constants betters. FWIW, I suggest that you put “String” somewhere in the title of your proposal when you revise it.<br></p><p>&gt; Adding a new value in the future should definitely be as straightforward as possible, but I’m not sure what about this approach makes that more difficult.<br></p><p>I think it’s just a matter of declaring a new constant on the Objective-C side, and it’ll get pulled into the struct definition or (if the new constant is in a different module) an extension thereof.<br></p><p>	- Doug<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160120/14e1fbaa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 22, 2016 at 04:00:00pm</p></header><div class="content"><p>I have updated the proposal &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt; to use struct over enum (https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md).<br></p><p>&gt; On Jan 20, 2016, at 11:01 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; FWIW, I suggest that you put “String” somewhere in the title of your proposal when you revise it.<br></p><p>Would this need to be limited to strings? There are other “magic constants” that could conceivably be imported as structs—I’m thinking, for instance, error codes.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160122/2c95a940/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi everyone!<br></p><p>	I know there has been a lot of activity on other, larger proposals, but does anyone have any more feedback here? Proposal link: https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Jan 22, 2016, at 4:14 PM, Jeff Kelley &lt;SlaunchaMan at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have updated the proposal &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt; to use struct over enum (https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;).<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 11:01 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, I suggest that you put “String” somewhere in the title of your proposal when you revise it.<br>&gt; <br>&gt; Would this need to be limited to strings? There are other “magic constants” that could conceivably be imported as structs—I’m thinking, for instance, error codes.<br>&gt; <br>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/dc032fb1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 9:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone!<br>&gt; <br>&gt; 	I know there has been a lot of activity on other, larger proposals, but does anyone have any more feedback here? Proposal link: https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;<br>I have a few more comments.<br></p><p>typedef NSString * HKQuantityTypeIdentifier __attribute__((struct(string)));<br></p><p>I don’t think “struct(string)” is the right (Objective-)C attribute here. For one, we don’t need to restate the type “string” at all: we know what the type is because it’s the type behind the typedef. Additionally, this is a Swift-specific mapping. How about __attribute__((swift_struct_wrapper)), to indicate that it’s Swift-specific and that the annotated type is a wrapper struct?<br></p><p>I think you need to clarify a few things:<br></p><p>(1) How are the names of the constants transformed? It looks like you’re chopping off the common prefix between the type name and the enum constant name. Should the result have initial lowercase letters?<br>(2) What happens if additional constants are defined in a different module? (I assume that the new “static let”s go into an extension)<br></p><p>Otherwise, LGTM!<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; Jeff Kelley<br>&gt; <br>&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; On Jan 22, 2016, at 4:14 PM, Jeff Kelley &lt;SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have updated the proposal &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt; to use struct over enum (https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;).<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 20, 2016, at 11:01 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, I suggest that you put “String” somewhere in the title of your proposal when you revise it.<br>&gt;&gt; <br>&gt;&gt; Would this need to be limited to strings? There are other “magic constants” that could conceivably be imported as structs—I’m thinking, for instance, error codes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Jeff Kelley<br>&gt;&gt; <br>&gt;&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/2cc3d8c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 29, 2016, at 10:48 AM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 29, 2016, at 9:19 AM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi everyone!<br>&gt;&gt; <br>&gt;&gt; 	I know there has been a lot of activity on other, larger proposals, but does anyone have any more feedback here? Proposal link: https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;<br>&gt; I have a few more comments.<br>&gt; <br>&gt; typedef NSString * HKQuantityTypeIdentifier __attribute__((struct(string)));<br>&gt; <br>&gt; I don’t think “struct(string)” is the right (Objective-)C attribute here. For one, we don’t need to restate the type “string” at all: we know what the type is because it’s the type behind the typedef. Additionally, this is a Swift-specific mapping. How about __attribute__((swift_struct_wrapper)), to indicate that it’s Swift-specific and that the annotated type is a wrapper struct?<br></p><p>Hrm, maybe<br></p><p> 	__attribute__((swift_wrapper(struct)))<br></p><p>to leave space for<br></p><p>	__attribute__((swift_wrapper(enum))<br></p><p>which I’m sure we will want as well. I’m somewhat inclined to want both in the same proposal so we don’t have to revisit this later, because there are use cases for both.<br></p><p>&gt; <br>&gt; I think you need to clarify a few things:<br>&gt; <br>&gt; (1) How are the names of the constants transformed? It looks like you’re chopping off the common prefix between the type name and the enum constant name. Should the result have initial lowercase letters?<br>&gt; (2) What happens if additional constants are defined in a different module? (I assume that the new “static let”s go into an extension)<br>&gt; <br>&gt; Otherwise, LGTM!<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Jeff Kelley<br>&gt;&gt; <br>&gt;&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt;&gt; On Jan 22, 2016, at 4:14 PM, Jeff Kelley &lt;SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have updated the proposal &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt; to use struct over enum (https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 20, 2016, at 11:01 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I suggest that you put “String” somewhere in the title of your proposal when you revise it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would this need to be limited to strings? There are other “magic constants” that could conceivably be imported as structs—I’m thinking, for instance, error codes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jeff Kelley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; SlaunchaMan at gmail.com &lt;mailto:SlaunchaMan at gmail.com&gt; | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/bca9738c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>January 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Thanks for the feedback, everyone! I’ve updated the proposal &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt; again to use both _attribute__((swift_wrapper(struct))) and __attribute__((swift_wrapper(struct))). Like Doug, I think having both fits the largest number of use cases.<br></p><p>I also changed the accessors on struct items to use var instead of let, which matches how option set types are imported.<br></p><p>&gt; On Jan 29, 2016, at 1:48 PM, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; I think you need to clarify a few things:<br>&gt; <br>&gt; (1) How are the names of the constants transformed? It looks like you’re chopping off the common prefix between the type name and the enum constant name. Should the result have initial lowercase letters?<br></p><p>I’m removing both common prefixes and suffixes, if any. That way, both the “NS” and “ErrorDomain” of “NSErrorDomain” get chopped off. The initial result is uppercase to match existing imports (e.g. OptionSetType):<br></p><p>struct NSEnumerationOptions : OptionSetType &lt;file:///Users/jeff/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_OptionSetType_Protocol/index.html#//apple_ref/swift/intf/s:PSs13OptionSetType&gt; {<br>    init(rawValue rawValue: UInt &lt;file:///Users/jeff/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Swift/Reference/Swift_UInt_Structure/index.html#//apple_ref/swift/struct/s:Su&gt;)<br>    static var Concurrent: NSEnumerationOptions &lt;file:///Users/jeff/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/swift/struct/c:@E at NSEnumerationOptions&gt; { get }<br>    static var Reverse: NSEnumerationOptions &lt;file:///Users/jeff/Library/Developer/Shared/Documentation/DocSets/com.apple.adc.documentation.iOS.docset/Contents/Resources/Documents/documentation/Cocoa/Reference/Foundation/Miscellaneous/Foundation_Constants/index.html#//apple_ref/swift/struct/c:@E at NSEnumerationOptions&gt; { get }<br>}<br></p><p>&gt; (2) What happens if additional constants are defined in a different module? (I assume that the new “static let”s go into an extension)<br></p><p>I don’t think it’s possible for another module to add cases to an enum, so for those, we’d have to make them structs instead and use an extension. There’s an example of this for structs in the new proposal.<br></p><p>Thanks for the feedback! This proposal is now better than ever.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/4d56b2e9/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>January 29, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 22, 2016, at 1:14 PM, Jeff Kelley via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have updated the proposal &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt; to use struct over enum (https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md &lt;https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md&gt;).<br>&gt; <br>&gt;&gt; On Jan 20, 2016, at 11:01 PM, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; FWIW, I suggest that you put “String” somewhere in the title of your proposal when you revise it.<br>&gt; <br>&gt; Would this need to be limited to strings? There are other “magic constants” that could conceivably be imported as structs—I’m thinking, for instance, error codes.<br></p><p>Error codes are *usually* enums, but that’s a good point.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/911fb5d9/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Pitch: Import Objective-C Constants as Enums</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>January 29, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 one to the updated proposal. I like the change a lot, even if it&#39;s<br>even more pain for the poor framework teams. ;-)<br></p><p>Apropos of nothing, a coworker reminded me today of something that would<br>fit well into this proposal, even if only as a clarifying example: UTIs<br>are a great instance of &quot;strongly-typedef&#39;ed strings&quot;, with the<br>possibility of user-defined cases, and whose use in Cocoa APIs is often<br>ambiguous. There are several hundred constants, too, so it&#39;d be a good<br>stress-test for everything in the proposal.<br></p><p>Cheers! Zachary Waldowski zach at waldowski.me<br></p><p><br>On Fri, Jan 22, 2016, at 04:14 PM, Jeff Kelley via swift-evolution wrote:<br>&gt; I have updated the proposal[1] to use struct over enum<br>&gt; (https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md)<br>&gt; .<br>&gt;<br>&gt;&gt; On Jan 20, 2016, at 11:01 PM, Douglas Gregor<br>&gt;&gt; &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; FWIW, I suggest that you put “String” somewhere in the title of your<br>&gt;&gt; proposal when you revise it.<br>&gt;<br>&gt; Would this need to be limited to strings? There are other “magic<br>&gt; constants” that could conceivably be imported as structs—I’m thinking,<br>&gt; for instance, error codes.<br>&gt;<br>&gt;<br>&gt; Jeff Kelley<br>&gt;<br>&gt;<br>&gt; SlaunchaMan at gmail.com | @SlaunchaMan[2] | jeffkelley.org<br>&gt;<br>&gt;&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br></p><p>Links:<br></p><p>  1. https://github.com/SlaunchaMan/swift-evolution/blob/import-objc-constants/proposals/0000-import-objc-constants.md<br>  2. https://twitter.com/SlaunchaMan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/e026edc3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
