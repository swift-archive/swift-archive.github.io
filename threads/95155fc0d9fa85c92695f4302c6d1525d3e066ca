<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33aa6e9d29ee0fdf3083f8d29e997118?s=50"></div><header><strong>Proper Way to make Errors in Swift 3</strong> from <string>Ronak</string> &lt;ronak2121 at yahoo.com&gt;<p>September 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello all,<br></p><p>We are proceeding to update all of our Swift code to Swift 3 now and had a few questions about the proper way to implement Errors. We need these entities to be available in Objective-C and they are actively being used in Swift classes marked as @objc.<br></p><p>I read: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt; completely and came up with this implementation:<br></p><p><br>/// The enumeration of the possible error codes in the Foundation error domain<br>@objc public class FoundationError: NSObject, CustomNSError {<br></p><p>    /// The underlying error code<br>    private let code: FoundationError.Code<br></p><p>    /// The type of an error code.<br>    @objc public enum Code: Int {<br></p><p>        /// An ARCOperationCondition failed during evaluation<br>        case operationConditionFailed = 10000<br></p><p>        /// An ARCOperation failed during execution<br>        case operationExecutionFailed = 10001<br>    }<br></p><p>    /// The domain of the error.<br>    public static var errorDomain: String {<br>        return &quot;FoundationError&quot;<br>    }<br></p><p>    /// The error code within the given domain.<br>    public var errorCode: Int {<br>        return code.rawValue<br>    }<br></p><p>    /// The user-info dictionary.<br>    public let errorUserInfo: [String : Any]<br></p><p>    /// Initializes a new FoundationError with an empty userInfo dictionary<br>    ///<br>    /// - parameter code: one of the available error codes<br>    ///<br>    /// - returns: a new instance of FoundationError<br>    public convenience init(code: FoundationError.Code) {<br>        self.init(code: code, userInfo: [:])<br>    }<br></p><p>    /// Initializes a new FoundationError with an userInfo dictionary<br>    ///<br>    /// - parameter code: one of the available error codes<br>    /// - parameter userInfo: the user-info dictionary<br>    ///<br>    /// - returns: a new instance of FoundationError<br>    public init(code: FoundationError.Code, userInfo: [String : Any]) {<br>        self.code = code<br>        errorUserInfo = userInfo<br>    }<br></p><p>    /// Computes whether two FoundationErrors are equal<br>    ///<br>    /// - parameter object: a FoundationError<br>    ///<br>    /// - returns: true, if the two errors are equal<br>    public override func isEqual(_ object: Any?) -&gt; Bool {<br>        guard let object = object as? FoundationError else { return false }<br></p><p>        return errorCode == object.errorCode &amp;&amp; errorUserInfo.keys.elementsEqual(object.errorUserInfo.keys)<br>    }<br>}<br></p><p>My question is whether this is the correct way to do this now; or is there another solution we should be doing? We would like to follow Swift Best Practices here, but unfortunately, the documentation is quite vague on this subject.<br></p><p><br>Thanks for your help!<br></p><p>Ronak Patel<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160929/951566ca/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>Proper Way to make Errors in Swift 3</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>September 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Error types themselves shouldn’t generally cross into Objective-C, because you don’t get interop; for that, we have Error, which crosses the bridge as NSError.<br></p><p>If it’s instructive to think of it this way, both Objective-C and Swift should define errors in their best native way, and use NSError. That’s, at least, the use case for CustomNSError and LocalizedError.<br></p><p>If you’re primarily exporting errors from Objective-C to be “seen” in Swift, you want to look into the ns_error_domain attribute on the C side. This generates a good deal of the enum Code: Int boilerplate coming in to Swift, but it’s obnoxious to create those errors from Swift.<br></p><p>If you’re primarily exporting errors from Swift to Objective-C, you can make any Swift type implement Error and CustomNSError, which can then cross the bridge.<br></p><p>The happy path of full error interop in both directions is a little more complicated. Generally you have to start with one of the above approach and “mirror” some values in the other language. Consider the following as a slightly over-wrought example of having your cake and eating it too:<br></p><p>extern NSString *const MyErrorDomain NS_REFINED_FOR_SWIFT;<br>extern NSString *const MyErrorUserInfoStringKey NS_REFINED_FOR_SWIFT;<br></p><p>typedef NS_ENUM(NSInteger, MyErrorCode) {<br>    MyErrorCodeOne,<br>    MyErrorCodeTwo,<br>    MyErrorCodeThree,<br>} NS_REFINED_FOR_SWIFT;<br></p><p>enum MyError: CustomNSError {<br></p><p>    case one(String)<br>    case two<br>    case three<br></p><p>    static var errorDomain: String {<br>        return __MyErrorDomain<br>    }<br></p><p>    var errorCode: Int {<br>        switch self {<br>        case .one:<br>            return __MyErrorCode.one.rawValue<br>        case .two:<br>            return __MyErrorCode.two.rawValue<br>        case .three:<br>            return __MyErrorCode.three.rawValue<br>        }<br>    }<br></p><p>    var errorUserInfo: [String: Any] {<br>        var userInfo = [String: Any]()<br>        if case let .one(string) = self {<br>            userInfo[__MyErrorUserInfoStringKey] = string<br>        }<br>        return userInfo<br>    }<br>    <br>}<br></p><p>&gt; On Sep 29, 2016, at 1:17 PM, Ronak via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; We are proceeding to update all of our Swift code to Swift 3 now and had a few questions about the proper way to implement Errors. We need these entities to be available in Objective-C and they are actively being used in Swift classes marked as @objc.<br>&gt; <br>&gt; I read: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt; completely and came up with this implementation:<br>&gt; <br>&gt; <br>&gt; /// The enumeration of the possible error codes in the Foundation error domain<br>&gt; @objc public class FoundationError: NSObject, CustomNSError {<br>&gt; <br>&gt;     /// The underlying error code<br>&gt;     private let code: FoundationError.Code<br>&gt; <br>&gt;     /// The type of an error code.<br>&gt;     @objc public enum Code: Int {<br>&gt; <br>&gt;         /// An ARCOperationCondition failed during evaluation<br>&gt;         case operationConditionFailed = 10000<br>&gt; <br>&gt;         /// An ARCOperation failed during execution<br>&gt;         case operationExecutionFailed = 10001<br>&gt;     }<br>&gt; <br>&gt;     /// The domain of the error.<br>&gt;     public static var errorDomain: String {<br>&gt;         return &quot;FoundationError&quot;<br>&gt;     }<br>&gt; <br>&gt;     /// The error code within the given domain.<br>&gt;     public var errorCode: Int {<br>&gt;         return code.rawValue<br>&gt;     }<br>&gt; <br>&gt;     /// The user-info dictionary.<br>&gt;     public let errorUserInfo: [String : Any]<br>&gt; <br>&gt;     /// Initializes a new FoundationError with an empty userInfo dictionary<br>&gt;     ///<br>&gt;     /// - parameter code: one of the available error codes<br>&gt;     ///<br>&gt;     /// - returns: a new instance of FoundationError<br>&gt;     public convenience init(code: FoundationError.Code) {<br>&gt;         self.init(code: code, userInfo: [:])<br>&gt;     }<br>&gt; <br>&gt;     /// Initializes a new FoundationError with an userInfo dictionary<br>&gt;     ///<br>&gt;     /// - parameter code: one of the available error codes<br>&gt;     /// - parameter userInfo: the user-info dictionary<br>&gt;     ///<br>&gt;     /// - returns: a new instance of FoundationError<br>&gt;     public init(code: FoundationError.Code, userInfo: [String : Any]) {<br>&gt;         self.code = code<br>&gt;         errorUserInfo = userInfo<br>&gt;     }<br>&gt; <br>&gt;     /// Computes whether two FoundationErrors are equal<br>&gt;     ///<br>&gt;     /// - parameter object: a FoundationError<br>&gt;     ///<br>&gt;     /// - returns: true, if the two errors are equal<br>&gt;     public override func isEqual(_ object: Any?) -&gt; Bool {<br>&gt;         guard let object = object as? FoundationError else { return false }<br>&gt; <br>&gt;         return errorCode == object.errorCode &amp;&amp; errorUserInfo.keys.elementsEqual(object.errorUserInfo.keys)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; My question is whether this is the correct way to do this now; or is there another solution we should be doing? We would like to follow Swift Best Practices here, but unfortunately, the documentation is quite vague on this subject.<br>&gt; <br>&gt; <br>&gt; Thanks for your help!<br>&gt; <br>&gt; Ronak Patel<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160929/dda2557b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33aa6e9d29ee0fdf3083f8d29e997118?s=50"></div><header><strong>Proper Way to make Errors in Swift 3</strong> from <string>Ronak</string> &lt;ronak2121 at yahoo.com&gt;<p>September 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Ahh..thanks for the reply Zach. I didn’t actually see your reply until now.<br></p><p>I’ll see how I can adjust my code.<br></p><p>Thanks for this!<br></p><p><br>&gt; On Sep 29, 2016, at 4:38 PM, Zach Waldowski &lt;zach at waldowski.me&gt; wrote:<br>&gt; <br>&gt; Error types themselves shouldn’t generally cross into Objective-C, because you don’t get interop; for that, we have Error, which crosses the bridge as NSError.<br>&gt; <br>&gt; If it’s instructive to think of it this way, both Objective-C and Swift should define errors in their best native way, and use NSError. That’s, at least, the use case for CustomNSError and LocalizedError.<br>&gt; <br>&gt; If you’re primarily exporting errors from Objective-C to be “seen” in Swift, you want to look into the ns_error_domain attribute on the C side. This generates a good deal of the enum Code: Int boilerplate coming in to Swift, but it’s obnoxious to create those errors from Swift.<br>&gt; <br>&gt; If you’re primarily exporting errors from Swift to Objective-C, you can make any Swift type implement Error and CustomNSError, which can then cross the bridge.<br>&gt; <br>&gt; The happy path of full error interop in both directions is a little more complicated. Generally you have to start with one of the above approach and “mirror” some values in the other language. Consider the following as a slightly over-wrought example of having your cake and eating it too:<br>&gt; <br>&gt; extern NSString *const MyErrorDomain NS_REFINED_FOR_SWIFT;<br>&gt; extern NSString *const MyErrorUserInfoStringKey NS_REFINED_FOR_SWIFT;<br>&gt; <br>&gt; typedef NS_ENUM(NSInteger, MyErrorCode) {<br>&gt;     MyErrorCodeOne,<br>&gt;     MyErrorCodeTwo,<br>&gt;     MyErrorCodeThree,<br>&gt; } NS_REFINED_FOR_SWIFT;<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt; <br>&gt;     case one(String)<br>&gt;     case two<br>&gt;     case three<br>&gt; <br>&gt;     static var errorDomain: String {<br>&gt;         return __MyErrorDomain<br>&gt;     }<br>&gt; <br>&gt;     var errorCode: Int {<br>&gt;         switch self {<br>&gt;         case .one:<br>&gt;             return __MyErrorCode.one.rawValue<br>&gt;         case .two:<br>&gt;             return __MyErrorCode.two.rawValue<br>&gt;         case .three:<br>&gt;             return __MyErrorCode.three.rawValue<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     var errorUserInfo: [String: Any] {<br>&gt;         var userInfo = [String: Any]()<br>&gt;         if case let .one(string) = self {<br>&gt;             userInfo[__MyErrorUserInfoStringKey] = string<br>&gt;         }<br>&gt;         return userInfo<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt;&gt; On Sep 29, 2016, at 1:17 PM, Ronak via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello all,<br>&gt;&gt; <br>&gt;&gt; We are proceeding to update all of our Swift code to Swift 3 now and had a few questions about the proper way to implement Errors. We need these entities to be available in Objective-C and they are actively being used in Swift classes marked as @objc.<br>&gt;&gt; <br>&gt;&gt; I read: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt; completely and came up with this implementation:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; /// The enumeration of the possible error codes in the Foundation error domain<br>&gt;&gt; @objc public class FoundationError: NSObject, CustomNSError {<br>&gt;&gt; <br>&gt;&gt;     /// The underlying error code<br>&gt;&gt;     private let code: FoundationError.Code<br>&gt;&gt; <br>&gt;&gt;     /// The type of an error code.<br>&gt;&gt;     @objc public enum Code: Int {<br>&gt;&gt; <br>&gt;&gt;         /// An ARCOperationCondition failed during evaluation<br>&gt;&gt;         case operationConditionFailed = 10000<br>&gt;&gt; <br>&gt;&gt;         /// An ARCOperation failed during execution<br>&gt;&gt;         case operationExecutionFailed = 10001<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /// The domain of the error.<br>&gt;&gt;     public static var errorDomain: String {<br>&gt;&gt;         return &quot;FoundationError&quot;<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /// The error code within the given domain.<br>&gt;&gt;     public var errorCode: Int {<br>&gt;&gt;         return code.rawValue<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /// The user-info dictionary.<br>&gt;&gt;     public let errorUserInfo: [String : Any]<br>&gt;&gt; <br>&gt;&gt;     /// Initializes a new FoundationError with an empty userInfo dictionary<br>&gt;&gt;     ///<br>&gt;&gt;     /// - parameter code: one of the available error codes<br>&gt;&gt;     ///<br>&gt;&gt;     /// - returns: a new instance of FoundationError<br>&gt;&gt;     public convenience init(code: FoundationError.Code) {<br>&gt;&gt;         self.init(code: code, userInfo: [:])<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /// Initializes a new FoundationError with an userInfo dictionary<br>&gt;&gt;     ///<br>&gt;&gt;     /// - parameter code: one of the available error codes<br>&gt;&gt;     /// - parameter userInfo: the user-info dictionary<br>&gt;&gt;     ///<br>&gt;&gt;     /// - returns: a new instance of FoundationError<br>&gt;&gt;     public init(code: FoundationError.Code, userInfo: [String : Any]) {<br>&gt;&gt;         self.code = code<br>&gt;&gt;         errorUserInfo = userInfo<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /// Computes whether two FoundationErrors are equal<br>&gt;&gt;     ///<br>&gt;&gt;     /// - parameter object: a FoundationError<br>&gt;&gt;     ///<br>&gt;&gt;     /// - returns: true, if the two errors are equal<br>&gt;&gt;     public override func isEqual(_ object: Any?) -&gt; Bool {<br>&gt;&gt;         guard let object = object as? FoundationError else { return false }<br>&gt;&gt; <br>&gt;&gt;         return errorCode == object.errorCode &amp;&amp; errorUserInfo.keys.elementsEqual(object.errorUserInfo.keys)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; My question is whether this is the correct way to do this now; or is there another solution we should be doing? We would like to follow Swift Best Practices here, but unfortunately, the documentation is quite vague on this subject.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks for your help!<br>&gt;&gt; <br>&gt;&gt; Ronak Patel<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160929/ea837bf4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33aa6e9d29ee0fdf3083f8d29e997118?s=50"></div><header><strong>Proper Way to make Errors in Swift 3</strong> from <string>Ronak</string> &lt;ronak2121 at yahoo.com&gt;<p>September 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I’ve actually switched our implementation to:<br></p><p>/// The type of an error code.<br>@objc public enum FoundationErrorCode: Int {<br></p><p>    /// An ARCOperationCondition failed during evaluation<br>    case operationConditionFailed = 10000<br></p><p>    /// An ARCOperation failed during execution<br>    case operationExecutionFailed = 10001<br></p><p>    /// An unsupported HTTP Method was encountered<br>    case unsupportedHTTPMethod = 10002<br>}<br></p><p>/// The enumeration of the possible error codes in the Foundation error domain<br>@objc public class FoundationError: NSObject, CustomNSError {<br></p><p>    /// The underlying error code<br>    private let code: FoundationErrorCode<br></p><p>    /// The domain of the error.<br>    public static var errorDomain: String {<br>        return &quot;FoundationError&quot;<br>    }<br></p><p>    /// The error code within the given domain.<br>    public var errorCode: Int {<br>        return code.rawValue<br>    }<br></p><p>    /// The user-info dictionary.<br>    public let errorUserInfo: [String : Any]<br></p><p>    /// Initializes a new FoundationError with an empty userInfo dictionary<br>    ///<br>    /// - parameter code: one of the available error codes<br>    ///<br>    /// - returns: a new instance of FoundationError<br>    public convenience init(code: FoundationErrorCode) {<br>        self.init(code: code, userInfo: [:])<br>    }<br></p><p>    /// Initializes a new FoundationError with an userInfo dictionary<br>    ///<br>    /// - parameter code: one of the available error codes<br>    /// - parameter userInfo: the user-info dictionary<br>    ///<br>    /// - returns: a new instance of FoundationError<br>    public init(code: FoundationErrorCode, userInfo: [String : Any]) {<br>        self.code = code<br>        errorUserInfo = userInfo<br>    }<br></p><p>    /// Computes whether two FoundationErrors are equal<br>    ///<br>    /// - parameter object: a FoundationError<br>    ///<br>    /// - returns: true, if the two errors are equal<br>    public override func isEqual(_ object: Any?) -&gt; Bool {<br>        guard let object = object as? FoundationError else { return false }<br></p><p>        return errorCode == object.errorCode &amp;&amp; errorUserInfo.keys.elementsEqual(object.errorUserInfo.keys)<br>    }<br>}<br></p><p>I hope this is closer to the correct way to implement this.<br></p><p>Thanks!<br></p><p>Ronak<br></p><p><br>&gt; On Sep 29, 2016, at 1:17 PM, Ronak via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello all,<br>&gt; <br>&gt; We are proceeding to update all of our Swift code to Swift 3 now and had a few questions about the proper way to implement Errors. We need these entities to be available in Objective-C and they are actively being used in Swift classes marked as @objc.<br>&gt; <br>&gt; I read: https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0112-nserror-bridging.md&gt; completely and came up with this implementation:<br>&gt; <br>&gt; <br>&gt; /// The enumeration of the possible error codes in the Foundation error domain<br>&gt; @objc public class FoundationError: NSObject, CustomNSError {<br>&gt; <br>&gt;     /// The underlying error code<br>&gt;     private let code: FoundationError.Code<br>&gt; <br>&gt;     /// The type of an error code.<br>&gt;     @objc public enum Code: Int {<br>&gt; <br>&gt;         /// An ARCOperationCondition failed during evaluation<br>&gt;         case operationConditionFailed = 10000<br>&gt; <br>&gt;         /// An ARCOperation failed during execution<br>&gt;         case operationExecutionFailed = 10001<br>&gt;     }<br>&gt; <br>&gt;     /// The domain of the error.<br>&gt;     public static var errorDomain: String {<br>&gt;         return &quot;FoundationError&quot;<br>&gt;     }<br>&gt; <br>&gt;     /// The error code within the given domain.<br>&gt;     public var errorCode: Int {<br>&gt;         return code.rawValue<br>&gt;     }<br>&gt; <br>&gt;     /// The user-info dictionary.<br>&gt;     public let errorUserInfo: [String : Any]<br>&gt; <br>&gt;     /// Initializes a new FoundationError with an empty userInfo dictionary<br>&gt;     ///<br>&gt;     /// - parameter code: one of the available error codes<br>&gt;     ///<br>&gt;     /// - returns: a new instance of FoundationError<br>&gt;     public convenience init(code: FoundationError.Code) {<br>&gt;         self.init(code: code, userInfo: [:])<br>&gt;     }<br>&gt; <br>&gt;     /// Initializes a new FoundationError with an userInfo dictionary<br>&gt;     ///<br>&gt;     /// - parameter code: one of the available error codes<br>&gt;     /// - parameter userInfo: the user-info dictionary<br>&gt;     ///<br>&gt;     /// - returns: a new instance of FoundationError<br>&gt;     public init(code: FoundationError.Code, userInfo: [String : Any]) {<br>&gt;         self.code = code<br>&gt;         errorUserInfo = userInfo<br>&gt;     }<br>&gt; <br>&gt;     /// Computes whether two FoundationErrors are equal<br>&gt;     ///<br>&gt;     /// - parameter object: a FoundationError<br>&gt;     ///<br>&gt;     /// - returns: true, if the two errors are equal<br>&gt;     public override func isEqual(_ object: Any?) -&gt; Bool {<br>&gt;         guard let object = object as? FoundationError else { return false }<br>&gt; <br>&gt;         return errorCode == object.errorCode &amp;&amp; errorUserInfo.keys.elementsEqual(object.errorUserInfo.keys)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; My question is whether this is the correct way to do this now; or is there another solution we should be doing? We would like to follow Swift Best Practices here, but unfortunately, the documentation is quite vague on this subject.<br>&gt; <br>&gt; <br>&gt; Thanks for your help!<br>&gt; <br>&gt; Ronak Patel<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160929/d49e015a/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
