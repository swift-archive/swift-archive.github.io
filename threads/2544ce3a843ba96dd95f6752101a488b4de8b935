<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>April 24, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;<br>&gt; I&#39;m still not sure why these are methods instead of operators.<br></p><p>I think this is an *excellent* choice, and I hope it is the first step to completely removing operators from protocols.<br></p><p>IMHO throwing operators into protocols is inconsistent and confusing. Having regular methods and a single generic version of the operator that calls down on the type’s methods is clearer and guarantees that generic code can avoid ambiguities by calling the methods directly, instead of having to rely only on heavily overloaded global operators.<br></p><p>—<br>Nicola<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 26, 2016 at 02:00:00pm</p></header><div class="content"><p>On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt; &gt;<br>&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;<br>&gt; I think this is an *excellent* choice, and I hope it is the first step to<br>&gt; completely removing operators from protocols.<br>&gt;<br>&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt; Having regular methods and a single generic version of the operator that<br>&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt; having to rely only on heavily overloaded global operators.<br>&gt;<br></p><p>I personally disagree on this point. To me, a protocol describes a set of<br>requirements for a type to fulfill, which includes things other than<br>methods. Just as a protocol can define initializers, properties, and<br>associated types that a type must define in order to conform, it makes<br>sense that a protocol would also define which operators a conforming type<br>must support.<br></p><p>Introducing a mapping between names and operators poses a few problems:<br></p><p>– IMO, they are overly verbose and add noise to the definition. This makes<br>the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>– They expose two ways to accomplish the same thing (writing `x.isEqual(to:<br>y)` and `x == y`).<br>– Do certain operators automatically get mapped to method names with<br>appropriate signatures across all types, or does a conforming type still<br>have to provide that mapping by implementing the operators separately? If<br>it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>protocol. If it&#39;s the former, does it make sense to automatically push<br>these operators for all types? Should any type that has an `add` method<br>automatically get `+` as a synonym as well? That may not be desirable.<br></p><p>I&#39;m very supportive of the floating-point protocol proposal in general, but<br>I feel the arithmetic and comparison operations should be exposed by<br>operators alone and not by methods, where there is a suitable operator that<br>has the intended meaning.<br></p><p><br></p><p>&gt;<br>&gt; —<br>&gt; Nicola<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/fd2cd3f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 26, 2016 at 10:00:00am</p></header><div class="content"><p>I’m with Nicola on this one. Operators are currently odd in that they have to be declared globally. Everything else about protocol conformance is kept within the conforming type.<br></p><p>- Dave Sweeris<br></p><p><br>&gt; On Apr 26, 2016, at 9:28 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt; &gt;<br>&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt; <br>&gt; I think this is an *excellent* choice, and I hope it is the first step to completely removing operators from protocols.<br>&gt; <br>&gt; IMHO throwing operators into protocols is inconsistent and confusing. Having regular methods and a single generic version of the operator that calls down on the type’s methods is clearer and guarantees that generic code can avoid ambiguities by calling the methods directly, instead of having to rely only on heavily overloaded global operators.<br>&gt; <br>&gt; I personally disagree on this point. To me, a protocol describes a set of requirements for a type to fulfill, which includes things other than methods. Just as a protocol can define initializers, properties, and associated types that a type must define in order to conform, it makes sense that a protocol would also define which operators a conforming type must support.<br>&gt; <br>&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt; <br>&gt; – IMO, they are overly verbose and add noise to the definition. This makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt; – They expose two ways to accomplish the same thing (writing `x.isEqual(to: y)` and `x == y`).<br>&gt; – Do certain operators automatically get mapped to method names with appropriate signatures across all types, or does a conforming type still have to provide that mapping by implementing the operators separately? If it&#39;s the latter, that&#39;s extra work for the author of the type writing the protocol. If it&#39;s the former, does it make sense to automatically push these operators for all types? Should any type that has an `add` method automatically get `+` as a synonym as well? That may not be desirable.<br>&gt; <br>&gt; I&#39;m very supportive of the floating-point protocol proposal in general, but I feel the arithmetic and comparison operations should be exposed by operators alone and not by methods, where there is a suitable operator that has the intended meaning.<br>&gt; <br>&gt;  <br>&gt; <br>&gt; —<br>&gt; Nicola<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/9ae39a0f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>That seems like a purely syntactic concern that could potentially be<br>addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all<br>operators using verbosely-named methods&quot; is the best one for the reasons I<br>mentioned above, and the question of &quot;how do we cleanly unify operators<br>with other protocol requirements?&quot; seems out-of-scope and orthogonal to<br>this proposal.<br></p><p>Given that we already have existing cases in the language where operators<br>are declared within protocols (`Equatable` being the first one that comes<br>to mind), I would recommend that this proposal follow that pattern for<br>consistency and then the community continue a separate discussion about<br>operators in protocols, which may or may not lead to changes across the<br>entire language and standard library. The protocol operators discussion<br>feels like a much larger topic that deserves to be discussed in its own<br>right without bogging down the rest of this proposal.<br></p><p><br>On Tue, Apr 26, 2016 at 8:18 AM David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; I’m with Nicola on this one. Operators are currently odd in that they have<br>&gt; to be declared globally. Everything else about protocol conformance is kept<br>&gt; within the conforming type.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt;<br>&gt; On Apr 26, 2016, at 9:28 AM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;<br>&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step to<br>&gt;&gt; completely removing operators from protocols.<br>&gt;&gt;<br>&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;<br>&gt;<br>&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt; requirements for a type to fulfill, which includes things other than<br>&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt; associated types that a type must define in order to conform, it makes<br>&gt; sense that a protocol would also define which operators a conforming type<br>&gt; must support.<br>&gt;<br>&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;<br>&gt; – IMO, they are overly verbose and add noise to the definition. This makes<br>&gt; the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt; – They expose two ways to accomplish the same thing (writing<br>&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt; – Do certain operators automatically get mapped to method names with<br>&gt; appropriate signatures across all types, or does a conforming type still<br>&gt; have to provide that mapping by implementing the operators separately? If<br>&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt; these operators for all types? Should any type that has an `add` method<br>&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;<br>&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt; has the intended meaning.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; —<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/fbd81e31/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 26, 2016 at 03:00:00pm</p></header><div class="content"><p>+1 to Tony&#39;s write-up.<br></p><p>On Tue, Apr 26, 2016 at 10:47 Tony Allevato via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; That seems like a purely syntactic concern that could potentially be<br>&gt; addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all<br>&gt; operators using verbosely-named methods&quot; is the best one for the reasons I<br>&gt; mentioned above, and the question of &quot;how do we cleanly unify operators<br>&gt; with other protocol requirements?&quot; seems out-of-scope and orthogonal to<br>&gt; this proposal.<br>&gt;<br>&gt; Given that we already have existing cases in the language where operators<br>&gt; are declared within protocols (`Equatable` being the first one that comes<br>&gt; to mind), I would recommend that this proposal follow that pattern for<br>&gt; consistency and then the community continue a separate discussion about<br>&gt; operators in protocols, which may or may not lead to changes across the<br>&gt; entire language and standard library. The protocol operators discussion<br>&gt; feels like a much larger topic that deserves to be discussed in its own<br>&gt; right without bogging down the rest of this proposal.<br>&gt;<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 8:18 AM David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;&gt; I’m with Nicola on this one. Operators are currently odd in that they<br>&gt;&gt; have to be declared globally. Everything else about protocol conformance is<br>&gt;&gt; kept within the conforming type.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 26, 2016, at 9:28 AM, Tony Allevato via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt;&gt; requirements for a type to fulfill, which includes things other than<br>&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt; must support.<br>&gt;&gt;<br>&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;<br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;<br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt; has the intended meaning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/21f0bc9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 from me as well to Tony&#39;s write-up.<br></p><p>-Thorsten <br></p><p>&gt; Am 26.04.2016 um 17:54 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; +1 to Tony&#39;s write-up.<br>&gt; <br>&gt;&gt; On Tue, Apr 26, 2016 at 10:47 Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; That seems like a purely syntactic concern that could potentially be addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all operators using verbosely-named methods&quot; is the best one for the reasons I mentioned above, and the question of &quot;how do we cleanly unify operators with other protocol requirements?&quot; seems out-of-scope and orthogonal to this proposal.<br>&gt;&gt; <br>&gt;&gt; Given that we already have existing cases in the language where operators are declared within protocols (`Equatable` being the first one that comes to mind), I would recommend that this proposal follow that pattern for consistency and then the community continue a separate discussion about operators in protocols, which may or may not lead to changes across the entire language and standard library. The protocol operators discussion feels like a much larger topic that deserves to be discussed in its own right without bogging down the rest of this proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Apr 26, 2016 at 8:18 AM David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt;&gt; I’m with Nicola on this one. Operators are currently odd in that they have to be declared globally. Everything else about protocol conformance is kept within the conforming type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 26, 2016, at 9:28 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step to completely removing operators from protocols.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing. Having regular methods and a single generic version of the operator that calls down on the type’s methods is clearer and guarantees that generic code can avoid ambiguities by calling the methods directly, instead of having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of requirements for a type to fulfill, which includes things other than methods. Just as a protocol can define initializers, properties, and associated types that a type must define in order to conform, it makes sense that a protocol would also define which operators a conforming type must support.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt;&gt;&gt; – They expose two ways to accomplish the same thing (writing `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt;&gt;&gt; – Do certain operators automatically get mapped to method names with appropriate signatures across all types, or does a conforming type still have to provide that mapping by implementing the operators separately? If it&#39;s the latter, that&#39;s extra work for the author of the type writing the protocol. If it&#39;s the former, does it make sense to automatically push these operators for all types? Should any type that has an `add` method automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general, but I feel the arithmetic and comparison operations should be exposed by operators alone and not by methods, where there is a suitable operator that has the intended meaning.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; —<br>&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/41a780a7/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 26, 2016 at 09:00:00am</p></header><div class="content"><p>I tend to agree. I’d like the inconsistency concerning operators and dispatch to be resolved by investigating making operators into members, not by forcing operators to be second-class citizens. (Obviously this deserves its own proposal and its own discussion.)<br></p><p>Jordan<br></p><p><br>&gt; On Apr 26, 2016, at 08:47, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That seems like a purely syntactic concern that could potentially be addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all operators using verbosely-named methods&quot; is the best one for the reasons I mentioned above, and the question of &quot;how do we cleanly unify operators with other protocol requirements?&quot; seems out-of-scope and orthogonal to this proposal.<br>&gt; <br>&gt; Given that we already have existing cases in the language where operators are declared within protocols (`Equatable` being the first one that comes to mind), I would recommend that this proposal follow that pattern for consistency and then the community continue a separate discussion about operators in protocols, which may or may not lead to changes across the entire language and standard library. The protocol operators discussion feels like a much larger topic that deserves to be discussed in its own right without bogging down the rest of this proposal.<br>&gt; <br>&gt; <br>&gt; On Tue, Apr 26, 2016 at 8:18 AM David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; I’m with Nicola on this one. Operators are currently odd in that they have to be declared globally. Everything else about protocol conformance is kept within the conforming type.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 26, 2016, at 9:28 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt; <br>&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step to completely removing operators from protocols.<br>&gt;&gt; <br>&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing. Having regular methods and a single generic version of the operator that calls down on the type’s methods is clearer and guarantees that generic code can avoid ambiguities by calling the methods directly, instead of having to rely only on heavily overloaded global operators.<br>&gt;&gt; <br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of requirements for a type to fulfill, which includes things other than methods. Just as a protocol can define initializers, properties, and associated types that a type must define in order to conform, it makes sense that a protocol would also define which operators a conforming type must support.<br>&gt;&gt; <br>&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt; <br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt; – Do certain operators automatically get mapped to method names with appropriate signatures across all types, or does a conforming type still have to provide that mapping by implementing the operators separately? If it&#39;s the latter, that&#39;s extra work for the author of the type writing the protocol. If it&#39;s the former, does it make sense to automatically push these operators for all types? Should any type that has an `add` method automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt; <br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general, but I feel the arithmetic and comparison operations should be exposed by operators alone and not by methods, where there is a suitable operator that has the intended meaning.<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; —<br>&gt;&gt; Nicola<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/d8158ae8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 9:19 AM, Jordan Rose via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I tend to agree. I’d like the inconsistency concerning operators and dispatch to be resolved by investigating making operators into members, not by forcing operators to be second-class citizens. (Obviously this deserves its own proposal and its own discussion.)<br></p><p>Though that has been the plan for a long time, I wonder if the opposite approach is better: make operators always be global, and never be allowed as protocol members. That would give us a very consistent design.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 5:47 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br></p><p>&gt; That seems like a purely syntactic concern that could potentially be<br>&gt; addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all<br>&gt; operators using verbosely-named methods&quot; is the best one for the reasons I<br>&gt; mentioned above, and the question of &quot;how do we cleanly unify operators<br>&gt; with other protocol requirements?&quot; seems out-of-scope and orthogonal to<br>&gt; this proposal.<br>&gt;<br>&gt; Given that we already have existing cases in the language where operators<br>&gt; are declared within protocols (`Equatable` being the first one that comes<br>&gt; to mind), I would recommend that this proposal follow that pattern for<br>&gt; consistency and then the community continue a separate discussion about<br>&gt; operators in protocols, which may or may not lead to changes across the<br>&gt; entire language and standard library. The protocol operators discussion<br>&gt; feels like a much larger topic that deserves to be discussed in its own<br>&gt; right without bogging down the rest of this proposal.<br>&gt;<br></p><p>Agreed; clearly changes to Equatable are orthogonal to this proposal and<br>would need to be discussed separately.<br></p><p>However, I support the specific implementation used by the FloatingPoint<br>protocol which is being discussed, and I prefer it to the &quot;old-style&quot;<br>alternative.<br></p><p>I suspect that the design came up as a necessity to work around compiler<br>inefficiencies, though I still hope that a more widespread change will be<br>forthcoming :-)<br></p><p>Nicola<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 8:18 AM David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;&gt; I’m with Nicola on this one. Operators are currently odd in that they<br>&gt;&gt; have to be declared globally. Everything else about protocol conformance is<br>&gt;&gt; kept within the conforming type.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Apr 26, 2016, at 9:28 AM, Tony Allevato via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt;&gt; requirements for a type to fulfill, which includes things other than<br>&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt; must support.<br>&gt;&gt;<br>&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;<br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;<br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt; has the intended meaning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/db93819b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 26, 2016 at 11:00:00am</p></header><div class="content"><p>On Apr 26, 2016, at 8:47 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; That seems like a purely syntactic concern that could potentially be addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all operators using verbosely-named methods&quot; is the best one for the reasons I mentioned above, and the question of &quot;how do we cleanly unify operators with other protocol requirements?&quot; seems out-of-scope and orthogonal to this proposal.<br></p><p>There is a strong motivation for this approach though: we want the type checker to be scalable.  John recently wrote an epic piece about why having tons of overloads is a really bad idea:<br>https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html<br></p><p>It is *much* better for type checker performance to have (e.g.):<br></p><p>func +&lt;T : FloatingPoint&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>func +&lt;T : Integer&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br></p><p>Rather than overloads for 4 floating point types, and 8+ integer types.   We really need to eliminate all the “expression too complex” classes of issues, and this is an important cause of them.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 11:42 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 26, 2016, at 8:47 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; That seems like a purely syntactic concern that could potentially be addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all operators using verbosely-named methods&quot; is the best one for the reasons I mentioned above, and the question of &quot;how do we cleanly unify operators with other protocol requirements?&quot; seems out-of-scope and orthogonal to this proposal.<br>&gt; <br>&gt; There is a strong motivation for this approach though: we want the type checker to be scalable.  John recently wrote an epic piece about why having tons of overloads is a really bad idea:<br>&gt; https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html<br>&gt; <br>&gt; It is *much* better for type checker performance to have (e.g.):<br>&gt; <br>&gt; func +&lt;T : FloatingPoint&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; func +&lt;T : Integer&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; <br>&gt; Rather than overloads for 4 floating point types, and 8+ integer types.   We really need to eliminate all the “expression too complex” classes of issues, and this is an important cause of them.<br></p><p>Also, sorry for not being explicit about this.  I’m not a type checker expert, but I believe that using operator requirements imposes the same load on the type checker as having large overload sets.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>You&#39;ll have to forgive my ignorance on the matter because I&#39;m also not a<br>type checker expert. If compile-time performance concerns are the<br>motivating factor, is it possible to address them in a different way that<br>would not require trampoline code or public interface bloat, like hoisting<br>operators into static protocol methods? Presumably then `lhs + rhs` for two<br>T&#39;s conforming to FloatingPoint would map directly to `T.+(_ lhs: T, _ rhs:<br>T)` and the concrete global overloads could still be omitted?<br></p><p><br>On Tue, Apr 26, 2016 at 11:44 AM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 26, 2016, at 11:42 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Apr 26, 2016, at 8:47 AM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; That seems like a purely syntactic concern that could potentially be<br>&gt; addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all<br>&gt; operators using verbosely-named methods&quot; is the best one for the reasons I<br>&gt; mentioned above, and the question of &quot;how do we cleanly unify operators<br>&gt; with other protocol requirements?&quot; seems out-of-scope and orthogonal to<br>&gt; this proposal.<br>&gt; &gt;<br>&gt; &gt; There is a strong motivation for this approach though: we want the type<br>&gt; checker to be scalable.  John recently wrote an epic piece about why having<br>&gt; tons of overloads is a really bad idea:<br>&gt; &gt;<br>&gt; https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html<br>&gt; &gt;<br>&gt; &gt; It is *much* better for type checker performance to have (e.g.):<br>&gt; &gt;<br>&gt; &gt; func +&lt;T : FloatingPoint&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; &gt; func +&lt;T : Integer&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; &gt;<br>&gt; &gt; Rather than overloads for 4 floating point types, and 8+ integer types.<br>&gt;  We really need to eliminate all the “expression too complex” classes of<br>&gt; issues, and this is an important cause of them.<br>&gt;<br>&gt; Also, sorry for not being explicit about this.  I’m not a type checker<br>&gt; expert, but I believe that using operator requirements imposes the same<br>&gt; load on the type checker as having large overload sets.<br>&gt;<br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/494cc20d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>If this design is a workaround for type checker limitations, then perhaps<br>comparison method names are better prefixed with an underscore and/or using<br>abbreviated terms-of-art (eq, lt, lte, etc.)? As Tony points out, it seems<br>tragic to promote to an equal footing with `2.0 + 2.0 == 4.0` the<br>alternative form `(2.0).adding(2.0).isEqual(to: 4.0)`.<br></p><p>On Tue, Apr 26, 2016 at 13:44 Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Apr 26, 2016, at 11:42 AM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Apr 26, 2016, at 8:47 AM, Tony Allevato via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; That seems like a purely syntactic concern that could potentially be<br>&gt; addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all<br>&gt; operators using verbosely-named methods&quot; is the best one for the reasons I<br>&gt; mentioned above, and the question of &quot;how do we cleanly unify operators<br>&gt; with other protocol requirements?&quot; seems out-of-scope and orthogonal to<br>&gt; this proposal.<br>&gt; &gt;<br>&gt; &gt; There is a strong motivation for this approach though: we want the type<br>&gt; checker to be scalable.  John recently wrote an epic piece about why having<br>&gt; tons of overloads is a really bad idea:<br>&gt; &gt;<br>&gt; https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html<br>&gt; &gt;<br>&gt; &gt; It is *much* better for type checker performance to have (e.g.):<br>&gt; &gt;<br>&gt; &gt; func +&lt;T : FloatingPoint&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; &gt; func +&lt;T : Integer&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; &gt;<br>&gt; &gt; Rather than overloads for 4 floating point types, and 8+ integer types.<br>&gt;  We really need to eliminate all the “expression too complex” classes of<br>&gt; issues, and this is an important cause of them.<br>&gt;<br>&gt; Also, sorry for not being explicit about this.  I’m not a type checker<br>&gt; expert, but I believe that using operator requirements imposes the same<br>&gt; load on the type checker as having large overload sets.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/c2f7eb09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 26, 2016 at 01:00:00pm</p></header><div class="content"><p>On Apr 26, 2016, at 12:28 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; If this design is a workaround for type checker limitations, then perhaps comparison method names are better prefixed with an underscore and/or using abbreviated terms-of-art (eq, lt, lte, etc.)? As Tony points out, it seems tragic to promote to an equal footing with `2.0 + 2.0 == 4.0` the alternative form `(2.0).adding(2.0).isEqual(to: 4.0)`.<br></p><p>I’d be open to considering that, but I’m definitely not an “API naming” guru.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>April 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 26, 2016, at 11:42, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Apr 26, 2016, at 8:47 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; That seems like a purely syntactic concern that could potentially be addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all operators using verbosely-named methods&quot; is the best one for the reasons I mentioned above, and the question of &quot;how do we cleanly unify operators with other protocol requirements?&quot; seems out-of-scope and orthogonal to this proposal.<br>&gt; <br>&gt; There is a strong motivation for this approach though: we want the type checker to be scalable.  John recently wrote an epic piece about why having tons of overloads is a really bad idea:<br>&gt; https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html<br>&gt; <br>&gt; It is *much* better for type checker performance to have (e.g.):<br>&gt; <br>&gt; func +&lt;T : FloatingPoint&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; func +&lt;T : Integer&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt; <br>&gt; Rather than overloads for 4 floating point types, and 8+ integer types.   We really need to eliminate all the “expression too complex” classes of issues, and this is an important cause of them.<br></p><p>That’s a reason to pull operators in as members, not push them out as second-class free functions.<br></p><p>Jordan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 27, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Apr 27, 2016, at 9:10 AM, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 26, 2016, at 11:42, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 26, 2016, at 8:47 AM, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; That seems like a purely syntactic concern that could potentially be addressed in other ways, though. I&#39;m not sure the choice of &quot;duplicate all operators using verbosely-named methods&quot; is the best one for the reasons I mentioned above, and the question of &quot;how do we cleanly unify operators with other protocol requirements?&quot; seems out-of-scope and orthogonal to this proposal.<br>&gt;&gt; <br>&gt;&gt; There is a strong motivation for this approach though: we want the type checker to be scalable.  John recently wrote an epic piece about why having tons of overloads is a really bad idea:<br>&gt;&gt; https://lists.swift.org/pipermail/swift-dev/Week-of-Mon-20160404/001650.html<br>&gt;&gt; <br>&gt;&gt; It is *much* better for type checker performance to have (e.g.):<br>&gt;&gt; <br>&gt;&gt; func +&lt;T : FloatingPoint&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt;&gt; func +&lt;T : Integer&gt;(lhs : T, rhs : T) -&gt; T { return lhs.add(rhs) }<br>&gt;&gt; <br>&gt;&gt; Rather than overloads for 4 floating point types, and 8+ integer types.   We really need to eliminate all the “expression too complex” classes of issues, and this is an important cause of them.<br>&gt; <br>&gt; That’s a reason to pull operators in as members, not push them out as second-class free functions.<br></p><p>There are a ton of open questions that would have to be resolved, but I agree that in theory that could resolve the issue as well.  <br></p><p>The practical problem is that those issues won’t get resolved in the Swift 3 cycle, and yet we still want improved numeric protocols, compile time, and decent overload failure diagnostics.<br></p><p>-Chris<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>April 26, 2016 at 07:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br></p><p>&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;<br>&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step to<br>&gt;&gt; completely removing operators from protocols.<br>&gt;&gt;<br>&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;<br>&gt;<br>&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt; requirements for a type to fulfill, which includes things other than<br>&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt; associated types that a type must define in order to conform, it makes<br>&gt; sense that a protocol would also define which operators a conforming type<br>&gt; must support.<br>&gt;<br></p><p>Well, I&#39;m not sure about that. A protocol describes what a type can do, so<br>it&#39;s debatable whether a global function is within this scope.<br></p><p>Operators are magically special: you can declare them inside a protocol and<br>require them to be available for conformance, even if they don&#39;t belong to<br>the type. You can&#39;t do the same thing for normal global functions, yet<br>conceptually global functions and operators are the same thing.<br></p><p><br>&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;<br>&gt; – IMO, they are overly verbose and add noise to the definition. This makes<br>&gt; the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt; – They expose two ways to accomplish the same thing (writing<br>&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt; – Do certain operators automatically get mapped to method names with<br>&gt; appropriate signatures across all types, or does a conforming type still<br>&gt; have to provide that mapping by implementing the operators separately? If<br>&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt; these operators for all types? Should any type that has an `add` method<br>&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;<br></p><p>The difference at the protocol declaration is between:<br></p><p>protocol Equatable {<br>    func ==(lhs: Self, rhs: Self) -&gt; Bool<br>}<br></p><p>and:<br></p><p>protocol Equatable {<br>    func isEqual(to other: Self) -&gt; Bool<br>}<br></p><p>func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>    return lhs.isEqual(to: rhs)<br>}<br></p><p>so the latter is a bit more verbose, but arguably clearer in intent, and<br>not different from how you would define any generic global function using a<br>protocol, or from how you can define protocol extensions with default<br>implementations that take advantage of the protocol&#39;s core methods.<br></p><p>The difference for the conformance is between:<br></p><p>extension Foo : Equatable { }<br></p><p>func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>    return &lt;comparison&gt;<br>}<br></p><p>and:<br></p><p>extension Bar : Equatable {<br>    func isEqual(to: Bar) -&gt; Bool {<br>        return &lt;comparison&gt;<br>    }<br>}<br></p><p>the former way to define the conformance can be confusing to newbies. The<br>latter is straightforward and consistent with the usual way to adopt a<br>protocol.<br></p><p>The == operator looks exactly the same at its use points, but the way how<br>it&#39;s implemented is different.<br>In the former case, it&#39;s many overloads of a global function, which can<br>stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to<br>disambiguate in case of ambiguities.<br>In the latter case, there is only one generic definition of ==, which<br>automatically applies to all types that conform to the protocol.<br></p><p>Nicola<br></p><p><br>&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt; has the intended meaning.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt; —<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/34fc1b0d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 26, 2016 at 08:00:00pm</p></header><div class="content"><p>See inline.<br></p><p>&gt; Am 26.04.2016 um 19:36 schrieb Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt; wrote:<br>&gt;&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step to completely removing operators from protocols.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing. Having regular methods and a single generic version of the operator that calls down on the type’s methods is clearer and guarantees that generic code can avoid ambiguities by calling the methods directly, instead of having to rely only on heavily overloaded global operators.<br>&gt;&gt; <br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of requirements for a type to fulfill, which includes things other than methods. Just as a protocol can define initializers, properties, and associated types that a type must define in order to conform, it makes sense that a protocol would also define which operators a conforming type must support.<br>&gt; <br>&gt; Well, I&#39;m not sure about that. A protocol describes what a type can do, so it&#39;s debatable whether a global function is within this scope.<br>&gt; <br>&gt; Operators are magically special: you can declare them inside a protocol and require them to be available for conformance, even if they don&#39;t belong to the type. You can&#39;t do the same thing for normal global functions, yet conceptually global functions and operators are the same thing.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt; <br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing `x.isEqual(to: y)` and `x == y`).<br></p><p>That is my concern with this approach as well. <br></p><p><br></p><p>&gt;&gt; – Do certain operators automatically get mapped to method names with appropriate signatures across all types, or does a conforming type still have to provide that mapping by implementing the operators separately? If it&#39;s the latter, that&#39;s extra work for the author of the type writing the protocol. If it&#39;s the former, does it make sense to automatically push these operators for all types? Should any type that has an `add` method automatically get `+` as a synonym as well? That may not be desirable.<br>&gt; <br>&gt; The difference at the protocol declaration is between:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; protocol Equatable {<br>&gt;     func isEqual(to other: Self) -&gt; Bool<br>&gt; }<br>&gt; <br>&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs.isEqual(to: rhs)<br>&gt; }<br>&gt; <br>&gt; so the latter is a bit more verbose, but arguably clearer in intent, and not different from how you would define any generic global function using a protocol, or from how you can define protocol extensions with default implementations that take advantage of the protocol&#39;s core methods.<br></p><p>The problem is that it is no longer clear whether to use the method or the operator to check for equality. <br></p><p>Now if we had some access modifier to hide the isEqual method except for overwriting it and using it within the operator, maybe some variant of &#39;protected&#39; (e.g. visible in implementors and the same file as the protocol) then that approach would be fine.<br></p><p>-Thorsten <br></p><p><br>&gt; <br>&gt; The difference for the conformance is between:<br>&gt; <br>&gt; extension Foo : Equatable { }<br>&gt; <br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return &lt;comparison&gt;<br>&gt; }<br>&gt; <br>&gt; and:<br>&gt; <br>&gt; extension Bar : Equatable {<br>&gt;     func isEqual(to: Bar) -&gt; Bool {<br>&gt;         return &lt;comparison&gt;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; the former way to define the conformance can be confusing to newbies. The latter is straightforward and consistent with the usual way to adopt a protocol.<br>&gt; <br>&gt; The == operator looks exactly the same at its use points, but the way how it&#39;s implemented is different.<br>&gt; In the former case, it&#39;s many overloads of a global function, which can stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to disambiguate in case of ambiguities.<br>&gt; In the latter case, there is only one generic definition of ==, which automatically applies to all types that conform to the protocol.<br>&gt;  <br>&gt; Nicola<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general, but I feel the arithmetic and comparison operations should be exposed by operators alone and not by methods, where there is a suitable operator that has the intended meaning.<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/bd6d4088/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9b5e7f229ebf32c8eca02e7cee0f379f?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Nicola Salmoria</string> &lt;nicola.salmoria at gmail.com&gt;<p>April 26, 2016 at 08:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 8:10 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br></p><p>&gt; See inline.<br>&gt;<br>&gt; Am 26.04.2016 um 19:36 schrieb Nicola Salmoria via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt;&gt; requirements for a type to fulfill, which includes things other than<br>&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt; must support.<br>&gt;&gt;<br>&gt;<br>&gt; Well, I&#39;m not sure about that. A protocol describes what a type can do, so<br>&gt; it&#39;s debatable whether a global function is within this scope.<br>&gt;<br>&gt; Operators are magically special: you can declare them inside a protocol<br>&gt; and require them to be available for conformance, even if they don&#39;t belong<br>&gt; to the type. You can&#39;t do the same thing for normal global functions, yet<br>&gt; conceptually global functions and operators are the same thing.<br>&gt;<br>&gt;<br>&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;<br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt;<br>&gt;<br>&gt; That is my concern with this approach as well.<br>&gt;<br>&gt;<br>&gt;<br>&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;<br>&gt;<br>&gt; The difference at the protocol declaration is between:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;     func isEqual(to other: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs.isEqual(to: rhs)<br>&gt; }<br>&gt;<br>&gt; so the latter is a bit more verbose, but arguably clearer in intent, and<br>&gt; not different from how you would define any generic global function using a<br>&gt; protocol, or from how you can define protocol extensions with default<br>&gt; implementations that take advantage of the protocol&#39;s core methods.<br>&gt;<br>&gt;<br>&gt; The problem is that it is no longer clear whether to use the method or the<br>&gt; operator to check for equality.<br>&gt;<br>&gt; Now if we had some access modifier to hide the isEqual method except for<br>&gt; overwriting it and using it within the operator, maybe some variant of<br>&gt; &#39;protected&#39; (e.g. visible in implementors and the same file as the<br>&gt; protocol) then that approach would be fine.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br></p><p>Why would you want to do that?<br></p><p>I see operators mostly as a convenience: a shortcut to express in a more<br>concise way something which should also be available through normal means.<br></p><p>It could be argued that generic code might prefer, for clarity, to use<br>explicit methods instead of vague global operators.<br></p><p>The approved but still unimplemented<br>https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br>also applies here, since the isEqual member method could also be used as a<br>static method for increased symmetry and clarity, i.e. instead of<br></p><p>_ = x.isEqual(to: y)<br></p><p>one could do<br></p><p>_ = Equatable.isEqual(x, to: y)<br></p><p>this could be useful in case of ambiguities.<br></p><p>Nicola<br></p><p><br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt; The difference for the conformance is between:<br>&gt;<br>&gt; extension Foo : Equatable { }<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return &lt;comparison&gt;<br>&gt; }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; extension Bar : Equatable {<br>&gt;     func isEqual(to: Bar) -&gt; Bool {<br>&gt;         return &lt;comparison&gt;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; the former way to define the conformance can be confusing to newbies. The<br>&gt; latter is straightforward and consistent with the usual way to adopt a<br>&gt; protocol.<br>&gt;<br>&gt; The == operator looks exactly the same at its use points, but the way how<br>&gt; it&#39;s implemented is different.<br>&gt; In the former case, it&#39;s many overloads of a global function, which can<br>&gt; stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to<br>&gt; disambiguate in case of ambiguities.<br>&gt; In the latter case, there is only one generic definition of ==, which<br>&gt; automatically applies to all types that conform to the protocol.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt; has the intended meaning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/ec662518/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 11:29 AM Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Tue, Apr 26, 2016 at 8:10 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; See inline.<br>&gt;&gt;<br>&gt;&gt; Am 26.04.2016 um 19:36 schrieb Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I personally disagree on this point. To me, a protocol describes a set<br>&gt;&gt;&gt; of requirements for a type to fulfill, which includes things other than<br>&gt;&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt;&gt; must support.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Well, I&#39;m not sure about that. A protocol describes what a type can do,<br>&gt;&gt; so it&#39;s debatable whether a global function is within this scope.<br>&gt;&gt;<br>&gt;&gt; Operators are magically special: you can declare them inside a protocol<br>&gt;&gt; and require them to be available for conformance, even if they don&#39;t belong<br>&gt;&gt; to the type. You can&#39;t do the same thing for normal global functions, yet<br>&gt;&gt; conceptually global functions and operators are the same thing.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That is my concern with this approach as well.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The difference at the protocol declaration is between:<br>&gt;&gt;<br>&gt;&gt; protocol Equatable {<br>&gt;&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; and:<br>&gt;&gt;<br>&gt;&gt; protocol Equatable {<br>&gt;&gt;     func isEqual(to other: Self) -&gt; Bool<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;     return lhs.isEqual(to: rhs)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; so the latter is a bit more verbose, but arguably clearer in intent, and<br>&gt;&gt; not different from how you would define any generic global function using a<br>&gt;&gt; protocol, or from how you can define protocol extensions with default<br>&gt;&gt; implementations that take advantage of the protocol&#39;s core methods.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The problem is that it is no longer clear whether to use the method or<br>&gt;&gt; the operator to check for equality.<br>&gt;&gt;<br>&gt;&gt; Now if we had some access modifier to hide the isEqual method except for<br>&gt;&gt; overwriting it and using it within the operator, maybe some variant of<br>&gt;&gt; &#39;protected&#39; (e.g. visible in implementors and the same file as the<br>&gt;&gt; protocol) then that approach would be fine.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;<br>&gt; Why would you want to do that?<br>&gt;<br>&gt; I see operators mostly as a convenience: a shortcut to express in a more<br>&gt; concise way something which should also be available through normal means.<br>&gt;<br></p><p>Why is the operator not the &quot;normal means&quot;? Centuries of mathematics tell<br>us that &quot;2 + 2 == 4&quot;, not &quot;2.adding(2).isEqual(to: 4)&quot;. We should make it<br>easier and consistent for Swift authors to write code that conforms to<br>existing terms (or in this case, symbols) of art, not introduce a<br>completely new and arbitrary set of methods that (1) bloat public<br>interfaces and (2) map to the same operators anyway.<br></p><p><br>It could be argued that generic code might prefer, for clarity, to use<br>&gt; explicit methods instead of vague global operators.<br>&gt;<br>&gt; The approved but still unimplemented<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br>&gt; also applies here, since the isEqual member method could also be used as a<br>&gt; static method for increased symmetry and clarity, i.e. instead of<br>&gt;<br>&gt; _ = x.isEqual(to: y)<br>&gt;<br>&gt; one could do<br>&gt;<br>&gt; _ = Equatable.isEqual(x, to: y)<br>&gt;<br>&gt; this could be useful in case of ambiguities.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The difference for the conformance is between:<br>&gt;&gt;<br>&gt;&gt; extension Foo : Equatable { }<br>&gt;&gt;<br>&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;     return &lt;comparison&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; and:<br>&gt;&gt;<br>&gt;&gt; extension Bar : Equatable {<br>&gt;&gt;     func isEqual(to: Bar) -&gt; Bool {<br>&gt;&gt;         return &lt;comparison&gt;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; the former way to define the conformance can be confusing to newbies. The<br>&gt;&gt; latter is straightforward and consistent with the usual way to adopt a<br>&gt;&gt; protocol.<br>&gt;&gt;<br>&gt;&gt; The == operator looks exactly the same at its use points, but the way how<br>&gt;&gt; it&#39;s implemented is different.<br>&gt;&gt; In the former case, it&#39;s many overloads of a global function, which can<br>&gt;&gt; stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to<br>&gt;&gt; disambiguate in case of ambiguities.<br>&gt;&gt; In the latter case, there is only one generic definition of ==, which<br>&gt;&gt; automatically applies to all types that conform to the protocol.<br>&gt;&gt;<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt;&gt; has the intended meaning.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; —<br>&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/8bc4cd9b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>Again, +1 to Tony&#39;s analysis. In the context of numerics in particular,<br>global functions and operators are very much &quot;normal means,&quot; and if<br>anything instance methods are rather &quot;convenience.&quot;<br>On Tue, Apr 26, 2016 at 13:36 Tony Allevato via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Apr 26, 2016 at 11:29 AM Nicola Salmoria &lt;<br>&gt; nicola.salmoria at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On Tue, Apr 26, 2016 at 8:10 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; See inline.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 26.04.2016 um 19:36 schrieb Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I personally disagree on this point. To me, a protocol describes a set<br>&gt;&gt;&gt;&gt; of requirements for a type to fulfill, which includes things other than<br>&gt;&gt;&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt;&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt;&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt;&gt;&gt; must support.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Well, I&#39;m not sure about that. A protocol describes what a type can do,<br>&gt;&gt;&gt; so it&#39;s debatable whether a global function is within this scope.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Operators are magically special: you can declare them inside a protocol<br>&gt;&gt;&gt; and require them to be available for conformance, even if they don&#39;t belong<br>&gt;&gt;&gt; to the type. You can&#39;t do the same thing for normal global functions, yet<br>&gt;&gt;&gt; conceptually global functions and operators are the same thing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt;&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt;&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt;&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That is my concern with this approach as well.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt;&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt;&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt;&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt;&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt;&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt;&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The difference at the protocol declaration is between:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; and:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protocol Equatable {<br>&gt;&gt;&gt;     func isEqual(to other: Self) -&gt; Bool<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;&gt;&gt;     return lhs.isEqual(to: rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; so the latter is a bit more verbose, but arguably clearer in intent, and<br>&gt;&gt;&gt; not different from how you would define any generic global function using a<br>&gt;&gt;&gt; protocol, or from how you can define protocol extensions with default<br>&gt;&gt;&gt; implementations that take advantage of the protocol&#39;s core methods.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The problem is that it is no longer clear whether to use the method or<br>&gt;&gt;&gt; the operator to check for equality.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Now if we had some access modifier to hide the isEqual method except for<br>&gt;&gt;&gt; overwriting it and using it within the operator, maybe some variant of<br>&gt;&gt;&gt; &#39;protected&#39; (e.g. visible in implementors and the same file as the<br>&gt;&gt;&gt; protocol) then that approach would be fine.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Why would you want to do that?<br>&gt;&gt;<br>&gt;&gt; I see operators mostly as a convenience: a shortcut to express in a more<br>&gt;&gt; concise way something which should also be available through normal means.<br>&gt;&gt;<br>&gt;<br>&gt; Why is the operator not the &quot;normal means&quot;? Centuries of mathematics tell<br>&gt; us that &quot;2 + 2 == 4&quot;, not &quot;2.adding(2).isEqual(to: 4)&quot;. We should make it<br>&gt; easier and consistent for Swift authors to write code that conforms to<br>&gt; existing terms (or in this case, symbols) of art, not introduce a<br>&gt; completely new and arbitrary set of methods that (1) bloat public<br>&gt; interfaces and (2) map to the same operators anyway.<br>&gt;<br>&gt;<br>&gt; It could be argued that generic code might prefer, for clarity, to use<br>&gt;&gt; explicit methods instead of vague global operators.<br>&gt;&gt;<br>&gt;&gt; The approved but still unimplemented<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0042-flatten-method-types.md<br>&gt;&gt; also applies here, since the isEqual member method could also be used as<br>&gt;&gt; a static method for increased symmetry and clarity, i.e. instead of<br>&gt;&gt;<br>&gt;&gt; _ = x.isEqual(to: y)<br>&gt;&gt;<br>&gt;&gt; one could do<br>&gt;&gt;<br>&gt;&gt; _ = Equatable.isEqual(x, to: y)<br>&gt;&gt;<br>&gt;&gt; this could be useful in case of ambiguities.<br>&gt;&gt;<br>&gt;&gt; Nicola<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The difference for the conformance is between:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Foo : Equatable { }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;&gt;&gt;     return &lt;comparison&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; and:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension Bar : Equatable {<br>&gt;&gt;&gt;     func isEqual(to: Bar) -&gt; Bool {<br>&gt;&gt;&gt;         return &lt;comparison&gt;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; the former way to define the conformance can be confusing to newbies.<br>&gt;&gt;&gt; The latter is straightforward and consistent with the usual way to adopt a<br>&gt;&gt;&gt; protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The == operator looks exactly the same at its use points, but the way<br>&gt;&gt;&gt; how it&#39;s implemented is different.<br>&gt;&gt;&gt; In the former case, it&#39;s many overloads of a global function, which can<br>&gt;&gt;&gt; stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to<br>&gt;&gt;&gt; disambiguate in case of ambiguities.<br>&gt;&gt;&gt; In the latter case, there is only one generic definition of ==, which<br>&gt;&gt;&gt; automatically applies to all types that conform to the protocol.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt;&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt;&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt;&gt;&gt; has the intended meaning.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; —<br>&gt;&gt;&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/1531d0b8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>April 26, 2016 at 01:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 12:36 PM, Nicola Salmoria via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt;&gt; requirements for a type to fulfill, which includes things other than<br>&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt; must support.<br>&gt;&gt;<br>&gt;<br>&gt; Well, I&#39;m not sure about that. A protocol describes what a type can do, so<br>&gt; it&#39;s debatable whether a global function is within this scope.<br>&gt;<br>&gt; Operators are magically special: you can declare them inside a protocol<br>&gt; and require them to be available for conformance, even if they don&#39;t belong<br>&gt; to the type. You can&#39;t do the same thing for normal global functions, yet<br>&gt; conceptually global functions and operators are the same thing.<br>&gt;<br></p><p>On the contrary, to my mind that&#39;s an argument to find some way to express<br>global functions as requirements for protocol conformance.<br></p><p><br>&gt;<br>&gt;&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;<br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;<br>&gt;<br>&gt; The difference at the protocol declaration is between:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;     func isEqual(to other: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs.isEqual(to: rhs)<br>&gt; }<br>&gt;<br>&gt; so the latter is a bit more verbose, but arguably clearer in intent, and<br>&gt; not different from how you would define any generic global function using a<br>&gt; protocol, or from how you can define protocol extensions with default<br>&gt; implementations that take advantage of the protocol&#39;s core methods.<br>&gt;<br>&gt; The difference for the conformance is between:<br>&gt;<br>&gt; extension Foo : Equatable { }<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return &lt;comparison&gt;<br>&gt; }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; extension Bar : Equatable {<br>&gt;     func isEqual(to: Bar) -&gt; Bool {<br>&gt;         return &lt;comparison&gt;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; the former way to define the conformance can be confusing to newbies. The<br>&gt; latter is straightforward and consistent with the usual way to adopt a<br>&gt; protocol.<br>&gt;<br>&gt; The == operator looks exactly the same at its use points, but the way how<br>&gt; it&#39;s implemented is different.<br>&gt; In the former case, it&#39;s many overloads of a global function, which can<br>&gt; stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to<br>&gt; disambiguate in case of ambiguities.<br>&gt; In the latter case, there is only one generic definition of ==, which<br>&gt; automatically applies to all types that conform to the protocol.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt; has the intended meaning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/7efbfcf6/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0067: Enhanced Floating Point Protocols</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 26, 2016 at 06:00:00pm</p></header><div class="content"><p>On Tue, Apr 26, 2016 at 10:36 AM Nicola Salmoria &lt;nicola.salmoria at gmail.com&gt;<br>wrote:<br></p><p>&gt; On Tue, Apr 26, 2016 at 4:28 PM, Tony Allevato &lt;allevato at google.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; On Sun, Apr 24, 2016 at 2:57 AM Nicola Salmoria via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; &gt; &gt; func isEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLess(than other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt; &gt; func isLessThanOrEqual(to other: Self) -&gt;Bool<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; I&#39;m still not sure why these are methods instead of operators.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I think this is an *excellent* choice, and I hope it is the first step<br>&gt;&gt;&gt; to completely removing operators from protocols.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; IMHO throwing operators into protocols is inconsistent and confusing.<br>&gt;&gt;&gt; Having regular methods and a single generic version of the operator that<br>&gt;&gt;&gt; calls down on the type’s methods is clearer and guarantees that generic<br>&gt;&gt;&gt; code can avoid ambiguities by calling the methods directly, instead of<br>&gt;&gt;&gt; having to rely only on heavily overloaded global operators.<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I personally disagree on this point. To me, a protocol describes a set of<br>&gt;&gt; requirements for a type to fulfill, which includes things other than<br>&gt;&gt; methods. Just as a protocol can define initializers, properties, and<br>&gt;&gt; associated types that a type must define in order to conform, it makes<br>&gt;&gt; sense that a protocol would also define which operators a conforming type<br>&gt;&gt; must support.<br>&gt;&gt;<br>&gt;<br>&gt; Well, I&#39;m not sure about that. A protocol describes what a type can do, so<br>&gt; it&#39;s debatable whether a global function is within this scope.<br>&gt;<br></p><p>In my eyes, &quot;instances of a type conforming to Foo can be compared to other<br>values using the == operator&quot; is a description of what a type can do, just<br>as &quot;instances of a type conforming to Foo have a method named isEqual that<br>can take another value as an argument&quot;. The only difference is how that is<br>constructed in the language. Where we seemt o differ is that I feel that<br>protocols should describe high-level requirements of a type (semantic),<br>while you are arguing that they should only describe requirements that can<br>be declared *within* them (syntactic). It&#39;s a good discussion to have, but<br>not limited to the scope of floating point numbers.<br></p><p><br>&gt; Operators are magically special: you can declare them inside a protocol<br>&gt; and require them to be available for conformance, even if they don&#39;t belong<br>&gt; to the type. You can&#39;t do the same thing for normal global functions, yet<br>&gt; conceptually global functions and operators are the same thing.<br>&gt;<br></p><p>I agree that this is currently an inconsistency, but perhaps only because<br>we think of operators as functions because they&#39;re defined with &quot;func&quot;. We<br>could either resolve the inconsistency by (1) using a different keyword,<br>like &quot;operator&quot; (which has been discussed before, but is essentially just a<br>visual change), (2) allowing global functions to be defined in the same way<br>(though there would need to be a syntax change to differentiate members<br>from globals in the protocol definitions, or (3) something else entirely<br>that I haven&#39;t thought of.<br></p><p><br></p><p>&gt; Introducing a mapping between names and operators poses a few problems:<br>&gt;&gt;<br>&gt;&gt; – IMO, they are overly verbose and add noise to the definition. This<br>&gt;&gt; makes the language look less clean (I&#39;m getting visions of NSDecimalNumber).<br>&gt;&gt; – They expose two ways to accomplish the same thing (writing<br>&gt;&gt; `x.isEqual(to: y)` and `x == y`).<br>&gt;&gt; – Do certain operators automatically get mapped to method names with<br>&gt;&gt; appropriate signatures across all types, or does a conforming type still<br>&gt;&gt; have to provide that mapping by implementing the operators separately? If<br>&gt;&gt; it&#39;s the latter, that&#39;s extra work for the author of the type writing the<br>&gt;&gt; protocol. If it&#39;s the former, does it make sense to automatically push<br>&gt;&gt; these operators for all types? Should any type that has an `add` method<br>&gt;&gt; automatically get `+` as a synonym as well? That may not be desirable.<br>&gt;&gt;<br>&gt;<br>&gt; The difference at the protocol declaration is between:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;     func ==(lhs: Self, rhs: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; protocol Equatable {<br>&gt;<br>&gt;     func isEqual(to other: Self) -&gt; Bool<br>&gt; }<br>&gt;<br>&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: T) -&gt; Bool {<br>&gt;     return lhs.isEqual(to: rhs)<br>&gt; }<br>&gt;<br>&gt; so the latter is a bit more verbose, but arguably clearer in intent, and<br>&gt; not different from how you would define any generic global function using a<br>&gt; protocol, or from how you can define protocol extensions with default<br>&gt; implementations that take advantage of the protocol&#39;s core methods.<br>&gt;<br></p><p>How would other global operators be defined? Would FloatingPointProtocol<br>define operators like +&lt;T: FloatingPointProtocol&gt;, which might be different<br>from something like +&lt;T: Matrix&gt; or +(lhs: String, rhs: String)? Or would<br>there be a magical Addable protocol that maps +&lt;T: Addable&gt; to .add?<br>(That&#39;s a strawman—I would hate for that protocol to exist :)<br></p><p>If the case is that individual protocols still have to define global<br>overloads of the operators, then we haven&#39;t really achieved much except for<br>introducing a new method into the protocol and moved the operator out,<br>which I don&#39;t believe isn&#39;t a satisfying way of solving the problem of<br>uniformity for protocol operators.<br></p><p><br></p><p>&gt;<br>&gt; The difference for the conformance is between:<br>&gt;<br>&gt; extension Foo : Equatable { }<br>&gt;<br>&gt; func ==(lhs: Foo, rhs: Foo) -&gt; Bool {<br>&gt;     return &lt;comparison&gt;<br>&gt; }<br>&gt;<br>&gt; and:<br>&gt;<br>&gt; extension Bar : Equatable {<br>&gt;     func isEqual(to: Bar) -&gt; Bool {<br>&gt;         return &lt;comparison&gt;<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; the former way to define the conformance can be confusing to newbies. The<br>&gt; latter is straightforward and consistent with the usual way to adopt a<br>&gt; protocol.<br>&gt;<br></p><p>However, the examples you presented are not the only possible ways that we<br>could solve this problem, and I think the community should be able to<br>discuss options that let us keep operators as first-class citizens in<br>protocols without bloating the protocols with unnecessary methods.<br></p><p>My larger concern though is that *for this proposal specifically*, using<br>method names instead of operators is inconsistent with Swift as it is<br>designed today, and worse, it is making a judgment call about how operators<br>should be expressed in protocols that deserves more discussion outside of<br>the context of this proposal. Essentially, it would shoehorn in a design<br>philosophy that hasn&#39;t been fully debated. (Just look at how much<br>bikeshedding has already gone into preposition/argument labeling for<br>isLessThanOrEqual(to:).)<br></p><p><br></p><p>&gt; The == operator looks exactly the same at its use points, but the way how<br>&gt; it&#39;s implemented is different.<br>&gt; In the former case, it&#39;s many overloads of a global function, which can<br>&gt; stress the compiler&#39;s type inference and doesn&#39;t offer an obvious way to<br>&gt; disambiguate in case of ambiguities.<br>&gt; In the latter case, there is only one generic definition of ==, which<br>&gt; automatically applies to all types that conform to the protocol.<br>&gt;<br>&gt; Nicola<br>&gt;<br>&gt;<br>&gt;&gt; I&#39;m very supportive of the floating-point protocol proposal in general,<br>&gt;&gt; but I feel the arithmetic and comparison operations should be exposed by<br>&gt;&gt; operators alone and not by methods, where there is a suitable operator that<br>&gt;&gt; has the intended meaning.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; —<br>&gt;&gt;&gt; Nicola<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160426/df3b981c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
