<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 21, 2016 at 08:00:00am</p></header><div class="content"><p>Hello Swift community,<br></p><p>The third review of &quot;SE-0117: Allow distinguishing between public access and public overridability&quot; begins now and runs through July 25. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 21, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 21 Jul 2016, at 17:33, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access and public overridability&quot; begins now and runs through July 25. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p><br>Just posted in the Review #2 thread. I read the updated proposal, and I have another idea besides making “final” default:<br></p><p>I would be okay with the inferred situation for classes being a semantic “final”. That is, that they cannot be subclassed, but they won’t be automatically optimised in a fragile way either. We could call it “sealed” if you want to explicitly specify it - the difference is that it doesn’t only apply at the module boundary, and it’s just an annotation for the type-checker (both yours and that of the third-party developer) that it shouldn’t allow this - it’s not license for library module’s compiler to give up flexibility. So:<br></p><p>public class Foo {}                        // Implicitly “sealed”. Cannot be subclassed anywhere. Does not provide optimiser guarantees of “final”.<br>public(sealed) class Foo {}           // as above<br></p><p>public final class Foo {}                // Implicitly “sealed”. Cannot be subclassed anywhere. Allows resilience-breaking optimisations.<br>public(sealed) final class Foo {}   // as above<br></p><p>public internal(open) class Foo {}                       // “open” overrides “sealed” for the internal scope. Cannot be subclassed externally; may be subclassed internally. Does not provide optimiser guarantees of “final”.<br>public open(internal) class Foo {}                       // another idea: flipping the order, so it becomes open(internal) rather than internal(open). This looks nicer, is the opposite of the property accessor scope syntax - &quot;public internal(set) ...&quot;<br>public(sealed) internal(open) class Foo {}          // as above<br></p><p>public(sealed) internal(open) final class Foo {}  // Error: A class cannot be both open and final<br></p><p>I believe that would meet the goals of:<br></p><p>- Not allowing subclassing from external modules unless explicitly allowed (the original goal)<br>- Making classes which are internally-subclassed easier to locally reason about (my nice-to-have)<br>- Maintain binary compatibility<br>- Do not give up binary flexibility unless the user explicitly asks for it (a goal in the LibraryEvolution docs, however current or not they may be)<br></p><p>Is there anything I missed?<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/74b6a325/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>On Jul 21, 2016, at 8:56 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; Just posted in the Review #2 thread. I read the updated proposal, and I have another idea besides making “final” default:<br></p><p>Hi Karl,<br></p><p>Please respond to proposal on this thread with your evaluation of it.  This isn’t the right place to make counterproposals.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>July 21, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 21 Jul 2016, at 20:49, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Jul 21, 2016, at 8:56 AM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Just posted in the Review #2 thread. I read the updated proposal, and I have another idea besides making “final” default:<br>&gt; <br>&gt; Hi Karl,<br>&gt; <br>&gt; Please respond to proposal on this thread with your evaluation of it.  This isn’t the right place to make counterproposals.<br>&gt; <br>&gt; -Chris<br></p><p>-1 from me. Same reasons as before, I think:<br></p><p>First proposal:<br>- Conflation of ‘public’ and ‘open’; it feels like open is a new higher access level, like getting married, or going sudo or something. If this proposal was accepted, ‘open&#39; should substitute ‘public’, and never be alongside it (the same way “public private class” makes no sense)<br></p><p>- The concept of classes/class members which are closed until ‘open’ed is a powerful one for documenting classes and writing locally-reasonable code. It shouldn’t be mixed up with exposure to external modules - we already have a concept to describe that; it’s called access levels and ‘public’. I’ve worked with horrible base-classes before with a mixture of internally overridden and non-overriden members, and I would have absolutely loved some compiler-enforced annotation in that case. It makes sure that people stick to the contracts for a class’ members, and that breaking them is something you need to think twice about.<br></p><p>Second proposal:<br>- I’m arguing for increased local reasoning for classes, this proposal wants to make more of the permissions implicit. I’m not a fan.<br>- Extra API can be added with extensions. Extra state is something we should look in to in general. Obj-C had associated objects; maybe we can do better with Swift.<br></p><p>Basically, if you consider that we would need an explicit keyword for the default, non-open state (lets say “sealed”) as we have for “internal” - whether or not it applies inside the module is the only difference between the first proposal and my counter-proposal.<br>We could make that change later, but I think we should go with the sound logic behind this idea, and go with the expectation of safety and local reasonability, and try to make it as consistent as possible from the start. We could loosen it up to only apply to ‘public’ members if too onerous (although my preference would be shorthands - “open-all” or something).<br></p><p>Karl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 2:29 PM, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On 21 Jul 2016, at 20:49, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Jul 21, 2016, at 8:56 AM, Karl &lt;razielim at gmail.com &lt;mailto:razielim at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Just posted in the Review #2 thread. I read the updated proposal, and I have another idea besides making “final” default:<br>&gt;&gt; <br>&gt;&gt; Hi Karl,<br>&gt;&gt; <br>&gt;&gt; Please respond to proposal on this thread with your evaluation of it.  This isn’t the right place to make counterproposals.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt; <br>&gt; -1 from me. Same reasons as before, I think:<br></p><p>I’m -1 as well, for the reasons that have already been given, but since it’s clear that this thing’s going to be rammed down our throats no matter how we feel about it, we might as well try to make lemonade:<br></p><p>&gt; First proposal:<br>&gt; - Conflation of ‘public’ and ‘open’; it feels like open is a new higher access level, like getting married, or going sudo or something. If this proposal was accepted, ‘open&#39; should substitute ‘public’, and never be alongside it (the same way “public private class” makes no sense)<br></p><p>Actually, if ‘public’ and ‘open’ are separated, it might allow us to finally have some sort of ‘protected’ access level. ‘private open’ implies something that can be subclassed but not otherwise accessed, which would more or less provide ‘protected’ functionality.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/d0de4f3e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a5a2cebcb5559ab317c1ce5a5ed9a064?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Garth Snyder</string> &lt;garth at garthsnyder.com&gt;<p>July 21, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>[ Long, sorry… ]<br></p><p>This version is a big step forward! Thanks for the continued work and comments...<br></p><p>I want to propose a small reframing that I think would help to clarify some of the remaining issues. It’s not really a “counterproposal” because I don’t think it actually changes all that much about the proposal. It’s more a question of how one conceptualizes the changes and fits them into the existing framework.<br></p><p>The gist is: let’s let the second shoe drop and admit that in the current proposal, “open” is now an access level modifier, pure and simple.<br></p><p>In the original proposal (and the ensuing discussion), there was tacit agreement that subclassability/overridability and access levels should be orthogonal. However, given the direction that the design has taken since then, I think we should revisit that decision.<br></p><p>open IS in fact an access level. I can’t say it any better than the proposal itself: “Since the first release of Swift, marking a class public has provided two capabilities: it allows other modules to instantiate and use the class, and it also allows other modules to define subclasses of it. Similarly, marking a class member (a method, property, or subscript) public has provided two capabilities: it allows other modules to use the member, and it also allows those modules to override it…This proposal suggests distinguishing these concepts. A public member will only be usable by other modules, but not overridable. An open member will be both usable and overridable. Similarly, a public class will only be usable by other modules, but not subclassable. An open class will be both usable and subclassable.”<br></p><p>In other words, subclassability/overridability always was an access level issue. All we are doing now is subdividing public into two separate sublevels, public and open. Just as public subsumes all the privileges of internal, open subsumes public.<br></p><p>Arguments:<br></p><p>First, the vast majority of resistance to this proposal (including my own, originally) has centered on the sense that coding options are being removed for potentially or partially ideological reasons (see SoftwareDevelopmentAttitude &lt;http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html&gt;), without clear value being offered in return. Reframing open as an access level completely nullifies this objection. “internal” is already the default access level, and the community seems very comfortable with this. For public APIs, developers are now simply required to make a neutral choice between public and open. There’s no strong-arming and no surprising imposition of new restrictions. Developers just have to make exactly the same, explicit access level decisions they did before. (For public API, the default is already so restrictive as to be moot. No accusations of “you picked the wrong default”!)<br></p><p>Second, framing open as an access level automatically resolves the ambiguity between proposal options #1 and #2, in favor of #1 (classes can be marked open). The reason there’s ambiguity about this choice is that there’s ambiguity about what open &quot;really is.” Pin down exactly how open fits into the larger language, and the resolution is obvious. We already know what it means for a class and its members to have different access levels: the members are clamped to the access level of the container. All of the arguments that led to this convention — chiefly, that one may want to keep eventual publication in mind while developing and then be able to “flip the switch” in one place —  apply equally to the additional privileges of open.  <br></p><p>Third, developers already understand access levels and how they interact. If open is just an access level, all of this proposal’s changes can be fully and naturally described in one line: “public no longer includes the right to subclass or override. To get the behavior formerly known as public, use open instead.” Clear, concise, and not very controversial.<br></p><p>Fourth, bending over backwards to insist that open is not an access level leads to a variety of weird effects and special cases. For example, the fact that open implies public unless otherwise stated, which is mighty strange for modifiers that are supposedly orthogonal. Not to mention all the potential headbutts mentioned earlier by Xiaodi Wu; I agree that open in combination with internal seems oxymoronic. All of these nits would just go away if open were an access level. Again, all of this is the case because open really does quack like an access level and walk like an access level.<br></p><p>Points:<br></p><p>Q: “But what about access-leveled entities for which ‘open’ doesn’t make sense? What does ‘open struct’ mean?”<br>A: It doesn’t mean anything and should be an error. Simple. It’s not as if there weren’t all kinds of above-grammar-level restrictions in the current design…<br></p><p>Q: “What about conflicts with other modifiers, e.g. ‘open is not permitted on declarations that are explicitly final or dynamic’? Isn’t it weird that a simple access level could cause this kind of conflict?”<br>A: Au contraire, it’s final and dynamic that impose special requirements. You can just as easily flip this around: “final may not be applied to objects at the open access level”. Doesn’t that make more sense anyway?<br></p><p>Q: “You yourself (Garth) have argued that there’s no value to being able to forbid subclassing at the class level, and others have taken this position as well. So why are you now so eager to add ‘open’ to class definitions?”<br>A: Because it leads to a simple, consistent, and uncontroversial design. I do think there is value in being able to “flip the switch” at the class level as well. From the technical/compiler perspective, it seems like most benefits derive from method-level restrictions (as the current proposal seems to suggest). However, from the perspective of API clients, the top-level question is always going to be “should I be subclassing this or not?” I wouldn’t argue in favor of a class-level keyword just for the purpose of documenting intention, but since we get it for free with these other benefits, I’m all for it.<br></p><p>Garth<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/ebffbcb3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 21, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; All of these nits would just go away if open were an access level. Again,<br>&gt; all of this is the case because open *really does* quack like an access<br>&gt; level and walk like an access level.<br></p><p><br>+1<br></p><p>Well-said Garth.<br></p><p>Nevin<br></p><p><br>On Thu, Jul 21, 2016 at 6:29 PM, Garth Snyder via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1<br>&gt;<br>&gt; [ Long, sorry… ]<br>&gt;<br>&gt; This version is a big step forward! Thanks for the continued work and<br>&gt; comments...<br>&gt;<br>&gt; I want to propose a small *reframing* that I think would help to clarify<br>&gt; some of the remaining issues. It’s not really a “counterproposal” because I<br>&gt; don’t think it actually changes all that much about the proposal. It’s more<br>&gt; a question of how one conceptualizes the changes and fits them into the<br>&gt; existing framework.<br>&gt;<br>&gt; *The gist is:* let’s let the second shoe drop and admit that in the<br>&gt; current proposal, “open” is now an access level modifier, pure and simple.<br>&gt;<br>&gt; In the original proposal (and the ensuing discussion), there was tacit<br>&gt; agreement that subclassability/overridability and access levels should be<br>&gt; orthogonal. However, given the direction that the design has taken since<br>&gt; then, I think we should revisit that decision.<br>&gt;<br>&gt; open *IS* in fact an access level. I can’t say it any better than the<br>&gt; proposal itself: *“Since the first release of Swift, marking a class<br>&gt; public has provided two capabilities: it allows other modules to<br>&gt; instantiate and use the class, and it also allows other modules to define<br>&gt; subclasses of it. Similarly, marking a class member (a method, property, or<br>&gt; subscript) public has provided two capabilities: it allows other modules to<br>&gt; use the member, and it also allows those modules to override it…This<br>&gt; proposal suggests distinguishing these concepts. A public member will only<br>&gt; be usable by other modules, but not overridable. An open member will be<br>&gt; both usable and overridable. Similarly, a public class will only be usable<br>&gt; by other modules, but not subclassable. An open class will be both usable<br>&gt; and subclassable.”*<br>&gt;<br>&gt; In other words, subclassability/overridability *always was *an access<br>&gt; level issue. *All we are doing now* is subdividing public into two<br>&gt; separate sublevels, public and open. Just as public subsumes all the<br>&gt; privileges of internal, open subsumes public.<br>&gt;<br>&gt;<br>&gt; *Arguments:*<br>&gt; *First*, the vast majority of resistance to this proposal (including my<br>&gt; own, originally) has centered on the sense that coding options are being<br>&gt; removed for potentially or partially ideological reasons (see<br>&gt; SoftwareDevelopmentAttitude<br>&gt; &lt;http://martinfowler.com/bliki/SoftwareDevelopmentAttitude.html&gt;),<br>&gt; without clear value being offered in return. Reframing open as an access<br>&gt; level *completely nullifies *this objection. “internal” is already the<br>&gt; default access level, and the community seems very comfortable with this.<br>&gt; For public APIs, developers are now simply required to make a neutral<br>&gt; choice between public and open. There’s no strong-arming and no surprising<br>&gt; imposition of new restrictions. Developers just have to make exactly the<br>&gt; same, explicit access level decisions they did before. (For public API, the<br>&gt; default is already so restrictive as to be moot. No accusations of “you<br>&gt; picked the wrong default”!)<br>&gt;<br>&gt; *Second*, framing open as an access level automatically resolves the<br>&gt; ambiguity between proposal options #1 and #2, in favor of #1 (classes<br>&gt; can be marked open). The reason there’s ambiguity about this choice is that<br>&gt; there’s ambiguity about what open &quot;really is.” Pin down exactly how open<br>&gt; fits into the larger language, and the resolution is obvious. We already<br>&gt; know what it means for a class and its members to have different access<br>&gt; levels: the members are clamped to the access level of the container. All<br>&gt; of the arguments that led to this convention — chiefly, that one may want<br>&gt; to keep eventual publication in mind while developing and then be able to<br>&gt; “flip the switch” in one place —  apply equally to the additional<br>&gt; privileges of open.<br>&gt;<br>&gt; *Third*, developers already understand access levels and how they<br>&gt; interact. If open is just an access level, all of this proposal’s changes<br>&gt; can be fully and naturally described in one line: “public no longer<br>&gt; includes the right to subclass or override. To get the behavior formerly<br>&gt; known as public, use open instead.” Clear, concise, and not very<br>&gt; controversial.<br>&gt;<br>&gt; *Fourth*, bending over backwards to insist that open is not an access<br>&gt; level leads to a variety of weird effects and special cases. For example,<br>&gt; the fact that open implies public unless otherwise stated, which is mighty<br>&gt; strange for modifiers that are supposedly orthogonal. Not to mention all<br>&gt; the potential headbutts mentioned earlier by Xiaodi Wu; I agree that open<br>&gt; in combination with internal seems oxymoronic. All of these nits would just<br>&gt; go away if open were an access level. Again, all of this is the case<br>&gt; because open *really does* quack like an access level and walk like an<br>&gt; access level.<br>&gt;<br>&gt;<br>&gt; *Points:*<br>&gt; *Q:* “But what about access-leveled entities for which ‘open’ doesn’t<br>&gt; make sense? What does ‘open struct’ mean?”<br>&gt; *A:* It doesn’t mean anything and should be an error. Simple. It’s not as<br>&gt; if there weren’t all kinds of above-grammar-level restrictions in the<br>&gt; current design…<br>&gt;<br>&gt; *Q:* “What about conflicts with other modifiers, e.g. ‘open is not<br>&gt; permitted on declarations that are explicitly final or dynamic’? Isn’t it<br>&gt; weird that a simple access level could cause this kind of conflict?”<br>&gt; *A:* Au contraire, it’s final and dynamic that impose special<br>&gt; requirements. You can just as easily flip this around: “final may not be<br>&gt; applied to objects at the open access level”. Doesn’t that make more sense<br>&gt; anyway?<br>&gt;<br>&gt; *Q:* “You yourself (Garth) have argued that there’s no value to being<br>&gt; able to forbid subclassing at the class level, and others have taken this<br>&gt; position as well. So why are you now so eager to add ‘open’ to class<br>&gt; definitions?”<br>&gt; *A:* Because it leads to a simple, consistent, and uncontroversial<br>&gt; design. I do think there is value in being able to “flip the switch” at the<br>&gt; class level as well. From the technical/compiler perspective, it seems like<br>&gt; most benefits derive from method-level restrictions (as the current<br>&gt; proposal seems to suggest). However, from the perspective of API clients,<br>&gt; the top-level question is always going to be “should I be subclassing this<br>&gt; or not?” I wouldn’t argue in favor of a class-level keyword just for the<br>&gt; purpose of documenting intention, but since we get it for free with these<br>&gt; other benefits, I’m all for it.<br>&gt;<br>&gt; Garth<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/464b8606/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 22, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Am 22.07.2016 um 00:29 schrieb Garth Snyder via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; In the original proposal (and the ensuing discussion), there was tacit agreement that subclassability/overridability and access levels should be orthogonal. However, given the direction that the design has taken since then, I think we should revisit that decision.<br>You can&#39;t change what you cannot see, so orthogonality was never a real option.<br>It could be, if &quot;public&quot; did not affect visibility, but rather the right to instantiate/call. In this scenario, you could specify an abstract class &quot;for free&quot; as &quot;private open class Foo&quot;.<br>I&#39;m still convinced that such synergies are highly desirable, and that a holistic take on the whole topic would be more beneficial for Swift than the small-scale changes that have been discussed so far.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/b15b2fe1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1 for the first design listed. Simplicity is nice but the ability to vend<br>non-final classes that cannot be publicly subclassed is worth the<br>complexity.<br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br>Yes.<br>        * Does this proposal fit well with the feel and direction of Swift?<br>Yes.<br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br>I haven&#39;t<br>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br>I have followed the discussion and I gave a quick reading of this version.<br></p><p>On Thu, Jul 21, 2016 at 11:33 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access<br>&gt; and public overridability&quot; begins now and runs through July 25. The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/42dcc03d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 21, 2016 at 11:00:00am</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 10:33 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access<br>&gt; and public overridability&quot; begins now and runs through July 25. The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>Much improved. I would be happy with either of the alternatives about open<br>classes.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>(See previous review.)<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes, almost entirely. One more nit. Now that `open` is proposed as a<br>standalone modifier (as opposed to `public open`), it should *not* be<br>composable with `internal`, etc. Here&#39;s why:<br></p><p>If I make an `internal` subclass of an `open` class, I should not be able<br>to have a `private open override`. In a [public] open subclass, I&#39;d be<br>required to have a [public] open override. So too for an internal subclass<br>it doesn&#39;t make sense that the override might have less visibility than the<br>type itself. Forbidding accessory access control modifiers would have the<br>desired effect of enforcing the same visibility for an overriding open<br>member as for its containing type.<br></p><p>Moreover, from a learnability standpoint, seeing `private open` and<br>`internal open` sets up the expectation that `public open` might be<br>meaningful and not redundant, and that `open` might mean `internal open`<br>just as in (nearly) all other circumstances the absence of `private`,<br>`fileprivate`, and `public` implies `internal`. Since this is not true, and<br>since accessory access control modifiers should never be necessary as<br>discussed above, I&#39;d advocate for forbidding the use of `open` in<br>conjunction with an explicit access level.<br></p><p>        * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>(See previous review.)<br></p><p><br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/c7a54bb8/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>On Thu, Jul 21, 2016 at 8:33 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access<br>&gt; and public overridability&quot; begins now and runs through July 25. The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>+1 to the first design. I wouldn&#39;t be upset if the second design was what<br>got accepted, but I strongly prefer the first.<br></p><p>One of the benefits of this proposal has been formalizing some software<br>design notions related to type extensibility, and I feel very strongly that<br>API authors should be forced to make a decision one way or the other at the<br>time that they design a class whether it is extensible or not. It&#39;s true<br>that under design #2 you get a closed class (module extending with data)<br>without the explicitness of the keyword. However, being able to look at a<br>class definition and know immediately whether it&#39;s intended to be open or<br>closed is even more important. The performance improvements also seem<br>compelling.<br></p><p>While the formal side of me really liked keeping orthogonal concepts<br>(visibility vs. extensibility) separate, I can appreciate the desire to<br>eliminate boilerplate. Having &quot;open&quot; imply &quot;public&quot; unless stated otherwise<br>seems like a reasonable compromise.<br></p><p>Likewise, open-within-a-module-and-closed-outside as the default for<br>&quot;public&quot; is entirely aligned with Swift&#39;s other default visibility,<br>internal-by-default. The credo is essentially &quot;don&#39;t protect users from<br>themselves and don&#39;t make coding more difficult for the common case of<br>within-app/module development, but the minute you decide to expose<br>something for other users, you must think about these things that affect<br>how others can and will use it.&quot;<br></p><p><br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>Yes. More mainstream languages need to do more to encourage authors to<br>think about their designs and to allow those who care deeply about API<br>design to express them well.<br></p><p><br>        * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br></p><p>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>        * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br></p><p>Read the original and latest proposals and followed the discussions.<br></p><p><br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/34552ffb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>(Google inbox won&#39;t let me inline my comments)<br></p><p>Thanks for the effort on iterating and refining this proposal.<br></p><p>+1 on the proposal, more strongly favoring the first design.<br></p><p>If my brain is working correctly it seems like we could start with the<br>first design and if somehow problematic move to the the second model in the<br>future without (much?) disruption. I didn&#39;t sit down and reason it out in<br>much depth (watching my 2.5 year old at the moment) however so I will leave<br>that to others to ponder.<br></p><p>I think it aligns well with Swifts principles in terms of favoring external<br>to module API to be intentional / explicit. The latest revisions - I think<br>- has also sufficiently reduced the burden to module developers which is<br>also another important aspect of Swift.<br></p><p>I haven&#39;t used a language the has this exact type of feature but I have<br>often desired to haven his type of capability when I was authoring<br>libraries for others (often in company). I am a believer in being very<br>explicit in API contract to both confine what I have to design for/test<br>when authoring a library as well as having more clarity when consuming a<br>library.<br></p><p><br></p><p><br>-Shawn<br></p><p>On Thu, Jul 21, 2016 at 11:33 AM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access<br>&gt; and public overridability&quot; begins now and runs through July 25. The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/3540c898/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 to the first design.  I think this is a great solution that balances the many considerations that have been raised on all sides of this issue.  `open` is 2 characters shorter than `public` so complaints about boilerplate are no longer valid.  `internal` is the “default” - neither `public` nor `open` are privileged as a “default” for publishing API outside of a module.  <br></p><p>I am interested in language enhancements such as exhaustive pattern matching on classes and protocols which rely on knowledge of the full class hierarchy.  Such enhancements will be far more useful if the language supports non-open, non-final classes.<br></p><p>There are design techniques that would require additional boilerplate if we cannot have non-open, non-final classes.  <br></p><p>Most importantly, requiring library authors to choose `public` or `open` provides important documentation value.  Users of the library will know whether the author intends to support subclasses or not.  The second design requires the use of comments and / or documentation to communicate this information.  I prefer important semantic considerations like this to be encoded in the language itself.<br></p><p>I would prefer to see better language support for composition to support compositional subclasses rather than choosing the second design here.  Language support for composition could be designed to work with structs as well as classes and would encourage the use of protocols rather than class hierarchies for polymorphism.  This feels like a much Swiftier direction to me.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.  Library authors are currently locked into “open” designs unless they are able to make the design `final` and remember to do so in the initial release.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Very much so.  It seeks an optimal middle ground that keeps boilerplate to a minimum while providing explicit API contracts.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>The closest is the requirement to mark methods as `virtual` in C++ and C#.  This solution is superior in a number of ways.  A couple of items come to mind immediately:<br></p><p>1. It avoids boilerplate within a module allowing for easy rapid prototyping and evolution of a design within a module.<br>2. It requires an explicit choice to be made when publishing an API which means that a library author can’t accidentally “forget” to include the `open` modifier if that is their intent.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth participation in many of the discussion threads and the initial review thread as well as in-depth study of all relevant proposals.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July 21, 2016 at 08:00:00pm</p></header><div class="content"><p>On 21.07.2016 18:33, Chris Lattner via swift-evolution wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access and public overridability&quot; begins now and runs through July 25. The proposal is available here:<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>+1 for *second* approach because :<br></p><p>* Simple mental model. It is adding `open` keyword for methods only. It is <br>very easy to understand/remember just one *new* rule : only `open` <br>methods/props could be overridden outside of the module. Easy to describe <br>this to anyone new in Swift.<br>* More flexible. You still can subclass the `public` class. But you can&#39;t <br>&quot;hurt&quot; the logic inside the module while you can have additional state and <br>methods in new class for your own logic. So IMO second approach fixes the <br>exact reason why we have this proposal *without* adding unnecessary <br>limitations and additional complexity.<br>* As I understand, for second approach there is no this IMO strange <br>limitation : &quot;The superclass of an open class must be open.&quot; (while yes, <br>this still exists: &quot;The overridden declaration of an open override must be <br>open.&quot;)<br>* I feel this approach more Swifty - free to subclass if you want for your <br>logic but safe for internal module&#39;s logic.<br>* &#39;open class&#39; adds complexity to access model, given we already have <br>public, internal, private, fileprivate<br>* Second approach unifies the syntax : structs and classes will have the <br>same syntax for public declaration (only difference : classes can have <br>&#39;open&#39; for methods/props)<br></p><p>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;<br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 21, 2016 at 10:00:00am</p></header><div class="content"><p>What is your evaluation of the proposal?<br>I think the philosophical direction of the proposal is good, though I still don’t like the actual implementation details. There are two concepts here:<br>the ability to subclass<br>the ability to override members<br></p><p>Having both of these concepts annotated with `open` is confusing as they do different things. Marking a class as open does **not** provide the ability to override. However, marking a member as `open` would provide the ability to override. These are two related but different concepts.<br></p><p>I see no reason why `virtual` should not be used to mark members that are inheritable and overridable. That concept is what is taught in schools, that concept is what is easily searchable, and that term is well known in the computer science field for this very concept. Just do a Google search between “open function” and “virtual function”. Deviating from this seems to be counter to one of Swift goals of being approachable. Having to learn `open` here is just mental noise that makes the coder have to think, “right… this is just a virtual method”.<br></p><p>To me, the better approach is:<br>change `open` to `virtual`<br>`virtual` is only allowed on inheritable and overridable members (i.e. `var`, `func`, and `subscript`)<br>`virtual` is not permitted on declarations that are explicitly `final` or `dynamic`. (Note that it&#39;s okay if one or both of the modifiers are implicitly inferred.)<br>A class is made inheritable outside of the module the **only** when the class is marked as both `public` and one or members are marked as `virtual` <br></p><p>Lastly, it’s almost certainly a bug in your code if you mark a member as `open` on your public class but forget to annotate your class also with `open`. Worse, this error will **only** be caught if you attempt to use this type **outside** the context of tests because `@testable` will grant your module the `open` class state because `@testable` is special.<br></p><p>The only scenario that this change doesn’t allow would be the ability to subclass a class that has no virtual members. In my opinion, this scenario is better handled via extensions anyway.<br></p><p>However, **if** this scenario really was desirable, this could later be added by allowing `virtual` (or `inheritable` or `open`...) on a class definition. However, I would still make the argument that once you have a `virtual` member on a type, that the class is implicitly marked as `virtual` as well (see reasoning above).<br></p><p>Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes<br></p><p>Does this proposal fit well with the feel and direction of Swift?<br>Yes<br></p><p>If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Yes, many. This proposal’s philosophical direction is more resilient by default.<br></p><p>How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>I’ve read the posts, thought about it, experimented, blogged about it.<br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/bb501468/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>July 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;<br>&gt; *What is your evaluation of the proposal?*<br></p><p><br>Strong +1 to either design, and neutral between them.<br></p><p>In the prior review I advocated that `open` should *only* apply to classes,<br>not members. This new proposal turns that on its head and is *vastly<br>superior*. Tagging open members with *just* the word `open`, eliding<br>`public` entirely, is a phenomenal improvement.<br></p><p>Kudos to the core team both for crafting this solution, and more<br>importantly for conducting the (lengthy!) review process with such aplomb.<br>It would have been easy (and tempting!) to end the first review by<br>“accepting with revision”, leaving us with needless boilerplate and a<br>suboptimal design. By instead inviting the community to bikeshed a second<br>time *with the constraint that `sealed` would be the default*, and then<br>meeting afterward to thoroughly discuss the possibilities, the core team<br>has truly demonstrated how an *ahem* open, public design process ought to<br>be carried out.<br></p><p><br>*Is the problem being addressed significant enough to warrant a change to<br>&gt; Swift?*<br></p><p><br>Honestly I am not in a position to say.<br></p><p><br>*Does this proposal fit well with the feel and direction of Swift?*<br></p><p><br>Well, the one aspect I am not sure about is, “A class member that overrides<br>an open class member must be explicitly declared open unless it is<br>explicitly final or it is a member of a final or non-public class. In any<br>case, it is considered open.”<br></p><p>This seems like an unnecessary restriction. Perhaps I want to override an<br>`open` member with a `public` one. As in,<br></p><p>open class Base { open var x: Int { return 6 } }<br>open class Sub: Base { public var x: Int { return 7 } }<br>open class Grand: Sub { final var x: Int { return 8 } }<br></p><p>Note that “Sub” might be defined in a separate module from “Base”, a module<br>that wants to publish Sub and Grand without letting its own clients<br>override `x` from them.<br></p><p><br>*If you have used other languages or libraries with a similar feature, how<br>&gt; do you feel that this proposal compares to those?*<br></p><p><br>Only languages with run-of-the-mill access control, nothing like this!<br></p><p><br>*How much effort did you put into your review? A glance, a quick reading,<br>&gt; or an in-depth study?*<br></p><p><br>I read all messages in the previous draft and review threads, and the<br>entire new proposal except for the 8-paragraph, 886-word “Motivation”<br>section. Seriously, that is 3½ pages of motivation!<br></p><p>Nevin<br></p><p><br>On Thu, Jul 21, 2016 at 11:33 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access<br>&gt; and public overridability&quot; begins now and runs through July 25. The<br>&gt; proposal is available here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160721/1ac6d906/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>On 21 July 2016 at 12:33, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt;<br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access and public overridability&quot; begins now and runs through July 25. The proposal is available here:<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br></p><p>I like the design with open and have no issues with it implicitly<br>meaning public. After a little confabulation I also believe the<br>original intent can be achieved by allowing subclassing to be open and<br>method overriding to be sealed by default, thus providing ground for<br>composition with no replacing of behaviour as exemplified in the<br>proposal, so I have no issues with it as long as methods are sealed by<br>default.<br></p><p>As for the openness of overriden methods, I still believe there should<br>be a way other than final to reseal the method. Sure there are means<br>to implement the same without it but not as elegantly IMO.<br></p><p>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I&#39;ve read the proposal and discussed the issue a lot on the threads.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>July 21, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br>+1 as before but for the first implementation. <br></p><p>I want to like implementation 2 but I really don’t see the need for it because extensions. <br></p><p>The only reason for 2 is if the core team thinks that we will never get stored properties can be added via extensions. <br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>n/1<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>reviewed the last two iterations.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ecdb231117dda838340bfcbb8873d28e?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Paul Cantrell</string> &lt;cantrell at pobox.com&gt;<p>July 21, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; • What is your evaluation of the proposal?<br></p><p>Breaking it down in parts:<br></p><p>+1 to the basic principle of making the external subclassing a conscious, explicit API design decision.<br></p><p>+1 to providing a design state for subclassability that leaves the most room for non-breaking future changes. Those who think about API design know that allowing subclassing is a non-retractable promise, but the fact that “final” will _also_ be non-retractible in Swift when we have ABI stability is a slam-dunk argument for the existence of “open.”<br></p><p>+1 to the word “open.” I went back and forth on this a little, pondering “subclassable,” “overridable,” etc., but those terms are misleading: they imply “not final,” and don’t capture the fact that module boundaries are an important ingredient of the concept at hand here.<br></p><p>-1 to “open” implying “public.” I continue to feel that I want to see the word “public” on every element that is part of my public API. I don’t mind “public open,” and the rationale in the Alternatives section didn’t sway me. However, I don’t consider this point a dealbreaker, and am still in favor of this proposal overall.<br></p><p>Without having a very strong feeling about it, I’m in favor of the “first design,” i.e. the existence of non-open, non-final classes. It’s the less surprising model, somehow. I also like the idea of a library being able to make assumptions about a closed set of subtypes, just as enums allow assumptions about a closed set of values. (A future construct could even apply enum-like code path analysis when switching on a supertype with a known set of subtypes.)<br></p><p>Despite that, I would accept the second design (no such thing as “open class”) if it consensus favored it.<br></p><p>&gt; • Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. It would be on good API design principles alone, but the coming ABI stability problems around final, at least in my dim understanding of them, makes this crucial.<br></p><p>&gt; • Does this proposal fit well with the feel and direction of Swift?<br></p><p>It does.<br></p><p>Swift favors making consequential design decisions explicit, and “non-final by default” currently breaks with that principle.<br></p><p>“Subclassable within a module by default” is consistent with Swift’s “internal by default” attitude.<br></p><p>&gt; • If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Other languages have solved these same API design concerns with “final by default.” I prefer this alternative.<br></p><p>&gt; • How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve loosely followed the conversation from the beginning, though I confess I did not count every sling and arrow in the long message threads.<br></p><p>Cheers,<br></p><p>Paul<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 22, 2016 at 09:00:00am</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br></p><p>- What is your evaluation of the proposal?<br></p><p>+1 to the second proposal, if we were to drop the concept of a final class. I feel like by blocking subclasses in preference to extensions, we would need to be 100% sure we could add stored properties in extensions, otherwise adding a stored property would require a subclass. I think that final fully on a class tends to be superfluous if we have final and/or open on methods. This would allow for composition with little penalty for optimisations.<br></p><p>If we have final classes as a whole, I recommend we go with option 1.<br></p><p>I personally prefer Option #2. I think that a lot of us are going “that’s not swifty” and using that as a justification. Lets be honest, we’re deliberately limiting ourselves here against composition via subclassing, without writing lots of frameworks and libraries where this would directly impact us and we’d learn our lessons. Why block composition via subclassing? Opinion, based on “this can all be done by extensions and that feels swifty”. Well it currently can’t be done via extensions. Perhaps we should be more open about this and allow users to choose their composition methodology… I feel like we’re blocking something unnecessarily.<br></p><p>Blocking all the members of a class can still be done, but we could theoretically allow composition on classes that are otherwise final or sealed. Why not?<br></p><p>I love the concept of clear subclassing with “Open” as an extension of the access level, showing public *and* subclassable. This is actually how I assumed this would work in the first place.<br></p><p>- Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes<br></p><p>- Does this proposal fit well with the feel and direction of Swift?<br>Yes. I think Option 2 however slightly changes that direction, and I think that’s a good thing.<br></p><p>- If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>N/A<br></p><p>- How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Continued interest in the discussion. Thorough read.<br></p><p><br>-Rod<br></p><p><br></p><p>&gt; On 22 Jul 2016, at 1:33 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access and public overridability&quot; begins now and runs through July 25. The proposal is available here:<br>&gt; <br>&gt; 	<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July 22, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br></p><p>I&#39;m not entirely decided, but I think Option 2 is marginally better:<br>• As long as every member is closed by default, there is benefit to other modules being able to add storage through subclassing, which may never be matched by extensions.<br>• Knowing every subclass at compile time is possible no matter the default, although I understand the default could influence the direction of the language.<br></p><p>I would guess that most users of ‘final’ use it to ensure the behaviour of every instance of a class is consistent (rather than for the compile-time knowledge that there are no subclasses, or for the small performance gain). This only requires making every member final, something currently not possible to enforce automatically, but would be much easier to enforce for new classes with this proposal.<br></p><p>Option 1 finalises all members by default, but conflates it with the ability to subclass in general, preventing additive subclasses. Option 2 finalises all members by default, but makes an exception for inherited members.<br></p><p>Both options make preserving the openness of inherited members the default for open classes, which in my opinion is dangerous, since subclasses may make assumptions about their behaviour that the superclass did not. If preserving openness of inherited members is to be standard, we at least need a way to opt-out, something like ‘final(members)’, to still allow for additive subclassing. I&#39;d prefer an opt-in solution.<br></p><p>In terms of practical benefit, Option 1 offers very little over Option 2 by making classes closed by default, since overrideability of members is opt-in. Most libraries I&#39;ve tried make their own class heirachies from scratch.<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>I&#39;ve never had any problem with the current system, and this does risk adding a lot of complexity for only a minor gain in safety, but I support the idea in principle.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Having open be an alternative to public seems better than the previous revisions. Beyond that, it&#39;s hard to say.<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Most languages I&#39;ve tried use an equivalent of final. This seems complicated in comparison, even with the revisions.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading through the proposal.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c72bd3ba434ad651a5d8d3d79f2d4c49?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Scott James Remnant</string> &lt;scott at netsplit.com&gt;<p>July 24, 2016 at 02:00:00pm</p></header><div class="content"><p>-1<br></p><p>This proposal is starting to go around in circles, and now re-includes various parts of the first version of this proposal which I objected to in that review thread on grounds of lack of clarity.<br></p><p>I don’t think this is making the language better at this point, it feels like this is being rushed to get “something in for Swift 3 at all costs.”<br></p><p>I have no objection to the fundamental concept of the proposal, but this should not come at the cost of the language, just on the grounds of the timeline. I think it would be better for this to be re-proposed without the rush for future versions of Swift - especially since it’s “additive.”<br></p><p>Scott<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/db6fd092e9f314aa7d66a4c6651e0e89?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Dmitriy Y. Volkov</string> &lt;volkovd90 at gmail.com&gt;<p>July 25, 2016 at 01:00:00pm</p></header><div class="content"><p>-1 to add this proposal for Swift 3.0<br></p><p>I’ve been reading mailing list for the last two reviews of this proposal and discussion turned from “We shouldn’t add this at all” - which was kind of justified  to “How actually will it interops with other swift features” - which still has a lot of questions of how exactly this modifiers will play out with other accessibility modifiers, and it seems like there is still no single answer. As Scott said, I have the same feeling that this proposal is being rushed to be accepted before the changed to Swift 3 are locked, and this won’t do any good to its semantics.<br></p><p>Perhaps, core team can write out their thoughts on how this addition to language will fit with all the current class modifiers (final, dynamic etc)? I think it might be accepted during the Swift 3.x phase, when all the edge cases will be thought out, made non-default and then enabled to its full force in Swift 4.0?<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f6b7154fd1d6a470d0b521a2e484bffc?s=50"></div><header><strong>[swift-evolution-announce] [Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Daniel Duan</string> &lt;daniel at duan.org&gt;<p>July 25, 2016 at 12:00:00am</p></header><div class="content"><p>* What is your evaluation of the proposal?<br>+1 for option 1.<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes, accidental or thoughtless exposure of non-final classes from 3rd party libraries are something worth addressing.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br>Yes. Having the privilege of working on a mature, pure Swift app, I can say that both code reuse and polymorphism can and should be better achieved without class inheritance (or classes at all, most of the time).<br></p><p>As alluded in the motivation section of the proposal, a third party Swift library down the line would mostly provide struct/enum types for users. Classes may be included to provide objects with reference semantics, these would be marked final by a responsible author today. And then, we have rare cases where inheritance is intended to provide customization and code reuse. The change in this proposal is sensible both for responsible library authors (who would stop worrying about missing `final`s), and for sloppy authors (who now are forced think about the interface of the library more). Ultimately, we&#39;ll get better libraries (to an extent) and happier users.<br></p><p>That&#39;s a direction I&#39;d like Swift to go.<br></p><p>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>No.<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Read all 3 versions and all discussions on this list. Also followed a lot of related threads on Twitter. Had quite a few discussions of it with ppl smarter than me IRL.<br></p><p>Sent from my iPad<br></p><p>&gt; On Jul 21, 2016, at 8:33 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/b67f0f46/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15ed660cd9d971062f9dd5084932a698?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>David Rönnqvist</string> &lt;david.ronnqvist at gmail.com&gt;<p>July 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 <br>In its third revision I like this proposal more. I think “open” is a good keyword for both members and classes. <br>I’m in favor of the first design for open classes. That said, I also acknowledge that subclassing without overriding anything doesn’t suffer from the problems that overriding members do. Additionally, even for a sealed class, new methods could be added thought extensions. This means the the benefits of the first design over the second one are fairly small. However, in my experience (which might be wrong), designing a class for subclassing without any overridable methods is quite uncommon, and in the first design can easily be resolved by making it open. I see it as a benefit of the first design that it allows for this distinction (a class can be make public without being subclassable).<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. <br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. <br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I’ve encountered virtual functions in C++ but only to a small extent.<br></p><p>I like this solution better because it makes the distinction between internally and externally overridable (and gets out of the way for internal overrides).<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Read the proposal and much of the discussion (but not all, there’s been so much 😉)<br></p><p>- David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160725/7672df3d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July 25, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On Jul 21, 2016, at 8:33 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Of the designs offered, I prefer #1, because:<br></p><p>1. I&#39;m not convinced that there&#39;s actually any sense in subclassing a class with no open members; it seems to me that any class intended to be used like this ought to be redesigned to use composition instead of subclassing.<br></p><p>2. I also think that you&#39;re still effectively depending on implementation details about the instance&#39;s lifecycle. Suppose I write a database library which has a Record class. It supports uniquing—that is, a single database record is never represented by two different Record instances. If the last external reference to a Record disappears, does the library hold onto that Record and return it again in response to another query, or does it deallocate it and create a new one? That barely matters *unless* you&#39;ve subclassed Record.<br></p><p>3. Even if there are no overrides, the class and the library around it probably still need to be designed for subclassing. Take the Record example from the previous point: the library will never use your subclass unless there&#39;s some hook for telling it which subclass to use. Subclassing isn&#39;t going to actually work right if the library doesn&#39;t expect any subclasses.<br></p><p>4. Even leaving that aside, you may still foisting surprising memory characteristics on the library. For instance, you might hang a large object graph off an instance that&#39;s intended to be lightweight, or create a retain cycle the library author took great pains to avoid.<br></p><p>5. Finally, this doesn&#39;t help with the stated goal of allowing you to make a class `final` in a later version of the library.<br></p><p>However, I&#39;m actually strongly in favor of Garth Snyder&#39;s call for `open` to explicitly become an access level. In design #1, it almost is already; making it official would simplify many aspects of this design.<br></p><p>(If we do take that road, I would further suggest requiring protocols to be marked `open` instead of `public`. I can easily imagine having closed `public` protocols which are visible but can&#39;t be conformed to; this would help with certain typing problems, such as `CKRecordValue`. On the other hand, if `public` were conformable from outside, I can&#39;t think of a use for marking a protocol `open`.<br></p><p>Protocol extension members should continue to be marked `public`. I could imagine `open` being added later, meaning that the member should be added as a protocol requirement so a specialized implementation can be provided; this would avoid the current boilerplate for defaulted protocol members.)<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I put a little bit less effort into this review than I did into the previous two reviews, the many discussion threads on this topic, or several months of thinking this over and changing my mind about the idea as the plan evolved.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July 25, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Jul 25, 2016, at 6:38 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Jul 21, 2016, at 8:33 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; Of the designs offered, I prefer #1, because:<br>&gt; <br>&gt; 1. I&#39;m not convinced that there&#39;s actually any sense in subclassing a class with no open members; it seems to me that any class intended to be used like this ought to be redesigned to use composition instead of subclassing.<br>&gt; <br>&gt; 2. I also think that you&#39;re still effectively depending on implementation details about the instance&#39;s lifecycle. Suppose I write a database library which has a Record class. It supports uniquing—that is, a single database record is never represented by two different Record instances. If the last external reference to a Record disappears, does the library hold onto that Record and return it again in response to another query, or does it deallocate it and create a new one? That barely matters *unless* you&#39;ve subclassed Record.<br>&gt; <br>&gt; 3. Even if there are no overrides, the class and the library around it probably still need to be designed for subclassing. Take the Record example from the previous point: the library will never use your subclass unless there&#39;s some hook for telling it which subclass to use. Subclassing isn&#39;t going to actually work right if the library doesn&#39;t expect any subclasses.<br>&gt; <br>&gt; 4. Even leaving that aside, you may still foisting surprising memory characteristics on the library. For instance, you might hang a large object graph off an instance that&#39;s intended to be lightweight, or create a retain cycle the library author took great pains to avoid.<br>&gt; <br>&gt; 5. Finally, this doesn&#39;t help with the stated goal of allowing you to make a class `final` in a later version of the library.<br>&gt; <br>&gt; However, I&#39;m actually strongly in favor of Garth Snyder&#39;s call for `open` to explicitly become an access level. In design #1, it almost is already; making it official would simplify many aspects of this design.<br>&gt; <br>&gt; (If we do take that road, I would further suggest requiring protocols to be marked `open` instead of `public`. I can easily imagine having closed `public` protocols which are visible but can&#39;t be conformed to; this would help with certain typing problems, such as `CKRecordValue`. On the other hand, if `public` were conformable from outside, I can&#39;t think of a use for marking a protocol `open`.<br></p><p>I am very much interested in introducing closed protocols.  This seems like an interesting and reasonable way to approach it.  I like that it makes the choice explicit across module boundaries with no real “default” to speak of - there is no additional “burden” (boilerplate) placed on either decision.<br></p><p>&gt; <br>&gt; Protocol extension members should continue to be marked `public`. I could imagine `open` being added later, meaning that the member should be added as a protocol requirement so a specialized implementation can be provided; this would avoid the current boilerplate for defaulted protocol members.)<br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; N/A.<br>&gt; <br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I put a little bit less effort into this review than I did into the previous two reviews, the many discussion threads on this topic, or several months of thinking this over and changing my mind about the idea as the plan evolved.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f457a34009ca0638b3c1640b3b923a82?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Andre</string> &lt;pyunpyun at mac.com&gt;<p>July 26, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; 2016/07/22 0:33、Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; のメール：<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The third review of &quot;SE-0117: Allow distinguishing between public access and public overridability&quot; begins now and runs through July 25. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0117-non-public-subclassable-by-default.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 for the first design<br>(it would be nice to have stored properties on extensions if we couldn&#39;t subclass anymore as that is one of the cases that I would subclass something, or uses associated object in objc)<br></p><p>----------<br></p><p>I am totally in agreement with Garths’ most lucid and cogent &quot;reframing&quot; of this proposal:<br></p><p>All we are doing now is subdividing public into two separate sublevels, public and open. Just as public subsumes all the privileges of internal, open subsumes public.<br></p><p>Then we can just reframe the gist of it like this:<br></p><p><br>Before SE-0117<br>After  SE-0117<br></p><p>Subclassable →<br>public<br>open<br></p><p>Visible →<br>public<br>public<br>Outside Module<br>Default →<br>internal<br>internal<br>Inside Module<br></p><p>private<br>private<br></p><p><br>This is a lot less controversial and if this is what this proposal really means, I think there would be a lot less resistance to it...<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>Yes<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Kotlin w/open classes except that it limits subclassing wether inside or outside of a &#39;module&#39; (basically taking harder stance against subclassing).<br></p><p>I like swifts &quot;middle-way&quot; approach.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Been following this proposal since original discussions, participated in previous reviews, read all the emails in his discussion and toyed a bit more with kotlin to understand it&#39;s open/sealed implementation compared to this proposal, also followed a couple conversations/blogs online about this proposal.<br></p><p>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160726/0758b15d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review #3] SE-0117: Allow distinguishing between public access and public overridability</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 27, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m not sure wether the review period is actually over (or better say &quot;turned into an internal discussion&quot;, as I haven&#39;t seen a result yet ;-), but as nobody jumped onto the &quot;something more holistic&quot;-train, I used my free time at the lake for some thinking…<br></p><p>There are three degrees of freedom, which makes it hard to create a complete table, but in essence, we are talking about this matrix:<br></p><p>Subclassing allowed	Subclassing forbidden<br>Instantiation allowed	open (public)	final (public final)<br>Instantiation forbidden	abstract	internal<br></p><p>As we have two* choices for each aspect, we have four keywords — no matter if we give each combination its own name, or build combinations of them.<br>I think combinations are less appealing, because there are already established terms for all cells, but your milage may vary.<br>Swift currently has no clean separation of the concepts, so &quot;final&quot; is actually &quot;public final&quot;.<br>The matrix contains &quot;abstract&quot;, and if you put the preoccupation of &quot;everything should be done with protocols!&quot; away, I guess you&#39;ll recognize the beauty of symmetry which is disturbed because one modifier is missing (I guess no one argues that we need something like abstract — it is just about how it can be expressed).<br></p><p>This simple table could be everything that is needed… if Swift had only a separation between modules (and as it has been decided to increase the number of levels, that simplification doesn&#39;t seem realistic).<br></p><p>So, we have an impressive number of four access levels, and it starts getting complicated to deal with 16 different keywords… but there is already a well-known alternative to model access rights based on the status of the accessor:<br>File rights in UNIX.<br>This system can be operated in a way that I wouldn&#39;t recommend for a programming language (&quot;func 755 foo()&quot; anyone?), but also in a more explicit form (&quot;group=rwx&quot;…).<br>The second variant could be adopted for Swift, and that is where it&#39;s getting really complicated, because syntax like &quot;module=subclass, public+call func foo()&quot; most likely isn&#39;t &quot;swifty&quot; as well… <br></p><p>None the less, this model would bring true orthogonality, and establish a clean separation of concerns.<br></p><p>- Tino<br></p><p>* properties left aside<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160727/645285ad/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
