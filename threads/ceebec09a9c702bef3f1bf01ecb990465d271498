<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>Why do open_existential instructions use a unique type per call site?</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>February 18, 2016 at 09:00:00am</p></header><div class="content"><p>Hi, <br></p><p>I am looking into a performance issue that Mark Lacey identified yesterday. He pointed out that the implementation of calls that go through protocols could be optimized by CSE-ing the method lookup. Before each call we emit code for loading the pointer of the witness table from the existential container, and then we perform another lookup in the witness table to find the method pointer. In some cases we can prove that the witness table is not changed by the program and we could reuse the method pointer and eliminate two loads.<br></p><p>Consider the code below:<br></p><p>protocol Pingable { func ping() }<br></p><p>func foo(x : Pingable) {<br>  x.ping()<br>  x.ping()<br>}<br></p><p>The Swift code above is translated into the abridged SIL function below:<br></p><p>sil hidden @_TF4main3fooFPS_8Pingable_T_ : $@convention(thin) (@in Pingable) -&gt; () {<br>bb0(%0 : $*Pingable):<br></p><p>// &quot;CE4&quot; call<br>  %2 = open_existential_addr %0 : $*Pingable to $*@opened(“8DF56CE4-...&quot;) Pingable<br>  %3 = witness_method $@opened(“8DF56CE4...&quot;) Pingable, #Pingable.ping!1, %2 : $*@opened(“8DF56CE4-..&quot;) Pingable :  .. <br>  %4 = apply %3&lt;@opened(“8DF56CE4-...&quot;) Pingable&gt;(%2) : … <br></p><p>// “4B4&quot; call<br>  %5 = open_existential_addr %0 : $*Pingable to $*@opened(&quot;8DF574B4-..” )Pingable<br>  %6 = witness_method $@opened(“8DF574B4...&quot;) Pingable, #Pingable.ping!1, %5 : $*@opened(&quot;8DF574B4-&quot;) Singable : …<br>  %7 = apply %6&lt;@opened(&quot;8DF574B4-&quot;) Pingable&gt;(%5) :  … <br> <br> destroy_addr %0 : $*Pingable<br>  %9 = tuple ()<br>  return %9 : $()<br>}<br></p><p>The three instructions open_existential_addr,witness_method and the apply are paired together with a unique type id. This means that the optimizer can’t replace the method pointer that was computed by the first call and use it for the second call. In the example above, we can’t use %3 for making the call in %7.  Notice that the ID of the first call ends with CE4 while the second ID ends with 4B4. <br></p><p>My question is, why are the open_existential_addr+witness_method+apply instructions tied together with a unique type?  Can we come up with a different representation that will allow us to optimize the witness method lookups?<br></p><p>Thanks<br>-Nadav<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Why do open_existential instructions use a unique type per call site?</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>February 18, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 18, 2016, at 9:46 AM, Nadav Rotem via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; Hi, <br>&gt; <br>&gt; I am looking into a performance issue that Mark Lacey identified yesterday. He pointed out that the implementation of calls that go through protocols could be optimized by CSE-ing the method lookup. Before each call we emit code for loading the pointer of the witness table from the existential container, and then we perform another lookup in the witness table to find the method pointer. In some cases we can prove that the witness table is not changed by the program and we could reuse the method pointer and eliminate two loads.<br>&gt; <br>&gt; Consider the code below:<br>&gt; <br>&gt; protocol Pingable { func ping() }<br>&gt; <br>&gt; func foo(x : Pingable) {<br>&gt;  x.ping()<br>&gt;  x.ping()<br>&gt; }<br>&gt; <br>&gt; The Swift code above is translated into the abridged SIL function below:<br>&gt; <br>&gt; sil hidden @_TF4main3fooFPS_8Pingable_T_ : $@convention(thin) (@in Pingable) -&gt; () {<br>&gt; bb0(%0 : $*Pingable):<br>&gt; <br>&gt; // &quot;CE4&quot; call<br>&gt;  %2 = open_existential_addr %0 : $*Pingable to $*@opened(“8DF56CE4-...&quot;) Pingable<br>&gt;  %3 = witness_method $@opened(“8DF56CE4...&quot;) Pingable, #Pingable.ping!1, %2 : $*@opened(“8DF56CE4-..&quot;) Pingable :  .. <br>&gt;  %4 = apply %3&lt;@opened(“8DF56CE4-...&quot;) Pingable&gt;(%2) : … <br>&gt; <br>&gt; // “4B4&quot; call<br>&gt;  %5 = open_existential_addr %0 : $*Pingable to $*@opened(&quot;8DF574B4-..” )Pingable<br>&gt;  %6 = witness_method $@opened(“8DF574B4...&quot;) Pingable, #Pingable.ping!1, %5 : $*@opened(&quot;8DF574B4-&quot;) Singable : …<br>&gt;  %7 = apply %6&lt;@opened(&quot;8DF574B4-&quot;) Pingable&gt;(%5) :  … <br>&gt; <br>&gt; destroy_addr %0 : $*Pingable<br>&gt;  %9 = tuple ()<br>&gt;  return %9 : $()<br>&gt; }<br>&gt; <br>&gt; The three instructions open_existential_addr,witness_method and the apply are paired together with a unique type id. This means that the optimizer can’t replace the method pointer that was computed by the first call and use it for the second call. In the example above, we can’t use %3 for making the call in %7.  Notice that the ID of the first call ends with CE4 while the second ID ends with 4B4. <br>&gt; <br>&gt; My question is, why are the open_existential_addr+witness_method+apply instructions tied together with a unique type?  Can we come up with a different representation that will allow us to optimize the witness method lookups?<br></p><p>It uses a unique ID because every single opening site might find a different type.  Even on a single address, we don’t know that the type hasn’t been changed between opening sites.  And representationally, we aren’t set up to do anything like have a type expressed in terms of a SIL value reference that then becomes canonically the same type as another if you CSE the value reference; our type representation expects canonical type equality to be pointer equality.<br></p><p>It should, however, be very straightforward to write a utility that clones (or rewrites) an instruction’s opened-existential uses.  The limitation there is that we don’t currently have a way to find all the occurrences of an opened existential type.  However, Mark and I were talking several weeks ago about adding implicit extra use tracking to instructions that are expressed in terms of a type other than the type of a value operand, so that, if those type(s) happen to contain opened archetypes, we can mark them as using the opening site.<br></p><p>Every instruction that has a Substitution or bare Type in its representation would have a variadic set of these extra uses, and they would be implicitly set up when creating the instruction by inspecting those types, finding the opened archetypes, and asking the SILFunction where those archetypes were introduced.  (It’s efficient to find out whether a type is expressed in terms of any opened archetypes.)<br></p><p>John.<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
