<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 28, 2016 at 02:00:00am</p></header><div class="content"><p>Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 6:28 PM, Joe Groff via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Erica Sadun via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; If you were addressing issue 2, what approach would you suggest:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Differentiating integer strides from floating point, and minimizing<br>&gt;&gt;&gt; floating point errors?<br>&gt;&gt;&gt; * Leaving the tech as-is with minimal code<br>&gt;&gt;&gt; change with a relatively high benefit?<br>&gt;&gt; <br>&gt;&gt; Arguably, floating point types shouldn&#39;t conform to Strideable at all, on<br>&gt;&gt; the general principle that genericizing arithmetic over ints and floats is<br>&gt;&gt; a trap. That would free floating point types to provide their own<br>&gt;&gt; specialized implementation of the stride methods. <br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; As if I don&#39;t already get enough grief from the C-for-loop people, now this? They&#39;ll be <br>&gt; burning semicolons on my front lawn at this rate. (And let me mention again that this<br>&gt; problem affects C-for-loop just as much as it does strides.)<br></p><p>Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>has working stride methods. If those methods are better than what they&#39;d<br>write naively, well, that&#39;s even better justification for taking the C loop<br>away. <br></p><p>&gt; <br>&gt;&gt;&gt; In both cases, I&#39;d still prefer the semantics to *go through* the end<br>&gt;&gt;&gt; point, not just stop at it, which is issue 1.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll have to defer to domain experts on this one. It seems superficially<br>&gt;&gt; appealing at least. If your only motivation is to get 1.0 through 2.0 by<br>&gt;&gt; 0.1 to include 2.0, though, that feels like weak justification to me, since<br>&gt;&gt; that&#39;s a symptom of a different problem. <br>&gt; <br>&gt; This sounds like it reduces to the following:<br>&gt; <br>&gt; 1. Leave as is, broken, requiring workarounds for nearly all floating point cases<br>&gt; <br>&gt; 2. Leave as is but remove floating point stride support, tick off<br>&gt; forloopians. Introduce floating point stride-alike,<br>&gt; which isn&#39;t terribly difficult but will need a different something since<br>&gt; `Stride` is built on `SignedNumberType`.<br>&gt; <br>&gt; 3. (This) Introduce a fix to make floating point less sucky and integers<br>&gt; more semantically fitting, with<br>&gt; minimal code change. Issue FIXME warnings during migration to warn<br>&gt; against changed semantics.<br>&gt; <br>&gt; 4. Do something else. Magic happens. Profit.<br>&gt; <br>&gt; -- E<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 27, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 7:30 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>&gt; has working stride methods. If those methods are better than what they&#39;d<br>&gt; write naively, well, that&#39;s even better justification for taking the C loop<br>&gt; away. <br></p><p>How about something like https://gist.github.com/erica/3cd5633b9e139844aa5a<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160227/d0e44ea5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>February 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 27 févr. 2016 à 21:54, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 7:30 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>&gt;&gt; has working stride methods. If those methods are better than what they&#39;d<br>&gt;&gt; write naively, well, that&#39;s even better justification for taking the C loop<br>&gt;&gt; away. <br>&gt; <br>&gt; How about something like https://gist.github.com/erica/3cd5633b9e139844aa5a &lt;https://gist.github.com/erica/3cd5633b9e139844aa5a&gt;<br>&gt; <br></p><p>This implementation with: <br>        let current = start + Double(self.iteration) * stride<br></p><p>does have the advantage of also fixing the following infinite loop (even though this example is bit silly)<br></p><p>for data in 1_000_000_000_000_000.0.stride(to:1_000_000_000_000_001.0, by:0.05)<br>{<br>    print(data)<br>}<br></p><p>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/75be6b16/attachment-0001.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 29, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Feb 27, 2016, at 6:54 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 7:30 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>&gt;&gt; has working stride methods. If those methods are better than what they&#39;d<br>&gt;&gt; write naively, well, that&#39;s even better justification for taking the C loop<br>&gt;&gt; away. <br>&gt; <br>&gt; How about something like https://gist.github.com/erica/3cd5633b9e139844aa5a &lt;https://gist.github.com/erica/3cd5633b9e139844aa5a&gt;<br>Functionally that seems reasonable. IMO it wouldn&#39;t be a problem to call the Double variant `stride(through:by:)` to match the integer form. Just for fun, you could simplify the condition here:<br></p><p>        if stride &gt; 0.0 ? current &gt;= end : current &lt;= end {<br></p><p>by using &#39;if signbit(current - end) == signbit(stride)&#39; instead.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/c2ccb0cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 4:48 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 27, 2016, at 6:54 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 27, 2016, at 7:30 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>&gt;&gt;&gt; has working stride methods. If those methods are better than what they&#39;d<br>&gt;&gt;&gt; write naively, well, that&#39;s even better justification for taking the C loop<br>&gt;&gt;&gt; away. <br>&gt;&gt; <br>&gt;&gt; How about something like https://gist.github.com/erica/3cd5633b9e139844aa5a &lt;https://gist.github.com/erica/3cd5633b9e139844aa5a&gt;<br>&gt; Functionally that seems reasonable. IMO it wouldn&#39;t be a problem to call the Double variant `stride(through:by:)` to match the integer form. Just for fun, you could simplify the condition here:<br>&gt; <br>&gt;         if stride &gt; 0.0 ? current &gt;= end : current &lt;= end {<br>&gt; <br>&gt; by using &#39;if signbit(current - end) == signbit(stride)&#39; instead.<br>&gt; <br>&gt; -Joe<br>&gt; <br></p><p>Updated proposal, including code tweak: https://gist.github.com/erica/03c398c06f6c47824429  <br></p><p>I get your point, but I&#39;m leaving this as `fstride` right now.  The proposal is *already* breaking several rules of Lattner. It&#39;s proposing not one but two distinct changes, which should probably be two separate proposals: &quot;Changing Strideable semantics&quot; and &quot;Decoupling Floating Point Strides from Generic Implementations&quot;. If decoupled, I&#39;ll recommend keeping stride name consistency. (I kind of recommend it here to, but I&#39;ll punch it more.)<br></p><p>I&#39;m about theeeeeeeesclose to separating them into those two proposals, and would like your feedback on that.<br></p><p>-- Erica<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/95f71ad6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 4:02 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 29, 2016, at 4:48 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 27, 2016, at 6:54 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 27, 2016, at 7:30 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>&gt;&gt;&gt;&gt; has working stride methods. If those methods are better than what they&#39;d<br>&gt;&gt;&gt;&gt; write naively, well, that&#39;s even better justification for taking the C loop<br>&gt;&gt;&gt;&gt; away. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How about something like https://gist.github.com/erica/3cd5633b9e139844aa5a &lt;https://gist.github.com/erica/3cd5633b9e139844aa5a&gt;<br>&gt;&gt; Functionally that seems reasonable. IMO it wouldn&#39;t be a problem to call the Double variant `stride(through:by:)` to match the integer form. Just for fun, you could simplify the condition here:<br>&gt;&gt; <br>&gt;&gt;         if stride &gt; 0.0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt; <br>&gt;&gt; by using &#39;if signbit(current - end) == signbit(stride)&#39; instead.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt; <br>&gt; Updated proposal, including code tweak: https://gist.github.com/erica/03c398c06f6c47824429 &lt;https://gist.github.com/erica/03c398c06f6c47824429&gt;  <br>&gt; <br>&gt; I get your point, but I&#39;m leaving this as `fstride` right now.  The proposal is *already* breaking several rules of Lattner. It&#39;s proposing not one but two distinct changes, which should probably be two separate proposals: &quot;Changing Strideable semantics&quot; and &quot;Decoupling Floating Point Strides from Generic Implementations&quot;. If decoupled, I&#39;ll recommend keeping stride name consistency. (I kind of recommend it here to, but I&#39;ll punch it more.)<br>&gt; <br>&gt; I&#39;m about theeeeeeeesclose to separating them into those two proposals, and would like your feedback on that.<br></p><p>I agree, splitting into two proposals is a good idea.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/6521000b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Discussion] stride behavior and a little bit of a call-back to digital numbers</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Let me go ahead and do that.<br></p><p>-- E<br></p><p>&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Feb 29, 2016, at 4:02 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Feb 29, 2016, at 4:48 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 27, 2016, at 6:54 PM, Erica Sadun &lt;erica at ericasadun.com &lt;mailto:erica at ericasadun.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Feb 27, 2016, at 7:30 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Forloopians probably don&#39;t care whether Float is Strideable, as long as it<br>&gt;&gt;&gt;&gt;&gt; has working stride methods. If those methods are better than what they&#39;d<br>&gt;&gt;&gt;&gt;&gt; write naively, well, that&#39;s even better justification for taking the C loop<br>&gt;&gt;&gt;&gt;&gt; away. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; How about something like https://gist.github.com/erica/3cd5633b9e139844aa5a &lt;https://gist.github.com/erica/3cd5633b9e139844aa5a&gt;<br>&gt;&gt;&gt; Functionally that seems reasonable. IMO it wouldn&#39;t be a problem to call the Double variant `stride(through:by:)` to match the integer form. Just for fun, you could simplify the condition here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;         if stride &gt; 0.0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; by using &#39;if signbit(current - end) == signbit(stride)&#39; instead.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Updated proposal, including code tweak: https://gist.github.com/erica/03c398c06f6c47824429 &lt;https://gist.github.com/erica/03c398c06f6c47824429&gt;  <br>&gt;&gt; <br>&gt;&gt; I get your point, but I&#39;m leaving this as `fstride` right now.  The proposal is *already* breaking several rules of Lattner. It&#39;s proposing not one but two distinct changes, which should probably be two separate proposals: &quot;Changing Strideable semantics&quot; and &quot;Decoupling Floating Point Strides from Generic Implementations&quot;. If decoupled, I&#39;ll recommend keeping stride name consistency. (I kind of recommend it here to, but I&#39;ll punch it more.)<br>&gt;&gt; <br>&gt;&gt; I&#39;m about theeeeeeeesclose to separating them into those two proposals, and would like your feedback on that.<br>&gt; <br>&gt; I agree, splitting into two proposals is a good idea.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/f7662687/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt;&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; I agree, splitting into two proposals is a good idea.<br>&gt;&gt; <br>&gt;&gt; -Joe<br></p><p>Decoupling Floating Point Strides from Generic Implementations<br></p><p>Proposal: SE-00XX<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br>Swift strides create progressions along &quot;notionally continuous one-dimensional values&quot; using a series of offset values. This proposal replaces the Swift&#39;s generic stride implementation with seperate algorithms for integer strides (the current implementation) and floating point strides.<br></p><p>This proposal was discussed on-list in the &quot;[Discussion] stride behavior and a little bit of a call-back to digital numbers&quot; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/8014&gt;thread.<br></p><p> &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#motivation&gt;Motivation<br></p><p>Strideable is genericized across both integer and floating point types. A single implementation causes floating point strides to accumulate errors through repeatedly adding by intervals. Floating point types deserve their own floating point-aware implementation that minimizes errors.<br></p><p> &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#current-art&gt;Current Art<br></p><p>A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression that is less than end.<br></p><p>A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, ... last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence.<br></p><p>While floating point calls present an extremely common use-case, they use integer-style math that accumulates errors during execution. Consider this example:<br></p><p>let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>print(zip(Array(1.0.stride(through: 2.01, by: 0.1)), ideal).map(-))<br>// prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>// 4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>// 6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16, <br>// 8.8817841970012523e-16]<br>To create an array containing values from 1.0 to 2.0, the developer must add an epsilon value to the throughargument. Otherwise the stride progression ends near 1.9. Increasing the argument from 2.0 to 2.01 is sufficient to include the end value.<br>The errors in the sequence increase over time. You see this as errors become larger towards the end of the progress. This is an artifact of the generic implementation.<br> &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#detail-design&gt;Detail Design<br></p><p>Under the current implementation, each floating point addition in a generic stride accrues errors. The following progression never reaches 2.0.<br></p><p>print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>// Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>This same issue occurs with traditional C-style for loops. This is an artifact of floating point math, and not the specific Swift statements:<br></p><p>var array: [Double] = []<br>for var i = 1.0; i &lt;= 2.0; i += 0.1 {<br>    array.append(i)<br>}<br>print(&quot;Array&quot;, array) <br>// Prints Array [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>You should not have to manually add an epsilon to force a progression to complete.<br></p><p>Floating point strides are inherently dissimilar to and should not be genericized with integer strides. I propose separate their implementation, freeing them to provide their own specialized progressions, using better numeric methods. In doing so, floating point values are no longer tied to implementations that unnecessarily accrue errors or otherwise provide less-than-ideal solutions.<br></p><p>The following example provides a rough pass at what this might look like for floating point math. I leave specific algorithm details to experts; a decimal number solution would be more appropriate. The fun<br></p><p>See: RandomAscii&#39;s write-ups on all things floating point &lt;https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition&gt;.<br></p><p>import Darwin<br></p><p>/// A `GeneratorType` for `DoubleStrideThrough`.<br>public struct DoubleStrideThroughGenerator : GeneratorType {<br>    let start: Double<br>    let end: Double<br>    let stride: Double<br>    var iteration: Int = 0<br>    var done: Bool = false<br></p><p>    public init(start: Double, end: Double, stride: Double) {<br>        (self.start, self.end, self.stride) = (start, end, stride)<br>    }<br></p><p>    /// Advance to the next element and return it, or `nil` if no next<br>    /// element exists.<br>    public mutating func next() -&gt; Double? {<br>        if done {<br>            return nil<br>        }<br>        let current = start + Double(iteration) * stride; iteration += 1<br>        if signbit(current - end) == signbit(stride) { // thanks Joe Groff<br>            if abs(current) &gt; abs(end) {<br>                done = true<br>                return current<br>            }<br>            return nil<br>        }<br>        return current<br>    }<br>}<br></p><p>public struct DoubleStrideThrough : SequenceType {<br>    let start: Double<br>    let end: Double<br>    let stride: Double<br></p><p>    /// Return a *generator* over the elements of this *sequence*.<br>    ///<br>    /// - Complexity: O(1).<br>    public func generate() -&gt; DoubleStrideThroughGenerator {<br>        return DoubleStrideThroughGenerator(<br>            start: start, end: end, stride: stride)<br>    }<br></p><p>    init(start: Double, end: Double, stride: Double) {<br>        _precondition(stride != 0, &quot;stride size must not be zero&quot;)<br>        (self.start, self.end, self.stride) = (start, end, stride)<br>    }<br></p><p>}<br></p><p>public extension Double {<br>    public func fstride(<br>        through end: Double, by stride: Double<br>        ) -&gt; DoubleStrideThrough {<br>        return DoubleStrideThrough(<br>            start: self, end: end, stride: stride)<br>    }<br>}<br>This implementation reduces floating point error by limiting accumulated additions. It uses the current Swift 2.2 through semantics (versus the revised through semantics proposed under separate cover), so it never reaches 2.0 without adding an epsilon value.<br></p><p>print(Array(1.0.fstride(through: 2.0, by: 0.1)))<br>// prints [1.0, 1.1000000000000001, 1.2, 1.3, 1.3999999999999999,<br>//         1.5, 1.6000000000000001, 1.7000000000000002, 1.8, <br>//         1.8999999999999999]<br></p><p>// versus the old style<br>print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>// prints [1.0, 1.1000000000000001, 1.2000000000000002, 1.3000000000000003, <br>//         1.4000000000000004, 1.5000000000000004, 1.6000000000000005, <br>//         1.7000000000000006, 1.8000000000000007, 1.9000000000000008]<br></p><p>print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), <br>          Array(1.0.fstride(through: 2.0, by: 0.1))).map(-))<br>// prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>//         4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>//         4.4408920985006262e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br></p><p>let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>print(zip(Array(1.0.fstride(through: 2.0, by: 0.1)), ideal).map(-))<br>print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), ideal).map(-))<br></p><p>// prints<br>// [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.2204460492503131e-16, 0.0, 0.0]<br>// [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>//  4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>//  6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br></p><p> &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#alternatives-considered&gt;Alternatives Considered<br></p><p>While precision math for decimal numbers would be better addressed by introducing a decimal type and/or warnings for at-risk floating point numbers, those features lie outside the scope of this proposal.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/bad87d6e/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February 29, 2016 at 10:00:00pm</p></header><div class="content"><p>On Mon, Feb 29, 2016 at 5:16 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Decoupling Floating Point Strides from Generic Implementations<br>&gt;<br>&gt;    - Proposal: SE-00XX<br>&gt;    - Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Swift strides create progressions along &quot;notionally continuous<br>&gt; one-dimensional values&quot; using a series of offset values. This proposal<br>&gt; replaces the Swift&#39;s generic stride implementation with seperate algorithms<br>&gt; for integer strides (the current implementation) and floating point strides.<br>&gt;<br>&lt;snip&gt;<br></p><p><br>&gt; If one were looking for a quick and dirty fix, the same kind of math used<br>&gt; in this rough solution (let value = start + count * interval) could be<br>&gt; adopted back into the current generic implementation.<br>&gt;<br></p><p>I would rather see this solution adopted.  Yes, it&#39;s inexact, but it&#39;s<br>about as exact as you can get with floating point numbers, and anyone<br>working with floating point numbers knows that you&#39;re not going to get an<br>exact decimal back.  At least it avoids accumulated errors and guarantees<br>that the proper number of values will be returned, to the limits of<br>floating point precision.<br></p><p>The problem with de-generifying Strideable is that oftentimes you may start<br>out working with integers and then find you need to change to floats to<br>accommodate a new requirement.  That could have very inconvenient ripple<br>effects if stride, arithmetic, etc. are not generic.<br></p><p>&gt;<br>&gt; &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; While precision math for decimal numbers would be better addressed by<br>&gt; introducing a decimal type and/or warnings for at-risk floating point<br>&gt; numbers, those features lie outside the scope of this proposal.<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/ff9f3114/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0089229ece6e648767cff4dc6c6d38ab?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Charles Kissinger</string> &lt;crk at akkyra.com&gt;<p>February 29, 2016 at 11:00:00pm</p></header><div class="content"><p>+1 for the improved floating point algorithm. I think I would be in favor of still calling it “stride” rather than “fstride”, but I could be persuaded otherwise.<br></p><p>There seems to be some missing text in the proposal where I’ve commented below.<br></p><p>—CK<br></p><p>&gt; On Feb 29, 2016, at 5:16 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I agree, splitting into two proposals is a good idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt; <br>&gt; Decoupling Floating Point Strides from Generic Implementations<br>&gt; <br>&gt; Proposal: SE-00XX<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Swift strides create progressions along &quot;notionally continuous one-dimensional values&quot; using a series of offset values. This proposal replaces the Swift&#39;s generic stride implementation with seperate algorithms for integer strides (the current implementation) and floating point strides.<br>&gt; <br>&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior and a little bit of a call-back to digital numbers&quot; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/8014&gt;thread.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#motivation&gt;Motivation<br>&gt; <br>&gt; Strideable is genericized across both integer and floating point types. A single implementation causes floating point strides to accumulate errors through repeatedly adding by intervals. Floating point types deserve their own floating point-aware implementation that minimizes errors.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#current-art&gt;Current Art<br>&gt; <br>&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression that is less than end.<br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, ... last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence.<br>&gt; <br>&gt; While floating point calls present an extremely common use-case, they use integer-style math that accumulates errors during execution. Consider this example:<br>&gt; <br>&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; print(zip(Array(1.0.stride(through: 2.01, by: 0.1)), ideal).map(-))<br>&gt; // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt; // 4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt; // 6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16, <br>&gt; // 8.8817841970012523e-16]<br>&gt; To create an array containing values from 1.0 to 2.0, the developer must add an epsilon value to the throughargument. Otherwise the stride progression ends near 1.9. Increasing the argument from 2.0 to 2.01 is sufficient to include the end value.<br>&gt; The errors in the sequence increase over time. You see this as errors become larger towards the end of the progress. This is an artifact of the generic implementation.<br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#detail-design&gt;Detail Design<br>&gt; <br>&gt; Under the current implementation, each floating point addition in a generic stride accrues errors. The following progression never reaches 2.0.<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; This same issue occurs with traditional C-style for loops. This is an artifact of floating point math, and not the specific Swift statements:<br>&gt; <br>&gt; var array: [Double] = []<br>&gt; for var i = 1.0; i &lt;= 2.0; i += 0.1 {<br>&gt;     array.append(i)<br>&gt; }<br>&gt; print(&quot;Array&quot;, array) <br>&gt; // Prints Array [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; You should not have to manually add an epsilon to force a progression to complete.<br>&gt; <br>&gt; Floating point strides are inherently dissimilar to and should not be genericized with integer strides. I propose separate their implementation, freeing them to provide their own specialized progressions, using better numeric methods. In doing so, floating point values are no longer tied to implementations that unnecessarily accrue errors or otherwise provide less-than-ideal solutions.<br>&gt; <br>&gt; The following example provides a rough pass at what this might look like for floating point math. I leave specific algorithm details to experts; a decimal number solution would be more appropriate. The fun<br>&gt; <br>*** What fun? ;-)<br></p><p><br>&gt; See: RandomAscii&#39;s write-ups on all things floating point &lt;https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition&gt;.<br>&gt; <br>&gt; import Darwin<br>&gt; <br>&gt; /// A `GeneratorType` for `DoubleStrideThrough`.<br>&gt; public struct DoubleStrideThroughGenerator : GeneratorType {<br>&gt;     let start: Double<br>&gt;     let end: Double<br>&gt;     let stride: Double<br>&gt;     var iteration: Int = 0<br>&gt;     var done: Bool = false<br>&gt; <br>&gt;     public init(start: Double, end: Double, stride: Double) {<br>&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;     }<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Double? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         let current = start + Double(iteration) * stride; iteration += 1<br>&gt;         if signbit(current - end) == signbit(stride) { // thanks Joe Groff<br>&gt;             if abs(current) &gt; abs(end) {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         return current<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public struct DoubleStrideThrough : SequenceType {<br>&gt;     let start: Double<br>&gt;     let end: Double<br>&gt;     let stride: Double<br>&gt; <br>&gt;     /// Return a *generator* over the elements of this *sequence*.<br>&gt;     ///<br>&gt;     /// - Complexity: O(1).<br>&gt;     public func generate() -&gt; DoubleStrideThroughGenerator {<br>&gt;         return DoubleStrideThroughGenerator(<br>&gt;             start: start, end: end, stride: stride)<br>&gt;     }<br>&gt; <br>&gt;     init(start: Double, end: Double, stride: Double) {<br>&gt;         _precondition(stride != 0, &quot;stride size must not be zero&quot;)<br>&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; public extension Double {<br>&gt;     public func fstride(<br>&gt;         through end: Double, by stride: Double<br>&gt;         ) -&gt; DoubleStrideThrough {<br>&gt;         return DoubleStrideThrough(<br>&gt;             start: self, end: end, stride: stride)<br>&gt;     }<br>&gt; }<br>&gt; This implementation reduces floating point error by limiting accumulated additions. It uses the current Swift 2.2 through semantics (versus the revised through semantics proposed under separate cover), so it never reaches 2.0 without adding an epsilon value.<br>&gt; <br>&gt; print(Array(1.0.fstride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1000000000000001, 1.2, 1.3, 1.3999999999999999,<br>&gt; //         1.5, 1.6000000000000001, 1.7000000000000002, 1.8, <br>&gt; //         1.8999999999999999]<br>&gt; <br>&gt; // versus the old style<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1000000000000001, 1.2000000000000002, 1.3000000000000003, <br>&gt; //         1.4000000000000004, 1.5000000000000004, 1.6000000000000005, <br>&gt; //         1.7000000000000006, 1.8000000000000007, 1.9000000000000008]<br>&gt; <br>&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), <br>&gt;           Array(1.0.fstride(through: 2.0, by: 0.1))).map(-))<br>&gt; // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt; //         4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt; //         4.4408920985006262e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt; <br>&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; print(zip(Array(1.0.fstride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt; <br>&gt; // prints<br>&gt; // [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.2204460492503131e-16, 0.0, 0.0]<br>&gt; // [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt; //  4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt; //  6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt; If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; While precision math for decimal numbers would be better addressed by introducing a decimal type and/or warnings for at-risk floating point numbers, those features lie outside the scope of this proposal.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/9de63bab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 07:00:00am</p></header><div class="content"><p>It would still be called stride. I just call it fstride here because I needed to test and run it in current Swift.<br></p><p>-- E<br></p><p><br>&gt; On Mar 1, 2016, at 12:37 AM, Charles Kissinger &lt;crk at akkyra.com&gt; wrote:<br>&gt; <br>&gt; +1 for the improved floating point algorithm. I think I would be in favor of still calling it “stride” rather than “fstride”, but I could be persuaded otherwise.<br>&gt; <br>&gt; There seems to be some missing text in the proposal where I’ve commented below.<br>&gt; <br>&gt; —CK<br>&gt; <br>&gt;&gt; On Feb 29, 2016, at 5:16 PM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; I agree, splitting into two proposals is a good idea.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; Decoupling Floating Point Strides from Generic Implementations<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-00XX<br>&gt;&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Swift strides create progressions along &quot;notionally continuous one-dimensional values&quot; using a series of offset values. This proposal replaces the Swift&#39;s generic stride implementation with seperate algorithms for integer strides (the current implementation) and floating point strides.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior and a little bit of a call-back to digital numbers&quot; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/8014&gt;thread.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Strideable is genericized across both integer and floating point types. A single implementation causes floating point strides to accumulate errors through repeatedly adding by intervals. Floating point types deserve their own floating point-aware implementation that minimizes errors.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#current-art&gt;Current Art<br>&gt;&gt; <br>&gt;&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression that is less than end.<br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, ... last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence.<br>&gt;&gt; <br>&gt;&gt; While floating point calls present an extremely common use-case, they use integer-style math that accumulates errors during execution. Consider this example:<br>&gt;&gt; <br>&gt;&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt; print(zip(Array(1.0.stride(through: 2.01, by: 0.1)), ideal).map(-))<br>&gt;&gt; // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt;&gt; // 4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt;&gt; // 6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16, <br>&gt;&gt; // 8.8817841970012523e-16]<br>&gt;&gt; To create an array containing values from 1.0 to 2.0, the developer must add an epsilon value to the throughargument. Otherwise the stride progression ends near 1.9. Increasing the argument from 2.0 to 2.01 is sufficient to include the end value.<br>&gt;&gt; The errors in the sequence increase over time. You see this as errors become larger towards the end of the progress. This is an artifact of the generic implementation.<br>&gt;&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#detail-design&gt;Detail Design<br>&gt;&gt; <br>&gt;&gt; Under the current implementation, each floating point addition in a generic stride accrues errors. The following progression never reaches 2.0.<br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; // Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt; This same issue occurs with traditional C-style for loops. This is an artifact of floating point math, and not the specific Swift statements:<br>&gt;&gt; <br>&gt;&gt; var array: [Double] = []<br>&gt;&gt; for var i = 1.0; i &lt;= 2.0; i += 0.1 {<br>&gt;&gt;     array.append(i)<br>&gt;&gt; }<br>&gt;&gt; print(&quot;Array&quot;, array) <br>&gt;&gt; // Prints Array [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt; You should not have to manually add an epsilon to force a progression to complete.<br>&gt;&gt; <br>&gt;&gt; Floating point strides are inherently dissimilar to and should not be genericized with integer strides. I propose separate their implementation, freeing them to provide their own specialized progressions, using better numeric methods. In doing so, floating point values are no longer tied to implementations that unnecessarily accrue errors or otherwise provide less-than-ideal solutions.<br>&gt;&gt; <br>&gt;&gt; The following example provides a rough pass at what this might look like for floating point math. I leave specific algorithm details to experts; a decimal number solution would be more appropriate. The fun<br>&gt;&gt; <br>&gt; *** What fun? ;-)<br>&gt; <br>&gt; <br>&gt;&gt; See: RandomAscii&#39;s write-ups on all things floating point &lt;https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition&gt;.<br>&gt;&gt; <br>&gt;&gt; import Darwin<br>&gt;&gt; <br>&gt;&gt; /// A `GeneratorType` for `DoubleStrideThrough`.<br>&gt;&gt; public struct DoubleStrideThroughGenerator : GeneratorType {<br>&gt;&gt;     let start: Double<br>&gt;&gt;     let end: Double<br>&gt;&gt;     let stride: Double<br>&gt;&gt;     var iteration: Int = 0<br>&gt;&gt;     var done: Bool = false<br>&gt;&gt; <br>&gt;&gt;     public init(start: Double, end: Double, stride: Double) {<br>&gt;&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;     /// element exists.<br>&gt;&gt;     public mutating func next() -&gt; Double? {<br>&gt;&gt;         if done {<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         let current = start + Double(iteration) * stride; iteration += 1<br>&gt;&gt;         if signbit(current - end) == signbit(stride) { // thanks Joe Groff<br>&gt;&gt;             if abs(current) &gt; abs(end) {<br>&gt;&gt;                 done = true<br>&gt;&gt;                 return current<br>&gt;&gt;             }<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;         return current<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public struct DoubleStrideThrough : SequenceType {<br>&gt;&gt;     let start: Double<br>&gt;&gt;     let end: Double<br>&gt;&gt;     let stride: Double<br>&gt;&gt; <br>&gt;&gt;     /// Return a *generator* over the elements of this *sequence*.<br>&gt;&gt;     ///<br>&gt;&gt;     /// - Complexity: O(1).<br>&gt;&gt;     public func generate() -&gt; DoubleStrideThroughGenerator {<br>&gt;&gt;         return DoubleStrideThroughGenerator(<br>&gt;&gt;             start: start, end: end, stride: stride)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     init(start: Double, end: Double, stride: Double) {<br>&gt;&gt;         _precondition(stride != 0, &quot;stride size must not be zero&quot;)<br>&gt;&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public extension Double {<br>&gt;&gt;     public func fstride(<br>&gt;&gt;         through end: Double, by stride: Double<br>&gt;&gt;         ) -&gt; DoubleStrideThrough {<br>&gt;&gt;         return DoubleStrideThrough(<br>&gt;&gt;             start: self, end: end, stride: stride)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; This implementation reduces floating point error by limiting accumulated additions. It uses the current Swift 2.2 through semantics (versus the revised through semantics proposed under separate cover), so it never reaches 2.0 without adding an epsilon value.<br>&gt;&gt; <br>&gt;&gt; print(Array(1.0.fstride(through: 2.0, by: 0.1)))<br>&gt;&gt; // prints [1.0, 1.1000000000000001, 1.2, 1.3, 1.3999999999999999,<br>&gt;&gt; //         1.5, 1.6000000000000001, 1.7000000000000002, 1.8, <br>&gt;&gt; //         1.8999999999999999]<br>&gt;&gt; <br>&gt;&gt; // versus the old style<br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; // prints [1.0, 1.1000000000000001, 1.2000000000000002, 1.3000000000000003, <br>&gt;&gt; //         1.4000000000000004, 1.5000000000000004, 1.6000000000000005, <br>&gt;&gt; //         1.7000000000000006, 1.8000000000000007, 1.9000000000000008]<br>&gt;&gt; <br>&gt;&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), <br>&gt;&gt;           Array(1.0.fstride(through: 2.0, by: 0.1))).map(-))<br>&gt;&gt; // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt;&gt; //         4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt;&gt; //         4.4408920985006262e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt;&gt; <br>&gt;&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt; print(zip(Array(1.0.fstride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt;&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt;&gt; <br>&gt;&gt; // prints<br>&gt;&gt; // [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.2204460492503131e-16, 0.0, 0.0]<br>&gt;&gt; // [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt;&gt; //  4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt;&gt; //  6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt;&gt; If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#alternatives-considered&gt;Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; While precision math for decimal numbers would be better addressed by introducing a decimal type and/or warnings for at-risk floating point numbers, those features lie outside the scope of this proposal.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/f01f6713/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March  1, 2016 at 06:00:00pm</p></header><div class="content"><p>Your implementation of `fstride` is faulty, it doesn&#39;t produce the<br>`through` value. Suggest you change to:<br></p><p>public extension Double {<br></p><p>    public func doubleStride(through end: Double, by stride: Double) -&gt;<br>LazyMapCollection&lt;Range&lt;Int&gt;, Double&gt; {<br></p><p>        let limit = Int(trunc((end - self) / stride))<br></p><p>        return (0 ... limit).lazy.map { self + Double($0) * stride }<br></p><p>    }<br></p><p>}<br></p><p><br>  -- Howard.<br></p><p>On 1 March 2016 at 12:16, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; I agree, splitting into two proposals is a good idea.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; Decoupling Floating Point Strides from Generic Implementations<br>&gt;<br>&gt;    - Proposal: SE-00XX<br>&gt;    - Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt;    - Status: TBD<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt; Swift strides create progressions along &quot;notionally continuous<br>&gt; one-dimensional values&quot; using a series of offset values. This proposal<br>&gt; replaces the Swift&#39;s generic stride implementation with seperate algorithms<br>&gt; for integer strides (the current implementation) and floating point strides.<br>&gt;<br>&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior<br>&gt; and a little bit of a call-back to digital numbers&quot;<br>&gt; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/8014&gt;thread.<br>&gt; &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#motivation&gt;Motivation<br>&gt;<br>&gt; Strideable is genericized across both integer and floating point types. A<br>&gt; single implementation causes floating point strides to accumulate errors<br>&gt; through repeatedly adding by intervals. Floating point types deserve<br>&gt; their own floating point-aware implementation that minimizes errors.<br>&gt; &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#current-art&gt;Current<br>&gt; Art<br>&gt;<br>&gt; A Strideable to sequence returns the sequence of values (self, self +<br>&gt; stride, self + stride + stride, ... *last*) where *last* is the last<br>&gt; value in the progression that is less than end.<br>&gt;<br>&gt; A Strideable through sequence currently returns the sequence of values (<br>&gt; self, self + stride, self + tride + stride, ... *last*) where *last* is<br>&gt; the last value in the progression less than or equal to end. There is no<br>&gt; guarantee that end is an element of the sequence.<br>&gt;<br>&gt; While floating point calls present an extremely common use-case, they use<br>&gt; integer-style math that accumulates errors during execution. Consider this<br>&gt; example:<br>&gt;<br>&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]print(zip(Array(1.0.stride(through: 2.01, by: 0.1)), ideal).map(-))// prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, // 4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, // 6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16, // 8.8817841970012523e-16]<br>&gt;<br>&gt;<br>&gt;    - To create an array containing values from 1.0 to 2.0, the developer<br>&gt;    must add an epsilon value to the throughargument. Otherwise the stride<br>&gt;    progression ends near 1.9. Increasing the argument from 2.0 to 2.01 is<br>&gt;    sufficient to include the end value.<br>&gt;    - The errors in the sequence increase over time. You see this as<br>&gt;    errors become larger towards the end of the progress. This is an artifact<br>&gt;    of the generic implementation.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#detail-design&gt;Detail<br>&gt; Design<br>&gt;<br>&gt; Under the current implementation, each floating point addition in a<br>&gt; generic stride accrues errors. The following progression never reaches 2.0.<br>&gt;<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;<br>&gt; This same issue occurs with traditional C-style for loops. This is an<br>&gt; artifact of floating point math, and not the specific Swift statements:<br>&gt;<br>&gt; var array: [Double] = []<br>&gt; for var i = 1.0; i &lt;= 2.0; i += 0.1 {<br>&gt;     array.append(i)<br>&gt; }<br>&gt; print(&quot;Array&quot;, array)<br>&gt; // Prints Array [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;<br>&gt; You should not have to manually add an epsilon to force a progression to<br>&gt; complete.<br>&gt;<br>&gt; Floating point strides are inherently dissimilar to and should not be<br>&gt; genericized with integer strides. I propose separate their implementation,<br>&gt; freeing them to provide their own specialized progressions, using better<br>&gt; numeric methods. In doing so, floating point values are no longer tied to<br>&gt; implementations that unnecessarily accrue errors or otherwise provide<br>&gt; less-than-ideal solutions.<br>&gt;<br>&gt; The following example provides a rough pass at what this might look like<br>&gt; for floating point math. I leave specific algorithm details to experts; a<br>&gt; decimal number solution would be more appropriate. The fun<br>&gt;<br>&gt; See: RandomAscii&#39;s write-ups on all things floating point<br>&gt; &lt;https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition&gt;<br>&gt; .<br>&gt;<br>&gt; import Darwin<br>&gt; /// A `GeneratorType` for `DoubleStrideThrough`.public struct DoubleStrideThroughGenerator : GeneratorType {<br>&gt;     let start: Double<br>&gt;     let end: Double<br>&gt;     let stride: Double<br>&gt;     var iteration: Int = 0<br>&gt;     var done: Bool = false<br>&gt;<br>&gt;     public init(start: Double, end: Double, stride: Double) {<br>&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;     }<br>&gt;<br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Double? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         let current = start + Double(iteration) * stride; iteration += 1<br>&gt;         if signbit(current - end) == signbit(stride) { // thanks Joe Groff<br>&gt;             if abs(current) &gt; abs(end) {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         return current<br>&gt;     }<br>&gt; }<br>&gt; public struct DoubleStrideThrough : SequenceType {<br>&gt;     let start: Double<br>&gt;     let end: Double<br>&gt;     let stride: Double<br>&gt;<br>&gt;     /// Return a *generator* over the elements of this *sequence*.<br>&gt;     ///<br>&gt;     /// - Complexity: O(1).<br>&gt;     public func generate() -&gt; DoubleStrideThroughGenerator {<br>&gt;         return DoubleStrideThroughGenerator(<br>&gt;             start: start, end: end, stride: stride)<br>&gt;     }<br>&gt;<br>&gt;     init(start: Double, end: Double, stride: Double) {<br>&gt;         _precondition(stride != 0, &quot;stride size must not be zero&quot;)<br>&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;     }<br>&gt;<br>&gt; }<br>&gt; public extension Double {<br>&gt;     public func fstride(<br>&gt;         through end: Double, by stride: Double<br>&gt;         ) -&gt; DoubleStrideThrough {<br>&gt;         return DoubleStrideThrough(<br>&gt;             start: self, end: end, stride: stride)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This implementation reduces floating point error by limiting accumulated<br>&gt; additions. It uses the current Swift 2.2 through semantics (versus the<br>&gt; revised through semantics proposed under separate cover), so it never<br>&gt; reaches 2.0 without adding an epsilon value.<br>&gt;<br>&gt; print(Array(1.0.fstride(through: 2.0, by: 0.1)))// prints [1.0, 1.1000000000000001, 1.2, 1.3, 1.3999999999999999,//         1.5, 1.6000000000000001, 1.7000000000000002, 1.8, //         1.8999999999999999]<br>&gt; // versus the old styleprint(Array(1.0.stride(through: 2.0, by: 0.1)))// prints [1.0, 1.1000000000000001, 1.2000000000000002, 1.3000000000000003, //         1.4000000000000004, 1.5000000000000004, 1.6000000000000005, //         1.7000000000000006, 1.8000000000000007, 1.9000000000000008]<br>&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)),<br>&gt;           Array(1.0.fstride(through: 2.0, by: 0.1))).map(-))// prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, //         4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, //         4.4408920985006262e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]print(zip(Array(1.0.fstride(through: 2.0, by: 0.1)), ideal).map(-))print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt; // prints// [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.2204460492503131e-16, 0.0, 0.0]// [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, //  4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, //  6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt;<br>&gt; If one were looking for a quick and dirty fix, the same kind of math used<br>&gt; in this rough solution (let value = start + count * interval) could be<br>&gt; adopted back into the current generic implementation.<br>&gt;<br>&gt; &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#alternatives-considered&gt;Alternatives<br>&gt; Considered<br>&gt; While precision math for decimal numbers would be better addressed by<br>&gt; introducing a decimal type and/or warnings for at-risk floating point<br>&gt; numbers, those features lie outside the scope of this proposal.<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/b3f3a412/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 07:00:00am</p></header><div class="content"><p>It does not produce the through value because that is how strides currently work. There&#39;s a second proposal to handle the through value.<br></p><p>-- E<br></p><p><br>&gt; On Mar 1, 2016, at 12:44 AM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Your implementation of `fstride` is faulty, it doesn&#39;t produce the `through` value. Suggest you change to:<br>&gt; <br>&gt; public extension Double {<br>&gt;     public func doubleStride(through end: Double, by stride: Double) -&gt; LazyMapCollection&lt;Range&lt;Int&gt;, Double&gt; {<br>&gt;         let limit = Int(trunc((end - self) / stride))<br>&gt;         return (0 ... limit).lazy.map { self + Double($0) * stride }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 1 March 2016 at 12:16, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I agree, splitting into two proposals is a good idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt; <br>&gt; Decoupling Floating Point Strides from Generic Implementations<br>&gt; <br>&gt; Proposal: SE-00XX<br>&gt; Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Swift strides create progressions along &quot;notionally continuous one-dimensional values&quot; using a series of offset values. This proposal replaces the Swift&#39;s generic stride implementation with seperate algorithms for integer strides (the current implementation) and floating point strides.<br>&gt; <br>&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior and a little bit of a call-back to digital numbers&quot; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/8014&gt;thread.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#motivation&gt;Motivation<br>&gt; <br>&gt; Strideable is genericized across both integer and floating point types. A single implementation causes floating point strides to accumulate errors through repeatedly adding by intervals. Floating point types deserve their own floating point-aware implementation that minimizes errors.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#current-art&gt;Current Art<br>&gt; <br>&gt; A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression that is less than end.<br>&gt; <br>&gt; A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, ... last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence.<br>&gt; <br>&gt; While floating point calls present an extremely common use-case, they use integer-style math that accumulates errors during execution. Consider this example:<br>&gt; <br>&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt; print(zip(Array(1.0.stride(through: 2.01, by: 0.1)), ideal).map(-))<br>&gt; // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt; // 4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt; // 6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16, <br>&gt; // 8.8817841970012523e-16]<br>&gt; To create an array containing values from 1.0 to 2.0, the developer must add an epsilon value to the throughargument. Otherwise the stride progression ends near 1.9. Increasing the argument from 2.0 to 2.01 is sufficient to include the end value.<br>&gt; The errors in the sequence increase over time. You see this as errors become larger towards the end of the progress. This is an artifact of the generic implementation.<br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#detail-design&gt;Detail Design<br>&gt; <br>&gt; Under the current implementation, each floating point addition in a generic stride accrues errors. The following progression never reaches 2.0.<br>&gt; <br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // Prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; This same issue occurs with traditional C-style for loops. This is an artifact of floating point math, and not the specific Swift statements:<br>&gt; <br>&gt; var array: [Double] = []<br>&gt; for var i = 1.0; i &lt;= 2.0; i += 0.1 {<br>&gt;     array.append(i)<br>&gt; }<br>&gt; print(&quot;Array&quot;, array) <br>&gt; // Prints Array [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; You should not have to manually add an epsilon to force a progression to complete.<br>&gt; <br>&gt; Floating point strides are inherently dissimilar to and should not be genericized with integer strides. I propose separate their implementation, freeing them to provide their own specialized progressions, using better numeric methods. In doing so, floating point values are no longer tied to implementations that unnecessarily accrue errors or otherwise provide less-than-ideal solutions.<br>&gt; <br>&gt; The following example provides a rough pass at what this might look like for floating point math. I leave specific algorithm details to experts; a decimal number solution would be more appropriate. The fun<br>&gt; <br>&gt; See: RandomAscii&#39;s write-ups on all things floating point &lt;https://randomascii.wordpress.com/2012/02/25/comparing-floating-point-numbers-2012-edition&gt;.<br>&gt; <br>&gt; import Darwin<br>&gt; <br>&gt; /// A `GeneratorType` for `DoubleStrideThrough`.<br>&gt; public struct DoubleStrideThroughGenerator : GeneratorType {<br>&gt;     let start: Double<br>&gt;     let end: Double<br>&gt;     let stride: Double<br>&gt;     var iteration: Int = 0<br>&gt;     var done: Bool = false<br>&gt; <br>&gt;     public init(start: Double, end: Double, stride: Double) {<br>&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;     }<br>&gt; <br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Double? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         let current = start + Double(iteration) * stride; iteration += 1<br>&gt;         if signbit(current - end) == signbit(stride) { // thanks Joe Groff<br>&gt;             if abs(current) &gt; abs(end) {<br>&gt;                 done = true<br>&gt;                 return current<br>&gt;             }<br>&gt;             return nil<br>&gt;         }<br>&gt;         return current<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public struct DoubleStrideThrough : SequenceType {<br>&gt;     let start: Double<br>&gt;     let end: Double<br>&gt;     let stride: Double<br>&gt; <br>&gt;     /// Return a *generator* over the elements of this *sequence*.<br>&gt;     ///<br>&gt;     /// - Complexity: O(1).<br>&gt;     public func generate() -&gt; DoubleStrideThroughGenerator {<br>&gt;         return DoubleStrideThroughGenerator(<br>&gt;             start: start, end: end, stride: stride)<br>&gt;     }<br>&gt; <br>&gt;     init(start: Double, end: Double, stride: Double) {<br>&gt;         _precondition(stride != 0, &quot;stride size must not be zero&quot;)<br>&gt;         (self.start, self.end, self.stride) = (start, end, stride)<br>&gt;     }<br>&gt; <br>&gt; }<br>&gt; <br>&gt; public extension Double {<br>&gt;     public func fstride(<br>&gt;         through end: Double, by stride: Double<br>&gt;         ) -&gt; DoubleStrideThrough {<br>&gt;         return DoubleStrideThrough(<br>&gt;             start: self, end: end, stride: stride)<br>&gt;     }<br>&gt; }<br>&gt; This implementation reduces floating point error by limiting accumulated additions. It uses the current Swift 2.2 through semantics (versus the revised through semantics proposed under separate cover), so it never reaches 2.0 without adding an epsilon value.<br>&gt; <br>&gt; print(Array(1.0.fstride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1000000000000001, 1.2, 1.3, 1.3999999999999999,<br>&gt; //         1.5, 1.6000000000000001, 1.7000000000000002, 1.8, <br>&gt; //         1.8999999999999999]<br>&gt; <br>&gt; // versus the old style<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1000000000000001, 1.2000000000000002, 1.3000000000000003, <br>&gt; //         1.4000000000000004, 1.5000000000000004, 1.6000000000000005, <br>&gt; //         1.7000000000000006, 1.8000000000000007, 1.9000000000000008]<br>&gt; <br>&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), <br>&gt;           Array(1.0.fstride(through: 2.0, by: 0.1))).map(-))<br>&gt; // prints [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt; //         4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt; //         4.4408920985006262e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt; <br>&gt; let ideal = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt; print(zip(Array(1.0.fstride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt; print(zip(Array(1.0.stride(through: 2.0, by: 0.1)), ideal).map(-))<br>&gt; <br>&gt; // prints<br>&gt; // [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.2204460492503131e-16, 0.0, 0.0]<br>&gt; // [0.0, 0.0, 2.2204460492503131e-16, 2.2204460492503131e-16, <br>&gt; //  4.4408920985006262e-16, 4.4408920985006262e-16, 4.4408920985006262e-16, <br>&gt; //  6.6613381477509392e-16, 6.6613381477509392e-16, 8.8817841970012523e-16]<br>&gt; If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br>&gt; <br>&gt;  &lt;https://gist.github.com/erica/cf50f3dc54bb3a090933#alternatives-considered&gt;Alternatives Considered<br>&gt; <br>&gt; While precision math for decimal numbers would be better addressed by introducing a decimal type and/or warnings for at-risk floating point numbers, those features lie outside the scope of this proposal.<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/f8088cdc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>I can&#39;t remember if I responded to this yet or not, since I just added an algorithm to the proposal and am finishing tweaks.<br></p><p>Strides can progress negatively as well as positively, and ranges don&#39;t support that. <br></p><p>(0.0)...(-1.2) returns fatal error: Invalid ClosedInterval bounds (end &lt; start)<br></p><p>Take a look at the updated proposal with the more precise second algorithm.<br></p><p>-- E<br></p><p><br>&gt; On Mar 1, 2016, at 12:44 AM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; Your implementation of `fstride` is faulty, it doesn&#39;t produce the `through` value. Suggest you change to:<br>&gt; <br>&gt; public extension Double {<br>&gt;     public func doubleStride(through end: Double, by stride: Double) -&gt; LazyMapCollection&lt;Range&lt;Int&gt;, Double&gt; {<br>&gt;         let limit = Int(trunc((end - self) / stride))<br>&gt;         return (0 ... limit).lazy.map { self + Double($0) * stride }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 1 March 2016 at 12:16, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; I agree, splitting into two proposals is a good idea.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt; <br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/56e92bdd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  1, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br></p><p>I notice that `start + count * interval` would actually work with `Int`, too.<br></p><p>I wonder if we might be better off introducing a sub-protocol of `Strideable` which can advance several increments at a time:<br></p><p>	protocol RandomStrideable: Strideable {<br>		func advancedBy(n: Self.Distance, times: Int) -&gt; Self<br>	}<br>	<br>	extension RandomStrideable {<br>		func stride(to end: Self, by: Distance) -&gt; RandomStrideTo&lt;Self&gt; { ... }<br>		func stride(through end: Self, by: Distance) -&gt; RandomStrideThrough { ... }<br>	}<br></p><p>`Double` and `Int` can both conform to `RandomStrideable`; types which cannot do this (*are* there any types which cannot do this?) can conform to `Strideable`.<br></p><p>Alternatively, if we actually *prefer* the repeated-advance implementation and we&#39;re only using this multiplication-based one because we have to, `Strideable` can be the new multiplication-based protocol and `IncrementalStrideable` can be a subprotocol which supports repeated-advance.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>March  1, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; Le 1 mars 2016 à 05:56, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;&gt; If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br>&gt; <br>&gt; I notice that `start + count * interval` would actually work with `Int`, too.<br>&gt; <br>&gt; I wonder if we might be better off introducing a sub-protocol of `Strideable` which can advance several increments at a time:<br>&gt; <br>&gt; 	protocol RandomStrideable: Strideable {<br>&gt; 		func advancedBy(n: Self.Distance, times: Int) -&gt; Self<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension RandomStrideable {<br>&gt; 		func stride(to end: Self, by: Distance) -&gt; RandomStrideTo&lt;Self&gt; { ... }<br>&gt; 		func stride(through end: Self, by: Distance) -&gt; RandomStrideThrough { ... }<br>&gt; 	}<br>&gt; <br>&gt; `Double` and `Int` can both conform to `RandomStrideable`; types which cannot do this (*are* there any types which cannot do this?) can conform to `Strideable`.<br>&gt; <br>&gt; Alternatively, if we actually *prefer* the repeated-advance implementation and we&#39;re only using this multiplication-based one because we have to, `Strideable` can be the new multiplication-based protocol and `IncrementalStrideable` can be a subprotocol which supports repeated-advance.<br></p><p>I was thinking about something similar, but  as precise Strideable (direct increment ok) and impreciseStrideable (multiplicative must be used). But my main question is reversed, beside Double what other type/concept would require the multiplicative approached?<br></p><p>Dany<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>Float and CGFloat pop to mind.<br></p><p>&gt; On Mar 1, 2016, at 4:41 AM, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I was thinking about something similar, but  as precise Strideable (direct increment ok) and impreciseStrideable (multiplicative must be used). But my main question is reversed, beside Double what other type/concept would require the multiplicative approached?<br>&gt; <br>&gt; Dany<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/7061039b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Decoupling Floating Point Strides from Generic Implementations</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 3:56 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; If one were looking for a quick and dirty fix, the same kind of math used in this rough solution (let value = start + count * interval) could be adopted back into the current generic implementation.<br>&gt; <br>&gt; I notice that `start + count * interval` would actually work with `Int`, too.<br>&gt; <br>&gt; I wonder if we might be better off introducing a sub-protocol of `Strideable` which can advance several increments at a time:<br>&gt; <br>&gt; 	protocol RandomStrideable: Strideable {<br>&gt; 		func advancedBy(n: Self.Distance, times: Int) -&gt; Self<br>&gt; 	}<br>&gt; 	<br>&gt; 	extension RandomStrideable {<br>&gt; 		func stride(to end: Self, by: Distance) -&gt; RandomStrideTo&lt;Self&gt; { ... }<br>&gt; 		func stride(through end: Self, by: Distance) -&gt; RandomStrideThrough { ... }<br>&gt; 	}<br>&gt; <br>&gt; `Double` and `Int` can both conform to `RandomStrideable`; types which cannot do this (*are* there any types which cannot do this?) can conform to `Strideable`.<br>&gt; <br>&gt; Alternatively, if we actually *prefer* the repeated-advance implementation and we&#39;re only using this multiplication-based one because we have to, `Strideable` can be the new multiplication-based protocol and `IncrementalStrideable` can be a subprotocol which supports repeated-advance.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>If you adopt a better algorithm, like the one in the updated proposal (https://gist.github.com/erica/cf50f3dc54bb3a090933), <br>would it still make sense to do this? The one time set-up for the generator is &quot;expensive&quot; if run at each access this way.<br></p><p>-- Erica<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>February 29, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; I agree, splitting into two proposals is a good idea.<br>&gt; <br>&gt; -Joe<br></p><p>Conventionalizing stride semantics<br></p><p>Proposal: SE-00NN<br>Author(s): Erica Sadun &lt;http://github.com/erica&gt;<br>Status: TBD<br>Review manager: TBD<br>Swift offers two stride functions, stride(to:, by:) and stride(through:, by:). This proposal introduces a third style and renames the existing to and through styles.<br></p><p>This proposal was discussed on-list in the &quot;[Discussion] stride behavior and a little bit of a call-back to digital numbers&quot; &lt;http://article.gmane.org/gmane.comp.lang.swift.evolution/8014&gt;thread.<br></p><p> &lt;https://gist.github.com/erica/2745585a4aac442db1fc#motivation&gt;Motivation<br></p><p>Strideable&#39;s function names do not semantically match the progressions they generate. Values produced by throughdo not pass through an end point; they stop at or before that fence. For example, 1.stride(through: 10, by: 8) returns the progress (1, 9), not (1, 9, 17). Similarly, its to function values reaches its end point. 1.stride(to:4, by:1) returns 1, 2, and 3. It never makes it to 4:<br></p><p>The current Swift definition of to returns values in [start, end) and will never reach end. In other words, you will never get to end.<br>The current Swift definition of through returns values in [start, end]. It may never reach end and certainly never goes through that value.<br>Some definitions with the help of the New Oxford American Dictionary<br></p><p>Moving to a value expresses &quot;a point reached at the end of a range&quot;.<br>To pass through a value, you should move beyond &quot;the position or location of something beyond or at the far end of (an opening or an obstacle)&quot;. <br>To move towards a value is to get &quot;close or closer&quot; or &quot;getting closer to achieving (a goal)&quot;.<br> &lt;https://gist.github.com/erica/2745585a4aac442db1fc#current-art&gt;Current Art<br></p><p>A Strideable to sequence returns the sequence of values (self, self + stride, self + stride + stride, ... last) where last is the last value in the progression that is less than end.<br></p><p>A Strideable through sequence currently returns the sequence of values (self, self + stride, self + tride + stride, ... last) where last is the last value in the progression less than or equal to end. There is no guarantee that end is an element of the sequence.<br></p><p>The name of the calling function through suggests the progression will pass through the end point before stopping. It does not. The name to suggests a progression will attempt to arrive at an end point. It does not.<br></p><p> &lt;https://gist.github.com/erica/2745585a4aac442db1fc#detail-design&gt;Detail Design<br></p><p>When striding to or through a number, the behavior does not match the meaning of the word. Swift should provide three stride styles not two.<br></p><p>Style 1: [start, end) by interval<br>This style is currently called to. I propose to rename it towards as each value works towards end. The final value in the progression is less than end<br></p><p>Style 2: [start, end] by interval<br>This style is currently called through. I propose to rename it to. The progression concludes with a value that is less than or equal to end. Swift provides no guarantee that end is an element of the sequence.<br></p><p>Style 3: [start, &gt;=end] by interval<br>I propose to introduce a new style called through. The final value is guaranteed to pass through end, either by finishing on end or past end. The final value is strictly less than end + interval.<br></p><p>A Style 3 implementation works as follows:<br></p><p>/// A `Strideable through` sequence currently returns the sequence of values <br>/// (`self`, `self + stride`, `self + stride + stride`, ... *last*) where *last* <br>/// is the first value in the progression **greater than or equal to** `end`. <br>/// There is no guarantee that `end` is an element of the sequence.<br></p><p>    /// Advance to the next element and return it, or `nil` if no next<br>    /// element exists.<br>    public mutating func next() -&gt; Element? {<br>        if done {<br>            return nil<br>        }<br>        if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>            done = true<br>            return current<br>        }<br>        let result = current<br>        current = current.advancedBy(stride)<br>        return result<br>    }<br>}<br>This solution is minimally disruptive to developers, respectful to existing code bases, and introduces a more complete semantic set of progressions that better matches progression names to developer expectations. (For example, &quot;this argument says it goes through a value but it never even reaches that value&quot;.)<br></p><p>Upon adopting this change, out-of-sync strides now pass through end values:<br></p><p>// Unit stride<br>print(Array(1.stride(through: 10, by: 1))) <br>// prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], no change<br></p><p>// Old out-of-sync stride<br>print(Array(1.stride(through: 10, by: 8)))<br>// prints [1, 9]<br></p><p>// New out-of-sync stride<br>print(Array(1.stride(through: 10, by: 8)))<br>// prints[1, 9, 17]<br>There are no functional changes existing stride implementations. Only their names change.<br></p><p>print(Array(1.stride(towards: 10, by: 8))) // was `to`<br>// prints [1, 9]<br></p><p>print(Array(1.stride(to: 10, by: 8))) // was `through`<br>// prints [1, 9]<br>Although floating point arithmetic presents a separate and orthogonal challenge, its behavior changes if this proposal is implemented under the current generic system. For example, through now includes a value at (or at least close to) 2.0 instead of stopping at 1.9 due to accumulated floating point errors.<br></p><p>// Old<br>print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>// prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br></p><p>// New<br>print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>// prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br></p><p>// Old, does not pass through 1.9<br>print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>// prints [1.0, 1.25, 1.5, 1.75]<br></p><p>// New, passes through 1.9<br>print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>// prints [1.0, 1.25, 1.5, 1.75, 2.0]<br> &lt;https://gist.github.com/erica/2745585a4aac442db1fc#impact-on-existing-code&gt;Impact on Existing Code<br></p><p>Renaming two stride functions and adding a third does not change or break existing code. The Swift 3 migrator can easily update the names for the two existing styles. That said, the migrator will not find in-place workarounds like a through: 2.01 epsilon adjustment to correct for floating-point fences. By adding FIXME: notes wherever through: is found and renamed to to:, the migrator could warn against continued use without a full inspection and could offer links to information about the semantic changes.<br></p><p> &lt;https://gist.github.com/erica/2745585a4aac442db1fc#alternatives-considered&gt;Alternatives Considered<br></p><p>The only alternative at this time is &quot;no change&quot; to existing semantics.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160229/2d445049/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March  1, 2016 at 02:00:00am</p></header><div class="content"><p>It&#39;s so nice to see such care devoted to clarifying these existing<br>names. I agree with the premise that stride(to:by:) and<br>stride(through:by:) are poorly named, but I&#39;d like to make two<br>critiques of this proposal--<br></p><p>Critique 1:<br></p><p>The basic distinction between the two current stride styles is that<br>one is inclusive and the other is exclusive of the end value. I agree<br>with you that &quot;to&quot; doesn&#39;t imply an exclusive end value, but &quot;towards&quot;<br>doesn&#39;t imply that the parameter is any sort of end value at<br>all--rather, it implies just a direction (or as you quote from the<br>NOAD, getting close or closer).<br></p><p>Two implications:<br></p><p>First, if I stride from 10 towards 0 by 1, by the plain English<br>meaning of the word &quot;towards&quot;, I would expect to obtain 10, 9, 8, 7,<br>6, etc. If we simply rename stride(to:by:) to stride(towards:by:), I<br>would not get that result. By contrast, it makes sense from the<br>current name that stride(to:by:) attempts to increment using the `by`<br>parameter without considering whether the end value is greater than or<br>less than the start value; if you can&#39;t get from here &quot;to&quot; there by<br>such increments, too bad!<br></p><p>Second, if I stride from 0 towards 10 by 1 (in the English language,<br>not in Swift), I may or may not stop short of 10 itself. That is,<br>whether &quot;towards&quot; is inclusive or exclusive of the end value can&#39;t be<br>inferred from the meaning of the word; after all, if I&#39;m making<br>strides towards a goal, I do intend to reach it, or at least that&#39;s<br>what I tell people when they ask how my PhD is going...<br></p><p>Generalizing from the word &quot;towards&quot;, I don&#39;t know that any two<br>prepositions in the English language can be used unambiguously to<br>convey the distinction between inclusive and exclusive end values.<br>Although, on some additional thought--if I had to suggest a<br>preposition, perhaps &quot;until&quot; or &quot;till&quot; would be more apt than<br>&quot;towards&quot;.<br></p><p>The saving grace of &quot;to&quot; and &quot;through&quot; in the current situation is<br>that the latter seems intuitively to go further than the former, and<br>if one deduces by analogy with the range operators that one of these<br>must exclude the end value and the other include it, then the two<br>names must mean what they do today. With three stride styles and three<br>prepositions, but only two range operators, this intuition is broken,<br>while the prepositions may not get much clearer (though I must admit<br>that your proposed use of &quot;to&quot; is an improvement).<br></p><p>Critique 2:<br></p><p>The original motivation behind your twin proposals was the epsilon<br>adjustment necessary for floating point end values. Your other<br>proposal fixes an issue with accumulated errors but doesn&#39;t solve the<br>need for an epsilon adjustment. Here, you propose adding a third<br>stride style to solve that problem, along the way shuffling the naming<br>of the existing stride styles. Since you haven&#39;t presented other use<br>cases for that third stride style here, and you haven&#39;t listed<br>alternatives considered for solving the original motivating problem<br>(i.e. epsilon adjustment), let me propose one alternative:<br></p><p>Keep the naming of stride styles as-is (inapt as they may be), and for<br>floating point end values make stride(through: aNumber, by: something)<br>equivalent to stride(to: theNextLargestRepresentableNumber, by:<br>somethingPositive) or stride(to: theNextSmallestRepresentableNumber,<br>by: somethingNegative). Would that solve your original issue<br>adequately?<br></p><p>Alternatively, if there are lots of examples that can be envisioned<br>for this third stride style, would the same examples suggest perhaps<br>that `..&gt;` might be a useful third range operator?<br></p><p><br>On Mon, Feb 29, 2016 at 7:14 PM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; I agree, splitting into two proposals is a good idea.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; Conventionalizing stride semantics<br>&gt;<br>&gt; Proposal: SE-00NN<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:,<br>&gt; by:). This proposal introduces a third style and renames the existing to and<br>&gt; through styles.<br>&gt;<br>&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior and<br>&gt; a little bit of a call-back to digital numbers&quot;thread.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Strideable&#39;s function names do not semantically match the progressions they<br>&gt; generate. Values produced by throughdo not pass through an end point; they<br>&gt; stop at or before that fence. For example, 1.stride(through: 10, by: 8)<br>&gt; returns the progress (1, 9), not (1, 9, 17). Similarly, its to function<br>&gt; values reaches its end point. 1.stride(to:4, by:1) returns 1, 2, and 3. It<br>&gt; never makes it to 4:<br>&gt;<br>&gt; The current Swift definition of to returns values in [start, end) and will<br>&gt; never reach end. In other words, you will never get to end.<br>&gt; The current Swift definition of through returns values in [start, end]. It<br>&gt; may never reach end and certainly never goes through that value.<br>&gt;<br>&gt; Some definitions with the help of the New Oxford American Dictionary<br>&gt;<br>&gt; Moving to a value expresses &quot;a point reached at the end of a range&quot;.<br>&gt; To pass through a value, you should move beyond &quot;the position or location of<br>&gt; something beyond or at the far end of (an opening or an obstacle)&quot;.<br>&gt; To move towards a value is to get &quot;close or closer&quot; or &quot;getting closer to<br>&gt; achieving (a goal)&quot;.<br>&gt;<br>&gt; Current Art<br>&gt;<br>&gt; A Strideable to sequence returns the sequence of values (self, self +<br>&gt; stride, self + stride + stride, ... last) where last is the last value in<br>&gt; the progression that is less than end.<br>&gt;<br>&gt; A Strideable through sequence currently returns the sequence of values<br>&gt; (self, self + stride, self + tride + stride, ... last) where last is the<br>&gt; last value in the progression less than or equal to end. There is no<br>&gt; guarantee that end is an element of the sequence.<br>&gt;<br>&gt; The name of the calling function through suggests the progression will pass<br>&gt; through the end point before stopping. It does not. The name to suggests a<br>&gt; progression will attempt to arrive at an end point. It does not.<br>&gt;<br>&gt; Detail Design<br>&gt;<br>&gt; When striding to or through a number, the behavior does not match the<br>&gt; meaning of the word. Swift should provide three stride styles not two.<br>&gt;<br>&gt; Style 1: [start, end) by interval<br>&gt; This style is currently called to. I propose to rename it towards as each<br>&gt; value works towards end. The final value in the progression is less than end<br>&gt;<br>&gt; Style 2: [start, end] by interval<br>&gt; This style is currently called through. I propose to rename it to. The<br>&gt; progression concludes with a value that is less than or equal to end. Swift<br>&gt; provides no guarantee that end is an element of the sequence.<br>&gt;<br>&gt; Style 3: [start, &gt;=end] by interval<br>&gt; I propose to introduce a new style called through. The final value is<br>&gt; guaranteed to pass through end, either by finishing on end or past end. The<br>&gt; final value is strictly less than end + interval.<br>&gt;<br>&gt; A Style 3 implementation works as follows:<br>&gt;<br>&gt; /// A `Strideable through` sequence currently returns the sequence of values<br>&gt; /// (`self`, `self + stride`, `self + stride + stride`, ... *last*) where<br>&gt; *last*<br>&gt; /// is the first value in the progression **greater than or equal to**<br>&gt; `end`.<br>&gt; /// There is no guarantee that `end` is an element of the sequence.<br>&gt;<br>&gt;     /// Advance to the next element and return it, or `nil` if no next<br>&gt;     /// element exists.<br>&gt;     public mutating func next() -&gt; Element? {<br>&gt;         if done {<br>&gt;             return nil<br>&gt;         }<br>&gt;         if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;             done = true<br>&gt;             return current<br>&gt;         }<br>&gt;         let result = current<br>&gt;         current = current.advancedBy(stride)<br>&gt;         return result<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; This solution is minimally disruptive to developers, respectful to existing<br>&gt; code bases, and introduces a more complete semantic set of progressions that<br>&gt; better matches progression names to developer expectations. (For example,<br>&gt; &quot;this argument says it goes through a value but it never even reaches that<br>&gt; value&quot;.)<br>&gt;<br>&gt; Upon adopting this change, out-of-sync strides now pass through end values:<br>&gt;<br>&gt; // Unit stride<br>&gt; print(Array(1.stride(through: 10, by: 1)))<br>&gt; // prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], no change<br>&gt;<br>&gt; // Old out-of-sync stride<br>&gt; print(Array(1.stride(through: 10, by: 8)))<br>&gt; // prints [1, 9]<br>&gt;<br>&gt; // New out-of-sync stride<br>&gt; print(Array(1.stride(through: 10, by: 8)))<br>&gt; // prints[1, 9, 17]<br>&gt;<br>&gt; There are no functional changes existing stride implementations. Only their<br>&gt; names change.<br>&gt;<br>&gt; print(Array(1.stride(towards: 10, by: 8))) // was `to`<br>&gt; // prints [1, 9]<br>&gt;<br>&gt; print(Array(1.stride(to: 10, by: 8))) // was `through`<br>&gt; // prints [1, 9]<br>&gt;<br>&gt; Although floating point arithmetic presents a separate and orthogonal<br>&gt; challenge, its behavior changes if this proposal is implemented under the<br>&gt; current generic system. For example, through now includes a value at (or at<br>&gt; least close to) 2.0 instead of stopping at 1.9 due to accumulated floating<br>&gt; point errors.<br>&gt;<br>&gt; // Old<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;<br>&gt; // New<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;<br>&gt; // Old, does not pass through 1.9<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;<br>&gt; // New, passes through 1.9<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;<br>&gt; Impact on Existing Code<br>&gt;<br>&gt; Renaming two stride functions and adding a third does not change or break<br>&gt; existing code. The Swift 3 migrator can easily update the names for the two<br>&gt; existing styles. That said, the migrator will not find in-place workarounds<br>&gt; like a through: 2.01 epsilon adjustment to correct for floating-point<br>&gt; fences. By adding FIXME: notes wherever through: is found and renamed to<br>&gt; to:, the migrator could warn against continued use without a full inspection<br>&gt; and could offer links to information about the semantic changes.<br>&gt;<br>&gt; Alternatives Considered<br>&gt;<br>&gt; The only alternative at this time is &quot;no change&quot; to existing semantics.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>I still wonder if a better solution might involve the same syntax as ranges currently benefit from, i.e:<br></p><p>	0 ..&lt; 10 // [0, 10) with an increment of 1<br>	(0 … 10).stride(2) // [0, 10] with an increment of 2<br></p><p>The most important change is that the default type for this should be able to handle higher starting indices, e.g:<br></p><p>	(10 … 0).stride(2) // [10, 0] with a decrement of 2<br></p><p>Basically I don’t like the stride global function in the first place =)<br></p><p>The benefit of the Range syntax is that it’s clear whether the end point is inclusive or exclusive, and it’s nice and succinct. The problem right now is just that ranges have a limit on the direction they can be traversed in for things like accessing slices of collections, in which case we’ll need to make sure that these still retain the same limitation.<br></p><p>&gt; On 1 Mar 2016, at 08:54, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;s so nice to see such care devoted to clarifying these existing<br>&gt; names. I agree with the premise that stride(to:by:) and<br>&gt; stride(through:by:) are poorly named, but I&#39;d like to make two<br>&gt; critiques of this proposal--<br>&gt; <br>&gt; Critique 1:<br>&gt; <br>&gt; The basic distinction between the two current stride styles is that<br>&gt; one is inclusive and the other is exclusive of the end value. I agree<br>&gt; with you that &quot;to&quot; doesn&#39;t imply an exclusive end value, but &quot;towards&quot;<br>&gt; doesn&#39;t imply that the parameter is any sort of end value at<br>&gt; all--rather, it implies just a direction (or as you quote from the<br>&gt; NOAD, getting close or closer).<br>&gt; <br>&gt; Two implications:<br>&gt; <br>&gt; First, if I stride from 10 towards 0 by 1, by the plain English<br>&gt; meaning of the word &quot;towards&quot;, I would expect to obtain 10, 9, 8, 7,<br>&gt; 6, etc. If we simply rename stride(to:by:) to stride(towards:by:), I<br>&gt; would not get that result. By contrast, it makes sense from the<br>&gt; current name that stride(to:by:) attempts to increment using the `by`<br>&gt; parameter without considering whether the end value is greater than or<br>&gt; less than the start value; if you can&#39;t get from here &quot;to&quot; there by<br>&gt; such increments, too bad!<br>&gt; <br>&gt; Second, if I stride from 0 towards 10 by 1 (in the English language,<br>&gt; not in Swift), I may or may not stop short of 10 itself. That is,<br>&gt; whether &quot;towards&quot; is inclusive or exclusive of the end value can&#39;t be<br>&gt; inferred from the meaning of the word; after all, if I&#39;m making<br>&gt; strides towards a goal, I do intend to reach it, or at least that&#39;s<br>&gt; what I tell people when they ask how my PhD is going...<br>&gt; <br>&gt; Generalizing from the word &quot;towards&quot;, I don&#39;t know that any two<br>&gt; prepositions in the English language can be used unambiguously to<br>&gt; convey the distinction between inclusive and exclusive end values.<br>&gt; Although, on some additional thought--if I had to suggest a<br>&gt; preposition, perhaps &quot;until&quot; or &quot;till&quot; would be more apt than<br>&gt; &quot;towards&quot;.<br>&gt; <br>&gt; The saving grace of &quot;to&quot; and &quot;through&quot; in the current situation is<br>&gt; that the latter seems intuitively to go further than the former, and<br>&gt; if one deduces by analogy with the range operators that one of these<br>&gt; must exclude the end value and the other include it, then the two<br>&gt; names must mean what they do today. With three stride styles and three<br>&gt; prepositions, but only two range operators, this intuition is broken,<br>&gt; while the prepositions may not get much clearer (though I must admit<br>&gt; that your proposed use of &quot;to&quot; is an improvement).<br>&gt; <br>&gt; Critique 2:<br>&gt; <br>&gt; The original motivation behind your twin proposals was the epsilon<br>&gt; adjustment necessary for floating point end values. Your other<br>&gt; proposal fixes an issue with accumulated errors but doesn&#39;t solve the<br>&gt; need for an epsilon adjustment. Here, you propose adding a third<br>&gt; stride style to solve that problem, along the way shuffling the naming<br>&gt; of the existing stride styles. Since you haven&#39;t presented other use<br>&gt; cases for that third stride style here, and you haven&#39;t listed<br>&gt; alternatives considered for solving the original motivating problem<br>&gt; (i.e. epsilon adjustment), let me propose one alternative:<br>&gt; <br>&gt; Keep the naming of stride styles as-is (inapt as they may be), and for<br>&gt; floating point end values make stride(through: aNumber, by: something)<br>&gt; equivalent to stride(to: theNextLargestRepresentableNumber, by:<br>&gt; somethingPositive) or stride(to: theNextSmallestRepresentableNumber,<br>&gt; by: somethingNegative). Would that solve your original issue<br>&gt; adequately?<br>&gt; <br>&gt; Alternatively, if there are lots of examples that can be envisioned<br>&gt; for this third stride style, would the same examples suggest perhaps<br>&gt; that `..&gt;` might be a useful third range operator?<br>&gt; <br>&gt; <br>&gt; On Mon, Feb 29, 2016 at 7:14 PM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; I agree, splitting into two proposals is a good idea.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Conventionalizing stride semantics<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-00NN<br>&gt;&gt; Author(s): Erica Sadun<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; <br>&gt;&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:,<br>&gt;&gt; by:). This proposal introduces a third style and renames the existing to and<br>&gt;&gt; through styles.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior and<br>&gt;&gt; a little bit of a call-back to digital numbers&quot;thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Strideable&#39;s function names do not semantically match the progressions they<br>&gt;&gt; generate. Values produced by throughdo not pass through an end point; they<br>&gt;&gt; stop at or before that fence. For example, 1.stride(through: 10, by: 8)<br>&gt;&gt; returns the progress (1, 9), not (1, 9, 17). Similarly, its to function<br>&gt;&gt; values reaches its end point. 1.stride(to:4, by:1) returns 1, 2, and 3. It<br>&gt;&gt; never makes it to 4:<br>&gt;&gt; <br>&gt;&gt; The current Swift definition of to returns values in [start, end) and will<br>&gt;&gt; never reach end. In other words, you will never get to end.<br>&gt;&gt; The current Swift definition of through returns values in [start, end]. It<br>&gt;&gt; may never reach end and certainly never goes through that value.<br>&gt;&gt; <br>&gt;&gt; Some definitions with the help of the New Oxford American Dictionary<br>&gt;&gt; <br>&gt;&gt; Moving to a value expresses &quot;a point reached at the end of a range&quot;.<br>&gt;&gt; To pass through a value, you should move beyond &quot;the position or location of<br>&gt;&gt; something beyond or at the far end of (an opening or an obstacle)&quot;.<br>&gt;&gt; To move towards a value is to get &quot;close or closer&quot; or &quot;getting closer to<br>&gt;&gt; achieving (a goal)&quot;.<br>&gt;&gt; <br>&gt;&gt; Current Art<br>&gt;&gt; <br>&gt;&gt; A Strideable to sequence returns the sequence of values (self, self +<br>&gt;&gt; stride, self + stride + stride, ... last) where last is the last value in<br>&gt;&gt; the progression that is less than end.<br>&gt;&gt; <br>&gt;&gt; A Strideable through sequence currently returns the sequence of values<br>&gt;&gt; (self, self + stride, self + tride + stride, ... last) where last is the<br>&gt;&gt; last value in the progression less than or equal to end. There is no<br>&gt;&gt; guarantee that end is an element of the sequence.<br>&gt;&gt; <br>&gt;&gt; The name of the calling function through suggests the progression will pass<br>&gt;&gt; through the end point before stopping. It does not. The name to suggests a<br>&gt;&gt; progression will attempt to arrive at an end point. It does not.<br>&gt;&gt; <br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; When striding to or through a number, the behavior does not match the<br>&gt;&gt; meaning of the word. Swift should provide three stride styles not two.<br>&gt;&gt; <br>&gt;&gt; Style 1: [start, end) by interval<br>&gt;&gt; This style is currently called to. I propose to rename it towards as each<br>&gt;&gt; value works towards end. The final value in the progression is less than end<br>&gt;&gt; <br>&gt;&gt; Style 2: [start, end] by interval<br>&gt;&gt; This style is currently called through. I propose to rename it to. The<br>&gt;&gt; progression concludes with a value that is less than or equal to end. Swift<br>&gt;&gt; provides no guarantee that end is an element of the sequence.<br>&gt;&gt; <br>&gt;&gt; Style 3: [start, &gt;=end] by interval<br>&gt;&gt; I propose to introduce a new style called through. The final value is<br>&gt;&gt; guaranteed to pass through end, either by finishing on end or past end. The<br>&gt;&gt; final value is strictly less than end + interval.<br>&gt;&gt; <br>&gt;&gt; A Style 3 implementation works as follows:<br>&gt;&gt; <br>&gt;&gt; /// A `Strideable through` sequence currently returns the sequence of values<br>&gt;&gt; /// (`self`, `self + stride`, `self + stride + stride`, ... *last*) where<br>&gt;&gt; *last*<br>&gt;&gt; /// is the first value in the progression **greater than or equal to**<br>&gt;&gt; `end`.<br>&gt;&gt; /// There is no guarantee that `end` is an element of the sequence.<br>&gt;&gt; <br>&gt;&gt;    /// Advance to the next element and return it, or `nil` if no next<br>&gt;&gt;    /// element exists.<br>&gt;&gt;    public mutating func next() -&gt; Element? {<br>&gt;&gt;        if done {<br>&gt;&gt;            return nil<br>&gt;&gt;        }<br>&gt;&gt;        if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;&gt;            done = true<br>&gt;&gt;            return current<br>&gt;&gt;        }<br>&gt;&gt;        let result = current<br>&gt;&gt;        current = current.advancedBy(stride)<br>&gt;&gt;        return result<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This solution is minimally disruptive to developers, respectful to existing<br>&gt;&gt; code bases, and introduces a more complete semantic set of progressions that<br>&gt;&gt; better matches progression names to developer expectations. (For example,<br>&gt;&gt; &quot;this argument says it goes through a value but it never even reaches that<br>&gt;&gt; value&quot;.)<br>&gt;&gt; <br>&gt;&gt; Upon adopting this change, out-of-sync strides now pass through end values:<br>&gt;&gt; <br>&gt;&gt; // Unit stride<br>&gt;&gt; print(Array(1.stride(through: 10, by: 1)))<br>&gt;&gt; // prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], no change<br>&gt;&gt; <br>&gt;&gt; // Old out-of-sync stride<br>&gt;&gt; print(Array(1.stride(through: 10, by: 8)))<br>&gt;&gt; // prints [1, 9]<br>&gt;&gt; <br>&gt;&gt; // New out-of-sync stride<br>&gt;&gt; print(Array(1.stride(through: 10, by: 8)))<br>&gt;&gt; // prints[1, 9, 17]<br>&gt;&gt; <br>&gt;&gt; There are no functional changes existing stride implementations. Only their<br>&gt;&gt; names change.<br>&gt;&gt; <br>&gt;&gt; print(Array(1.stride(towards: 10, by: 8))) // was `to`<br>&gt;&gt; // prints [1, 9]<br>&gt;&gt; <br>&gt;&gt; print(Array(1.stride(to: 10, by: 8))) // was `through`<br>&gt;&gt; // prints [1, 9]<br>&gt;&gt; <br>&gt;&gt; Although floating point arithmetic presents a separate and orthogonal<br>&gt;&gt; challenge, its behavior changes if this proposal is implemented under the<br>&gt;&gt; current generic system. For example, through now includes a value at (or at<br>&gt;&gt; least close to) 2.0 instead of stopping at 1.9 due to accumulated floating<br>&gt;&gt; point errors.<br>&gt;&gt; <br>&gt;&gt; // Old<br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;&gt; <br>&gt;&gt; // New<br>&gt;&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt;&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;&gt; <br>&gt;&gt; // Old, does not pass through 1.9<br>&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;&gt; <br>&gt;&gt; // New, passes through 1.9<br>&gt;&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt;&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;&gt; <br>&gt;&gt; Impact on Existing Code<br>&gt;&gt; <br>&gt;&gt; Renaming two stride functions and adding a third does not change or break<br>&gt;&gt; existing code. The Swift 3 migrator can easily update the names for the two<br>&gt;&gt; existing styles. That said, the migrator will not find in-place workarounds<br>&gt;&gt; like a through: 2.01 epsilon adjustment to correct for floating-point<br>&gt;&gt; fences. By adding FIXME: notes wherever through: is found and renamed to<br>&gt;&gt; to:, the migrator could warn against continued use without a full inspection<br>&gt;&gt; and could offer links to information about the semantic changes.<br>&gt;&gt; <br>&gt;&gt; Alternatives Considered<br>&gt;&gt; <br>&gt;&gt; The only alternative at this time is &quot;no change&quot; to existing semantics.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/b8fef4e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>I take issue with the proposed definition of &quot;through&quot; used. When Googling<br>&quot;definition of through&quot;, the example sentence used for the definition Erica<br>provided is &quot;The approach to the church is through the gate&quot;. Doesn&#39;t sound<br>like we&#39;re discussing ranges there; sounds like location.<br></p><p>A more range-based definition that pops up is &quot;up to and including (a<br>particular point in an ordered sequence)&quot;, which sounds exactly like the<br>way &quot;through&quot; is being used today in stride. Example sentence given: &quot;They<br>will be in town from March 24 through May 7&quot;. Commonly, English speakers<br>often refer to the numbers &quot;1 through 10&quot;, which refers to [1, 10].<br></p><p>I also have a strong distaste for &quot;towards&quot;, as the ambiguity that Xiaodi<br>mentioned makes it seem like you could reach any point before 10 in the<br>range [1, 10), be it 2 all the way through 9 (notice I use &quot;through&quot; here<br>to mean [2, 9]).<br></p><p>I feel like ultimately this proposal makes the semantics of stride less<br>clear. While the naming today seems pretty obvious to me, I would<br>absolutely have to frequently refer to documentation if the proposed<br>changes were accepted. The changes proposed don&#39;t seem to match the<br>semantics of words used every day to describe ranges.<br></p><p>Thanks,<br>Seth<br>On Tue, Mar 1, 2016 at 1:00 AM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I still wonder if a better solution might involve the same syntax as<br>&gt; ranges currently benefit from, i.e:<br>&gt;<br>&gt; 0 ..&lt; 10 // [0, 10) with an increment of 1<br>&gt; (0 … 10).stride(2) // [0, 10] with an increment of 2<br>&gt;<br>&gt; The most important change is that the default type for this should be able<br>&gt; to handle higher starting indices, e.g:<br>&gt;<br>&gt; (10 … 0).stride(2) // [10, 0] with a decrement of 2<br>&gt;<br>&gt; Basically I don’t like the stride global function in the first place =)<br>&gt;<br>&gt; The benefit of the Range syntax is that it’s clear whether the end point<br>&gt; is inclusive or exclusive, and it’s nice and succinct. The problem right<br>&gt; now is just that ranges have a limit on the direction they can be traversed<br>&gt; in for things like accessing slices of collections, in which case we’ll<br>&gt; need to make sure that these still retain the same limitation.<br>&gt;<br>&gt; On 1 Mar 2016, at 08:54, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; It&#39;s so nice to see such care devoted to clarifying these existing<br>&gt; names. I agree with the premise that stride(to:by:) and<br>&gt; stride(through:by:) are poorly named, but I&#39;d like to make two<br>&gt; critiques of this proposal--<br>&gt;<br>&gt; Critique 1:<br>&gt;<br>&gt; The basic distinction between the two current stride styles is that<br>&gt; one is inclusive and the other is exclusive of the end value. I agree<br>&gt; with you that &quot;to&quot; doesn&#39;t imply an exclusive end value, but &quot;towards&quot;<br>&gt; doesn&#39;t imply that the parameter is any sort of end value at<br>&gt; all--rather, it implies just a direction (or as you quote from the<br>&gt; NOAD, getting close or closer).<br>&gt;<br>&gt; Two implications:<br>&gt;<br>&gt; First, if I stride from 10 towards 0 by 1, by the plain English<br>&gt; meaning of the word &quot;towards&quot;, I would expect to obtain 10, 9, 8, 7,<br>&gt; 6, etc. If we simply rename stride(to:by:) to stride(towards:by:), I<br>&gt; would not get that result. By contrast, it makes sense from the<br>&gt; current name that stride(to:by:) attempts to increment using the `by`<br>&gt; parameter without considering whether the end value is greater than or<br>&gt; less than the start value; if you can&#39;t get from here &quot;to&quot; there by<br>&gt; such increments, too bad!<br>&gt;<br>&gt; Second, if I stride from 0 towards 10 by 1 (in the English language,<br>&gt; not in Swift), I may or may not stop short of 10 itself. That is,<br>&gt; whether &quot;towards&quot; is inclusive or exclusive of the end value can&#39;t be<br>&gt; inferred from the meaning of the word; after all, if I&#39;m making<br>&gt; strides towards a goal, I do intend to reach it, or at least that&#39;s<br>&gt; what I tell people when they ask how my PhD is going...<br>&gt;<br>&gt; Generalizing from the word &quot;towards&quot;, I don&#39;t know that any two<br>&gt; prepositions in the English language can be used unambiguously to<br>&gt; convey the distinction between inclusive and exclusive end values.<br>&gt; Although, on some additional thought--if I had to suggest a<br>&gt; preposition, perhaps &quot;until&quot; or &quot;till&quot; would be more apt than<br>&gt; &quot;towards&quot;.<br>&gt;<br>&gt; The saving grace of &quot;to&quot; and &quot;through&quot; in the current situation is<br>&gt; that the latter seems intuitively to go further than the former, and<br>&gt; if one deduces by analogy with the range operators that one of these<br>&gt; must exclude the end value and the other include it, then the two<br>&gt; names must mean what they do today. With three stride styles and three<br>&gt; prepositions, but only two range operators, this intuition is broken,<br>&gt; while the prepositions may not get much clearer (though I must admit<br>&gt; that your proposed use of &quot;to&quot; is an improvement).<br>&gt;<br>&gt; Critique 2:<br>&gt;<br>&gt; The original motivation behind your twin proposals was the epsilon<br>&gt; adjustment necessary for floating point end values. Your other<br>&gt; proposal fixes an issue with accumulated errors but doesn&#39;t solve the<br>&gt; need for an epsilon adjustment. Here, you propose adding a third<br>&gt; stride style to solve that problem, along the way shuffling the naming<br>&gt; of the existing stride styles. Since you haven&#39;t presented other use<br>&gt; cases for that third stride style here, and you haven&#39;t listed<br>&gt; alternatives considered for solving the original motivating problem<br>&gt; (i.e. epsilon adjustment), let me propose one alternative:<br>&gt;<br>&gt; Keep the naming of stride styles as-is (inapt as they may be), and for<br>&gt; floating point end values make stride(through: aNumber, by: something)<br>&gt; equivalent to stride(to: theNextLargestRepresentableNumber, by:<br>&gt; somethingPositive) or stride(to: theNextSmallestRepresentableNumber,<br>&gt; by: somethingNegative). Would that solve your original issue<br>&gt; adequately?<br>&gt;<br>&gt; Alternatively, if there are lots of examples that can be envisioned<br>&gt; for this third stride style, would the same examples suggest perhaps<br>&gt; that `..&gt;` might be a useful third range operator?<br>&gt;<br>&gt;<br>&gt; On Mon, Feb 29, 2016 at 7:14 PM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Feb 29, 2016, at 5:03 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; I agree, splitting into two proposals is a good idea.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;<br>&gt; Conventionalizing stride semantics<br>&gt;<br>&gt; Proposal: SE-00NN<br>&gt; Author(s): Erica Sadun<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;<br>&gt; Swift offers two stride functions, stride(to:, by:) and stride(through:,<br>&gt; by:). This proposal introduces a third style and renames the existing to<br>&gt; and<br>&gt; through styles.<br>&gt;<br>&gt; This proposal was discussed on-list in the &quot;[Discussion] stride behavior<br>&gt; and<br>&gt; a little bit of a call-back to digital numbers&quot;thread.<br>&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Strideable&#39;s function names do not semantically match the progressions they<br>&gt; generate. Values produced by throughdo not pass through an end point; they<br>&gt; stop at or before that fence. For example, 1.stride(through: 10, by: 8)<br>&gt; returns the progress (1, 9), not (1, 9, 17). Similarly, its to function<br>&gt; values reaches its end point. 1.stride(to:4, by:1) returns 1, 2, and 3. It<br>&gt; never makes it to 4:<br>&gt;<br>&gt; The current Swift definition of to returns values in [start, end) and will<br>&gt; never reach end. In other words, you will never get to end.<br>&gt; The current Swift definition of through returns values in [start, end]. It<br>&gt; may never reach end and certainly never goes through that value.<br>&gt;<br>&gt; Some definitions with the help of the New Oxford American Dictionary<br>&gt;<br>&gt; Moving to a value expresses &quot;a point reached at the end of a range&quot;.<br>&gt; To pass through a value, you should move beyond &quot;the position or location<br>&gt; of<br>&gt; something beyond or at the far end of (an opening or an obstacle)&quot;.<br>&gt; To move towards a value is to get &quot;close or closer&quot; or &quot;getting closer to<br>&gt; achieving (a goal)&quot;.<br>&gt;<br>&gt; Current Art<br>&gt;<br>&gt; A Strideable to sequence returns the sequence of values (self, self +<br>&gt; stride, self + stride + stride, ... last) where last is the last value in<br>&gt; the progression that is less than end.<br>&gt;<br>&gt; A Strideable through sequence currently returns the sequence of values<br>&gt; (self, self + stride, self + tride + stride, ... last) where last is the<br>&gt; last value in the progression less than or equal to end. There is no<br>&gt; guarantee that end is an element of the sequence.<br>&gt;<br>&gt; The name of the calling function through suggests the progression will pass<br>&gt; through the end point before stopping. It does not. The name to suggests a<br>&gt; progression will attempt to arrive at an end point. It does not.<br>&gt;<br>&gt; Detail Design<br>&gt;<br>&gt; When striding to or through a number, the behavior does not match the<br>&gt; meaning of the word. Swift should provide three stride styles not two.<br>&gt;<br>&gt; Style 1: [start, end) by interval<br>&gt; This style is currently called to. I propose to rename it towards as each<br>&gt; value works towards end. The final value in the progression is less than<br>&gt; end<br>&gt;<br>&gt; Style 2: [start, end] by interval<br>&gt; This style is currently called through. I propose to rename it to. The<br>&gt; progression concludes with a value that is less than or equal to end. Swift<br>&gt; provides no guarantee that end is an element of the sequence.<br>&gt;<br>&gt; Style 3: [start, &gt;=end] by interval<br>&gt; I propose to introduce a new style called through. The final value is<br>&gt; guaranteed to pass through end, either by finishing on end or past end. The<br>&gt; final value is strictly less than end + interval.<br>&gt;<br>&gt; A Style 3 implementation works as follows:<br>&gt;<br>&gt; /// A `Strideable through` sequence currently returns the sequence of<br>&gt; values<br>&gt; /// (`self`, `self + stride`, `self + stride + stride`, ... *last*) where<br>&gt; *last*<br>&gt; /// is the first value in the progression **greater than or equal to**<br>&gt; `end`.<br>&gt; /// There is no guarantee that `end` is an element of the sequence.<br>&gt;<br>&gt;    /// Advance to the next element and return it, or `nil` if no next<br>&gt;    /// element exists.<br>&gt;    public mutating func next() -&gt; Element? {<br>&gt;        if done {<br>&gt;            return nil<br>&gt;        }<br>&gt;        if stride &gt; 0 ? current &gt;= end : current &lt;= end {<br>&gt;            done = true<br>&gt;            return current<br>&gt;        }<br>&gt;        let result = current<br>&gt;        current = current.advancedBy(stride)<br>&gt;        return result<br>&gt;    }<br>&gt; }<br>&gt;<br>&gt; This solution is minimally disruptive to developers, respectful to existing<br>&gt; code bases, and introduces a more complete semantic set of progressions<br>&gt; that<br>&gt; better matches progression names to developer expectations. (For example,<br>&gt; &quot;this argument says it goes through a value but it never even reaches that<br>&gt; value&quot;.)<br>&gt;<br>&gt; Upon adopting this change, out-of-sync strides now pass through end values:<br>&gt;<br>&gt; // Unit stride<br>&gt; print(Array(1.stride(through: 10, by: 1)))<br>&gt; // prints [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], no change<br>&gt;<br>&gt; // Old out-of-sync stride<br>&gt; print(Array(1.stride(through: 10, by: 8)))<br>&gt; // prints [1, 9]<br>&gt;<br>&gt; // New out-of-sync stride<br>&gt; print(Array(1.stride(through: 10, by: 8)))<br>&gt; // prints[1, 9, 17]<br>&gt;<br>&gt; There are no functional changes existing stride implementations. Only their<br>&gt; names change.<br>&gt;<br>&gt; print(Array(1.stride(towards: 10, by: 8))) // was `to`<br>&gt; // prints [1, 9]<br>&gt;<br>&gt; print(Array(1.stride(to: 10, by: 8))) // was `through`<br>&gt; // prints [1, 9]<br>&gt;<br>&gt; Although floating point arithmetic presents a separate and orthogonal<br>&gt; challenge, its behavior changes if this proposal is implemented under the<br>&gt; current generic system. For example, through now includes a value at (or at<br>&gt; least close to) 2.0 instead of stopping at 1.9 due to accumulated floating<br>&gt; point errors.<br>&gt;<br>&gt; // Old<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9]<br>&gt;<br>&gt; // New<br>&gt; print(Array(1.0.stride(through: 2.0, by: 0.1)))<br>&gt; // prints [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0]<br>&gt;<br>&gt; // Old, does not pass through 1.9<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75]<br>&gt;<br>&gt; // New, passes through 1.9<br>&gt; print(Array(1.0.stride(through: 1.9, by: 0.25)))<br>&gt; // prints [1.0, 1.25, 1.5, 1.75, 2.0]<br>&gt;<br>&gt; Impact on Existing Code<br>&gt;<br>&gt; Renaming two stride functions and adding a third does not change or break<br>&gt; existing code. The Swift 3 migrator can easily update the names for the two<br>&gt; existing styles. That said, the migrator will not find in-place workarounds<br>&gt; like a through: 2.01 epsilon adjustment to correct for floating-point<br>&gt; fences. By adding FIXME: notes wherever through: is found and renamed to<br>&gt; to:, the migrator could warn against continued use without a full<br>&gt; inspection<br>&gt; and could offer links to information about the semantic changes.<br>&gt;<br>&gt; Alternatives Considered<br>&gt;<br>&gt; The only alternative at this time is &quot;no change&quot; to existing semantics.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/3fc69764/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m open to other name suggestions for the three styles.<br></p><p>-- E<br></p><p><br>&gt; On Mar 1, 2016, at 2:18 AM, Seth Friedman via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I take issue with the proposed definition of &quot;through&quot; used. When Googling &quot;definition of through&quot;, the example sentence used for the definition Erica provided is &quot;The approach to the church is through the gate&quot;. Doesn&#39;t sound like we&#39;re discussing ranges there; sounds like location.<br>&gt; <br>&gt; A more range-based definition that pops up is &quot;up to and including (a particular point in an ordered sequence)&quot;, which sounds exactly like the way &quot;through&quot; is being used today in stride. Example sentence given: &quot;They will be in town from March 24 through May 7&quot;. Commonly, English speakers often refer to the numbers &quot;1 through 10&quot;, which refers to [1, 10].<br>&gt; <br>&gt; I also have a strong distaste for &quot;towards&quot;, as the ambiguity that Xiaodi mentioned makes it seem like you could reach any point before 10 in the range [1, 10), be it 2 all the way through 9 (notice I use &quot;through&quot; here to mean [2, 9]).<br>&gt; <br>&gt; I feel like ultimately this proposal makes the semantics of stride less clear. While the naming today seems pretty obvious to me, I would absolutely have to frequently refer to documentation if the proposed changes were accepted. The changes proposed don&#39;t seem to match the semantics of words used every day to describe ranges.<br>&gt; <br>&gt; Thanks,<br>&gt; Seth<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 2:00 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; I still wonder if a better solution might involve the same syntax as ranges currently benefit from, i.e:<br>&gt; <br>&gt; 	0 ..&lt; 10 // [0, 10) with an increment of 1<br>&gt; 	(0 … 10).stride(2) // [0, 10] with an increment of 2<br>&gt; <br>&gt; The most important change is that the default type for this should be able to handle higher starting indices, e.g:<br>&gt; <br>&gt; 	(10 … 0).stride(2) // [10, 0] with a decrement of 2<br>&gt; <br>&gt; Basically I don’t like the stride global function in the first place =)<br>&gt; <br>&gt; The benefit of the Range syntax is that it’s clear whether the end point is inclusive or exclusive, and it’s nice and succinct. The problem right now is just that ranges have a limit on the direction they can be traversed in for things like accessing slices of collections, in which case we’ll need to make sure that these still retain the same limitation.<br>&gt; <br></p><p>This would have to be a separate proposal to allow descending ranges. I think that would be a good addition to the language and encourage you to write it.<br></p><p>-- E<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/1c723ac9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 1:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; It&#39;s so nice to see such care devoted to clarifying these existing<br>&gt; names. I agree with the premise that stride(to:by:) and<br>&gt; stride(through:by:) are poorly named, but I&#39;d like to make two<br>&gt; critiques of this proposal--<br>&gt; <br>&gt; Critique 1:<br>&gt; <br>&gt; The basic distinction between the two current stride styles is that<br>&gt; one is inclusive and the other is exclusive of the end value. I agree<br>&gt; with you that &quot;to&quot; doesn&#39;t imply an exclusive end value, but &quot;towards&quot;<br>&gt; doesn&#39;t imply that the parameter is any sort of end value at<br>&gt; all--rather, it implies just a direction (or as you quote from the<br>&gt; NOAD, getting close or closer).<br>&gt; <br>&gt; Two implications:<br>&gt; <br>&gt; First, if I stride from 10 towards 0 by 1, by the plain English<br>&gt; meaning of the word &quot;towards&quot;, I would expect to obtain 10, 9, 8, 7,<br>&gt; 6, etc. If we simply rename stride(to:by:) to stride(towards:by:), I<br>&gt; would not get that result. By contrast, it makes sense from the<br>&gt; current name that stride(to:by:) attempts to increment using the `by`<br>&gt; parameter without considering whether the end value is greater than or<br>&gt; less than the start value; if you can&#39;t get from here &quot;to&quot; there by<br>&gt; such increments, too bad!<br></p><p>Do you want the stride to pick up the sign automatically? Instead of <br></p><p>print(Array(10.stride(to: 0, by: -1))) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], current Swift<br></p><p>have<br></p><p>print(Array(10.stride(to: 0, by: 1))) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], adjusted sign<br></p><p>Or am I missing your point of &quot;if I stride from 10 towards 0 by 1&quot;?<br></p><p><br>&gt; Second, if I stride from 0 towards 10 by 1 (in the English language,<br>&gt; not in Swift), I may or may not stop short of 10 itself. That is,<br>&gt; whether &quot;towards&quot; is inclusive or exclusive of the end value can&#39;t be<br>&gt; inferred from the meaning of the word; after all, if I&#39;m making<br>&gt; strides towards a goal, I do intend to reach it, or at least that&#39;s<br>&gt; what I tell people when they ask how my PhD is going...<br></p><p>I&#39;m searching for a word that means &quot;in the direction of but never reaching&quot;. <br></p><p>print(Array(10.stride(to: 0, by: -1))) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1], current Swift<br></p><p>This never reaches 0.<br></p><p><br>&gt; Generalizing from the word &quot;towards&quot;, I don&#39;t know that any two<br>&gt; prepositions in the English language can be used unambiguously to<br>&gt; convey the distinction between inclusive and exclusive end values.<br>&gt; Although, on some additional thought--if I had to suggest a<br>&gt; preposition, perhaps &quot;until&quot; or &quot;till&quot; would be more apt than<br>&gt; &quot;towards&quot;.<br></p><p>`until` to me suggests reaching the end-point.<br></p><p>&gt; The saving grace of &quot;to&quot; and &quot;through&quot; in the current situation is<br>&gt; that the latter seems intuitively to go further than the former,<br></p><p>Quite often, it doesn&#39;t really:<br></p><p>print(Array(1.stride(to:10, by: 8))) // [1, 9]<br>print(Array(1.stride(through:10, by: 8))) // [1, 9]<br></p><p><br>&gt; and<br>&gt; if one deduces by analogy with the range operators that one of these<br>&gt; must exclude the end value and the other include it, then the two<br>&gt; names must mean what they do today. With three stride styles and three<br>&gt; prepositions, but only two range operators, this intuition is broken,<br>&gt; while the prepositions may not get much clearer (though I must admit<br>&gt; that your proposed use of &quot;to&quot; is an improvement).<br>&gt; <br>&gt; Critique 2:<br>&gt; <br>&gt; The original motivation behind your twin proposals was the epsilon<br>&gt; adjustment necessary for floating point end values. Your other<br>&gt; proposal fixes an issue with accumulated errors but doesn&#39;t solve the<br>&gt; need for an epsilon adjustment.<br></p><p>Actually, I&#39;ve tweaked it this morning to take care of that. Reload: https://gist.github.com/erica/cf50f3dc54bb3a090933<br></p><p>&gt; Here, you propose adding a third<br>&gt; stride style to solve that problem<br></p><p>It&#39;s really solving the 1/10/by 8 problem more than the 2.0 problem. Which is a big reason why I even<br>brought up the issue of separating the proposals in the first place.  To me, the following just doesn&#39;t make<br>sense:<br></p><p>print(Array(1.stride(through:10, by: 8))) // [1, 9]<br></p><p><br>&gt; , along the way shuffling the naming<br>&gt; of the existing stride styles. Since you haven&#39;t presented other use<br>&gt; cases for that third stride style here, and you haven&#39;t listed<br>&gt; alternatives considered for solving the original motivating problem<br>&gt; (i.e. epsilon adjustment), let me propose one alternative:<br></p><p>Canonical use-cases for all three styles:<br></p><p>1 towards 5 by 1: [1, 2, 3, 4] <br>This style mimics a..&lt;b but allows non-unit and negative progressions<br></p><p>1 to 5 by 1: [1, 2, 3, 4, 5]<br>This style mimics a...b but allows non-unit and negative progressions<br></p><p>1 through 10 by 8: [1, 9, 17]<br>This style ensures a non-unit and negative progression that passes to or through the final value, <br>ensuring that the range of the progression fully includes the range of the from and to values:<br>[first...last] subsumes [from...through]. You might call this a..&gt;b<br></p><p>&gt; Keep the naming of stride styles as-is (inapt as they may be), and for<br>&gt; floating point end values make stride(through: aNumber, by: something)<br>&gt; equivalent to stride(to: theNextLargestRepresentableNumber, by:<br>&gt; somethingPositive) or stride(to: theNextSmallestRepresentableNumber,<br>&gt; by: somethingNegative). Would that solve your original issue<br>&gt; adequately?<br>&gt; <br>&gt; Alternatively, if there are lots of examples that can be envisioned<br>&gt; for this third stride style, would the same examples suggest perhaps<br>&gt; that `..&gt;` might be a useful third range operator? <br></p><p>I like that quite a lot actually.<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/5e1dd0dd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 10:36 AM, Erica Sadun via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 1, 2016, at 1:54 AM, Xiaodi Wu &lt;xiaodi.wu at gmail.com &lt;mailto:xiaodi.wu at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It&#39;s so nice to see such care devoted to clarifying these existing<br>&gt;&gt; names. I agree with the premise that stride(to:by:) and<br>&gt;&gt; stride(through:by:) are poorly named, but I&#39;d like to make two<br>&gt;&gt; critiques of this proposal--<br></p><p>Updated proposal: https://gist.github.com/erica/2745585a4aac442db1fc<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/0a2e3d5a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March  1, 2016 at 01:00:00pm</p></header><div class="content"><p>Inline below.<br></p><p>On Tue, Mar 1, 2016 at 11:36 AM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;<br>&gt; Do you want the stride to pick up the sign automatically? Instead of<br>&gt;<br>&gt; print(Array(10.stride(to: 0, by: -1))) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],<br>&gt; current Swift<br>&gt;<br>&gt; have<br>&gt;<br>&gt; print(Array(10.stride(to: 0, by: 1))) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],<br>&gt; adjusted sign<br>&gt;<br>&gt; Or am I missing your point of &quot;if I stride from 10 towards 0 by 1&quot;?<br></p><p>To clarify, I am not troubled that stride(to:by:) as it is now doesn&#39;t<br>pick up the sign. The point is that, if renamed to<br>stride(towards:by:), the English meaning of &quot;towards&quot; implies that it<br>would pick up the sign. It is a critique of the suggested renaming,<br>not a critique of the algorithm being renamed.<br></p><p>&gt;<br>&gt; I&#39;m searching for a word that means &quot;in the direction of but never<br>&gt; reaching&quot;.<br>&gt;<br>&gt; print(Array(10.stride(to: 0, by: -1))) // [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],<br>&gt; current Swift<br>&gt;<br>&gt; This never reaches 0.<br></p><p>I understand the aim, and I&#39;d be greatly pleased if you found such a<br>word. Here my point is that &quot;towards&quot; doesn&#39;t quite fulfill that<br>purpose because, in English, (a) making strides &quot;towards&quot; something<br>has no relation to whether one in fact gets there; and (b) the<br>intention behind making strides &quot;towards&quot; something is that one does<br>in fact get there. The only thing that &quot;towards&quot; unambiguously<br>suggests (IMO) is that it picks up the sign, which is the one thing<br>that stride(towards:by:) would not do after a simple renaming from<br>stride(to:by:).<br></p><p>&gt;<br>&gt; `until` to me suggests reaching the end-point.<br>&gt;<br></p><p>If I tell someone that I&#39;m here &quot;until&quot; 6 p.m., I would hope that they<br>do not try to find me there at 6. The implication is that, at 6, I get<br>up to leave.<br></p><p>But that&#39;s tangential to the point I&#39;m trying to make, which is this--<br></p><p>Proposition 1: &quot;Until&quot; is one of the only words I can find where the<br>dictionary gives at least one definition that suggests never reaching<br>the end point. [For example: OED until 6(B)(c): &quot;In similar sense<br>without a negative: Before the time that; before. Cf. till conj. 1c.&quot;]<br></p><p>Proposition 2: [I think we both accept this.] There are other meanings<br>of the word &quot;until&quot; that do suggest reaching the end point.<br></p><p>Conclusion with a little leap of logic: I can&#39;t think of a word in<br>English without this ambiguity. Clarity in naming these stride styles<br>may have to rely on factors other than the English meaning of the the<br>prepositions used for labels. One such source of clarity (for me) are<br>the parallels between the two stride styles and two range operators.<br></p><p>&gt;<br>&gt; Quite often, it doesn&#39;t really:<br>&gt;<br>&gt; print(Array(1.stride(to:10, by: 8))) // [1, 9]<br>&gt; print(Array(1.stride(through:10, by: 8))) // [1, 9]<br>&gt;<br>&gt;<br></p><p>I&#39;m aware, and it doesn&#39;t bother me. I&#39;m satisfied that *when* the two<br>do differ, `through` goes further than `to`, as their names would<br>imply. The argument is that this is enough to deduce, by analogy with<br>range operators, that one is closed and the other half-open.<br></p><p>&gt;<br>&gt; Actually, I&#39;ve tweaked it this morning to take care of that. Reload:<br>&gt; https://gist.github.com/erica/cf50f3dc54bb3a090933<br>&gt;<br></p><p>I must misunderstand what it is you tweaked. You still write that the<br>other proposal doesn&#39;t remove the need for manual epsilon adjustment?<br></p><p>&gt;<br>&gt; It&#39;s really solving the 1/10/by 8 problem more than the 2.0 problem. Which<br>&gt; is a big reason why I even<br>&gt; brought up the issue of separating the proposals in the first place.  To me,<br>&gt; the following just doesn&#39;t make<br>&gt; sense:<br>&gt;<br>&gt; print(Array(1.stride(through:10, by: 8))) // [1, 9]<br>&gt;<br></p><p>I&#39;m not pleased with it, but I can make sense of it if I contort my<br>thinking a little:<br>Take the numbers 1 through 10, stride through that range by 8. You<br>must get: 1, 9.<br></p><p>In other words, the contortion I must accept is this: &quot;through&quot;<br>doesn&#39;t go with &quot;stride&quot;, even though it should. Mentally rearrange to<br>put &quot;through&quot; between start and end, moving the word &quot;stride&quot; after<br>the end: 1 through 10, stride by 8. With this approach, I can<br>understand why someone would name the two stride styles &quot;to&quot; and<br>&quot;through&quot;. Consider the typical (American?) English phrase &quot;open Mon<br>thru Fri, 9 to 5&quot;: Fri is included, but 5 is excluded.<br></p><p>&gt;<br>&gt; Canonical use-cases for all three styles:<br>&gt;<br>&gt; 1 towards 5 by 1: [1, 2, 3, 4]<br>&gt; This style mimics a..&lt;b but allows non-unit and negative progressions<br>&gt;<br>&gt; 1 to 5 by 1: [1, 2, 3, 4, 5]<br>&gt; This style mimics a...b but allows non-unit and negative progressions<br>&gt;<br>&gt; 1 through 10 by 8: [1, 9, 17]<br>&gt; This style ensures a non-unit and negative progression that passes to or<br>&gt; through the final value,<br>&gt; ensuring that the range of the progression fully includes the range of the<br>&gt; from and to values:<br>&gt; [first...last] subsumes [from...through]. You might call this a..&gt;b<br>&gt;<br></p><p>I understand that you believe this makes the behavior of &quot;through&quot;<br>more sensible. I could even agree. But do we need this third stride<br>style, whatever it&#39;s called? Essentially, my question is: besides the<br>issue of epsilon adjustments, when have you encountered a case in your<br>code where you&#39;ve needed to stride beyond the end point?<br></p><p>&gt;<br>&gt; I like that quite a lot actually.<br>&gt;<br></p><p>:) Thanks.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 01:00:00pm</p></header><div class="content"><p>On Mar 1, 2016, at 12:25 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; To clarify, I am not troubled that stride(to:by:) as it is now doesn&#39;t<br>&gt; pick up the sign. The point is that, if renamed to<br>&gt; stride(towards:by:), the English meaning of &quot;towards&quot; implies that it<br>&gt; would pick up the sign. It is a critique of the suggested renaming,<br>&gt; not a critique of the algorithm being renamed.<br></p><p>Summarizing: &quot;Using `towards` suggests that the by value picks up the vector direction and<br>can be misleading.<br></p><p>Response:<br></p><p>1. yeah.<br>2. but no solution is going to be ideal.<br>3. alternatives: approaching, movingTowards, advancedTowards.  Included in the latest <br>revision of the proposal. <br></p><p>My big issues are &quot;this thing says it goes through and it doesn&#39;t, this thing says it goes to and it doesn&#39;t&quot;.<br>So long as those are fixed reasonably well, I am happy, even without the naming being perfect.<br></p><p>&gt; I must misunderstand what it is you tweaked. You still write that the<br>&gt; other proposal doesn&#39;t remove the need for manual epsilon adjustment?<br></p><p>In order to separate this into two proposals, I had to make sure they weren&#39;t depending on each other.<br>So this proposal *only* addresses the semantic mismatch I described 4 lines up.<br></p><p>Manual epsilon adjustment is simply a floating point thing, and is discussed at length in the<br>other proposal (Again, keep refreshing gist.github because both are works in progress.)<br></p><p>&gt;&gt; [first...last] subsumes [from...through]. You might call this a..&gt;b<br>&gt;&gt; <br>&gt; <br>&gt; I understand that you believe this makes the behavior of &quot;through&quot;<br>&gt; more sensible. I could even agree. But do we need this third stride<br>&gt; style, whatever it&#39;s called? Essentially, my question is: besides the<br>&gt; issue of epsilon adjustments, when have you encountered a case in your<br>&gt; code where you&#39;ve needed to stride beyond the end point?<br></p><p>First, I renamed it with the two options a...&gt;b, a..&gt;=b and a..=&gt;b to suggest &quot;reach or greater&quot;. <br></p><p>Second, yes, and I added a big new section on canonical use cases.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/e83b619f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March  1, 2016 at 03:00:00pm</p></header><div class="content"><p>I think I see where we&#39;ve not been connecting. You&#39;ve phrased the<br>problem to be solved this way: &quot;this thing says it goes through and it<br>doesn&#39;t, this thing says it goes to and it doesn&#39;t&quot;.<br></p><p>I can see why you&#39;d see this as one single issue. You want the things<br>to do what they say. And we very much still need the current function<br>of stride(to:by:), so you rename that &#39;towards&#39;. That&#39;s how you end up<br>with three stride styles instead of two.<br></p><p>I haven&#39;t been thinking of it in that way. I see what you&#39;re proposing<br>here as two discrete concerns:<br>1. You think the current things are poorly named. You propose<br>different names for them.<br>2. You think we need a new third thing. You propose a new thing.<br></p><p>My feedback, in a nutshell, is that I agree with you on the issue<br>you&#39;ve identified in (1), but I quibble about the exact names--I&#39;m<br>sure whatever is adopted will be great, though. (And thank you for<br>taking the time to describe the problem and drive this!)<br></p><p>However, I&#39;m not convinced that (2) is an issue. Reading your revised<br>gist, I&#39;m still not convinced. I see one example about graph axes. As<br>it happens, I&#39;m about to write some code to plot some stuff, and I<br>haven&#39;t been regretting the lack of this third stride style. The<br>reason is that I very much need to compute the top of the axis before<br>I start striding through anything. Drawing axis tick marks comes quite<br>a bit after computing the axis limits. And once I&#39;ve got the axis<br>limits, I can use the second stride style. So, no convincing use case<br>yet, imho. I still think we can address (1) without doing anything<br>about (2).<br></p><p><br>On Tue, Mar 1, 2016 at 2:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; On Mar 1, 2016, at 12:25 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; To clarify, I am not troubled that stride(to:by:) as it is now doesn&#39;t<br>&gt; pick up the sign. The point is that, if renamed to<br>&gt; stride(towards:by:), the English meaning of &quot;towards&quot; implies that it<br>&gt; would pick up the sign. It is a critique of the suggested renaming,<br>&gt; not a critique of the algorithm being renamed.<br>&gt;<br>&gt;<br>&gt; Summarizing: &quot;Using `towards` suggests that the by value picks up the vector<br>&gt; direction and<br>&gt; can be misleading.<br>&gt;<br>&gt; Response:<br>&gt;<br>&gt; 1. yeah.<br>&gt; 2. but no solution is going to be ideal.<br>&gt; 3. alternatives: approaching, movingTowards, advancedTowards.  Included in<br>&gt; the latest<br>&gt; revision of the proposal.<br>&gt;<br>&gt; My big issues are &quot;this thing says it goes through and it doesn&#39;t, this<br>&gt; thing says it goes to and it doesn&#39;t&quot;.<br>&gt; So long as those are fixed reasonably well, I am happy, even without the<br>&gt; naming being perfect.<br>&gt;<br>&gt; I must misunderstand what it is you tweaked. You still write that the<br>&gt; other proposal doesn&#39;t remove the need for manual epsilon adjustment?<br>&gt;<br>&gt;<br>&gt; In order to separate this into two proposals, I had to make sure they<br>&gt; weren&#39;t depending on each other.<br>&gt; So this proposal *only* addresses the semantic mismatch I described 4 lines<br>&gt; up.<br>&gt;<br>&gt; Manual epsilon adjustment is simply a floating point thing, and is discussed<br>&gt; at length in the<br>&gt; other proposal (Again, keep refreshing gist.github because both are works in<br>&gt; progress.)<br>&gt;<br>&gt; [first...last] subsumes [from...through]. You might call this a..&gt;b<br>&gt;<br>&gt;<br>&gt; I understand that you believe this makes the behavior of &quot;through&quot;<br>&gt; more sensible. I could even agree. But do we need this third stride<br>&gt; style, whatever it&#39;s called? Essentially, my question is: besides the<br>&gt; issue of epsilon adjustments, when have you encountered a case in your<br>&gt; code where you&#39;ve needed to stride beyond the end point?<br>&gt;<br>&gt;<br>&gt; First, I renamed it with the two options a...&gt;b, a..&gt;=b and a..=&gt;b to<br>&gt; suggest &quot;reach or greater&quot;.<br>&gt;<br>&gt; Second, yes, and I added a big new section on canonical use cases.<br>&gt;<br>&gt; -- E<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 02:00:00pm</p></header><div class="content"><p>I don&#39;t think we&#39;re terribly far apart at this point. Looking forward to your thoughts <br>and insights as you ponder.<br></p><p>-- E<br></p><p>&gt; On Mar 1, 2016, at 2:02 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think I see where we&#39;ve not been connecting. You&#39;ve phrased the<br>&gt; problem to be solved this way: &quot;this thing says it goes through and it<br>&gt; doesn&#39;t, this thing says it goes to and it doesn&#39;t&quot;.<br>&gt; <br>&gt; I can see why you&#39;d see this as one single issue. You want the things<br>&gt; to do what they say. And we very much still need the current function<br>&gt; of stride(to:by:), so you rename that &#39;towards&#39;. That&#39;s how you end up<br>&gt; with three stride styles instead of two.<br>&gt; <br>&gt; I haven&#39;t been thinking of it in that way. I see what you&#39;re proposing<br>&gt; here as two discrete concerns:<br>&gt; 1. You think the current things are poorly named. You propose<br>&gt; different names for them.<br>&gt; 2. You think we need a new third thing. You propose a new thing.<br>&gt; <br>&gt; My feedback, in a nutshell, is that I agree with you on the issue<br>&gt; you&#39;ve identified in (1), but I quibble about the exact names--I&#39;m<br>&gt; sure whatever is adopted will be great, though. (And thank you for<br>&gt; taking the time to describe the problem and drive this!)<br>&gt; <br>&gt; However, I&#39;m not convinced that (2) is an issue. Reading your revised<br>&gt; gist, I&#39;m still not convinced. I see one example about graph axes. As<br>&gt; it happens, I&#39;m about to write some code to plot some stuff, and I<br>&gt; haven&#39;t been regretting the lack of this third stride style. The<br>&gt; reason is that I very much need to compute the top of the axis before<br>&gt; I start striding through anything. Drawing axis tick marks comes quite<br>&gt; a bit after computing the axis limits. And once I&#39;ve got the axis<br>&gt; limits, I can use the second stride style. So, no convincing use case<br>&gt; yet, imho. I still think we can address (1) without doing anything<br>&gt; about (2).<br>&gt; <br>&gt; <br>&gt; On Tue, Mar 1, 2016 at 2:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt;&gt; On Mar 1, 2016, at 12:25 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To clarify, I am not troubled that stride(to:by:) as it is now doesn&#39;t<br>&gt;&gt; pick up the sign. The point is that, if renamed to<br>&gt;&gt; stride(towards:by:), the English meaning of &quot;towards&quot; implies that it<br>&gt;&gt; would pick up the sign. It is a critique of the suggested renaming,<br>&gt;&gt; not a critique of the algorithm being renamed.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Summarizing: &quot;Using `towards` suggests that the by value picks up the vector<br>&gt;&gt; direction and<br>&gt;&gt; can be misleading.<br>&gt;&gt; <br>&gt;&gt; Response:<br>&gt;&gt; <br>&gt;&gt; 1. yeah.<br>&gt;&gt; 2. but no solution is going to be ideal.<br>&gt;&gt; 3. alternatives: approaching, movingTowards, advancedTowards.  Included in<br>&gt;&gt; the latest<br>&gt;&gt; revision of the proposal.<br>&gt;&gt; <br>&gt;&gt; My big issues are &quot;this thing says it goes through and it doesn&#39;t, this<br>&gt;&gt; thing says it goes to and it doesn&#39;t&quot;.<br>&gt;&gt; So long as those are fixed reasonably well, I am happy, even without the<br>&gt;&gt; naming being perfect.<br>&gt;&gt; <br>&gt;&gt; I must misunderstand what it is you tweaked. You still write that the<br>&gt;&gt; other proposal doesn&#39;t remove the need for manual epsilon adjustment?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; In order to separate this into two proposals, I had to make sure they<br>&gt;&gt; weren&#39;t depending on each other.<br>&gt;&gt; So this proposal *only* addresses the semantic mismatch I described 4 lines<br>&gt;&gt; up.<br>&gt;&gt; <br>&gt;&gt; Manual epsilon adjustment is simply a floating point thing, and is discussed<br>&gt;&gt; at length in the<br>&gt;&gt; other proposal (Again, keep refreshing gist.github because both are works in<br>&gt;&gt; progress.)<br>&gt;&gt; <br>&gt;&gt; [first...last] subsumes [from...through]. You might call this a..&gt;b<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I understand that you believe this makes the behavior of &quot;through&quot;<br>&gt;&gt; more sensible. I could even agree. But do we need this third stride<br>&gt;&gt; style, whatever it&#39;s called? Essentially, my question is: besides the<br>&gt;&gt; issue of epsilon adjustments, when have you encountered a case in your<br>&gt;&gt; code where you&#39;ve needed to stride beyond the end point?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; First, I renamed it with the two options a...&gt;b, a..&gt;=b and a..=&gt;b to<br>&gt;&gt; suggest &quot;reach or greater&quot;.<br>&gt;&gt; <br>&gt;&gt; Second, yes, and I added a big new section on canonical use cases.<br>&gt;&gt; <br>&gt;&gt; -- E<br>&gt;&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1faea18be9eb2d50c4edcd223f2d685?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Seth Friedman</string> &lt;sethfri at gmail.com&gt;<p>March  2, 2016 at 07:00:00am</p></header><div class="content"><p>I agree with Xiaodi that the use case given for the third stride style<br>isn&#39;t compelling because you can simply increase the upper bound of the<br>range that you&#39;re striding across. I&#39;d be curious to see a reason why you&#39;d<br>want to stride past a bound and only stop one &quot;by&quot; past the bound. Seems<br>like an esoteric function to include in stdlib.<br></p><p>Assuming there exists a compelling use case, I definitely like &quot;beyond&quot; or<br>&quot;past&quot; better than &quot;through&quot;, as again the definition used for &quot;through&quot; in<br>the proposal is not a numerical one. I think the current &quot;Strideable<br>through&quot; style should keep its name.<br></p><p>The current &quot;Strideable to&quot; style is less ideally named, but I think it&#39;s<br>more obvious than &quot;toward&quot; or any of the other proposed names in the<br>updated gist for the reasons already discussed. Perhaps &quot;Strideable until&quot;<br>would make more sense, as that better captures the finality of &quot;we&#39;re<br>stopping when we see this upper bound&quot;.<br></p><p>Thanks,<br>Seth<br>On Tue, Mar 1, 2016 at 1:20 PM Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I don&#39;t think we&#39;re terribly far apart at this point. Looking forward to<br>&gt; your thoughts<br>&gt; and insights as you ponder.<br>&gt;<br>&gt; -- E<br>&gt;<br>&gt; &gt; On Mar 1, 2016, at 2:02 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think I see where we&#39;ve not been connecting. You&#39;ve phrased the<br>&gt; &gt; problem to be solved this way: &quot;this thing says it goes through and it<br>&gt; &gt; doesn&#39;t, this thing says it goes to and it doesn&#39;t&quot;.<br>&gt; &gt;<br>&gt; &gt; I can see why you&#39;d see this as one single issue. You want the things<br>&gt; &gt; to do what they say. And we very much still need the current function<br>&gt; &gt; of stride(to:by:), so you rename that &#39;towards&#39;. That&#39;s how you end up<br>&gt; &gt; with three stride styles instead of two.<br>&gt; &gt;<br>&gt; &gt; I haven&#39;t been thinking of it in that way. I see what you&#39;re proposing<br>&gt; &gt; here as two discrete concerns:<br>&gt; &gt; 1. You think the current things are poorly named. You propose<br>&gt; &gt; different names for them.<br>&gt; &gt; 2. You think we need a new third thing. You propose a new thing.<br>&gt; &gt;<br>&gt; &gt; My feedback, in a nutshell, is that I agree with you on the issue<br>&gt; &gt; you&#39;ve identified in (1), but I quibble about the exact names--I&#39;m<br>&gt; &gt; sure whatever is adopted will be great, though. (And thank you for<br>&gt; &gt; taking the time to describe the problem and drive this!)<br>&gt; &gt;<br>&gt; &gt; However, I&#39;m not convinced that (2) is an issue. Reading your revised<br>&gt; &gt; gist, I&#39;m still not convinced. I see one example about graph axes. As<br>&gt; &gt; it happens, I&#39;m about to write some code to plot some stuff, and I<br>&gt; &gt; haven&#39;t been regretting the lack of this third stride style. The<br>&gt; &gt; reason is that I very much need to compute the top of the axis before<br>&gt; &gt; I start striding through anything. Drawing axis tick marks comes quite<br>&gt; &gt; a bit after computing the axis limits. And once I&#39;ve got the axis<br>&gt; &gt; limits, I can use the second stride style. So, no convincing use case<br>&gt; &gt; yet, imho. I still think we can address (1) without doing anything<br>&gt; &gt; about (2).<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Tue, Mar 1, 2016 at 2:29 PM, Erica Sadun &lt;erica at ericasadun.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt; On Mar 1, 2016, at 12:25 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; To clarify, I am not troubled that stride(to:by:) as it is now doesn&#39;t<br>&gt; &gt;&gt; pick up the sign. The point is that, if renamed to<br>&gt; &gt;&gt; stride(towards:by:), the English meaning of &quot;towards&quot; implies that it<br>&gt; &gt;&gt; would pick up the sign. It is a critique of the suggested renaming,<br>&gt; &gt;&gt; not a critique of the algorithm being renamed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Summarizing: &quot;Using `towards` suggests that the by value picks up the<br>&gt; vector<br>&gt; &gt;&gt; direction and<br>&gt; &gt;&gt; can be misleading.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Response:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1. yeah.<br>&gt; &gt;&gt; 2. but no solution is going to be ideal.<br>&gt; &gt;&gt; 3. alternatives: approaching, movingTowards, advancedTowards.  Included<br>&gt; in<br>&gt; &gt;&gt; the latest<br>&gt; &gt;&gt; revision of the proposal.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; My big issues are &quot;this thing says it goes through and it doesn&#39;t, this<br>&gt; &gt;&gt; thing says it goes to and it doesn&#39;t&quot;.<br>&gt; &gt;&gt; So long as those are fixed reasonably well, I am happy, even without the<br>&gt; &gt;&gt; naming being perfect.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I must misunderstand what it is you tweaked. You still write that the<br>&gt; &gt;&gt; other proposal doesn&#39;t remove the need for manual epsilon adjustment?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; In order to separate this into two proposals, I had to make sure they<br>&gt; &gt;&gt; weren&#39;t depending on each other.<br>&gt; &gt;&gt; So this proposal *only* addresses the semantic mismatch I described 4<br>&gt; lines<br>&gt; &gt;&gt; up.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Manual epsilon adjustment is simply a floating point thing, and is<br>&gt; discussed<br>&gt; &gt;&gt; at length in the<br>&gt; &gt;&gt; other proposal (Again, keep refreshing gist.github because both are<br>&gt; works in<br>&gt; &gt;&gt; progress.)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; [first...last] subsumes [from...through]. You might call this a..&gt;b<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I understand that you believe this makes the behavior of &quot;through&quot;<br>&gt; &gt;&gt; more sensible. I could even agree. But do we need this third stride<br>&gt; &gt;&gt; style, whatever it&#39;s called? Essentially, my question is: besides the<br>&gt; &gt;&gt; issue of epsilon adjustments, when have you encountered a case in your<br>&gt; &gt;&gt; code where you&#39;ve needed to stride beyond the end point?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; First, I renamed it with the two options a...&gt;b, a..&gt;=b and a..=&gt;b to<br>&gt; &gt;&gt; suggest &quot;reach or greater&quot;.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Second, yes, and I added a big new section on canonical use cases.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -- E<br>&gt; &gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/2bd5f875/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; In other words, the contortion I must accept is this: &quot;through&quot;<br>&gt; doesn&#39;t go with &quot;stride&quot;, even though it should. Mentally rearrange to<br>&gt; put &quot;through&quot; between start and end, moving the word &quot;stride&quot; after<br>&gt; the end: 1 through 10, stride by 8. With this approach, I can<br>&gt; understand why someone would name the two stride styles &quot;to&quot; and<br>&gt; &quot;through&quot;. Consider the typical (American?) English phrase &quot;open Mon<br>&gt; thru Fri, 9 to 5&quot;: Fri is included, but 5 is excluded.<br></p><p>So in other other words, the change from `stride(from: 1, to: 2, by: 0.1)` to `1.stride(to: 2, by: 0.1)` is the source of the problem and should be reversed.<br></p><p>(Sorry, pet peeve of mine.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  2, 2016 at 01:00:00am</p></header><div class="content"><p>On Wed, Mar 2, 2016 at 1:20 AM, Brent Royal-Gordon via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; In other words, the contortion I must accept is this: &quot;through&quot;<br>&gt;&gt; doesn&#39;t go with &quot;stride&quot;, even though it should. Mentally rearrange to<br>&gt;&gt; put &quot;through&quot; between start and end, moving the word &quot;stride&quot; after<br>&gt;&gt; the end: 1 through 10, stride by 8. With this approach, I can<br>&gt;&gt; understand why someone would name the two stride styles &quot;to&quot; and<br>&gt;&gt; &quot;through&quot;. Consider the typical (American?) English phrase &quot;open Mon<br>&gt;&gt; thru Fri, 9 to 5&quot;: Fri is included, but 5 is excluded.<br>&gt;<br>&gt; So in other other words, the change from `stride(from: 1, to: 2, by: 0.1)` to `1.stride(to: 2, by: 0.1)` is the source of the problem and should be reversed.<br></p><p>It is reversed in SE-0006.<br></p><p>https://github.com/apple/swift-evolution/blob/master/proposals/0006-apply-api-guidelines-to-the-standard-library.md<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March  2, 2016 at 01:00:00am</p></header><div class="content"><p>&gt;&gt; So in other other words, the change from `stride(from: 1, to: 2, by: 0.1)` to `1.stride(to: 2, by: 0.1)` is the source of the problem and should be reversed.<br>&gt; <br>&gt; It is reversed in SE-0006.<br></p><p>Wow, as of seven days ago. That&#39;s a very pleasant surprise (and one that&#39;s probably relevant to this thread).<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>March  2, 2016 at 02:00:00pm</p></header><div class="content"><p>Indeed! For me, the reverted syntax makes sufficient sense.<br></p><p>On Wed, Mar 2, 2016 at 3:58 AM Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt;&gt; So in other other words, the change from `stride(from: 1, to: 2, by:<br>&gt; 0.1)` to `1.stride(to: 2, by: 0.1)` is the source of the problem and should<br>&gt; be reversed.<br>&gt; &gt;<br>&gt; &gt; It is reversed in SE-0006.<br>&gt;<br>&gt; Wow, as of seven days ago. That&#39;s a very pleasant surprise (and one that&#39;s<br>&gt; probably relevant to this thread).<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/13de6845/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  2, 2016 at 09:00:00pm</p></header><div class="content"><p>+1 from me as well<br></p><p>-Thorsten<br></p><p><br>&gt; Am 02.03.2016 um 15:34 schrieb Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Indeed! For me, the reverted syntax makes sufficient sense.<br>&gt; <br>&gt; On Wed, Mar 2, 2016 at 3:58 AM Brent Royal-Gordon &lt;brent at architechies.com &lt;mailto:brent at architechies.com&gt;&gt; wrote:<br>&gt; &gt;&gt; So in other other words, the change from `stride(from: 1, to: 2, by: 0.1)` to `1.stride(to: 2, by: 0.1)` is the source of the problem and should be reversed.<br>&gt; &gt;<br>&gt; &gt; It is reversed in SE-0006.<br>&gt; <br>&gt; Wow, as of seven days ago. That&#39;s a very pleasant surprise (and one that&#39;s probably relevant to this thread).<br>&gt; <br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/6424763a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>On Mon, Feb 29, 2016 at 5:14 PM, Erica Sadun via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Style 1: [start, end) by interval<br>&gt; This style is currently called to. I propose to rename it towards as each<br>&gt; value works towards end. The final value in the progression is less than end<br></p><p>The current usage of &#39;through&#39; seems unambiguous to me.  &#39;to&#39; could be<br>improved by using &#39;upTo&#39; instead.<br></p><p>stride(from: 1, upTo: 10, by: 1) // [1, 10)<br></p><p>&#39;upTo&#39; is already precedented in Collection.prefix(upTo:).<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m adding in &quot;upTo&quot; as an alternative to &quot;to&quot;. Reload in a minute or two.<br></p><p>-- E<br></p><p>&gt; On Mar 1, 2016, at 10:52 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Feb 29, 2016 at 5:14 PM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Style 1: [start, end) by interval<br>&gt;&gt; This style is currently called to. I propose to rename it towards as each<br>&gt;&gt; value works towards end. The final value in the progression is less than end<br>&gt; <br>&gt; The current usage of &#39;through&#39; seems unambiguous to me.  &#39;to&#39; could be<br>&gt; improved by using &#39;upTo&#39; instead.<br>&gt; <br>&gt; stride(from: 1, upTo: 10, by: 1) // [1, 10)<br>&gt; <br>&gt; &#39;upTo&#39; is already precedented in Collection.prefix(upTo:).<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>Please disregard previous reply. Just realized, what about 10..&gt;1 by -1?  upTo: doesn&#39;t work there.<br></p><p>&gt; On Mar 1, 2016, at 10:52 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Feb 29, 2016 at 5:14 PM, Erica Sadun via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Style 1: [start, end) by interval<br>&gt;&gt; This style is currently called to. I propose to rename it towards as each<br>&gt;&gt; value works towards end. The final value in the progression is less than end<br>&gt; <br>&gt; The current usage of &#39;through&#39; seems unambiguous to me.  &#39;to&#39; could be<br>&gt; improved by using &#39;upTo&#39; instead.<br>&gt; <br>&gt; stride(from: 1, upTo: 10, by: 1) // [1, 10)<br>&gt; <br>&gt; &#39;upTo&#39; is already precedented in Collection.prefix(upTo:).<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2d172fa3c47108d84ee35a68e8d675c1?s=50"></div><header><strong>[Proposal] Conventionalizing stride semantics</strong> from <string>Ross O&#39;Brien</string> &lt;narrativium+swift at gmail.com&gt;<p>March  1, 2016 at 06:00:00pm</p></header><div class="content"><p>A suggestion: &quot;stride(approaching:by:)&quot;<br></p><p>On Tue, Mar 1, 2016 at 5:55 PM, Erica Sadun via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Please disregard previous reply. Just realized, what about 10..&gt;1 by -1?<br>&gt; upTo: doesn&#39;t work there.<br>&gt;<br>&gt; &gt; On Mar 1, 2016, at 10:52 AM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; On Mon, Feb 29, 2016 at 5:14 PM, Erica Sadun via swift-evolution<br>&gt; &gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt; Style 1: [start, end) by interval<br>&gt; &gt;&gt; This style is currently called to. I propose to rename it towards as<br>&gt; each<br>&gt; &gt;&gt; value works towards end. The final value in the progression is less<br>&gt; than end<br>&gt; &gt;<br>&gt; &gt; The current usage of &#39;through&#39; seems unambiguous to me.  &#39;to&#39; could be<br>&gt; &gt; improved by using &#39;upTo&#39; instead.<br>&gt; &gt;<br>&gt; &gt; stride(from: 1, upTo: 10, by: 1) // [1, 10)<br>&gt; &gt;<br>&gt; &gt; &#39;upTo&#39; is already precedented in Collection.prefix(upTo:).<br>&gt; &gt;<br>&gt; &gt; Dmitri<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; &gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/a9da10c4/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
