<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br></p><p>In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br></p><p>I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br></p><p>So things like:<br></p><p>let n : Int? = 5<br></p><p>let r = n + 5<br></p><p>would actually compile as <br></p><p>let r = n.map {$0 + 5}<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/6d9ade47/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br></p><p><br></p><p>&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt; <br>&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt; <br>&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt; <br>&gt; So things like:<br>&gt; <br>&gt; let n : Int? = 5<br>&gt; <br>&gt; let r = n + 5<br>&gt; <br>&gt; would actually compile as <br>&gt; <br>&gt; let r = n.map {$0 + 5}<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/95d5f303/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 28, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes<br>&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt; <br>&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt; <br>&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt; <br>&gt;&gt; So things like:<br>&gt;&gt; <br>&gt;&gt; let n : Int? = 5<br>&gt;&gt; <br>&gt;&gt; let r = n + 5<br>&gt;&gt; <br>&gt;&gt; would actually compile as <br>&gt;&gt; <br>&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/3ae304c6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>January 28, 2016 at 06:00:00am</p></header><div class="content"><p>Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br></p><p>-Thorsten <br></p><p>&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Yes<br>&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/94193345/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 27, 2016 at 09:00:00pm</p></header><div class="content"><p>Maybe something like this?<br></p><p>let n : Int? = 5<br></p><p>let r = n? + 5<br></p><p><br>&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Yes<br>&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/0c748534/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Something like that would be good.<br></p><p><br>&gt; On 2016-01-28, at 12:50:50, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; Maybe something like this?<br>&gt; <br>&gt; let n : Int? = 5<br>&gt; <br>&gt; let r = n? + 5<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/b26e200f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 27, 2016 at 10:00:00pm</p></header><div class="content"><p>Kind works like optional chaining. In that the result remains an optional.<br></p><p>+1 for this, in that I agree that too often, control flow must be used for optionals. IMO clean code has fewer control flow statements and is more linear if possible. <br></p><p>&gt; On Jan 27, 2016, at 10:01 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; Something like that would be good.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-28, at 12:50:50, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Maybe something like this?<br>&gt;&gt; <br>&gt;&gt; let n : Int? = 5<br>&gt;&gt; <br>&gt;&gt; let r = n? + 5<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/0b9432f5/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 27, 2016 at 11:00:00pm</p></header><div class="content"><p>I&#39;ve wanted this sort of thing a lot. It would also work for other<br>functions, such as<br></p><p>    manager.doSomething(data: data, count: n?)<br></p><p>which is equivalent to<br></p><p>    n.map { manager.doSomething(data: data, count: $0) }<br></p><p>It might be hard to see exactly which operator/function applications such a<br>thing applies to, if used in the context of a complex expression.<br></p><p>Jacob<br></p><p>On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Maybe something like this?<br>&gt;<br>&gt; let n : Int? = 5<br>&gt;<br>&gt; let r = n? + 5<br>&gt;<br>&gt;<br>&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt; Too much hidden magic IMO. This would mean loosing the benefits of<br>&gt; optionals, i.e. making explicit where optional cases occur and that<br>&gt; handling the missing case has to be considered.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; Yes<br>&gt;<br>&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;<br>&gt; Trying to see if I got this. So the type of r would be Int? at the end of<br>&gt; this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift currently encourages a lot of conditional code - especially when it<br>&gt; comes to optionals.  In most cases when you are computing etc. on an<br>&gt; Optional you would expect that you would want an optional result and things<br>&gt; to be able to use optionals.<br>&gt;<br>&gt; In another language I generally just `map` one optional to another - which<br>&gt; may not be the most readable code to some not use to optionals.<br>&gt;<br>&gt; I was wondering if maybe an expression is not available that it would<br>&gt; rewrite the syntax to map from one to another value.<br>&gt;<br>&gt; So things like:<br>&gt;<br>&gt; let n : Int? = 5<br>&gt;<br>&gt; let r = n + 5<br>&gt;<br>&gt; would actually compile as<br>&gt;<br>&gt; let r = n.map {$0 + 5}<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160127/01da58c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/388e62373f2bcb0ef212df56de255497?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Robert S Mozayeni</string> &lt;r at mzy.me&gt;<p>January 28, 2016 at 03:00:00am</p></header><div class="content"><p>+1 for Paul and Jacob’s ideas.<br></p><p>I’m not a fan of the original example, because then you could just have one optional variable or constant that just cascades through your code and gives everything an inferred Optional type, and then you lose the power of optionals because the compiler doesn’t make you check for them. Here’s an example for where that could go awry:<br></p><p>Let&#39;s say you&#39;re writing code that takes a String from user input somewhere and parses it into an Int.<br></p><p>let numCaloriesJustEaten = Int(userInputString) //Let&#39;s say userInputString is `two`. Type inferred as `Int?`, and would have value of nil<br>dict[&quot;caloricConsumption&quot;] = numCaloriesJustEaten + (dict[&quot;caloricConsumption&quot;] ?? 0)<br></p><p>The intention of this code would be to increment caloricConsumption by the recently-eaten calories. In Swift, this (rightfully) wouldn’t compile. If Swift operated according to the original example, then the whole expression of `numCaloriesJustEaten + (dict[&quot;caloricConsumption&quot;] ?? 0)` would compile, and would have a value of nil at runtime.<br>This would remove the value of `dict[&quot;caloricConsumption”]` because when you set a the value of a key to nil, it removes that key from the dictionary entirely. This would be a logic error that is currently caught as a compile-time error in Swift today.<br></p><p>-Robert<br></p><p>&gt; On Jan 28, 2016, at 2:34 AM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt; <br>&gt;     manager.doSomething(data: data, count: n?)<br>&gt; <br>&gt; which is equivalent to<br>&gt; <br>&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt; <br>&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Maybe something like this?<br>&gt; <br>&gt; let n : Int? = 5<br>&gt; <br>&gt; let r = n? + 5<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/116bd64a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt;     manager.doSomething(data: data, count: n?)<br></p><p>What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br></p><p><br>&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt; <br>&gt;     manager.doSomething(data: data, count: n?)<br>&gt; <br>&gt; which is equivalent to<br>&gt; <br>&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt; <br>&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Maybe something like this?<br>&gt; <br>&gt; let n : Int? = 5<br>&gt; <br>&gt; let r = n? + 5<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/6839ed73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 29, 2016 at 04:00:00am</p></header><div class="content"><p>That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in<br>it, it becomes optional (it&#39;s basically optional chaining, but for function<br>calls and other expressions instead of just dot-notation).<br>On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br></p><p>&gt;<br>&gt;     manager.doSomething(data: data, count: n?)<br>&gt;<br>&gt;<br>&gt; What if the return value of doSomething is not an optional?  Expressions<br>&gt; are easy — but there might be some conflicts with this one.<br>&gt;<br>&gt;<br>&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other<br>&gt; functions, such as<br>&gt;<br>&gt;     manager.doSomething(data: data, count: n?)<br>&gt;<br>&gt; which is equivalent to<br>&gt;<br>&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;<br>&gt; It might be hard to see exactly which operator/function applications such<br>&gt; a thing applies to, if used in the context of a complex expression.<br>&gt;<br>&gt; Jacob<br>&gt;<br>&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Maybe something like this?<br>&gt;&gt;<br>&gt;&gt; let n : Int? = 5<br>&gt;&gt;<br>&gt;&gt; let r = n? + 5<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of<br>&gt;&gt; optionals, i.e. making explicit where optional cases occur and that<br>&gt;&gt; handling the missing case has to be considered.<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; Yes<br>&gt;&gt;<br>&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of<br>&gt;&gt; this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Swift currently encourages a lot of conditional code - especially when it<br>&gt;&gt; comes to optionals.  In most cases when you are computing etc. on an<br>&gt;&gt; Optional you would expect that you would want an optional result and things<br>&gt;&gt; to be able to use optionals.<br>&gt;&gt;<br>&gt;&gt; In another language I generally just `map` one optional to another -<br>&gt;&gt; which may not be the most readable code to some not use to optionals.<br>&gt;&gt;<br>&gt;&gt; I was wondering if maybe an expression is not available that it would<br>&gt;&gt; rewrite the syntax to map from one to another value.<br>&gt;&gt;<br>&gt;&gt; So things like:<br>&gt;&gt;<br>&gt;&gt; let n : Int? = 5<br>&gt;&gt;<br>&gt;&gt; let r = n + 5<br>&gt;&gt;<br>&gt;&gt; would actually compile as<br>&gt;&gt;<br>&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/64d9cc14/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 11:00:00am</p></header><div class="content"><p>Since the foundation of this proposal is Paul’s and yours - will either of you be drawing up the proposal?<br></p><p><br>&gt; On 2016-01-29, at 11:41:21, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in it, it becomes optional (it&#39;s basically optional chaining, but for function calls and other expressions instead of just dot-notation).<br>&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt; <br>&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt; <br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt; <br>&gt;&gt; which is equivalent to<br>&gt;&gt; <br>&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt; <br>&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Maybe something like this?<br>&gt;&gt; <br>&gt;&gt; let n : Int? = 5<br>&gt;&gt; <br>&gt;&gt; let r = n? + 5<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/37ea4a06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 28, 2016 at 09:00:00pm</p></header><div class="content"><p>I can take a stab at it. I will try to follow your lead and keep it short.  :-)<br></p><p>&gt; On Jan 28, 2016, at 8:44 PM, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; Since the foundation of this proposal is Paul’s and yours - will either of you be drawing up the proposal?<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-29, at 11:41:21, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in it, it becomes optional (it&#39;s basically optional chaining, but for function calls and other expressions instead of just dot-notation).<br>&gt;&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt; <br>&gt;&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/0250fd69/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Thanks, looking forward to it.<br></p><p>&gt; On 2016-01-29, at 12:04:10, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; I can take a stab at it. I will try to follow your lead and keep it short.  :-)<br>&gt; <br>&gt;&gt; On Jan 28, 2016, at 8:44 PM, Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Since the foundation of this proposal is Paul’s and yours - will either of you be drawing up the proposal?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2016-01-29, at 11:41:21, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in it, it becomes optional (it&#39;s basically optional chaining, but for function calls and other expressions instead of just dot-notation).<br>&gt;&gt;&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/2379c5e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February 15, 2016 at 12:00:00am</p></header><div class="content"><p>This is a draft.<br>Sorry for the multi-week delay, been too tired after work to think about this, since it is a long weekend, I continued work on this looking for feedback now. The biggest addition is what to do with parameters to functions by utilizing the nil-coalescing operator in some new ways. I did not finish the detailed design, want to see if it is a good direction first.<br></p><p>Non-Conditional Optional Unwrapping<br></p><p>Proposal: SE- &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-name.md&gt;TBD<br>Author(s): Paul Ossenbruggen, Craig Cruden <br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/apple/swift-evolution#introduction&gt;Introduction<br></p><p>Currently there are many cases, in Swift, where control flow must be used to handle optionals. For example<br></p><p>   	let a : Int? = 10<br>	let b = 5<br></p><p>	if let a = a {<br>            return a + b<br>    	} else {<br>            return nil<br>    	}<br></p><p>Since we can’t operate on the optional for a, we need to unwrap it, if is non nil otherwise it should return a nil. For something this simple we have introduced control flow statements which makes the intent of the code harder to follow, adds many braces and is less linear. Code that is linear, in general, tends to be easier to follow, because at the end of it you know you have a certain result. <br></p><p>Swift-evolution thread:  [swift-evolution] Brainstorming: Optional sugar inferred map<br></p><p> &lt;https://github.com/apple/swift-evolution#motivation&gt;Motivation<br></p><p>Often it is necessary to add conditional code for optionals earlier in the code than you like when it would be nice to leave it as an optional longer, thus allowing your code to be more linear. Optional chaining already allows code to be linearized for properties this proposal builds upon that. <br></p><p> &lt;https://github.com/apple/swift-evolution#proposed-solution&gt;Proposed solution<br></p><p>The solution is to allow the question mark operator to be applied to an optional value in places that it currently is prohibited. This already works in Swift 2, for objects. For example: <br></p><p>var v : String? = &quot;It exists&quot;<br>var w : String? = nil<br>v?.appendContentsOf(&quot;.&quot;)<br>v -&gt; “It exists.&quot;<br>w?.appendContentsOf(&quot;.&quot;)<br>w -&gt; nil<br></p><p>The ? operator is unwrapped and the appendContentsOf method is only executed if the value is non-nil. However you can not do the following, which seems natural:<br></p><p>a? + b<br></p><p>You could write the code from the introduction using the map function, map on an optional will only execute if a is non-nil:<br></p><p>     a.map {$0 + b} <br>    <br>This is pretty non intuitive to someone not familiar with map on optionals, plus they must deal with the closure and an unarmed parameter. Either that or they will have to use the if let form to unwrap. With this proposal, however, you can much more simply and intuitively write it exactly as shown above: a? + b. It is an optional result where the result is nil or the unwrapped a plus b. The code is very easy to understand and it eliminates the control flow. <br></p><p>One area of complication is if you are using the optional in a parameter to a function that takes a non optional as in the following example:<br></p><p>func doSomething(value: Int) -&gt; Int {<br>    return value<br>}<br>doSomething(a?) // illegal<br></p><p>The question mark would not be allowed as a parameter to a function because the code surrounding the call site should not run if the parameter is nil.<br></p><p>If we were to do this with map, you would do the following:<br></p><p>let c : Int? = nil<br>let ra = a.map { doSomething($0) }<br>let rc = c.map { doSomething($0) }<br></p><p>ra -&gt; 5<br>rc -&gt; nil<br></p><p>To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil: <br></p><p>func doSomething(value: Int) -&gt; Int {<br>    return value<br>}<br></p><p>let ra = a ?? doSomething($$) <br>let rc = c ?? doSomething($$)<br></p><p>ra -&gt; 5<br>rc -&gt; nil<br></p><p>multiple statements would allow a statement block after the nil-coalescing operator:<br></p><p>func doSomethingElse(value1: Int, value2: Int) -&gt; Void {<br>    return value1 + value2<br>}<br>let ra = a ?? { <br>	  doSomething($$) <br>	  doSomethingElse($$, value2: b) <br>}<br> <br>multiple optionals would work utilizing a tuple that could address elements using the $n syntax: <br></p><p>	a? + c? <br>	(a, c) ?? doSomethingElse($0, value2: $1)<br></p><p>Using a tuple as opposed to an array would allow disparate types. All values would have to be non-nil for the optional to execute the code after the ??. <br>Detailed Design<br></p><p>Continuing from the above example, If a is nil, the rest of the operation will be short circuited, so that if there was a complicated operation to where b is that calculation would not occur. Furthermore, a and b must resolve to the same type when unwrapped. <br></p><p>&lt;Not Complete&gt;<br></p><p> &lt;https://github.com/apple/swift-evolution#impact-on-existing-code&gt;Impact on existing code<br></p><p>Existing code would not be affected by this change. <br></p><p> &lt;https://github.com/apple/swift-evolution#alternatives-considered&gt;Alternatives considered<br></p><p>Completely implicit unwrapping<br>The only other alternative considered was Craig Cruden’s initial brainstorming idea of eliminating the need to unwrap it. <br></p><p>func add(a : Int?, b : Int) -&gt; Int? {<br>    return a + b<br>}<br></p><p>This was interesting in that it got the discussion started, but eliminates much of the benefit of optionals, as Thorsten Seitz said:<br></p><p>Too much hidden magic IMO. This would mean losing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br></p><p><br>Don’t try to solve the parameter cases <br>The extensions to the nil-coalescing operator may add complexity to the proposal. Perhaps that should be a separate proposal. This could be useful on its own. <br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/10f8072b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 15, 2016 at 09:00:00am</p></header><div class="content"><p>On Feb 15, 2016, at 12:49 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The ? operator is unwrapped and the appendContentsOf method is only executed if the value is non-nil. However you can not do the following, which seems natural:<br>&gt; <br>&gt; a? + b<br></p><p>FWIW, &quot;a?” is the degenerate form of the optional chaining operation, which tests A, conditionally extracts its value, then re-wraps it back up without performing any other operations on it.  It is equivalent to “a?.identity()”.  The compiler rejects it because it is confusing/surprising for people, not because it is undefined.<br></p><p>I would be very concerned with defining this operation to mean something else, because that introduces inconsistency and a completely different kind of surprise to the language.<br></p><p>&gt; <br>&gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil: <br></p><p>Just to point one thing out, ?? is an operator in the stdlib.  Doing something like this would require baking it into the compiler.<br></p><p><br>IMO, the problem you’re addressing is already adequately solved by guard.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/e7360af8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>-1 from me as it means that a complex statement with a single question marked variable could in fact be an entirely optional statement. While I dislike the boilerplate as well, I think it’s much better to have the explicit conditional branch there to make it absolutely clear that a statement is being executed in one case and not in another.<br></p><p>I appreciate the intent of the proposal though, I just think it’s not the right solution as it could make code less readable as I feel it’s better to be explicit with cases such as these IMO.<br></p><p>Also, I don’t like the nil-coalescing operator changes, as it seems to contradict the normal form where the right hand side is the fallback value, not the intended result. It’d be better to have some kind of non-nil operator, but personally I don’t think it’s worth it.<br></p><p>&gt; On 15 Feb 2016, at 17:45, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Feb 15, 2016, at 12:49 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The ? operator is unwrapped and the appendContentsOf method is only executed if the value is non-nil. However you can not do the following, which seems natural:<br>&gt;&gt; <br>&gt;&gt; a? + b<br>&gt; <br>&gt; FWIW, &quot;a?” is the degenerate form of the optional chaining operation, which tests A, conditionally extracts its value, then re-wraps it back up without performing any other operations on it.  It is equivalent to “a?.identity()”.  The compiler rejects it because it is confusing/surprising for people, not because it is undefined.<br>&gt; <br>&gt; I would be very concerned with defining this operation to mean something else, because that introduces inconsistency and a completely different kind of surprise to the language.<br>&gt;&gt; <br>&gt;&gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil: <br>&gt; <br>&gt; Just to point one thing out, ?? is an operator in the stdlib.  Doing something like this would require baking it into the compiler.<br>&gt; <br>&gt; <br>&gt; IMO, the problem you’re addressing is already adequately solved by guard.<br>&gt; <br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/0f92a993/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 12:22 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt; -1 from me as it means that a complex statement with a single question marked variable could in fact be an entirely optional statement. While I dislike the boilerplate as well, I think it’s much better to have the explicit conditional branch there to make it absolutely clear that a statement is being executed in one case and not in another.<br></p><p><br>We frequently use  optional chaining, where you get an optional result. How is this different?<br></p><p>&gt; I appreciate the intent of the proposal though, I just think it’s not the right solution as it could make code less readable as I feel it’s better to be explicit with cases such as these IMO.<br></p><p><br>I am puzzled as to how it is less readable than the examples using “if let” and map, this seems far more readable to me. <br></p><p>&gt; Also, I don’t like the nil-coalescing operator changes, as it seems to contradict the normal form where the right hand side is the fallback value, not the intended result. It’d be better to have some kind of non-nil operator, but personally I don’t think it’s worth it.<br></p><p><br>For nil-coalescing changes, while I see your point, i don’t see why we should constrain it to that usage model only, if it can be made more powerful and easier to read than map. This is essentially syntactic sugar for map on an optional.  Currently it is possible to do this: <br></p><p>a ?? doSomething(59)<br></p><p>it is not a huge stretch to allow the result of the left hand optional expression on the right hand side:<br></p><p>	    a ?? doSomething($$)<br></p><p>The more advanced things like multiple statements in closure, or tuple are certainly up for discussion or could even be a future addition, if there is demand.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/d8c6f763/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 16, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 16.02.2016 um 05:52 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; Currently it is possible to do this: <br>&gt; <br>&gt; a ?? doSomething(59)<br>&gt; <br>&gt; it is not a huge stretch to allow the result of the left hand optional expression on the right hand side:<br>&gt; <br>&gt; 	    a ?? doSomething($$)<br></p><p>Actually it *is* a huge stretch because it is just the opposite!<br>The second version is just `map` written with an operator where the rhs is only called for the case that a value is present, i.e. non-nil.<br>The first version covers the opposite case where the value is absent, i.e. is nil. <br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/8c18a2f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February 16, 2016 at 07:00:00am</p></header><div class="content"><p>Oh wait, yeah now I see the problem. <br></p><p>&gt; On Feb 15, 2016, at 10:32 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 16.02.2016 um 05:52 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; Currently it is possible to do this: <br>&gt;&gt; <br>&gt;&gt; a ?? doSomething(59)<br>&gt;&gt; <br>&gt;&gt; it is not a huge stretch to allow the result of the left hand optional expression on the right hand side:<br>&gt;&gt; <br>&gt;&gt; 	    a ?? doSomething($$)<br>&gt; <br>&gt; Actually it *is* a huge stretch because it is just the opposite!<br>&gt; The second version is just `map` written with an operator where the rhs is only called for the case that a value is present, i.e. non-nil.<br>&gt; The first version covers the opposite case where the value is absent, i.e. is nil. <br>&gt; <br>&gt; -Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/85ecbff7/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Feb 15, 2016, at 9:45 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Feb 15, 2016, at 12:49 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The ? operator is unwrapped and the appendContentsOf method is only executed if the value is non-nil. However you can not do the following, which seems natural:<br>&gt;&gt; <br>&gt;&gt; a? + b<br>&gt; <br>&gt; FWIW, &quot;a?” is the degenerate form of the optional chaining operation, which tests A, conditionally extracts its value, then re-wraps it back up without performing any other operations on it.  It is equivalent to “a?.identity()”.  The compiler rejects it because it is confusing/surprising for people, not because it is undefined.<br></p><p>Thanks for explaining that, that it is doing an identity and that is not undefined. I certainly missed that. . <br></p><p>&gt; <br>&gt; I would be very concerned with defining this operation to mean something else, because that introduces inconsistency and a completely different kind of surprise to the language.<br></p><p><br>I am sorry, I am not getting why this is meaning something else, confusing or inconsistent, seems more consistent because you are returning an optional and that would not surprise me, it seems more surprising that you get an error. if it was already an optional and the expression as a whole results in a an optional, which is similar to what happens with optional chaining. With optional chaining, I expect it to return an optional as well, to me this seems very similar. If a is an optional, it would not be surprising for a? to return an optional. For example, <br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil: <br>&gt; <br>&gt; Just to point one thing out, ?? is an operator in the stdlib.  Doing something like this would require baking it into the compiler.<br>&gt; <br></p><p>I guess if auto closure could take a parameter you could do something like this:<br></p><p>@warn_unused_result<br>public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: (result : T) throws -&gt; T) rethrows -&gt; T {<br>    return optional != nil ? optional! : try defaultValue(result: optional!)<br>}<br></p><p>I am not an expert on this though. I would acknowledge that to the later examples with multiple statements may be harder to do. <br></p><p>&gt; <br>&gt; IMO, the problem you’re addressing is already adequately solved by guard.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/f03b2e42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February 15, 2016 at 08:00:00pm</p></header><div class="content"><p>Oops, I had an example and decided to delete it.<br></p><p><br>&gt; On Feb 15, 2016, at 8:52 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 15, 2016, at 9:45 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Feb 15, 2016, at 12:49 AM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The ? operator is unwrapped and the appendContentsOf method is only executed if the value is non-nil. However you can not do the following, which seems natural:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a? + b<br>&gt;&gt; <br>&gt;&gt; FWIW, &quot;a?” is the degenerate form of the optional chaining operation, which tests A, conditionally extracts its value, then re-wraps it back up without performing any other operations on it.  It is equivalent to “a?.identity()”.  The compiler rejects it because it is confusing/surprising for people, not because it is undefined.<br>&gt; <br>&gt; Thanks for explaining that, that it is doing an identity and that is not undefined. I certainly missed that. . <br>&gt; <br>&gt;&gt; <br>&gt;&gt; I would be very concerned with defining this operation to mean something else, because that introduces inconsistency and a completely different kind of surprise to the language.<br>&gt; <br>&gt; <br>&gt; I am sorry, I am not getting why this is meaning something else, confusing or inconsistent, seems more consistent because you are returning an optional and that would not surprise me, it seems more surprising that you get an error. if it was already an optional and the expression as a whole results in a an optional, which is similar to what happens with optional chaining. With optional chaining, I expect it to return an optional as well, to me this seems very similar. If a is an optional, it would not be surprising for a? to return an optional. For example, <br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil: <br>&gt;&gt; <br>&gt;&gt; Just to point one thing out, ?? is an operator in the stdlib.  Doing something like this would require baking it into the compiler.<br>&gt;&gt; <br>&gt; <br>&gt; I guess if auto closure could take a parameter you could do something like this:<br>&gt; <br>&gt; @warn_unused_result<br>&gt; public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: (result : T) throws -&gt; T) rethrows -&gt; T {<br>&gt;     return optional != nil ? optional! : try defaultValue(result: optional!)<br>&gt; }<br>&gt; <br>&gt; I am not an expert on this though. I would acknowledge that to the later examples with multiple statements may be harder to do. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; IMO, the problem you’re addressing is already adequately solved by guard.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160215/7873b06d/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 16, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; Am 16.02.2016 um 05:52 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I guess if auto closure could take a parameter you could do something like this:<br>&gt; <br>&gt; @warn_unused_result<br>&gt; public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: (result : T) throws -&gt; T) rethrows -&gt; T {<br>&gt;     return optional != nil ? optional! : try defaultValue(result: optional!)<br>&gt; }<br></p><p>This will always throw an exception as you are force unwrapping the optional in both branches of the ternary, i.e. also in the branch which is used when it is nil.<br></p><p>-Thorsten <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/9ec4da5b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>February 16, 2016 at 07:00:00am</p></header><div class="content"><p>Yeah, sorry did that kind of quick. Just trying to express the idea, maybe my implementation left something to be desired. I wanted the result not the optional. <br></p><p><br>&gt; On Feb 15, 2016, at 10:35 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Am 16.02.2016 um 05:52 schrieb Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt; <br>&gt;&gt; I guess if auto closure could take a parameter you could do something like this:<br>&gt;&gt; <br>&gt;&gt; @warn_unused_result<br>&gt;&gt; public func ??&lt;T&gt;(optional: T?, @autoclosure defaultValue: (result : T) throws -&gt; T) rethrows -&gt; T {<br>&gt;&gt;     return optional != nil ? optional! : try defaultValue(result: optional!)<br>&gt;&gt; }<br>&gt; <br>&gt; This will always throw an exception as you are force unwrapping the optional in both branches of the ternary, i.e. also in the branch which is used when it is nil.<br>&gt; <br>&gt; -Thorsten <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160216/4528418d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 15, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; To address this, the nil-coalescing operator would allow $$, where $$ is the unwrapped unnamed result of the expression when non nil: <br>&gt; <br>&gt; func doSomething(value: Int) -&gt; Int {<br>&gt;     return value<br>&gt; }<br>&gt; <br>&gt; let ra = a ?? doSomething($$) <br>&gt; let rc = c ?? doSomething($$)<br>&gt; <br>&gt; ra -&gt; 5<br>&gt; rc -&gt; nil<br></p><p>I think this is completely the wrong way to approach this.<br></p><p>*If* you want to implement this feature, I think the way to do it is to say that you can put ? after any optional parameter to a normal function call, and Swift will unwrap all the parameters so marked and make the call return `nil` if any of them are nil.<br></p><p>	let ra = doSomething(a?)<br>	let rc = doSomething(c?)<br></p><p>Naturally, since operators are just function calls with a funny syntax, this would also extend to operators.<br></p><p>	a? + b	// a.k.a. +(a?, b)<br></p><p>Even in this form, however, I don&#39;t think this is a feature worth having. Too indirect and specialized.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 29, 2016 at 01:00:00am</p></header><div class="content"><p>Jacob,<br></p><p>While working on proposal, I am just trying to understand one thing with this. In your second example using map, it is clear where the block of code begins. How would you deal with multiple statements or ones that returned no value:<br></p><p>    	manager.doSomething(data: data, count: n?); doSomethingElse( n?)<br></p><p>the equivalent with map is<br></p><p>	n.map { manager.doSomething(data: data, count: $0); doSomethingElse($0)  }<br></p><p>Thanks,<br>- Paul<br></p><p>&gt; On Jan 28, 2016, at 8:41 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in it, it becomes optional (it&#39;s basically optional chaining, but for function calls and other expressions instead of just dot-notation).<br>&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt; <br>&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt; <br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt; <br>&gt;&gt; which is equivalent to<br>&gt;&gt; <br>&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt; <br>&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Maybe something like this?<br>&gt;&gt; <br>&gt;&gt; let n : Int? = 5<br>&gt;&gt; <br>&gt;&gt; let r = n? + 5<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/02d64a61/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 29, 2016 at 05:00:00pm</p></header><div class="content"><p>Hi Paul,<br>I think the two statements would behave separately (as if you had used map<br>twice).<br></p><p>If you want them to act together, you could do this:<br></p><p>{ manager.doSomething(data: data, count: $0); doSomethingElse($0) }(n?)<br></p><p>Another aspect worth considering is whether this syntax should work with<br>multiple optionals used in the same expression. (e.g. if they are all<br>non-nil, the expression is evaluated.)<br>On Fri, Jan 29, 2016 at 1:53 AM Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; Jacob,<br>&gt;<br>&gt; While working on proposal, I am just trying to understand one thing with<br>&gt; this. In your second example using map, it is clear where the block of code<br>&gt; begins. How would you deal with multiple statements or ones that returned<br>&gt; no value:<br>&gt;<br>&gt;     manager.doSomething(data: data, count: n?); doSomethingElse( n?)<br>&gt;<br>&gt; the equivalent with map is<br>&gt;<br>&gt; n.map { manager.doSomething(data: data, count: $0); doSomethingElse($0)  }<br>&gt;<br>&gt; Thanks,<br>&gt; - Paul<br>&gt;<br>&gt; On Jan 28, 2016, at 8:41 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears<br>&gt; in it, it becomes optional (it&#39;s basically optional chaining, but for<br>&gt; function calls and other expressions instead of just dot-notation).<br>&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What if the return value of doSomething is not an optional?  Expressions<br>&gt;&gt; are easy — but there might be some conflicts with this one.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other<br>&gt;&gt; functions, such as<br>&gt;&gt;<br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;<br>&gt;&gt; which is equivalent to<br>&gt;&gt;<br>&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;<br>&gt;&gt; It might be hard to see exactly which operator/function applications such<br>&gt;&gt; a thing applies to, if used in the context of a complex expression.<br>&gt;&gt;<br>&gt;&gt; Jacob<br>&gt;&gt;<br>&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of<br>&gt;&gt;&gt; optionals, i.e. making explicit where optional cases occur and that<br>&gt;&gt;&gt; handling the missing case has to be considered.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end<br>&gt;&gt;&gt; of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when<br>&gt;&gt;&gt; it comes to optionals.  In most cases when you are computing etc. on an<br>&gt;&gt;&gt; Optional you would expect that you would want an optional result and things<br>&gt;&gt;&gt; to be able to use optionals.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In another language I generally just `map` one optional to another -<br>&gt;&gt;&gt; which may not be the most readable code to some not use to optionals.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would<br>&gt;&gt;&gt; rewrite the syntax to map from one to another value.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; would actually compile as<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/b104a30f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 29, 2016 at 09:00:00am</p></header><div class="content"><p>Yeah I was thinking about that too, multiple optionals. It gets a bit confusing as to the scope.  <br></p><p>Wondering if we should pass it on as an optional or not allow it? Something else?<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 29, 2016, at 9:26 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Paul,<br>&gt; I think the two statements would behave separately (as if you had used map twice).<br>&gt; <br>&gt; If you want them to act together, you could do this: <br>&gt; <br>&gt; { manager.doSomething(data: data, count: $0); doSomethingElse($0) }(n?)<br>&gt; <br>&gt; Another aspect worth considering is whether this syntax should work with multiple optionals used in the same expression. (e.g. if they are all non-nil, the expression is evaluated.)<br>&gt;&gt; On Fri, Jan 29, 2016 at 1:53 AM Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt; Jacob,<br>&gt;&gt; <br>&gt;&gt; While working on proposal, I am just trying to understand one thing with this. In your second example using map, it is clear where the block of code begins. How would you deal with multiple statements or ones that returned no value:<br>&gt;&gt; <br>&gt;&gt;     	manager.doSomething(data: data, count: n?); doSomethingElse( n?)<br>&gt;&gt; <br>&gt;&gt; the equivalent with map is<br>&gt;&gt; <br>&gt;&gt; 	n.map { manager.doSomething(data: data, count: $0); doSomethingElse($0)  }<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Paul<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 8:41 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in it, it becomes optional (it&#39;s basically optional chaining, but for function calls and other expressions instead of just dot-notation).<br>&gt;&gt;&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/9354df51/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Another conundrum: are the optional-pattern arguments evaluated before any<br>other arguments? After?<br>On Fri, Jan 29, 2016 at 9:54 AM Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; Yeah I was thinking about that too, multiple optionals. It gets a bit<br>&gt; confusing as to the scope.<br>&gt;<br>&gt; Wondering if we should pass it on as an optional or not allow it?<br>&gt; Something else?<br>&gt;<br>&gt; Sent from my iPhone<br>&gt;<br>&gt; On Jan 29, 2016, at 9:26 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hi Paul,<br>&gt; I think the two statements would behave separately (as if you had used map<br>&gt; twice).<br>&gt;<br>&gt; If you want them to act together, you could do this:<br>&gt;<br>&gt; { manager.doSomething(data: data, count: $0); doSomethingElse($0) }(n?)<br>&gt;<br>&gt; Another aspect worth considering is whether this syntax should work with<br>&gt; multiple optionals used in the same expression. (e.g. if they are all<br>&gt; non-nil, the expression is evaluated.)<br>&gt; On Fri, Jan 29, 2016 at 1:53 AM Paul Ossenbruggen &lt;possen at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Jacob,<br>&gt;&gt;<br>&gt;&gt; While working on proposal, I am just trying to understand one thing with<br>&gt;&gt; this. In your second example using map, it is clear where the block of code<br>&gt;&gt; begins. How would you deal with multiple statements or ones that returned<br>&gt;&gt; no value:<br>&gt;&gt;<br>&gt;&gt;     manager.doSomething(data: data, count: n?); doSomethingElse( n?)<br>&gt;&gt;<br>&gt;&gt; the equivalent with map is<br>&gt;&gt;<br>&gt;&gt; n.map { manager.doSomething(data: data, count: $0); doSomethingElse($0)  }<br>&gt;&gt;<br>&gt;&gt; Thanks,<br>&gt;&gt; - Paul<br>&gt;&gt;<br>&gt;&gt; On Jan 28, 2016, at 8:41 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears<br>&gt;&gt; in it, it becomes optional (it&#39;s basically optional chaining, but for<br>&gt;&gt; function calls and other expressions instead of just dot-notation).<br>&gt;&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What if the return value of doSomething is not an optional?  Expressions<br>&gt;&gt;&gt; are easy — but there might be some conflicts with this one.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other<br>&gt;&gt;&gt; functions, such as<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It might be hard to see exactly which operator/function applications<br>&gt;&gt;&gt; such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of<br>&gt;&gt;&gt;&gt; optionals, i.e. making explicit where optional cases occur and that<br>&gt;&gt;&gt;&gt; handling the missing case has to be considered.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end<br>&gt;&gt;&gt;&gt; of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when<br>&gt;&gt;&gt;&gt; it comes to optionals.  In most cases when you are computing etc. on an<br>&gt;&gt;&gt;&gt; Optional you would expect that you would want an optional result and things<br>&gt;&gt;&gt;&gt; to be able to use optionals.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another -<br>&gt;&gt;&gt;&gt; which may not be the most readable code to some not use to optionals.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would<br>&gt;&gt;&gt;&gt; rewrite the syntax to map from one to another value.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; would actually compile as<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/17a8aacb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 30, 2016 at 06:00:00am</p></header><div class="content"><p>I would think it would be functionally equivalent to Scala.<br></p><p>for {<br>   o1 &lt;- optional1<br>   o2 &lt;- optional2<br>   ..<br>} yield { manager.doSumething(data, o1, o2) }<br></p><p>which is a combination of maps and flatMaps.<br></p><p>&gt; On 2016-01-30, at 1:06:00, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Another conundrum: are the optional-pattern arguments evaluated before any other arguments? After?<br>&gt; On Fri, Jan 29, 2016 at 9:54 AM Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt; Yeah I was thinking about that too, multiple optionals. It gets a bit confusing as to the scope.  <br>&gt; <br>&gt; Wondering if we should pass it on as an optional or not allow it? Something else?<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Jan 29, 2016, at 9:26 AM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Hi Paul,<br>&gt;&gt; I think the two statements would behave separately (as if you had used map twice).<br>&gt;&gt; <br>&gt;&gt; If you want them to act together, you could do this: <br>&gt;&gt; <br>&gt;&gt; { manager.doSomething(data: data, count: $0); doSomethingElse($0) }(n?)<br>&gt;&gt; <br>&gt;&gt; Another aspect worth considering is whether this syntax should work with multiple optionals used in the same expression. (e.g. if they are all non-nil, the expression is evaluated.)<br>&gt;&gt; On Fri, Jan 29, 2016 at 1:53 AM Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Jacob,<br>&gt;&gt; <br>&gt;&gt; While working on proposal, I am just trying to understand one thing with this. In your second example using map, it is clear where the block of code begins. How would you deal with multiple statements or ones that returned no value:<br>&gt;&gt; <br>&gt;&gt;     	manager.doSomething(data: data, count: n?); doSomethingElse( n?)<br>&gt;&gt; <br>&gt;&gt; the equivalent with map is<br>&gt;&gt; <br>&gt;&gt; 	n.map { manager.doSomething(data: data, count: $0); doSomethingElse($0)  }<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; - Paul<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 28, 2016, at 8:41 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;d be the point. If doSomething were not optional, when &quot;n?&quot; appears in it, it becomes optional (it&#39;s basically optional chaining, but for function calls and other expressions instead of just dot-notation).<br>&gt;&gt;&gt; On Thu, Jan 28, 2016 at 8:38 PM Craig Cruden &lt;ccruden at novafore.com &lt;mailto:ccruden at novafore.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/42ec212a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>January 30, 2016 at 04:00:00pm</p></header><div class="content"><p>The for translates into:<br></p><p>o1.flatMap(x =&gt; o2.map(y =&gt; manager.doSumething(data, x, y)))<br></p><p>&gt; On 2016-01-30, at 6:15:18, Craig Cruden &lt;ccruden at novafore.com&gt; wrote:<br>&gt; <br>&gt; I would think it would be functionally equivalent to Scala.<br>&gt; <br>&gt; for {<br>&gt;    o1 &lt;- optional1<br>&gt;    o2 &lt;- optional2<br>&gt;    ..<br>&gt; } yield { manager.doSumething(data, o1, o2) }<br>&gt; <br>&gt; which is a combination of maps and flatMaps.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/102639f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 30, 2016 at 09:00:00am</p></header><div class="content"><p>This is all still in the brainstorming realm. The issue is that doSomething looks like it should always be called. I think that the nil coalescing operator works here:<br></p><p>func doSomething(value: Int) -&gt; Int {<br>    return value<br>}<br>let pf : Int? = 5<br>let py : Int? = nil<br></p><p>// the following is:<br>let gf = pf ?? doSomething(pf!) <br>let gy = py ?? doSomething(py!)<br></p><p>gf -&gt; 5<br>gy -&gt; nil<br></p><p>// is the equivalent of:<br>let ff = pf.map { doSomething($0) }<br>let fy = py.map { doSomething($0) }<br></p><p>ff -&gt; 5<br>fy -&gt; nil<br></p><p>This works with the language as it stands today but I don’t like the forced unwrap. However, with the rest of the proposal this would work because  pf? would give you the unwrapped value, which would not be nil at that point.<br></p><p>let gf = pf ?? doSomething(pf?) <br>let gy = py ?? doSomething(py?)<br></p><p><br>But one outstanding issue is that gf and gy would not be optional unless you explicitly write out the type like this.<br></p><p>let gf : Int? = pf ?? doSomething(pf?) <br>let gy : Int? = py ?? doSomething(py?)<br></p><p>I think this is in line with the language as it is today. Unless we want to add a new sugar to upgrade an optional <br></p><p>let gf? = pf ?? doSomething(pf?) <br>let gy? = py ?? doSomething(py?)<br></p><p>where if there is a let or var assignment with a question mark the type is upgraded to an optional.<br></p><p>------<br></p><p>Moving back to the more complex example. The more complex example would require another construct. We would need to have a way to add a block.for nil coalescing but pretty sure that would not be approved and it probably creates other problems. Assuming that doSomething else is a void function. <br></p><p>  let dd  = n ?? { manager.doSomething(data: data, count: n!); doSomethingElse( n! ) }<br></p><p>So without adding more constructs you would have to do this for the more complex example:<br></p><p>   let dd  = n ??  manager.doSomething(data: data, count: n?)<br>   if let n = n {<br>   	doSomethingElse( n ) <br>  }<br></p><p>In which case you might as well do this:<br></p><p>   let dd : Int? = nil<br>   if let n = n {<br>	 dd = manager.doSomething(data: data, count: n)<br>   	 doSomethingElse( n ) <br>  }<br></p><p>But I think the more complex example will be rare and the last example is fine should you have a complex situation<br></p><p><br>&gt; Another conundrum: are the optional-pattern arguments evaluated before any other arguments? After?<br></p><p>&gt; I think the two statements would behave separately (as if you had used map twice).<br>&gt; <br>&gt; If you want them to act together, you could do this: <br>&gt; <br>&gt; { manager.doSomething(data: data, count: $0); doSomethingElse($0) }(n?)<br>&gt; <br>&gt; Another aspect worth considering is whether this syntax should work with multiple optionals used in the same expression. (e.g. if they are all non-nil, the expression is evaluated.)<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/5d94e505/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>January 29, 2016 at 08:00:00pm</p></header><div class="content"><p>I&#39;m not sure this is even possible (at least on x86/ARM), but could we do something like how the Mill CPU handles errors?<br></p><p>If you&#39;re not familiar with it, my understanding is that it just ignores errors (and cascades them through operations) until you try to write the invalid value to memory, at which point the exception is raised.<br></p><p>Seems like, in principle anyway, if Swift supported pure functions, the compiler could just silently propagate the nil until you try to store it in a non-optional variable, at which point you&#39;d get the standard &quot;didn&#39;t unwrap optional&quot; error.<br></p><p>Like I said, I&#39;m not sure this is even possible for compiled code, if the target platform doesn&#39;t have hardware support for it anyway.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Jan 28, 2016, at 20:38, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt; <br>&gt; What if the return value of doSomething is not an optional?  Expressions are easy — but there might be some conflicts with this one.<br>&gt; <br>&gt; <br>&gt;&gt; On 2016-01-28, at 14:34:58, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt; <br>&gt;&gt;     manager.doSomething(data: data, count: n?)<br>&gt;&gt; <br>&gt;&gt; which is equivalent to<br>&gt;&gt; <br>&gt;&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt; <br>&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Jan 27, 2016 at 9:50 PM, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; Maybe something like this?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let r = n? + 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:46 PM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Too much hidden magic IMO. This would mean loosing the benefits of optionals, i.e. making explicit where optional cases occur and that handling the missing case has to be considered. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Am 28.01.2016 um 06:30 schrieb Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes<br>&gt;&gt;&gt;&gt;&gt;&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trying to see if I got this. So the type of r would be Int? at the end of this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift currently encourages a lot of conditional code - especially when it comes to optionals.  In most cases when you are computing etc. on an Optional you would expect that you would want an optional result and things to be able to use optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In another language I generally just `map` one optional to another - which may not be the most readable code to some not use to optionals.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was wondering if maybe an expression is not available that it would rewrite the syntax to map from one to another value.  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So things like:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let n : Int? = 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n + 5<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; would actually compile as <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let r = n.map {$0 + 5}<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160129/796c32f9/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 27, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt; <br>&gt;     manager.doSomething(data: data, count: n?)<br>&gt; <br>&gt; which is equivalent to<br>&gt; <br>&gt;     n.map { manager.doSomething(data: data, count: $0) }<br>&gt; <br>&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br></p><p>Yes, this would be a major problem with this sort of feature. Without some explicit delimiter for the bounds of the map operation, you have either extremely subtle rules for defining the implicit bounds, or an exponential type-checking problem figuring it out from context. <br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 30, 2016 at 09:00:00pm</p></header><div class="content"><p>This is what I came up with so far. As Joe points out, it needs delimiters for more complex maps. Assume this for the examples:<br></p><p>func doSomething(value: Int) -&gt; Int {<br>    return value<br>}<br>let pf : Int? = 5<br>let pg : Int? = nil<br></p><p>for simple expressions you could do this which is a pretty big win:<br></p><p>let gf = pf? + 5<br></p><p>For cases where the expression should not call a function if a parameter is nil, I came up with this for syntactic sugar which has delimiters. Inside the brackets the variable name is unwrapped automatically and real name of the variable is used. rather than $0. It is a win over the if let approach:<br></p><p>// if let approach<br>let ff : Int? = nil<br>if let pf = pf {<br> ff = doSomething(pf) <br>}  <br></p><p>// the delimited approach is:<br>let gf = pf?{ doSomething(pf) }  // pf not nil doSomething is called<br>let gg = pg?{ doSomething(pg) }  // pg is nil doSomething is not called.<br></p><p>gf -&gt; 5<br>gg -&gt; nil<br></p><p>// which is the equivalent of the map approach:<br>let ff = pf.map { doSomething($0) }<br>let fg = pg.map { doSomething($0) }<br></p><p>ff -&gt; 5<br>fg -&gt; nil<br></p><p>Assuming that this syntax is not a big enough win over the map version, This means that in this situation, you need to use map.. If doSomething() took an optional though you could do this, because doSomething would always be called.<br></p><p>let gf = doSomething(pf?)  // result is optional, could also omit “?&quot;<br>let hf = doSomething(pf? + 5) // result is still an optional<br></p><p>- Paul<br>&gt; On Jan 30, 2016, at 10:28 AM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 27, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt; <br>&gt;&gt;    manager.doSomething(data: data, count: n?)<br>&gt;&gt; <br>&gt;&gt; which is equivalent to<br>&gt;&gt; <br>&gt;&gt;    n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt; <br>&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt; <br>&gt; Yes, this would be a major problem with this sort of feature. Without some explicit delimiter for the bounds of the map operation, you have either extremely subtle rules for defining the implicit bounds, or an exponential type-checking problem figuring it out from context. <br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160130/5f89752f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>January 31, 2016 at 08:00:00pm</p></header><div class="content"><p>I don’t think I can go any further on the proposal until this is worked out. Any ideas or feedback would be welcome. <br></p><p>Options so far are:<br>• Only add simple expressions  use map for cases where code is conditionally executed after the map<br>• Add simple expressions and delimited approach for cases where the code is conditionally executed after the map.<br>• Some other ideas<br>• Forget about the proposal. <br></p><p><br>&gt; On Jan 30, 2016, at 9:24 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt; <br>&gt; This is what I came up with so far. As Joe points out, it needs delimiters for more complex maps. Assume this for the examples:<br>&gt; <br>&gt; func doSomething(value: Int) -&gt; Int {<br>&gt;     return value<br>&gt; }<br>&gt; let pf : Int? = 5<br>&gt; let pg : Int? = nil<br>&gt; <br>&gt; for simple expressions you could do this which is a pretty big win:<br>&gt; <br>&gt; let gf = pf? + 5<br>&gt; <br>&gt; For cases where the expression should not call a function if a parameter is nil, I came up with this for syntactic sugar which has delimiters. Inside the brackets the variable name is unwrapped automatically and real name of the variable is used. rather than $0. It is a win over the if let approach:<br>&gt; <br>&gt; // if let approach<br>&gt; let ff : Int? = nil<br>&gt; if let pf = pf {<br>&gt;  ff = doSomething(pf) <br>&gt; }  <br>&gt; <br>&gt; // the delimited approach is:<br>&gt; let gf = pf?{ doSomething(pf) }  // pf not nil doSomething is called<br>&gt; let gg = pg?{ doSomething(pg) }  // pg is nil doSomething is not called.<br>&gt; <br>&gt; gf -&gt; 5<br>&gt; gg -&gt; nil<br>&gt; <br>&gt; // which is the equivalent of the map approach:<br>&gt; let ff = pf.map { doSomething($0) }<br>&gt; let fg = pg.map { doSomething($0) }<br>&gt; <br>&gt; ff -&gt; 5<br>&gt; fg -&gt; nil<br>&gt; <br>&gt; Assuming that this syntax is not a big enough win over the map version, This means that in this situation, you need to use map.. If doSomething() took an optional though you could do this, because doSomething would always be called.<br>&gt; <br>&gt; let gf = doSomething(pf?)  // result is optional, could also omit “?&quot;<br>&gt; let hf = doSomething(pf? + 5) // result is still an optional<br>&gt; <br>&gt; - Paul<br>&gt;&gt; On Jan 30, 2016, at 10:28 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt; <br>&gt;&gt; Yes, this would be a major problem with this sort of feature. Without some explicit delimiter for the bounds of the map operation, you have either extremely subtle rules for defining the implicit bounds, or an exponential type-checking problem figuring it out from context. <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160131/1458faee/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February  1, 2016 at 01:00:00pm</p></header><div class="content"><p>I would think the extra delimiters would just make it hairy — so if it were delimiter or not being able to be done I would think you would assign an intermediary value to another let.  <br></p><p>i.e. <br></p><p>let n = pf? + 5<br>let hf = doSomething(n?)<br></p><p>—<br></p><p>That being said I don’t see why their could not be a rule for inferred unwrapping.  So if a function parameter was defined as Int and it was passed Some(Int) it would execute, but if it were None/Nil then it would skip execution.  <br></p><p><br>&gt; On 2016-01-31, at 12:24:03, Paul Ossenbruggen via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This is what I came up with so far. As Joe points out, it needs delimiters for more complex maps. Assume this for the examples:<br>&gt; <br>&gt; func doSomething(value: Int) -&gt; Int {<br>&gt;     return value<br>&gt; }<br>&gt; let pf : Int? = 5<br>&gt; let pg : Int? = nil<br>&gt; <br>&gt; for simple expressions you could do this which is a pretty big win:<br>&gt; <br>&gt; let gf = pf? + 5<br>&gt; <br>&gt; For cases where the expression should not call a function if a parameter is nil, I came up with this for syntactic sugar which has delimiters. Inside the brackets the variable name is unwrapped automatically and real name of the variable is used. rather than $0. It is a win over the if let approach:<br>&gt; <br>&gt; // if let approach<br>&gt; let ff : Int? = nil<br>&gt; if let pf = pf {<br>&gt;  ff = doSomething(pf) <br>&gt; }  <br>&gt; <br>&gt; // the delimited approach is:<br>&gt; let gf = pf?{ doSomething(pf) }  // pf not nil doSomething is called<br>&gt; let gg = pg?{ doSomething(pg) }  // pg is nil doSomething is not called.<br>&gt; <br>&gt; gf -&gt; 5<br>&gt; gg -&gt; nil<br>&gt; <br>&gt; // which is the equivalent of the map approach:<br>&gt; let ff = pf.map { doSomething($0) }<br>&gt; let fg = pg.map { doSomething($0) }<br>&gt; <br>&gt; ff -&gt; 5<br>&gt; fg -&gt; nil<br>&gt; <br>&gt; Assuming that this syntax is not a big enough win over the map version, This means that in this situation, you need to use map.. If doSomething() took an optional though you could do this, because doSomething would always be called.<br>&gt; <br>&gt; let gf = doSomething(pf?)  // result is optional, could also omit “?&quot;<br>&gt; let hf = doSomething(pf? + 5) // result is still an optional<br>&gt; <br>&gt; - Paul<br>&gt;&gt; On Jan 30, 2016, at 10:28 AM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 27, 2016, at 11:34 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve wanted this sort of thing a lot. It would also work for other functions, such as<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    manager.doSomething(data: data, count: n?)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; which is equivalent to<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    n.map { manager.doSomething(data: data, count: $0) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be hard to see exactly which operator/function applications such a thing applies to, if used in the context of a complex expression.<br>&gt;&gt; <br>&gt;&gt; Yes, this would be a major problem with this sort of feature. Without some explicit delimiter for the bounds of the map operation, you have either extremely subtle rules for defining the implicit bounds, or an exponential type-checking problem figuring it out from context. <br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160201/625b8b1f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Brainstorming: Optional sugar inferred map</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>January 28, 2016 at 05:00:00pm</p></header><div class="content"><p>Assuming Paul is correct then you require Optional to be a sequence type<br>and you would use flatMap. I believe there has been such discussions in the<br>past but they don&#39;t seem to have gone anywhere. Java and Scala both do what<br>you want with their sequence types, maybe Swift will follow :).<br></p><p>On 28 January 2016 at 16:30, Craig Cruden via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yes<br>&gt;<br>&gt; On 2016-01-28, at 12:28:40, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br>&gt;<br>&gt; Trying to see if I got this. So the type of r would be Int? at the end of<br>&gt; this? And if n were nil then r would be nil? Otherwise it r is 10?<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Jan 27, 2016, at 9:19 PM, Craig Cruden via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Swift currently encourages a lot of conditional code - especially when it<br>&gt; comes to optionals.  In most cases when you are computing etc. on an<br>&gt; Optional you would expect that you would want an optional result and things<br>&gt; to be able to use optionals.<br>&gt;<br>&gt; In another language I generally just `map` one optional to another - which<br>&gt; may not be the most readable code to some not use to optionals.<br>&gt;<br>&gt; I was wondering if maybe an expression is not available that it would<br>&gt; rewrite the syntax to map from one to another value.<br>&gt;<br>&gt; So things like:<br>&gt;<br>&gt; let n : Int? = 5<br>&gt;<br>&gt; let r = n + 5<br>&gt;<br>&gt; would actually compile as<br>&gt;<br>&gt; let r = n.map {$0 + 5}<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>  -- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160128/d31c3dd8/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
