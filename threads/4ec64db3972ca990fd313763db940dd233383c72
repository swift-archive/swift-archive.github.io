<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 04:00:00am</p></header><div class="content"><p>‘If I understand the other discussions regarding the evolution of Swift&#39;s function arguments model, the similarity to tuples with labeled components is a historical artifact and now merely coincidental.’<br></p><p>Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br></p><p>Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br></p><p>------------ Begin Message ------------ <br>Group: gmane.comp.lang.swift.evolution <br>MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br></p><p>On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br></p><p>&gt;Hello Swift community,<br>&gt;<br>&gt;The review of &quot;SE-0111: Remove type system significance of function<br>&gt;argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;available here:<br>&gt;<br>&gt;<br>&gt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;<br>&gt;Reviews are an important part of the Swift evolution process. All reviews<br>&gt;should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;or, if you would like to keep your feedback private, directly to the<br>&gt;review manager.<br>&gt;<br>&gt;What goes into a review?<br>&gt;<br>&gt;The goal of the review process is to improve the proposal under review<br>&gt;through constructive criticism and contribute to the direction of Swift.<br>&gt;When writing your review, here are some questions you might want to answer<br>&gt;in your review:<br>&gt;<br>&gt;* What is your evaluation of the proposal?<br>&gt;<br></p><p>+1. I&#39;m in agreement with others in this thread who say that the labels are<br>parts of the *name* of the function, not parts of its *type*. If I<br>understand the other discussions regarding the evolution of Swift&#39;s<br>function arguments model, the similarity to tuples with labeled components<br>is a historical artifact and now merely coincidental.<br></p><p>The analogy to Objective-C here is obvious, where you have selectors<br>instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>contains all of the parts, not just the base name.<br></p><p>Swift function names to me are like German separable verbs. Even when<br>they&#39;re split across the sentence with multiple words in-between, the<br>prefix is still considered part of that verb, not a separate word/concept.<br></p><p><br></p><p>&gt;* Is the problem being addressed significant enough to warrant a<br>&gt;change to Swift?<br>&gt;<br></p><p>Yes.<br></p><p><br></p><p>&gt;* Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>of argument names to differentiate between overloads with the same argument<br>types at the same positions. To me, this is another admission that the<br>labels are part of the function&#39;s *name*.<br></p><p><br></p><p>&gt;* If you have used other languages or libraries with a similar<br>&gt;feature, how do you feel that this proposal compares to those?<br>&gt;<br></p><p>Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>have named/keyword arguments (like Python) are dynamic languages that treat<br>the incoming argument list as a dictionary; in that case, the language<br>design is significantly different and I can&#39;t draw an analogy between them.<br></p><p><br>&gt;* How much effort did you put into your review? A glance, a quick<br>&gt;reading, or an in-depth study?<br>&gt;<br></p><p>Read the proposal and loosely followed the discussion.<br></p><p><br>&gt;<br>&gt;More information about the Swift evolution process is available at<br>&gt;<br>&gt;https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt;Thank you,<br>&gt;<br>&gt;-Chris Lattner<br>&gt;Review Manager<br>&gt;<br>&gt;<br>&gt;_______________________________________________<br>&gt;swift-evolution mailing list<br>&gt;swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>------------- End Message ------------- <br></p><p><br></p><p>From James F<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 8:15 PM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; ‘If I understand the other discussions regarding the evolution of Swift&#39;s function arguments model, the similarity to tuples with labeled components is a historical artifact and now merely coincidental.’<br></p><p>It&#39;s been stated repeatedly in this thread and many others that modeling argument lists as tuples is a non-goal.<br></p><p>&gt; <br>&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br></p><p>Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br></p><p>&gt; <br>&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br></p><p>Tuples have many, many uses apart from modeling argument lists.<br></p><p>&gt; <br>&gt; ------------ Begin Message ------------ <br>&gt; Group: gmane.comp.lang.swift.evolution <br>&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt; <br>&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt; available here:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt; <br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt; <br>&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt; function arguments model, the similarity to tuples with labeled components<br>&gt; is a historical artifact and now merely coincidental.<br>&gt; <br>&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt; contains all of the parts, not just the base name.<br>&gt; <br>&gt; Swift function names to me are like German separable verbs. Even when<br>&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt; <br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt; <br>&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt; of argument names to differentiate between overloads with the same argument<br>&gt; types at the same positions. To me, this is another admission that the<br>&gt; labels are part of the function&#39;s *name*.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt; <br>&gt; <br>&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt; <br>&gt; <br>&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt; <br>&gt; <br>&gt; Read the proposal and loosely followed the discussion.<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; ------------- End Message ------------- <br>&gt; <br>&gt; <br>&gt; <br>&gt; From James F<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 2 Jul 2016, at 04:22, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 8:15 PM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; ‘If I understand the other discussions regarding the evolution of Swift&#39;s function arguments model, the similarity to tuples with labeled components is a historical artifact and now merely coincidental.’<br>&gt; <br>&gt; It&#39;s been stated repeatedly in this thread and many others that modeling argument lists as tuples is a non-goal.<br>&gt; <br></p><p>See https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/023221.html<br></p><p>It may be a non-goal, but there are reasons relating to generics/variadics that make doing so advantageous. If we&#39;re considering moving labels to the container&#39;s name, then we&#39;re moving to a model where such a thing may be more practical, so it may be appropriate to reassess this.<br></p><p>&gt;&gt; <br>&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt; <br>&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt; <br></p><p>This seems just the same problem as not being able to assign:<br></p><p>(a: Int, b: Int) -&gt; ()<br></p><p>to a type of:<br></p><p>(x: Int, y: Int) -&gt; ()<br></p><p>Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br></p><p>&gt;&gt; <br>&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt; <br>&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt; <br></p><p>• lightweight structs<br>• loosely-typed structs<br>• …as structs<br></p><p>There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br></p><p>So there&#39;s nothing really making a compelling argument here.<br></p><p>&gt;&gt; <br>&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt;&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt; available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt; <br>&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt; <br>&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; ------------- End Message ------------- <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/bf5b7aa3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 8:37 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 2 Jul 2016, at 04:22, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 8:15 PM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ‘If I understand the other discussions regarding the evolution of Swift&#39;s function arguments model, the similarity to tuples with labeled components is a historical artifact and now merely coincidental.’<br>&gt;&gt; <br>&gt;&gt; It&#39;s been stated repeatedly in this thread and many others that modeling argument lists as tuples is a non-goal.<br>&gt;&gt; <br>&gt; <br>&gt; See https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/023221.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/023221.html&gt;<br>&gt; <br>&gt; It may be a non-goal, but there are reasons relating to generics/variadics that make doing so advantageous. If we&#39;re considering moving labels to the container&#39;s name, then we&#39;re moving to a model where such a thing may be more practical, so it may be appropriate to reassess this.<br></p><p>This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt; <br>&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt; <br>&gt; <br>&gt; This seems just the same problem as not being able to assign:<br>&gt; <br>&gt; (a: Int, b: Int) -&gt; ()<br>&gt; <br>&gt; to a type of:<br>&gt; <br>&gt; (x: Int, y: Int) -&gt; ()<br>&gt; <br>&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br></p><p>There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br></p><p>So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt; <br>&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt; <br>&gt; <br>&gt; • lightweight structs<br>&gt; • loosely-typed structs<br>&gt; • …as structs<br>&gt; <br>&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt; <br>&gt; So there&#39;s nothing really making a compelling argument here.<br></p><p>What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com &lt;mailto:CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/4a09ec41/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 8:37 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 2 Jul 2016, at 04:22, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jul 1, 2016, at 8:15 PM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ‘If I understand the other discussions regarding the evolution of Swift&#39;s function arguments model, the similarity to tuples with labeled components is a historical artifact and now merely coincidental.’<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;s been stated repeatedly in this thread and many others that modeling argument lists as tuples is a non-goal.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; See https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160627/023221.html<br>&gt;&gt; <br>&gt;&gt; It may be a non-goal, but there are reasons relating to generics/variadics that make doing so advantageous. If we&#39;re considering moving labels to the container&#39;s name, then we&#39;re moving to a model where such a thing may be more practical, so it may be appropriate to reassess this.<br>&gt; <br>&gt; This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br>&gt; <br></p><p>Fair point, but it seems this could stand as a lightweight complement to generics. There seems to be a lack of support for the side of keeping what functionality we already have in this area.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt; <br>&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; to a type of:<br>&gt;&gt; <br>&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt; <br>&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br>&gt; <br>&gt; There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br>&gt; <br>&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br>&gt; <br></p><p>Sorry, I meant the reasoning for removing them from the type system. As you said, there was a better argument. I&#39;m observing that this may once again be the case following this change.<br></p><p>It doesn&#39;t help that this went through to the wrong thread, and the quick email I sent to acknowledge this has fallen in a hole somewhere.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; • lightweight structs<br>&gt;&gt; • loosely-typed structs<br>&gt;&gt; • …as structs<br>&gt;&gt; <br>&gt;&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt; <br>&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt; <br>&gt; What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt; <br></p><p>I&#39;m not sure how to interpret this, sorry.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/8b667080/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>July  1, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt; <br>&gt; <br>&gt; Fair point, but it seems this could stand as a lightweight complement to generics. There seems to be a lack of support for the side of keeping what functionality we already have in this area.<br></p><p>FWIW, I liked and used tuple splat before it was removed from the language.<br></p><p>I thought about it, and I think a lightweight, limited form of tuple application would probably be worth pursuing even before variadic generics go into the language (especially since they are a low-priority item). Perhaps someone could draft a proposal for Swift 3.1.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; to a type of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt; <br>&gt;&gt; There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br>&gt;&gt; <br>&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br>&gt;&gt; <br>&gt; <br>&gt; Sorry, I meant the reasoning for removing them from the type system. As you said, there was a better argument. I&#39;m observing that this may once again be the case following this change.<br></p><p><br>I still think it would be a bit odd to have (e.g.) a rejuvenated tuple splatter try to enforce the labels on whatever tuples you pass to it, since those labels would necessarily be tied to a specific function&#39;s name, rather than the meaning of the arguments themselves. Do you think there would be too much room for programmer error if such a splatter necessarily took in unlabeled tuples? (Right now any labeled tuple is interchangeable with a non-labeled tuple with the same constituent types...)<br></p><p>&gt; <br>&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; • lightweight structs<br>&gt;&gt;&gt; • loosely-typed structs<br>&gt;&gt;&gt; • …as structs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt; <br>&gt;&gt; What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt; <br>&gt; <br>&gt; I&#39;m not sure how to interpret this, sorry.<br></p><p>Perhaps I misunderstood your original point. In that case, I apologize.<br></p><p>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com &lt;mailto:CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md &lt;https://github.com/apple/swift-evolution/blob/master/process.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org &lt;mailto:swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/feebd4df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Fair point, but it seems this could stand as a lightweight complement to generics. There seems to be a lack of support for the side of keeping what functionality we already have in this area.<br>&gt; <br>&gt; FWIW, I liked and used tuple splat before it was removed from the language.<br>&gt; <br>&gt; I thought about it, and I think a lightweight, limited form of tuple application would probably be worth pursuing even before variadic generics go into the language (especially since they are a low-priority item). Perhaps someone could draft a proposal for Swift 3.1.<br>&gt; <br></p><p>This is why I support keeping what existing semantics we can, rather than stripping it all out only to reimplement it as soon as people realise it&#39;s missing.<br></p><p>The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br></p><p>A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; to a type of:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sorry, I meant the reasoning for removing them from the type system. As you said, there was a better argument. I&#39;m observing that this may once again be the case following this change.<br>&gt; <br>&gt; <br>&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple splatter try to enforce the labels on whatever tuples you pass to it, since those labels would necessarily be tied to a specific function&#39;s name, rather than the meaning of the arguments themselves. Do you think there would be too much room for programmer error if such a splatter necessarily took in unlabeled tuples? (Right now any labeled tuple is interchangeable with a non-labeled tuple with the same constituent types...)<br>&gt; <br></p><p>My idea is that if we switch to using:<br></p><p>let functionType(a:b:) = add(_:_:)<br></p><p>then it make sense to have tuples match this syntax, to avoid having two similar naming mechanisms with very different semantics:<br></p><p>let values(x:y:) = (1, 2)<br></p><p>Like a function&#39;s argument labels are rarely sensible out of context, tuples are best passed around without considering their labels. For example:<br></p><p>let name: (first: String, last: String) = …<br></p><p>name.first //clear<br></p><p>func join(stringTuple: (String, String))<br></p><p>join(stringTuple: name) //is this allowed?<br></p><p><br>At this point (generally as soon as the tuple leaves the context of its containing variable), the original parameter labels are meaningless. Alternatively:<br></p><p><br>let name(first:last:): (String, String) = …<br></p><p>name.first //still clear<br></p><p>join(name) //clearly allowed, since the labels are not part of the type<br></p><p><br>With this, if I understand you properly, argument names wouldn&#39;t be present in the type system to begin with, so calling the result of a splatter would be predictable:<br></p><p>join(a: String, b: String)<br></p><p>let splatted: ((String, String)) -&gt; () = splat(join) // or splat( join(a:b:) )<br></p><p>splatted(name) // or splatted( name(first:last:) )<br></p><p>&gt;&gt; <br>&gt;&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; • lightweight structs<br>&gt;&gt;&gt;&gt; • loosely-typed structs<br>&gt;&gt;&gt;&gt; • …as structs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt; <br>&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt;&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt;&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt;&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt;&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt;&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt;&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt;&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt;&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/9f78f4e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 05:00:00am</p></header><div class="content"><p>&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br></p><p>Effectively the presence of parameter annotations in a tuple make it a ‘splat-only tuple’.<br></p><p>From James F<br></p><p>&gt; On 2 Jul 2016, at 05:38, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Fair point, but it seems this could stand as a lightweight complement to generics. There seems to be a lack of support for the side of keeping what functionality we already have in this area.<br>&gt;&gt; <br>&gt;&gt; FWIW, I liked and used tuple splat before it was removed from the language.<br>&gt;&gt; <br>&gt;&gt; I thought about it, and I think a lightweight, limited form of tuple application would probably be worth pursuing even before variadic generics go into the language (especially since they are a low-priority item). Perhaps someone could draft a proposal for Swift 3.1.<br>&gt;&gt; <br>&gt; <br>&gt; This is why I support keeping what existing semantics we can, rather than stripping it all out only to reimplement it as soon as people realise it&#39;s missing.<br>&gt; <br>&gt; The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br>&gt; <br>&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; to a type of:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I meant the reasoning for removing them from the type system. As you said, there was a better argument. I&#39;m observing that this may once again be the case following this change.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple splatter try to enforce the labels on whatever tuples you pass to it, since those labels would necessarily be tied to a specific function&#39;s name, rather than the meaning of the arguments themselves. Do you think there would be too much room for programmer error if such a splatter necessarily took in unlabeled tuples? (Right now any labeled tuple is interchangeable with a non-labeled tuple with the same constituent types...)<br>&gt;&gt; <br>&gt; <br>&gt; My idea is that if we switch to using:<br>&gt; <br>&gt; let functionType(a:b:) = add(_:_:)<br>&gt; <br>&gt; then it make sense to have tuples match this syntax, to avoid having two similar naming mechanisms with very different semantics:<br>&gt; <br>&gt; let values(x:y:) = (1, 2)<br>&gt; <br>&gt; Like a function&#39;s argument labels are rarely sensible out of context, tuples are best passed around without considering their labels. For example:<br>&gt; <br>&gt; let name: (first: String, last: String) = …<br>&gt; <br>&gt; name.first //clear<br>&gt; <br>&gt; func join(stringTuple: (String, String))<br>&gt; <br>&gt; join(stringTuple: name) //is this allowed?<br>&gt; <br>&gt; <br>&gt; At this point (generally as soon as the tuple leaves the context of its containing variable), the original parameter labels are meaningless. Alternatively:<br>&gt; <br>&gt; <br>&gt; let name(first:last:): (String, String) = …<br>&gt; <br>&gt; name.first //still clear<br>&gt; <br>&gt; join(name) //clearly allowed, since the labels are not part of the type<br>&gt; <br>&gt; <br>&gt; With this, if I understand you properly, argument names wouldn&#39;t be present in the type system to begin with, so calling the result of a splatter would be predictable:<br>&gt; <br>&gt; join(a: String, b: String)<br>&gt; <br>&gt; let splatted: ((String, String)) -&gt; () = splat(join) // or splat( join(a:b:) )<br>&gt; <br>&gt; splatted(name) // or splatted( name(first:last:) )<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; • lightweight structs<br>&gt;&gt;&gt;&gt;&gt; • loosely-typed structs<br>&gt;&gt;&gt;&gt;&gt; • …as structs<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt;&gt; <br>&gt;&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/550fea05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  2, 2016 at 05:00:00am</p></header><div class="content"><p>What&#39;s the basis for your claim that tuples are best passed around without<br>their labels? If I have `typealias CartesianCoordinates = (x: Double, y:<br>Double)`, these labels are absolutely meaningful, and I would not want them<br>to be interchangeable with a hypothetical `typealias PolarCoordinates = (r:<br>Double, theta: Double)`. Although argument labels are part of the name,<br>tuple labels are part of the type; there are good reasons for that, and the<br>two are no longer meant to be similar. This proposal takes us the rest of<br>the way in clarifying this important distinction.<br>On Fri, Jul 1, 2016 at 11:52 PM James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple +<br>&gt; annotations’ relevant to use in parameter lists. If you can restrict this<br>&gt; pseudo-type to the appropriate context, like we are heading towards with<br>&gt; disallowing ImplicityUnwrappedOptional in function signatures, why not<br>&gt; restrict certain type annotations to only occur in function signatures?<br>&gt;<br>&gt;<br>&gt; Effectively the presence of parameter annotations in a tuple make it a<br>&gt; ‘splat-only tuple’.<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; On 2 Jul 2016, at 05:38, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; This functionality naturally falls out of any decent proposal for variadic<br>&gt; generics. I&#39;d rather wait until we can re-add it in a principled manner<br>&gt; than stuff yet another @-prefixed special case into the language.<br>&gt;<br>&gt;<br>&gt; Fair point, but it seems this could stand as a lightweight complement to<br>&gt; generics. There seems to be a lack of support for the side of keeping what<br>&gt; functionality we already have in this area.<br>&gt;<br>&gt;<br>&gt; FWIW, I liked and used tuple splat before it was removed from the language.<br>&gt;<br>&gt; I thought about it, and I think a lightweight, limited form of tuple<br>&gt; application would probably be worth pursuing even before variadic generics<br>&gt; go into the language (especially since they are a low-priority item).<br>&gt; Perhaps someone could draft a proposal for Swift 3.1.<br>&gt;<br>&gt;<br>&gt; This is why I support keeping what existing semantics we can, rather than<br>&gt; stripping it all out only to reimplement it as soon as people realise it&#39;s<br>&gt; missing.<br>&gt;<br>&gt; The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br>&gt;<br>&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple +<br>&gt; annotations’ relevant to use in parameter lists. If you can restrict this<br>&gt; pseudo-type to the appropriate context, like we are heading towards with<br>&gt; disallowing ImplicityUnwrappedOptional in function signatures, why not<br>&gt; restrict certain type annotations to only occur in function signatures?<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in<br>&gt; the type system be changed in the exact same way?<br>&gt;<br>&gt;<br>&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an<br>&gt; `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing<br>&gt; confusing about them, at least not in the same way that function types are.<br>&gt;<br>&gt;<br>&gt; This seems just the same problem as not being able to assign:<br>&gt;<br>&gt; (a: Int, b: Int) -&gt; ()<br>&gt;<br>&gt; to a type of:<br>&gt;<br>&gt; (x: Int, y: Int) -&gt; ()<br>&gt;<br>&gt; Functions and tuples are the only uses of labels in the type system I&#39;m<br>&gt; aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;<br>&gt;<br>&gt; There was a better argument for this sort of thing before the naming<br>&gt; guidelines. Swift 2 argument labels often described the semantic value of<br>&gt; their arguments. Now you have guidelines which assign non-descriptive<br>&gt; prepositional phrases as argument labels. It makes no sense to pull the<br>&gt; prepositional phase comprising the argument label (as opposed to the<br>&gt; argument name itself) into the type, since that phrase is meaningless<br>&gt; outside the context of the primary function name, but the current system<br>&gt; (and any based off it) would do just that.<br>&gt;<br>&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function<br>&gt; argument labels.<br>&gt;<br>&gt;<br>&gt; Sorry, I meant the reasoning for removing them from the type system. As<br>&gt; you said, there was a better argument. I&#39;m observing that this may once<br>&gt; again be the case following this change.<br>&gt;<br>&gt;<br>&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple<br>&gt; splatter try to enforce the labels on whatever tuples you pass to it, since<br>&gt; those labels would necessarily be tied to a specific function&#39;s name,<br>&gt; rather than the meaning of the arguments themselves. Do you think there<br>&gt; would be too much room for programmer error if such a splatter necessarily<br>&gt; took in unlabeled tuples? (Right now any labeled tuple is interchangeable<br>&gt; with a non-labeled tuple with the same constituent types...)<br>&gt;<br>&gt;<br>&gt; My idea is that if we switch to using:<br>&gt;<br>&gt; let functionType(a:b:) = add(_:_:)<br>&gt;<br>&gt; then it make sense to have tuples match this syntax, to avoid having two<br>&gt; similar naming mechanisms with very different semantics:<br>&gt;<br>&gt; let values(x:y:) = (1, 2)<br>&gt;<br>&gt; Like a function&#39;s argument labels are rarely sensible out of context,<br>&gt; tuples are best passed around without considering their labels. For example:<br>&gt;<br>&gt; let name: (first: String, last: String) = …<br>&gt;<br>&gt; name.first //clear<br>&gt;<br>&gt; func join(stringTuple: (String, String))<br>&gt;<br>&gt; join(stringTuple: name) //is this allowed?<br>&gt;<br>&gt;<br>&gt; At this point (generally as soon as the tuple leaves the context of its<br>&gt; containing variable), the original parameter labels are meaningless.<br>&gt; Alternatively:<br>&gt;<br>&gt;<br>&gt; let name(first:last:): (String, String) = …<br>&gt;<br>&gt; name.first //still clear<br>&gt;<br>&gt; join(name) //clearly allowed, since the labels are not part of the type<br>&gt;<br>&gt;<br>&gt; With this, if I understand you properly, argument names wouldn&#39;t be<br>&gt; present in the type system to begin with, so calling the result of a<br>&gt; splatter would be predictable:<br>&gt;<br>&gt; join(a: String, b: String)<br>&gt;<br>&gt; let splatted: ((String, String)) -&gt; () = splat(join) // or splat(<br>&gt; join(a:b:) )<br>&gt;<br>&gt; splatted(name) // or splatted( name(first:last:) )<br>&gt;<br>&gt;<br>&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick<br>&gt; email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Or are tuples destined to become nothing more than a historical artifact?<br>&gt; If this is the case, then we might as well remove them now.<br>&gt;<br>&gt;<br>&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;<br>&gt;<br>&gt; • lightweight structs<br>&gt; • loosely-typed structs<br>&gt; • …as structs<br>&gt;<br>&gt; There is no particular reason Void must be modelled as the empty struct,<br>&gt; since any non-subclassable Type.self is likewise a singleton.<br>&gt;<br>&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;<br>&gt;<br>&gt; What? You asked if tuples were going to become a historical artifact? The<br>&gt; answer is, &quot;no, they aren&#39;t, because they have uses besides modeling<br>&gt; argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt;<br>&gt;<br>&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------ Begin Message ------------<br>&gt;<br>&gt; Group: gmane.comp.lang.swift.evolution<br>&gt;<br>&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;<br>&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Hello Swift community,<br>&gt;<br>&gt;<br>&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;<br>&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;<br>&gt; available here:<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;<br>&gt; review manager.<br>&gt;<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt;<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt;<br>&gt; in your review:<br>&gt;<br>&gt;<br>&gt; * What is your evaluation of the proposal?<br>&gt;<br>&gt;<br>&gt;<br>&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;<br>&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;<br>&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;<br>&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;<br>&gt; is a historical artifact and now merely coincidental.<br>&gt;<br>&gt;<br>&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;<br>&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;<br>&gt; contains all of the parts, not just the base name.<br>&gt;<br>&gt;<br>&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;<br>&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;<br>&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;<br>&gt; change to Swift?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;<br>&gt; of argument names to differentiate between overloads with the same argument<br>&gt;<br>&gt; types at the same positions. To me, this is another admission that the<br>&gt;<br>&gt; labels are part of the function&#39;s *name*.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; * If you have used other languages or libraries with a similar<br>&gt;<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;<br>&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;<br>&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;<br>&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;<br>&gt;<br>&gt;<br>&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt;<br>&gt;<br>&gt; Read the proposal and loosely followed the discussion.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt;<br>&gt; -Chris Lattner<br>&gt;<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ------------- End Message -------------<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; _______________________________________________<br>&gt;<br>&gt; swift-evolution mailing list<br>&gt;<br>&gt; swift-evolution at swift.org<br>&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/307e4891/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 07:00:00am</p></header><div class="content"><p>Tuples are inherently interchangable. If you want to avoid this, the safest way is to use a struct.<br></p><p>Labels/naming shouldn&#39;t be relied on to provide type information, this is why implicit conformance to protocols is disallowed.<br></p><p>From James F<br></p><p>&gt; On 2 Jul 2016, at 06:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; What&#39;s the basis for your claim that tuples are best passed around without their labels? If I have `typealias CartesianCoordinates = (x: Double, y: Double)`, these labels are absolutely meaningful, and I would not want them to be interchangeable with a hypothetical `typealias PolarCoordinates = (r: Double, theta: Double)`. Although argument labels are part of the name, tuple labels are part of the type; there are good reasons for that, and the two are no longer meant to be similar. This proposal takes us the rest of the way in clarifying this important distinction.<br>&gt; On Fri, Jul 1, 2016 at 11:52 PM James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br>&gt;&gt; <br>&gt;&gt; Effectively the presence of parameter annotations in a tuple make it a ‘splat-only tuple’.<br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt;&gt; On 2 Jul 2016, at 05:38, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Fair point, but it seems this could stand as a lightweight complement to generics. There seems to be a lack of support for the side of keeping what functionality we already have in this area.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, I liked and used tuple splat before it was removed from the language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I thought about it, and I think a lightweight, limited form of tuple application would probably be worth pursuing even before variadic generics go into the language (especially since they are a low-priority item). Perhaps someone could draft a proposal for Swift 3.1.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is why I support keeping what existing semantics we can, rather than stripping it all out only to reimplement it as soon as people realise it&#39;s missing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a type of:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sorry, I meant the reasoning for removing them from the type system. As you said, there was a better argument. I&#39;m observing that this may once again be the case following this change.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple splatter try to enforce the labels on whatever tuples you pass to it, since those labels would necessarily be tied to a specific function&#39;s name, rather than the meaning of the arguments themselves. Do you think there would be too much room for programmer error if such a splatter necessarily took in unlabeled tuples? (Right now any labeled tuple is interchangeable with a non-labeled tuple with the same constituent types...)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My idea is that if we switch to using:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let functionType(a:b:) = add(_:_:)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; then it make sense to have tuples match this syntax, to avoid having two similar naming mechanisms with very different semantics:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let values(x:y:) = (1, 2)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Like a function&#39;s argument labels are rarely sensible out of context, tuples are best passed around without considering their labels. For example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let name: (first: String, last: String) = …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; name.first //clear<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func join(stringTuple: (String, String))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; join(stringTuple: name) //is this allowed?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At this point (generally as soon as the tuple leaves the context of its containing variable), the original parameter labels are meaningless. Alternatively:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let name(first:last:): (String, String) = …<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; name.first //still clear<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; join(name) //clearly allowed, since the labels are not part of the type<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this, if I understand you properly, argument names wouldn&#39;t be present in the type system to begin with, so calling the result of a splatter would be predictable:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; join(a: String, b: String)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let splatted: ((String, String)) -&gt; () = splat(join) // or splat( join(a:b:) )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; splatted(name) // or splatted( name(first:last:) )<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • lightweight structs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • loosely-typed structs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; • …as structs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/a2e0fe2c/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  2, 2016 at 01:00:00am</p></header><div class="content"><p>On Sat, Jul 2, 2016 at 1:03 AM, James Froggatt &lt;james.froggatt at me.com&gt;<br>wrote:<br></p><p>&gt; Tuples are inherently interchangable. If you want to avoid this, the<br>&gt; safest way is to use a struct.<br>&gt;<br></p><p>```<br>typealias Foo = (a: Int, b: Int)<br>typealias Bar = (c: Int, d: Int)<br>var foo: Foo = (1, 2)<br>var bar: Bar = (3, 4)<br>foo = bar<br>```<br>ERROR at line 5, col 7: cannot assign value of type &#39;Bar&#39; (aka &#39;(c: Int, d:<br>Int)&#39;) to type &#39;Foo&#39; (aka &#39;(a: Int, b: Int)&#39;)<br></p><p>What do you mean when you say that tuples are inherently interchangeable?<br>What am I not safe from?<br></p><p><br>&gt; Labels/naming shouldn&#39;t be relied on to provide type information,<br>&gt;<br></p><p>For a tuple type, labels are treated as part of the type; I *do* rely on<br>that. Why do you say that it shouldn&#39;t be relied on?<br></p><p><br>&gt; this is why implicit conformance to protocols is disallowed.<br>&gt;<br></p><p>I don&#39;t follow.<br></p><p>&gt;From James F<br>&gt;<br>&gt; On 2 Jul 2016, at 06:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; What&#39;s the basis for your claim that tuples are best passed around without<br>&gt; their labels? If I have `typealias CartesianCoordinates = (x: Double, y:<br>&gt; Double)`, these labels are absolutely meaningful, and I would not want them<br>&gt; to be interchangeable with a hypothetical `typealias PolarCoordinates = (r:<br>&gt; Double, theta: Double)`. Although argument labels are part of the name,<br>&gt; tuple labels are part of the type; there are good reasons for that, and the<br>&gt; two are no longer meant to be similar. This proposal takes us the rest of<br>&gt; the way in clarifying this important distinction.<br>&gt; On Fri, Jul 1, 2016 at 11:52 PM James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple +<br>&gt;&gt; annotations’ relevant to use in parameter lists. If you can restrict this<br>&gt;&gt; pseudo-type to the appropriate context, like we are heading towards with<br>&gt;&gt; disallowing ImplicityUnwrappedOptional in function signatures, why not<br>&gt;&gt; restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Effectively the presence of parameter annotations in a tuple make it a<br>&gt;&gt; ‘splat-only tuple’.<br>&gt;&gt;<br>&gt;&gt; From James F<br>&gt;&gt;<br>&gt;&gt; On 2 Jul 2016, at 05:38, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This functionality naturally falls out of any decent proposal for<br>&gt;&gt; variadic generics. I&#39;d rather wait until we can re-add it in a principled<br>&gt;&gt; manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Fair point, but it seems this could stand as a lightweight complement to<br>&gt;&gt; generics. There seems to be a lack of support for the side of keeping what<br>&gt;&gt; functionality we already have in this area.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; FWIW, I liked and used tuple splat before it was removed from the<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;&gt; I thought about it, and I think a lightweight, limited form of tuple<br>&gt;&gt; application would probably be worth pursuing even before variadic generics<br>&gt;&gt; go into the language (especially since they are a low-priority item).<br>&gt;&gt; Perhaps someone could draft a proposal for Swift 3.1.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is why I support keeping what existing semantics we can, rather than<br>&gt;&gt; stripping it all out only to reimplement it as soon as people realise it&#39;s<br>&gt;&gt; missing.<br>&gt;&gt;<br>&gt;&gt; The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br>&gt;&gt;<br>&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple +<br>&gt;&gt; annotations’ relevant to use in parameter lists. If you can restrict this<br>&gt;&gt; pseudo-type to the appropriate context, like we are heading towards with<br>&gt;&gt; disallowing ImplicityUnwrappedOptional in function signatures, why not<br>&gt;&gt; restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in<br>&gt;&gt; the type system be changed in the exact same way?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an<br>&gt;&gt; `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing<br>&gt;&gt; confusing about them, at least not in the same way that function types are.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;<br>&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;<br>&gt;&gt; to a type of:<br>&gt;&gt;<br>&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;<br>&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m<br>&gt;&gt; aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; There was a better argument for this sort of thing before the naming<br>&gt;&gt; guidelines. Swift 2 argument labels often described the semantic value of<br>&gt;&gt; their arguments. Now you have guidelines which assign non-descriptive<br>&gt;&gt; prepositional phrases as argument labels. It makes no sense to pull the<br>&gt;&gt; prepositional phase comprising the argument label (as opposed to the<br>&gt;&gt; argument name itself) into the type, since that phrase is meaningless<br>&gt;&gt; outside the context of the primary function name, but the current system<br>&gt;&gt; (and any based off it) would do just that.<br>&gt;&gt;<br>&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function<br>&gt;&gt; argument labels.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Sorry, I meant the reasoning for removing them from the type system. As<br>&gt;&gt; you said, there was a better argument. I&#39;m observing that this may once<br>&gt;&gt; again be the case following this change.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple<br>&gt;&gt; splatter try to enforce the labels on whatever tuples you pass to it, since<br>&gt;&gt; those labels would necessarily be tied to a specific function&#39;s name,<br>&gt;&gt; rather than the meaning of the arguments themselves. Do you think there<br>&gt;&gt; would be too much room for programmer error if such a splatter necessarily<br>&gt;&gt; took in unlabeled tuples? (Right now any labeled tuple is interchangeable<br>&gt;&gt; with a non-labeled tuple with the same constituent types...)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; My idea is that if we switch to using:<br>&gt;&gt;<br>&gt;&gt; let functionType(a:b:) = add(_:_:)<br>&gt;&gt;<br>&gt;&gt; then it make sense to have tuples match this syntax, to avoid having two<br>&gt;&gt; similar naming mechanisms with very different semantics:<br>&gt;&gt;<br>&gt;&gt; let values(x:y:) = (1, 2)<br>&gt;&gt;<br>&gt;&gt; Like a function&#39;s argument labels are rarely sensible out of context,<br>&gt;&gt; tuples are best passed around without considering their labels. For example:<br>&gt;&gt;<br>&gt;&gt; let name: (first: String, last: String) = …<br>&gt;&gt;<br>&gt;&gt; name.first //clear<br>&gt;&gt;<br>&gt;&gt; func join(stringTuple: (String, String))<br>&gt;&gt;<br>&gt;&gt; join(stringTuple: name) //is this allowed?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; At this point (generally as soon as the tuple leaves the context of its<br>&gt;&gt; containing variable), the original parameter labels are meaningless.<br>&gt;&gt; Alternatively:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; let name(first:last:): (String, String) = …<br>&gt;&gt;<br>&gt;&gt; name.first //still clear<br>&gt;&gt;<br>&gt;&gt; join(name) //clearly allowed, since the labels are not part of the type<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; With this, if I understand you properly, argument names wouldn&#39;t be<br>&gt;&gt; present in the type system to begin with, so calling the result of a<br>&gt;&gt; splatter would be predictable:<br>&gt;&gt;<br>&gt;&gt; join(a: String, b: String)<br>&gt;&gt;<br>&gt;&gt; let splatted: ((String, String)) -&gt; () = splat(join) // or splat(<br>&gt;&gt; join(a:b:) )<br>&gt;&gt;<br>&gt;&gt; splatted(name) // or splatted( name(first:last:) )<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick<br>&gt;&gt; email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Or are tuples destined to become nothing more than a historical artifact?<br>&gt;&gt; If this is the case, then we might as well remove them now.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; • lightweight structs<br>&gt;&gt; • loosely-typed structs<br>&gt;&gt; • …as structs<br>&gt;&gt;<br>&gt;&gt; There is no particular reason Void must be modelled as the empty struct,<br>&gt;&gt; since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;<br>&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What? You asked if tuples were going to become a historical artifact? The<br>&gt;&gt; answer is, &quot;no, they aren&#39;t, because they have uses besides modeling<br>&gt;&gt; argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ------------ Begin Message ------------<br>&gt;&gt;<br>&gt;&gt; Group: gmane.comp.lang.swift.evolution<br>&gt;&gt;<br>&gt;&gt; MsgID: &lt;<br>&gt;&gt; CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;<br>&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;<br>&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;<br>&gt;&gt; available here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;<br>&gt;&gt; review manager.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; What goes into a review?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;<br>&gt;&gt; in your review:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels<br>&gt;&gt; are<br>&gt;&gt;<br>&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;<br>&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;<br>&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;<br>&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;<br>&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;<br>&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;<br>&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;<br>&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;<br>&gt;&gt; change to Swift?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;<br>&gt;&gt; of argument names to differentiate between overloads with the same<br>&gt;&gt; argument<br>&gt;&gt;<br>&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;<br>&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;<br>&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that<br>&gt;&gt; treat<br>&gt;&gt;<br>&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;<br>&gt;&gt; design is significantly different and I can&#39;t draw an analogy between<br>&gt;&gt; them.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Chris Lattner<br>&gt;&gt;<br>&gt;&gt; Review Manager<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt;<br>&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ------------- End Message -------------<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; From James F<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt;<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/70ce97f4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e841a2a33b72c728c55ff99200275784?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>James Froggatt</string> &lt;james.froggatt at me.com&gt;<p>July  2, 2016 at 07:00:00am</p></header><div class="content"><p>typealias Point = (x: Int, y: Int)<br>typealias Dimensions = (x: Int, y: Int)<br></p><p>let point: Point = (x: 5, y: 5)<br></p><p>let dimensions = point<br></p><p>Fundamentally different concepts may have labels happen to be the same. Structs protect against this conversion, tuples don&#39;t.<br></p><p>Explicit protocol conformance is justified in this way:<br></p><p>protocol GridPoint {<br>    var x: Int {get}<br>    var y: Int {get}<br>}<br></p><p>protocol Box {<br>    associatedtype UnitType<br>    var x: UnitType {get}<br>    var y: UnitType {get}<br>    var z: UnitType {get}<br>}<br></p><p>GridPoints obviously shouldn&#39;t be Boxes, but with implicit conformance, every Box would be a GridPoint.<br></p><p>From James F<br></p><p>&gt; On 2 Jul 2016, at 07:31, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; On Sat, Jul 2, 2016 at 1:03 AM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt; Tuples are inherently interchangable. If you want to avoid this, the safest way is to use a struct.<br>&gt; <br>&gt; ```<br>&gt; typealias Foo = (a: Int, b: Int)<br>&gt; typealias Bar = (c: Int, d: Int)<br>&gt; var foo: Foo = (1, 2)<br>&gt; var bar: Bar = (3, 4)<br>&gt; foo = bar<br>&gt; ```<br>&gt; ERROR at line 5, col 7: cannot assign value of type &#39;Bar&#39; (aka &#39;(c: Int, d: Int)&#39;) to type &#39;Foo&#39; (aka &#39;(a: Int, b: Int)&#39;)<br>&gt; <br>&gt; What do you mean when you say that tuples are inherently interchangeable? What am I not safe from?<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Labels/naming shouldn&#39;t be relied on to provide type information,<br>&gt; <br>&gt; For a tuple type, labels are treated as part of the type; I *do* rely on that. Why do you say that it shouldn&#39;t be relied on?<br>&gt;  <br>&gt;&gt; this is why implicit conformance to protocols is disallowed.<br>&gt; <br>&gt; I don&#39;t follow.<br>&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt;&gt; On 2 Jul 2016, at 06:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What&#39;s the basis for your claim that tuples are best passed around without their labels? If I have `typealias CartesianCoordinates = (x: Double, y: Double)`, these labels are absolutely meaningful, and I would not want them to be interchangeable with a hypothetical `typealias PolarCoordinates = (r: Double, theta: Double)`. Although argument labels are part of the name, tuple labels are part of the type; there are good reasons for that, and the two are no longer meant to be similar. This proposal takes us the rest of the way in clarifying this important distinction.<br>&gt;&gt;&gt; On Fri, Jul 1, 2016 at 11:52 PM James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Effectively the presence of parameter annotations in a tuple make it a ‘splat-only tuple’.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 2 Jul 2016, at 05:38, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This functionality naturally falls out of any decent proposal for variadic generics. I&#39;d rather wait until we can re-add it in a principled manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Fair point, but it seems this could stand as a lightweight complement to generics. There seems to be a lack of support for the side of keeping what functionality we already have in this area.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; FWIW, I liked and used tuple splat before it was removed from the language.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I thought about it, and I think a lightweight, limited form of tuple application would probably be worth pursuing even before variadic generics go into the language (especially since they are a low-priority item). Perhaps someone could draft a proposal for Swift 3.1.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is why I support keeping what existing semantics we can, rather than stripping it all out only to reimplement it as soon as people realise it&#39;s missing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple + annotations’ relevant to use in parameter lists. If you can restrict this pseudo-type to the appropriate context, like we are heading towards with disallowing ImplicityUnwrappedOptional in function signatures, why not restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels in the type system be changed in the exact same way?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to a type of:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There was a better argument for this sort of thing before the naming guidelines. Swift 2 argument labels often described the semantic value of their arguments. Now you have guidelines which assign non-descriptive prepositional phrases as argument labels. It makes no sense to pull the prepositional phase comprising the argument label (as opposed to the argument name itself) into the type, since that phrase is meaningless outside the context of the primary function name, but the current system (and any based off it) would do just that.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function argument labels.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sorry, I meant the reasoning for removing them from the type system. As you said, there was a better argument. I&#39;m observing that this may once again be the case following this change.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple splatter try to enforce the labels on whatever tuples you pass to it, since those labels would necessarily be tied to a specific function&#39;s name, rather than the meaning of the arguments themselves. Do you think there would be too much room for programmer error if such a splatter necessarily took in unlabeled tuples? (Right now any labeled tuple is interchangeable with a non-labeled tuple with the same constituent types...)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My idea is that if we switch to using:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let functionType(a:b:) = add(_:_:)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; then it make sense to have tuples match this syntax, to avoid having two similar naming mechanisms with very different semantics:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let values(x:y:) = (1, 2)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Like a function&#39;s argument labels are rarely sensible out of context, tuples are best passed around without considering their labels. For example:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let name: (first: String, last: String) = …<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; name.first //clear<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func join(stringTuple: (String, String))<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; join(stringTuple: name) //is this allowed?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; At this point (generally as soon as the tuple leaves the context of its containing variable), the original parameter labels are meaningless. Alternatively:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let name(first:last:): (String, String) = …<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; name.first //still clear<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; join(name) //clearly allowed, since the labels are not part of the type<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this, if I understand you properly, argument names wouldn&#39;t be present in the type system to begin with, so calling the result of a splatter would be predictable:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; join(a: String, b: String)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let splatted: ((String, String)) -&gt; () = splat(join) // or splat( join(a:b:) )<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; splatted(name) // or splatted( name(first:last:) )<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It doesn&#39;t help that this went through to the wrong thread, and the quick email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • lightweight structs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • loosely-typed structs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; • …as structs<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; There is no particular reason Void must be modelled as the empty struct, since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What? You asked if tuples were going to become a historical artifact? The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------ Begin Message ------------ <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MsgID: &lt;CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels are<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled components<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; prefix is still considered part of that verb, not a separate word/concept.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the use<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; of argument names to differentiate between overloads with the same argument<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used that<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that treat<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between them.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; ------------- End Message ------------- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/873d9d4c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0111: Remove type system significance of function argument labels</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  2, 2016 at 07:00:00am</p></header><div class="content"><p>Those aren&#39;t two &quot;interchangeable&quot; types in your example; it&#39;s the same<br>type with two aliases. By contrast, the tuple types `(x: Int, y: Int)` and<br>`(a: Int, b: Int)` are distinct, as I illustrated above.<br></p><p>You are correct that one of the unique aspects of labeled tuple types would<br>no longer be so unique if Swift had implicit protocol conformance. It does<br>not follow that this unique aspect of tuples should be eliminated from the<br>language.<br></p><p>I choose to use tuples precisely where I want this behavior. For instance,<br>I don&#39;t care if you write `typealias GridCoordinates = (x: Int, y: Int)`<br>and I write `typealias CartesianCoordinates = ...`; I choose to alias a<br>tuple type precisely because I want such &quot;interchangeability.&quot; But I do<br>care about the labels being `x` and `y`, and that&#39;s where the labeled tuple<br>comes in.<br></p><p>On Sat, Jul 2, 2016 at 1:52 AM James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br></p><p>&gt; typealias Point = (x: Int, y: Int)<br>&gt; typealias Dimensions = (x: Int, y: Int)<br>&gt;<br>&gt; let point: Point = (x: 5, y: 5)<br>&gt;<br>&gt; let dimensions = point<br>&gt;<br>&gt; Fundamentally different concepts may have labels happen to be the same.<br>&gt; Structs protect against this conversion, tuples don&#39;t.<br>&gt;<br>&gt; Explicit protocol conformance is justified in this way:<br>&gt;<br>&gt; protocol GridPoint {<br>&gt;     var x: Int {get}<br>&gt;     var y: Int {get}<br>&gt; }<br>&gt;<br>&gt; protocol Box {<br>&gt;     associatedtype UnitType<br>&gt;     var x: UnitType {get}<br>&gt;     var y: UnitType {get}<br>&gt;     var z: UnitType {get}<br>&gt; }<br>&gt;<br>&gt; GridPoints obviously shouldn&#39;t be Boxes, but with implicit conformance,<br>&gt; every Box would be a GridPoint.<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; On 2 Jul 2016, at 07:31, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Sat, Jul 2, 2016 at 1:03 AM, James Froggatt &lt;james.froggatt at me.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Tuples are inherently interchangable. If you want to avoid this, the<br>&gt;&gt; safest way is to use a struct.<br>&gt;&gt;<br>&gt;<br>&gt; ```<br>&gt; typealias Foo = (a: Int, b: Int)<br>&gt; typealias Bar = (c: Int, d: Int)<br>&gt; var foo: Foo = (1, 2)<br>&gt; var bar: Bar = (3, 4)<br>&gt; foo = bar<br>&gt; ```<br>&gt; ERROR at line 5, col 7: cannot assign value of type &#39;Bar&#39; (aka &#39;(c: Int,<br>&gt; d: Int)&#39;) to type &#39;Foo&#39; (aka &#39;(a: Int, b: Int)&#39;)<br>&gt;<br>&gt; What do you mean when you say that tuples are inherently interchangeable?<br>&gt; What am I not safe from?<br>&gt;<br>&gt;<br>&gt;&gt; Labels/naming shouldn&#39;t be relied on to provide type information,<br>&gt;&gt;<br>&gt;<br>&gt; For a tuple type, labels are treated as part of the type; I *do* rely on<br>&gt; that. Why do you say that it shouldn&#39;t be relied on?<br>&gt;<br>&gt;<br>&gt;&gt; this is why implicit conformance to protocols is disallowed.<br>&gt;&gt;<br>&gt;<br>&gt; I don&#39;t follow.<br>&gt;<br>&gt; From James F<br>&gt;&gt;<br>&gt;&gt; On 2 Jul 2016, at 06:43, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What&#39;s the basis for your claim that tuples are best passed around<br>&gt;&gt; without their labels? If I have `typealias CartesianCoordinates = (x:<br>&gt;&gt; Double, y: Double)`, these labels are absolutely meaningful, and I would<br>&gt;&gt; not want them to be interchangeable with a hypothetical `typealias<br>&gt;&gt; PolarCoordinates = (r: Double, theta: Double)`. Although argument labels<br>&gt;&gt; are part of the name, tuple labels are part of the type; there are good<br>&gt;&gt; reasons for that, and the two are no longer meant to be similar. This<br>&gt;&gt; proposal takes us the rest of the way in clarifying this important<br>&gt;&gt; distinction.<br>&gt;&gt; On Fri, Jul 1, 2016 at 11:52 PM James Froggatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple +<br>&gt;&gt;&gt; annotations’ relevant to use in parameter lists. If you can restrict this<br>&gt;&gt;&gt; pseudo-type to the appropriate context, like we are heading towards with<br>&gt;&gt;&gt; disallowing ImplicityUnwrappedOptional in function signatures, why not<br>&gt;&gt;&gt; restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Effectively the presence of parameter annotations in a tuple make it a<br>&gt;&gt;&gt; ‘splat-only tuple’.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2 Jul 2016, at 05:38, James Froggatt &lt;james.froggatt at me.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2 Jul 2016, at 05:03, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Jul 1, 2016, at 8:55 PM, James Froggatt &lt;james.froggatt at me.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 2 Jul 2016, at 04:46, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This functionality naturally falls out of any decent proposal for<br>&gt;&gt;&gt; variadic generics. I&#39;d rather wait until we can re-add it in a principled<br>&gt;&gt;&gt; manner than stuff yet another @-prefixed special case into the language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Fair point, but it seems this could stand as a lightweight complement to<br>&gt;&gt;&gt; generics. There seems to be a lack of support for the side of keeping what<br>&gt;&gt;&gt; functionality we already have in this area.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; FWIW, I liked and used tuple splat before it was removed from the<br>&gt;&gt;&gt; language.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I thought about it, and I think a lightweight, limited form of tuple<br>&gt;&gt;&gt; application would probably be worth pursuing even before variadic generics<br>&gt;&gt;&gt; go into the language (especially since they are a low-priority item).<br>&gt;&gt;&gt; Perhaps someone could draft a proposal for Swift 3.1.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is why I support keeping what existing semantics we can, rather<br>&gt;&gt;&gt; than stripping it all out only to reimplement it as soon as people realise<br>&gt;&gt;&gt; it&#39;s missing.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The distinction between (Int, Int) and ((Int, Int)) seems trivial.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A parameter list of (inout Int, @noescape Int -&gt; ()) is just a ‘tuple +<br>&gt;&gt;&gt; annotations’ relevant to use in parameter lists. If you can restrict this<br>&gt;&gt;&gt; pseudo-type to the appropriate context, like we are heading towards with<br>&gt;&gt;&gt; disallowing ImplicityUnwrappedOptional in function signatures, why not<br>&gt;&gt;&gt; restrict certain type annotations to only occur in function signatures?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Is it though? Couldn&#39;t the current confusing situation of tuple labels<br>&gt;&gt;&gt; in the type system be changed in the exact same way?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tuple labels work the way you expect them to work: you can&#39;t assign an<br>&gt;&gt;&gt; `(a: 1, b: 2)` to a variable of type `(x: Int, y: Int)`. There is nothing<br>&gt;&gt;&gt; confusing about them, at least not in the same way that function types are.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This seems just the same problem as not being able to assign:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (a: Int, b: Int) -&gt; ()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; to a type of:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (x: Int, y: Int) -&gt; ()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Functions and tuples are the only uses of labels in the type system I&#39;m<br>&gt;&gt;&gt; aware of. The reasoning for one case seems likely to apply to the other.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There was a better argument for this sort of thing before the naming<br>&gt;&gt;&gt; guidelines. Swift 2 argument labels often described the semantic value of<br>&gt;&gt;&gt; their arguments. Now you have guidelines which assign non-descriptive<br>&gt;&gt;&gt; prepositional phrases as argument labels. It makes no sense to pull the<br>&gt;&gt;&gt; prepositional phase comprising the argument label (as opposed to the<br>&gt;&gt;&gt; argument name itself) into the type, since that phrase is meaningless<br>&gt;&gt;&gt; outside the context of the primary function name, but the current system<br>&gt;&gt;&gt; (and any based off it) would do just that.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So no, I don&#39;t think the reasoning for tuple labels applies to function<br>&gt;&gt;&gt; argument labels.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Sorry, I meant the reasoning for removing them from the type system. As<br>&gt;&gt;&gt; you said, there was a better argument. I&#39;m observing that this may once<br>&gt;&gt;&gt; again be the case following this change.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I still think it would be a bit odd to have (e.g.) a rejuvenated tuple<br>&gt;&gt;&gt; splatter try to enforce the labels on whatever tuples you pass to it, since<br>&gt;&gt;&gt; those labels would necessarily be tied to a specific function&#39;s name,<br>&gt;&gt;&gt; rather than the meaning of the arguments themselves. Do you think there<br>&gt;&gt;&gt; would be too much room for programmer error if such a splatter necessarily<br>&gt;&gt;&gt; took in unlabeled tuples? (Right now any labeled tuple is interchangeable<br>&gt;&gt;&gt; with a non-labeled tuple with the same constituent types...)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My idea is that if we switch to using:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let functionType(a:b:) = add(_:_:)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; then it make sense to have tuples match this syntax, to avoid having two<br>&gt;&gt;&gt; similar naming mechanisms with very different semantics:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let values(x:y:) = (1, 2)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Like a function&#39;s argument labels are rarely sensible out of context,<br>&gt;&gt;&gt; tuples are best passed around without considering their labels. For example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let name: (first: String, last: String) = …<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; name.first //clear<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func join(stringTuple: (String, String))<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; join(stringTuple: name) //is this allowed?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; At this point (generally as soon as the tuple leaves the context of its<br>&gt;&gt;&gt; containing variable), the original parameter labels are meaningless.<br>&gt;&gt;&gt; Alternatively:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let name(first:last:): (String, String) = …<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; name.first //still clear<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; join(name) //clearly allowed, since the labels are not part of the type<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; With this, if I understand you properly, argument names wouldn&#39;t be<br>&gt;&gt;&gt; present in the type system to begin with, so calling the result of a<br>&gt;&gt;&gt; splatter would be predictable:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; join(a: String, b: String)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let splatted: ((String, String)) -&gt; () = splat(join) // or splat(<br>&gt;&gt;&gt; join(a:b:) )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; splatted(name) // or splatted( name(first:last:) )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; It doesn&#39;t help that this went through to the wrong thread, and the<br>&gt;&gt;&gt; quick email I sent to acknowledge this has fallen in a hole somewhere.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or are tuples destined to become nothing more than a historical<br>&gt;&gt;&gt; artifact? If this is the case, then we might as well remove them now.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Tuples have many, many uses apart from modeling argument lists.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; • lightweight structs<br>&gt;&gt;&gt; • loosely-typed structs<br>&gt;&gt;&gt; • …as structs<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; There is no particular reason Void must be modelled as the empty struct,<br>&gt;&gt;&gt; since any non-subclassable Type.self is likewise a singleton.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So there&#39;s nothing really making a compelling argument here.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What? You asked if tuples were going to become a historical artifact?<br>&gt;&gt;&gt; The answer is, &quot;no, they aren&#39;t, because they have uses besides modeling<br>&gt;&gt;&gt; argument labels&quot;. Void as the empty tuple is irrelevant to the discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not sure how to interpret this, sorry.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Perhaps I misunderstood your original point. In that case, I apologize.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ------------ Begin Message ------------<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Group: gmane.comp.lang.swift.evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; MsgID: &lt;<br>&gt;&gt;&gt; CAOw3ZebrvO92FRnv2XK1Y_+S2LqYvouo-fM46bPmuFfOF2P1Og at mail.gmail.com&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thu, Jun 30, 2016 at 11:26 AM Chris Lattner via swift-evolution &lt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The review of &quot;SE-0111: Remove type system significance of function<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; argument labels&quot; begins now and runs through July 4. The proposal is<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; available here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0111-remove-arg-label-type-significance.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When writing your review, here are some questions you might want to<br>&gt;&gt;&gt; answer<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; +1. I&#39;m in agreement with others in this thread who say that the labels<br>&gt;&gt;&gt; are<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; parts of the *name* of the function, not parts of its *type*. If I<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; understand the other discussions regarding the evolution of Swift&#39;s<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; function arguments model, the similarity to tuples with labeled<br>&gt;&gt;&gt; components<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; is a historical artifact and now merely coincidental.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The analogy to Objective-C here is obvious, where you have selectors<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; instead of functions. The selector is the &quot;name&quot; of the &quot;function&quot; and it<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; contains all of the parts, not just the base name.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Swift function names to me are like German separable verbs. Even when<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; they&#39;re split across the sentence with multiple words in-between, the<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; prefix is still considered part of that verb, not a separate<br>&gt;&gt;&gt; word/concept.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes. This feels like a natural follow-up to SE-0021, which allowed the<br>&gt;&gt;&gt; use<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; of argument names to differentiate between overloads with the same<br>&gt;&gt;&gt; argument<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; types at the same positions. To me, this is another admission that the<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; labels are part of the function&#39;s *name*.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Aside from Objective-C mentioned above, the other languages I&#39;ve used<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; have named/keyword arguments (like Python) are dynamic languages that<br>&gt;&gt;&gt; treat<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; the incoming argument list as a dictionary; in that case, the language<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; design is significantly different and I can&#39;t draw an analogy between<br>&gt;&gt;&gt; them.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; * How much effort did you put into your review? A glance, a quick<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Read the proposal and loosely followed the discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution-m3FHrko0VLzYtjvyW6yDsg at public.gmane.org<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ------------- End Message -------------<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; From James F<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160702/cd4706cb/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
