<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 24, 2016 at 06:00:00pm</p></header><div class="content"><p>It is a common practice in C to assign to integer (int, int16, int64, etc.) typed variables “constant&quot; values declared in enums. In swift, it is in fact possible to do that by using enums&#39; “rawValue” property. When importing structs from C into swift, we even get some fields declared with an integer type, but expecting the assignment of a “constant” declared inside an enum. Of course, this is error prone, it is “old-style” programming and very confusing for newcomers. To solve this issue, my proposal is to be able to create extensions that promote certain fields within a class or struct to enums.<br></p><p>For instance, let’s take these sample C struct and enum:<br></p><p>struct Card {<br>	int suit;<br>	int rank;<br>};<br></p><p>typedef enum {HEARTS, DIAMONDS, CLUBS, SPADES} CardSuit;<br></p><p>(Note: I understand that above code follows a bad programming practice, yet it is widely common)<br></p><p>It should be imported into swift as follows:<br></p><p>struct Card {<br>	suit:Int<br>	value:Int<br>}<br></p><p>enum CardSuit : Int {<br>	case Hearts, Diamonds, Clubs, Spades<br>}<br></p><p>Now, I propose to be able to create an extension as follows:<br></p><p>extension Card {<br>	#enumvalue(suit:CardSuit)<br>}<br></p><p>From this moment on, the suit field should only receive CardSuit values, thus not requiring the use of raw values for assignments.<br></p><p>These extensions should also be of great interest for people using CoreData, since it is not possible to declare enums in models. Therefore, to declare enums, it is necessary to declare integer values, and then use the “unsafe”, “unexpressive&quot; approach explained before.<br></p><p>Note that the proposal intends to only support promotions from integer values to enum values, but, for example, it could also be extended to string values. <br></p><p>Finally, it could be appropriate to extend this proposal to redeclare func’s signatures, in order to promote certain parameters to enum values.<br></p><p>Best,<br></p><p>Carlos.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/674fead3bfff884c72fa02c35d68f258?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>James Campbell</string> &lt;james at supmenow.com&gt;<p>March 24, 2016 at 05:00:00pm</p></header><div class="content"><p>I would rather have a syntax that mirrors the way Protocol does it.<br></p><p>struct Card {<br>        suit:enum&lt;CardSuit&gt;<br>        value:Int<br>}<br></p><p>or we could change it so this only excepts the enum itself unless<br>you explicitly cast from a Int or another enum:<br></p><p>struct Card {<br>        suit:CardSuit<br>        value:Int<br>}<br></p><p>*___________________________________*<br></p><p>*James⎥Head Of CEO*<br></p><p>*james at supmenow.com &lt;james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com&gt;*<br></p><p>*Sup*<br></p><p>*Runway East *<br></p><p>*10 Finsbury Square*<br></p><p>*London*<br></p><p>* EC2A 1AF *<br></p><p>On Thu, Mar 24, 2016 at 5:41 PM, Carlos Rodríguez Domínguez &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; It is a common practice in C to assign to integer (int, int16, int64,<br>&gt; etc.) typed variables “constant&quot; values declared in enums. In swift, it is<br>&gt; in fact possible to do that by using enums&#39; “rawValue” property. When<br>&gt; importing structs from C into swift, we even get some fields declared with<br>&gt; an integer type, but expecting the assignment of a “constant” declared<br>&gt; inside an enum. Of course, this is error prone, it is “old-style”<br>&gt; programming and very confusing for newcomers. To solve this issue, my<br>&gt; proposal is to be able to create extensions that promote certain fields<br>&gt; within a class or struct to enums.<br>&gt;<br>&gt; For instance, let’s take these sample C struct and enum:<br>&gt;<br>&gt; struct Card {<br>&gt;         int suit;<br>&gt;         int rank;<br>&gt; };<br>&gt;<br>&gt; typedef enum {HEARTS, DIAMONDS, CLUBS, SPADES} CardSuit;<br>&gt;<br>&gt; (Note: I understand that above code follows a bad programming practice,<br>&gt; yet it is widely common)<br>&gt;<br>&gt; It should be imported into swift as follows:<br>&gt;<br>&gt; struct Card {<br>&gt;         suit:Int<br>&gt;         value:Int<br>&gt; }<br>&gt;<br>&gt; enum CardSuit : Int {<br>&gt;         case Hearts, Diamonds, Clubs, Spades<br>&gt; }<br>&gt;<br>&gt; Now, I propose to be able to create an extension as follows:<br>&gt;<br>&gt; extension Card {<br>&gt;         #enumvalue(suit:CardSuit)<br>&gt; }<br>&gt;<br>&gt; From this moment on, the suit field should only receive CardSuit values,<br>&gt; thus not requiring the use of raw values for assignments.<br>&gt;<br>&gt; These extensions should also be of great interest for people using<br>&gt; CoreData, since it is not possible to declare enums in models. Therefore,<br>&gt; to declare enums, it is necessary to declare integer values, and then use<br>&gt; the “unsafe”, “unexpressive&quot; approach explained before.<br>&gt;<br>&gt; Note that the proposal intends to only support promotions from integer<br>&gt; values to enum values, but, for example, it could also be extended to<br>&gt; string values.<br>&gt;<br>&gt; Finally, it could be appropriate to extend this proposal to redeclare<br>&gt; func’s signatures, in order to promote certain parameters to enum values.<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; Carlos.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/e0dafd07/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 24, 2016 at 07:00:00pm</p></header><div class="content"><p>Well, I propose the “#” syntax to be consistent with other proposals that intend to provide compilation-related code. In this case, the proposal is just a way to provide an indication that a certain field within a struct or class should be enforced to be a value of a certain enum, not just a plain integer, by the compiler. Anyhow, I think many different sintaxis could be elaborated. For example, another possible syntax could imply reusing the typealias expression:<br></p><p>extension Card{<br>	typealias suit:CardSuit = suit:Int<br>}<br></p><p>However, I assume that using this syntax it should be possible to directly assign to the suit field both an integer or a CardSuit.<br></p><p>&gt; El 24 mar 2016, a las 18:43, James Campbell &lt;james at supmenow.com&gt; escribió:<br>&gt; <br>&gt; I would rather have a syntax that mirrors the way Protocol does it.<br>&gt; <br>&gt; struct Card {<br>&gt;         suit:enum&lt;CardSuit&gt;<br>&gt;         value:Int<br>&gt; }<br>&gt; <br>&gt; or we could change it so this only excepts the enum itself unless you explicitly cast from a Int or another enum:<br>&gt; <br>&gt; struct Card {<br>&gt;         suit:CardSuit<br>&gt;         value:Int<br>&gt; }<br>&gt; <br>&gt; ___________________________________<br>&gt; <br>&gt; James⎥Head Of CEO<br>&gt; <br>&gt; james at supmenow.com &lt;mailto:james at supmenow.com&gt;⎥supmenow.com &lt;http://supmenow.com/&gt;<br>&gt; Sup<br>&gt; <br>&gt; Runway East &gt; <br>&gt; <br>&gt; 10 Finsbury Square<br>&gt; <br>&gt; London<br>&gt; <br>&gt;  &gt; EC2A 1AF <br>&gt; <br>&gt; <br>&gt; On Thu, Mar 24, 2016 at 5:41 PM, Carlos Rodríguez Domínguez &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; It is a common practice in C to assign to integer (int, int16, int64, etc.) typed variables “constant&quot; values declared in enums. In swift, it is in fact possible to do that by using enums&#39; “rawValue” property. When importing structs from C into swift, we even get some fields declared with an integer type, but expecting the assignment of a “constant” declared inside an enum. Of course, this is error prone, it is “old-style” programming and very confusing for newcomers. To solve this issue, my proposal is to be able to create extensions that promote certain fields within a class or struct to enums.<br>&gt; <br>&gt; For instance, let’s take these sample C struct and enum:<br>&gt; <br>&gt; struct Card {<br>&gt;         int suit;<br>&gt;         int rank;<br>&gt; };<br>&gt; <br>&gt; typedef enum {HEARTS, DIAMONDS, CLUBS, SPADES} CardSuit;<br>&gt; <br>&gt; (Note: I understand that above code follows a bad programming practice, yet it is widely common)<br>&gt; <br>&gt; It should be imported into swift as follows:<br>&gt; <br>&gt; struct Card {<br>&gt;         suit:Int<br>&gt;         value:Int<br>&gt; }<br>&gt; <br>&gt; enum CardSuit : Int {<br>&gt;         case Hearts, Diamonds, Clubs, Spades<br>&gt; }<br>&gt; <br>&gt; Now, I propose to be able to create an extension as follows:<br>&gt; <br>&gt; extension Card {<br>&gt;         #enumvalue(suit:CardSuit)<br>&gt; }<br>&gt; <br>&gt; From this moment on, the suit field should only receive CardSuit values, thus not requiring the use of raw values for assignments.<br>&gt; <br>&gt; These extensions should also be of great interest for people using CoreData, since it is not possible to declare enums in models. Therefore, to declare enums, it is necessary to declare integer values, and then use the “unsafe”, “unexpressive&quot; approach explained before.<br>&gt; <br>&gt; Note that the proposal intends to only support promotions from integer values to enum values, but, for example, it could also be extended to string values.<br>&gt; <br>&gt; Finally, it could be appropriate to extend this proposal to redeclare func’s signatures, in order to promote certain parameters to enum values.<br>&gt; <br>&gt; Best,<br>&gt; <br>&gt; Carlos.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/8d55d25a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>March 24, 2016 at 10:00:00pm</p></header><div class="content"><p>Why can’t you do this? No raw values required, except to initialize the enums.<br></p><p>struct Card {<br>    enum Suit : Int { case Hearts, Spades, Diamonds, Clubs }<br>    enum Rank : Int { case Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Jack, Queen, King }<br></p><p>    let suit : Suit<br>    let rank : Rank<br></p><p>    init?(suit: Int, rank: Int) {<br>        guard let suit = Suit(rawValue: suit),<br>              let rank = Rank(rawValue: rank) else {<br>                return nil<br>        }<br>        self.suit = suit<br>        self.rank = rank<br>    }<br>}<br></p><p>let firstCard = Card(suit: 0, rank: 3)<br>let secondCard = Card(suit: 3, rank: 2)<br>firstCard?.rank // returns Four<br>secondCard?.suit // returns Clubs<br></p><p><br></p><p>&gt; On Mar 24, 2016, at 11:18 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, I propose the “#” syntax to be consistent with other proposals that intend to provide compilation-related code. In this case, the proposal is just a way to provide an indication that a certain field within a struct or class should be enforced to be a value of a certain enum, not just a plain integer, by the compiler. Anyhow, I think many different sintaxis could be elaborated. For example, another possible syntax could imply reusing the typealias expression:<br>&gt; <br>&gt; extension Card{<br>&gt; 	typealias suit:CardSuit = suit:Int<br>&gt; }<br>&gt; <br>&gt; However, I assume that using this syntax it should be possible to directly assign to the suit field both an integer or a CardSuit.<br>&gt;&gt; b<br></p><p>&gt;&gt; On Thu, Mar 24, 2016 at 5:41 PM, Carlos Rodríguez Domínguez &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; It is a common practice in C to assign to integer (int, int16, int64, etc.) typed variables “constant&quot; values declared in enums. In swift, it is in fact possible to do that by using enums&#39; “rawValue” property. When importing structs from C into swift, we even get some fields declared with an integer type, but expecting the assignment of a “constant” declared inside an enum. Of course, this is error prone, it is “old-style” programming and very confusing for newcomers. To solve this issue, my proposal is to be able to create extensions that promote certain fields within a class or struct to enums.<br>&gt;&gt; <br>&gt;&gt; For instance, let’s take these sample C struct and enum:<br>&gt;&gt; <br>&gt;&gt; struct Card {<br>&gt;&gt;         int suit;<br>&gt;&gt;         int rank;<br>&gt;&gt; };<br>&gt;&gt; <br>&gt;&gt; typedef enum {HEARTS, DIAMONDS, CLUBS, SPADES} CardSuit;<br>&gt;&gt; <br>&gt;&gt; (Note: I understand that above code follows a bad programming practice, yet it is widely common)<br>&gt;&gt; <br>&gt;&gt; It should be imported into swift as follows:<br>&gt;&gt; <br>&gt;&gt; struct Card {<br>&gt;&gt;         suit:Int<br>&gt;&gt;         value:Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; enum CardSuit : Int {<br>&gt;&gt;         case Hearts, Diamonds, Clubs, Spades<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Now, I propose to be able to create an extension as follows:<br>&gt;&gt; <br>&gt;&gt; extension Card {<br>&gt;&gt;         #enumvalue(suit:CardSuit)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; From this moment on, the suit field should only receive CardSuit values, thus not requiring the use of raw values for assignments.<br>&gt;&gt; <br>&gt;&gt; These extensions should also be of great interest for people using CoreData, since it is not possible to declare enums in models. Therefore, to declare enums, it is necessary to declare integer values, and then use the “unsafe”, “unexpressive&quot; approach explained before.<br>&gt;&gt; <br>&gt;&gt; Note that the proposal intends to only support promotions from integer values to enum values, but, for example, it could also be extended to string values.<br>&gt;&gt; <br>&gt;&gt; Finally, it could be appropriate to extend this proposal to redeclare func’s signatures, in order to promote certain parameters to enum values.<br>&gt;&gt; <br>&gt;&gt; Best,<br>&gt;&gt; <br>&gt;&gt; Carlos.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160324/f53c11fe/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 25, 2016 at 10:00:00am</p></header><div class="content"><p>The key of this proposal is that the struct/class should come from outside any swift source code, that is, either imported by the compiler from C, or auto-generated from any external tool (i.e., a CoreData autogenerated class from a graphically specified data model). Of course, in well written structures (as specified by Paul Ossenbruggen) we shouldn’t have any need for this proposal. However, many C structures make use of a raw type instead of an enum type, but specifying (through the associated documentation, not by any type enforcement) that only a set of enum values are allowed. Consequently, the resulting code making use of those structures becomes highly error prone, and, particularly in swift, very “old-style” code and difficult to understand for newcomers.<br></p><p>Again, I would like to highlight that my proposal intends to avoid as much as possible the use of enums’ raw values.<br></p><p><br>&gt; El 25 mar 2016, a las 6:42, Paul Ossenbruggen &lt;possen at gmail.com&gt; escribió:<br>&gt; <br>&gt; Why can’t you do this? No raw values required, except to initialize the enums.<br>&gt; <br>&gt; struct Card {<br>&gt;     enum Suit : Int { case Hearts, Spades, Diamonds, Clubs }<br>&gt;     enum Rank : Int { case Ace, Two, Three, Four, Five, Six, Seven, Eight, Nine, Jack, Queen, King }<br>&gt; <br>&gt;     let suit : Suit<br>&gt;     let rank : Rank<br>&gt; <br>&gt;     init?(suit: Int, rank: Int) {<br>&gt;         guard let suit = Suit(rawValue: suit),<br>&gt;               let rank = Rank(rawValue: rank) else {<br>&gt;                 return nil<br>&gt;         }<br>&gt;         self.suit = suit<br>&gt;         self.rank = rank<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let firstCard = Card(suit: 0, rank: 3)<br>&gt; let secondCard = Card(suit: 3, rank: 2)<br>&gt; firstCard?.rank // returns Four<br>&gt; secondCard?.suit // returns Clubs<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Mar 24, 2016, at 11:18 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well, I propose the “#” syntax to be consistent with other proposals that intend to provide compilation-related code. In this case, the proposal is just a way to provide an indication that a certain field within a struct or class should be enforced to be a value of a certain enum, not just a plain integer, by the compiler. Anyhow, I think many different sintaxis could be elaborated. For example, another possible syntax could imply reusing the typealias expression:<br>&gt;&gt; <br>&gt;&gt; extension Card{<br>&gt;&gt; 	typealias suit:CardSuit = suit:Int<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; However, I assume that using this syntax it should be possible to directly assign to the suit field both an integer or a CardSuit.<br>&gt;&gt;&gt; b<br>&gt; <br>&gt;&gt;&gt; On Thu, Mar 24, 2016 at 5:41 PM, Carlos Rodríguez Domínguez &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; It is a common practice in C to assign to integer (int, int16, int64, etc.) typed variables “constant&quot; values declared in enums. In swift, it is in fact possible to do that by using enums&#39; “rawValue” property. When importing structs from C into swift, we even get some fields declared with an integer type, but expecting the assignment of a “constant” declared inside an enum. Of course, this is error prone, it is “old-style” programming and very confusing for newcomers. To solve this issue, my proposal is to be able to create extensions that promote certain fields within a class or struct to enums.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For instance, let’s take these sample C struct and enum:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Card {<br>&gt;&gt;&gt;         int suit;<br>&gt;&gt;&gt;         int rank;<br>&gt;&gt;&gt; };<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typedef enum {HEARTS, DIAMONDS, CLUBS, SPADES} CardSuit;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Note: I understand that above code follows a bad programming practice, yet it is widely common)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It should be imported into swift as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Card {<br>&gt;&gt;&gt;         suit:Int<br>&gt;&gt;&gt;         value:Int<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum CardSuit : Int {<br>&gt;&gt;&gt;         case Hearts, Diamonds, Clubs, Spades<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, I propose to be able to create an extension as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Card {<br>&gt;&gt;&gt;         #enumvalue(suit:CardSuit)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; From this moment on, the suit field should only receive CardSuit values, thus not requiring the use of raw values for assignments.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; These extensions should also be of great interest for people using CoreData, since it is not possible to declare enums in models. Therefore, to declare enums, it is necessary to declare integer values, and then use the “unsafe”, “unexpressive&quot; approach explained before.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the proposal intends to only support promotions from integer values to enum values, but, for example, it could also be extended to string values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Finally, it could be appropriate to extend this proposal to redeclare func’s signatures, in order to promote certain parameters to enum values.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Carlos.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160325/c3510d76/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 25, 2016 at 11:00:00am</p></header><div class="content"><p>(Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole)<br></p><p>This proposal intends to allow developers to rewrite func signatures to better adapt certain imported C functions to swift. For instance, the function to create a POSIX socket has a C signature like this:<br></p><p>int socket(int domain, int type, int protocol);<br></p><p>In swift, it is currently imported like this:<br></p><p>func socket(_: Int32, _: Int32, _: Int32) -&gt; Int32<br></p><p>However, by documentation, the first parameter should be one of a set of constants beginning with PF_. The second one should be either SOCK_STREAM, SOCK_DGRAM or SOCK_RAW. The third one should be a constant specifying the protocol to use. Finally, the result could be either -1 (to indicate an error) or another integer to indicate that a socket descriptor has been returned.<br></p><p>As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br></p><p>#mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>	if result == -1 {<br>		return nil<br>	}<br>	else{<br>		return result<br>	}<br>}<br></p><p>Note that the compiler should enforce a function call to the original function that we are rewriting.<br></p><p>After a rewriting has happened, three options may be considered: either to allow the original function to be called, to avoid the original function to be called (through a compiler error with a fix-it) or to emit a warning, advising the developer to adopt the rewritten signature.<br></p><p>Anyhow, this proposal should allow a greatly increased interoperability between old style code and swift, which, in my opinion, is quite “forced” right now.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Reposting my comment from that other thread:<br></p><p>[...] it&#39;s more of an external annotation on C code, something that we don&#39;t currently support for user code. (My understanding is that they have it implemented for Apple frameworks.) Perhaps, with Swift 3 going Linux, with should expose the ability to annotate external code to the users? And enum importing could be a part of that.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 25, 2016 at 02:00:00pm</p></header><div class="content"><p>Well, it might be both an external annotation on C code and something specific within swift. The first is interesting when you have access to the C source code, but the later is good if you either don’t have access to the C source code, or the code (swift, objective-c, C, etc.) is autogenerated by an external tool (for instance, CoreData tools).<br></p><p>&gt; El 25 mar 2016, a las 14:22, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; escribió:<br>&gt; <br>&gt; Reposting my comment from that other thread:<br>&gt; <br>&gt; [...] it&#39;s more of an external annotation on C code, something that we don&#39;t currently support for user code. (My understanding is that they have it implemented for Apple frameworks.) Perhaps, with Swift 3 going Linux, with should expose the ability to annotate external code to the users? And enum importing could be a part of that.<br>&gt; <br>&gt; A.<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 25, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt; <br>&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt; 	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt; 	if result == -1 {<br>&gt; 		return nil<br>&gt; 	}<br>&gt; 	else{<br>&gt; 		return result<br>&gt; 	}<br>&gt; }<br></p><p>What&#39;s wrong with just overloading it like this without hiding the original? That way you can start by directly porting (perhaps even mechanically converting) the code and later refine it to use the nicer Swift-style overload.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 26, 2016 at 11:00:00am</p></header><div class="content"><p>Well, the difference is that the compiler could produce a warning or error with fixit to indicate the developer that an alternative signature to the originally C imported one is available. This way, code ports should gain much readability, while not requiring much effort from the developer to make use of the newer signature.<br></p><p>El 26 mar 2016, a las 5:53, Brent Royal-Gordon &lt;brent at architechies.com&gt; escribió:<br></p><p>&gt;&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt;&gt; <br>&gt;&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt;&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt;&gt;    let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt;&gt;    if result == -1 {<br>&gt;&gt;        return nil<br>&gt;&gt;    }<br>&gt;&gt;    else{<br>&gt;&gt;        return result<br>&gt;&gt;    }<br>&gt;&gt; }<br>&gt; <br>&gt; What&#39;s wrong with just overloading it like this without hiding the original? That way you can start by directly porting (perhaps even mechanically converting) the code and later refine it to use the nicer Swift-style overload.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 26, 2016 at 02:00:00pm</p></header><div class="content"><p>I’ve been rethinking the proposal and maybe a more suitable syntax should be:<br></p><p>#override(socket(_:,_:,_:)-&gt;Int32)<br>func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>	//…<br>}<br></p><p>In this way it is clearer that the idea is to bring func overriding to global functions.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 26, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt;&gt; What&#39;s wrong with just overloading it like this without hiding the original? That way you can start by directly porting (perhaps even mechanically converting) the code and later refine it to use the nicer Swift-style overload.<br>&gt; <br>&gt; Well, the difference is that the compiler could produce a warning or error with fixit to indicate the developer that an alternative signature to the originally C imported one is available. This way, code ports should gain much readability, while not requiring much effort from the developer to make use of the newer signature.<br></p><p>If that&#39;s all you want, maybe we can have an attribute which says &quot;prefer this version over that one&quot;:<br></p><p>	@preferred(since: 3.0, over: socket(_: Int32, _: Int32, _: Int32) -&gt; Int32)<br>	func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>		let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>		if result == -1 {<br>			return nil<br>		}<br>		else{<br>			return result<br>		}<br>	}<br></p><p>This would effectively apply an `@available(deprecated: 3.0, renamed: socket(domain: SocketDomain, type: SocketType, protocol: SocketProtocol) -&gt; socket_t?)` to the other API.<br></p><p>(Or, for that matter, you could simply use an API note to apply that deprecation to the other API, which would not require any new features.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 27, 2016 at 10:00:00am</p></header><div class="content"><p>That’s a really good syntax. Maybe the new @preferred could complete the current @available, by also providing fix-it support. Note that it should be enforced to have “compatible” parameters and return types between the old-style func and the preferred one, as opposed to the current @available, which does not have this enforcement (thus not providing fix-it support). <br></p><p><br>&gt; El 26 mar 2016, a las 22:00, Brent Royal-Gordon &lt;brent at architechies.com&gt; escribió:<br>&gt; <br>&gt;&gt;&gt; What&#39;s wrong with just overloading it like this without hiding the original? That way you can start by directly porting (perhaps even mechanically converting) the code and later refine it to use the nicer Swift-style overload.<br>&gt;&gt; <br>&gt;&gt; Well, the difference is that the compiler could produce a warning or error with fixit to indicate the developer that an alternative signature to the originally C imported one is available. This way, code ports should gain much readability, while not requiring much effort from the developer to make use of the newer signature.<br>&gt; <br>&gt; If that&#39;s all you want, maybe we can have an attribute which says &quot;prefer this version over that one&quot;:<br>&gt; <br>&gt; 	@preferred(since: 3.0, over: socket(_: Int32, _: Int32, _: Int32) -&gt; Int32)<br>&gt; 	func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt; 		let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt; 		if result == -1 {<br>&gt; 			return nil<br>&gt; 		}<br>&gt; 		else{<br>&gt; 			return result<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; This would effectively apply an `@available(deprecated: 3.0, renamed: socket(domain: SocketDomain, type: SocketType, protocol: SocketProtocol) -&gt; socket_t?)` to the other API.<br>&gt; <br>&gt; (Or, for that matter, you could simply use an API note to apply that deprecation to the other API, which would not require any new features.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 27, 2016 at 09:00:00am</p></header><div class="content"><p>+1 for me too, sounds like a very useful syntax with a not incredibly huge cost.<br></p><p>[[iOS messageWithContent:webContent] broadcast]<br></p><p>&gt; On 27 Mar 2016, at 09:31, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That’s a really good syntax. Maybe the new @preferred could complete the current @available, by also providing fix-it support. Note that it should be enforced to have “compatible” parameters and return types between the old-style func and the preferred one, as opposed to the current @available, which does not have this enforcement (thus not providing fix-it support). <br>&gt; <br>&gt; <br>&gt;&gt; El 26 mar 2016, a las 22:00, Brent Royal-Gordon &lt;brent at architechies.com&gt; escribió:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; What&#39;s wrong with just overloading it like this without hiding the original? That way you can start by directly porting (perhaps even mechanically converting) the code and later refine it to use the nicer Swift-style overload.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, the difference is that the compiler could produce a warning or error with fixit to indicate the developer that an alternative signature to the originally C imported one is available. This way, code ports should gain much readability, while not requiring much effort from the developer to make use of the newer signature.<br>&gt;&gt; <br>&gt;&gt; If that&#39;s all you want, maybe we can have an attribute which says &quot;prefer this version over that one&quot;:<br>&gt;&gt; <br>&gt;&gt;    @preferred(since: 3.0, over: socket(_: Int32, _: Int32, _: Int32) -&gt; Int32)<br>&gt;&gt;    func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt;&gt;        let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt;&gt;        if result == -1 {<br>&gt;&gt;            return nil<br>&gt;&gt;        }<br>&gt;&gt;        else{<br>&gt;&gt;            return result<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; This would effectively apply an `@available(deprecated: 3.0, renamed: socket(domain: SocketDomain, type: SocketType, protocol: SocketProtocol) -&gt; socket_t?)` to the other API.<br>&gt;&gt; <br>&gt;&gt; (Or, for that matter, you could simply use an API note to apply that deprecation to the other API, which would not require any new features.)<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>April 25, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Mar 26, 2016, at 2:00 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If that&#39;s all you want, maybe we can have an attribute which says &quot;prefer this version over that one&quot;:<br>&gt; <br>&gt; 	@preferred(since: 3.0, over: socket(_: Int32, _: Int32, _: Int32) -&gt; Int32)<br>&gt; 	func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt; 		…<br>&gt; 	}<br>&gt; <br>&gt; This would effectively apply an `@available(deprecated: 3.0, renamed: socket(domain: SocketDomain, type: SocketType, protocol: SocketProtocol) -&gt; socket_t?)` to the other API.<br></p><p>This capability sounds useful in other situations where some outside API is undesirable in your code. For example in the Swift standard library itself we have our own &quot;halt with an error&quot; functions such as fatalError(). We almost always want to use those instead of something like abort() or exit(). It would be useful to mark fatalError() as the preferred replacement for abort() and exit(). Then the compiler would help enforce our policy.<br></p><p>(In C code we could enforce such non-usage with ugly things like `#define abort() dont_call_abort()`. That ugly solution is not available in Swift.)<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Mar 25, 2016, at 3:25 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole)<br>&gt; <br>&gt; This proposal intends to allow developers to rewrite func signatures to better adapt certain imported C functions to swift. For instance, the function to create a POSIX socket has a C signature like this:<br>&gt; <br>&gt; int socket(int domain, int type, int protocol);<br>&gt; <br>&gt; In swift, it is currently imported like this:<br>&gt; <br>&gt; func socket(_: Int32, _: Int32, _: Int32) -&gt; Int32<br>&gt; <br>&gt; However, by documentation, the first parameter should be one of a set of constants beginning with PF_. The second one should be either SOCK_STREAM, SOCK_DGRAM or SOCK_RAW. The third one should be a constant specifying the protocol to use. Finally, the result could be either -1 (to indicate an error) or another integer to indicate that a socket descriptor has been returned.<br>&gt; <br>&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt; <br>&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt; 	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt; 	if result == -1 {<br>&gt; 		return nil<br>&gt; 	}<br>&gt; 	else{<br>&gt; 		return result<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Note that the compiler should enforce a function call to the original function that we are rewriting.<br>&gt; <br>&gt; After a rewriting has happened, three options may be considered: either to allow the original function to be called, to avoid the original function to be called (through a compiler error with a fix-it) or to emit a warning, advising the developer to adopt the rewritten signature.<br>&gt; <br>&gt; Anyhow, this proposal should allow a greatly increased interoperability between old style code and swift, which, in my opinion, is quite “forced” right now.<br></p><p>FWIW, there have been a number of proposals in roughly this space, using annotations in the C headers to improve the mapping into Swift, including<br></p><p>	Import as member: https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md<br>	Import Objective-C constants as Swift types: https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md<br>	Better translation of Objective-C APIs into Swift (the swift_name attribute part, at least): https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Well, those proposal are more oriented towards annotating on C/Objective-C files to allow a more sophisticate import into swift. However, my proposal is to be able to directly annotate in swift, in order to fix “old-style” imports, autogenerated code, etc. Please, allow me to repeat myself, but consider the example of Core Data, in which model classes are autogenerated from a graphical model that, for instance, lacks from enums’ support. Therefore, if we use Core Data, then we can not use enums (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole).<br></p><p>&gt; El 28 mar 2016, a las 7:29, Douglas Gregor &lt;dgregor at apple.com&gt; escribió:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 3:25 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole)<br>&gt;&gt; <br>&gt;&gt; This proposal intends to allow developers to rewrite func signatures to better adapt certain imported C functions to swift. For instance, the function to create a POSIX socket has a C signature like this:<br>&gt;&gt; <br>&gt;&gt; int socket(int domain, int type, int protocol);<br>&gt;&gt; <br>&gt;&gt; In swift, it is currently imported like this:<br>&gt;&gt; <br>&gt;&gt; func socket(_: Int32, _: Int32, _: Int32) -&gt; Int32<br>&gt;&gt; <br>&gt;&gt; However, by documentation, the first parameter should be one of a set of constants beginning with PF_. The second one should be either SOCK_STREAM, SOCK_DGRAM or SOCK_RAW. The third one should be a constant specifying the protocol to use. Finally, the result could be either -1 (to indicate an error) or another integer to indicate that a socket descriptor has been returned.<br>&gt;&gt; <br>&gt;&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt;&gt; <br>&gt;&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt;&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt;&gt; 	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt;&gt; 	if result == -1 {<br>&gt;&gt; 		return nil<br>&gt;&gt; 	}<br>&gt;&gt; 	else{<br>&gt;&gt; 		return result<br>&gt;&gt; 	}<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Note that the compiler should enforce a function call to the original function that we are rewriting.<br>&gt;&gt; <br>&gt;&gt; After a rewriting has happened, three options may be considered: either to allow the original function to be called, to avoid the original function to be called (through a compiler error with a fix-it) or to emit a warning, advising the developer to adopt the rewritten signature.<br>&gt;&gt; <br>&gt;&gt; Anyhow, this proposal should allow a greatly increased interoperability between old style code and swift, which, in my opinion, is quite “forced” right now.<br>&gt; <br>&gt; FWIW, there have been a number of proposals in roughly this space, using annotations in the C headers to improve the mapping into Swift, including<br>&gt; <br>&gt; 	Import as member: https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md<br>&gt; 	Import Objective-C constants as Swift types: https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md<br>&gt; 	Better translation of Objective-C APIs into Swift (the swift_name attribute part, at least): https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9211cc51e7e6f1221cce0842f653735a?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Thomas Guthrie</string> &lt;tomguthrie at gmail.com&gt;<p>March 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 29 Mar 2016, at 11:02, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Well, those proposal are more oriented towards annotating on C/Objective-C files to allow a more sophisticate import into swift. However, my proposal is to be able to directly annotate in swift, in order to fix “old-style” imports, autogenerated code, etc. Please, allow me to repeat myself, but consider the example of Core Data, in which model classes are autogenerated from a graphical model that, for instance, lacks from enums’ support. Therefore, if we use Core Data, then we can not use enums (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole).<br></p><p>If you can’t annotate the headers why not have a wrapper module that uses the C version of the module internally? Then anywhere that uses the original, int using version, has to explicitly import it. (For example a Sqlite module internally imports CSqlite) I don’t know if SwiftPM allows explicit submodules &lt;http://clang.llvm.org/docs/Modules.html#submodule-declaration&gt; but if it does that means only your wrapper module has access to the int version.<br></p><p>This seems much better than an annotation that basically only hides an imported function that you’d have to include in any project using the C library anyway.<br></p><p><br>— Thomas<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/a77c73f0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>March 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 29, 2016, at 3:02 AM, Carlos Rodríguez Domínguez &lt;carlos at everywaretech.es&gt; wrote:<br>&gt; <br>&gt; Well, those proposal are more oriented towards annotating on C/Objective-C files to allow a more sophisticate import into swift.<br></p><p>Yes, that is true. The philosophy behind these is that it’s better to automatically transform (via annotation) than manually wrap. Naturally, such transformations cannot handle everything.<br></p><p>&gt; However, my proposal is to be able to directly annotate in swift, in order to fix “old-style” imports, autogenerated code, etc. Please, allow me to repeat myself, but consider the example of Core Data, in which model classes are autogenerated from a graphical model that, for instance, lacks from enums’ support. Therefore, if we use Core Data, then we can not use enums (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole).<br></p><p>There is a Clang attribute “swift_private” that prefixes the name of the declaration with “__” when it is imported into Swift. That way, you can wrap it with a different, more Swift-friendly, API that calls the “__” version.<br></p><p>Note that we do have a mechanism for annotating C/Objective-C APIs without modifying the headers, called “API notes”. It’s a simple YAML format that lets us describe various Clang attributes for entities, e.g., provide the Swift name for a given C function, mark a type as unavailable in Swift, and so on. It’s semi-documented in the swift-clang sources:<br></p><p>	https://github.com/apple/swift-clang/blob/upstream-with-swift/lib/APINotes/APINotesYAMLCompiler.cpp<br></p><p>Essentially, one writes a YAML file for each module that needs annotation. API notes was designed as a transitional technology, so it’s a bit under-designed for a general-purpose tool. However, as we add more Clang-side annotations to improve the mapping of C/Objective-C APIs into Swift, it’s becoming more likely that API notes could/should grow into a more general mechanism for adapting existing C/Objective-C APIs to Swift without manually wrapping everything.<br></p><p>	- Doug<br></p><p>&gt;&gt; El 28 mar 2016, a las 7:29, Douglas Gregor &lt;dgregor at apple.com&gt; escribió:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 25, 2016, at 3:25 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal intends to allow developers to rewrite func signatures to better adapt certain imported C functions to swift. For instance, the function to create a POSIX socket has a C signature like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; int socket(int domain, int type, int protocol);<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In swift, it is currently imported like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func socket(_: Int32, _: Int32, _: Int32) -&gt; Int32<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, by documentation, the first parameter should be one of a set of constants beginning with PF_. The second one should be either SOCK_STREAM, SOCK_DGRAM or SOCK_RAW. The third one should be a constant specifying the protocol to use. Finally, the result could be either -1 (to indicate an error) or another integer to indicate that a socket descriptor has been returned.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt;&gt;&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt;&gt;&gt; 	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt;&gt;&gt; 	if result == -1 {<br>&gt;&gt;&gt; 		return nil<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; 	else{<br>&gt;&gt;&gt; 		return result<br>&gt;&gt;&gt; 	}<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that the compiler should enforce a function call to the original function that we are rewriting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After a rewriting has happened, three options may be considered: either to allow the original function to be called, to avoid the original function to be called (through a compiler error with a fix-it) or to emit a warning, advising the developer to adopt the rewritten signature.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anyhow, this proposal should allow a greatly increased interoperability between old style code and swift, which, in my opinion, is quite “forced” right now.<br>&gt;&gt; <br>&gt;&gt; FWIW, there have been a number of proposals in roughly this space, using annotations in the C headers to improve the mapping into Swift, including<br>&gt;&gt; <br>&gt;&gt; 	Import as member: https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md<br>&gt;&gt; 	Import Objective-C constants as Swift types: https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md<br>&gt;&gt; 	Better translation of Objective-C APIs into Swift (the swift_name attribute part, at least): https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>April 25, 2016 at 12:00:00am</p></header><div class="content"><p>Thanks for the explanation, which makes me think that it should be suitable, as you comment, to promote API notes to a “first class” transition technology.<br></p><p>As a first approach towards that goal, would it be ok to expand the notion of “bridging headers” to also include API notes? In that case, it could be appropriate to develop a new C syntax to refer to YAML API notes inside bridging headers. For instance, something like this could be nice:<br></p><p>#apinotes “notes.yaml”<br></p><p><br>&gt; El 29 mar 2016, a las 18:45, Douglas Gregor &lt;dgregor at apple.com&gt; escribió:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 29, 2016, at 3:02 AM, Carlos Rodríguez Domínguez &lt;carlos at everywaretech.es&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Well, those proposal are more oriented towards annotating on C/Objective-C files to allow a more sophisticate import into swift.<br>&gt; <br>&gt; Yes, that is true. The philosophy behind these is that it’s better to automatically transform (via annotation) than manually wrap. Naturally, such transformations cannot handle everything.<br>&gt; <br>&gt;&gt; However, my proposal is to be able to directly annotate in swift, in order to fix “old-style” imports, autogenerated code, etc. Please, allow me to repeat myself, but consider the example of Core Data, in which model classes are autogenerated from a graphical model that, for instance, lacks from enums’ support. Therefore, if we use Core Data, then we can not use enums (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole).<br>&gt; <br>&gt; There is a Clang attribute “swift_private” that prefixes the name of the declaration with “__” when it is imported into Swift. That way, you can wrap it with a different, more Swift-friendly, API that calls the “__” version.<br>&gt; <br>&gt; Note that we do have a mechanism for annotating C/Objective-C APIs without modifying the headers, called “API notes”. It’s a simple YAML format that lets us describe various Clang attributes for entities, e.g., provide the Swift name for a given C function, mark a type as unavailable in Swift, and so on. It’s semi-documented in the swift-clang sources:<br>&gt; <br>&gt; 	https://github.com/apple/swift-clang/blob/upstream-with-swift/lib/APINotes/APINotesYAMLCompiler.cpp<br>&gt; <br>&gt; Essentially, one writes a YAML file for each module that needs annotation. API notes was designed as a transitional technology, so it’s a bit under-designed for a general-purpose tool. However, as we add more Clang-side annotations to improve the mapping of C/Objective-C APIs into Swift, it’s becoming more likely that API notes could/should grow into a more general mechanism for adapting existing C/Objective-C APIs to Swift without manually wrapping everything.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt;&gt;&gt; El 28 mar 2016, a las 7:29, Douglas Gregor &lt;dgregor at apple.com&gt; escribió:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Mar 25, 2016, at 3:25 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal intends to allow developers to rewrite func signatures to better adapt certain imported C functions to swift. For instance, the function to create a POSIX socket has a C signature like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; int socket(int domain, int type, int protocol);<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In swift, it is currently imported like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; func socket(_: Int32, _: Int32, _: Int32) -&gt; Int32<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; However, by documentation, the first parameter should be one of a set of constants beginning with PF_. The second one should be either SOCK_STREAM, SOCK_DGRAM or SOCK_RAW. The third one should be a constant specifying the protocol to use. Finally, the result could be either -1 (to indicate an error) or another integer to indicate that a socket descriptor has been returned.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt;&gt;&gt;&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt;&gt;&gt;&gt; 	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt;&gt;&gt;&gt; 	if result == -1 {<br>&gt;&gt;&gt;&gt; 		return nil<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; 	else{<br>&gt;&gt;&gt;&gt; 		return result<br>&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that the compiler should enforce a function call to the original function that we are rewriting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; After a rewriting has happened, three options may be considered: either to allow the original function to be called, to avoid the original function to be called (through a compiler error with a fix-it) or to emit a warning, advising the developer to adopt the rewritten signature.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anyhow, this proposal should allow a greatly increased interoperability between old style code and swift, which, in my opinion, is quite “forced” right now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, there have been a number of proposals in roughly this space, using annotations in the C headers to improve the mapping into Swift, including<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	Import as member: https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md<br>&gt;&gt;&gt; 	Import Objective-C constants as Swift types: https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md<br>&gt;&gt;&gt; 	Better translation of Objective-C APIs into Swift (the swift_name attribute part, at least): https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Rewrite imported C function signatures</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 3:45 PM, Carlos Rodríguez Domínguez &lt;carlos at everywaretech.es&gt; wrote:<br>&gt; <br>&gt; Thanks for the explanation, which makes me think that it should be suitable, as you comment, to promote API notes to a “first class” transition technology.<br>&gt; <br>&gt; As a first approach towards that goal, would it be ok to expand the notion of “bridging headers” to also include API notes? In that case, it could be appropriate to develop a new C syntax to refer to YAML API notes inside bridging headers. For instance, something like this could be nice:<br>&gt; <br>&gt; #apinotes “notes.yaml”<br></p><p>I think of API notes like module maps: it’s an external format that lays additional semantic information on top of existing headers without requiring you to modify those headers (because you often don’t control them).<br></p><p>	- Doug<br></p><p>&gt; <br>&gt; <br>&gt;&gt; El 29 mar 2016, a las 18:45, Douglas Gregor &lt;dgregor at apple.com&gt; escribió:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 29, 2016, at 3:02 AM, Carlos Rodríguez Domínguez &lt;carlos at everywaretech.es&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Well, those proposal are more oriented towards annotating on C/Objective-C files to allow a more sophisticate import into swift.<br>&gt;&gt; <br>&gt;&gt; Yes, that is true. The philosophy behind these is that it’s better to automatically transform (via annotation) than manually wrap. Naturally, such transformations cannot handle everything.<br>&gt;&gt; <br>&gt;&gt;&gt; However, my proposal is to be able to directly annotate in swift, in order to fix “old-style” imports, autogenerated code, etc. Please, allow me to repeat myself, but consider the example of Core Data, in which model classes are autogenerated from a graphical model that, for instance, lacks from enums’ support. Therefore, if we use Core Data, then we can not use enums (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole).<br>&gt;&gt; <br>&gt;&gt; There is a Clang attribute “swift_private” that prefixes the name of the declaration with “__” when it is imported into Swift. That way, you can wrap it with a different, more Swift-friendly, API that calls the “__” version.<br>&gt;&gt; <br>&gt;&gt; Note that we do have a mechanism for annotating C/Objective-C APIs without modifying the headers, called “API notes”. It’s a simple YAML format that lets us describe various Clang attributes for entities, e.g., provide the Swift name for a given C function, mark a type as unavailable in Swift, and so on. It’s semi-documented in the swift-clang sources:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-clang/blob/upstream-with-swift/lib/APINotes/APINotesYAMLCompiler.cpp<br>&gt;&gt; <br>&gt;&gt; Essentially, one writes a YAML file for each module that needs annotation. API notes was designed as a transitional technology, so it’s a bit under-designed for a general-purpose tool. However, as we add more Clang-side annotations to improve the mapping of C/Objective-C APIs into Swift, it’s becoming more likely that API notes could/should grow into a more general mechanism for adapting existing C/Objective-C APIs to Swift without manually wrapping everything.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; El 28 mar 2016, a las 7:29, Douglas Gregor &lt;dgregor at apple.com&gt; escribió:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mar 25, 2016, at 3:25 AM, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; (Please, take a look at the proposal named &quot;[swift-evolution] Promote &quot;primitive&quot; types to enums in extensions” in order to understand the intention of my proposal as a whole)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal intends to allow developers to rewrite func signatures to better adapt certain imported C functions to swift. For instance, the function to create a POSIX socket has a C signature like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; int socket(int domain, int type, int protocol);<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In swift, it is currently imported like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; func socket(_: Int32, _: Int32, _: Int32) -&gt; Int32<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; However, by documentation, the first parameter should be one of a set of constants beginning with PF_. The second one should be either SOCK_STREAM, SOCK_DGRAM or SOCK_RAW. The third one should be a constant specifying the protocol to use. Finally, the result could be either -1 (to indicate an error) or another integer to indicate that a socket descriptor has been returned.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; As you can observe, that old-style signature is highly error prone, does not comply with swift guidelines, it is difficult to understand, etc. My opinion is that there should be some syntax to rewrite the signature to avoid those issues. For instance, a possible syntax could be:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; #mapsignature(socket(_:,_:,_:)-&gt;Int32)<br>&gt;&gt;&gt;&gt;&gt; func socket(domain:SocketDomain, type:SocketType, protocol:SocketProtocol) -&gt; socket_t? {<br>&gt;&gt;&gt;&gt;&gt; 	let result = socket(domain.rawValue, type.rawValue, protocol.rawValue)<br>&gt;&gt;&gt;&gt;&gt; 	if result == -1 {<br>&gt;&gt;&gt;&gt;&gt; 		return nil<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; 	else{<br>&gt;&gt;&gt;&gt;&gt; 		return result<br>&gt;&gt;&gt;&gt;&gt; 	}<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that the compiler should enforce a function call to the original function that we are rewriting.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; After a rewriting has happened, three options may be considered: either to allow the original function to be called, to avoid the original function to be called (through a compiler error with a fix-it) or to emit a warning, advising the developer to adopt the rewritten signature.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anyhow, this proposal should allow a greatly increased interoperability between old style code and swift, which, in my opinion, is quite “forced” right now.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; FWIW, there have been a number of proposals in roughly this space, using annotations in the C headers to improve the mapping into Swift, including<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	Import as member: https://github.com/apple/swift-evolution/blob/master/proposals/0044-import-as-member.md<br>&gt;&gt;&gt;&gt; 	Import Objective-C constants as Swift types: https://github.com/apple/swift-evolution/blob/master/proposals/0033-import-objc-constants.md<br>&gt;&gt;&gt;&gt; 	Better translation of Objective-C APIs into Swift (the swift_name attribute part, at least): https://github.com/apple/swift-evolution/blob/master/proposals/0005-objective-c-name-translation.md<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 25, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 25 Mar 2016, at 09:56, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The key of this proposal is that the struct/class should come from outside any swift source code, that is, either imported by the compiler from C, or auto-generated from any external tool (i.e., a CoreData autogenerated class from a graphically specified data model). Of course, in well written structures (as specified by Paul Ossenbruggen) we shouldn’t have any need for this proposal. However, many C structures make use of a raw type instead of an enum type, but specifying (through the associated documentation, not by any type enforcement) that only a set of enum values are allowed. Consequently, the resulting code making use of those structures becomes highly error prone, and, particularly in swift, very “old-style” code and difficult to understand for newcomers.<br>&gt; <br>&gt; Again, I would like to highlight that my proposal intends to avoid as much as possible the use of enums’ raw values.<br></p><p>I think I may be similarly misunderstanding your proposal; your intention then is to import the type as an enum with raw value (to facilitate the conversion to/from the C code) but without exposing that raw value on the Swift side?<br></p><p>In that case I think I’m in favour.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Yes, exactly, that’s a great summary of the proposal!<br></p><p>&gt; El 25 mar 2016, a las 12:25, Haravikk &lt;swift-evolution at haravikk.me&gt; escribió:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Mar 2016, at 09:56, Carlos Rodríguez Domínguez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The key of this proposal is that the struct/class should come from outside any swift source code, that is, either imported by the compiler from C, or auto-generated from any external tool (i.e., a CoreData autogenerated class from a graphically specified data model). Of course, in well written structures (as specified by Paul Ossenbruggen) we shouldn’t have any need for this proposal. However, many C structures make use of a raw type instead of an enum type, but specifying (through the associated documentation, not by any type enforcement) that only a set of enum values are allowed. Consequently, the resulting code making use of those structures becomes highly error prone, and, particularly in swift, very “old-style” code and difficult to understand for newcomers.<br>&gt;&gt; <br>&gt;&gt; Again, I would like to highlight that my proposal intends to avoid as much as possible the use of enums’ raw values.<br>&gt; <br>&gt; I think I may be similarly misunderstanding your proposal; your intention then is to import the type as an enum with raw value (to facilitate the conversion to/from the C code) but without exposing that raw value on the Swift side?<br>&gt; <br>&gt; In that case I think I’m in favour.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f822334c2f6ebeafd3a41cd44c82a62b?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Andrey Tarantsov</string> &lt;andrey at tarantsov.com&gt;<p>March 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; I think I may be similarly misunderstanding your proposal; your intention then is to import the type as an enum with raw value (to facilitate the conversion to/from the C code) but without exposing that raw value on the Swift side?<br>&gt; <br>&gt; In that case I think I’m in favour.<br></p><p>Me too.<br></p><p>But perhaps not through the originally proposed syntax. I don&#39;t think this is an extension — it&#39;s more of an external annotation on C code, something that we don&#39;t currently support for user code. (My understanding is that they have it implemented for Apple frameworks.)<br></p><p>Perhaps, with Swift 3 going Linux, with should expose the ability to annotate external code to the users? And enum importing could be a part of that.<br></p><p>A.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1507f328ec552aa99fe2a158caacef44?s=50"></div><header><strong>Promote &quot;primitive&quot; types to enums in extensions</strong> from <string>Carlos Rodríguez Domínguez</string> &lt;carlos at everywaretech.es&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>(Recalling from the other thread…)<br></p><p>Well, it might be both an external annotation on C code and something specific within swift. The first is interesting when you have access to the C source code, but the later is good if you either don’t have access to the C source code, or the code (swift, objective-c, C, etc.) is autogenerated by an external tool (for instance, CoreData tools).<br></p><p>&gt; El 25 mar 2016, a las 14:20, Andrey Tarantsov &lt;andrey at tarantsov.com&gt; escribió:<br>&gt; <br>&gt;&gt; I think I may be similarly misunderstanding your proposal; your intention then is to import the type as an enum with raw value (to facilitate the conversion to/from the C code) but without exposing that raw value on the Swift side?<br>&gt;&gt; <br>&gt;&gt; In that case I think I’m in favour.<br>&gt; <br>&gt; Me too.<br>&gt; <br>&gt; But perhaps not through the originally proposed syntax. I don&#39;t think this is an extension — it&#39;s more of an external annotation on C code, something that we don&#39;t currently support for user code. (My understanding is that they have it implemented for Apple frameworks.)<br>&gt; <br>&gt; Perhaps, with Swift 3 going Linux, with should expose the ability to annotate external code to the users? And enum importing could be a part of that.<br>&gt; <br>&gt; A.<br>&gt; <br>&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
