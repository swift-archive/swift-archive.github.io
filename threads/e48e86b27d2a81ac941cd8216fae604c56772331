<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 20, 2016 at 07:00:00am</p></header><div class="content"><p>Hi,<br></p><p>Is there a way to find out how big an object is on the heap?<br></p><p>Cheers,<br></p><p> — Howard.<br></p><p>PS I did search swift-users but no luck :(<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Object size on heap</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>March 21, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Mar 19, 2016, at 4:53 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Is there a way to find out how big an object is on the heap?<br></p><p>Yes, the sizeof() &lt;http://swiftdoc.org/v2.2/func/sizeof/&gt; function.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160321/9ba07a96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Object size on heap</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;&gt; Is there a way to find out how big an object is on the heap?<br>&gt; <br>&gt; Yes, the sizeof() function.<br></p><p>I think he&#39;s asking for the size of the object itself. For a reference type, `sizeof()` gives you the size of the reference.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Object size on heap</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 21, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 19, 2016, at 1:53 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; <br>&gt; Is there a way to find out how big an object is on the heap?<br></p><p>No public API yet. For entertainment purposes, you could use the runtime&#39;s swift_class_getInstanceExtents function, passing in the class object for the instance.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 22, 2016 at 03:00:00pm</p></header><div class="content"><p>How do you call swift_class_getInstanceExtents, it doesn&#39;t show in Xcode?<br></p><p>  -- Howard.<br></p><p>On 22 March 2016 at 06:07, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Mar 19, 2016, at 1:53 PM, Howard Lovatt via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hi,<br>&gt; &gt;<br>&gt; &gt; Is there a way to find out how big an object is on the heap?<br>&gt;<br>&gt; No public API yet. For entertainment purposes, you could use the runtime&#39;s<br>&gt; swift_class_getInstanceExtents function, passing in the class object for<br>&gt; the instance.<br>&gt;<br>&gt; -Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160322/d79d1572/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Object size on heap</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March 22, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On Mar 21, 2016, at 9:31 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; How do you call swift_class_getInstanceExtents, it doesn&#39;t show in Xcode?<br></p><p>It&#39;s not provided as API by default. You can do this as an unsupported hack:<br></p><p>@_silgen_name(&quot;swift_class_getInstanceExtents&quot;)<br>func swift_class_getInstanceExtents(theClass: AnyClass)<br>  -&gt; (negative: UInt, positive: UInt)<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160322/051f8ba8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Object size on heap</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>March 22, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 22, 2016, at 8:47, Joe Groff via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 21, 2016, at 9:31 PM, Howard Lovatt &lt;howard.lovatt at gmail.com &lt;mailto:howard.lovatt at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; How do you call swift_class_getInstanceExtents, it doesn&#39;t show in Xcode?<br>&gt; <br>&gt; It&#39;s not provided as API by default. You can do this as an unsupported hack:<br>&gt; <br>&gt; @_silgen_name(&quot;swift_class_getInstanceExtents&quot;)<br>&gt; func swift_class_getInstanceExtents(theClass: AnyClass)<br>&gt;   -&gt; (negative: UInt, positive: UInt)<br></p><p>This has probably gone too far to hide it already, but, um, what do you plan to do with this information?<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160322/684ef62b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 23, 2016 at 02:00:00pm</p></header><div class="content"><p>I am writing custom collection classes and trying to assess which one is<br>better, both in terms of performance and memory usage. Won&#39;t be used in<br>&#39;real&#39; code, just to guide development.<br></p><p>  -- Howard.<br></p><p>On 23 March 2016 at 03:52, Jordan Rose &lt;jordan_rose at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 22, 2016, at 8:47, Joe Groff via swift-users &lt;swift-users at swift.org&gt;<br>&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Mar 21, 2016, at 9:31 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How do you call swift_class_getInstanceExtents, it doesn&#39;t show in Xcode?<br>&gt;<br>&gt;<br>&gt; It&#39;s not provided as API by default. You can do this as an unsupported<br>&gt; hack:<br>&gt;<br>&gt; @_silgen_name(&quot;swift_class_getInstanceExtents&quot;)<br>&gt; func swift_class_getInstanceExtents(theClass: AnyClass)<br>&gt;   -&gt; (negative: UInt, positive: UInt)<br>&gt;<br>&gt;<br>&gt; This has probably gone too far to hide it already, but, um, what do you<br>&gt; plan to do with this information?<br>&gt;<br>&gt; Jordan<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160323/83289877/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Object size on heap</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>March 23, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 22, 2016, at 11:04 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I am writing custom collection classes and trying to assess which one is better, both in terms of performance and memory usage. Won&#39;t be used in &#39;real&#39; code, just to guide development.<br></p><p>You might consider using heap profiling tools too, like (on Mac OS) the Instruments app or the `heap` command-line tool. If you use these while running a benchmark app using your API, it can show you how much total heap space gets used.<br></p><p>Actual heap usage can differ from the raw “sizeof” a data type, since allocators will often round up block sizes or return a somewhat larger block than necessary. Heap fragmentation can also increase memory usage beyond what you’d expect, and different allocation patterns can affect fragmentation.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160323/9527cbeb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 24, 2016 at 09:00:00am</p></header><div class="content"><p>Thanks, I will give that a try<br></p><p>  -- Howard.<br></p><p>On 24 March 2016 at 03:17, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 22, 2016, at 11:04 PM, Howard Lovatt via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I am writing custom collection classes and trying to assess which one is<br>&gt; better, both in terms of performance and memory usage. Won&#39;t be used in<br>&gt; &#39;real&#39; code, just to guide development.<br>&gt;<br>&gt;<br>&gt; You might consider using heap profiling tools too, like (on Mac OS) the<br>&gt; Instruments app or the `heap` command-line tool. If you use these while<br>&gt; running a benchmark app using your API, it can show you how much total heap<br>&gt; space gets used.<br>&gt;<br>&gt; Actual heap usage can differ from the raw “sizeof” a data type, since<br>&gt; allocators will often round up block sizes or return a somewhat larger<br>&gt; block than necessary. Heap fragmentation can also increase memory usage<br>&gt; beyond what you’d expect, and different allocation patterns can affect<br>&gt; fragmentation.<br>&gt;<br>&gt; —Jens<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160324/e8897a22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d631f09a3a336a15ae258e01899cb736?s=50"></div><header><strong>Object size on heap</strong> from <string>Kate Stone</string> &lt;k8stone at apple.com&gt;<p>March 23, 2016 at 04:00:00pm</p></header><div class="content"><p>I definitely concur that tools like Instruments are the best way to understand the impact of decisions on memory across the board.  For fine-grained inquiries about memory use you can also rely on malloc family functions to make inquiries:<br></p><p>let required_size = malloc_size(unsafeAddressOf(object_reference))<br>let actual_size = malloc_good_size(required_size)<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>&gt; On Mar 23, 2016, at 3:59 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks, I will give that a try<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 24 March 2016 at 03:17, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mar 22, 2016, at 11:04 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I am writing custom collection classes and trying to assess which one is better, both in terms of performance and memory usage. Won&#39;t be used in &#39;real&#39; code, just to guide development.<br>&gt; <br>&gt; You might consider using heap profiling tools too, like (on Mac OS) the Instruments app or the `heap` command-line tool. If you use these while running a benchmark app using your API, it can show you how much total heap space gets used.<br>&gt; <br>&gt; Actual heap usage can differ from the raw “sizeof” a data type, since allocators will often round up block sizes or return a somewhat larger block than necessary. Heap fragmentation can also increase memory usage beyond what you’d expect, and different allocation patterns can affect fragmentation.<br>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160323/10312774/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>@Kate,<br></p><p>I don&#39;t seem to be able to get `malloc_...` to work. EG:<br></p><p>class TestClass {<br>    let a = 0<br>    let b: Int? = nil<br>}<br>@_silgen_name(&quot;swift_class_getInstanceExtents&quot;) func<br>swift_class_getInstanceExtents(theClass: AnyClass) -&gt; (negative: UInt,<br>positive: UInt)<br>print(&quot;swift_class_getInstanceExtents =<br>\(swift_class_getInstanceExtents(TestClass))&quot;)<br>let requiredSize = malloc_size(unsafeAddressOf(TestClass()))<br>print(&quot;malloc_size = \(requiredSize)&quot;)<br>print(&quot;malloc_good_size = \(malloc_good_size(requiredSize))&quot;)<br></p><p><br>Prints:<br></p><p>swift_class_getInstanceExtents = (0, 33)<br>malloc_size = 0<br>malloc_good_size = 16<br></p><p><br>The `swift_class_getInstanceExtents` seems correct to me: 16 bytes for<br>class overhead + 16 bytes for `a` and `b` + 1 byte because `b` is an<br>optional = 33 bytes.<br></p><p>Not sure what `malloc_...` is giving?<br></p><p>  -- Howard.<br></p><p>On 24 March 2016 at 10:39, Kate Stone &lt;k8stone at apple.com&gt; wrote:<br></p><p>&gt; I definitely concur that tools like Instruments are the best way to<br>&gt; understand the impact of decisions on memory across the board.  For<br>&gt; fine-grained inquiries about memory use you can also rely on malloc family<br>&gt; functions to make inquiries:<br>&gt;<br>&gt; let required_size = malloc_size(unsafeAddressOf(*object_reference*))<br>&gt; let actual_size = malloc_good_size(required_size)<br>&gt;<br>&gt;<br>&gt; Kate Stone k8stone at apple.com<br>&gt;  Xcode Low Level Tools<br>&gt;<br>&gt; On Mar 23, 2016, at 3:59 PM, Howard Lovatt via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; Thanks, I will give that a try<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 24 March 2016 at 03:17, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Mar 22, 2016, at 11:04 PM, Howard Lovatt via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I am writing custom collection classes and trying to assess which one is<br>&gt;&gt; better, both in terms of performance and memory usage. Won&#39;t be used in<br>&gt;&gt; &#39;real&#39; code, just to guide development.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; You might consider using heap profiling tools too, like (on Mac OS) the<br>&gt;&gt; Instruments app or the `heap` command-line tool. If you use these while<br>&gt;&gt; running a benchmark app using your API, it can show you how much total heap<br>&gt;&gt; space gets used.<br>&gt;&gt;<br>&gt;&gt; Actual heap usage can differ from the raw “sizeof” a data type, since<br>&gt;&gt; allocators will often round up block sizes or return a somewhat larger<br>&gt;&gt; block than necessary. Heap fragmentation can also increase memory usage<br>&gt;&gt; beyond what you’d expect, and different allocation patterns can affect<br>&gt;&gt; fragmentation.<br>&gt;&gt;<br>&gt;&gt; —Jens<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160324/55a5d1fc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d631f09a3a336a15ae258e01899cb736?s=50"></div><header><strong>Object size on heap</strong> from <string>Kate Stone</string> &lt;k8stone at apple.com&gt;<p>March 23, 2016 at 05:00:00pm</p></header><div class="content"><p>You’re almost certainly seeing side effects of not keeping the instance of TestClass alive long enough for the unsafe pointer to still refer to an allocated malloc block.  A quick REPL session illustrates this fact:<br></p><p>  1&gt; class TestClass { <br>  2.     let a = 0 <br>  3.     let b: Int? = nil <br>  4. }<br>  5&gt; import Foundation<br>  6&gt; malloc_size(unsafeAddressOf(TestClass())) <br>$R0: Int = 0<br>  7&gt; let x = TestClass()<br>x: TestClass = {<br>  a = 0<br>  b = nil<br>}<br>  8&gt; malloc_size(unsafeAddressOf(x))<br>$R1: Int = 48<br></p><p>On line 6 the result of the TestClass() expression is being used only to call unsafeAddressOf, and then it’s being freed before the call to malloc_size.  On line 8 the variable x is retaining the instance so the malloc’ed region can be measured.<br></p><p>Of course all of this relies on the implementation assumption that allocated objects go on malloc’s heap and is subject to implementation details about object layout.  So while this may be instructive now it’s certainly no guarantee of how things will work in the future.<br></p><p>Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br> Xcode Low Level Tools<br></p><p>&gt; On Mar 23, 2016, at 5:13 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt; wrote:<br>&gt; <br>&gt; @Kate,<br>&gt; <br>&gt; I don&#39;t seem to be able to get `malloc_...` to work. EG:<br>&gt; <br>&gt; class TestClass {<br>&gt;     let a = 0<br>&gt;     let b: Int? = nil<br>&gt; }<br>&gt; @_silgen_name(&quot;swift_class_getInstanceExtents&quot;) func swift_class_getInstanceExtents(theClass: AnyClass) -&gt; (negative: UInt, positive: UInt)<br>&gt; print(&quot;swift_class_getInstanceExtents = \(swift_class_getInstanceExtents(TestClass))&quot;)<br>&gt; let requiredSize = malloc_size(unsafeAddressOf(TestClass()))<br>&gt; print(&quot;malloc_size = \(requiredSize)&quot;)<br>&gt; print(&quot;malloc_good_size = \(malloc_good_size(requiredSize))&quot;)<br>&gt; <br>&gt; Prints:<br>&gt; <br>&gt; swift_class_getInstanceExtents = (0, 33)<br>&gt; malloc_size = 0<br>&gt; malloc_good_size = 16<br>&gt; <br>&gt; The `swift_class_getInstanceExtents` seems correct to me: 16 bytes for class overhead + 16 bytes for `a` and `b` + 1 byte because `b` is an optional = 33 bytes.<br>&gt; <br>&gt; Not sure what `malloc_...` is giving?<br>&gt; <br>&gt;   -- Howard.<br>&gt; <br>&gt; On 24 March 2016 at 10:39, Kate Stone &lt;k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;&gt; wrote:<br>&gt; I definitely concur that tools like Instruments are the best way to understand the impact of decisions on memory across the board.  For fine-grained inquiries about memory use you can also rely on malloc family functions to make inquiries:<br>&gt; <br>&gt; let required_size = malloc_size(unsafeAddressOf(object_reference))<br>&gt; let actual_size = malloc_good_size(required_size)<br>&gt; <br>&gt; Kate Stone k8stone at apple.com &lt;mailto:k8stone at apple.com&gt;<br>&gt;  Xcode Low Level Tools<br>&gt; <br>&gt;&gt; On Mar 23, 2016, at 3:59 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks, I will give that a try<br>&gt;&gt; <br>&gt;&gt;   -- Howard.<br>&gt;&gt; <br>&gt;&gt; On 24 March 2016 at 03:17, Jens Alfke &lt;jens at mooseyard.com &lt;mailto:jens at mooseyard.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 22, 2016, at 11:04 PM, Howard Lovatt via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am writing custom collection classes and trying to assess which one is better, both in terms of performance and memory usage. Won&#39;t be used in &#39;real&#39; code, just to guide development.<br>&gt;&gt; <br>&gt;&gt; You might consider using heap profiling tools too, like (on Mac OS) the Instruments app or the `heap` command-line tool. If you use these while running a benchmark app using your API, it can show you how much total heap space gets used.<br>&gt;&gt; <br>&gt;&gt; Actual heap usage can differ from the raw “sizeof” a data type, since allocators will often round up block sizes or return a somewhat larger block than necessary. Heap fragmentation can also increase memory usage beyond what you’d expect, and different allocation patterns can affect fragmentation.<br>&gt;&gt; <br>&gt;&gt; —Jens<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160323/488683e4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 24, 2016 at 11:00:00am</p></header><div class="content"><p>Thanks, you are correct. Very helpful.<br></p><p>  -- Howard.<br></p><p>On 24 March 2016 at 11:20, Kate Stone &lt;k8stone at apple.com&gt; wrote:<br></p><p>&gt; You’re almost certainly seeing side effects of not keeping the instance of<br>&gt; TestClass alive long enough for the unsafe pointer to still refer to an<br>&gt; allocated malloc block.  A quick REPL session illustrates this fact:<br>&gt;<br>&gt;   1&gt; class TestClass {<br>&gt;   2.     let a = 0<br>&gt;   3.     let b: Int? = nil<br>&gt;   4. }<br>&gt;   5&gt; import Foundation<br>&gt;   6&gt; malloc_size(unsafeAddressOf(TestClass()))<br>&gt; $R0: Int = 0<br>&gt;   7&gt; let x = TestClass()<br>&gt; x: TestClass = {<br>&gt;   a = 0<br>&gt;   b = nil<br>&gt; }<br>&gt;   8&gt; malloc_size(unsafeAddressOf(x))<br>&gt; $R1: Int = 48<br>&gt;<br>&gt; On line 6 the result of the TestClass() expression is being used only to<br>&gt; call unsafeAddressOf, and then it’s being freed before the call to<br>&gt; malloc_size.  On line 8 the variable x is retaining the instance so the<br>&gt; malloc’ed region can be measured.<br>&gt;<br>&gt; Of course all of this relies on the implementation assumption that<br>&gt; allocated objects go on malloc’s heap and is subject to implementation<br>&gt; details about object layout.  So while this may be instructive now it’s<br>&gt; certainly no guarantee of how things will work in the future.<br>&gt;<br>&gt; Kate Stone k8stone at apple.com<br>&gt;  Xcode Low Level Tools<br>&gt;<br>&gt; On Mar 23, 2016, at 5:13 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; @Kate,<br>&gt;<br>&gt; I don&#39;t seem to be able to get `malloc_...` to work. EG:<br>&gt;<br>&gt; class TestClass {<br>&gt;     let a = 0<br>&gt;     let b: Int? = nil<br>&gt; }<br>&gt; @_silgen_name(&quot;swift_class_getInstanceExtents&quot;) func<br>&gt; swift_class_getInstanceExtents(theClass: AnyClass) -&gt; (negative: UInt,<br>&gt; positive: UInt)<br>&gt; print(&quot;swift_class_getInstanceExtents =<br>&gt; \(swift_class_getInstanceExtents(TestClass))&quot;)<br>&gt; let requiredSize = malloc_size(unsafeAddressOf(TestClass()))<br>&gt; print(&quot;malloc_size = \(requiredSize)&quot;)<br>&gt; print(&quot;malloc_good_size = \(malloc_good_size(requiredSize))&quot;)<br>&gt;<br>&gt;<br>&gt; Prints:<br>&gt;<br>&gt; swift_class_getInstanceExtents = (0, 33)<br>&gt; malloc_size = 0<br>&gt; malloc_good_size = 16<br>&gt;<br>&gt;<br>&gt; The `swift_class_getInstanceExtents` seems correct to me: 16 bytes for<br>&gt; class overhead + 16 bytes for `a` and `b` + 1 byte because `b` is an<br>&gt; optional = 33 bytes.<br>&gt;<br>&gt; Not sure what `malloc_...` is giving?<br>&gt;<br>&gt;   -- Howard.<br>&gt;<br>&gt; On 24 March 2016 at 10:39, Kate Stone &lt;k8stone at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt; I definitely concur that tools like Instruments are the best way to<br>&gt;&gt; understand the impact of decisions on memory across the board.  For<br>&gt;&gt; fine-grained inquiries about memory use you can also rely on malloc family<br>&gt;&gt; functions to make inquiries:<br>&gt;&gt;<br>&gt;&gt; let required_size = malloc_size(unsafeAddressOf(*object_reference*))<br>&gt;&gt; let actual_size = malloc_good_size(required_size)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Kate Stone k8stone at apple.com<br>&gt;&gt;  Xcode Low Level Tools<br>&gt;&gt;<br>&gt;&gt; On Mar 23, 2016, at 3:59 PM, Howard Lovatt via swift-users &lt;<br>&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thanks, I will give that a try<br>&gt;&gt;<br>&gt;&gt;   -- Howard.<br>&gt;&gt;<br>&gt;&gt; On 24 March 2016 at 03:17, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Mar 22, 2016, at 11:04 PM, Howard Lovatt via swift-users &lt;<br>&gt;&gt;&gt; swift-users at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I am writing custom collection classes and trying to assess which one is<br>&gt;&gt;&gt; better, both in terms of performance and memory usage. Won&#39;t be used in<br>&gt;&gt;&gt; &#39;real&#39; code, just to guide development.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; You might consider using heap profiling tools too, like (on Mac OS) the<br>&gt;&gt;&gt; Instruments app or the `heap` command-line tool. If you use these while<br>&gt;&gt;&gt; running a benchmark app using your API, it can show you how much total heap<br>&gt;&gt;&gt; space gets used.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Actual heap usage can differ from the raw “sizeof” a data type, since<br>&gt;&gt;&gt; allocators will often round up block sizes or return a somewhat larger<br>&gt;&gt;&gt; block than necessary. Heap fragmentation can also increase memory usage<br>&gt;&gt;&gt; beyond what you’d expect, and different allocation patterns can affect<br>&gt;&gt;&gt; fragmentation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; —Jens<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160324/2fc97e75/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Object size on heap</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 23, 2016 at 02:00:00pm</p></header><div class="content"><p>Many thanks<br></p><p>  -- Howard.<br></p><p>On 23 March 2016 at 02:47, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Mar 21, 2016, at 9:31 PM, Howard Lovatt &lt;howard.lovatt at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; How do you call swift_class_getInstanceExtents, it doesn&#39;t show in Xcode?<br>&gt;<br>&gt;<br>&gt; It&#39;s not provided as API by default. You can do this as an unsupported<br>&gt; hack:<br>&gt;<br>&gt; @_silgen_name(&quot;swift_class_getInstanceExtents&quot;)<br>&gt; func swift_class_getInstanceExtents(theClass: AnyClass)<br>&gt;   -&gt; (negative: UInt, positive: UInt)<br>&gt;<br>&gt; -Joe<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160323/158f249d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
