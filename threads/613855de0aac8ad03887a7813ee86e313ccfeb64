<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 24, 2016 at 08:00:00am</p></header><div class="content"><p>In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br></p><p>My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br></p><p>Example:<br>x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>x = 5  <br></p><p>Example:<br>y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>print(y) <br></p><p>Example Optional Binding:<br>if index = myArray.indexOf(&quot;A&quot;) {<br>	print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>}<br></p><p>etc...<br></p><p>This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br></p><p>Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br></p><p>Kind regards,<br>Darko Damjanovic-Lichtfuss<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7ba3c93f9350613c243eeb87c602935e?s=50"></div><header><strong>Mutability inference</strong> from <string>David Smith</string> &lt;david_smith at apple.com&gt;<p>February 23, 2016 at 11:00:00pm</p></header><div class="content"><p>One tricky thing with languages like this (javascript, for example) is that it becomes easy to accidentally introduce a new variable rather than refer to an existing one.<br></p><p>	David<br></p><p>&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt; <br>&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt; <br>&gt; Example:<br>&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt; x = 5  <br>&gt; <br>&gt; Example:<br>&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt; print(y) <br>&gt; <br>&gt; Example Optional Binding:<br>&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt; 	print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt; }<br>&gt; <br>&gt; etc...<br>&gt; <br>&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt; <br>&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt; <br>&gt; Kind regards,<br>&gt; Darko Damjanovic-Lichtfuss<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2050a4c85c8fc9b9042ba39f0fe796ad?s=50"></div><header><strong>Mutability inference</strong> from <string>Mathieu Godart</string> &lt;m at godart.co&gt;<p>February 24, 2016 at 09:00:00am</p></header><div class="content"><p>Interesting idea. I like to be able to be lazy! 😊 <br></p><p>But I agree with David. So, we could imagine a new keyword, like &quot;varlet&quot; or &quot;autovar&quot;, or whatever to avoid confusion between declaration and assignment... But this would impact drastically the readability. The compiler would know, but not the human reader. And this loss in readability would be very impactful, imho. The mutability character carries a lot of information. <br></p><p>If you want to be lazy about it, what about letting the compiler advice you? You could define every new variable as &quot;var&quot;, without thinking about it. And after you completed the implementation of the related scope, see what the compiler tells you. And just apply its advice.<br></p><p>Wouldn&#39;t that be sufficient?<br></p><p>Mathieu Godart<br></p><p>PS : This is my first post on this mailing list. So, hello the Swift community!<br></p><p><br></p><p>&gt; Le 24 févr. 2016 à 08:10, David Smith via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; One tricky thing with languages like this (javascript, for example) is that it becomes easy to accidentally introduce a new variable rather than refer to an existing one.<br>&gt; <br>&gt;    David<br>&gt; <br>&gt;&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt; <br>&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt; x = 5  <br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt; print(y) <br>&gt;&gt; <br>&gt;&gt; Example Optional Binding:<br>&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;    print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; etc...<br>&gt;&gt; <br>&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt; <br>&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt; <br>&gt;&gt; Kind regards,<br>&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 25, 2016 at 03:00:00am</p></header><div class="content"><p>Hello Mathieu,<br></p><p>&gt; If you want to be lazy about it, what about letting the compiler advice you? You could define every new variable as &quot;var&quot;, without thinking about it. And after you completed the implementation of the related scope, see what the compiler tells you. And just apply its advice.<br>&gt; <br>&gt; Wouldn&#39;t that be sufficient?<br></p><p><br>You are right, I work in a similar way currently. I have my personal rule to commit into Git 100% error _and_ warning free. So I define every new variable as „let“ and if I get a compiler error I change it to &quot;var“. So this is going on all day long - I define „let“ and often the compiler say’s „no - var!“ and I obey. (what else?) :) But after doing this game a thousand times I got tired. Asking myself - well, if the compiler knows better anyway, why do _I_ have to tell him all the time? I fully understand the advantages of immutability (that’s why at first „let“ and not „var“) but meanwhile it just feels like boilerplate repetitive code and the machine dictates it to me anyway.<br></p><p>- Darko<br></p><p><br></p><p><br>&gt; Am 24.02.2016 um 09:37 schrieb Mathieu Godart &lt;m at godart.co&gt;:<br>&gt; <br>&gt; Interesting idea. I like to be able to be lazy! 😊 <br>&gt; <br>&gt; But I agree with David. So, we could imagine a new keyword, like &quot;varlet&quot; or &quot;autovar&quot;, or whatever to avoid confusion between declaration and assignment... But this would impact drastically the readability. The compiler would know, but not the human reader. And this loss in readability would be very impactful, imho. The mutability character carries a lot of information. <br>&gt; <br>&gt; If you want to be lazy about it, what about letting the compiler advice you? You could define every new variable as &quot;var&quot;, without thinking about it. And after you completed the implementation of the related scope, see what the compiler tells you. And just apply its advice.<br>&gt; <br>&gt; Wouldn&#39;t that be sufficient?<br>&gt; <br>&gt; Mathieu Godart<br>&gt; <br>&gt; PS : This is my first post on this mailing list. So, hello the Swift community!<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Le 24 févr. 2016 à 08:10, David Smith via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; One tricky thing with languages like this (javascript, for example) is that it becomes easy to accidentally introduce a new variable rather than refer to an existing one.<br>&gt;&gt; <br>&gt;&gt;   David<br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt;&gt; x = 5  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt;&gt; print(y) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example Optional Binding:<br>&gt;&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;&gt;   print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; etc...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Mutability inference</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 24, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; You are right, I work in a similar way currently. I have my personal rule to commit into Git 100% error _and_ warning free. So I define every new variable as „let“ and if I get a compiler error I change it to &quot;var“.<br></p><p>I think the intention is that, before you change it to `var`, you should examine your code and see if there&#39;s a way you could write it that would allow it to remain a `let`. Could you assign it to a new constant instead of changing the old variable? Could you use a nonmutating operation instead of a mutating one? It&#39;s not that you *have* to take the nonmutating option—`var`s exist in Swift because they&#39;re perfectly appropriate in many cases—but if you try to turn `var`-based code into `let`-based code, the `let`-based version is often better.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 25, 2016 at 10:00:00am</p></header><div class="content"><p>Hello Gordon,<br></p><p>so what you basically are saying is that the developer still can be smarter then the compiler in this regards. In this case - yes, it would be better to leave it as it is currently. I was not aware of this viewpoint. It seemed to me that the current warnings are already the best possible solution anyway. <br></p><p>In this case my proposal is just to early. Maybe the compiler will evolve in the future in such a way that also immutability/mutability can be better done by the compiler then by the developer. <br></p><p>Nevertheless thanks to all of you for the great input. <br></p><p>Br,<br>Darko<br></p><p><br></p><p>&gt; Am 25.02.2016 um 03:37 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt; <br>&gt;&gt; You are right, I work in a similar way currently. I have my personal rule to commit into Git 100% error _and_ warning free. So I define every new variable as „let“ and if I get a compiler error I change it to &quot;var“.<br>&gt; <br>&gt; I think the intention is that, before you change it to `var`, you should examine your code and see if there&#39;s a way you could write it that would allow it to remain a `let`. Could you assign it to a new constant instead of changing the old variable? Could you use a nonmutating operation instead of a mutating one? It&#39;s not that you *have* to take the nonmutating option—`var`s exist in Swift because they&#39;re perfectly appropriate in many cases—but if you try to turn `var`-based code into `let`-based code, the `let`-based version is often better.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7b4f0271043628eecd950f1e3cdd1a84?s=50"></div><header><strong>Mutability inference</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at googlemail.com&gt;<p>February 25, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 25 Feb 2016, at 10:41, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In this case my proposal is just to early. Maybe the compiler will evolve in the future in such a way that also immutability/mutability can be better done by the compiler then by the developer. <br></p><p>I don’t think you should be looking forward to it :) If the compilers ever evolve that far, most programmers might just become unemployed. <br></p><p>t.<br></p><p>&gt; <br>&gt; Nevertheless thanks to all of you for the great input. <br>&gt; <br>&gt; Br,<br>&gt; Darko<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 25.02.2016 um 03:37 schrieb Brent Royal-Gordon &lt;brent at architechies.com&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; You are right, I work in a similar way currently. I have my personal rule to commit into Git 100% error _and_ warning free. So I define every new variable as „let“ and if I get a compiler error I change it to &quot;var“.<br>&gt;&gt; <br>&gt;&gt; I think the intention is that, before you change it to `var`, you should examine your code and see if there&#39;s a way you could write it that would allow it to remain a `let`. Could you assign it to a new constant instead of changing the old variable? Could you use a nonmutating operation instead of a mutating one? It&#39;s not that you *have* to take the nonmutating option—`var`s exist in Swift because they&#39;re perfectly appropriate in many cases—but if you try to turn `var`-based code into `let`-based code, the `let`-based version is often better.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d68c97e8e2f1653b54c24493caf236ae?s=50"></div><header><strong>Mutability inference</strong> from <string>Stephen Celis</string> &lt;stephen.celis at gmail.com&gt;<p>February 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 24, 2016, at 2:10 AM, David Smith via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One tricky thing with languages like this (javascript, for example) is that it becomes easy to accidentally introduce a new variable rather than refer to an existing one.<br></p><p><br>There are ways around this.<br></p><p>I like mutability to be explicit, but do like the idea of making `let` optional in cases where it can be assumed a new variable is being introduced:<br></p><p>  let a: String = &quot;string&quot;<br>  b: String = &quot;string&quot; // short-hand avoids let<br>  b := &quot;string&quot; // shorter-hand<br></p><p>--<br>Stephen<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/aeab22e60ba7b7e2bd445775850448d1?s=50"></div><header><strong>Mutability inference</strong> from <string>Radosław Pietruszewski</string> &lt;radexpl at gmail.com&gt;<p>February 24, 2016 at 09:00:00am</p></header><div class="content"><p>This is by design:<br></p><p>1. You do have to explicitly declare a variable with let or var to disambiguate, in the eyes of the reader, declaration and assignment. This way, when you see `let x = y`, you know for sure, without double checking, that “x” has no previous value. This is also makes the code more resilient, because if you accidentally reuse a name or whatever, the compiler will warn you.<br></p><p>2. You have to explicitly opt into mutability not to aid the compiler, but to let the compiler aid you!<br></p><p>This teaches you to make immutable things by default, because immutability gives you a guarantee that a thing won’t change. You don’t have to think about it. You’re protected from your future self trying to change a value of a constant. And when you declare a `var`, but don’t need mutability capabilities, the compiler pushes you to change it to `let`, again, to protect yourself from future yourself’s mistakes.<br></p><p>Fun fact: Rust goes even further in pushing you to be immutable by default. Variables are declared by “let x = y”, and to opt into mutability you have to write “mut let x = y”.<br></p><p>— Radek<br></p><p>&gt; On 24 Feb 2016, at 08:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt; <br>&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt; <br>&gt; Example:<br>&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt; x = 5  <br>&gt; <br>&gt; Example:<br>&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt; print(y) <br>&gt; <br>&gt; Example Optional Binding:<br>&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt; 	print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt; }<br>&gt; <br>&gt; etc...<br>&gt; <br>&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt; <br>&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt; <br>&gt; Kind regards,<br>&gt; Darko Damjanovic-Lichtfuss<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Mutability inference</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 24, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br></p><p>The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 25, 2016 at 03:00:00am</p></header><div class="content"><p>Hello Chris,<br></p><p>&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  <br></p><p>You are right, it would. On the other side - the same is happening already with type inference, right? And to an even greater extent - because: isn&#39;t the very type even more important on first sight then the mutability? But it turns out not to be a problem because of the compilers type safety. It doesn&#39;t matter what you do with it, you can rest assured that the compiler will take care not to misuse the type in any way. And this is not the only &quot;magic&quot; which is taken care of by the compiler, think about copy-on-write for value types or ARC. All of this is „hidden“ and not clear on first sight.<br></p><p>&gt; The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br></p><p>Yes, but now it&#39;s not _that_ important anymore, because the compiler can take care of it. Same as with type inference, COW and ARC. The compiler knows better - meanwhile. And same as with type inference you still could write &quot;let&quot; and &quot;var&quot; if it is important in the current context. And if you explicitly want the reader of the code to know about it on first sight.<br></p><p>But I have to admit that making both „let“ and „var&quot; optional without any substitute could lead to problems. Like David Smith wrote:<br></p><p>&quot;it becomes easy to accidentally introduce a new variable rather than refer to an existing one&quot;<br></p><p>Stephen Celis gives a very good solution for this:<br></p><p>let a: String = &quot;string&quot;<br>b: String = &quot;string&quot; // short-hand avoids let<br>b := &quot;string&quot; // shorter-hand<br></p><p>I like this. The obvious other solution would be a new keyword (don&#39;t like this).<br></p><p>It would not be of a big problem for me if it stay&#39;s like it is currently, not at all. It just feels like it&#39;s time to move on because the compiler get&#39;s smarter and smarter. It was a similar situation with ARC a few years ago if I remember it correctly. At first it was just an additional help for the developer (like the mutability warnings currently) but later it turned out that the compiler already surpasses the developer.<br></p><p>I am new to this list, so sorry about &quot;jumping around&quot; with the proposal. But currently I have no one else to discuss this because I am the only Swift developer in my company. :) Please let me know if this kind of discussion is not appropriate on this list. Thanks.<br></p><p>- Darko<br></p><p><br></p><p><br>&gt; Am 24.02.2016 um 19:40 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt; <br>&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br>&gt; <br>&gt; -Chris<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3d118cdf2fe31053bc7032466c4da282?s=50"></div><header><strong>Mutability inference</strong> from <string>Craig Cruden</string> &lt;ccruden at novafore.com&gt;<p>February 25, 2016 at 09:00:00am</p></header><div class="content"><p>There is quite a bit of difference between type inference and mutable / immutable inference.  <br></p><p>Types are important and type safety is important - as it allows the compiler to check during compile time.  Type inference does not take away from this - the compiler still checks that a variable / constant is the same type wherever it is used.  <br></p><p>It does not matter whether variable “a” is a string.  It matters that if “a” is a string, it is always a string.  <br></p><p>I do think that “let” is unfortunately scattered throughout the code which makes things like pattern matching less focused/clear - and would appreciate if let is inferred in those circumstances.<br></p><p>“var” should never be inferred.  <br></p><p>As far as “let x = …&quot; being inferred, I don’t see much benefit — and quite a bit of risk of variables bleeding unintentionally between different scopes.  (let is also pretty standard in math).<br></p><p><br>&gt; On 2016-02-25, at 9:26:18, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Chris,<br>&gt; <br>&gt;&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  <br>&gt; <br>&gt; You are right, it would. On the other side - the same is happening already with type inference, right? And to an even greater extent - because: isn&#39;t the very type even more important on first sight then the mutability? But it turns out not to be a problem because of the compilers type safety. It doesn&#39;t matter what you do with it, you can rest assured that the compiler will take care not to misuse the type in any way. And this is not the only &quot;magic&quot; which is taken care of by the compiler, think about copy-on-write for value types or ARC. All of this is „hidden“ and not clear on first sight.<br>&gt; <br>&gt;&gt; The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br>&gt; <br>&gt; Yes, but now it&#39;s not _that_ important anymore, because the compiler can take care of it. Same as with type inference, COW and ARC. The compiler knows better - meanwhile. And same as with type inference you still could write &quot;let&quot; and &quot;var&quot; if it is important in the current context. And if you explicitly want the reader of the code to know about it on first sight.<br>&gt; <br>&gt; But I have to admit that making both „let“ and „var&quot; optional without any substitute could lead to problems. Like David Smith wrote:<br>&gt; <br>&gt; &quot;it becomes easy to accidentally introduce a new variable rather than refer to an existing one&quot;<br>&gt; <br>&gt; Stephen Celis gives a very good solution for this:<br>&gt; <br>&gt; let a: String = &quot;string&quot;<br>&gt; b: String = &quot;string&quot; // short-hand avoids let<br>&gt; b := &quot;string&quot; // shorter-hand<br>&gt; <br>&gt; I like this. The obvious other solution would be a new keyword (don&#39;t like this).<br>&gt; <br>&gt; It would not be of a big problem for me if it stay&#39;s like it is currently, not at all. It just feels like it&#39;s time to move on because the compiler get&#39;s smarter and smarter. It was a similar situation with ARC a few years ago if I remember it correctly. At first it was just an additional help for the developer (like the mutability warnings currently) but later it turned out that the compiler already surpasses the developer.<br>&gt; <br>&gt; I am new to this list, so sorry about &quot;jumping around&quot; with the proposal. But currently I have no one else to discuss this because I am the only Swift developer in my company. :) Please let me know if this kind of discussion is not appropriate on this list. Thanks.<br>&gt; <br>&gt; - Darko<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 24.02.2016 um 19:40 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt; <br>&gt;&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/74b2be3f33e2efebef65c9a48c32872a?s=50"></div><header><strong>Mutability inference</strong> from <string>Angelo Villegas</string> &lt;gelo.web at gmail.com&gt;<p>February 25, 2016 at 03:00:00am</p></header><div class="content"><p>Writability over maintainability? I&#39;m going to vote against this, so -1.<br>On Thu, 25 Feb 2016 at 10:43 AM Craig Cruden via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; There is quite a bit of difference between type inference and mutable /<br>&gt; immutable inference.<br>&gt;<br>&gt; Types are important and type safety is important - as it allows the<br>&gt; compiler to check during compile time.  Type inference does not take away<br>&gt; from this - the compiler still checks that a variable / constant is the<br>&gt; same type wherever it is used.<br>&gt;<br>&gt; It does not matter whether variable “a” is a string.  It matters that if<br>&gt; “a” is a string, it is always a string.<br>&gt;<br>&gt; I do think that “let” is unfortunately scattered throughout the code which<br>&gt; makes things like pattern matching less focused/clear - and would<br>&gt; appreciate if let is inferred in those circumstances.<br>&gt;<br>&gt; “var” should never be inferred.<br>&gt;<br>&gt; As far as “let x = …&quot; being inferred, I don’t see much benefit — and quite<br>&gt; a bit of risk of variables bleeding unintentionally between different<br>&gt; scopes.  (let is also pretty standard in math).<br>&gt;<br>&gt;<br>&gt; &gt; On 2016-02-25, at 9:26:18, Darko Damjanovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Chris,<br>&gt; &gt;<br>&gt; &gt;&gt; The problem with this approach is that you’re favoring writability of<br>&gt; the code at the expense of readability/maintainability.<br>&gt; &gt;<br>&gt; &gt; You are right, it would. On the other side - the same is happening<br>&gt; already with type inference, right? And to an even greater extent -<br>&gt; because: isn&#39;t the very type even more important on first sight then the<br>&gt; mutability? But it turns out not to be a problem because of the compilers<br>&gt; type safety. It doesn&#39;t matter what you do with it, you can rest assured<br>&gt; that the compiler will take care not to misuse the type in any way. And<br>&gt; this is not the only &quot;magic&quot; which is taken care of by the compiler, think<br>&gt; about copy-on-write for value types or ARC. All of this is „hidden“ and not<br>&gt; clear on first sight.<br>&gt; &gt;<br>&gt; &gt;&gt; The major win of having let and var in the code is that it expresses<br>&gt; the intention of what is happening: when you see a “let x = …” you know<br>&gt; that x will never be changed.<br>&gt; &gt;<br>&gt; &gt; Yes, but now it&#39;s not _that_ important anymore, because the compiler can<br>&gt; take care of it. Same as with type inference, COW and ARC. The compiler<br>&gt; knows better - meanwhile. And same as with type inference you still could<br>&gt; write &quot;let&quot; and &quot;var&quot; if it is important in the current context. And if you<br>&gt; explicitly want the reader of the code to know about it on first sight.<br>&gt; &gt;<br>&gt; &gt; But I have to admit that making both „let“ and „var&quot; optional without<br>&gt; any substitute could lead to problems. Like David Smith wrote:<br>&gt; &gt;<br>&gt; &gt; &quot;it becomes easy to accidentally introduce a new variable rather than<br>&gt; refer to an existing one&quot;<br>&gt; &gt;<br>&gt; &gt; Stephen Celis gives a very good solution for this:<br>&gt; &gt;<br>&gt; &gt; let a: String = &quot;string&quot;<br>&gt; &gt; b: String = &quot;string&quot; // short-hand avoids let<br>&gt; &gt; b := &quot;string&quot; // shorter-hand<br>&gt; &gt;<br>&gt; &gt; I like this. The obvious other solution would be a new keyword (don&#39;t<br>&gt; like this).<br>&gt; &gt;<br>&gt; &gt; It would not be of a big problem for me if it stay&#39;s like it is<br>&gt; currently, not at all. It just feels like it&#39;s time to move on because the<br>&gt; compiler get&#39;s smarter and smarter. It was a similar situation with ARC a<br>&gt; few years ago if I remember it correctly. At first it was just an<br>&gt; additional help for the developer (like the mutability warnings currently)<br>&gt; but later it turned out that the compiler already surpasses the developer.<br>&gt; &gt;<br>&gt; &gt; I am new to this list, so sorry about &quot;jumping around&quot; with the<br>&gt; proposal. But currently I have no one else to discuss this because I am the<br>&gt; only Swift developer in my company. :) Please let me know if this kind of<br>&gt; discussion is not appropriate on this list. Thanks.<br>&gt; &gt;<br>&gt; &gt; - Darko<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 24.02.2016 um 19:40 schrieb Chris Lattner &lt;clattner at apple.com&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable<br>&gt; is never written to and therefore should be a &quot;let&quot; constant. So now the<br>&gt; compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing<br>&gt; code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I<br>&gt; have to declare it all the time by myself if the compiler anyway knows best?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The problem with this approach is that you’re favoring writability of<br>&gt; the code at the expense of readability/maintainability.  The major win of<br>&gt; having let and var in the code is that it expresses the intention of what<br>&gt; is happening: when you see a “let x = …” you know that x will never be<br>&gt; changed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/b10c3b75/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>Mutability inference</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 25, 2016 at 06:00:00am</p></header><div class="content"><p>Explicit variable-level mutability declaration is one of the strong points of Swift. Nothing is gained by saving on ‘var’ or ‘let’. I strongly doubt that removing mutability declarations would improve the speed of writing (its just 3 extra characters). At the same time, these declarations force you to think about the structure of your algorithms and your code. <br></p><p>— Taras<br></p><p>&gt; On 25 Feb 2016, at 04:24, Angelo Villegas via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Writability over maintainability? I&#39;m going to vote against this, so -1. <br>&gt; On Thu, 25 Feb 2016 at 10:43 AM Craig Cruden via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; There is quite a bit of difference between type inference and mutable / immutable inference.<br>&gt; <br>&gt; Types are important and type safety is important - as it allows the compiler to check during compile time.  Type inference does not take away from this - the compiler still checks that a variable / constant is the same type wherever it is used.<br>&gt; <br>&gt; It does not matter whether variable “a” is a string.  It matters that if “a” is a string, it is always a string.<br>&gt; <br>&gt; I do think that “let” is unfortunately scattered throughout the code which makes things like pattern matching less focused/clear - and would appreciate if let is inferred in those circumstances.<br>&gt; <br>&gt; “var” should never be inferred.<br>&gt; <br>&gt; As far as “let x = …&quot; being inferred, I don’t see much benefit — and quite a bit of risk of variables bleeding unintentionally between different scopes.  (let is also pretty standard in math).<br>&gt; <br>&gt; <br>&gt; &gt; On 2016-02-25, at 9:26:18, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Hello Chris,<br>&gt; &gt;<br>&gt; &gt;&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.<br>&gt; &gt;<br>&gt; &gt; You are right, it would. On the other side - the same is happening already with type inference, right? And to an even greater extent - because: isn&#39;t the very type even more important on first sight then the mutability? But it turns out not to be a problem because of the compilers type safety. It doesn&#39;t matter what you do with it, you can rest assured that the compiler will take care not to misuse the type in any way. And this is not the only &quot;magic&quot; which is taken care of by the compiler, think about copy-on-write for value types or ARC. All of this is „hidden“ and not clear on first sight.<br>&gt; &gt;<br>&gt; &gt;&gt; The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br>&gt; &gt;<br>&gt; &gt; Yes, but now it&#39;s not _that_ important anymore, because the compiler can take care of it. Same as with type inference, COW and ARC. The compiler knows better - meanwhile. And same as with type inference you still could write &quot;let&quot; and &quot;var&quot; if it is important in the current context. And if you explicitly want the reader of the code to know about it on first sight.<br>&gt; &gt;<br>&gt; &gt; But I have to admit that making both „let“ and „var&quot; optional without any substitute could lead to problems. Like David Smith wrote:<br>&gt; &gt;<br>&gt; &gt; &quot;it becomes easy to accidentally introduce a new variable rather than refer to an existing one&quot;<br>&gt; &gt;<br>&gt; &gt; Stephen Celis gives a very good solution for this:<br>&gt; &gt;<br>&gt; &gt; let a: String = &quot;string&quot;<br>&gt; &gt; b: String = &quot;string&quot; // short-hand avoids let<br>&gt; &gt; b := &quot;string&quot; // shorter-hand<br>&gt; &gt;<br>&gt; &gt; I like this. The obvious other solution would be a new keyword (don&#39;t like this).<br>&gt; &gt;<br>&gt; &gt; It would not be of a big problem for me if it stay&#39;s like it is currently, not at all. It just feels like it&#39;s time to move on because the compiler get&#39;s smarter and smarter. It was a similar situation with ARC a few years ago if I remember it correctly. At first it was just an additional help for the developer (like the mutability warnings currently) but later it turned out that the compiler already surpasses the developer.<br>&gt; &gt;<br>&gt; &gt; I am new to this list, so sorry about &quot;jumping around&quot; with the proposal. But currently I have no one else to discuss this because I am the only Swift developer in my company. :) Please let me know if this kind of discussion is not appropriate on this list. Thanks.<br>&gt; &gt;<br>&gt; &gt; - Darko<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;&gt; Am 24.02.2016 um 19:40 schrieb Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt;:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On Feb 23, 2016, at 11:06 PM, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  The major win of having let and var in the code is that it expresses the intention of what is happening: when you see a “let x = …” you know that x will never be changed.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Chris<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/1bbff91a/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Mutability inference</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>February 24, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Feb 24, 2016, at 18:26 , Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; The problem with this approach is that you’re favoring writability of the code at the expense of readability/maintainability.  <br>&gt; <br>&gt; You are right, it would. On the other side - the same is happening already with type inference, right? And to an even greater extent - because: isn&#39;t the very type even more important on first sight then the mutability? But it turns out not to be a problem because of the compilers type safety. It doesn&#39;t matter what you do with it, you can rest assured that the compiler will take care not to misuse the type in any way. And this is not the only &quot;magic&quot; which is taken care of by the compiler, think about copy-on-write for value types or ARC. All of this is „hidden“ and not clear on first sight.<br></p><p>I&#39;m not particularly happy with this view of type inference. I think the reason it&#39;s okay to infer the type of a binding is because it&#39;s obvious from context (i.e. the expression). If it&#39;s not obvious, you should write it even if the compiler can figure it out for you.<br></p><p>Ideally, code should be written for humans to read, not for compilers to check. I&#39;d like to be able to read a commit and know what it&#39;s doing without having to build it.<br></p><p>I&#39;m against &quot;implicit var&quot; on these grounds because it turns out it&#39;s much simpler to &quot;look at code and know what it does&quot; if a local variable has the same value the whole time it&#39;s used, at least for me. &quot;Implicit var&quot; for locals is the same as not having &#39;let&#39;, because as we&#39;ve seen in C most people won&#39;t bother to use &#39;let&#39; and its restrictions when it&#39;s not the default.<br></p><p>(I&#39;m against &quot;implicit let&quot; for the JavaScript/Python reason of it being too easy to accidentally create a new binding when you meant to modify something in scope or vice versa.)<br></p><p>Jordan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/c3cd9d61/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9ea02b9a2f6e3d188e9e974e30d565e0?s=50"></div><header><strong>Mutability inference</strong> from <string>Riley Avron</string> &lt;ravron at dropbox.com&gt;<p>February 24, 2016 at 01:00:00pm</p></header><div class="content"><p>–1. This would make reading and maintaining code appreciably harder for a<br>trivial reduction in character count when writing code.<br></p><p>Riley<br></p><p>On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the current Swift version the compiler is warning me if a variable is<br>&gt; never written to and therefore should be a &quot;let&quot; constant. So now the<br>&gt; compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing<br>&gt; code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I<br>&gt; have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;<br>&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;<br>&gt; Example:<br>&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to,<br>&gt; no need to declare it manually<br>&gt; x = 5<br>&gt;<br>&gt; Example:<br>&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt; print(y)<br>&gt;<br>&gt; Example Optional Binding:<br>&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt; }<br>&gt;<br>&gt; etc...<br>&gt;<br>&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability<br>&gt; declarations - just to make them optional. If I still want to write it to<br>&gt; make it clear just by reading thru the code then this is ok. But I can omit<br>&gt; &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure<br>&gt; that the compiler is already doing the best?<br>&gt;<br>&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot;<br>&gt; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be<br>&gt; the default and if I want mutability I have explicitly declare it as &quot;var&quot;.<br>&gt; This is already the rule for function parameters.<br>&gt;<br>&gt; Kind regards,<br>&gt; Darko Damjanovic-Lichtfuss<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/8f7a43a8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Mutability inference</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 24, 2016 at 05:00:00pm</p></header><div class="content"><p>-1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br></p><p>~Robert Widmann<br></p><p>2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br></p><p>&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt; <br>&gt; Riley<br>&gt; <br>&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt; <br>&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt; x = 5<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt; print(y)<br>&gt;&gt; <br>&gt;&gt; Example Optional Binding:<br>&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; etc...<br>&gt;&gt; <br>&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt; <br>&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt; <br>&gt;&gt; Kind regards,<br>&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/110cee55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Mutability inference</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>February 24, 2016 at 11:00:00pm</p></header><div class="content"><p>I’m a -1 as well; while I do find the warnings annoying sometimes when a declare a var that I haven’t modified yet, I’d rather have them than not. If there were an option to not decide then developers could end up using it by default just because it’s easier, which could allow a slew of bugs to creep in that Swift currently protects against.<br></p><p>&gt; On 24 Feb 2016, at 22:52, Developer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt;&gt; <br>&gt;&gt; Riley<br>&gt;&gt; <br>&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt; <br>&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt; x = 5<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt; print(y)<br>&gt;&gt; <br>&gt;&gt; Example Optional Binding:<br>&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; etc...<br>&gt;&gt; <br>&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt; <br>&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt; <br>&gt;&gt; Kind regards,<br>&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/040b2cef/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 25, 2016 at 03:00:00am</p></header><div class="content"><p>Could you give some examples about such bugs? Thanks.<br></p><p><br>&gt; Am 25.02.2016 um 00:42 schrieb Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I’m a -1 as well; while I do find the warnings annoying sometimes when a declare a var that I haven’t modified yet, I’d rather have them than not. If there were an option to not decide then developers could end up using it by default just because it’s easier, which could allow a slew of bugs to creep in that Swift currently protects against.<br>&gt; <br>&gt;&gt; On 24 Feb 2016, at 22:52, Developer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Riley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt;&gt; x = 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt;&gt; print(y)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example Optional Binding:<br>&gt;&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; etc...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/c643e3fb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 25, 2016 at 03:00:00am</p></header><div class="content"><p>Hello Robert,<br></p><p>I am doing most of the time application development, so I do not need to take care _so_ much about it. But I assume in case of writing lib’s for external usage this could be important, yes. But If you want to explicitly declare immutability just write „let“. Nothing hinders you, right?<br></p><p>- Darko<br></p><p><br>&gt; Am 24.02.2016 um 23:52 schrieb Developer &lt;devteam.codafi at gmail.com&gt;:<br>&gt; <br>&gt; -1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; のメッセージ:<br>&gt; <br>&gt;&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt;&gt; <br>&gt;&gt; Riley<br>&gt;&gt; <br>&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt; <br>&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt; x = 5<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt; print(y)<br>&gt;&gt; <br>&gt;&gt; Example Optional Binding:<br>&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; etc...<br>&gt;&gt; <br>&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt; <br>&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt; <br>&gt;&gt; Kind regards,<br>&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/104ff927/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Mutability inference</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 24, 2016 at 09:00:00pm</p></header><div class="content"><p>But that&#39;s the thing: I don&#39;t wish to encourage mutability through the omission of a keyword.  (I don&#39;t wish to encourage mutability in any case, but that&#39;s beside the point!). Your point about types being implicit is entirely different.  If type inference does its job, there is no way to apply a term of a certain type as an argument to a function expecting a different type.  The same is not true of this scheme of inference.  Because I cannot ask swift to guarantee that terms are mutable or immutable, or specify that a function should be pure, I have no immediate guarantees about the mutability of my variables at first glance.  That&#39;s a level of uncertainty about my code I wouldn&#39;t wish to have for any amount of keystroke savings.  <br></p><p>~Robert Widmann<br></p><p>2016/02/24 21:34、Darko Damjanovic &lt;darkodamjanovic at me.com&gt; のメッセージ:<br></p><p>&gt; Hello Robert,<br>&gt; <br>&gt; I am doing most of the time application development, so I do not need to take care _so_ much about it. But I assume in case of writing lib’s for external usage this could be important, yes. But If you want to explicitly declare immutability just write „let“. Nothing hinders you, right?<br>&gt; <br>&gt; - Darko<br>&gt; <br>&gt; <br>&gt;&gt; Am 24.02.2016 um 23:52 schrieb Developer &lt;devteam.codafi at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; -1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Riley<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt;&gt;&gt; x = 5<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt;&gt;&gt; print(y)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Example Optional Binding:<br>&gt;&gt;&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; etc...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/18e55e20/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b281e721f8cbea65ab93ef72bd034a70?s=50"></div><header><strong>Mutability inference</strong> from <string>Darko Damjanovic</string> &lt;darkodamjanovic at me.com&gt;<p>February 25, 2016 at 04:00:00am</p></header><div class="content"><p>Hello Robert,<br></p><p>that&#39;s great, getting so much highly accurate input about this theme makes me understand better the advantages of the current solution. I appreciate that. Thanks.<br></p><p>- Darko<br></p><p><br></p><p>&gt; Am 25.02.2016 um 03:59 schrieb Developer &lt;devteam.codafi at gmail.com&gt;:<br>&gt; <br>&gt; But that&#39;s the thing: I don&#39;t wish to encourage mutability through the omission of a keyword.  (I don&#39;t wish to encourage mutability in any case, but that&#39;s beside the point!). Your point about types being implicit is entirely different.  If type inference does its job, there is no way to apply a term of a certain type as an argument to a function expecting a different type.  The same is not true of this scheme of inference.  Because I cannot ask swift to guarantee that terms are mutable or immutable, or specify that a function should be pure, I have no immediate guarantees about the mutability of my variables at first glance.  That&#39;s a level of uncertainty about my code I wouldn&#39;t wish to have for any amount of keystroke savings.  <br>&gt; <br>&gt; ~Robert Widmann<br>&gt; <br>&gt; 2016/02/24 21:34、Darko Damjanovic &lt;darkodamjanovic at me.com&gt; のメッセージ:<br>&gt; <br>&gt;&gt; Hello Robert,<br>&gt;&gt; <br>&gt;&gt; I am doing most of the time application development, so I do not need to take care _so_ much about it. But I assume in case of writing lib’s for external usage this could be important, yes. But If you want to explicitly declare immutability just write „let“. Nothing hinders you, right?<br>&gt;&gt; <br>&gt;&gt; - Darko<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 24.02.2016 um 23:52 schrieb Developer &lt;devteam.codafi at gmail.com&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Riley<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt;&gt;&gt;&gt; x = 5<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt;&gt;&gt;&gt; print(y)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Example Optional Binding:<br>&gt;&gt;&gt;&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;&gt;&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; etc...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160225/1b1e8e10/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Mutability inference</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>February 24, 2016 at 10:00:00pm</p></header><div class="content"><p>It is an interesting idea all the same, and it would be cool to see it applied in a language like ML that encourages large amounts of let-bound constants and statements. <br></p><p>~Robert Widmann<br></p><p>2016/02/24 22:21、Darko Damjanovic &lt;darkodamjanovic at me.com&gt; のメッセージ:<br></p><p>&gt; Hello Robert,<br>&gt; <br>&gt; that&#39;s great, getting so much highly accurate input about this theme makes me understand better the advantages of the current solution. I appreciate that. Thanks.<br>&gt; <br>&gt; - Darko<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Am 25.02.2016 um 03:59 schrieb Developer &lt;devteam.codafi at gmail.com&gt;:<br>&gt;&gt; <br>&gt;&gt; But that&#39;s the thing: I don&#39;t wish to encourage mutability through the omission of a keyword.  (I don&#39;t wish to encourage mutability in any case, but that&#39;s beside the point!). Your point about types being implicit is entirely different.  If type inference does its job, there is no way to apply a term of a certain type as an argument to a function expecting a different type.  The same is not true of this scheme of inference.  Because I cannot ask swift to guarantee that terms are mutable or immutable, or specify that a function should be pure, I have no immediate guarantees about the mutability of my variables at first glance.  That&#39;s a level of uncertainty about my code I wouldn&#39;t wish to have for any amount of keystroke savings.  <br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; 2016/02/24 21:34、Darko Damjanovic &lt;darkodamjanovic at me.com&gt; のメッセージ:<br>&gt;&gt; <br>&gt;&gt;&gt; Hello Robert,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am doing most of the time application development, so I do not need to take care _so_ much about it. But I assume in case of writing lib’s for external usage this could be important, yes. But If you want to explicitly declare immutability just write „let“. Nothing hinders you, right?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Darko<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 24.02.2016 um 23:52 schrieb Developer &lt;devteam.codafi at gmail.com&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1.  In addition, it would imply that all variables are mutable &quot;by default&quot; (a la Python), because all it would take to change an implicit let to an implicit var would be an accidental extra assignment in another branch somewhere.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ~Robert Widmann<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2016/02/24 16:44、Riley Avron via swift-evolution &lt;swift-evolution at swift.org&gt; のメッセージ:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; –1. This would make reading and maintaining code appreciably harder for a trivial reduction in character count when writing code. <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Riley<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 23 February 2016 at 23:06, Darko Damjanovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; In the current Swift version the compiler is warning me if a variable is never written to and therefore should be a &quot;let&quot; constant. So now the compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to, no need to declare it manually<br>&gt;&gt;&gt;&gt;&gt;&gt; x = 5<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example:<br>&gt;&gt;&gt;&gt;&gt;&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt;&gt;&gt;&gt;&gt;&gt; print(y)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Example Optional Binding:<br>&gt;&gt;&gt;&gt;&gt;&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; etc...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability declarations - just to make them optional. If I still want to write it to make it clear just by reading thru the code then this is ok. But I can omit &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure that the compiler is already doing the best?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be the default and if I want mutability I have explicitly declare it as &quot;var&quot;. This is already the rule for function parameters.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Kind regards,<br>&gt;&gt;&gt;&gt;&gt;&gt; Darko Damjanovic-Lichtfuss<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/6d4d67ef/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06e1007412a9c7c2dc41297c9cf99a5d?s=50"></div><header><strong>Mutability inference</strong> from <string>Shawn Erickson</string> &lt;shawnce at gmail.com&gt;<p>February 24, 2016 at 09:00:00pm</p></header><div class="content"><p>I like compact code but not at the cost of code readability and clarity. I<br>think this degrades the later more then helps the former.<br></p><p>-Shawn<br></p><p>On Tue, Feb 23, 2016 at 11:13 PM Darko Damjanovic via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the current Swift version the compiler is warning me if a variable is<br>&gt; never written to and therefore should be a &quot;let&quot; constant. So now the<br>&gt; compiler knows best if &quot;let&quot; or &quot;var&quot; should be applied. During writing<br>&gt; code I experience repetitive hints about using &quot;let&quot; or &quot;var&quot; so why do I<br>&gt; have to declare it all the time by myself if the compiler anyway knows best?<br>&gt;<br>&gt; My proposal would be to make the declaration of &quot;let&quot; and &quot;var&quot; optional.<br>&gt;<br>&gt; Example:<br>&gt; x = 0 // &lt;- implicitly declared as &quot;var x&quot; because later was written to,<br>&gt; no need to declare it manually<br>&gt; x = 5<br>&gt;<br>&gt; Example:<br>&gt; y = 0 // &lt;- implicitly declared as &quot;let y&quot; because later was not written to<br>&gt; print(y)<br>&gt;<br>&gt; Example Optional Binding:<br>&gt; if index = myArray.indexOf(&quot;A&quot;) {<br>&gt;         print(index) // here it&#39;s clear that index can be &quot;let index&quot;<br>&gt; }<br>&gt;<br>&gt; etc...<br>&gt;<br>&gt; This would _not_ mean to disallow or remove the &quot;var and &quot;let&quot; mutability<br>&gt; declarations - just to make them optional. If I still want to write it to<br>&gt; make it clear just by reading thru the code then this is ok. But I can omit<br>&gt; &quot;var and &quot;let&quot; if I want -  why bother about it at all if I can go sure<br>&gt; that the compiler is already doing the best?<br>&gt;<br>&gt; Another option (if this is &quot;too much&quot; change) would be to just make &quot;let&quot;<br>&gt; optional and &quot;var&quot; still should be explicitly written. So &quot;let&quot; would be<br>&gt; the default and if I want mutability I have explicitly declare it as &quot;var&quot;.<br>&gt; This is already the rule for function parameters.<br>&gt;<br>&gt; Kind regards,<br>&gt; Darko Damjanovic-Lichtfuss<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160224/c72b8dff/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
