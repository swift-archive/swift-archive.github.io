<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Review] SE-0027 Expose code unit initializers on String</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>February 15, 2016 at 04:00:00pm</p></header><div class="content"><p>on Mon Feb 15 2016, Zach Waldowski &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Responses are inline.<br>&gt;<br>&gt; Best,<br>&gt; Zachary Waldowski<br>&gt; zach at waldowski.me<br>&gt;<br>&gt; On Mon, Feb 15, 2016, at 02:10 PM, Dave Abrahams via swift-evolution<br>&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; on Mon Feb 15 2016, Zach Waldowski &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; See responses inline.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Aside: omgomgomg I got Dave Abrahams to respond to a proposal of mine<br>&gt;&gt; <br>&gt;&gt; Don&#39;t worry; it&#39;ll wear off soon enough...<br>&gt;&gt; <br>&gt;&gt; &gt; Excitedly,<br>&gt;&gt; &gt;   Zachary Waldowski<br>&gt;&gt; &gt;   zach at waldowski.me<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; On Mon, Feb 15, 2016, at 11:48 AM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; on Thu Feb 11 2016, Douglas Gregor &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; &gt; Hello Swift community,<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The review of SE-0027 &quot;Expose code unit initializers on String&quot; begins<br>&gt;&gt; &gt;&gt; &gt; now and runs through February 16, 2016. The proposal is available<br>&gt;&gt; &gt;&gt; &gt; here:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; &gt;&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt; &gt;&gt; &gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &gt;&gt; &gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; &gt;&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; &gt;&gt; &gt; review manager. When replying, please try to keep the proposal link at<br>&gt;&gt; &gt;&gt; &gt; the top of the message:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Proposal link:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; &gt;&gt; &gt; Reply text<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; Other replies<br>&gt;&gt; &gt;&gt; &gt;  &lt;https://github.com/apple/swift-evolution#what-goes-into-a-review-1&gt;What goes into a review?<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; &gt;&gt; &gt; through constructive criticism and, eventually, determine the<br>&gt;&gt; &gt;&gt; &gt; direction of Swift. When writing your review, here are some questions<br>&gt;&gt; &gt;&gt; &gt; you might want to answer in your review:<br>&gt;&gt; &gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; &gt; What is your evaluation of the proposal?<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; I support the intent of the proposal but am -1 on the specific proposal<br>&gt;&gt; &gt;&gt; as offered.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; First, in the presentation, there are several things that make it hard<br>&gt;&gt; &gt;&gt; to evaluate:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; 1. The &quot;decode&quot; function signature is so wide that it can&#39;t be read<br>&gt;&gt; &gt;&gt;    without scrolling at<br>&gt;&gt; &gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0027-string-from-code-units.md<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; 2. The proposal doesn&#39;t show any usage of the proposed APIs, so it<br>&gt;&gt; &gt;&gt;    is hard to understand what effect these APIs would have on real<br>&gt;&gt; &gt;&gt;    code.  There are some examples of uses in<br>&gt;&gt; &gt;&gt;    https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units<br>&gt;&gt; &gt;&gt;    but I have to dig for them.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; 3. The description of the “Detailed Design” doesn&#39;t show any examples<br>&gt;&gt; &gt;&gt;    either, so I have to imagine what “backporting the Swift 3.0 versions<br>&gt;&gt; &gt;&gt;    of the CString constructors, then making them generic over their<br>&gt;&gt; &gt;&gt;    input and codec” means.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The notes are appreciated. I&#39;ll take care to add examples and fix<br>&gt;&gt; &gt; formatting. The proposal was always intended to be paired with the PR to<br>&gt;&gt; &gt; the stdlib, and that lack of clarity did not come up during the proposal<br>&gt;&gt; &gt; vetting stage.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; Next, when I look at *uses* that I can find (in the tests), I don&#39;t find<br>&gt;&gt; &gt;&gt; them to be clear.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;   String(validatingCodeUnits: result, as: UTF8.self)<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; What does “validatingCodeUnits” mean?  Clearly we&#39;re going to do some<br>&gt;&gt; &gt;&gt; checking.  Is there a repair?  Is the initializer failable?  <br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m open to suggestions. The names as they are were lifted from the<br>&gt;&gt; &gt; changes to the CString APIs made on swift-3-api-guidelines.<br>&gt;&gt; <br>&gt;&gt; I suspected that they might be so I went and checked on GitHub... but<br>&gt;&gt; now I see that only searches the default branch :-P<br>&gt;&gt; <br>&gt;&gt;     https://help.github.com/articles/searching-code/<br>&gt;&gt; <br>&gt;&gt; But if the naming error was on our side, my apologies.  We should do<br>&gt;&gt; better, regardless.<br>&gt;&gt; <br>&gt;&gt; &gt; &quot;repairingCodeUnits&quot; implies to me that there is something already wrong<br>&gt;&gt; &gt; with them. <br>&gt;&gt; <br>&gt;&gt; That doesn&#39;t bother me.  If you are requesting the repair, you are<br>&gt;&gt; effectively assuming that there is something already wrong with them.<br>&gt;&gt; <br>&gt;&gt; &gt; I&#39;m also not sure as to the point of the initializer being failable;<br>&gt;&gt; &gt; many domain initializers in the stdlib don&#39;t indicate that they can<br>&gt;&gt; &gt; fail directly in the name.<br>&gt;&gt; <br>&gt;&gt; The point I&#39;m trying to make is that the implications of “validating”<br>&gt;&gt; aren&#39;t clear, not that I can&#39;t tell whether it&#39;s failable.<br>&gt;<br>&gt; Okay, point taken. Is your recommendation behind &quot;repairingCodeUnits&quot;?<br></p><p>If repairingInvalidCodeUnits reflects the correct semantics, that&#39;s what<br>I&#39;d use.<br></p><p>&gt; Or something else?<br>&gt;<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; In this change, for example:<br>&gt;&gt; &gt;&gt; https://github.com/apple/swift/compare/master...zwaldowski:string-from-code-units#diff-d39ec2c4819c950aeef95f899f53b104R79<br>&gt;&gt; &gt;&gt; I find the old code much clearer than the new code (I&#39;m not sure why<br>&gt;&gt; &gt;&gt; _decode starts with an underscore here; isn&#39;t it part of your proposed<br>&gt;&gt; &gt;&gt; public API?)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The PR is ahead of the proposal here. It was pointed out in the review<br>&gt;&gt; &gt; thread up to this point that that that &quot;primitive&quot; isn&#39;t truly needed;<br>&gt;&gt; &gt; the initializers on String should be the API used by all.<br>&gt;&gt; <br>&gt;&gt; Okay, well, proposals (including any diffs they reference) should remain<br>&gt;&gt; stable under review so we know what we&#39;re reviewing.  I really don&#39;t<br>&gt;&gt; know what&#39;s being proposed here.<br>&gt;<br>&gt; Noted. I was following the example set by many other reviews, and I<br>&gt; apologize for not knowing what the right was here.<br></p><p>n/p.<br></p><p>&gt; I intend to continue to push changes to the PR (or make a new branch,<br>&gt; more likely), but will strive to make the proposal not dependent on the<br>&gt; branch anyway. <br>&gt;<br>&gt;&gt; <br>&gt;&gt; &gt; static func decode&lt;<br>&gt;&gt; &gt;   Encoding: UnicodeCodecType, <br>&gt;&gt; &gt;   Input: CollectionType where Input.Generator.Element == Encoding.CodeUnit<br>&gt;&gt; &gt; &gt;(<br>&gt;&gt; &gt;    _: Input, as: Encoding.Type, repairingInvalidCodeUnits: Bool = default<br>&gt;&gt; &gt; ) -&gt; (result: String, repairsMade: Bool)?<br>&gt;&gt; <br>&gt;&gt; It seems like you are withdrawing decode from the proposal?<br></p><p>?<br></p><p>&gt;&gt; &gt; For convenience, the Bool flag here is also separated out to a more<br>&gt;&gt; &gt; common-case pair of String initializers:<br>&gt;&gt; <br>&gt;&gt; I don&#39;t understand what it means for a “bool flag to be separated out to<br>&gt;&gt; a... pair of ... initializers.”<br>&gt;&gt; <br>&gt;&gt; &gt; init&lt;...&gt;(codeUnits: Input, as: Encoding.Type)<br>&gt;&gt; &gt; init?&lt;...&gt;(validatingCodeUnits: Input, as: Encoding.Type)<br>&gt;&gt; <br>&gt;&gt; Are you saying that the first initializer corresponds to<br>&gt;&gt; `repairingInvalidCodeUnits: true` and the second to<br>&gt;&gt; `repairingInvalidCodeUnits: false`?<br>&gt;<br>&gt; Yes.<br></p><p>Okay, well the language you used doesn&#39;t make that clear.<br></p><p>&gt;&gt; What about the user who wants repairs if necessary and wants to know<br>&gt;&gt; about it when repairs were made?<br>&gt;<br>&gt; That&#39;s valid enough reason to keep the full version of decode around,<br>&gt; though I will again note that the flag is typically ignored. I&#39;ve yet to<br>&gt; find someone actually using it.<br></p><p>Does the standard library use it?<br></p><p>&gt;&gt; &gt; Finally, for more direct compatibility with String.Type.fromCString(_:)<br>&gt;&gt; &gt; and String.Type.fromCStringRepairingIllFormedUTF8(_:), these<br>&gt;&gt; &gt; constructors are overloaded for pointer-based strings of unknown length:<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; init(cString: UnsafePointer&lt;CChar&gt;)<br>&gt;&gt; &gt; init?(validatingCString: UnsafePointer&lt;CChar&gt;)<br>&gt;&gt; <br>&gt;&gt; Why are we trying to “be compatible” with those static methods?  <br>&gt;<br>&gt; They are existing public API and they are being deprecated and replaced<br>&gt; by this proposal. It was noted during the proposal shopping period that<br>&gt; requiring strlen and creating an UnsafeBufferPointer would be, in as<br>&gt; many words, too much migration effort.<br></p><p>Ah.<br></p><p>&gt;&gt; &gt; The ugliness in this instance is transitional; <br>&gt;&gt; <br>&gt;&gt; What ugliness?<br>&gt;<br>&gt; &quot;I find the old code much clearer than the new code&quot;, being the<br>&gt; forwarding implementation of<br>&gt; String.Type.fromCStringRepairingIllFormedUTF8(_:).<br></p><p>I&#39;m sorry, I don&#39;t mean to be difficult, really, but I don&#39;t understand<br>how that answers my quetsion.<br></p><p>&gt;&gt; &gt; it stems from bridging the old-style constructor to the new-style<br>&gt;&gt; &gt; one. <br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what that means either.<br>&gt;<br>&gt; String.Type.fromCString(_:) and<br>&gt; String.Type.fromCStringRepairingIllFormedUTF8(_:) are replaced by<br>&gt; String(validatingCString:) and String(cString:), respectively, as<br>&gt; described under &quot;Impact on existing code&quot;.<br></p><p>Nor that.<br></p><p>&gt;&gt; &gt; The old signature&#39;s return type is awkward in that it returns the<br>&gt;&gt; &gt; extra hadError flag regardless of whether decoding failed, which is<br>&gt;&gt; &gt; discarded almost universally by clients in the stdlib.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I intend to revert the change to `fromCStringRepairingIllFormedUTF8`, or<br>&gt;&gt; &gt; elide `_decode` into it instead.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t know what that means either.<br>&gt;<br>&gt; You found the changes fromCStringRepairingIllFormedUTF8 unclear, I<br>&gt; intend to return it to the previous version.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; Lastly, I am very concerned about the “Alternatives Considered” section,<br>&gt;&gt; &gt;&gt; where, of one alternative, it says:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt;       This might be the better long-term solution from the perspective<br>&gt;&gt; &gt;&gt;       of API maintenance, but in the meantime this proposal has a fairly<br>&gt;&gt; &gt;&gt;       low impact.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; We can&#39;t accept changes into the standard library “in the meantime,”<br>&gt;&gt; &gt;&gt; with the expectation that something more comprehensive will make them<br>&gt;&gt; &gt;&gt; obsolete.  Even though we&#39;ve had migration tools, we never operated that<br>&gt;&gt; &gt;&gt; way in the past, and as we head toward API and ABI stability it is even<br>&gt;&gt; &gt;&gt; more true today.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I understand the sentiment here, but I don&#39;t think &quot;wait for the next<br>&gt;&gt; &gt; rewrite of String&quot; is a good solution to a problem that the stdlib<br>&gt;&gt; &gt; already resolves. <br>&gt;&gt; <br>&gt;&gt; I&#39;m really confused.  If the stdlib already resolves the problem, why is<br>&gt;&gt; there a proposal?<br>&gt;<br>&gt; It has implementations in underscored form, which I can&#39;t use.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; &gt; See below.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; &gt; Is the problem being addressed significant enough to warrant a change<br>&gt;&gt; &gt;&gt; &gt; to Swift?<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Yes.<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; &gt; Does this proposal fit well with the feel and direction of Swift?  <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; W.r.t. direction, the fact that we have a major String overhaul planned<br>&gt;&gt; &gt;&gt; means that tackling this one corner of the API is probably not entirely<br>&gt;&gt; &gt;&gt; appropriate.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; &quot;Corner&quot; is an unfair characterization; <br>&gt;&gt; <br>&gt;&gt; Not at all; this addresses an important use-case, but accounts for a<br>&gt;&gt; very small part of the API.<br>&gt;&gt; <br>&gt;&gt; &gt; users of Swift want to implement things to the level of safety and<br>&gt;&gt; &gt; performance bar set by the stdlib, but we are currently at a<br>&gt;&gt; &gt; disadvantage. No better example can be found but in<br>&gt;&gt; &gt; corelibs-foundation:<br>&gt;&gt; &gt; https://github.com/apple/swift-corelibs-foundation/blob/546dc8e16c3c34ca50f5752c6d0f39c3524f5f0a/Foundation/NSString.swift#L305.<br>&gt;&gt; <br>&gt;&gt; Heh, well, that&#39;s ironic.  Before Swift was released we had all of this<br>&gt;&gt; functionality for unicode transcoding available in the String API, and<br>&gt;&gt; it was decided that to avoid treading into Foundation&#39;s territory, any<br>&gt;&gt; functionality already exposed by NSString should not be public API on<br>&gt;&gt; String without Foundation loaded.<br>&gt;&gt; <br>&gt;<br>&gt; That&#39;s unfortunate.<br>&gt;<br>&gt;&gt; I have ambitions that Swift strings will be first-class standalone types<br>&gt;&gt; without the need to rely on Foundation some day soon, but under the<br>&gt;&gt; circumstances we may need a more comprehensive change than merely adding<br>&gt;&gt; fast unicode transcoding to justify treading into this area.<br>&gt;&gt; <br>&gt;&gt; &gt; Is it not a deficiency of the stdlib when code has to resort to<br>&gt;&gt; &gt; non-public methods? <br>&gt;&gt; <br>&gt;&gt; Yes.  There are lots of deficiencies in the stdlib.  I&#39;m not saying this<br>&gt;&gt; shouldn&#39;t be addressed, but I&#39;m concerned about addressing this in a<br>&gt;&gt; temporary way that we think may be sub-optimal.<br>&gt;&gt; <br>&gt;&gt; &gt; The stdlib (i.e., the parts touched by the PR) and corelibs-foundation<br>&gt;&gt; &gt; would have to move in lockstep to adopt a replacement, so the existing<br>&gt;&gt; &gt; underscored versions are as good as public API.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I understand, and 100% encourage, the reticence around new API. However,<br>&gt;&gt; &gt; we&#39;ve created a worse problem by encouraging slow, buggy, custom<br>&gt;&gt; &gt; versions of behavior that already exists in the stdlib, or implying that<br>&gt;&gt; &gt; the underscored API should be used because we haven&#39;t managed something<br>&gt;&gt; &gt; better yet. :/<br>&gt;&gt; <br>&gt;&gt; I am not reticent to have new API.  I am reticent to accept partial or<br>&gt;&gt; known-suboptimal temporary solutions when we are developing a<br>&gt;&gt; comprehensive plan that ought to address the same problems (among many<br>&gt;&gt; others).<br>&gt;<br>&gt; Not it&#39;s my turn to be confused. I don&#39;t think of this proposal as a<br>&gt; temporary solution, and would like more color on that if you would. <br></p><p>You have said that in the fullness of time this problem would be better<br>addressed a different way.<br></p><p>&gt; Even if a &quot;more complete&quot; variant found its way to the String views,<br>&gt; the number of clients in the stdlib and Foundation make it clear that<br>&gt; this group of constructors are necessary. Unless the entire<br>&gt; UnicodeCodec concept is going away, I don&#39;t see this proposal causing<br>&gt; a drastic migration problem; if they are, then the proposed<br>&gt; constructors would be just a small component of another heroic<br>&gt; migration anyway.<br></p><p>We&#39;re not going to have that many more heroic migrations; that&#39;s my<br>point.  We should approve the right answer, whatever that is.<br></p><p>-- <br>-Dave<br></p></div></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
