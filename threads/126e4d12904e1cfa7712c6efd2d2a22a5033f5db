<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>September 29, 2016 at 07:00:00pm</p></header><div class="content"><p>+1 to conditional conformances in general.<br>&gt; &gt;&gt; What other designs were considered and rejected? It seems like some kind of escape hatch would be preferred if you happen to get into this situation, though you make some really good points about the pitfalls.<br>&gt; &gt; <br>&gt; &gt; I don’t have a fully-baked alternative proposal—it would probably have to involve some kind of preference rule for picking the “best” set of (consistent!) conformances to satisfy a particular request, introduce a disambiguation syntax for cases where that preference rule does the wrong thing, and some way of teaching the dynamic-casting machinery to do the same thing.<br>&gt; <br>&gt; Yeah your description is already sounding like a lot of work :)<br>I still think it is worth looking at this issue in general though. I think it is one of the big holes in swift’s grammar, and the sooner we find a way to express distributed ordering, the less churn it will cause when we make the change (and the more consistency we can have across language features which share this issue).  It doesn’t necessarily have to be fixed in this proposal though, as long as we don’t paint ourselves into a corner.<br></p><p>&gt; You get a compile error if there are two conformances of SomeWrapper to Equatable; it doesn’t actually matter whether they are conditional, but people are far more likely to expect to be able to having overlapping conditional conformances.<br>&gt; <br>&gt; Slightly off-topic but I was hit quick badly by this recently because two libraries I was trying to import both conformed UIControlState to Hashable to be able to use it as Dictionary indices. It seems like something that might happen kind of regularly with important protocols like Hashable and Equatable.<br></p><p>I agree with David that the non-overlapping issue is going to come up a lot around things like Equatable.<br></p><p>One potential solution would be to have the ability to mark a conditionally conforming extension as “weak” (or another term which has been bikeshedded).  In this case, it would then act similarly to default implementations of protocols.  That is, it would provide conformance if no one else was, but defer to any other implementation which is available. This means library authors can provide basic conditional conformance without locking out more specific implementations.  This deferral would likely be on a method by method basis (similar to default protocol implementations), though the “weak” (or equivalent) annotation would apply to the extension as a whole.<br></p><p>Thanks,<br>Jon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/126ef5db/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal draft] Conditional conformances</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Sep 29, 2016, at 7:45 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; +1 to conditional conformances in general.<br>&gt;&gt; &gt;&gt; What other designs were considered and rejected? It seems like some kind of escape hatch would be preferred if you happen to get into this situation, though you make some really good points about the pitfalls.<br>&gt;&gt; &gt; <br>&gt;&gt; &gt; I don’t have a fully-baked alternative proposal—it would probably have to involve some kind of preference rule for picking the “best” set of (consistent!) conformances to satisfy a particular request, introduce a disambiguation syntax for cases where that preference rule does the wrong thing, and some way of teaching the dynamic-casting machinery to do the same thing.<br>&gt;&gt; <br>&gt;&gt; Yeah your description is already sounding like a lot of work :)<br>&gt; I still think it is worth looking at this issue in general though. I think it is one of the big holes in swift’s grammar, and the sooner we find a way to express distributed ordering, the less churn it will cause when we make the change (and the more consistency we can have across language features which share this issue).  It doesn’t necessarily have to be fixed in this proposal though, as long as we don’t paint ourselves into a corner.<br></p><p>I agree that we need to address the inability to disambiguate in the language. I&#39;d like to see it addressed comprehensively, so we don&#39;t end up with one syntax in part of the language that doesn&#39;t work in another, similar part of the language. So it should cover &quot;I want to call this specific thing in this protocol extension defined in this other module...&quot; and &quot;I want to this method to implement that requirement of this specific protocol&quot; and such. <br></p><p>In a sense, this particular proposal doesn&#39;t &quot;need&quot; disambiguation because it bans ambiguities. <br></p><p>&gt; <br>&gt;&gt; You get a compile error if there are two conformances of SomeWrapper to Equatable; it doesn’t actually matter whether they are conditional, but people are far more likely to expect to be able to having overlapping conditional conformances.<br>&gt;&gt; <br>&gt;&gt; Slightly off-topic but I was hit quick badly by this recently because two libraries I was trying to import both conformed UIControlState to Hashable to be able to use it as Dictionary indices. It seems like something that might happen kind of regularly with important protocols like Hashable and Equatable.<br>&gt; <br>&gt; I agree with David that the non-overlapping issue is going to come up a lot around things like Equatable.<br></p><p>Yeah, it&#39;s likely to happen most with libraries imported from C/Objective-C and the standard library&#39;s protocols, because the C/Objective-C types won&#39;t have considered those conformances initially and yet everyone uses the standard library protocols. <br></p><p>&gt; <br>&gt; One potential solution would be to have the ability to mark a conditionally conforming extension as “weak” (or another term which has been bikeshedded).  In this case, it would then act similarly to default implementations of protocols.  That is, it would provide conformance if no one else was, but defer to any other implementation which is available. This means library authors can provide basic conditional conformance without locking out more specific implementations.  This deferral would likely be on a method by method basis (similar to default protocol implementations), though the “weak” (or equivalent) annotation would apply to the extension as a whole.<br></p><p>This is roughly the shape of solutions we&#39;ve discussed. There is some runtime validation we might need---for example, to make sure all of the conformances define the same associated type witnesses---but it&#39;s something we can probably do via lazy deduplication at runtime. <br></p><p>  - Doug<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160929/4ab627ff/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
