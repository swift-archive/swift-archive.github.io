<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Pitch] Add overrides with UnsafePointer sources to non-destructive copying methods on UnsafeMutablePointer</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February  3, 2016 at 12:00:00am</p></header><div class="content"><p>Hi everyone!<br></p><p>I have a small change to `UnsafeMutablePointer` that I&#39;d like to pitch here before turning it into a full proposal and I&#39;d love to hear your feedback on it.<br></p><p><br>`UnsafeMutablePointer` offers the following methods to copy memory contents non-destructively:<br></p><p>func assignBackwardFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>func assignFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>func initializeFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br></p><p>Basically my proposal boils down to adding overloads for these methods to `UnsafeMutablePointer` that take `UnsafePointer` source arguments instead.<br></p><p>Currently it is necessary to cast an `UnsafePointer` to `UnsafeMutablePointer` before using it with one of these methods:<br></p><p>let source: UnsafePointer&lt;Int&gt; = ...<br>let destination: UnsafeMutablePointer&lt;Int&gt; = ...<br></p><p>destination.assignFrom(UnsafeMutablePointer(source), count: count)<br></p><p>I&#39;d like to get rid of these casts. I would argue that they are not only technically unnecessary and add visual noise but that they could actually be a source of confusion.<br>A cast of an `UnsafePointer` to its mutable variant should throw up a red flag in most cases and even though this case is ultimately innocuous it still increases cognitive load on the reader.<br></p><p><br></p><p>Alternatives:<br></p><p>* The obvious alternative is to simply not add these methods. I&#39;d argue that they provide enough benefit to justify their existence while only minimally increasing the stdlib surface area, especially by merit of being overloads.<br></p><p>* One way of working around the overloads would be to, for example, add a `PointerProtocol` to the standard library and make use of that in these methods. However, that would be a much more intrusive change with little immediate (if any) benefit and introduces more questions than it answers.<br></p><p>* Finally, the implicit conversions from `UnsafeMutablePointer&lt;T&gt;` to `UnsafePointer&lt;T&gt;` could be leveraged to work around the need for overloads by dropping the existing methods taking `UnsafeMutablePointer` source arguments. If I had to guess, I&#39;d say that bit of compiler magic probably exists more in service of (Obj)-C interaction and I would be wary to depend on it here. It&#39;s also non-obvious from a documentation and auto-completion perspective.<br></p><p><br>Related:<br>I also have a few related items that might make sense to discuss in tandem while we&#39;re talking about `UnsafePointer` and friends.<br></p><p>* func distanceTo(x: Unsafe(Mutable)Pointer&lt;Memory&gt;) -&gt; Int<br>This is the only other method on `UnsafePointer` and `UnsafeMutablePointer` for which similar overloads might make sense. However, I cannot really see enough of a use case to justify adding overloads here. Also the current methods match protocol requirements whereas the overloads would not.<br></p><p>* UnsafeBufferPointer.init()<br>One might argue that if we are not going to (a)buse implicit conversions that we should perhaps also add an explicitly overloaded initializer to `UnsafeBufferPointer` that takes an `UnsafeMutablePointer`. I&#39;d agree that is a minor sore point but this is less problematic to begin with and given that one can already use the implicit conversion here I&#39;m not particularly inclined to add this. Also I&#39;d strongly argue against its symmetrical other (an initializer to `UnsafeMutableBufferPointer` taking an `UnsafePointer`).<br></p><p>* `Unsafe(Mutable)Pointer` conversion initializers. <br>The generic conversion initializers for `UnsafePointer` and `UnsafeMutablePointer` suffer from a minor type inference deficiency. For example:<br></p><p>let ptr: UnsafeMutablePointer&lt;Int&gt; = nil<br>let ptr2 = UnsafePointer(ptr) // Error: Cannot invoke initializer for type &#39;UnsafePointer&lt;_&gt;&#39; with an argument list of type &#39;(UnsafeMutablePointer&lt;Int&gt;)&#39;<br></p><p>In this and similar cases, the compiler cannot currently infer the seemingly obvious choice of retaining the same generic parameter without some additional context.<br>Technically this could be solved by adding non-generic initializers but that seems like a clutch. This is probably a conscious design decision or at least known limitation with the type inference system and should be addressed there.<br></p><p><br>- Janosch<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/000c941b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Pitch] Add overrides with UnsafePointer sources to non-destructive copying methods on UnsafeMutablePointer</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>February  2, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 2 févr. 2016, at 16:06, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; func assignBackwardFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt; func assignFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt; func initializeFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt; <br>&gt; Basically my proposal boils down to adding overloads for these methods to `UnsafeMutablePointer` that take `UnsafePointer` source arguments instead.<br></p><p>I agree with these; I have run into this situation as well.<br></p><p>&gt; <br>&gt; Related:<br>&gt; I also have a few related items that might make sense to discuss in tandem while we&#39;re talking about `UnsafePointer` and friends.<br>&gt; <br>&gt; * func distanceTo(x: Unsafe(Mutable)Pointer&lt;Memory&gt;) -&gt; Int<br>&gt; This is the only other method on `UnsafePointer` and `UnsafeMutablePointer` for which similar overloads might make sense. However, I cannot really see enough of a use case to justify adding overloads here. Also the current methods match protocol requirements whereas the overloads would not.<br></p><p>I don’t think this would makes sense. This method exists to support indexing within a single block of memory; overloading across types might encourage recklessness.<br></p><p>This being said, I’ve come to think the indexing operations should only exist on the Buffer wrappers to the UnsafePointer family.<br></p><p>Guillaume Lessard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>[Pitch] Add overrides with UnsafePointer sources to non-destructive copying methods on UnsafeMutablePointer</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>February  3, 2016 at 03:00:00pm</p></header><div class="content"><p>Looks reasonable to me.<br></p><p>Félix<br></p><p>&gt; Le 2 févr. 2016 à 19:50:50, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 2 févr. 2016, at 16:06, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; func assignBackwardFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt;&gt; func assignFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt;&gt; func initializeFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt;&gt; <br>&gt;&gt; Basically my proposal boils down to adding overloads for these methods to `UnsafeMutablePointer` that take `UnsafePointer` source arguments instead.<br>&gt; <br>&gt; I agree with these; I have run into this situation as well.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Related:<br>&gt;&gt; I also have a few related items that might make sense to discuss in tandem while we&#39;re talking about `UnsafePointer` and friends.<br>&gt;&gt; <br>&gt;&gt; * func distanceTo(x: Unsafe(Mutable)Pointer&lt;Memory&gt;) -&gt; Int<br>&gt;&gt; This is the only other method on `UnsafePointer` and `UnsafeMutablePointer` for which similar overloads might make sense. However, I cannot really see enough of a use case to justify adding overloads here. Also the current methods match protocol requirements whereas the overloads would not.<br>&gt; <br>&gt; I don’t think this would makes sense. This method exists to support indexing within a single block of memory; overloading across types might encourage recklessness.<br>&gt; <br>&gt; This being said, I’ve come to think the indexing operations should only exist on the Buffer wrappers to the UnsafePointer family.<br>&gt; <br>&gt; Guillaume Lessard<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/a1ec48fa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b660eecceda60138f137d353b8289925?s=50"></div><header><strong>[Pitch] Add overrides with UnsafePointer sources to non-destructive copying methods on UnsafeMutablePointer</strong> from <string>Janosch Hildebrand</string> &lt;jnosh at jnosh.com&gt;<p>February  9, 2016 at 05:00:00pm</p></header><div class="content"><p>A proposal draft can be found here:<br></p><p>https://github.com/Jnosh/swift-evolution/blob/copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source/proposals/0000-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.md &lt;https://github.com/Jnosh/swift-evolution/blob/copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source/proposals/0000-copying-to-unsafe-mutable-pointer-with-unsafe-pointer-source.md&gt;<br></p><p>- Janosch<br></p><p>&gt; On 03 Feb 2016, at 21:52, Félix Cloutier &lt;felixcca at yahoo.ca&gt; wrote:<br>&gt; <br>&gt; Looks reasonable to me.<br>&gt; <br>&gt; Félix<br>&gt; <br>&gt;&gt; Le 2 févr. 2016 à 19:50:50, Guillaume Lessard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 2 févr. 2016, at 16:06, Janosch Hildebrand via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func assignBackwardFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt;&gt;&gt; func assignFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt;&gt;&gt; func initializeFrom(source: UnsafeMutablePointer&lt;Pointee&gt;, count: Int)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Basically my proposal boils down to adding overloads for these methods to `UnsafeMutablePointer` that take `UnsafePointer` source arguments instead.<br>&gt;&gt; <br>&gt;&gt; I agree with these; I have run into this situation as well.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Related:<br>&gt;&gt;&gt; I also have a few related items that might make sense to discuss in tandem while we&#39;re talking about `UnsafePointer` and friends.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * func distanceTo(x: Unsafe(Mutable)Pointer&lt;Memory&gt;) -&gt; Int<br>&gt;&gt;&gt; This is the only other method on `UnsafePointer` and `UnsafeMutablePointer` for which similar overloads might make sense. However, I cannot really see enough of a use case to justify adding overloads here. Also the current methods match protocol requirements whereas the overloads would not.<br>&gt;&gt; <br>&gt;&gt; I don’t think this would makes sense. This method exists to support indexing within a single block of memory; overloading across types might encourage recklessness.<br>&gt;&gt; <br>&gt;&gt; This being said, I’ve come to think the indexing operations should only exist on the Buffer wrappers to the UnsafePointer family.<br>&gt;&gt; <br>&gt;&gt; Guillaume Lessard<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160209/95d5e04e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
