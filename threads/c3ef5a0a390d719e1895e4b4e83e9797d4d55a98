<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/775f6d0d1d1207c0e78b2eaf4eb38e4c?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Jimmy Sambuo</string> &lt;jsambuo at gmail.com&gt;<p>December 19, 2015 at 09:00:00pm</p></header><div class="content"><p>Hi Swift-Evolution,<br></p><p>I&#39;ve been playing around with an idea, and I wanted to see what you think<br>about it.<br></p><p>My proposal is to add a `pure` keyword/attribute to Swift.<br></p><p>Similar to throws, you would mark a function as pure to say it will not<br>cause any observable side-effects and hold referential transparency:<br></p><p>```swift<br></p><p>func pure add(x: Int, y: Int) -&gt; Int {<br></p><p>    return x + y<br></p><p>}<br></p><p>```<br></p><p>By adding this attribute, the function is guaranteed to have some<br>properties:<br></p><p>   1. The function must have a return value<br>   2. This function can only call other pure functions<br>   3. This function cannot access/modify global or static variables.<br></p><p>```swift<br></p><p>func pure getDate() -&gt; NSDate {<br></p><p>    return NSDate.date() // Error: pure function &#39;getDate&#39; cannot call<br>impure function &#39;date&#39;<br></p><p>}<br></p><p>```<br></p><p>This would be similar to the pure keyword in D (<br>https://dlang.org/spec/function.html#pure-functions) or the noSideEffect<br>pragma in Nim (<br>http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma).<br></p><p>My motivation for this is that I want to create applications that follow a<br>&quot;Functional Core, Imperative Shell&quot; style [Gary Bernhardt]. By marking all<br>of my functions within the functional core as pure, the compiler can help<br>me if I accidentally start writing impure functions. In theory, this should<br>make my application simpler and more testable. Reviewing pull requests will<br>also be simpler since in the functional portion of my codebase, checking<br>for pure can be a criteria. Ideally, I&#39;d run a static analyzer to see that<br>I have more pure functions than impure ones, which should help me control<br>complexity by encouraging me to have a larger &quot;value&quot; layer and smaller<br>&quot;object&quot; layer [Andy Matuschak].<br></p><p>Logically, I think of this as Swift having all functions return &quot;Implicitly<br>Impure Values&quot; (similar to how every object from objective-c is an<br>implicitly unwrapped optional). All existing Swift functions are actually<br>returning a IO&lt;SomeType&gt;, and functions using that are implicitly<br>unwrapping them. Swift can be super nice by hiding this fact, making the<br>language much more familiar and accessible to developers not used to<br>purity. Adding `pure` allows devs to tap into the compiler&#39;s power and<br>prevent unwanted side-effects without directly exposing the IO type.<br></p><p>The benefits I see are:<br></p><p>   - Explicit intentions - This allows design decisions to be communicated<br>   clearly to other developers and maintainers, as well as the compiler and<br>   other static analysis tools.<br>   - Compile-time guarantee - The compiler can help prevent unintentional<br>   state modifications.<br>   - Encouragement of better state management practices - More people will<br>   be aware of the concept of functional purity and may try to design their<br>   code to have more pure functions, which should make more code simpler and<br>   testable. This isn&#39;t a guarantee it will happen, but more people should<br>   understand it if it brings concrete results instead of just being an<br>   abstract concept.<br>   - Reduced cognitive load when understanding code - More pure functions<br>   should make it easier to reason about code.<br>   - Opt-in to purity - Swift will be just as accessible to new developers,<br>   but experienced developers will be able to take advantage of this.<br>   - Backwards compatible (mostly) - Existing codebases should still<br>   compile without any change (unless pure was used as a variable/method/class<br>   name).<br></p><p>Of course, there are risks of this feature. Some of the risks include:<br></p><p>   - This could make the language more difficult to work with. Developers<br>   maintaining an existing codebase with lots of pure function may become<br>   confused or frustrated when they realize they cannot do easy things such as<br>   logging within the method.<br>      - A counterargument to this may be that when Swift was introduced,<br>      optionals also made the language difficult to use. People implicitly<br>      unwrapped them just so things will compile, or returned them from methods<br>      without much consideration to what that implies. Nevertheless, this made<br>      Swift a safer language to use by explicitly when nil is a possible value.<br>      Developers are more conscious about nil being a potential value.<br>Similarly,<br>      I think developers should be more aware about side-effect causing<br>      functions. Being clear about this and separating these concerns should<br>      bring about more safer and testable Swift applications.<br>   - Implementation of this feature could be difficult. Swift can implement<br>   it in several different ways depending on the desired result of this<br>   feature, such as having stronger or weaker purity guarantees to make the<br>   feature easier to use or simpler to implement. An effect system may have to<br>   be created.<br>      - Alternatively, this could be done in a lightweight manner where the<br>      feature is introduced and known &quot;pure-like&quot; functions are marked<br>      in swift-corelibs-foundation.<br></p><p>To be honest, I don&#39;t have much experience in languages that have this<br>feature. I would imagine many people are interested in the notion of pure<br>functions, but the question here is if it would be worth it, feasible, or<br>even aligned with Swift&#39;s goals to have this feature. I&#39;m half-expecting<br>that this has already been brought up and determined to be out of scope or<br>not a good idea.<br></p><p>Thanks for your consideration. Please let me know what you think.<br>-- <br>Jimmy Sambuo<br>www.sambuo.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151219/c3ef5a98/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>December 20, 2015 at 04:00:00pm</p></header><div class="content"><p>I have wanted to propose this myself. The main advantage I want from it is<br>that you could have a @pure on closure type signatures, similar to<br>@noescape to restrict the type of closures that can be used.<br></p><p>On Sun, Dec 20, 2015 at 4:00 PM, Jimmy Sambuo via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi Swift-Evolution,<br>&gt;<br>&gt; I&#39;ve been playing around with an idea, and I wanted to see what you think<br>&gt; about it.<br>&gt;<br>&gt; My proposal is to add a `pure` keyword/attribute to Swift.<br>&gt;<br>&gt; Similar to throws, you would mark a function as pure to say it will not<br>&gt; cause any observable side-effects and hold referential transparency:<br>&gt;<br>&gt; ```swift<br>&gt;<br>&gt; func pure add(x: Int, y: Int) -&gt; Int {<br>&gt;<br>&gt;     return x + y<br>&gt;<br>&gt; }<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; By adding this attribute, the function is guaranteed to have some<br>&gt; properties:<br>&gt;<br>&gt;    1. The function must have a return value<br>&gt;    2. This function can only call other pure functions<br>&gt;    3. This function cannot access/modify global or static variables.<br>&gt;<br>&gt; ```swift<br>&gt;<br>&gt; func pure getDate() -&gt; NSDate {<br>&gt;<br>&gt;     return NSDate.date() // Error: pure function &#39;getDate&#39; cannot call<br>&gt; impure function &#39;date&#39;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; This would be similar to the pure keyword in D (<br>&gt; https://dlang.org/spec/function.html#pure-functions) or the noSideEffect<br>&gt; pragma in Nim (<br>&gt; http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma).<br>&gt;<br>&gt; My motivation for this is that I want to create applications that follow a<br>&gt; &quot;Functional Core, Imperative Shell&quot; style [Gary Bernhardt]. By marking all<br>&gt; of my functions within the functional core as pure, the compiler can help<br>&gt; me if I accidentally start writing impure functions. In theory, this should<br>&gt; make my application simpler and more testable. Reviewing pull requests will<br>&gt; also be simpler since in the functional portion of my codebase, checking<br>&gt; for pure can be a criteria. Ideally, I&#39;d run a static analyzer to see that<br>&gt; I have more pure functions than impure ones, which should help me control<br>&gt; complexity by encouraging me to have a larger &quot;value&quot; layer and smaller<br>&gt; &quot;object&quot; layer [Andy Matuschak].<br>&gt;<br>&gt; Logically, I think of this as Swift having all functions return<br>&gt; &quot;Implicitly Impure Values&quot; (similar to how every object from objective-c is<br>&gt; an implicitly unwrapped optional). All existing Swift functions are<br>&gt; actually returning a IO&lt;SomeType&gt;, and functions using that are implicitly<br>&gt; unwrapping them. Swift can be super nice by hiding this fact, making the<br>&gt; language much more familiar and accessible to developers not used to<br>&gt; purity. Adding `pure` allows devs to tap into the compiler&#39;s power and<br>&gt; prevent unwanted side-effects without directly exposing the IO type.<br>&gt;<br>&gt; The benefits I see are:<br>&gt;<br>&gt;    - Explicit intentions - This allows design decisions to be<br>&gt;    communicated clearly to other developers and maintainers, as well as the<br>&gt;    compiler and other static analysis tools.<br>&gt;    - Compile-time guarantee - The compiler can help prevent unintentional<br>&gt;    state modifications.<br>&gt;    - Encouragement of better state management practices - More people<br>&gt;    will be aware of the concept of functional purity and may try to design<br>&gt;    their code to have more pure functions, which should make more code simpler<br>&gt;    and testable. This isn&#39;t a guarantee it will happen, but more people should<br>&gt;    understand it if it brings concrete results instead of just being an<br>&gt;    abstract concept.<br>&gt;    - Reduced cognitive load when understanding code - More pure functions<br>&gt;    should make it easier to reason about code.<br>&gt;    - Opt-in to purity - Swift will be just as accessible to new<br>&gt;    developers, but experienced developers will be able to take advantage of<br>&gt;    this.<br>&gt;    - Backwards compatible (mostly) - Existing codebases should still<br>&gt;    compile without any change (unless pure was used as a variable/method/class<br>&gt;    name).<br>&gt;<br>&gt; Of course, there are risks of this feature. Some of the risks include:<br>&gt;<br>&gt;    - This could make the language more difficult to work with. Developers<br>&gt;    maintaining an existing codebase with lots of pure function may become<br>&gt;    confused or frustrated when they realize they cannot do easy things such as<br>&gt;    logging within the method.<br>&gt;       - A counterargument to this may be that when Swift was introduced,<br>&gt;       optionals also made the language difficult to use. People implicitly<br>&gt;       unwrapped them just so things will compile, or returned them from methods<br>&gt;       without much consideration to what that implies. Nevertheless, this made<br>&gt;       Swift a safer language to use by explicitly when nil is a possible value.<br>&gt;       Developers are more conscious about nil being a potential value. Similarly,<br>&gt;       I think developers should be more aware about side-effect causing<br>&gt;       functions. Being clear about this and separating these concerns should<br>&gt;       bring about more safer and testable Swift applications.<br>&gt;    - Implementation of this feature could be difficult. Swift can<br>&gt;    implement it in several different ways depending on the desired result of<br>&gt;    this feature, such as having stronger or weaker purity guarantees to make<br>&gt;    the feature easier to use or simpler to implement. An effect system may<br>&gt;    have to be created.<br>&gt;       - Alternatively, this could be done in a lightweight manner where<br>&gt;       the feature is introduced and known &quot;pure-like&quot; functions are marked<br>&gt;       in swift-corelibs-foundation.<br>&gt;<br>&gt; To be honest, I don&#39;t have much experience in languages that have this<br>&gt; feature. I would imagine many people are interested in the notion of pure<br>&gt; functions, but the question here is if it would be worth it, feasible, or<br>&gt; even aligned with Swift&#39;s goals to have this feature. I&#39;m half-expecting<br>&gt; that this has already been brought up and determined to be out of scope or<br>&gt; not a good idea.<br>&gt;<br>&gt; Thanks for your consideration. Please let me know what you think.<br>&gt; --<br>&gt; Jimmy Sambuo<br>&gt; www.sambuo.com<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151220/13a96ef3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 11:00:00am</p></header><div class="content"><p>On Dec 19, 2015, at 9:00 PM, Jimmy Sambuo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; My proposal is to add a `pure` keyword/attribute to Swift.<br>&gt; <br>I’m a fan of this in concept, and the mechanics for this feature would probably allow us to have safe “computed lets” as well.  My one concern about this is that there probably has to be some way to unsafely “force a call to a non-pure function to be allowed in a pure one”, both because of type system limitations as well as interoperability with C and other languages.  Even ignoring issues around errno, it would be sad for a pure function to not be able to call “sin(x)” just because it weren’t marked __attribute__((const)).<br></p><p>A proposal in this area should consider how “pure” would interact with the type system, and it would probably make sense as an attribute @pure instead of a declmodifier.<br></p><p>-Chris<br></p><p><br>&gt; Similar to throws, you would mark a function as pure to say it will not cause any observable side-effects and hold referential transparency:<br>&gt; <br>&gt; ```swift<br>&gt; <br>&gt; func pure add(x: Int, y: Int) -&gt; Int {<br>&gt; <br>&gt;     return x + y<br>&gt; <br>&gt; }<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; By adding this attribute, the function is guaranteed to have some properties:<br>&gt; <br>&gt; The function must have a return value<br>&gt; This function can only call other pure functions<br>&gt; This function cannot access/modify global or static variables.<br>&gt; ```swift<br>&gt; <br>&gt; func pure getDate() -&gt; NSDate {<br>&gt; <br>&gt;     return NSDate.date() // Error: pure function &#39;getDate&#39; cannot call impure function &#39;date&#39; <br>&gt; <br>&gt; }<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; This would be similar to the pure keyword in D (https://dlang.org/spec/function.html#pure-functions &lt;https://dlang.org/spec/function.html#pure-functions&gt;) or the noSideEffect pragma in Nim (http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma &lt;http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma&gt;).<br>&gt; <br>&gt; My motivation for this is that I want to create applications that follow a &quot;Functional Core, Imperative Shell&quot; style [Gary Bernhardt]. By marking all of my functions within the functional core as pure, the compiler can help me if I accidentally start writing impure functions. In theory, this should make my application simpler and more testable. Reviewing pull requests will also be simpler since in the functional portion of my codebase, checking for pure can be a criteria. Ideally, I&#39;d run a static analyzer to see that I have more pure functions than impure ones, which should help me control complexity by encouraging me to have a larger &quot;value&quot; layer and smaller &quot;object&quot; layer [Andy Matuschak].<br>&gt; <br>&gt; Logically, I think of this as Swift having all functions return &quot;Implicitly Impure Values&quot; (similar to how every object from objective-c is an implicitly unwrapped optional). All existing Swift functions are actually returning a IO&lt;SomeType&gt;, and functions using that are implicitly unwrapping them. Swift can be super nice by hiding this fact, making the language much more familiar and accessible to developers not used to purity. Adding `pure` allows devs to tap into the compiler&#39;s power and prevent unwanted side-effects without directly exposing the IO type.<br>&gt; <br>&gt; The benefits I see are:<br>&gt; <br>&gt; Explicit intentions - This allows design decisions to be communicated clearly to other developers and maintainers, as well as the compiler and other static analysis tools.<br>&gt; Compile-time guarantee - The compiler can help prevent unintentional state modifications. <br>&gt; Encouragement of better state management practices - More people will be aware of the concept of functional purity and may try to design their code to have more pure functions, which should make more code simpler and testable. This isn&#39;t a guarantee it will happen, but more people should understand it if it brings concrete results instead of just being an abstract concept.<br>&gt; Reduced cognitive load when understanding code - More pure functions should make it easier to reason about code. <br>&gt; Opt-in to purity - Swift will be just as accessible to new developers, but experienced developers will be able to take advantage of this.<br>&gt; Backwards compatible (mostly) - Existing codebases should still compile without any change (unless pure was used as a variable/method/class name).<br>&gt; Of course, there are risks of this feature. Some of the risks include:<br>&gt; <br>&gt; This could make the language more difficult to work with. Developers maintaining an existing codebase with lots of pure function may become confused or frustrated when they realize they cannot do easy things such as logging within the method.<br>&gt; A counterargument to this may be that when Swift was introduced, optionals also made the language difficult to use. People implicitly unwrapped them just so things will compile, or returned them from methods without much consideration to what that implies. Nevertheless, this made Swift a safer language to use by explicitly when nil is a possible value. Developers are more conscious about nil being a potential value. Similarly, I think developers should be more aware about side-effect causing functions. Being clear about this and separating these concerns should bring about more safer and testable Swift applications.<br>&gt; Implementation of this feature could be difficult. Swift can implement it in several different ways depending on the desired result of this feature, such as having stronger or weaker purity guarantees to make the feature easier to use or simpler to implement. An effect system may have to be created.<br>&gt; Alternatively, this could be done in a lightweight manner where the feature is introduced and known &quot;pure-like&quot; functions are marked in swift-corelibs-foundation.<br>&gt; To be honest, I don&#39;t have much experience in languages that have this feature. I would imagine many people are interested in the notion of pure functions, but the question here is if it would be worth it, feasible, or even aligned with Swift&#39;s goals to have this feature. I&#39;m half-expecting that this has already been brought up and determined to be out of scope or not a good idea.<br>&gt; <br>&gt; Thanks for your consideration. Please let me know what you think.<br>&gt; <br>&gt; -- <br>&gt; Jimmy Sambuo<br>&gt; www.sambuo.com &lt;http://www.sambuo.com/&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/46f40af7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>On Mon, Dec 21, 2015 at 11:55 AM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; …there probably has to be some way to unsafely “force a call to a non-pure<br>&gt; function to be allowed in a pure one”, both because of type system<br>&gt; limitations as well as interoperability with C and other languages.  Even<br>&gt; ignoring issues around errno, it would be sad for a pure function to not be<br>&gt; able to call “sin(x)” just because it weren’t marked __attribute__((const)).<br>&gt;<br></p><p>Minor tangent, but should the same apply to @noescape? (Lack of this is why<br>I bothered with SE-0012<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0012-add-noescape-to-public-library-api.md&gt;<br>)<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/c786086a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 12:05 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Dec 21, 2015 at 11:55 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; …there probably has to be some way to unsafely “force a call to a non-pure function to be allowed in a pure one”, both because of type system limitations as well as interoperability with C and other languages.  Even ignoring issues around errno, it would be sad for a pure function to not be able to call “sin(x)” just because it weren’t marked __attribute__((const)).<br>&gt; <br>&gt; Minor tangent, but should the same apply to @noescape? <br></p><p>Yes, it should.  I believe you can currently use an unsafe cast to remove @noescape, and that the stdlib does it in a few places.  Dmitri, do you know where?<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/e700ecf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 1:49 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 12:05 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Mon, Dec 21, 2015 at 11:55 AM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; …there probably has to be some way to unsafely “force a call to a non-pure function to be allowed in a pure one”, both because of type system limitations as well as interoperability with C and other languages.  Even ignoring issues around errno, it would be sad for a pure function to not be able to call “sin(x)” just because it weren’t marked __attribute__((const)).<br>&gt;&gt; <br>&gt;&gt; Minor tangent, but should the same apply to @noescape? <br>&gt; <br>&gt; Yes, it should.  I believe you can currently use an unsafe cast to remove @noescape, and that the stdlib does it in a few places.  Dmitri, do you know where?<br></p><p>The runtime does this using unsafeBitCast, but don&#39;t follow its example—I don&#39;t want to promise this will always be possible. There are representation optimizations we can do with @noescape closures that would be blocked if they always had to be bitcastable to refcounted escapable closures. I&#39;d like to introduce a `Builtin.makeEscapable` operation specifically to go from @noescape to escapable, introducing a refcounting shim if necessary in the future.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/fd4a259b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/49e77a417c2ab608756778c4a75ee14f?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Alex Popov</string> &lt;hello at alexpopov.ca&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>Slight tangent, would a guarantee of purity also allow for more Tail-Call<br>Optimizations? A cursory glance at SO seems to point to TCO not always being<br>applied, especially when ARC is involved.<br></p><p>  <br></p><p>&lt;br  <br>—<br></p><p>Alex Popov Jr.<br></p><p>Principal iOS Developer | Shelfie<br></p><p>&gt; On Dec 21 2015, at 1:55 pm, Joe Groff via swift-evolution &amp;lt;swift-<br>evolution at swift.org&amp;gt; wrote:  <br>  <br></p><p>&gt;<br></p><p>&gt;&gt; On Dec 21, 2015, at 1:49 PM, Chris Lattner via swift-evolution &amp;lt;[swift-<br>evolution at swift.org](mailto:swift-evolution at swift.org)&amp;gt; wrote:<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt;&gt; On Dec 21, 2015, at 12:05 PM, Jacob Bandes-Storch<br>&amp;lt;[jtbandes at gmail.com](mailto:jtbandes at gmail.com)&amp;gt; wrote:<br></p><p>&gt;&gt;&gt;<br></p><p>&gt;&gt;&gt;  <br></p><p>&gt;&gt;&gt;<br></p><p>&gt;&gt;&gt; On Mon, Dec 21, 2015 at 11:55 AM, Chris Lattner via swift-evolution &amp;lt<br>;[swift-evolution at swift.org](mailto:swift-evolution at swift.org)&amp;gt; wrote:  <br></p><p>&gt;&gt;&gt;<br></p><p>&gt;&gt;&gt;&gt; …there probably has to be some way to unsafely “force a call to a non-<br>pure function to be allowed in a pure one”, both because of type system<br>limitations as well as interoperability with C and other languages.  Even<br>ignoring issues around errno, it would be sad for a pure function to not be<br>able to call “sin(x)” just because it weren’t marked __attribute__((const)).<br></p><p>&gt;&gt;&gt;<br></p><p>&gt;&gt;&gt;  <br></p><p>&gt;&gt;&gt;<br></p><p>&gt;&gt;&gt; Minor tangent, but should the same apply to @noescape?<br></p><p>&gt;&gt;<br></p><p>&gt;&gt;  <br></p><p>&gt;&gt;<br></p><p>&gt;&gt; Yes, it should.  I believe you can currently use an unsafe cast to remove<br>@noescape, and that the stdlib does it in a few places.  Dmitri, do you know<br>where?<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; The runtime does this using unsafeBitCast, but don&#39;t follow its example—I<br>don&#39;t want to promise this will always be possible. There are representation<br>optimizations we can do with @noescape closures that would be blocked if they<br>always had to be bitcastable to refcounted escapable closures. I&#39;d like to<br>introduce a `Builtin.makeEscapable` operation specifically to go from<br>@noescape to escapable, introducing a refcounting shim if necessary in the<br>future.<br></p><p>&gt;<br></p><p>&gt;  <br></p><p>&gt;<br></p><p>&gt; -Joe<br></p><p>&gt;<br></p><p>&gt; ![](https://u2002410.ct.sendgrid.net/wf/open?upn=CmwAv3oRa0AH4Hd1bWC6X-<br>2BzbhPqo1YEo6mPHEujr90vNqvSlNKW0iy2BTd4OxR0SCJAwyLx2cZ3twpk4M4WqgQG-<br>2FHUcfU2eLopRmdzTmpLuLZtOY1eD9WFERKSEU-2Fh8ZpSXZO8n-2FxFdugKSpD2tVIHo-<br>2B1Xm1Kx9Z6REnSigwhXQc1ZZ21GoUrVYCyW9mvlG9yTXA-2F8<br>-2BkRL3jMogyILA8zEwqIWg15KQWC24Bm6WqsLc-3D)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/276fa8be/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 2:04 PM, Alex Popov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Slight tangent, would a guarantee of purity also allow for more Tail-Call Optimizations? A cursory glance at SO seems to point to TCO not always being applied, especially when ARC is involved.<br></p><p><br>I don&#39;t think any reasonable meaning for `pure` in Swift would affect the possibility of TCO. There was another thread about TCO here you might read back on; as I explained there, ARC is not a barrier to TCO, our ownership and machine-level calling conventions are. We would need to be able to use a specific calling convention for guaranteed-TCOable entry points.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I started another thread on @pure in swift, luckily Chris Lattner reminded<br>me about this one. I&#39;m going to continue any discussion here so we don&#39;t<br>fragment the conversation.<br></p><p>The other thread was a pre-proposal discussion called &quot;Proposal proposal:<br>@pure keyword&quot;, it isn&#39;t archived so I cannot link it.<br></p><p>I&#39;ve summarised the progress so far here (it&#39;s in the proposals directory<br>for convenience):<br></p><p>https://github.com/therealbnut/swift/blob/therealbnut-pure-preproprosal/docs/proposals/PureKeyword.rst<br></p><p>If I&#39;ve missed anything or you want to update, clarify, fix typos, etc.<br>please submit a PR :) I&#39;m trying to keep it focused on things that have<br>little contention.<br></p><p>I&#39;ve tried to unify the ideas from both the other thread and this one into<br>that summary. As it&#39;s not really a proposal I haven&#39;t included the<br>excellent justifications that Jimmy initially stated, they can be added if<br>it becomes a proposal. Please add a PR if you would like them there.<br></p><p><br>On Tue, Dec 22, 2015 at 9:08 AM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 21, 2015, at 2:04 PM, Alex Popov via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Slight tangent, would a guarantee of purity also allow for more<br>&gt; Tail-Call Optimizations? A cursory glance at SO seems to point to TCO not<br>&gt; always being applied, especially when ARC is involved.<br>&gt;<br>&gt;<br>&gt; I don&#39;t think any reasonable meaning for `pure` in Swift would affect the<br>&gt; possibility of TCO. There was another thread about TCO here you might read<br>&gt; back on; as I explained there, ARC is not a barrier to TCO, our ownership<br>&gt; and machine-level calling conventions are. We would need to be able to use<br>&gt; a specific calling convention for guaranteed-TCOable entry points.<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/020caac4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/775f6d0d1d1207c0e78b2eaf4eb38e4c?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Jimmy Sambuo</string> &lt;jsambuo at gmail.com&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Thanks Andrew and everyone for your ideas and inputs.<br></p><p>Andrew, your summary is amazing. It covers so many non-trivial cases of<br>this feature.<br>I believe this is the archive of the other thread:<br>https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006005.html<br></p><p>I was hesitant to add more to this discussion because I was only able to<br>think of the trivial case, and I know this can have lots of hidden<br>complexities and implications. Looking at Andrew&#39;s summary gave me some<br>ideas for talking points. Specifically, the section with inout parameters<br>and pure mutating functions seems strange to me as I wasn&#39;t expecting<br>mutation to occur, but this may be a valid scenario for &quot;weakly pure&quot;<br>functions, where parameters can be modified.<br></p><p>Chris had mentioned that there probably should be some way to to unsafely<br>&quot;force a call to a non-pure function to be allowed in a pure one,&quot; and that it<br>would probably make sense as an attribute @pure instead of a declmodifier.<br>Perhaps this is another form of &quot;weakly pure&quot; functions. I&#39;m thinking in<br>this case, pure is acting as a marker, the type system does not have to<br>know about actual purity and an effects system would not have to be<br>implemented in this case. This should make implementation simpler and less<br>invasive to the existing type system.<br></p><p>Imagine if ! was used to call an impure function within a pure function:<br></p><p>```swift<br>/// Wrapper around C sin()<br>func sin(x: Double) @pure -&gt; Double {<br>    return sin(x)!<br>}<br>```<br></p><p>In my mind, seeing ! tells me something could be wrong there so pay closer<br>attention. I would think `sin` is a C function so Swift doesn&#39;t know it<br>should be pure, but sine is a math function so it should be safe. What<br>about for actually impure functions? Optionals and try! crashes when<br>expectations are not met. Should `potentiallyImpureFunc()!` or<br>`mostlyPureFunc()!` crash if an &quot;impure&quot; value or side effect occurs? How<br>would the runtime know this if purity is defined by annotations? Maybe it<br>shouldn&#39;t crash, but now ! is slightly different from optionals and try!.<br>Perhaps there should be a different symbol for &quot;unwrapping&quot; impure<br>functions. Then there would be two different symbols for unwrapping.<br></p><p>My major concern is I&#39;d want to avoid a situation where developers are<br>adding @pure and unwrapping impure functions just to make their app<br>compile, making @pure meaningless since most of their pure functions will<br>actually be impure. I&#39;m not sure of a good way to prevent this.<br></p><p><br>On Sun, Jan 10, 2016 at 12:41 AM, Andrew Bennett via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi,<br>&gt;<br>&gt; I started another thread on @pure in swift, luckily Chris Lattner reminded<br>&gt; me about this one. I&#39;m going to continue any discussion here so we don&#39;t<br>&gt; fragment the conversation.<br>&gt;<br>&gt; The other thread was a pre-proposal discussion called &quot;Proposal proposal:<br>&gt; @pure keyword&quot;, it isn&#39;t archived so I cannot link it.<br>&gt;<br>&gt; I&#39;ve summarised the progress so far here (it&#39;s in the proposals directory<br>&gt; for convenience):<br>&gt;<br>&gt;<br>&gt; https://github.com/therealbnut/swift/blob/therealbnut-pure-preproprosal/docs/proposals/PureKeyword.rst<br>&gt;<br>&gt; If I&#39;ve missed anything or you want to update, clarify, fix typos, etc.<br>&gt; please submit a PR :) I&#39;m trying to keep it focused on things that have<br>&gt; little contention.<br>&gt;<br>&gt; I&#39;ve tried to unify the ideas from both the other thread and this one into<br>&gt; that summary. As it&#39;s not really a proposal I haven&#39;t included the<br>&gt; excellent justifications that Jimmy initially stated, they can be added if<br>&gt; it becomes a proposal. Please add a PR if you would like them there.<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 22, 2015 at 9:08 AM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 21, 2015, at 2:04 PM, Alex Popov via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Slight tangent, would a guarantee of purity also allow for more<br>&gt;&gt; Tail-Call Optimizations? A cursory glance at SO seems to point to TCO not<br>&gt;&gt; always being applied, especially when ARC is involved.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think any reasonable meaning for `pure` in Swift would affect the<br>&gt;&gt; possibility of TCO. There was another thread about TCO here you might read<br>&gt;&gt; back on; as I explained there, ARC is not a barrier to TCO, our ownership<br>&gt;&gt; and machine-level calling conventions are. We would need to be able to use<br>&gt;&gt; a specific calling convention for guaranteed-TCOable entry points.<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p><p><br>-- <br>Jimmy Sambuo<br>www.sambuo.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/39e194c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>January 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I am very much in support to of a @pure decorator. It could unlock a new level of performance for Swift and make everything safer. <br></p><p>For the issue of essentially pure functions that cannot be statically validated as pure (due to calling external code etc, as described by many in this thread), I think that one way to solve it would be to use a decorator along the lines of @pure(unsafe). This decorator would mean that the compiler should treat this function as pure, ‘trusting’ the programmer.<br></p><p>- T. <br></p><p>&gt; On 10 Jan 2016, at 22:27, Jimmy Sambuo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Thanks Andrew and everyone for your ideas and inputs.<br>&gt; <br>&gt; Andrew, your summary is amazing. It covers so many non-trivial cases of this feature.<br>&gt; I believe this is the archive of the other thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006005.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006005.html&gt;<br>&gt; <br>&gt; I was hesitant to add more to this discussion because I was only able to think of the trivial case, and I know this can have lots of hidden complexities and implications. Looking at Andrew&#39;s summary gave me some ideas for talking points. Specifically, the section with inout parameters and pure mutating functions seems strange to me as I wasn&#39;t expecting mutation to occur, but this may be a valid scenario for &quot;weakly pure&quot; functions, where parameters can be modified.<br>&gt; <br>&gt; Chris had mentioned that there probably should be some way to to unsafely &quot;force a call to a non-pure function to be allowed in a pure one,&quot; and that it would probably make sense as an attribute @pure instead of a declmodifier. Perhaps this is another form of &quot;weakly pure&quot; functions. I&#39;m thinking in this case, pure is acting as a marker, the type system does not have to know about actual purity and an effects system would not have to be implemented in this case. This should make implementation simpler and less invasive to the existing type system.<br>&gt; <br>&gt; Imagine if ! was used to call an impure function within a pure function:<br>&gt; <br>&gt; ```swift<br>&gt; /// Wrapper around C sin()<br>&gt; func sin(x: Double) @pure -&gt; Double {<br>&gt;     return sin(x)!<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; In my mind, seeing ! tells me something could be wrong there so pay closer attention. I would think `sin` is a C function so Swift doesn&#39;t know it should be pure, but sine is a math function so it should be safe. What about for actually impure functions? Optionals and try! crashes when expectations are not met. Should `potentiallyImpureFunc()!` or `mostlyPureFunc()!` crash if an &quot;impure&quot; value or side effect occurs? How would the runtime know this if purity is defined by annotations? Maybe it shouldn&#39;t crash, but now ! is slightly different from optionals and try!. Perhaps there should be a different symbol for &quot;unwrapping&quot; impure functions. Then there would be two different symbols for unwrapping.<br>&gt; <br>&gt; My major concern is I&#39;d want to avoid a situation where developers are adding @pure and unwrapping impure functions just to make their app compile, making @pure meaningless since most of their pure functions will actually be impure. I&#39;m not sure of a good way to prevent this.<br>&gt; <br>&gt; <br>&gt; On Sun, Jan 10, 2016 at 12:41 AM, Andrew Bennett via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; Hi,<br>&gt; <br>&gt; I started another thread on @pure in swift, luckily Chris Lattner reminded me about this one. I&#39;m going to continue any discussion here so we don&#39;t fragment the conversation.<br>&gt; <br>&gt; The other thread was a pre-proposal discussion called &quot;Proposal proposal: @pure keyword&quot;, it isn&#39;t archived so I cannot link it.<br>&gt; <br>&gt; I&#39;ve summarised the progress so far here (it&#39;s in the proposals directory for convenience):<br>&gt; <br>&gt; https://github.com/therealbnut/swift/blob/therealbnut-pure-preproprosal/docs/proposals/PureKeyword.rst &lt;https://github.com/therealbnut/swift/blob/therealbnut-pure-preproprosal/docs/proposals/PureKeyword.rst&gt;<br>&gt; <br>&gt; If I&#39;ve missed anything or you want to update, clarify, fix typos, etc. please submit a PR :) I&#39;m trying to keep it focused on things that have little contention.<br>&gt; <br>&gt; I&#39;ve tried to unify the ideas from both the other thread and this one into that summary. As it&#39;s not really a proposal I haven&#39;t included the excellent justifications that Jimmy initially stated, they can be added if it becomes a proposal. Please add a PR if you would like them there.<br>&gt; <br>&gt; <br>&gt; On Tue, Dec 22, 2015 at 9:08 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 21, 2015, at 2:04 PM, Alex Popov via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Slight tangent, would a guarantee of purity also allow for more Tail-Call Optimizations? A cursory glance at SO seems to point to TCO not always being applied, especially when ARC is involved.<br>&gt; <br>&gt; <br>&gt; I don&#39;t think any reasonable meaning for `pure` in Swift would affect the possibility of TCO. There was another thread about TCO here you might read back on; as I explained there, ARC is not a barrier to TCO, our ownership and machine-level calling conventions are. We would need to be able to use a specific calling convention for guaranteed-TCOable entry points.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Jimmy Sambuo<br>&gt; www.sambuo.com &lt;http://www.sambuo.com/&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/b7440247/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4027ca32415d9fecd483292ef8f98b02?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Andrew Bennett</string> &lt;cacoyi at gmail.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Jimmy,<br></p><p>Interesting ideas with !, although I&#39;m worried it would clash with other<br>uses of the operator. For example: optional return types. There&#39;s probably<br>more precedent for this syntax: sin!(x), but it will also clash in some<br>cases (optional function in objc protocol, optional closure).<br></p><p>I think something much more verbose (a function) would be fine as it&#39;s<br>probably not going to be called often. I expect initially it&#39;s probably<br>sufficient for it to be a Builtin function only used in the standard<br>library. Failing that a global clearly unsafe function:<br>unsafelyPurifyFunction(...).<br></p><p>With inout I don&#39;t think it is actually weaker, I could be wrong. I see the<br>following as equivalent (from a purity standpoint):<br></p><p>func test1(inout a: Int) @pure -&gt; Double {}<br>x = test1(&amp;a)<br></p><p>func test2(a: Int) @pure -&gt; (Double, Int) {}<br>(x, a) = test2(a)<br></p><p><br>If they&#39;re equivalent then this can be pure:<br></p><p>extension Int {<br></p><p>mutating func addSome(x: Int) @pure {<br></p><p>self += x<br></p><p>}<br></p><p>}<br></p><p>let x: (inout Int, Int) @pure -&gt; Void = Int.addOne<br></p><p><br>However the curried function signature must be adjusted so it cannot be<br>partially applied, previously it would have been this:<br></p><p>let x: (inout Int) -&gt; (Int) -&gt; Void = Int.addOne<br></p><p><br>If we&#39;re happy with this equivalence, I don&#39;t think it&#39;s a useful to<br>distinguish inout and other pure functions (no need for @pure(unsafe)<br>here). As long as the parameters predictably cover everything affected I am<br>happy.<br></p><p>Reference types may be an issue here, but no more than elsewhere.<br></p><p>----<br></p><p>As far as weak-pure goes: I think references have a lot of issues with<br>@pure. It may be necessary to know if any types a @pure function uses<br>interact at all with a reference type, stores it, uses it to compute, etc.<br></p><p>A gotcha example:<br></p><p>AnySequence uses a class internally (dynamic dispatch for type erasure), a<br>pure function may want to return AnySequence, which appears to be a value<br>type. See ExistentialCollection.swift.gyb.<br></p><p>The compiler may not be able to ensure two sequences with the same input<br>are equivalent because their internal class has a different reference.<br>Equitable could definitely work, but at compile time?<br></p><p>This is going to be a problem for referential transparency.<br></p><p>Possible Solutions<br> 1) Reference types or types composed of reference types are initially<br>unavailable to @pure functions, unless locally scoped.<br> 2) Relax the referential transparency requirement when the output is a<br>reference type or composed of reference types.<br> 3) Add a @copy keyword for types, this would mean it can be safely use<br>copy-on-write with no shared references. I think this would be useful in<br>other cases too, but should be avoided if possible as it&#39;s a large change<br>that would require other proposal(s).<br></p><p>Not entirely a solution, but interesting:<br></p><p>You cannot return a newly allocated reference type, but you can return a<br>closure: () -&gt; ReferenceType<br></p><p>It can still use memoization to always return the same closure, avoid any<br>computation to derive the closure, but the closure doesn&#39;t necessarily<br>return the same reference.<br></p><p><br></p><p>On Mon, Jan 11, 2016 at 8:27 AM, Jimmy Sambuo &lt;jsambuo at gmail.com&gt; wrote:<br></p><p>&gt; Thanks Andrew and everyone for your ideas and inputs.<br>&gt;<br>&gt; Andrew, your summary is amazing. It covers so many non-trivial cases of<br>&gt; this feature.<br>&gt; I believe this is the archive of the other thread:<br>&gt; https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160104/006005.html<br>&gt;<br>&gt; I was hesitant to add more to this discussion because I was only able to<br>&gt; think of the trivial case, and I know this can have lots of hidden<br>&gt; complexities and implications. Looking at Andrew&#39;s summary gave me some<br>&gt; ideas for talking points. Specifically, the section with inout parameters<br>&gt; and pure mutating functions seems strange to me as I wasn&#39;t expecting<br>&gt; mutation to occur, but this may be a valid scenario for &quot;weakly pure&quot;<br>&gt; functions, where parameters can be modified.<br>&gt;<br>&gt; Chris had mentioned that there probably should be some way to to unsafely<br>&gt; &quot;force a call to a non-pure function to be allowed in a pure one,&quot; and that it<br>&gt; would probably make sense as an attribute @pure instead of a declmodifier.<br>&gt; Perhaps this is another form of &quot;weakly pure&quot; functions. I&#39;m thinking in<br>&gt; this case, pure is acting as a marker, the type system does not have to<br>&gt; know about actual purity and an effects system would not have to be<br>&gt; implemented in this case. This should make implementation simpler and less<br>&gt; invasive to the existing type system.<br>&gt;<br>&gt; Imagine if ! was used to call an impure function within a pure function:<br>&gt;<br>&gt; ```swift<br>&gt; /// Wrapper around C sin()<br>&gt; func sin(x: Double) @pure -&gt; Double {<br>&gt;     return sin(x)!<br>&gt; }<br>&gt; ```<br>&gt;<br>&gt; In my mind, seeing ! tells me something could be wrong there so pay closer<br>&gt; attention. I would think `sin` is a C function so Swift doesn&#39;t know it<br>&gt; should be pure, but sine is a math function so it should be safe. What<br>&gt; about for actually impure functions? Optionals and try! crashes when<br>&gt; expectations are not met. Should `potentiallyImpureFunc()!` or<br>&gt; `mostlyPureFunc()!` crash if an &quot;impure&quot; value or side effect occurs? How<br>&gt; would the runtime know this if purity is defined by annotations? Maybe it<br>&gt; shouldn&#39;t crash, but now ! is slightly different from optionals and try!.<br>&gt; Perhaps there should be a different symbol for &quot;unwrapping&quot; impure<br>&gt; functions. Then there would be two different symbols for unwrapping.<br>&gt;<br>&gt; My major concern is I&#39;d want to avoid a situation where developers are<br>&gt; adding @pure and unwrapping impure functions just to make their app<br>&gt; compile, making @pure meaningless since most of their pure functions will<br>&gt; actually be impure. I&#39;m not sure of a good way to prevent this.<br>&gt;<br>&gt;<br>&gt; On Sun, Jan 10, 2016 at 12:41 AM, Andrew Bennett via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi,<br>&gt;&gt;<br>&gt;&gt; I started another thread on @pure in swift, luckily Chris Lattner<br>&gt;&gt; reminded me about this one. I&#39;m going to continue any discussion here so we<br>&gt;&gt; don&#39;t fragment the conversation.<br>&gt;&gt;<br>&gt;&gt; The other thread was a pre-proposal discussion called &quot;Proposal proposal:<br>&gt;&gt; @pure keyword&quot;, it isn&#39;t archived so I cannot link it.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve summarised the progress so far here (it&#39;s in the proposals directory<br>&gt;&gt; for convenience):<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/therealbnut/swift/blob/therealbnut-pure-preproprosal/docs/proposals/PureKeyword.rst<br>&gt;&gt;<br>&gt;&gt; If I&#39;ve missed anything or you want to update, clarify, fix typos, etc.<br>&gt;&gt; please submit a PR :) I&#39;m trying to keep it focused on things that have<br>&gt;&gt; little contention.<br>&gt;&gt;<br>&gt;&gt; I&#39;ve tried to unify the ideas from both the other thread and this one<br>&gt;&gt; into that summary. As it&#39;s not really a proposal I haven&#39;t included the<br>&gt;&gt; excellent justifications that Jimmy initially stated, they can be added if<br>&gt;&gt; it becomes a proposal. Please add a PR if you would like them there.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, Dec 22, 2015 at 9:08 AM, Joe Groff via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &gt; On Dec 21, 2015, at 2:04 PM, Alex Popov via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Slight tangent, would a guarantee of purity also allow for more<br>&gt;&gt;&gt; Tail-Call Optimizations? A cursory glance at SO seems to point to TCO not<br>&gt;&gt;&gt; always being applied, especially when ARC is involved.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think any reasonable meaning for `pure` in Swift would affect<br>&gt;&gt;&gt; the possibility of TCO. There was another thread about TCO here you might<br>&gt;&gt;&gt; read back on; as I explained there, ARC is not a barrier to TCO, our<br>&gt;&gt;&gt; ownership and machine-level calling conventions are. We would need to be<br>&gt;&gt;&gt; able to use a specific calling convention for guaranteed-TCOable entry<br>&gt;&gt;&gt; points.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; Jimmy Sambuo<br>&gt; www.sambuo.com<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160111/b3c7bb36/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>December 21, 2015 at 03:00:00pm</p></header><div class="content"><p>I have been thinking about this proposal since the list opened up.  I think<br>that @read(none|only) should be considered as an alternative. Just as in<br>clang and the optimizer annotations @read(none) would be the attribute<br>described and @read(only) could read global variables but could not write.<br>Is it possible to generate a runtime error if we guarantee that function A<br>is pure, only to call it and &#39;find out&#39; that it isn&#39;t? If we can, then do<br>try syntax could be considered.<br></p><p>On Mon, Dec 21, 2015 at 2:55 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On Dec 19, 2015, at 9:00 PM, Jimmy Sambuo via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; My proposal is to add a `pure` keyword/attribute to Swift.<br>&gt;<br>&gt; I’m a fan of this in concept, and the mechanics for this feature would<br>&gt; probably allow us to have safe “computed lets” as well.  My one concern<br>&gt; about this is that there probably has to be some way to unsafely “force a<br>&gt; call to a non-pure function to be allowed in a pure one”, both because of<br>&gt; type system limitations as well as interoperability with C and other<br>&gt; languages.  Even ignoring issues around errno, it would be sad for a pure<br>&gt; function to not be able to call “sin(x)” just because it weren’t marked<br>&gt; __attribute__((const)).<br>&gt;<br>&gt; A proposal in this area should consider how “pure” would interact with the<br>&gt; type system, and it would probably make sense as an attribute @pure instead<br>&gt; of a declmodifier.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; Similar to throws, you would mark a function as pure to say it will not<br>&gt; cause any observable side-effects and hold referential transparency:<br>&gt;<br>&gt; ```swift<br>&gt;<br>&gt; func pure add(x: Int, y: Int) -&gt; Int {<br>&gt;<br>&gt;     return x + y<br>&gt;<br>&gt; }<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; By adding this attribute, the function is guaranteed to have some<br>&gt; properties:<br>&gt;<br>&gt;    1. The function must have a return value<br>&gt;    2. This function can only call other pure functions<br>&gt;    3. This function cannot access/modify global or static variables.<br>&gt;<br>&gt; ```swift<br>&gt;<br>&gt; func pure getDate() -&gt; NSDate {<br>&gt;<br>&gt;     return NSDate.date() // Error: pure function &#39;getDate&#39; cannot call<br>&gt; impure function &#39;date&#39;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; ```<br>&gt;<br>&gt; This would be similar to the pure keyword in D (<br>&gt; https://dlang.org/spec/function.html#pure-functions) or the noSideEffect<br>&gt; pragma in Nim (<br>&gt; http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma).<br>&gt;<br>&gt; My motivation for this is that I want to create applications that follow a<br>&gt; &quot;Functional Core, Imperative Shell&quot; style [Gary Bernhardt]. By marking all<br>&gt; of my functions within the functional core as pure, the compiler can help<br>&gt; me if I accidentally start writing impure functions. In theory, this should<br>&gt; make my application simpler and more testable. Reviewing pull requests will<br>&gt; also be simpler since in the functional portion of my codebase, checking<br>&gt; for pure can be a criteria. Ideally, I&#39;d run a static analyzer to see that<br>&gt; I have more pure functions than impure ones, which should help me control<br>&gt; complexity by encouraging me to have a larger &quot;value&quot; layer and smaller<br>&gt; &quot;object&quot; layer [Andy Matuschak].<br>&gt;<br>&gt; Logically, I think of this as Swift having all functions return<br>&gt; &quot;Implicitly Impure Values&quot; (similar to how every object from objective-c is<br>&gt; an implicitly unwrapped optional). All existing Swift functions are<br>&gt; actually returning a IO&lt;SomeType&gt;, and functions using that are implicitly<br>&gt; unwrapping them. Swift can be super nice by hiding this fact, making the<br>&gt; language much more familiar and accessible to developers not used to<br>&gt; purity. Adding `pure` allows devs to tap into the compiler&#39;s power and<br>&gt; prevent unwanted side-effects without directly exposing the IO type.<br>&gt;<br>&gt; The benefits I see are:<br>&gt;<br>&gt;    - Explicit intentions - This allows design decisions to be<br>&gt;    communicated clearly to other developers and maintainers, as well as the<br>&gt;    compiler and other static analysis tools.<br>&gt;    - Compile-time guarantee - The compiler can help prevent unintentional<br>&gt;    state modifications.<br>&gt;    - Encouragement of better state management practices - More people<br>&gt;    will be aware of the concept of functional purity and may try to design<br>&gt;    their code to have more pure functions, which should make more code simpler<br>&gt;    and testable. This isn&#39;t a guarantee it will happen, but more people should<br>&gt;    understand it if it brings concrete results instead of just being an<br>&gt;    abstract concept.<br>&gt;    - Reduced cognitive load when understanding code - More pure functions<br>&gt;    should make it easier to reason about code.<br>&gt;    - Opt-in to purity - Swift will be just as accessible to new<br>&gt;    developers, but experienced developers will be able to take advantage of<br>&gt;    this.<br>&gt;    - Backwards compatible (mostly) - Existing codebases should still<br>&gt;    compile without any change (unless pure was used as a variable/method/class<br>&gt;    name).<br>&gt;<br>&gt; Of course, there are risks of this feature. Some of the risks include:<br>&gt;<br>&gt;    - This could make the language more difficult to work with. Developers<br>&gt;    maintaining an existing codebase with lots of pure function may become<br>&gt;    confused or frustrated when they realize they cannot do easy things such as<br>&gt;    logging within the method.<br>&gt;       - A counterargument to this may be that when Swift was introduced,<br>&gt;       optionals also made the language difficult to use. People implicitly<br>&gt;       unwrapped them just so things will compile, or returned them from methods<br>&gt;       without much consideration to what that implies. Nevertheless, this made<br>&gt;       Swift a safer language to use by explicitly when nil is a possible value.<br>&gt;       Developers are more conscious about nil being a potential value. Similarly,<br>&gt;       I think developers should be more aware about side-effect causing<br>&gt;       functions. Being clear about this and separating these concerns should<br>&gt;       bring about more safer and testable Swift applications.<br>&gt;    - Implementation of this feature could be difficult. Swift can<br>&gt;    implement it in several different ways depending on the desired result of<br>&gt;    this feature, such as having stronger or weaker purity guarantees to make<br>&gt;    the feature easier to use or simpler to implement. An effect system may<br>&gt;    have to be created.<br>&gt;       - Alternatively, this could be done in a lightweight manner where<br>&gt;       the feature is introduced and known &quot;pure-like&quot; functions are marked<br>&gt;       in swift-corelibs-foundation.<br>&gt;<br>&gt; To be honest, I don&#39;t have much experience in languages that have this<br>&gt; feature. I would imagine many people are interested in the notion of pure<br>&gt; functions, but the question here is if it would be worth it, feasible, or<br>&gt; even aligned with Swift&#39;s goals to have this feature. I&#39;m half-expecting<br>&gt; that this has already been brought up and determined to be out of scope or<br>&gt; not a good idea.<br>&gt;<br>&gt; Thanks for your consideration. Please let me know what you think.<br>&gt; --<br>&gt; Jimmy Sambuo<br>&gt; www.sambuo.com<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/c6e463f3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 12:20 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I have been thinking about this proposal since the list opened up.  I think that @read(none|only) should be considered as an alternative. Just as in clang and the optimizer annotations @read(none) would be the attribute described and @read(only) could read global variables but could not write. Is it possible to generate a runtime error if we guarantee that function A is pure, only to call it and &#39;find out&#39; that it isn&#39;t? If we can, then do try syntax could be considered. <br></p><p>Another approach here is an effects system. If a pure function were spelled `(T) =&gt; U`, then `readonly` could be expressed as `(T) reads =&gt; U`, and (T) -&gt; U could remain as a synonym for (T) reads, writes =&gt; U, in the spirit of encouraging immutability without punishing mutability.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/38168ef0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>December 22, 2015 at 08:00:00am</p></header><div class="content"><p>-1 for using -&gt; and =&gt; to mean different types of functions, not-pure and pure respectively. In fact I dislike using symbols unless they are really well known. Keywords read a lot better. <br></p><p>Sent from my iPad<br></p><p>&gt; On 22 Dec 2015, at 8:37 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 21, 2015, at 12:20 PM, T.J. Usiyan via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I have been thinking about this proposal since the list opened up.  I think that @read(none|only) should be considered as an alternative. Just as in clang and the optimizer annotations @read(none) would be the attribute described and @read(only) could read global variables but could not write. Is it possible to generate a runtime error if we guarantee that function A is pure, only to call it and &#39;find out&#39; that it isn&#39;t? If we can, then do try syntax could be considered. <br>&gt; <br>&gt; Another approach here is an effects system. If a pure function were spelled `(T) =&gt; U`, then `readonly` could be expressed as `(T) reads =&gt; U`, and (T) -&gt; U could remain as a synonym for (T) reads, writes =&gt; U, in the spirit of encouraging immutability without punishing mutability.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151222/1e5f3eeb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 21, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 21, 2015, at 12:20 PM, T.J. Usiyan &lt;griotspeak at gmail.com&gt; wrote:<br>&gt; <br>&gt; I have been thinking about this proposal since the list opened up.  I think that @read(none|only) should be considered as an alternative. Just as in clang and the optimizer annotations @read(none) would be the attribute described and @read(only) could read global variables but could not write. Is it possible to generate a runtime error if we guarantee that function A is pure, only to call it and &#39;find out&#39; that it isn&#39;t? If we can, then do try syntax could be considered. <br></p><p>Yes, this is worth considering, but it would be nice to avoid this if possible.  There are two interesting related-but-different problems that could be tackled here:<br></p><p>1. Optimization hints:  These would align to llvm’s readnone/readonly attributes (const/pure in GCC nomenclature).<br>2. Expanding the existing ‘let’ language model from properties to functions: this would allow computed lets.<br></p><p>I’m personally more interested in making #2 happen.  It is the attribute that (like noescape) would need to permeate the type system.<br></p><p>#1 could be interesting, but it could also be a different thing that is an attribute of a declaration, not an attribute of the declaration’s type.  LLVM also supports a number of other interesting attributes that can be useful to expose someday in Swift, but I’m not keen to do that unless there is a very strong and specific need to do so:<br>http://llvm.org/docs/LangRef.html#id671<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; On Mon, Dec 21, 2015 at 2:55 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; On Dec 19, 2015, at 9:00 PM, Jimmy Sambuo via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; My proposal is to add a `pure` keyword/attribute to Swift.<br>&gt;&gt; <br>&gt; <br>&gt; I’m a fan of this in concept, and the mechanics for this feature would probably allow us to have safe “computed lets” as well.  My one concern about this is that there probably has to be some way to unsafely “force a call to a non-pure function to be allowed in a pure one”, both because of type system limitations as well as interoperability with C and other languages.  Even ignoring issues around errno, it would be sad for a pure function to not be able to call “sin(x)” just because it weren’t marked __attribute__((const)).<br>&gt; <br>&gt; A proposal in this area should consider how “pure” would interact with the type system, and it would probably make sense as an attribute @pure instead of a declmodifier.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; Similar to throws, you would mark a function as pure to say it will not cause any observable side-effects and hold referential transparency:<br>&gt;&gt; <br>&gt;&gt; ```swift<br>&gt;&gt; <br>&gt;&gt; func pure add(x: Int, y: Int) -&gt; Int {<br>&gt;&gt; <br>&gt;&gt;     return x + y<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; By adding this attribute, the function is guaranteed to have some properties:<br>&gt;&gt; <br>&gt;&gt; The function must have a return value<br>&gt;&gt; This function can only call other pure functions<br>&gt;&gt; This function cannot access/modify global or static variables.<br>&gt;&gt; ```swift<br>&gt;&gt; <br>&gt;&gt; func pure getDate() -&gt; NSDate {<br>&gt;&gt; <br>&gt;&gt;     return NSDate.date() // Error: pure function &#39;getDate&#39; cannot call impure function &#39;date&#39; <br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; ```<br>&gt;&gt; <br>&gt;&gt; This would be similar to the pure keyword in D (https://dlang.org/spec/function.html#pure-functions &lt;https://dlang.org/spec/function.html#pure-functions&gt;) or the noSideEffect pragma in Nim (http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma &lt;http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma&gt;).<br>&gt;&gt; <br>&gt;&gt; My motivation for this is that I want to create applications that follow a &quot;Functional Core, Imperative Shell&quot; style [Gary Bernhardt]. By marking all of my functions within the functional core as pure, the compiler can help me if I accidentally start writing impure functions. In theory, this should make my application simpler and more testable. Reviewing pull requests will also be simpler since in the functional portion of my codebase, checking for pure can be a criteria. Ideally, I&#39;d run a static analyzer to see that I have more pure functions than impure ones, which should help me control complexity by encouraging me to have a larger &quot;value&quot; layer and smaller &quot;object&quot; layer [Andy Matuschak].<br>&gt;&gt; <br>&gt;&gt; Logically, I think of this as Swift having all functions return &quot;Implicitly Impure Values&quot; (similar to how every object from objective-c is an implicitly unwrapped optional). All existing Swift functions are actually returning a IO&lt;SomeType&gt;, and functions using that are implicitly unwrapping them. Swift can be super nice by hiding this fact, making the language much more familiar and accessible to developers not used to purity. Adding `pure` allows devs to tap into the compiler&#39;s power and prevent unwanted side-effects without directly exposing the IO type.<br>&gt;&gt; <br>&gt;&gt; The benefits I see are:<br>&gt;&gt; <br>&gt;&gt; Explicit intentions - This allows design decisions to be communicated clearly to other developers and maintainers, as well as the compiler and other static analysis tools.<br>&gt;&gt; Compile-time guarantee - The compiler can help prevent unintentional state modifications. <br>&gt;&gt; Encouragement of better state management practices - More people will be aware of the concept of functional purity and may try to design their code to have more pure functions, which should make more code simpler and testable. This isn&#39;t a guarantee it will happen, but more people should understand it if it brings concrete results instead of just being an abstract concept.<br>&gt;&gt; Reduced cognitive load when understanding code - More pure functions should make it easier to reason about code. <br>&gt;&gt; Opt-in to purity - Swift will be just as accessible to new developers, but experienced developers will be able to take advantage of this.<br>&gt;&gt; Backwards compatible (mostly) - Existing codebases should still compile without any change (unless pure was used as a variable/method/class name).<br>&gt;&gt; Of course, there are risks of this feature. Some of the risks include:<br>&gt;&gt; <br>&gt;&gt; This could make the language more difficult to work with. Developers maintaining an existing codebase with lots of pure function may become confused or frustrated when they realize they cannot do easy things such as logging within the method.<br>&gt;&gt; A counterargument to this may be that when Swift was introduced, optionals also made the language difficult to use. People implicitly unwrapped them just so things will compile, or returned them from methods without much consideration to what that implies. Nevertheless, this made Swift a safer language to use by explicitly when nil is a possible value. Developers are more conscious about nil being a potential value. Similarly, I think developers should be more aware about side-effect causing functions. Being clear about this and separating these concerns should bring about more safer and testable Swift applications.<br>&gt;&gt; Implementation of this feature could be difficult. Swift can implement it in several different ways depending on the desired result of this feature, such as having stronger or weaker purity guarantees to make the feature easier to use or simpler to implement. An effect system may have to be created.<br>&gt;&gt; Alternatively, this could be done in a lightweight manner where the feature is introduced and known &quot;pure-like&quot; functions are marked in swift-corelibs-foundation.<br>&gt;&gt; To be honest, I don&#39;t have much experience in languages that have this feature. I would imagine many people are interested in the notion of pure functions, but the question here is if it would be worth it, feasible, or even aligned with Swift&#39;s goals to have this feature. I&#39;m half-expecting that this has already been brought up and determined to be out of scope or not a good idea.<br>&gt;&gt; <br>&gt;&gt; Thanks for your consideration. Please let me know what you think.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Jimmy Sambuo<br>&gt;&gt; www.sambuo.com &lt;http://www.sambuo.com/&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/0a1617cd/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/47e3aeeaf151d4f51ee15fc7871bf584?s=50"></div><header><strong>[Proposal idea] Support for pure functions</strong> from <string>Rudolf Adamkovič</string> &lt;salutis at me.com&gt;<p>February 20, 2016 at 11:00:00am</p></header><div class="content"><p>+1<br></p><p>In my framework, I have a set of closures with memoized inputs. These are supplied by the user. Right now, all I can do is to document that all supplied closures need to be 100% pure.<br></p><p>R+<br></p><p>&gt; On 20 Dec 2015, at 06:00, Jimmy Sambuo via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Swift-Evolution,<br>&gt; <br>&gt; I&#39;ve been playing around with an idea, and I wanted to see what you think about it.<br>&gt; <br>&gt; My proposal is to add a `pure` keyword/attribute to Swift.<br>&gt; <br>&gt; Similar to throws, you would mark a function as pure to say it will not cause any observable side-effects and hold referential transparency:<br>&gt; <br>&gt; ```swift<br>&gt; <br>&gt; func pure add(x: Int, y: Int) -&gt; Int {<br>&gt; <br>&gt;     return x + y<br>&gt; <br>&gt; }<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; By adding this attribute, the function is guaranteed to have some properties:<br>&gt; <br>&gt; The function must have a return value<br>&gt; This function can only call other pure functions<br>&gt; This function cannot access/modify global or static variables.<br>&gt; ```swift<br>&gt; <br>&gt; func pure getDate() -&gt; NSDate {<br>&gt; <br>&gt;     return NSDate.date() // Error: pure function &#39;getDate&#39; cannot call impure function &#39;date&#39; <br>&gt; <br>&gt; }<br>&gt; <br>&gt; ```<br>&gt; <br>&gt; This would be similar to the pure keyword in D (https://dlang.org/spec/function.html#pure-functions &lt;https://dlang.org/spec/function.html#pure-functions&gt;) or the noSideEffect pragma in Nim (http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma &lt;http://nim-lang.org/docs/manual.html#pragmas-nosideeffect-pragma&gt;).<br>&gt; <br>&gt; My motivation for this is that I want to create applications that follow a &quot;Functional Core, Imperative Shell&quot; style [Gary Bernhardt]. By marking all of my functions within the functional core as pure, the compiler can help me if I accidentally start writing impure functions. In theory, this should make my application simpler and more testable. Reviewing pull requests will also be simpler since in the functional portion of my codebase, checking for pure can be a criteria. Ideally, I&#39;d run a static analyzer to see that I have more pure functions than impure ones, which should help me control complexity by encouraging me to have a larger &quot;value&quot; layer and smaller &quot;object&quot; layer [Andy Matuschak].<br>&gt; <br>&gt; Logically, I think of this as Swift having all functions return &quot;Implicitly Impure Values&quot; (similar to how every object from objective-c is an implicitly unwrapped optional). All existing Swift functions are actually returning a IO&lt;SomeType&gt;, and functions using that are implicitly unwrapping them. Swift can be super nice by hiding this fact, making the language much more familiar and accessible to developers not used to purity. Adding `pure` allows devs to tap into the compiler&#39;s power and prevent unwanted side-effects without directly exposing the IO type.<br>&gt; <br>&gt; The benefits I see are:<br>&gt; <br>&gt; Explicit intentions - This allows design decisions to be communicated clearly to other developers and maintainers, as well as the compiler and other static analysis tools.<br>&gt; Compile-time guarantee - The compiler can help prevent unintentional state modifications. <br>&gt; Encouragement of better state management practices - More people will be aware of the concept of functional purity and may try to design their code to have more pure functions, which should make more code simpler and testable. This isn&#39;t a guarantee it will happen, but more people should understand it if it brings concrete results instead of just being an abstract concept.<br>&gt; Reduced cognitive load when understanding code - More pure functions should make it easier to reason about code. <br>&gt; Opt-in to purity - Swift will be just as accessible to new developers, but experienced developers will be able to take advantage of this.<br>&gt; Backwards compatible (mostly) - Existing codebases should still compile without any change (unless pure was used as a variable/method/class name).<br>&gt; Of course, there are risks of this feature. Some of the risks include:<br>&gt; <br>&gt; This could make the language more difficult to work with. Developers maintaining an existing codebase with lots of pure function may become confused or frustrated when they realize they cannot do easy things such as logging within the method.<br>&gt; A counterargument to this may be that when Swift was introduced, optionals also made the language difficult to use. People implicitly unwrapped them just so things will compile, or returned them from methods without much consideration to what that implies. Nevertheless, this made Swift a safer language to use by explicitly when nil is a possible value. Developers are more conscious about nil being a potential value. Similarly, I think developers should be more aware about side-effect causing functions. Being clear about this and separating these concerns should bring about more safer and testable Swift applications.<br>&gt; Implementation of this feature could be difficult. Swift can implement it in several different ways depending on the desired result of this feature, such as having stronger or weaker purity guarantees to make the feature easier to use or simpler to implement. An effect system may have to be created.<br>&gt; Alternatively, this could be done in a lightweight manner where the feature is introduced and known &quot;pure-like&quot; functions are marked in swift-corelibs-foundation.<br>&gt; To be honest, I don&#39;t have much experience in languages that have this feature. I would imagine many people are interested in the notion of pure functions, but the question here is if it would be worth it, feasible, or even aligned with Swift&#39;s goals to have this feature. I&#39;m half-expecting that this has already been brought up and determined to be out of scope or not a good idea.<br>&gt; <br>&gt; Thanks for your consideration. Please let me know what you think.<br>&gt; <br>&gt; -- <br>&gt; Jimmy Sambuo<br>&gt; www.sambuo.com &lt;http://www.sambuo.com/&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160220/2e23e6f4/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
