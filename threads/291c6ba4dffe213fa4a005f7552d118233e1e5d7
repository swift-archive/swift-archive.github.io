<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>August  5, 2016 at 06:00:00pm</p></header><div class="content"><p>MOTIVATION:<br></p><p>SE-0112 includes the CustomNSError protocol, which includes the properties errorDomain, errorCode, and errorUserInfo. These properties can be used to tell Swift how to convert an error to an NSError. However, there are no default implementations for errorDomain and errorCode, and there is no way to access the default values for _domain and _code that Error enums get in Swift. Thus, even if all one wanted to do was to provide a value for NSURLErrorKey, one has to do all this:<br></p><p>enum MyError: CustomNSError {<br>	case foo(URL)<br>	case bar(URL)<br>	case baz(URL)<br></p><p>	static var errorDomain: String {<br>		return “com.MyCompany.MyApp.MyError”<br>	}<br></p><p>	var errorCode: Int {<br>		switch self {<br>		case .foo(_):<br>			return 1<br>		case .bar(_):<br>			return 2<br>		case .baz(_):<br>			return 3<br>		}<br>	}<br></p><p>	var errorUserInfo: [String : NSObject] {<br>		// construct the actual user info<br>	}<br>}<br></p><p>Notice how far down you have to read before you finally get to the part that constructs the interesting information.<br></p><p>PROPROSED SOLUTION:<br></p><p>Add default implementations for all the properties in CustomNSError.<br></p><p>DETAILED DESIGN:<br></p><p>The implementations for errorCode and errorDomain will simply provide the default values of _code and _domain already provided by Swift enums. The default implementation for errorUserInfo will simply return an empty dictionary.<br></p><p>This would allow the above enum to be written simply as:<br></p><p>enum MyError: CustomNSError {<br>	case foo(URL)<br>	case bar(URL)<br>	case baz(URL)<br></p><p>	var errorUserInfo: [String : NSObject] {<br>		// construct the actual user info<br>	}<br>}<br></p><p>and the frameworks would provide something appropriate for the domain and code.<br></p><p>Charles<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>August 16, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 4:32 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; SE-0112 includes the CustomNSError protocol, which includes the properties errorDomain, errorCode, and errorUserInfo. These properties can be used to tell Swift how to convert an error to an NSError. However, there are no default implementations for errorDomain and errorCode, and there is no way to access the default values for _domain and _code that Error enums get in Swift. Thus, even if all one wanted to do was to provide a value for NSURLErrorKey, one has to do all this:<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt; 	case foo(URL)<br>&gt; 	case bar(URL)<br>&gt; 	case baz(URL)<br>&gt; <br>&gt; 	static var errorDomain: String {<br>&gt; 		return “com.MyCompany.MyApp.MyError”<br>&gt; 	}<br>&gt; <br>&gt; 	var errorCode: Int {<br>&gt; 		switch self {<br>&gt; 		case .foo(_):<br>&gt; 			return 1<br>&gt; 		case .bar(_):<br>&gt; 			return 2<br>&gt; 		case .baz(_):<br>&gt; 			return 3<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; 	var errorUserInfo: [String : NSObject] {<br>&gt; 		// construct the actual user info<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Notice how far down you have to read before you finally get to the part that constructs the interesting information.<br>&gt; <br>&gt; PROPROSED SOLUTION:<br>&gt; <br>&gt; Add default implementations for all the properties in CustomNSError.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; The implementations for errorCode and errorDomain will simply provide the default values of _code and _domain already provided by Swift enums. The default implementation for errorUserInfo will simply return an empty dictionary.<br>&gt; <br>&gt; This would allow the above enum to be written simply as:<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt; 	case foo(URL)<br>&gt; 	case bar(URL)<br>&gt; 	case baz(URL)<br>&gt; <br>&gt; 	var errorUserInfo: [String : NSObject] {<br>&gt; 		// construct the actual user info<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; and the frameworks would provide something appropriate for the domain and code.<br></p><p>+1, this seems entirely reasonable to me, and probably should have been part of the original SE-0112.<br></p><p>	- Doug<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>August 16, 2016 at 03:00:00pm</p></header><div class="content"><p>+1<br></p><p>Sent from my iPhone<br></p><p>&gt; On Aug 5, 2016, at 18:32, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; SE-0112 includes the CustomNSError protocol, which includes the properties errorDomain, errorCode, and errorUserInfo. These properties can be used to tell Swift how to convert an error to an NSError. However, there are no default implementations for errorDomain and errorCode, and there is no way to access the default values for _domain and _code that Error enums get in Swift. Thus, even if all one wanted to do was to provide a value for NSURLErrorKey, one has to do all this:<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt;    case foo(URL)<br>&gt;    case bar(URL)<br>&gt;    case baz(URL)<br>&gt; <br>&gt;    static var errorDomain: String {<br>&gt;        return “com.MyCompany.MyApp.MyError”<br>&gt;    }<br>&gt; <br>&gt;    var errorCode: Int {<br>&gt;        switch self {<br>&gt;        case .foo(_):<br>&gt;            return 1<br>&gt;        case .bar(_):<br>&gt;            return 2<br>&gt;        case .baz(_):<br>&gt;            return 3<br>&gt;        }<br>&gt;    }<br>&gt; <br>&gt;    var errorUserInfo: [String : NSObject] {<br>&gt;        // construct the actual user info<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; Notice how far down you have to read before you finally get to the part that constructs the interesting information.<br>&gt; <br>&gt; PROPROSED SOLUTION:<br>&gt; <br>&gt; Add default implementations for all the properties in CustomNSError.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; The implementations for errorCode and errorDomain will simply provide the default values of _code and _domain already provided by Swift enums. The default implementation for errorUserInfo will simply return an empty dictionary.<br>&gt; <br>&gt; This would allow the above enum to be written simply as:<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt;    case foo(URL)<br>&gt;    case bar(URL)<br>&gt;    case baz(URL)<br>&gt; <br>&gt;    var errorUserInfo: [String : NSObject] {<br>&gt;        // construct the actual user info<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; and the frameworks would provide something appropriate for the domain and code.<br>&gt; <br>&gt; Charles<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Aug 5, 2016, at 4:32 PM, Charles Srstka via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; MOTIVATION:<br>&gt; <br>&gt; SE-0112 includes the CustomNSError protocol, which includes the properties errorDomain, errorCode, and errorUserInfo. These properties can be used to tell Swift how to convert an error to an NSError. However, there are no default implementations for errorDomain and errorCode, and there is no way to access the default values for _domain and _code that Error enums get in Swift. Thus, even if all one wanted to do was to provide a value for NSURLErrorKey, one has to do all this:<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt; 	case foo(URL)<br>&gt; 	case bar(URL)<br>&gt; 	case baz(URL)<br>&gt; <br>&gt; 	static var errorDomain: String {<br>&gt; 		return “com.MyCompany.MyApp.MyError”<br>&gt; 	}<br>&gt; <br>&gt; 	var errorCode: Int {<br>&gt; 		switch self {<br>&gt; 		case .foo(_):<br>&gt; 			return 1<br>&gt; 		case .bar(_):<br>&gt; 			return 2<br>&gt; 		case .baz(_):<br>&gt; 			return 3<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; 	var errorUserInfo: [String : NSObject] {<br>&gt; 		// construct the actual user info<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; Notice how far down you have to read before you finally get to the part that constructs the interesting information.<br>&gt; <br>&gt; PROPROSED SOLUTION:<br>&gt; <br>&gt; Add default implementations for all the properties in CustomNSError.<br>&gt; <br>&gt; DETAILED DESIGN:<br>&gt; <br>&gt; The implementations for errorCode and errorDomain will simply provide the default values of _code and _domain already provided by Swift enums. The default implementation for errorUserInfo will simply return an empty dictionary.<br>&gt; <br>&gt; This would allow the above enum to be written simply as:<br>&gt; <br>&gt; enum MyError: CustomNSError {<br>&gt; 	case foo(URL)<br>&gt; 	case bar(URL)<br>&gt; 	case baz(URL)<br>&gt; <br>&gt; 	var errorUserInfo: [String : NSObject] {<br>&gt; 		// construct the actual user info<br>&gt; 	}<br>&gt; }<br>&gt; <br>&gt; and the frameworks would provide something appropriate for the domain and code.<br></p><p>The core team discussed this and will take this as an amendment to SE-0112. Charles, can you turn this into a pull request to update the SE-0112 document?<br></p><p>	- Doug<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>September  2, 2016 at 02:00:00pm</p></header><div class="content"><p>Why not simply add those default implementations to Error?<br>I can&#39;t see the value of hiding read-only properties that are already there...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September  2, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Sep 2, 2016, at 5:59 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Why not simply add those default implementations to Error?<br>&gt; I can&#39;t see the value of hiding read-only properties that are already there…<br></p><p>Domain, code, and user-info are useful for Cocoa interoperability but aren’t otherwise necessary in Swift, which captures that information more directly in the (concrete) error types that conform to Error.<br></p><p>	- Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>September  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Domain, code, and user-info are useful for Cocoa interoperability but aren’t otherwise necessary in Swift, which captures that information more directly in the (concrete) error types that conform to Error.<br>So the only motivation to hide _code and _domain is to discourage Objective-C-like dispatching in Swift, right?<br>For me, that would not be enough motivation to require something like &quot;CustomNSError&quot;, but probably this isn&#39;t the opinion of the majority.<br></p><p>I still think Error should be a legacy-type that is only needed for interoperability… but removing the restriction that only Error-types can be thrown is additive, so I won&#39;t continue discussing this now.<br></p><p>- Tino<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>Amendment to SE-0112: Default values for errorDomain and errorCode</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>September  8, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Sep 8, 2016, at 3:46 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Domain, code, and user-info are useful for Cocoa interoperability but aren’t otherwise necessary in Swift, which captures that information more directly in the (concrete) error types that conform to Error.<br>&gt; So the only motivation to hide _code and _domain is to discourage Objective-C-like dispatching in Swift, right?<br></p><p>The only reason _code and _domain exist is for Objective-C interoperability. They are not part of the Swift error model.<br></p><p>&gt; For me, that would not be enough motivation to require something like &quot;CustomNSError&quot;, but probably this isn&#39;t the opinion of the majority.<br></p><p>CustomNSError exists for cases where one wants to customize how a Swift error is translated into NSError. It’s for fine-grained control of something that generally shouldn’t matter to Swift developers.<br></p><p>&gt; I still think Error should be a legacy-type that is only needed for interoperability… but removing the restriction that only Error-types can be thrown is additive, so I won&#39;t continue discussing this now.<br></p><p><br>FWIW, I am completely against the direction you propose, for a number of reasons:<br></p><p>* If we take away the Error abstraction, then the way to deal with errors in general is via Any, which erases important meaning from the static type system <br>* Throwing any old type (let’s throw an Int! A closure!) makes it *very* hard to improve handling of that error type, e.g., you’re not going to be able to retroactively make Int or String conform to LocalizedError to provide a better user experience.<br>* There are useful extensions of the Error protocol in Foundation, e.g., the “localizedDescription” property, that one wouldn’t (and couldn’t) put onto ‘Any’. There might be more of such extensions in the future<br></p><p>	- Doug<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
