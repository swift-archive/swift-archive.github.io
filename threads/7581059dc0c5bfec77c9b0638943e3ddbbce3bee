<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md&gt;<br></p><p><br>1. What is your evaluation of the proposal?<br></p><p>+1. While I am not qualified on the technical feasibility of this proposal, I do like it, and find it addresses a lot of annoyances using libdispatch within Swift Code. I agree that libdispatch feels awkward in Swift, especially where relating to dispatch_time_t, which this proposal addresses. As long as there are no significant technical hurdles, I support this proposal.<br></p><p><br>2. Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. The API is awkward to use from within Swift, and this will update it to optimise for Swift usage.<br></p><p><br>3. Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes. It brings libdispatch into line with other imported C APIs where functions have been added to structs, and other Swift-style modifications have been made.<br></p><p><br>4. If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>I have no experience with language features like this, except using libdispatch in C &amp; Objective-C code, and I find it is actually easier to use in Objective C because it feels at home in a C world. In Swift, the issues with bridging, and the inconsistency with the language, make it somewhat more annoying to use.<br></p><p>5. How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A quick read, admittedly.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/c855a366/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I think this is a great idea and a great proposal. GCD is already a<br>powerful, elegant tool available to Swift users, and this makes it feel<br>even more Swift-like.<br></p><p>Feedback/questions:<br>- Is there a use case for user subclassing of a queue type? If not, should<br>they be final?<br>- Is there a reason to use class methods rather than static methods for the<br>queue types? I was under the impression that static methods would be<br>preferred unless a good reason exists to dispatch upon metatype.<br>- Nit: &quot;DispatchWallTime&quot; is spelled &quot;DispatchWalltime&quot; (lowercase &#39;t&#39;) in<br>the code samples.<br>- Is it allowed/technically possible for non-stdlib code to use<br>_ObjectiveCBridgable?<br></p><p>Best,<br>Austin<br></p><p><br>On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/aeebbc13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 10, 2016 at 10:00:00pm</p></header><div class="content"><p>I also think that this proposal highlights a reason why the stdlib should<br>have some sort of &#39;indigenous&#39; binary data capability, given that both<br>Foundation and libdispatch would theoretically be able to leverage such a<br>feature.<br></p><p>Austin<br></p><p>On Tue, May 10, 2016 at 10:22 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>wrote:<br></p><p>&gt; I think this is a great idea and a great proposal. GCD is already a<br>&gt; powerful, elegant tool available to Swift users, and this makes it feel<br>&gt; even more Swift-like.<br>&gt;<br>&gt; Feedback/questions:<br>&gt; - Is there a use case for user subclassing of a queue type? If not, should<br>&gt; they be final?<br>&gt; - Is there a reason to use class methods rather than static methods for<br>&gt; the queue types? I was under the impression that static methods would be<br>&gt; preferred unless a good reason exists to dispatch upon metatype.<br>&gt; - Nit: &quot;DispatchWallTime&quot; is spelled &quot;DispatchWalltime&quot; (lowercase &#39;t&#39;)<br>&gt; in the code samples.<br>&gt; - Is it allowed/technically possible for non-stdlib code to use<br>&gt; _ObjectiveCBridgable?<br>&gt;<br>&gt; Best,<br>&gt; Austin<br>&gt;<br>&gt;<br>&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hello Swift community,<br>&gt;&gt;<br>&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt;&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt;&gt; here:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;&gt;<br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt;&gt; should be sent to the swift-evolution mailing list at<br>&gt;&gt;<br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt; review manager.<br>&gt;&gt;<br>&gt;&gt; What goes into a review?<br>&gt;&gt;<br>&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt; in your review:<br>&gt;&gt;<br>&gt;&gt;         * What is your evaluation of the proposal?<br>&gt;&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt;&gt; change to Swift?<br>&gt;&gt;         * Does this proposal fit well with the feel and direction of<br>&gt;&gt; Swift?<br>&gt;&gt;         * If you have used other languages or libraries with a similar<br>&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;         * How much effort did you put into your review? A glance, a quick<br>&gt;&gt; reading, or an in-depth study?<br>&gt;&gt;<br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;<br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;<br>&gt;&gt; Thank you,<br>&gt;&gt;<br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/8272bf65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 11, 2016 at 12:00:00am</p></header><div class="content"><p>Did not see this proposal coming down the pipeline, but a more Swift-like<br>GCD will be fantastic. In terms of painting the bike shed, I&#39;m not quite<br>sure about having adverbs &quot;synchronously&quot; and &quot;asynchronously&quot; as method<br>names. Conveniently, &quot;sync&quot; and &quot;async&quot; avoid the issue entirely, and they<br>are pretty widespread and acceptable as terms of art, no?<br></p><p>One more nit: &quot;DispatchSourceMachRecv&quot; in the table, but<br>&quot;DispatchSourceMachReceive&quot; in the code sample.<br></p><p><br>On Wed, May 11, 2016 at 12:24 AM, Austin Zheng via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I also think that this proposal highlights a reason why the stdlib should<br>&gt; have some sort of &#39;indigenous&#39; binary data capability, given that both<br>&gt; Foundation and libdispatch would theoretically be able to leverage such a<br>&gt; feature.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt; On Tue, May 10, 2016 at 10:22 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; I think this is a great idea and a great proposal. GCD is already a<br>&gt;&gt; powerful, elegant tool available to Swift users, and this makes it feel<br>&gt;&gt; even more Swift-like.<br>&gt;&gt;<br>&gt;&gt; Feedback/questions:<br>&gt;&gt; - Is there a use case for user subclassing of a queue type? If not,<br>&gt;&gt; should they be final?<br>&gt;&gt; - Is there a reason to use class methods rather than static methods for<br>&gt;&gt; the queue types? I was under the impression that static methods would be<br>&gt;&gt; preferred unless a good reason exists to dispatch upon metatype.<br>&gt;&gt; - Nit: &quot;DispatchWallTime&quot; is spelled &quot;DispatchWalltime&quot; (lowercase &#39;t&#39;)<br>&gt;&gt; in the code samples.<br>&gt;&gt; - Is it allowed/technically possible for non-stdlib code to use<br>&gt;&gt; _ObjectiveCBridgable?<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt; Austin<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt;&gt;&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt;&gt;&gt; here:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All<br>&gt;&gt;&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the<br>&gt;&gt;&gt; review manager.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review<br>&gt;&gt;&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt;&gt;&gt; When writing your review, here are some questions you might want to answer<br>&gt;&gt;&gt; in your review:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         * What is your evaluation of the proposal?<br>&gt;&gt;&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt;&gt;&gt; change to Swift?<br>&gt;&gt;&gt;         * Does this proposal fit well with the feel and direction of<br>&gt;&gt;&gt; Swift?<br>&gt;&gt;&gt;         * If you have used other languages or libraries with a similar<br>&gt;&gt;&gt; feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt;         * How much effort did you put into your review? A glance, a<br>&gt;&gt;&gt; quick reading, or an in-depth study?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/a297c399/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>May 10, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On May 10, 2016, at 10:22 PM, Austin Zheng via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think this is a great idea and a great proposal. GCD is already a powerful, elegant tool available to Swift users, and this makes it feel even more Swift-like.<br>&gt; <br>&gt; Feedback/questions:<br>&gt; - Is there a use case for user subclassing of a queue type? If not, should they be final?<br></p><p>Currently it’s not possible to subclass these classes in Objective C either, the metaclass symbols for the libdispatch Objective-C classes are not exported. This same restriction applies to those classes when interacting with them in swift, even though the classes themselves are not marked `final`.<br></p><p>&gt; - Is there a reason to use class methods rather than static methods for the queue types? I was under the impression that static methods would be preferred unless a good reason exists to dispatch upon metatype.<br></p><p>This detail passed me by, I will investigate.<br></p><p>&gt; - Nit: &quot;DispatchWallTime&quot; is spelled &quot;DispatchWalltime&quot; (lowercase &#39;t&#39;) in the code samples.<br></p><p>I apologise, along with the one or two other spelling/naming issues others have pointed out. One or two of these names changed recently and I clearly didn’t catch all of them.<br></p><p>&gt; - Is it allowed/technically possible for non-stdlib code to use _ObjectiveCBridgable?<br></p><p>Similar to the Foundation mutability proposal, this will end up being an internal implementation detail of DispatchData’s struct bridging.<br></p><p>Regards,<br>M<br></p><p>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt; <br>&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>May 10, 2016 at 11:00:00pm</p></header><div class="content"><p>Excellent, thanks for answering my questions!<br></p><p>If the classes should/can not be subclassed, they should probably be marked<br>as &#39;final&#39; in order to make this clear to consumers, regardless of<br>performance or correctness implications.<br></p><p>Austin<br></p><p>On Tue, May 10, 2016 at 11:12 PM, Matt Wright &lt;mww at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On May 10, 2016, at 10:22 PM, Austin Zheng via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; I think this is a great idea and a great proposal. GCD is already a<br>&gt; powerful, elegant tool available to Swift users, and this makes it feel<br>&gt; even more Swift-like.<br>&gt; &gt;<br>&gt; &gt; Feedback/questions:<br>&gt; &gt; - Is there a use case for user subclassing of a queue type? If not,<br>&gt; should they be final?<br>&gt;<br>&gt; Currently it’s not possible to subclass these classes in Objective C<br>&gt; either, the metaclass symbols for the libdispatch Objective-C classes are<br>&gt; not exported. This same restriction applies to those classes when<br>&gt; interacting with them in swift, even though the classes themselves are not<br>&gt; marked `final`.<br>&gt;<br>&gt; &gt; - Is there a reason to use class methods rather than static methods for<br>&gt; the queue types? I was under the impression that static methods would be<br>&gt; preferred unless a good reason exists to dispatch upon metatype.<br>&gt;<br>&gt; This detail passed me by, I will investigate.<br>&gt;<br>&gt; &gt; - Nit: &quot;DispatchWallTime&quot; is spelled &quot;DispatchWalltime&quot; (lowercase &#39;t&#39;)<br>&gt; in the code samples.<br>&gt;<br>&gt; I apologise, along with the one or two other spelling/naming issues others<br>&gt; have pointed out. One or two of these names changed recently and I clearly<br>&gt; didn’t catch all of them.<br>&gt;<br>&gt; &gt; - Is it allowed/technically possible for non-stdlib code to use<br>&gt; _ObjectiveCBridgable?<br>&gt;<br>&gt; Similar to the Foundation mutability proposal, this will end up being an<br>&gt; internal implementation detail of DispatchData’s struct bridging.<br>&gt;<br>&gt; Regards,<br>&gt; M<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Best,<br>&gt; &gt; Austin<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; Swift?<br>&gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/80671475/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>May 13, 2016 at 11:00:00am</p></header><div class="content"><p>[Apologies for the weird threading, I missed the original email to the list so I can’t reply to it directly]<br></p><p>I just wanted to let the list know that I updated proposal SE-0088 to fix the typos and include a more complete listing of the Dispatch module after the transformations in the proposal have been applied. Additionally, I’ve been keeping up with some of the feedback in this review thread and looking to see which ones would be best applied to the proposal. Though it should be made clear, this particular update only covers fixing the inconsistencies in my original proposal and providing a more complete overview of the module layout.<br></p><p>Similar to the changes in Foundation that are proposed on swift-evolution, I don’t expect all of the changes in libdispatch will be able to go through this process. As this is a large change (and, hopefully, a step forwards) to libdispatch I believe it is important to bring it to the swift-evolution list and take away your feedback for inclusion in future iterations of the module.<br></p><p>Thanks again for your continued feedback,<br>Matt<br></p><p>&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 13, 2016 at 07:00:00pm</p></header><div class="content"><p>This looks great. Thanks for revising. I&#39;m now a +1 on this.<br></p><p>A couple more minor suggestions:<br></p><p>- Consider renaming setTimer(...) to resetTimer() or just reset(), or<br>something similar?<br></p><p>- Consider making Semaphore&#39;s wait() throw an error, rather than returning<br>non-zero, in the event of a timeout. Most common uses will be &quot;try!<br>wait()&quot;. Or you could have waitForever() be a separate, non-throwing<br>function.<br></p><p>Jacob Bandes-Storch<br></p><p>On Fri, May 13, 2016 at 11:36 AM, Matt Wright via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; list so I can’t reply to it directly]<br>&gt;<br>&gt; I just wanted to let the list know that I updated proposal SE-0088 to fix<br>&gt; the typos and include a more complete listing of the Dispatch module after<br>&gt; the transformations in the proposal have been applied. Additionally, I’ve<br>&gt; been keeping up with some of the feedback in this review thread and looking<br>&gt; to see which ones would be best applied to the proposal. Though it should<br>&gt; be made clear, this particular update only covers fixing the<br>&gt; inconsistencies in my original proposal and providing a more complete<br>&gt; overview of the module layout.<br>&gt;<br>&gt; Similar to the changes in Foundation that are proposed on swift-evolution,<br>&gt; I don’t expect all of the changes in libdispatch will be able to go through<br>&gt; this process. As this is a large change (and, hopefully, a step forwards)<br>&gt; to libdispatch I believe it is important to bring it to the swift-evolution<br>&gt; list and take away your feedback for inclusion in future iterations of the<br>&gt; module.<br>&gt;<br>&gt; Thanks again for your continued feedback,<br>&gt; Matt<br>&gt;<br>&gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; Swift?<br>&gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/25063811/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 12:24 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; This looks great. Thanks for revising. I&#39;m now a +1 on this.<br>&gt; <br>&gt; A couple more minor suggestions:<br>&gt; <br>&gt; - Consider renaming setTimer(...) to resetTimer() or just reset(), or something similar?<br></p><p>setTimer addresses both the initial setup as well as setting it again. I’m not sure reset is a good name for it.<br></p><p>&gt; - Consider making Semaphore&#39;s wait() throw an error, rather than returning non-zero, in the event of a timeout. Most common uses will be &quot;try! wait()&quot;. Or you could have waitForever() be a separate, non-throwing function.<br></p><p>Throwing an error here seems like a sensible improvement.<br></p><p>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Fri, May 13, 2016 at 11:36 AM, Matt Wright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; [Apologies for the weird threading, I missed the original email to the list so I can’t reply to it directly]<br>&gt; <br>&gt; I just wanted to let the list know that I updated proposal SE-0088 to fix the typos and include a more complete listing of the Dispatch module after the transformations in the proposal have been applied. Additionally, I’ve been keeping up with some of the feedback in this review thread and looking to see which ones would be best applied to the proposal. Though it should be made clear, this particular update only covers fixing the inconsistencies in my original proposal and providing a more complete overview of the module layout.<br>&gt; <br>&gt; Similar to the changes in Foundation that are proposed on swift-evolution, I don’t expect all of the changes in libdispatch will be able to go through this process. As this is a large change (and, hopefully, a step forwards) to libdispatch I believe it is important to bring it to the swift-evolution list and take away your feedback for inclusion in future iterations of the module.<br>&gt; <br>&gt; Thanks again for your continued feedback,<br>&gt; Matt<br>&gt; <br>&gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; &gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; &gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; &gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 13, 2016 at 07:00:00pm</p></header><div class="content"><p>More nits:<br></p><p>setHighWater(highWater:) and its ilk should should probably be<br>setHighWater(_:) and so on (I include among these setInterval(interval:),<br>setTargetQueue(queue:), etc.)<br></p><p>Similarly, in terms of conforming to Swift guidelines, I notice many<br>instances where labels repeat the parameter type, especially<br>DispatchWalltime. For instance, setTimer(walltime: DispatchWalltime,<br>leeway: DispatchTimeInterval)--not sure what to suggest here other than<br>point out that the first label is redundant.<br>On Fri, May 13, 2016 at 11:36 Matt Wright via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; [Apologies for the weird threading, I missed the original email to the<br>&gt; list so I can’t reply to it directly]<br>&gt;<br>&gt; I just wanted to let the list know that I updated proposal SE-0088 to fix<br>&gt; the typos and include a more complete listing of the Dispatch module after<br>&gt; the transformations in the proposal have been applied. Additionally, I’ve<br>&gt; been keeping up with some of the feedback in this review thread and looking<br>&gt; to see which ones would be best applied to the proposal. Though it should<br>&gt; be made clear, this particular update only covers fixing the<br>&gt; inconsistencies in my original proposal and providing a more complete<br>&gt; overview of the module layout.<br>&gt;<br>&gt; Similar to the changes in Foundation that are proposed on swift-evolution,<br>&gt; I don’t expect all of the changes in libdispatch will be able to go through<br>&gt; this process. As this is a large change (and, hopefully, a step forwards)<br>&gt; to libdispatch I believe it is important to bring it to the swift-evolution<br>&gt; list and take away your feedback for inclusion in future iterations of the<br>&gt; module.<br>&gt;<br>&gt; Thanks again for your continued feedback,<br>&gt; Matt<br>&gt;<br>&gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt; &gt;<br>&gt; &gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All<br>&gt; reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt; &gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt; &gt;         * Does this proposal fit well with the feel and direction of<br>&gt; Swift?<br>&gt; &gt;         * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br>&gt; &gt;         * How much effort did you put into your review? A glance, a<br>&gt; quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/4644df43/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>May 13, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 12:29 PM, Xiaodi Wu &lt;xiaodi.wu at gmail.com&gt; wrote:<br>&gt; <br>&gt; More nits:<br>&gt; <br>&gt; setHighWater(highWater:) and its ilk should should probably be setHighWater(_:) and so on (I include among these setInterval(interval:), setTargetQueue(queue:), etc.)<br></p><p>I suspect setHighWater and setLowWater can probably become setLimit(highWater:) setLimit(lowWater:). setTargetQueue -&gt; setTarget(queue:) seems like an obvious change but something about it doesn’t sit particularly right with me. I will think about this further. There were both very useful bits feedback on these names though, thank you!<br></p><p>&gt; Similarly, in terms of conforming to Swift guidelines, I notice many instances where labels repeat the parameter type, especially DispatchWalltime. For instance, setTimer(walltime: DispatchWalltime, leeway: DispatchTimeInterval)--not sure what to suggest here other than point out that the first label is redundant.<br></p><p>setTimer() in particular has a setTimer(start:,…) and setTimer(walltime:,…) that are distinct, perhaps the latter could be `walltimeStart:`. While there was an earlier argument for removing Walltime as a typed concept, we believe it is advantageous to keep different “types” of time as separate distinct Swift types in the module.<br></p><p>&gt; On Fri, May 13, 2016 at 11:36 Matt Wright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; [Apologies for the weird threading, I missed the original email to the list so I can’t reply to it directly]<br>&gt; <br>&gt; I just wanted to let the list know that I updated proposal SE-0088 to fix the typos and include a more complete listing of the Dispatch module after the transformations in the proposal have been applied. Additionally, I’ve been keeping up with some of the feedback in this review thread and looking to see which ones would be best applied to the proposal. Though it should be made clear, this particular update only covers fixing the inconsistencies in my original proposal and providing a more complete overview of the module layout.<br>&gt; <br>&gt; Similar to the changes in Foundation that are proposed on swift-evolution, I don’t expect all of the changes in libdispatch will be able to go through this process. As this is a large change (and, hopefully, a step forwards) to libdispatch I believe it is important to bring it to the swift-evolution list and take away your feedback for inclusion in future iterations of the module.<br>&gt; <br>&gt; Thanks again for your continued feedback,<br>&gt; Matt<br>&gt; <br>&gt; &gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; Hello Swift community,<br>&gt; &gt;<br>&gt; &gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; &gt;<br>&gt; &gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; &gt;<br>&gt; &gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; &gt;<br>&gt; &gt; What goes into a review?<br>&gt; &gt;<br>&gt; &gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; &gt;<br>&gt; &gt;         * What is your evaluation of the proposal?<br>&gt; &gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; &gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; &gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; &gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; &gt;<br>&gt; &gt; More information about the Swift evolution process is available at<br>&gt; &gt;<br>&gt; &gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; &gt;<br>&gt; &gt; Thank you,<br>&gt; &gt;<br>&gt; &gt; -Chris Lattner<br>&gt; &gt; Review Manager<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 16, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi,<br></p><p>I’m a +1 on the proposal, I think it’s a no brainer, but I do have one question...<br></p><p>What is the reasoning behind repeating the module name in the type name? e.g we have `Dispatch.DispatchQueue`. Why not `Dispatch.Queue`? It seems a bit pointless for the Swift team to go to all that effort to give us name spaces and then for us to ignore them.<br></p><p><br>&gt; On 13 May 2016, at 19:36, Matt Wright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; [Apologies for the weird threading, I missed the original email to the list so I can’t reply to it directly]<br>&gt; <br>&gt; I just wanted to let the list know that I updated proposal SE-0088 to fix the typos and include a more complete listing of the Dispatch module after the transformations in the proposal have been applied. Additionally, I’ve been keeping up with some of the feedback in this review thread and looking to see which ones would be best applied to the proposal. Though it should be made clear, this particular update only covers fixing the inconsistencies in my original proposal and providing a more complete overview of the module layout.<br>&gt; <br>&gt; Similar to the changes in Foundation that are proposed on swift-evolution, I don’t expect all of the changes in libdispatch will be able to go through this process. As this is a large change (and, hopefully, a step forwards) to libdispatch I believe it is important to bring it to the swift-evolution list and take away your feedback for inclusion in future iterations of the module.<br>&gt; <br>&gt; Thanks again for your continued feedback,<br>&gt; Matt<br>&gt; <br>&gt;&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt;        * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;        * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;        * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;        * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Oh man, this is fantastic!<br></p><p>* What is your evaluation of the proposal?<br></p><p>Great stuff, really brings dispatch into the world of Swift, and seems like it will not only make it more pleasant but better.<br></p><p>I have a couple of questions:<br>- Why is everything prefixed with Dispatch-, when you can surely rename the module, e.g. Dispatch.Queue, Dispatch.IO, or is the concern that this could clash? It just would be nice to write Queue directly. Group can become WorkGroup, to match WorkItem.<br>- Can static vars be added to DispatchQueue for all the concurrent QOS? So you can just write DispatchQueue.utility, or DispatchQueue.utilityConcurrent. I think this would increase their adoption.<br>- Is the .synchronously method able to have the @noescape attribute added?<br>- .asynchronously/.synchronously feels a bit long, will be interested to see what others think.<br>- Will DispatchData bridge to Foundation’s NSData, both in Darwin and Linux?<br></p><p>To be honest, I’d rather this become more of a standard alongside Swift than Foundation. I think you can build interesting modern APIs on top of this, such as for working with files and data, that get have concurrency and compatible with QOS by default.<br></p><p>For example, DispatchData supersedes NSData as Swift’s native ‘Data’, and extra methods that NSData has DispatchData gets in the same way Swift’s String gets some NSString methods. Eventually these methods are ported to DispatchData as extensions, or in new forms that make use of protocols and other Swift features.<br></p><p>* Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes, I think this will increase adoption, and make it feel like an official part of Swift.<br></p><p>* Does this proposal fit well with the feel and direction of Swift?<br>Yes, this makes libdispatch modern and suitable for future applications.<br></p><p>* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Compared to using it in Objective-C, it seems to cover all the features.<br></p><p>* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>A good read.<br></p><p><br>&gt; On 11 May 2016, at 2:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Sorry, instead of saying this I meant to say fall into the pit of success with concurrency and QOS. (http://blog.codinghorror.com/falling-into-the-pit-of-success/)<br>The Foundation APIs such as -[NSData writeToURL:atomically:] are easy to find yet synchronous, and might be a newcomer’s first choice. A new API built on top of libdispatch might make doing the right thing the first choice.<br></p><p>&gt; On 11 May 2016, at 3:41 PM, Patrick Smith &lt;pgwsmith at gmail.com&gt; wrote:<br>&gt; <br>&gt; that get have concurrency and compatible with QOS by default.<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>May 11, 2016 at 01:00:00am</p></header><div class="content"><p>I&#39;m one of the largest dispatch-on-linux users right now.  In fact, I&#39;m reasonably sure I&#39;m THE largest.  I have an application in production that uses some 400 dispatch calls.  <br></p><p>On Linux, I&#39;m running Swift 3 in production, essentially because Dispatch/Linux in 2.2 does not even exist.  On OSX/iOS, I compile the same codebase with Swift 2.2, because that&#39;s the version that&#39;s released, and using released software is a sane thing to do.<br></p><p>This proposal places me in the uncomfortable situation of trying to somehow smooth out a truly MASSIVE API delta with #if.  And that&#39;s not going to happen.  Realistically, what I will do is create some kind of FrankenSwift that either backports the new API to Swift 3 or the old API to Swift 2.  And that is a ton of work, really stupid work, and I would infinitely prefer to spend that time doing something actually useful to the world.  To be clear, I don&#39;t fear migration; what I fear is the heisenmigration, where one of my platforms must migrate, and the other ones can&#39;t.<br></p><p>More broadly, I am concerned about the direction the language is going where we do not even have working libraries yet and already we are doing sweeping API changes to them.  I suspect this is motivated by a fundamentally incorrect premise–the premise that because it&#39;s not released yet, we can get away with it.  When actually that&#39;s backwards: we can get away with breaking changes later, but if we do them now we will ruin everything.  Let me explain.<br></p><p>Right now, Linux Swift programmers exist. And they need to be able to solve ordinary problems, like writing a string to a file, or spinning up a background thread.  And I do mean: sometime before Late 2016.  No amount of telling them &quot;don&#39;t do that, it&#39;s not released&quot; is going to stop this.  The only question is whether upstream is going to be the repo that solves their problem, or whether they go to solve the problem somewhere else.  Because when they go somewhere else, they invest there.<br></p><p>Increasingly, because upstream is not interested in the problem, I am seeing Linux folk go solve the problem somewhere else.  Just counting the projects I&#39;m personally aware of, there are 3 foundation alternatives and 1 package manager alternative.  All because upstream has no sane path to e.g. reading a file on disk in the kind of timeframe working programmers actually need to do it in.<br></p><p>What we *should* be doing is creating libraries that *work*, *releasing them*, and then we can do as much API Disneyland as we want without harassing the working programmer.<br></p><p>1.  If we&#39;re out of bugs to fix, why not release?  Then folks like me can get off the snapshot treadmill and we won&#39;t be annoyed by massive API delta until we can do it all at once, which is (relatively) easy.<br>2.  If we&#39;re not out of bugs to fix, why not work on them, and then release, and then come back to this?<br>3.  Since Swift 3 will have a stable ABI, why not ship both libdispatch2 and libdispatch3 and let the programmer plan her own migration?  I&#39;m not even sure the stable ABI part is relevant, since Dispatch is almost entirely C.<br></p><p>All of these are saner alternatives to the proposal, and all of them achieve the stated goal (e.g. we still end up with happy modern APIs).<br></p><p>I don&#39;t mean to pick on this proposal specifically, I agree with the need to modernize the API surface area.  But if we continue to do breaking changes first and releases later I&#39;m concerned about where the early adopters will get pushed to.<br></p><p>Drew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/7c5c18e1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 11, 2016 at 01:00:00am</p></header><div class="content"><p>On Wed, May 11, 2016 at 1:30 AM, Drew Crawford via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I&#39;m one of the largest dispatch-on-linux users right now.  In fact, I&#39;m<br>&gt; reasonably sure I&#39;m *THE* largest.  I have an application in production<br>&gt; that uses some 400 dispatch calls.<br>&gt;<br>&gt; On Linux, I&#39;m running Swift 3 in production, essentially because<br>&gt; Dispatch/Linux in 2.2 does not even exist.  On OSX/iOS, I compile the same<br>&gt; codebase with Swift 2.2, because that&#39;s the version that&#39;s released, and<br>&gt; using released software is a sane thing to do.<br>&gt;<br>&gt; This proposal places me in the uncomfortable situation of trying to<br>&gt; somehow smooth out a truly MASSIVE API delta with #if.  And that&#39;s not<br>&gt; going to happen.  Realistically, what I will do is create some kind of<br>&gt; FrankenSwift that either backports the new API to Swift 3 or the old API to<br>&gt; Swift 2.  And that is a ton of work, really stupid work, and I would<br>&gt; infinitely prefer to spend that time doing something actually useful to the<br>&gt; world.  To be clear, I don&#39;t fear migration; what I fear is the<br>&gt; heisenmigration, where one of my platforms must migrate, and the other ones<br>&gt; can&#39;t.<br>&gt;<br>&gt; More broadly, I am concerned about the direction the language is going<br>&gt; where we do not even have working libraries yet and already we are doing<br>&gt; sweeping API changes to them.  I suspect this is motivated by a<br>&gt; fundamentally incorrect premise–the premise that because it&#39;s not released<br>&gt; yet, we can get away with it.  When actually that&#39;s backwards: we can get<br>&gt; away with breaking changes later, but if we do them now we will ruin<br>&gt; everything.  Let me explain.<br>&gt;<br>&gt; Right now, Linux Swift programmers exist. And they need to be able to<br>&gt; solve ordinary problems, like writing a string to a file, or spinning up a<br>&gt; background thread.  And I do mean: sometime before Late 2016.  No amount of<br>&gt; telling them &quot;don&#39;t do that, it&#39;s not released&quot; is going to stop this.  The<br>&gt; only question is whether upstream is going to be the repo that solves their<br>&gt; problem, or whether they go to solve the problem somewhere else.  Because<br>&gt; when they go somewhere else, they invest there.<br>&gt;<br>&gt; Increasingly, because upstream is not interested in the problem, I am<br>&gt; seeing Linux folk go solve the problem somewhere else.  Just counting the<br>&gt; projects I&#39;m personally aware of, there are 3 foundation alternatives and 1<br>&gt; package manager alternative.  All because upstream has no sane path to e.g.<br>&gt; reading a file on disk in the kind of timeframe working programmers<br>&gt; actually need to do it in.<br>&gt;<br>&gt; What we *should* be doing is creating libraries that **work**, **releasing<br>&gt; them**, and then we can do as much API Disneyland as we want without<br>&gt; harassing the working programmer.<br>&gt;<br>&gt; 1.  If we&#39;re out of bugs to fix, why not release?  Then folks like me can<br>&gt; get off the snapshot treadmill and we won&#39;t be annoyed by massive API delta<br>&gt; until we can do it all at once, which is (relatively) easy.<br>&gt; 2.  If we&#39;re not out of bugs to fix, why not work on them, and then<br>&gt; release, and then come back to this?<br>&gt; 3.  Since Swift 3 will have a stable ABI, why not ship both libdispatch2<br>&gt; and libdispatch3 and let the programmer plan her own migration?  I&#39;m not<br>&gt; even sure the stable ABI part is relevant, since Dispatch is almost<br>&gt; entirely C.<br>&gt;<br>&gt; All of these are saner alternatives to the proposal, and all of them<br>&gt; achieve the stated goal (e.g. we still end up with happy modern APIs).<br>&gt;<br>&gt; I don&#39;t mean to pick on this proposal specifically, I agree with the need<br>&gt; to modernize the API surface area.  But if we continue to do breaking<br>&gt; changes first and releases later I&#39;m concerned about where the early<br>&gt; adopters will get pushed to.<br>&gt;<br></p><p>FWIW, I believe the first Swift 3 preview branch is being created from<br>master tomorrow...<br></p><p><br>&gt;<br>&gt; Drew<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/83adb384/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I completely disagree with what you said. It sounds extreme to me to release a v1 of a library without giving yourself the flexibility to iterate on it beforehand.<br></p><p>&gt; On 11 May 2016, at 08:30, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m one of the largest dispatch-on-linux users right now.  In fact, I&#39;m reasonably sure I&#39;m THE largest.  I have an application in production that uses some 400 dispatch calls.  <br>&gt; <br>&gt; On Linux, I&#39;m running Swift 3 in production, essentially because Dispatch/Linux in 2.2 does not even exist.  On OSX/iOS, I compile the same codebase with Swift 2.2, because that&#39;s the version that&#39;s released, and using released software is a sane thing to do.<br>&gt; <br>&gt; This proposal places me in the uncomfortable situation of trying to somehow smooth out a truly MASSIVE API delta with #if.  And that&#39;s not going to happen.  Realistically, what I will do is create some kind of FrankenSwift that either backports the new API to Swift 3 or the old API to Swift 2.  And that is a ton of work, really stupid work, and I would infinitely prefer to spend that time doing something actually useful to the world.  To be clear, I don&#39;t fear migration; what I fear is the heisenmigration, where one of my platforms must migrate, and the other ones can&#39;t.<br>&gt; <br>&gt; More broadly, I am concerned about the direction the language is going where we do not even have working libraries yet and already we are doing sweeping API changes to them.  I suspect this is motivated by a fundamentally incorrect premise–the premise that because it&#39;s not released yet, we can get away with it.  When actually that&#39;s backwards: we can get away with breaking changes later, but if we do them now we will ruin everything.  Let me explain.<br>&gt; <br>&gt; Right now, Linux Swift programmers exist. And they need to be able to solve ordinary problems, like writing a string to a file, or spinning up a background thread.  And I do mean: sometime before Late 2016.  No amount of telling them &quot;don&#39;t do that, it&#39;s not released&quot; is going to stop this.  The only question is whether upstream is going to be the repo that solves their problem, or whether they go to solve the problem somewhere else.  Because when they go somewhere else, they invest there.<br>&gt; <br>&gt; Increasingly, because upstream is not interested in the problem, I am seeing Linux folk go solve the problem somewhere else.  Just counting the projects I&#39;m personally aware of, there are 3 foundation alternatives and 1 package manager alternative.  All because upstream has no sane path to e.g. reading a file on disk in the kind of timeframe working programmers actually need to do it in.<br>&gt; <br>&gt; What we *should* be doing is creating libraries that *work*, *releasing them*, and then we can do as much API Disneyland as we want without harassing the working programmer.<br>&gt; <br>&gt; 1.  If we&#39;re out of bugs to fix, why not release?  Then folks like me can get off the snapshot treadmill and we won&#39;t be annoyed by massive API delta until we can do it all at once, which is (relatively) easy.<br>&gt; 2.  If we&#39;re not out of bugs to fix, why not work on them, and then release, and then come back to this?<br>&gt; 3.  Since Swift 3 will have a stable ABI, why not ship both libdispatch2 and libdispatch3 and let the programmer plan her own migration?  I&#39;m not even sure the stable ABI part is relevant, since Dispatch is almost entirely C.<br>&gt; <br>&gt; All of these are saner alternatives to the proposal, and all of them achieve the stated goal (e.g. we still end up with happy modern APIs).<br>&gt; <br>&gt; I don&#39;t mean to pick on this proposal specifically, I agree with the need to modernize the API surface area.  But if we continue to do breaking changes first and releases later I&#39;m concerned about where the early adopters will get pushed to.<br>&gt; <br>&gt; Drew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/5a74891b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a838c63b9093a77fb88231d65effa3b3?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Drew Crawford</string> &lt;drew at sealedabstract.com&gt;<p>May 11, 2016 at 06:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 6:34 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; It sounds extreme to me to release a v1 of a library without giving yourself the flexibility to iterate on it beforehand.<br></p><p>Dispatch is already released (on two platforms).  So that ship sailed in 2010.  The question in front of us is whether we&#39;re going to focus in getting the Linux port to parity with Darwin or whether we&#39;re going off an an API design adventure before seriously addressing that goal.<br></p><p>It seems prudent to point out that &quot;API design&quot; appears last on our list of Swift 3 goals, while &quot;Portability &lt;https://github.com/apple/swift-evolution&gt;&quot; is in the top three.  So I don&#39;t know why my position would be &quot;extreme&quot;, as it is more consistent with what we are on paper supposed to be doing in this release.<br></p><p>It also seems prudent to point out that we are going to do the first preview branch tomorrow.  Obviously none of us really know what to expect, but the official guidance includes such statements as &quot;only changes that align with the core goals of the release will be considered&quot; and &quot;Source-breaking changes to the language will be considered on a case-by-case basis.&quot;  I think we should consider whether rewriting the entire Dispatch API surface area is something that would clear that bar.<br></p><p>I agree with all the individual API changes.  They&#39;re great.  I just think the timing is wrong.  We should get to Darwin parity, and then we&#39;ll be in a position to pull the trigger on this.<br></p><p>Drew<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/8ab0c84e/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>May 11, 2016 at 03:00:00pm</p></header><div class="content"><p>You do make some good points; we have a variety of important areas that are completely unimplemented across any platforms, besides the feature parity across platforms.<br></p><p>I also wonder why this can’t be provided as a new library on top of (rather than as a replacement for) the existing libDispatch C interface. I have my own DispatchQueue class that does a lot of what this proposal suggests but it doesn’t replace the dispatch_* calls so it doesn’t break anything.<br></p><p>We are starting to accumulate a massive number of breaking changes. Yes there are fix-its but you still have problems with branches and coordinating the upgrade.<br></p><p>I’m also sympathetic to the fact that any changes we want to make will only get more difficult with time and the longer we wait to refactor APIs, rename things, etc the less likely it will even be possible. I think part of the rush for these kinds of changes is the fact that Swift 3 wants to focus on ABI stability and a lot of people are interpreting that as “this is our last chance to fix everything we don’t like!”, though ABI stability != API stability. Might just be me though.<br></p><p><br>Russ<br></p><p><br>&gt; On May 10, 2016, at 11:30 PM, Drew Crawford via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;m one of the largest dispatch-on-linux users right now.  In fact, I&#39;m reasonably sure I&#39;m THE largest.  I have an application in production that uses some 400 dispatch calls.  <br>&gt; <br>&gt; On Linux, I&#39;m running Swift 3 in production, essentially because Dispatch/Linux in 2.2 does not even exist.  On OSX/iOS, I compile the same codebase with Swift 2.2, because that&#39;s the version that&#39;s released, and using released software is a sane thing to do.<br>&gt; <br>&gt; This proposal places me in the uncomfortable situation of trying to somehow smooth out a truly MASSIVE API delta with #if.  And that&#39;s not going to happen.  Realistically, what I will do is create some kind of FrankenSwift that either backports the new API to Swift 3 or the old API to Swift 2.  And that is a ton of work, really stupid work, and I would infinitely prefer to spend that time doing something actually useful to the world.  To be clear, I don&#39;t fear migration; what I fear is the heisenmigration, where one of my platforms must migrate, and the other ones can&#39;t.<br>&gt; <br>&gt; More broadly, I am concerned about the direction the language is going where we do not even have working libraries yet and already we are doing sweeping API changes to them.  I suspect this is motivated by a fundamentally incorrect premise–the premise that because it&#39;s not released yet, we can get away with it.  When actually that&#39;s backwards: we can get away with breaking changes later, but if we do them now we will ruin everything.  Let me explain.<br>&gt; <br>&gt; Right now, Linux Swift programmers exist. And they need to be able to solve ordinary problems, like writing a string to a file, or spinning up a background thread.  And I do mean: sometime before Late 2016.  No amount of telling them &quot;don&#39;t do that, it&#39;s not released&quot; is going to stop this.  The only question is whether upstream is going to be the repo that solves their problem, or whether they go to solve the problem somewhere else.  Because when they go somewhere else, they invest there.<br>&gt; <br>&gt; Increasingly, because upstream is not interested in the problem, I am seeing Linux folk go solve the problem somewhere else.  Just counting the projects I&#39;m personally aware of, there are 3 foundation alternatives and 1 package manager alternative.  All because upstream has no sane path to e.g. reading a file on disk in the kind of timeframe working programmers actually need to do it in.<br>&gt; <br>&gt; What we *should* be doing is creating libraries that *work*, *releasing them*, and then we can do as much API Disneyland as we want without harassing the working programmer.<br>&gt; <br>&gt; 1.  If we&#39;re out of bugs to fix, why not release?  Then folks like me can get off the snapshot treadmill and we won&#39;t be annoyed by massive API delta until we can do it all at once, which is (relatively) easy.<br>&gt; 2.  If we&#39;re not out of bugs to fix, why not work on them, and then release, and then come back to this?<br>&gt; 3.  Since Swift 3 will have a stable ABI, why not ship both libdispatch2 and libdispatch3 and let the programmer plan her own migration?  I&#39;m not even sure the stable ABI part is relevant, since Dispatch is almost entirely C.<br>&gt; <br>&gt; All of these are saner alternatives to the proposal, and all of them achieve the stated goal (e.g. we still end up with happy modern APIs).<br>&gt; <br>&gt; I don&#39;t mean to pick on this proposal specifically, I agree with the need to modernize the API surface area.  But if we continue to do breaking changes first and releases later I&#39;m concerned about where the early adopters will get pushed to.<br>&gt; <br>&gt; Drew<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/98879f47/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 10, 2016 at 11:00:00pm</p></header><div class="content"><p>* What is your evaluation of the proposal?<br></p><p>I&#39;m generally in favor of a modernized API overlay like this (and I&#39;ve<br>written something like it<br>&lt;https://gist.github.com/jtbandes/a5ce62019585dd4f998e&gt; myself, albeit much<br>simpler), but I&#39;m hoping this proposal can go through another round or two<br>of discussion/bikeshedding/revision before approval.<br></p><p>(Small note: I&#39;m really happy about the strong-typed-ness of the Source<br>subclasses, e.g. how mergeData is only available for Add/Or.)<br></p><p>In no particular order, here are some things on which I&#39;m unclear, or<br>not-so-+1:<br></p><p>- synchronously()&#39;s block parameter should be @noescape. Perhaps more<br>arguably, it should have a generic return type and rethrows, like<br>autoreleasepool<br>now does<br>&lt;https://github.com/apple/swift-evolution/blob/master/proposals/0061-autoreleasepool-signature.md&gt;<br>.<br></p><p>- The names asynchronously(execute:) and synchronously(execute:) don&#39;t seem<br>to fit with any API guidelines I&#39;m aware of. Did you consider including the<br>verb in the method name?  (And I&#39;m guessing that &quot;func<br>synchronously(work:...)&quot; is meant to be &quot;func synchronously(execute<br>work:...)&quot;?) As another bikeshed-item, I&#39;d vote for<br>&quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;, and<br>perhaps whenDone() instead of notify().<br></p><p>- Are DispatchWorkItemFlags meant to overlay dispatch_block_flags? It would<br>be nice to explicitly list these in the proposal.<br></p><p>- Are functions like dispatch_barrier_sync totally gone in favor of passing<br>a .barrier flag? It would be nice to explicitly state this in the proposal.<br></p><p>- I echo Austin&#39;s concerns about subclassability. I think it would be<br>dangerously misleading if the classes were subclassable from user code,<br>even if it didn&#39;t work properly.<br></p><p>- What of the APIs provided on Semaphore and Group objects? I&#39;d like to see<br>these before I vote for the proposal.<br></p><p>- What will dispatch_set_target_queue&#39;s replacement look like look like?<br></p><p>- What about dispatch_once?<br></p><p>- Why use class funcs for the Source initializers, rather than an init on<br>each individual subclass?<br></p><p>- Since DispatchSpecificKey is an object now, is there any concern with the<br>object being allocated at the same address as an old, since-deallocated,<br>object? (This might cause user confusion if both were used as &quot;different&quot;<br>keys.)<br></p><p><br>        * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br></p><p>Yes.<br></p><p>        * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Getting there.<br></p><p>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>Medium-quick reading of this proposal. I&#39;ve thought about this issue a good<br>deal in the past, though.<br></p><p>Jacob<br></p><p>On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello Swift community,<br>&gt;<br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming<br>&gt; conventions&quot; begins now and runs through May 17. The proposal is available<br>&gt; here:<br>&gt;<br>&gt;<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;<br>&gt; Reviews are an important part of the Swift evolution process. All reviews<br>&gt; should be sent to the swift-evolution mailing list at<br>&gt;<br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; or, if you would like to keep your feedback private, directly to the<br>&gt; review manager.<br>&gt;<br>&gt; What goes into a review?<br>&gt;<br>&gt; The goal of the review process is to improve the proposal under review<br>&gt; through constructive criticism and contribute to the direction of Swift.<br>&gt; When writing your review, here are some questions you might want to answer<br>&gt; in your review:<br>&gt;<br>&gt;<br>&gt; More information about the Swift evolution process is available at<br>&gt;<br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;<br>&gt; Thank you,<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160510/9a011dbd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>Hey Jacob,<br></p><p>I agree with you that there are some unanswered questions and areas we would need some more polish on, but libdispatch was a bit unwieldy in Objective-C already and when used as is in Swift code it looks to be even less user friendly and not because it has to, but because of a lack of proper improvements such as the one described here. <br></p><p>I strongly hope we can get this in time for Swift 3... (not given up on cleaner dispatching rules for protocols and protocol extensions, but that&#39;s another story :)).<br></p><p>Sent from my iPhone<br></p><p>&gt; On 11 May 2016, at 07:52, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; I&#39;m generally in favor of a modernized API overlay like this (and I&#39;ve written something like it myself, albeit much simpler), but I&#39;m hoping this proposal can go through another round or two of discussion/bikeshedding/revision before approval.<br>&gt; <br>&gt; (Small note: I&#39;m really happy about the strong-typed-ness of the Source subclasses, e.g. how mergeData is only available for Add/Or.)<br>&gt; <br>&gt; In no particular order, here are some things on which I&#39;m unclear, or not-so-+1:<br>&gt; <br>&gt; - synchronously()&#39;s block parameter should be @noescape. Perhaps more arguably, it should have a generic return type and rethrows, like autoreleasepool now does.<br>&gt; <br>&gt; - The names asynchronously(execute:) and synchronously(execute:) don&#39;t seem to fit with any API guidelines I&#39;m aware of. Did you consider including the verb in the method name?  (And I&#39;m guessing that &quot;func synchronously(work:...)&quot; is meant to be &quot;func synchronously(execute work:...)&quot;?) As another bikeshed-item, I&#39;d vote for &quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;, and perhaps whenDone() instead of notify().<br>&gt; <br>&gt; - Are DispatchWorkItemFlags meant to overlay dispatch_block_flags? It would be nice to explicitly list these in the proposal.<br>&gt; <br>&gt; - Are functions like dispatch_barrier_sync totally gone in favor of passing a .barrier flag? It would be nice to explicitly state this in the proposal.<br>&gt; <br>&gt; - I echo Austin&#39;s concerns about subclassability. I think it would be dangerously misleading if the classes were subclassable from user code, even if it didn&#39;t work properly.<br>&gt; <br>&gt; - What of the APIs provided on Semaphore and Group objects? I&#39;d like to see these before I vote for the proposal.<br>&gt; <br>&gt; - What will dispatch_set_target_queue&#39;s replacement look like look like?<br>&gt; <br>&gt; - What about dispatch_once?<br>&gt; <br>&gt; - Why use class funcs for the Source initializers, rather than an init on each individual subclass?<br>&gt; <br>&gt; - Since DispatchSpecificKey is an object now, is there any concern with the object being allocated at the same address as an old, since-deallocated, object? (This might cause user confusion if both were used as &quot;different&quot; keys.)<br>&gt; <br>&gt; <br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Getting there.<br>&gt; <br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Medium-quick reading of this proposal. I&#39;ve thought about this issue a good deal in the past, though.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt;&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/2a5c6d95/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>May 11, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On May 10, 2016, at 11:52 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; I&#39;m generally in favor of a modernized API overlay like this (and I&#39;ve written something like it myself, albeit much simpler), but I&#39;m hoping this proposal can go through another round or two of discussion/bikeshedding/revision before approval.<br>&gt; <br>&gt; (Small note: I&#39;m really happy about the strong-typed-ness of the Source subclasses, e.g. how mergeData is only available for Add/Or.)<br>&gt; <br>&gt; In no particular order, here are some things on which I&#39;m unclear, or not-so-+1:<br>&gt; <br>&gt; - synchronously()&#39;s block parameter should be @noescape. Perhaps more arguably, it should have a generic return type and rethrows, like autoreleasepool now does.<br></p><p>Both of these are present in the changes I have for this proposal. The former point is a mistake in my proposal text, the latter is an unfortunate oversight on my part in putting together the proposal document.<br></p><p>&gt; - The names asynchronously(execute:) and synchronously(execute:) don&#39;t seem to fit with any API guidelines I&#39;m aware of. Did you consider including the verb in the method name?  <br></p><p>We did. Of the number of names that we discussed, none of them were perfect. sync/async are common in other languages but don’t fit the general direction of the Swift 3 naming conventions. Using `dispatchAsynchronously` is an extremely long method name, even more so than `asynchronously`. `perform` does not capture the sync/async nature of the calls particularly well, compared to DispatchWorkItem where `perform` immediately executes the block.<br></p><p>&gt; (And I&#39;m guessing that &quot;func synchronously(work:...)&quot; is meant to be &quot;func synchronously(execute work:...)”?)<br></p><p>Right.<br></p><p>&gt; As another bikeshed-item, I&#39;d vote for &quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;, and perhaps whenDone() instead of notify().<br></p><p>Here the init() functions closely mirror Data from Foundation, the Objective-C class is toll-free bridged to NSData and we desired a close match to the Foundation Swift API. `notify` is Dispatch-only API though, I’ll go think over that one.<br></p><p>&gt; - Are DispatchWorkItemFlags meant to overlay dispatch_block_flags? It would be nice to explicitly list these in the proposal.<br></p><p>The dispatch_block_* API is completely superseded by DispatchWorkItem in the proposal. DispatchWorkItemFlags is the equivalent to dispatch_block_flags.<br></p><p>&gt; - Are functions like dispatch_barrier_sync totally gone in favor of passing a .barrier flag? It would be nice to explicitly state this in the proposal.<br></p><p>Yes, you can supply .barrier to either `synchronously` or `asynchronously`, or create a DispatchWorkItem as a barrier item. Where possible the multiple variants of a class (dispatch_async, dispatch_barrier_async, etc) are collapsed into a single method with default arguments.<br></p><p>&gt; - I echo Austin&#39;s concerns about subclassability. I think it would be dangerously misleading if the classes were subclassable from user code, even if it didn&#39;t work properly.<br></p><p>Building at compile time will fail. So you wouldn’t get very far trying to use them, I plan to investigate adding `final` here (it’s only absent for technical reasons, as the classes originate from Objective-C).<br></p><p>&gt; - What of the APIs provided on Semaphore and Group objects? I&#39;d like to see these before I vote for the proposal.<br></p><p>These would be transformed similarly, I will include them when updating the proposal.<br></p><p>class DispatchSemaphore : DispatchObject {                                                                                                                 <br></p><p>  init(value: Int)<br></p><p>  func wait(timeout: DispatchTime = default) -&gt; Int<br></p><p>  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br></p><p>  func signal() -&gt; Int<br></p><p>}<br></p><p>class DispatchGroup : DispatchObject {<br></p><p>  init()                                                                                                                <br></p><p>  func wait(timeout: DispatchTime = default) -&gt; Int<br></p><p>  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br></p><p>  func notify(queue: DispatchQueue, block: () -&gt; Void)<br></p><p>  func enter()<br></p><p>  func leave()<br></p><p>}<br></p><p><br>&gt; - What will dispatch_set_target_queue&#39;s replacement look like look like?<br></p><p>extension DispatchObject {                                                                                                                                 <br></p><p>  func setTargetQueue(queue: DispatchQueue?)<br></p><p>}<br></p><p>&gt; <br>&gt; - What about dispatch_once?<br></p><p>Removed. Swift already has lazy initialisation at the language level, dispatch_once is neither needed nor safe in Swift.<br></p><p>&gt; - Why use class funcs for the Source initializers, rather than an init on each individual subclass?<br></p><p>Implementation limitations. The “subclasses&quot; are protocols would be introduced in order to attain a level of type safety around DispatchSource. We felt this was a significant enough improvement that it was worth including even with this implementation wart.<br></p><p>&gt; <br>&gt; - Since DispatchSpecificKey is an object now, is there any concern with the object being allocated at the same address as an old, since-deallocated, object? (This might cause user confusion if both were used as &quot;different&quot; keys.)<br></p><p>The intention, though something that cannot be enforced, is that DispatchSpecificKey would be a global static object. I’d be interested if anyone has a pattern that more throughly enforces the allocation pattern required by the underlying API.<br></p><p>&gt; <br>&gt; <br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; Yes.<br>&gt; <br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Getting there.<br>&gt; <br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; Medium-quick reading of this proposal. I&#39;ve thought about this issue a good deal in the past, though.<br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;         https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;         https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>May 12, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 7:09 AM, Matt Wright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On May 10, 2016, at 11:52 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt; <br>&gt;&gt; I&#39;m generally in favor of a modernized API overlay like this (and I&#39;ve written something like it myself, albeit much simpler), but I&#39;m hoping this proposal can go through another round or two of discussion/bikeshedding/revision before approval.<br>&gt;&gt; <br>&gt;&gt; (Small note: I&#39;m really happy about the strong-typed-ness of the Source subclasses, e.g. how mergeData is only available for Add/Or.)<br>&gt;&gt; <br>&gt;&gt; In no particular order, here are some things on which I&#39;m unclear, or not-so-+1:<br>&gt;&gt; <br>&gt;&gt; - synchronously()&#39;s block parameter should be @noescape. Perhaps more arguably, it should have a generic return type and rethrows, like autoreleasepool now does.<br>&gt; <br>&gt; Both of these are present in the changes I have for this proposal. The former point is a mistake in my proposal text, the latter is an unfortunate oversight on my part in putting together the proposal document.<br>&gt; <br>&gt;&gt; - The names asynchronously(execute:) and synchronously(execute:) don&#39;t seem to fit with any API guidelines I&#39;m aware of. Did you consider including the verb in the method name?  <br>&gt; <br>&gt; We did. Of the number of names that we discussed, none of them were perfect. sync/async are common in other languages but don’t fit the general direction of the Swift 3 naming conventions. Using `dispatchAsynchronously` is an extremely long method name, even more so than `asynchronously`. `perform` does not capture the sync/async nature of the calls particularly well, compared to DispatchWorkItem where `perform` immediately executes the block.<br>&gt; <br>&gt;&gt; (And I&#39;m guessing that &quot;func synchronously(work:...)&quot; is meant to be &quot;func synchronously(execute work:...)”?)<br>&gt; <br>&gt; Right.<br>&gt; <br>&gt;&gt; As another bikeshed-item, I&#39;d vote for &quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;, and perhaps whenDone() instead of notify().<br>&gt; <br>&gt; Here the init() functions closely mirror Data from Foundation, the Objective-C class is toll-free bridged to NSData and we desired a close match to the Foundation Swift API. `notify` is Dispatch-only API though, I’ll go think over that one.<br>&gt; <br>&gt;&gt; - Are DispatchWorkItemFlags meant to overlay dispatch_block_flags? It would be nice to explicitly list these in the proposal.<br>&gt; <br>&gt; The dispatch_block_* API is completely superseded by DispatchWorkItem in the proposal. DispatchWorkItemFlags is the equivalent to dispatch_block_flags.<br>&gt; <br>&gt;&gt; - Are functions like dispatch_barrier_sync totally gone in favor of passing a .barrier flag? It would be nice to explicitly state this in the proposal.<br>&gt; <br>&gt; Yes, you can supply .barrier to either `synchronously` or `asynchronously`, or create a DispatchWorkItem as a barrier item. Where possible the multiple variants of a class (dispatch_async, dispatch_barrier_async, etc) are collapsed into a single method with default arguments.<br>&gt; <br>&gt;&gt; - I echo Austin&#39;s concerns about subclassability. I think it would be dangerously misleading if the classes were subclassable from user code, even if it didn&#39;t work properly.<br>&gt; <br>&gt; Building at compile time will fail. So you wouldn’t get very far trying to use them, I plan to investigate adding `final` here (it’s only absent for technical reasons, as the classes originate from Objective-C).<br>&gt; <br>&gt;&gt; - What of the APIs provided on Semaphore and Group objects? I&#39;d like to see these before I vote for the proposal.<br>&gt; <br>&gt; These would be transformed similarly, I will include them when updating the proposal.<br>&gt; <br>&gt; class DispatchSemaphore : DispatchObject {                                                                             <br>&gt; <br>&gt;  init(value: Int)<br>&gt; <br>&gt;  func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt; <br>&gt;  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt; <br>&gt;  func signal() -&gt; Int<br>&gt; <br>&gt; }<br>&gt; <br>&gt; class DispatchGroup : DispatchObject {<br>&gt; <br>&gt;  init()                                                                                                                <br>&gt; <br>&gt;  func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt; <br>&gt;  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt; <br>&gt;  func notify(queue: DispatchQueue, block: () -&gt; Void)<br>&gt; <br>&gt;  func enter()<br>&gt; <br>&gt;  func leave()<br>&gt; <br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; - What will dispatch_set_target_queue&#39;s replacement look like look like?<br>&gt; <br>&gt; extension DispatchObject {                                                                                                          <br>&gt; <br>&gt;  func setTargetQueue(queue: DispatchQueue?)<br>&gt; <br>&gt; }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - What about dispatch_once?<br>&gt; <br>&gt; Removed. Swift already has lazy initialisation at the language level, dispatch_once is neither needed nor safe in Swift.<br></p><p>Hi Matt, <br></p><p>What other API would be removed ? Could the proposal be updated with the API that will not be reachable from the swift wrapper?<br></p><p>Thank you. <br></p><p><br></p><p><br></p><p><br></p><p><br>&gt; <br>&gt;&gt; - Why use class funcs for the Source initializers, rather than an init on each individual subclass?<br>&gt; <br>&gt; Implementation limitations. The “subclasses&quot; are protocols would be introduced in order to attain a level of type safety around DispatchSource. We felt this was a significant enough improvement that it was worth including even with this implementation wart.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; - Since DispatchSpecificKey is an object now, is there any concern with the object being allocated at the same address as an old, since-deallocated, object? (This might cause user confusion if both were used as &quot;different&quot; keys.)<br>&gt; <br>&gt; The intention, though something that cannot be enforced, is that DispatchSpecificKey would be a global static object. I’d be interested if anyone has a pattern that more throughly enforces the allocation pattern required by the underlying API.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;        * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;        * Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; <br>&gt;&gt; Getting there.<br>&gt;&gt; <br>&gt;&gt;        * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; Medium-quick reading of this proposal. I&#39;ve thought about this issue a good deal in the past, though.<br>&gt;&gt; <br>&gt;&gt; Jacob<br>&gt;&gt; <br>&gt;&gt; On Tue, May 10, 2016 at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt;        https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt;        https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/0db3586d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/562c2299436b75df013fb428ddf90ce6?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Pierre Habouzit</string> &lt;pierre at habouzit.net&gt;<p>May 12, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 10:49 AM, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 7:09 AM, Matt Wright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 10, 2016, at 11:52 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m generally in favor of a modernized API overlay like this (and I&#39;ve written something like it myself, albeit much simpler), but I&#39;m hoping this proposal can go through another round or two of discussion/bikeshedding/revision before approval.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (Small note: I&#39;m really happy about the strong-typed-ness of the Source subclasses, e.g. how mergeData is only available for Add/Or.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In no particular order, here are some things on which I&#39;m unclear, or not-so-+1:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - synchronously()&#39;s block parameter should be @noescape. Perhaps more arguably, it should have a generic return type and rethrows, like autoreleasepool now does.<br>&gt;&gt; <br>&gt;&gt; Both of these are present in the changes I have for this proposal. The former point is a mistake in my proposal text, the latter is an unfortunate oversight on my part in putting together the proposal document.<br>&gt;&gt; <br>&gt;&gt;&gt; - The names asynchronously(execute:) and synchronously(execute:) don&#39;t seem to fit with any API guidelines I&#39;m aware of. Did you consider including the verb in the method name?  <br>&gt;&gt; <br>&gt;&gt; We did. Of the number of names that we discussed, none of them were perfect. sync/async are common in other languages but don’t fit the general direction of the Swift 3 naming conventions. Using `dispatchAsynchronously` is an extremely long method name, even more so than `asynchronously`. `perform` does not capture the sync/async nature of the calls particularly well, compared to DispatchWorkItem where `perform` immediately executes the block.<br>&gt;&gt; <br>&gt;&gt;&gt; (And I&#39;m guessing that &quot;func synchronously(work:...)&quot; is meant to be &quot;func synchronously(execute work:...)”?)<br>&gt;&gt; <br>&gt;&gt; Right.<br>&gt;&gt; <br>&gt;&gt;&gt; As another bikeshed-item, I&#39;d vote for &quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;, and perhaps whenDone() instead of notify().<br>&gt;&gt; <br>&gt;&gt; Here the init() functions closely mirror Data from Foundation, the Objective-C class is toll-free bridged to NSData and we desired a close match to the Foundation Swift API. `notify` is Dispatch-only API though, I’ll go think over that one.<br>&gt;&gt; <br>&gt;&gt;&gt; - Are DispatchWorkItemFlags meant to overlay dispatch_block_flags? It would be nice to explicitly list these in the proposal.<br>&gt;&gt; <br>&gt;&gt; The dispatch_block_* API is completely superseded by DispatchWorkItem in the proposal. DispatchWorkItemFlags is the equivalent to dispatch_block_flags.<br>&gt;&gt; <br>&gt;&gt;&gt; - Are functions like dispatch_barrier_sync totally gone in favor of passing a .barrier flag? It would be nice to explicitly state this in the proposal.<br>&gt;&gt; <br>&gt;&gt; Yes, you can supply .barrier to either `synchronously` or `asynchronously`, or create a DispatchWorkItem as a barrier item. Where possible the multiple variants of a class (dispatch_async, dispatch_barrier_async, etc) are collapsed into a single method with default arguments.<br>&gt;&gt; <br>&gt;&gt;&gt; - I echo Austin&#39;s concerns about subclassability. I think it would be dangerously misleading if the classes were subclassable from user code, even if it didn&#39;t work properly.<br>&gt;&gt; <br>&gt;&gt; Building at compile time will fail. So you wouldn’t get very far trying to use them, I plan to investigate adding `final` here (it’s only absent for technical reasons, as the classes originate from Objective-C).<br>&gt;&gt; <br>&gt;&gt;&gt; - What of the APIs provided on Semaphore and Group objects? I&#39;d like to see these before I vote for the proposal.<br>&gt;&gt; <br>&gt;&gt; These would be transformed similarly, I will include them when updating the proposal.<br>&gt;&gt; <br>&gt;&gt; class DispatchSemaphore : DispatchObject {                                                                             <br>&gt;&gt; <br>&gt;&gt;  init(value: Int)<br>&gt;&gt; <br>&gt;&gt;  func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt;&gt; <br>&gt;&gt;  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt;&gt; <br>&gt;&gt;  func signal() -&gt; Int<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class DispatchGroup : DispatchObject {<br>&gt;&gt; <br>&gt;&gt;  init()                                                                                                                <br>&gt;&gt; <br>&gt;&gt;  func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt;&gt; <br>&gt;&gt;  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt;&gt; <br>&gt;&gt;  func notify(queue: DispatchQueue, block: () -&gt; Void)<br>&gt;&gt; <br>&gt;&gt;  func enter()<br>&gt;&gt; <br>&gt;&gt;  func leave()<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; - What will dispatch_set_target_queue&#39;s replacement look like look like?<br>&gt;&gt; <br>&gt;&gt; extension DispatchObject {                                                                                                          <br>&gt;&gt; <br>&gt;&gt;  func setTargetQueue(queue: DispatchQueue?)<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - What about dispatch_once?<br>&gt;&gt; <br>&gt;&gt; Removed. Swift already has lazy initialisation at the language level, dispatch_once is neither needed nor safe in Swift.<br>&gt; <br>&gt; Hi Matt, <br>&gt; <br>&gt; What other API would be removed ? Could the proposal be updated with the API that will not be reachable from the swift wrapper?<br>&gt; <br>&gt; Thank you. <br></p><p>- dispatch_retain/dispatch_release() that are obviously useless in swift<br>- dispatch_get_context/dispatch_set_context() and dispatch_set_finalizer_f() because it has no ownership semantics and were only there for ports where you had no blocks (as in closures)<br>- dispatch_once() and dispatch_once_f() because global initializers do that job in swift<br>- in general all _f variants, which would be really awkward to use from swift anyway<br>- anything that was deprecated in previous releases (dispatch_debug, dispatch_debugv, dispatch_get_current_queue) as per usual swift import rules<br></p><p><br>-Pierre<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/b5e3506e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 12, 2016 at 10:00:00pm</p></header><div class="content"><p>dispatch_get_context, dispatch_set_context are not around simply in the<br>absence of blocks. They&#39;re just as useful as the queue-specific data<br>APIs as they have thread-specific storage.<br> <br>Zach Waldowski<br>zach at waldowski.me<br> <br> <br>On Thu, May 12, 2016, at 08:50 PM, Pierre Habouzit via swift-evolution wrote:<br>&gt;&gt; On May 12, 2016, at 10:49 AM, Jose Cheyo Jimenez via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; On May 11, 2016, at 7:09 AM, Matt Wright via swift-evolution &lt;swift-<br>&gt;&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On May 10, 2016, at 11:52 PM, Jacob Bandes-Storch via swift-<br>&gt;&gt;&gt;&gt; evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m generally in favor of a modernized API overlay like this (and<br>&gt;&gt;&gt;&gt; I&#39;ve written something like it myself, albeit much simpler), but<br>&gt;&gt;&gt;&gt; I&#39;m hoping this proposal can go through another round or two of<br>&gt;&gt;&gt;&gt; discussion/bikeshedding/revision before approval.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (Small note: I&#39;m really happy about the strong-typed-ness of the<br>&gt;&gt;&gt;&gt; Source subclasses, e.g. how mergeData is only available for<br>&gt;&gt;&gt;&gt; Add/Or.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; In no particular order, here are some things on which I&#39;m unclear,<br>&gt;&gt;&gt;&gt; or not-so-+1:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - synchronously()&#39;s block parameter should be @noescape. Perhaps<br>&gt;&gt;&gt;&gt;   more arguably, it should have a generic return type and rethrows,<br>&gt;&gt;&gt;&gt;   like autoreleasepool now does.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Both of these are present in the changes I have for this proposal.<br>&gt;&gt;&gt; The former point is a mistake in my proposal text, the latter is an<br>&gt;&gt;&gt; unfortunate oversight on my part in putting together the proposal<br>&gt;&gt;&gt; document.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - The names asynchronously(execute:) and synchronously(execute:)<br>&gt;&gt;&gt;&gt;   don&#39;t seem to fit with any API guidelines I&#39;m aware of. Did you<br>&gt;&gt;&gt;&gt;   consider including the verb in the method name?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; We did. Of the number of names that we discussed, none of them were<br>&gt;&gt;&gt; perfect. sync/async are common in other languages but don’t fit the<br>&gt;&gt;&gt; general direction of the Swift 3 naming conventions. Using<br>&gt;&gt;&gt; `dispatchAsynchronously` is an extremely long method name, even more<br>&gt;&gt;&gt; so than `asynchronously`. `perform` does not capture the sync/async<br>&gt;&gt;&gt; nature of the calls particularly well, compared to DispatchWorkItem<br>&gt;&gt;&gt; where `perform` immediately executes the block.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (And I&#39;m guessing that &quot;func synchronously(work:...)&quot; is meant to<br>&gt;&gt;&gt;&gt; be &quot;func synchronously(execute work:...)”?)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As another bikeshed-item, I&#39;d vote for<br>&gt;&gt;&gt;&gt; &quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;,<br>&gt;&gt;&gt;&gt; and perhaps whenDone() instead of notify().<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here the init() functions closely mirror Data from Foundation, the<br>&gt;&gt;&gt; Objective-C class is toll-free bridged to NSData and we desired a<br>&gt;&gt;&gt; close match to the Foundation Swift API. `notify` is Dispatch-only<br>&gt;&gt;&gt; API though, I’ll go think over that one.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Are DispatchWorkItemFlags meant to overlay dispatch_block_flags?<br>&gt;&gt;&gt;&gt;   It would be nice to explicitly list these in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The dispatch_block_* API is completely superseded by<br>&gt;&gt;&gt; DispatchWorkItem in the proposal. DispatchWorkItemFlags is the<br>&gt;&gt;&gt; equivalent to dispatch_block_flags.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - Are functions like dispatch_barrier_sync totally gone in favor of<br>&gt;&gt;&gt;&gt;   passing a .barrier flag? It would be nice to explicitly state<br>&gt;&gt;&gt;&gt;   this in the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Yes, you can supply .barrier to either `synchronously` or<br>&gt;&gt;&gt; `asynchronously`, or create a DispatchWorkItem as a barrier item.<br>&gt;&gt;&gt; Where possible the multiple variants of a class (dispatch_async,<br>&gt;&gt;&gt; dispatch_barrier_async, etc) are collapsed into a single method with<br>&gt;&gt;&gt; default arguments.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - I echo Austin&#39;s concerns about subclassability. I think it would<br>&gt;&gt;&gt;&gt;   be dangerously misleading if the classes were subclassable from<br>&gt;&gt;&gt;&gt;   user code, even if it didn&#39;t work properly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Building at compile time will fail. So you wouldn’t get very far<br>&gt;&gt;&gt; trying to use them, I plan to investigate adding `final` here (it’s<br>&gt;&gt;&gt; only absent for technical reasons, as the classes originate from<br>&gt;&gt;&gt; Objective-C).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - What of the APIs provided on Semaphore and Group objects? I&#39;d<br>&gt;&gt;&gt;&gt;   like to see these before I vote for the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; These would be transformed similarly, I will include them when<br>&gt;&gt;&gt; updating the proposal.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class DispatchSemaphore : DispatchObject {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; init(value: Int)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func signal() -&gt; Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; class DispatchGroup : DispatchObject {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; init()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func notify(queue: DispatchQueue, block: () -&gt; Void)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func enter()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func leave()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - What will dispatch_set_target_queue&#39;s replacement look like look<br>&gt;&gt;&gt;&gt;   like?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; extension DispatchObject {<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func setTargetQueue(queue: DispatchQueue?)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; - What about dispatch_once?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Removed. Swift already has lazy initialisation at the language<br>&gt;&gt;&gt; level, dispatch_once is neither needed nor safe in Swift.<br>&gt;&gt;<br>&gt;&gt; Hi Matt,<br>&gt;&gt;<br>&gt;&gt; What other API would be removed ? Could the proposal be updated with<br>&gt;&gt; the API that will not be reachable from the swift wrapper?<br>&gt;&gt;<br>&gt;&gt; Thank you.<br>&gt;<br>&gt; - dispatch_retain/dispatch_release() that are obviously useless<br>&gt;   in swift<br>&gt; - dispatch_get_context/dispatch_set_context() and<br>&gt;   dispatch_set_finalizer_f() because it has no ownership semantics and<br>&gt;   were only there for ports where you had no blocks (as in closures)<br>&gt; - dispatch_once() and dispatch_once_f() because global initializers do<br>&gt;   that job in swift<br>&gt; - in general all _f variants, which would be really awkward to use<br>&gt;   from swift anyway<br>&gt; - anything that was deprecated in previous releases (dispatch_debug,<br>&gt;   dispatch_debugv, dispatch_get_current_queue) as per usual swift<br>&gt;   import rules<br>&gt;<br>&gt;<br>&gt; -Pierre<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/ec804f2b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/27423842cafa2fc08bf56ff675a852e5?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Daniel A. Steffen</string> &lt;das at apple.com&gt;<p>May 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On May 12, 2016, at 22:29, Zach Waldowski via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; dispatch_get_context, dispatch_set_context are not around simply in the absence of blocks. They&#39;re just as useful as the queue-specific data APIs as they have thread-specific storage.<br></p><p>dispatch_get_context and dispatch_set_context are per-object storage of a single word, there is no connection to threads.<br></p><p>there are many problems with this API including the lack of synchronization between getters and setters and ill-defined ownership semantics (e.g. a setter replacing an already set context leaks the previous value).<br></p><p>On queues this API has been subsumed by the getSpecific/setSpecific API which does not have these problems, for other classes we felt that its drawbacks and problems outweighed the benefits that it provided.<br></p><p>Daniel<br></p><p>&gt;  <br>&gt; Zach Waldowski<br>&gt; zach at waldowski.me &lt;mailto:zach at waldowski.me&gt;<br>&gt;  <br>&gt;  <br>&gt; On Thu, May 12, 2016, at 08:50 PM, Pierre Habouzit via swift-evolution wrote:<br>&gt;&gt;&gt; On May 12, 2016, at 10:49 AM, Jose Cheyo Jimenez via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On May 11, 2016, at 7:09 AM, Matt Wright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On May 10, 2016, at 11:52 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;        * What is your evaluation of the proposal?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I&#39;m generally in favor of a modernized API overlay like this (and I&#39;ve written something like it myself, albeit much simpler), but I&#39;m hoping this proposal can go through another round or two of discussion/bikeshedding/revision before approval.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; (Small note: I&#39;m really happy about the strong-typed-ness of the Source subclasses, e.g. how mergeData is only available for Add/Or.)<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; In no particular order, here are some things on which I&#39;m unclear, or not-so-+1:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - synchronously()&#39;s block parameter should be @noescape. Perhaps more arguably, it should have a generic return type and rethrows, like autoreleasepool now does.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Both of these are present in the changes I have for this proposal. The former point is a mistake in my proposal text, the latter is an unfortunate oversight on my part in putting together the proposal document.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - The names asynchronously(execute:) and synchronously(execute:) don&#39;t seem to fit with any API guidelines I&#39;m aware of. Did you consider including the verb in the method name?  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; We did. Of the number of names that we discussed, none of them were perfect. sync/async are common in other languages but don’t fit the general direction of the Swift 3 naming conventions. Using `dispatchAsynchronously` is an extremely long method name, even more so than `asynchronously`. `perform` does not capture the sync/async nature of the calls particularly well, compared to DispatchWorkItem where `perform` immediately executes the block.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; (And I&#39;m guessing that &quot;func synchronously(work:...)&quot; is meant to be &quot;func synchronously(execute work:...)”?)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Right.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; As another bikeshed-item, I&#39;d vote for &quot;Data.init(withoutCopying:...)&quot; rather than &quot;(bytesNoCopy:...)&quot;, and perhaps whenDone() instead of notify().<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Here the init() functions closely mirror Data from Foundation, the Objective-C class is toll-free bridged to NSData and we desired a close match to the Foundation Swift API. `notify` is Dispatch-only API though, I’ll go think over that one.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - Are DispatchWorkItemFlags meant to overlay dispatch_block_flags? It would be nice to explicitly list these in the proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; The dispatch_block_* API is completely superseded by DispatchWorkItem in the proposal. DispatchWorkItemFlags is the equivalent to dispatch_block_flags.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - Are functions like dispatch_barrier_sync totally gone in favor of passing a .barrier flag? It would be nice to explicitly state this in the proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Yes, you can supply .barrier to either `synchronously` or `asynchronously`, or create a DispatchWorkItem as a barrier item. Where possible the multiple variants of a class (dispatch_async, dispatch_barrier_async, etc) are collapsed into a single method with default arguments.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - I echo Austin&#39;s concerns about subclassability. I think it would be dangerously misleading if the classes were subclassable from user code, even if it didn&#39;t work properly.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Building at compile time will fail. So you wouldn’t get very far trying to use them, I plan to investigate adding `final` here (it’s only absent for technical reasons, as the classes originate from Objective-C).<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - What of the APIs provided on Semaphore and Group objects? I&#39;d like to see these before I vote for the proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; These would be transformed similarly, I will include them when updating the proposal.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; class DispatchSemaphore : DispatchObject {                                                                             <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  init(value: Int)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func signal() -&gt; Int<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; class DispatchGroup : DispatchObject {<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  init()                                                                                                                <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func wait(timeout: DispatchTime = default) -&gt; Int<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func wait(walltime timeout: DispatchWalltime) -&gt; Int<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func notify(queue: DispatchQueue, block: () -&gt; Void)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func enter()<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func leave()<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - What will dispatch_set_target_queue&#39;s replacement look like look like?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; extension DispatchObject {                                                                                                          <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  func setTargetQueue(queue: DispatchQueue?)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; - What about dispatch_once?<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Removed. Swift already has lazy initialisation at the language level, dispatch_once is neither needed nor safe in Swift.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Hi Matt, <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What other API would be removed ? Could the proposal be updated with the API that will not be reachable from the swift wrapper?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Thank you. <br>&gt;&gt;  <br>&gt;&gt; - dispatch_retain/dispatch_release() that are obviously useless in swift<br>&gt;&gt; - dispatch_get_context/dispatch_set_context() and dispatch_set_finalizer_f() because it has no ownership semantics and were only there for ports where you had no blocks (as in closures)<br>&gt;&gt; - dispatch_once() and dispatch_once_f() because global initializers do that job in swift<br>&gt;&gt; - in general all _f variants, which would be really awkward to use from swift anyway<br>&gt;&gt; - anything that was deprecated in previous releases (dispatch_debug, dispatch_debugv, dispatch_get_current_queue) as per usual swift import rules<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; -Pierre<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/4f3b5b58/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15947d27758dc90df81fd42c4a387bbb?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>James Dempsey</string> &lt;dempsey at mac.com&gt;<p>May 11, 2016 at 06:00:00am</p></header><div class="content"><p>My main piece of feedback is that the method names synchronously() and asynchronously() don’t conform to Swift 3 naming conventions for functions and methods:<br></p><p>&quot;Name functions and methods according to their side-effects<br></p><p>	• Those without side-effects should read as noun phrases, e.g. x.distance(to: y), i.successor().<br></p><p>	• Those with side-effects should read as imperative verb phrases, e.g., print(x), x.sort(), x.append(y).”<br></p><p>The method names<br></p><p>	synchronously()<br>	asynchronously() <br></p><p>are both adverbs, not noun phrases or verb phrases.<br>These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br></p><p><br>Since these are the methods where you actually dispatch a block into a queue<br></p><p>dispatchSynchronously()<br>dispatchAsynchronously()<br></p><p>would include the verb in the name of the methods.<br></p><p><br>Since the majority of uses of GCD is for async dispatch, you could possibly make async the ‘default&#39; and have the two names be:<br></p><p>dispatch() // Dispatches Asynchronously<br>dispatchSynchronously()<br></p><p><br>You could potentially make the case that ’sync’ and ‘async’ are well-known terms in their own right, not just abbreviations, and use them instead of the longer words:<br></p><p>dispatchAsynch()<br>dispatchSynch()<br></p><p><br>James<br></p><p><br></p><p><br>&gt; On May 10, 2016, at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/6f5bdf5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>Jacob Bandes-Storch suggested:<br></p><p>synchronously(execute work: …)<br></p><p>So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br></p><p>Or perhaps:<br></p><p>synchronously(dispatch work: …)<br>asynchronously(dispatch work: …)<br></p><p><br></p><p>&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The method names<br>&gt; <br>&gt; 	synchronously()<br>&gt; 	asynchronously() <br>&gt; <br>&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt; <br>&gt; <br>&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt; <br>&gt; dispatchSynchronously()<br>&gt; dispatchAsynchronously()<br>&gt; <br>&gt; would include the verb in the name of the methods.<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/19f44516/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15947d27758dc90df81fd42c4a387bbb?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>James Dempsey</string> &lt;dempsey at mac.com&gt;<p>May 11, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br></p><p><br>It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br></p><p>In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br></p><p>At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br></p><p><br>Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br></p><p>Could there be just a single dispatch() method, with async as a flag with a default value of true?<br></p><p>It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br></p><p>James<br></p><p><br></p><p>&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; Jacob Bandes-Storch suggested:<br>&gt; <br>&gt; synchronously(execute work: …)<br>&gt; <br>&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt; <br>&gt; Or perhaps:<br>&gt; <br>&gt; synchronously(dispatch work: …)<br>&gt; asynchronously(dispatch work: …)<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The method names<br>&gt;&gt; <br>&gt;&gt; 	synchronously()<br>&gt;&gt; 	asynchronously() <br>&gt;&gt; <br>&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt; <br>&gt;&gt; dispatchSynchronously()<br>&gt;&gt; dispatchAsynchronously()<br>&gt;&gt; <br>&gt;&gt; would include the verb in the name of the methods.<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/cf1ea558/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 12, 2016 at 01:00:00am</p></header><div class="content"><p>You could use dispatch(), and name the synchronous method something else? synchronize() or its shortened form sync(), which is a real word, or maybe wait(). (However, there was a beauty in the yin-yang of async/sync in the original API. I would call them terms of art, like map, filter, reduce, etc)<br></p><p><br>class DispatchQueue : DispatchObject {<br>    func synchronize(work: @convention(block) () -&gt; Void)<br></p><p>    func dispatch(<br>        group: DispatchGroup? = nil, <br>        qos: DispatchQoS = .unspecified, <br>        flags: DispatchWorkItemFlags = [], <br>        work: @convention(block) () -&gt; Void)<br>}<br></p><p>queue.dispatch(group: group) {<br>    print(&quot;Hello World&quot;)<br>}<br></p><p>queue.synchronize {<br>    print(&quot;Hello World&quot;)<br>}<br></p><p><br>&gt; On 12 May 2016, at 12:50 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt; <br>&gt; <br>&gt; It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br>&gt; <br>&gt; In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br>&gt; <br>&gt; At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br>&gt; <br>&gt; <br>&gt; Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br>&gt; <br>&gt; Could there be just a single dispatch() method, with async as a flag with a default value of true?<br>&gt; <br>&gt; It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br>&gt; <br>&gt; James<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Jacob Bandes-Storch suggested:<br>&gt;&gt; <br>&gt;&gt; synchronously(execute work: …)<br>&gt;&gt; <br>&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt; <br>&gt;&gt; Or perhaps:<br>&gt;&gt; <br>&gt;&gt; synchronously(dispatch work: …)<br>&gt;&gt; asynchronously(dispatch work: …)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The method names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	synchronously()<br>&gt;&gt;&gt; 	asynchronously() <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; dispatchSynchronously()<br>&gt;&gt;&gt; dispatchAsynchronously()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would include the verb in the name of the methods.<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/9a99c8c3/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 11, 2016 at 08:00:00am</p></header><div class="content"><p>On Wed, May 11, 2016 at 7:50 AM, James Dempsey via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So maybe that will conform to the API naming guideline?  Or would the verb<br>&gt; have to be in the base name of the func?<br>&gt;<br>&gt;<br>&gt; It seems from the guidelines that the intent is for the verb to be in the<br>&gt; base name of the func, especially since there is another set of guidelines<br>&gt; for naming function parameters.<br>&gt;<br>&gt; In general the other methods in the proposal are verbs (perform(),<br>&gt; notify(), wait(), cancel(), etc.)<br>&gt;<br>&gt; At least for me, not including a verb makes the API read like the sentence<br>&gt; “The dog quickly”.  This wasn’t so bad in the C API, because you could read<br>&gt; the word ‘dispatch’ as the verb.<br>&gt;<br>&gt;<br>&gt; Looking at the current GDC API, it does seem like dispatching<br>&gt; synchronously is the rare and special case.<br>&gt;<br>&gt; Could there be just a single dispatch() method, with async as a flag with<br>&gt; a default value of true?<br>&gt;<br>&gt; It might be a little ugly because most of the other parameters of the<br>&gt; proposed asynchronously() method would not apply in the sync case.<br>&gt;<br></p><p>This is a nice idea, but unfortunately it would defeat the ability to use<br>@noescape/rethrows/generic-return-type for the sync version.<br></p><p><br>&gt; James<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;<br>&gt; Jacob Bandes-Storch suggested:<br>&gt;<br>&gt; synchronously(execute work: …)<br>&gt;<br>&gt;<br>This wasn&#39;t meant to be a suggestion for the name, just pointing out what<br>might have been a typo/inconsistency in the proposal.<br></p><p>Jacob<br></p><p>&gt;<br>&gt; So maybe that will conform to the API naming guideline?  Or would the verb<br>&gt; have to be in the base name of the func?<br>&gt;<br>&gt; Or perhaps:<br>&gt;<br>&gt; synchronously(dispatch work: …)<br>&gt; asynchronously(dispatch work: …)<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The method names<br>&gt;<br>&gt; synchronously()<br>&gt; asynchronously()<br>&gt;<br>&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt; These methods have side effects, so each name should have a verb in it to<br>&gt; make it a verb phrase.<br>&gt;<br>&gt;<br>&gt; Since these are the methods where you actually dispatch a block into a<br>&gt; queue<br>&gt;<br>&gt; dispatchSynchronously()<br>&gt; dispatchAsynchronously()<br>&gt;<br>&gt; would include the verb in the name of the methods.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/f3530e8e/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>May 11, 2016 at 11:00:00pm</p></header><div class="content"><p>For synchronously and asynchronously how about the adverbs before the verb:<br></p><p>syncDispatch()<br>asyncDispatch()<br></p><p>?<br></p><p>&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt; <br>&gt; <br>&gt; It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br>&gt; <br>&gt; In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br>&gt; <br>&gt; At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br>&gt; <br>&gt; <br>&gt; Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br>&gt; <br>&gt; Could there be just a single dispatch() method, with async as a flag with a default value of true?<br>&gt; <br>&gt; It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br>&gt; <br>&gt; James<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Jacob Bandes-Storch suggested:<br>&gt;&gt; <br>&gt;&gt; synchronously(execute work: …)<br>&gt;&gt; <br>&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt; <br>&gt;&gt; Or perhaps:<br>&gt;&gt; <br>&gt;&gt; synchronously(dispatch work: …)<br>&gt;&gt; asynchronously(dispatch work: …)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The method names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	synchronously()<br>&gt;&gt;&gt; 	asynchronously() <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; dispatchSynchronously()<br>&gt;&gt;&gt; dispatchAsynchronously()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; would include the verb in the name of the methods.<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/bb810e52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/68d21c811b4f037d9cbd43013319f9b4?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Muse M</string> &lt;james.lei65 at gmail.com&gt;<p>May 12, 2016 at 11:00:00am</p></header><div class="content"><p>I would prefer a space before Dispatch() and this could allows developer to<br>extend new and custom features like fastasync, multithread, benchmark,<br>fifo, etc.Just an opinion.<br></p><p>sync Dispatch()<br>async Dispatch()<br></p><p>On Thu, May 12, 2016 at 11:02 AM, Ricardo Parada via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; For synchronously and asynchronously how about the adverbs before the verb:<br>&gt;<br>&gt; syncDispatch()<br>&gt; asyncDispatch()<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com&gt; wrote:<br>&gt;<br>&gt; So maybe that will conform to the API naming guideline?  Or would the verb<br>&gt; have to be in the base name of the func?<br>&gt;<br>&gt;<br>&gt; It seems from the guidelines that the intent is for the verb to be in the<br>&gt; base name of the func, especially since there is another set of guidelines<br>&gt; for naming function parameters.<br>&gt;<br>&gt; In general the other methods in the proposal are verbs (perform(),<br>&gt; notify(), wait(), cancel(), etc.)<br>&gt;<br>&gt; At least for me, not including a verb makes the API read like the sentence<br>&gt; “The dog quickly”.  This wasn’t so bad in the C API, because you could read<br>&gt; the word ‘dispatch’ as the verb.<br>&gt;<br>&gt;<br>&gt; Looking at the current GDC API, it does seem like dispatching<br>&gt; synchronously is the rare and special case.<br>&gt;<br>&gt; Could there be just a single dispatch() method, with async as a flag with<br>&gt; a default value of true?<br>&gt;<br>&gt; It might be a little ugly because most of the other parameters of the<br>&gt; proposed asynchronously() method would not apply in the sync case.<br>&gt;<br>&gt; James<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;<br>&gt; Jacob Bandes-Storch suggested:<br>&gt;<br>&gt; synchronously(execute work: …)<br>&gt;<br>&gt; So maybe that will conform to the API naming guideline?  Or would the verb<br>&gt; have to be in the base name of the func?<br>&gt;<br>&gt; Or perhaps:<br>&gt;<br>&gt; synchronously(dispatch work: …)<br>&gt; asynchronously(dispatch work: …)<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The method names<br>&gt;<br>&gt; synchronously()<br>&gt; asynchronously()<br>&gt;<br>&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt; These methods have side effects, so each name should have a verb in it to<br>&gt; make it a verb phrase.<br>&gt;<br>&gt;<br>&gt; Since these are the methods where you actually dispatch a block into a<br>&gt; queue<br>&gt;<br>&gt; dispatchSynchronously()<br>&gt; dispatchAsynchronously()<br>&gt;<br>&gt; would include the verb in the name of the methods.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/cfe60963/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/15947d27758dc90df81fd42c4a387bbb?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>James Dempsey</string> &lt;dempsey at mac.com&gt;<p>May 12, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 8:02 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; For synchronously and asynchronously how about the adverbs before the verb:<br>&gt; <br>&gt; syncDispatch()<br>&gt; asyncDispatch()<br></p><p><br>I think with the abbreviation ‘sync’ it’s very easy to read ‘sync’ as a verb and dispatch as a noun.<br></p><p>i.e. I’m going to sync up with you about our plan<br>i.e. I received a dispatch from headquarters<br></p><p>I would be very fine with<br></p><p>dispatchAsync() and dispatchSync() as method names.<br></p><p><br></p><p>&gt; <br>&gt; ?<br>&gt; <br>&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com &lt;mailto:dempsey at mac.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br>&gt;&gt; <br>&gt;&gt; In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br>&gt;&gt; <br>&gt;&gt; At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br>&gt;&gt; <br>&gt;&gt; Could there be just a single dispatch() method, with async as a flag with a default value of true?<br>&gt;&gt; <br>&gt;&gt; It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br>&gt;&gt; <br>&gt;&gt; James<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Jacob Bandes-Storch suggested:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; synchronously(execute work: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or perhaps:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; synchronously(dispatch work: …)<br>&gt;&gt;&gt; asynchronously(dispatch work: …)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The method names<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	synchronously()<br>&gt;&gt;&gt;&gt; 	asynchronously() <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt;&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; dispatchSynchronously()<br>&gt;&gt;&gt;&gt; dispatchAsynchronously()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; would include the verb in the name of the methods.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/046f52ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 12, 2016 at 08:00:00pm</p></header><div class="content"><p>dispatch() and dispatchSync() would be my preference as asynchronous dispatch is the point of GCD and synchronous dispatch is a special case and therefore I think the visual asymmetry is an advantage.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 12.05.2016 um 20:10 schrieb James Dempsey via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt;&gt; On May 11, 2016, at 8:02 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; For synchronously and asynchronously how about the adverbs before the verb:<br>&gt;&gt; <br>&gt;&gt; syncDispatch()<br>&gt;&gt; asyncDispatch()<br>&gt; <br>&gt; <br>&gt; I think with the abbreviation ‘sync’ it’s very easy to read ‘sync’ as a verb and dispatch as a noun.<br>&gt; <br>&gt; i.e. I’m going to sync up with you about our plan<br>&gt; i.e. I received a dispatch from headquarters<br>&gt; <br>&gt; I would be very fine with<br>&gt; <br>&gt; dispatchAsync() and dispatchSync() as method names.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; ?<br>&gt;&gt; <br>&gt;&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com &lt;mailto:dempsey at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could there be just a single dispatch() method, with async as a flag with a default value of true?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; James<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Jacob Bandes-Storch suggested:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; synchronously(execute work: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Or perhaps:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; synchronously(dispatch work: …)<br>&gt;&gt;&gt;&gt; asynchronously(dispatch work: …)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The method names<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	synchronously()<br>&gt;&gt;&gt;&gt;&gt; 	asynchronously() <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt;&gt;&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; dispatchSynchronously()<br>&gt;&gt;&gt;&gt;&gt; dispatchAsynchronously()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would include the verb in the name of the methods.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/94fae83c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>May 12, 2016 at 11:00:00am</p></header><div class="content"><p>Exactly: I also consider synchronous dispatch a special case not worthy of sacrificing a better name (`dispatch`) for it. I prefer to have a single `dispatch` as the main function name. Here is my proposed modified signature based on the proposal &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md&gt;:<br></p><p>class DispatchQueue : DispatchObject {<br>    func dispatch(synchronous: Bool, work: @convention(block) () -&gt; Void)<br></p><p>    func dispatch(<br>        group: DispatchGroup? = nil, <br>        qos: DispatchQoS = .unspecified, <br>        flags: DispatchWorkItemFlags = [], <br>        work: @convention(block) () -&gt; Void)<br>}<br></p><p>queue. dispatch(group: group) {<br>    print(&quot;Hello World&quot;)<br>}<br></p><p>queue.dispatch(synchronous: true) {<br>    print(&quot;Hello World&quot;)<br>}<br></p><p>In the above synchronous variant, passing synchronous flag as false simply delegates to async function. This saves us from having to use a name like dispatchSync(). <br></p><p>Actually, I currently have my own wrapper for libdispatch that works in this way. My wrapper also unifies more of the API under the same `dispatch` function with more optional parameters. For example, `apply` functions are also handled with `dispatch` function. It will iterate if `iterations:` optional parameter is specified and so on. I find it very convenient to use and the resulting code is very clear and readable.<br></p><p>I know, this goes further than importing the existing API, but concurrency API has such a profound impact on the overall style and readability of code that it is worth going even further than what proposal suggests to get a really clear and readable API.<br></p><p>Hooman <br>&gt; On May 12, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; dispatch() and dispatchSync() would be my preference as asynchronous dispatch is the point of GCD and synchronous dispatch is a special case and therefore I think the visual asymmetry is an advantage.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 12.05.2016 um 20:10 schrieb James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 8:02 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For synchronously and asynchronously how about the adverbs before the verb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; syncDispatch()<br>&gt;&gt;&gt; asyncDispatch()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think with the abbreviation ‘sync’ it’s very easy to read ‘sync’ as a verb and dispatch as a noun.<br>&gt;&gt; <br>&gt;&gt; i.e. I’m going to sync up with you about our plan<br>&gt;&gt; i.e. I received a dispatch from headquarters<br>&gt;&gt; <br>&gt;&gt; I would be very fine with<br>&gt;&gt; <br>&gt;&gt; dispatchAsync() and dispatchSync() as method names.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com &lt;mailto:dempsey at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could there be just a single dispatch() method, with async as a flag with a default value of true?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; James<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob Bandes-Storch suggested:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; synchronously(execute work: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or perhaps:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; synchronously(dispatch work: …)<br>&gt;&gt;&gt;&gt;&gt; asynchronously(dispatch work: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The method names<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	synchronously()<br>&gt;&gt;&gt;&gt;&gt;&gt; 	asynchronously() <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt;&gt;&gt;&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; dispatchSynchronously()<br>&gt;&gt;&gt;&gt;&gt;&gt; dispatchAsynchronously()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would include the verb in the name of the methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/6e0e3ec9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 12, 2016 at 06:00:00pm</p></header><div class="content"><p>This would defeat @noescape and any generic return type we might want to<br>add to dispatchSync.<br>On Thu, May 12, 2016 at 11:52 AM Hooman Mehr via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; Exactly: I also consider synchronous dispatch a special case not worthy of<br>&gt; sacrificing a better name (`dispatch`) for it. I prefer to have a single<br>&gt; `dispatch` as the main function name. Here is my proposed modified<br>&gt; signature based on the proposal<br>&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md&gt;<br>&gt; :<br>&gt;<br>&gt; class DispatchQueue : DispatchObject {<br>&gt;     func dispatch(synchronous: Bool, work: @convention(block) () -&gt; Void)<br>&gt;<br>&gt;<br>&gt;<br>&gt; func dispatch(<br>&gt;         group: DispatchGroup? = nil,<br>&gt;         qos: DispatchQoS = .unspecified,<br>&gt;         flags: DispatchWorkItemFlags = [],<br>&gt;         work: @convention(block) () -&gt; Void<br>&gt;<br>&gt; )<br>&gt; }<br>&gt;<br>&gt; queue. dispatch(group: group) {<br>&gt;     print(&quot;Hello World&quot;)<br>&gt; }<br>&gt;<br>&gt; queue.dispatch(synchronous: true) {<br>&gt;     print(&quot;Hello World&quot;)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; In the above synchronous variant, passing synchronous flag as false simply<br>&gt; delegates to async function. This saves us from having to use a name like<br>&gt; dispatchSync().<br>&gt;<br>&gt; Actually, I currently have my own wrapper for libdispatch that works in<br>&gt; this way. My wrapper also unifies more of the API under the same `dispatch`<br>&gt; function with more optional parameters. For example, `apply` functions are<br>&gt; also handled with `dispatch` function. It will iterate if `iterations:`<br>&gt; optional parameter is specified and so on. I find it very convenient to use<br>&gt; and the resulting code is very clear and readable.<br>&gt;<br>&gt; I know, this goes further than importing the existing API, but concurrency<br>&gt; API has such a profound impact on the overall style and readability of code<br>&gt; that it is worth going even further than what proposal suggests to get a<br>&gt; really clear and readable API.<br>&gt;<br>&gt; Hooman<br>&gt;<br>&gt; On May 12, 2016, at 11:16 AM, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; dispatch() and dispatchSync() would be my preference as asynchronous<br>&gt; dispatch is the point of GCD and synchronous dispatch is a special case and<br>&gt; therefore I think the visual asymmetry is an advantage.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Am 12.05.2016 um 20:10 schrieb James Dempsey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 8:02 PM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt;<br>&gt; For synchronously and asynchronously how about the adverbs before the verb:<br>&gt;<br>&gt; syncDispatch()<br>&gt; asyncDispatch()<br>&gt;<br>&gt;<br>&gt;<br>&gt; I think with the abbreviation ‘sync’ it’s very easy to read ‘sync’ as a<br>&gt; verb and dispatch as a noun.<br>&gt;<br>&gt; i.e. I’m going to sync up with you about our plan<br>&gt; i.e. I received a dispatch from headquarters<br>&gt;<br>&gt; I would be very fine with<br>&gt;<br>&gt; dispatchAsync() and dispatchSync() as method names.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; ?<br>&gt;<br>&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com&gt; wrote:<br>&gt;<br>&gt; So maybe that will conform to the API naming guideline?  Or would the verb<br>&gt; have to be in the base name of the func?<br>&gt;<br>&gt;<br>&gt; It seems from the guidelines that the intent is for the verb to be in the<br>&gt; base name of the func, especially since there is another set of guidelines<br>&gt; for naming function parameters.<br>&gt;<br>&gt; In general the other methods in the proposal are verbs (perform(),<br>&gt; notify(), wait(), cancel(), etc.)<br>&gt;<br>&gt; At least for me, not including a verb makes the API read like the sentence<br>&gt; “The dog quickly”.  This wasn’t so bad in the C API, because you could read<br>&gt; the word ‘dispatch’ as the verb.<br>&gt;<br>&gt;<br>&gt; Looking at the current GDC API, it does seem like dispatching<br>&gt; synchronously is the rare and special case.<br>&gt;<br>&gt; Could there be just a single dispatch() method, with async as a flag with<br>&gt; a default value of true?<br>&gt;<br>&gt; It might be a little ugly because most of the other parameters of the<br>&gt; proposed asynchronously() method would not apply in the sync case.<br>&gt;<br>&gt; James<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com&gt; wrote:<br>&gt;<br>&gt; Jacob Bandes-Storch suggested:<br>&gt;<br>&gt; synchronously(execute work: …)<br>&gt;<br>&gt; So maybe that will conform to the API naming guideline?  Or would the verb<br>&gt; have to be in the base name of the func?<br>&gt;<br>&gt; Or perhaps:<br>&gt;<br>&gt; synchronously(dispatch work: …)<br>&gt; asynchronously(dispatch work: …)<br>&gt;<br>&gt;<br>&gt;<br>&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; The method names<br>&gt;<br>&gt; synchronously()<br>&gt; asynchronously()<br>&gt;<br>&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt; These methods have side effects, so each name should have a verb in it to<br>&gt; make it a verb phrase.<br>&gt;<br>&gt;<br>&gt; Since these are the methods where you actually dispatch a block into a<br>&gt; queue<br>&gt;<br>&gt; dispatchSynchronously()<br>&gt; dispatchAsynchronously()<br>&gt;<br>&gt; would include the verb in the name of the methods.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/f65eb852/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 13, 2016 at 02:00:00pm</p></header><div class="content"><p>+1 to naming like this. dispatch() and dispatchSynchronously() if needed to please thy naming gods.<br></p><p><br>&gt; On 13 May 2016, at 4:16 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; dispatch() and dispatchSync() would be my preference as asynchronous dispatch is the point of GCD and synchronous dispatch is a special case and therefore I think the visual asymmetry is an advantage.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 12.05.2016 um 20:10 schrieb James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 8:02 PM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For synchronously and asynchronously how about the adverbs before the verb:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; syncDispatch()<br>&gt;&gt;&gt; asyncDispatch()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I think with the abbreviation ‘sync’ it’s very easy to read ‘sync’ as a verb and dispatch as a noun.<br>&gt;&gt; <br>&gt;&gt; i.e. I’m going to sync up with you about our plan<br>&gt;&gt; i.e. I received a dispatch from headquarters<br>&gt;&gt; <br>&gt;&gt; I would be very fine with<br>&gt;&gt; <br>&gt;&gt; dispatchAsync() and dispatchSync() as method names.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 10:50 AM, James Dempsey &lt;dempsey at mac.com &lt;mailto:dempsey at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It seems from the guidelines that the intent is for the verb to be in the base name of the func, especially since there is another set of guidelines for naming function parameters.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In general the other methods in the proposal are verbs (perform(), notify(), wait(), cancel(), etc.)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; At least for me, not including a verb makes the API read like the sentence “The dog quickly”.  This wasn’t so bad in the C API, because you could read the word ‘dispatch’ as the verb.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Looking at the current GDC API, it does seem like dispatching synchronously is the rare and special case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could there be just a single dispatch() method, with async as a flag with a default value of true?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It might be a little ugly because most of the other parameters of the proposed asynchronously() method would not apply in the sync case.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; James<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 11, 2016, at 7:14 AM, Ricardo Parada &lt;rparada at mac.com &lt;mailto:rparada at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Jacob Bandes-Storch suggested:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; synchronously(execute work: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; So maybe that will conform to the API naming guideline?  Or would the verb have to be in the base name of the func?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Or perhaps:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; synchronously(dispatch work: …)<br>&gt;&gt;&gt;&gt;&gt; asynchronously(dispatch work: …)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 11, 2016, at 9:32 AM, James Dempsey via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The method names<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	synchronously()<br>&gt;&gt;&gt;&gt;&gt;&gt; 	asynchronously() <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; are both adverbs, not noun phrases or verb phrases.<br>&gt;&gt;&gt;&gt;&gt;&gt; These methods have side effects, so each name should have a verb in it to make it a verb phrase.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Since these are the methods where you actually dispatch a block into a queue<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; dispatchSynchronously()<br>&gt;&gt;&gt;&gt;&gt;&gt; dispatchAsynchronously()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; would include the verb in the name of the methods.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/1804f4be/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f50a7532821edd503161abf3f2eb87cd?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Cole Campbell</string> &lt;cole.m.campbell at icloud.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; My main piece of feedback is that the method names synchronously() and asynchronously() don’t conform to Swift 3 naming conventions for functions and methods:<br></p><p>I agree.<br></p><p>&gt; dispatchAsynch()<br>&gt; dispatchSynch()<br></p><p>I prefer something like this. It feels more Swifty. As it is, they aren&#39;t any longer than asynchronously(), if name length is a concern.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/3fc168f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b3592d65fd9318ba2f2b70379835526b?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Sean Heber</string> &lt;sean at fifthace.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>I don’t know if this is a problem per-say, but very likely the API would often be used in code looking more like this:<br></p><p>DispatchQueue.main.dispatchAsynch {<br> // stuff<br>}<br></p><p>And maybe this is just me, but the double occurrence of the word “dispatch” in there rubs me the wrong way. :P<br></p><p>This is probably silly, but we’re dealing with a “queue” here, so in some ways, could’t we “add” work to the queues or something?<br></p><p>DispatchQueue.main.add(.asynchronously) {<br> // async..<br>}<br></p><p>l8r<br>Sean<br></p><p><br>&gt; On May 11, 2016, at 10:10 AM, Cole Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; My main piece of feedback is that the method names synchronously() and asynchronously() don’t conform to Swift 3 naming conventions for functions and methods:<br>&gt; <br>&gt; I agree.<br>&gt; <br>&gt;&gt; dispatchAsynch()<br>&gt;&gt; dispatchSynch()<br>&gt; <br>&gt; I prefer something like this. It feels more Swifty. As it is, they aren&#39;t any longer than asynchronously(), if name length is a concern.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f50a7532821edd503161abf3f2eb87cd?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Cole Campbell</string> &lt;cole.m.campbell at icloud.com&gt;<p>May 11, 2016 at 10:00:00am</p></header><div class="content"><p>Sorry, I realized after seeing Darren&#39;s message that I made a mistake. The abbreviation doesn&#39;t end with &#39;h&#39;. It should be:<br></p><p>dispatchAsync()<br>dispatchSync()<br></p><p>&gt; On May 11, 2016, at 10:10 AM, Cole Campbell via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; My main piece of feedback is that the method names synchronously() and asynchronously() don’t conform to Swift 3 naming conventions for functions and methods:<br>&gt; <br>&gt; I agree.<br>&gt; <br>&gt;&gt; dispatchAsynch()<br>&gt;&gt; dispatchSynch()<br>&gt; <br>&gt; I prefer something like this. It feels more Swifty. As it is, they aren&#39;t any longer than asynchronously(), if name length is a concern.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/98d97b38/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d9dbc0dfeb74eab8dd9bbd9cbd84680?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Jose Cheyo Jimenez</string> &lt;cheyo at masters3d.com&gt;<p>May 11, 2016 at 07:00:00am</p></header><div class="content"><p>I like the idea. <br></p><p>I didn&#39;t see these function but I am not sure if they are part of that library. <br></p><p>dispatch_queue_create(&quot;uniqueName&quot;, DISPATCH_QUEUE_CONCURRENT)<br></p><p>dispatch_apply(someInt, queue){....<br></p><p>&gt; On May 10, 2016, at 9:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt;    https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt;    * What is your evaluation of the proposal?<br>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt;    https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/426fbd3d9b662663dc5647b08c4e3410?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Anders Ha</string> &lt;hello at andersio.co&gt;<p>May 11, 2016 at 02:00:00pm</p></header><div class="content"><p>1. What is your evaluation of the proposal?<br></p><p>+1 on the proposal’s objective - the swiftification of libdispatch is greatly appreciated. But I have reservation in the particulars of the proposal which are not in line with the API Design Guidelines.<br></p><p>For example, the `getSpecific(_:)` instance method in `DispatchQueue` is supposed to have no side effect like `NSObject.value(_:)` - just the retrieval of the value. But it somehow has a `get` suffix in the method name. Likewise, the class function `getSpecific(_:)` has a similar issue, but also not describing the behaviour precisely enough. Shouldn’t it be something like`specificForCurrentQueue(_:)`?<br></p><p>On the other hand, The adverbs used by `synchronously(_:)` and `asynchornously(_:)` in `DispatchQueue` fits nowhere in the guidelines, which (generally speaking) requires either imperative verb for functions having side-effects, or nouns for whatever else. Both functions clearly have a side effect on the queue, be it performing atomics or appending a block. IMO these should be verbs describing the behaviour, like `sync`, `synchronize`, `perform`, `performAndWait`, `schedule` or `run`.<br></p><p><br>queue.synchronously(block)   // Is this grammatical? :-[  <br></p><p><br>One may argue these adverbs are term of arts, but then why not simply use the short form (`async` and `sync`) from the C API, which is less verbose and could even possibly be implied as imperative verbs? Say `async` and `sync` as a shorthand of `asynchronize` * and `synchronise`.<br></p><p>* this doesn’t formally exist… yet.<br></p><p>2. Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes. It should improve the experience of Swift developers, since libdispatch is heavily used in the Cocoa platforms. Autocompletion would have less noise, and the interface is cleaner to work with.<br></p><p>3. Does this proposal fit well with the feel and direction of Swift?<br>Yes.<br></p><p>4. If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>There are a few wrappers on GitHub that serves a similar purpose. But it is always great to have less dependency, especially for things that are essential like libdispatch.<br></p><p>5. How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>A focused study on the `DispatchQueue` renaming, since it would be the thing affecting me the most.<br></p><p>&gt; On 11 May 2016, at 12:39 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/0cebb834/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 11, 2016 at 06:00:00pm</p></header><div class="content"><p>1. What is your evaluation of the proposal?<br>+1 I think this is a big win for readability.<br></p><p>2. Is the problem being addressed significant enough to warrant a change to Swift?<br>Yes. dispatch is used nearly everywhere so many many projects would benefit from it.<br></p><p>3. Does this proposal fit well with the feel and direction of Swift?<br>Making the API more “swift&quot; and feel more natural definitely is the direction Swift libraries are / should be going in.<br></p><p>4. If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>Unfortunately not.<br></p><p>5. How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>Read the proposal twice.<br></p><p>A little nitpick:<br></p><p>let item = DispatchWorkItem(qos: .qosUserInitiated) {<br>    print(&quot;Hello World&quot;)<br>}<br></p><p>I’d change the enum case from .qosUserInitiated to .userInitiated (maybe that’s just a typo since in the code example before uses .unspecified).<br></p><p>- Dennis<br></p><p>&gt; On May 11, 2016, at 6:39 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution-announce mailing list<br>&gt; swift-evolution-announce at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/f1d1fa80/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0db24e79de1d6e82cf6327b091903b1b?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Pierre Habouzit</string> &lt;phabouzit at apple.com&gt;<p>May 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On May 11, 2016, at 9:02 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; 1. What is your evaluation of the proposal?<br>&gt; +1 I think this is a big win for readability.<br>&gt; <br>&gt; 2. Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; Yes. dispatch is used nearly everywhere so many many projects would benefit from it.<br>&gt; <br>&gt; 3. Does this proposal fit well with the feel and direction of Swift?<br>&gt; Making the API more “swift&quot; and feel more natural definitely is the direction Swift libraries are / should be going in.<br>&gt; <br>&gt; 4. If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; Unfortunately not.<br>&gt; <br>&gt; 5. How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; Read the proposal twice.<br>&gt; <br>&gt; A little nitpick:<br>&gt; <br>&gt; let item = DispatchWorkItem(qos: .qosUserInitiated) {<br>&gt;     print(&quot;Hello World&quot;)<br>&gt; }<br>&gt; <br>&gt; I’d change the enum case from .qosUserInitiated to .userInitiated (maybe that’s just a typo since in the code example before uses .unspecified).<br></p><p>I think it is a typo, only default needs to be qosDefault because default is a keyword, and asking all users to back-tick it isn’t really good either.<br>(also no one should really specify qos class default anyway).<br></p><p>&gt; <br>&gt; - Dennis<br>&gt; <br>&gt;&gt; On May 11, 2016, at 6:39 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md&gt;<br>&gt;&gt; <br>&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt; <br>&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt; <br>&gt;&gt; What goes into a review?<br>&gt;&gt; <br>&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt; swift-evolution-announce at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/1bbe37c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 12, 2016 at 09:00:00am</p></header><div class="content"><p>- Dennis<br></p><p>&gt; On May 12, 2016, at 9:34 AM, Pierre Habouzit &lt;phabouzit at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; On May 11, 2016, at 9:02 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; 1. What is your evaluation of the proposal?<br>&gt;&gt; +1 I think this is a big win for readability.<br>&gt;&gt; <br>&gt;&gt; 2. Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; Yes. dispatch is used nearly everywhere so many many projects would benefit from it.<br>&gt;&gt; <br>&gt;&gt; 3. Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; Making the API more “swift&quot; and feel more natural definitely is the direction Swift libraries are / should be going in.<br>&gt;&gt; <br>&gt;&gt; 4. If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; Unfortunately not.<br>&gt;&gt; <br>&gt;&gt; 5. How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; Read the proposal twice.<br>&gt;&gt; <br>&gt;&gt; A little nitpick:<br>&gt;&gt; <br>&gt;&gt; let item = DispatchWorkItem(qos: .qosUserInitiated) {<br>&gt;&gt;     print(&quot;Hello World&quot;)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I’d change the enum case from .qosUserInitiated to .userInitiated (maybe that’s just a typo since in the code example before uses .unspecified).<br>&gt; <br>&gt; I think it is a typo, only default needs to be qosDefault because default is a keyword, and asking all users to back-tick it isn’t really good either.<br>&gt; (also no one should really specify qos class default anyway).<br></p><p>Even .default should be okay once SE-0071 &lt;https://github.com/apple/swift-evolution/blob/23da9e94fd9580e59bdae50abf122d3d3c852a8f/proposals/0071-member-keywords.md&gt; is implemented.<br></p><p>&gt;&gt; <br>&gt;&gt; - Dennis<br>&gt;&gt; <br>&gt;&gt;&gt; On May 11, 2016, at 6:39 AM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello Swift community,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What goes into a review?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt;&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thank you,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris Lattner<br>&gt;&gt;&gt; Review Manager<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution-announce mailing list<br>&gt;&gt;&gt; swift-evolution-announce at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution-announce<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/91bbbdf0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 12, 2016 at 10:00:00pm</p></header><div class="content"><p>On May 12, 2016, at 12:59 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; let item = DispatchWorkItem(qos: .qosUserInitiated) {<br>&gt;&gt;&gt;     print(&quot;Hello World&quot;)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’d change the enum case from .qosUserInitiated to .userInitiated (maybe that’s just a typo since in the code example before uses .unspecified).<br>&gt;&gt; <br>&gt;&gt; I think it is a typo, only default needs to be qosDefault because default is a keyword, and asking all users to back-tick it isn’t really good either.<br>&gt;&gt; (also no one should really specify qos class default anyway).<br>&gt; <br>&gt; Even .default should be okay once SE-0071 &lt;https://github.com/apple/swift-evolution/blob/23da9e94fd9580e59bdae50abf122d3d3c852a8f/proposals/0071-member-keywords.md&gt; is implemented.<br></p><p>SE-0071 is implemented already.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160512/b3300548/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ec8a60462a511e833c5c4a83b424c958?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Dennis Weissmann</string> &lt;dennis at dennisweissmann.me&gt;<p>May 13, 2016 at 08:00:00am</p></header><div class="content"><p>Awesome! :) You are too fast to follow up!<br></p><p>- Dennis<br>Sent from my iPhone<br></p><p>&gt; On May 13, 2016, at 7:02 AM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On May 12, 2016, at 12:59 AM, Dennis Weissmann via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; let item = DispatchWorkItem(qos: .qosUserInitiated) {<br>&gt;&gt;&gt;&gt;     print(&quot;Hello World&quot;)<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’d change the enum case from .qosUserInitiated to .userInitiated (maybe that’s just a typo since in the code example before uses .unspecified).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it is a typo, only default needs to be qosDefault because default is a keyword, and asking all users to back-tick it isn’t really good either.<br>&gt;&gt;&gt; (also no one should really specify qos class default anyway).<br>&gt;&gt; <br>&gt;&gt; Even .default should be okay once SE-0071 is implemented.<br>&gt; <br>&gt; SE-0071 is implemented already.<br>&gt; <br>&gt; -Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/1e48dfe4/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 2382 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160513/1e48dfe4/attachment.p7s&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76eb9711d45c1c9a71c0f24004072a22?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Zach Waldowski</string> &lt;zach at waldowski.me&gt;<p>May 11, 2016 at 01:00:00pm</p></header><div class="content"><p>I don&#39;t recall seeing this proposal being pitched, and will also include<br>feedback of that stripe. Other responses inline.<br></p><p>On Wed, May 11, 2016, at 12:39 AM, Chris Lattner via swift-evolution<br>wrote:<br>&gt; 	* What is your evaluation of the proposal?<br></p><p>Strong +1 in concept. I&#39;m thrilled that this might happen.<br></p><p>+0 in current implementation. The proposal as written does not fully<br>conform to Swift API standards and does not fully address the current<br>surface area of the Dispatch API. I am concerned about losing features<br>and performance in our haste to make something &quot;more Swifty.&quot;<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>GCD&#39;s lack of integration with Swift — in part from the contusions the<br>API performs to be compatible with multiple languages at the API level<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>See other feedback below. Making changes in general is very much a good<br>idea. The APIs described do not always fit with Swift.<br></p><p>Separate from the APIs described herein, I am curious as to how much of<br>what needs to be done can or should be accomplished with apinotes and<br>the auditing facilities from SE-0044; it seems like <br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>With additions, the resulting API would be a nice improvement and go a<br>long way to making Swift feel like it has high-level multithreading<br>support.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>In-depth study. I am an aggressive user of GCD in Swift.<br></p><p>---<br></p><p>## Type Naming and Structures<br></p><p>The namespace of GCD is already &quot;Dispatch&quot;. The existing types in the<br>proposal are translating from snake-case to camel-case; this isn&#39;t<br>wholly necessary to me as Swift doesn&#39;t suffer from C&#39;s global<br>namespace.<br></p><p>dispatch_object_t is obviously a problem in this respect, but its use is<br>already fuzzy in current GCD (incl. in other languages; its use in C is<br>equally sketchy). I almost feel like the features of dispatch_object_t<br>should be encapsulated in protocols. (resume, cancel, etc.)<br></p><p>## Missing API<br></p><p>- Group, IO, and Semaphore are missing in their entirety.<br>- Data needs init() to match the dispatch_data_empty constant.<br>- There&#39;s no equivalent to dispatch_data_copy_region(3), which can be<br>used to step through the contiguous buffers (among other things).<br>- The shared functionality of dispatch_get_context(1),<br>dispatch_set_context(2), and dispatch_set_finalizer_f(2) are not<br>modeled.<br>- The shared functionality of dispatch_suspend(2) and dispatch_resume(2)<br>are not modeled.<br>- Queue has no getters for its label and QoS class.<br>- Queues do not have any modeling for their target queue.<br>- Custom queues cannot be created.<br>- dispatch_barrier_sync(2) is not represented. (Neither is<br>dispatch_barrier_async(2), but this is modeled by<br>DispatchWorkItemFlags.)<br>- No equivalents for dispatch_apply(3), dispatch_main(),<br>dispatch_after(3).<br></p><p>## API comments<br></p><p>- WorkItem<br>   * DispatchQueue.asynchronously(_:qos:flags:work:) should have a<br>   variant that takes a DispatchWorkItem. With the API as written, you<br>   could not enqueue a work item then cancel it.<br>   * Flags should be a nested type.<br></p><p>- Source<br>   * The details section needs examples of at least one of the<br>   DispatchSource protocols (i.e., DispatchSourceFileSystemObject). The<br>   current approach would seem to lose API inherited from DispatchSource<br>   and DispatchObject unless those are modeled in some other way.<br>   * None of Source&#39;s APIs for assigning handlers, configuring timers,<br>   getting or merging the user-defined data, or cancelling are exposed.<br></p><p>- Data<br>   * Overall, the API does not encapsulate dispatch_data_t&#39;s status as a<br>   tree of discontiguous buffers. I&#39;d expect at least to have API to<br>   have a view of the contiguous buffers, for instance.<br>   * The alternate forms of append(_:) don&#39;t address management of the<br>   appended buffer&#39;s memory. Do they copy?<br>   * What are the COW semantics? In-place mutation is not thread-safe,<br>   whereas dispatch_data_t&#39;s current concatenation mechanisms are.<br>   * enumerateBytes(_:) is unclear, as it is enumerating the underlying<br>   byte buffers.<br></p><p>- Queue<br>   * Queue.asynchronously(group:qos:flags:work:) and<br>   Queue.synchronously(_:) does not conform to the API guidelines.<br>   * Queue.synchronously(_:) should be @noescape. If possible,<br>   rethrowing and returning a &lt;T&gt; would be optimal.<br></p><p>Sincerely,<br>  Zachary Waldowski<br>  zach at waldowski.me<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7abf2ce34651dd5e97cd97b16ce21bae?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Guillaume Lessard</string> &lt;glessard at tffenterprises.com&gt;<p>May 11, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>I like it; with the fixes already mentioned by Matt, I have some extra comments and questions:<br></p><p>- It would be nicer to use the Dispatch namespace, rather than prefix everything.<br>- It seems unfortunate to have 11 DispatchSourceSUBTYPE protocols at top level.<br></p><p>- DispatchQueue initialization is only implied; its initializer(s) should be described<br></p><p>- dispatch_queue_get_qos_class and dispatch_set_target_queue are not mentioned.<br>- dispatch_after and dispatch_apply aren’t mentioned either.<br></p><p>- dispatch_suspend and dispatch_resume; would these be available on DispatchObject or just some of its subclasses?<br></p><p>- dispatch_set_context, dispatch_get_context, and dispatch_set_finalizer; do those stay or disappear?<br></p><p>- please describe the api related to dispatch_io_t<br></p><p><br>Other comments:<br></p><p>- Queue.{synchronously,asynchronously} are odd names for Swift. Since the labels include a verb, I feel they’re fine, though.<br>The suggestion of `dispatchSynchronously` is too long; `dispatchSync` is not better than the adverb; just `sync` is unclear (the verb would be synchronize, which is wrong.)<br></p><p><br>&gt; * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. Using libdispatch with the old api is okay, but weird.<br></p><p>&gt; * Does this proposal fit well with the feel and direction of Swift?<br></p><p>Mostly; I’m sure it will after the feedback.<br></p><p>&gt; * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I’ve been a libdispatch user in Swift since the beginning: I’ve formed opinions. I read the proposal carefully.<br></p><p>Guillaume Lessard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2ddf7419fbdd69635522af227c08327c?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>David P Grove</string> &lt;groved at us.ibm.com&gt;<p>May 11, 2016 at 04:00:00pm</p></header><div class="content"><p>My personal opinions, as someone who is relatively new to Swift and<br>libdispatch, but has spent some time playing with them recently ;)<br></p><p>&gt;    * What is your evaluation of the proposal?<br></p><p>Overall, I like the direction of the proposal.  I think moving away from<br>the legacy C APIs will make libdispatch in Swift more accessible and<br>pleasant to use.<br></p><p>I would like to see more details on how the overlay will be implemented on<br>platforms without Objective-C.  Specifically, since libdispatch is mostly a<br>C library, it seems to me that this would be a good opportunity to purge<br>Objective-C from the libdispatch implementation entirely and have a simpler<br>and more portable Swift + C implementation.  That is what we have to do for<br>Linux, so let&#39;s eliminate some of the platform differences and do it<br>everywhere.  However, that may be at odds with the &quot;without adding runtime<br>overhead&quot; objective of the proposal.  I made an attempt earlier this spring<br>to get libdispatch&#39;s C structs to masquerade as Swift classes (instead of<br>Objective-C classes as they currently do when Objective-C is available).  I<br>gave up because some of the implementation tricks used in libdispatch&#39;s<br>queues made it a fairly invasive change.  However, others more skilled in<br>Swift+libdispatch might be able to pull it off.  Is the implementation plan<br>to write a fairly thick Swift layer that wraps primitive C types, or is it<br>something else?<br></p><p>Echoing others, I would keep sync/async as names in the APIs. These are<br>well known terms that are used in many similar tasking libraries in other<br>languages; they are also familiar to current libdispatch users.<br></p><p>I would like to see a statically checkable distinction in the API between<br>Darwin-specific functionality and the APIs that are truly cross platform.<br>This mainly shows up in the DispatchSources portion of the API.  Tag<br>methods of DispatchSource with availability macros or similar?<br></p><p>It seems overly verbose to prefix all the types with Dispatch....is this<br>really necessary?<br></p><p><br>&gt;    * Is the problem being addressed significant enough to warrant a<br>change to Swift?<br></p><p>&gt;From a Linux perspective, the existing Swift libdispatch API is badly<br>incomplete. The lack of Objective-C on Linux results in a poor quality<br>import of the dispatch headers.  Something needs to be done in the Swift 3<br>time frame to fix this.  We could get by with a less sweeping change than<br>this proposal, but something does need to be done.<br></p><p>Ideally, the new overlay would also be back-ported to Swift 2.2 to address<br>Drew&#39;s valid concerns about maintaining cross-platform code that uses<br>libdispatch during the transition from Swift 2.2 to Swift 3.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>	Yes (but I am newish to Swift...).<br></p><p>&gt;    * If you have used other languages or libraries with a similar<br>&gt; feature, how do you feel that this proposal compares to those?<br></p><p>	It should get libdispatch in Swift to be roughly on par with the<br>integrated experience one gets from using tasking libraries in other modern<br>object-oriented languages with closures.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick<br>&gt; reading, or an in-depth study?<br></p><p>	Read proposal carefully.  Have thought about the issues quite a bit<br>recently.<br></p><p>--dave<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160511/815d237a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[swift-evolution-announce] [Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>I&#39;m overall in favor.<br></p><p>I agree with the others who say that `synchronously` and `asynchronously` are poor name choices. If we&#39;re going to deviate from the API guidelines, we should at least choose names which have other desirable properties, like brevity or matching existing terms of art. These names don&#39;t. I would prefer `sync` and `async`, or if necessary, `dispatchSync` and `dispatchAsync`.<br></p><p>I&#39;m very impressed by the way the &quot;specific&quot; APIs have been translated to Swift, but I think the method names are wrong, particularly the `get` method. Ideally these would be a subscript, but we don&#39;t have generic subscripts yet. Failing that, I suggest using `specificValue(for key:)` and `setSpecificValue(_ value: for key:)`. I&#39;m also worried about how this will interoperate with Objective-C: Will there be some way to smuggle one of the arbitrary Objective-C pointers for this API into Swift as a DispatchSpecificKey, or vice versa?<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. libdispatch is pretty awkward even in Objective-C, let alone in Swift.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>N/A.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>Quick reading.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May 12, 2016 at 01:00:00pm</p></header><div class="content"><p>Hello,<br></p><p>Does the proposal fixes the errors introduced by the latest May 9 snapshot ?<br></p><p>Since IUO are abolished (https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md) and pointer nullability is expressed using Optional (https://github.com/apple/swift-evolution/blob/master/proposals/0055-optional-unsafe-pointers.md), I get many errors as soon as I use libdispatch:<br></p><p>	let sem = dispatch_semaphore_create(0)<br>	dispatch_semaphore_wait(sem, …)				// Error: Value of optional type not unwrapped<br>	dispatch_semaphore_signal(sem)					// Error: Value of optional type not unwrapped<br></p><p>	let source = dispatch_source_create(…)<br>	dispatch_source_set_event_handler(source) { … }	// Error: Value of optional type not unwrapped<br>	dispatch_source_set_cancel_handler(source) { … }	// Error: Value of optional type not unwrapped<br>	dispatch_resume(source)						// Error: Value of optional type not unwrapped<br></p><p>Of course, it&#39;s easy to fix. Still, the fix is usually adding a bang (!), because most apps prefer crashing when dispatch_semaphore_create or dispatch_source_create fails. And if I don&#39;t mind using bangs when it&#39;s the best solution, I can&#39;t be happy to see bangs everywhere.<br></p><p>In short: libdispatch is currently in its worst state ever :-)<br></p><p>Cheers to all,<br>Gwendal Roué<br></p><p><br>&gt; Le 11 mai 2016 à 06:39, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0088: Modernize libdispatch for Swift 3 naming conventions&quot; begins now and runs through May 17. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0088-libdispatch-for-swift3.md<br>&gt; <br>&gt; Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br>&gt; <br>&gt; 	https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; or, if you would like to keep your feedback private, directly to the review manager.<br>&gt; <br>&gt; What goes into a review?<br>&gt; <br>&gt; The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br>&gt; <br>&gt; 	* What is your evaluation of the proposal?<br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b6a0b6562cd412f587c69d192f335161?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>plx</string> &lt;plxswift at icloud.com&gt;<p>May 13, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; 	* What is your evaluation of the proposal?<br></p><p>+1 conceptually, some quibbles.<br></p><p>I agree with a few others that `synchronously` and `asynchronously` aren’t ideal; `dispatchSynchronously` or `dispatchSync` (or `performSync` or `performSynchronously`) all seem more-appropriate.<br></p><p>I understand the impetus behind having fewer core methods, but IMHO the `dispatch_barrier_sync` and `dispatch_barrier_async` calls ought to have direct equivalents here (even if they are just sodlib-supplied conveniences that call through to the unified method).<br></p><p>I also don’t see `dispatch_apply` here anywhere; intentional? Ideally it’d be @noescape, but handling `throw` / `rethrow` for that function in this case seems complicated.<br></p><p>This next one is subjective, but I find the placement of the group-related methods somewhat backwards vis-a-vis how I think of them in terms of the C-API.<br></p><p>EG: I think of `dispatch_group_async` as a “method” on a `dispatch_group`, so would’ve expected this:<br></p><p>class DispatchGroup : DispatchObject {<br></p><p>  // (actual name should match chosen name convention)<br>  func asynchronouslyDispatch(to queue: DispatchQueue, work: @convention(block) () -&gt; Void)<br></p><p>  // (actual name should match chosen name convention)<br>  func notify(on queue: DispatchQueue, using block: @convention(block) () -&gt; Void)<br></p><p>}<br></p><p>…(and presumably the API would have manual enter/leave/wait methods and so on exposed).<br></p><p>I don’t feel strongly here but bring it up in case others feel similarly.<br></p><p>I’m a little confused about the `DispatchSpecificKey&lt;T&gt;` class; is it anything more than a way to &quot;smuggle in” a generic type parameter for the associated value? <br></p><p>Also on queue-specifics, what is our expected story if we have custom destructors? Subclass `DispatchSpecificKey`? <br></p><p>For things like `Int` specifics, I assume this API is storing auto-boxed values…? Is there any way to side-step if we use want to store an unsafe pointer? It’s not a big deal for me if we can’t under this API, TBH, but I’d at least like to see this API’s implementation and costs spelled-out more explicitly.<br></p><p>For `DispatchData`, is there a principled reason there isn’t something like this defined:<br></p><p>struct DispatchDataSegment {<br>  let bytes: UnsafeBufferPointer&lt;UInt8&gt;<br>  let byteIndex: Int<br>}<br></p><p>extension DispatchData {<br></p><p>  /// Returns a sequence that enumerates the contiguous chunks,<br>  /// e.g. a sequence with elements of type `DispatchDataSegment`.<br>  ///<br>  /// Sequence-based eplacement-for `enumerateBytes(_:)`<br>  var segmentSequence: DispatchDataSegmentSequence { get }<br></p><p>}<br></p><p>…or something analogous (instead of the proposed use dispatch_data_apply?)? <br></p><p>I don’t see any API yet for setting target queues, or getting queue labels. I know the proposal isn’t documenting the APIs in full but it’s hard to evaluate in that absence.<br></p><p>I don’t see basic API on dispatch sources yet for things like setting event handlers, (etc.); again I know the APIs aren’t fully specified here but it’s hard to evaluate something that’s not fully specified.<br></p><p><br>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/901d914d4288b1c11599f55e0a452e8c?s=50"></div><header><strong>[Review] SE-0088: Modernize libdispatch for Swift 3 naming conventions</strong> from <string>Matt Wright</string> &lt;mww at apple.com&gt;<p>May 13, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On May 13, 2016, at 9:29 AM, plx via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; 	* What is your evaluation of the proposal?<br>&gt; <br>&gt; +1 conceptually, some quibbles.<br>&gt; <br>&gt; I agree with a few others that `synchronously` and `asynchronously` aren’t ideal; `dispatchSynchronously` or `dispatchSync` (or `performSync` or `performSynchronously`) all seem more-appropriate.<br>&gt; <br>&gt; I understand the impetus behind having fewer core methods, but IMHO the `dispatch_barrier_sync` and `dispatch_barrier_async` calls ought to have direct equivalents here (even if they are just sodlib-supplied conveniences that call through to the unified method).<br></p><p>I don’t see having barrier as separate methods as a particularly good fit for Swift. Given that there are other options surrounding how a block operates when it is executed, it makes more sense as default parameters to the same methods. This avoids having to have variants of the block submission methods for both barrier, QoS, both, etc.<br></p><p>&gt; <br>&gt; I also don’t see `dispatch_apply` here anywhere; intentional? Ideally it’d be @noescape, but handling `throw` / `rethrow` for that function in this case seems complicated.<br></p><p>This is here in the updated version, though I agree it’s not simple to handle throwing out of the block as multiple threads are executing the same code at once.<br></p><p>&gt; <br>&gt; This next one is subjective, but I find the placement of the group-related methods somewhat backwards vis-a-vis how I think of them in terms of the C-API.<br></p><p>I suspect this can go either way but the block is still being executed on a given queue, you’re just associating the execution of that block with a given group. In my mind that lives on the queue, as the execution will still occur there. Contrasting this to notify, which requests that the group itself submits the notify block to the queue when the group itself is empty.<br></p><p>&gt; <br>&gt; EG: I think of `dispatch_group_async` as a “method” on a `dispatch_group`, so would’ve expected this:<br>&gt; <br>&gt; class DispatchGroup : DispatchObject {<br>&gt; <br>&gt;  // (actual name should match chosen name convention)<br>&gt;  func asynchronouslyDispatch(to queue: DispatchQueue, work: @convention(block) () -&gt; Void)<br>&gt; <br>&gt;  // (actual name should match chosen name convention)<br>&gt;  func notify(on queue: DispatchQueue, using block: @convention(block) () -&gt; Void)<br>&gt; <br>&gt; }<br>&gt; <br>&gt; …(and presumably the API would have manual enter/leave/wait methods and so on exposed).<br>&gt; <br>&gt; I don’t feel strongly here but bring it up in case others feel similarly.<br>&gt; <br>&gt; I’m a little confused about the `DispatchSpecificKey&lt;T&gt;` class; is it anything more than a way to &quot;smuggle in” a generic type parameter for the associated value? <br></p><p>I think it’s a little stronger than “smuggle in” here, it allows the compiler to enforce that you have the same type going into setSpecific that you get out of getSpecific (or DispatchQueue.getSpecific) for a given key. The C API here forces you to cast away from void* and I think this is a good example of how the Swift equivalent API is helping make things safer.<br></p><p>&gt; <br>&gt; Also on queue-specifics, what is our expected story if we have custom destructors? Subclass `DispatchSpecificKey`? <br></p><p>The value supplied to setSpecific is boxed inside a class that’s then retained. When the queue is deallocated, or the value is replaced then the box is released and normal Swift semantics for memory management will kick in on your boxed value. That way the API is still flexible enough to consume non-objects, like Ints, but also capable of taking references to classes too.<br></p><p>&gt; <br>&gt; For things like `Int` specifics, I assume this API is storing auto-boxed values…? Is there any way to side-step if we use want to store an unsafe pointer? It’s not a big deal for me if we can’t under this API, TBH, but I’d at least like to see this API’s implementation and costs spelled-out more explicitly.<br>&gt; <br>&gt; For `DispatchData`, is there a principled reason there isn’t something like this defined:<br>&gt; <br>&gt; struct DispatchDataSegment {<br>&gt;  let bytes: UnsafeBufferPointer&lt;UInt8&gt;<br>&gt;  let byteIndex: Int<br>&gt; }<br>&gt; <br>&gt; extension DispatchData {<br>&gt; <br>&gt;  /// Returns a sequence that enumerates the contiguous chunks,<br>&gt;  /// e.g. a sequence with elements of type `DispatchDataSegment`.<br>&gt;  ///<br>&gt;  /// Sequence-based eplacement-for `enumerateBytes(_:)`<br>&gt;  var segmentSequence: DispatchDataSegmentSequence { get }<br>&gt; <br>&gt; }<br></p><p>This is a good path to investigate in future improvements here.<br></p><p>&gt; <br>&gt; …or something analogous (instead of the proposed use dispatch_data_apply?)? <br>&gt; <br>&gt; I don’t see any API yet for setting target queues, or getting queue labels. I know the proposal isn’t documenting the APIs in full but it’s hard to evaluate in that absence.<br>&gt; <br>&gt; I don’t see basic API on dispatch sources yet for things like setting event handlers, (etc.); again I know the APIs aren’t fully specified here but it’s hard to evaluate something that’s not fully specified.<br></p><p>These should be present in today’s updated module listing.<br></p><p>&gt; <br>&gt; <br>&gt;&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt;&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br>&gt;&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt;&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt;&gt; <br>&gt;&gt; More information about the Swift evolution process is available at<br>&gt;&gt; <br>&gt;&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt;&gt; <br>&gt;&gt; Thank you,<br>&gt;&gt; <br>&gt;&gt; -Chris Lattner<br>&gt;&gt; Review Manager<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
