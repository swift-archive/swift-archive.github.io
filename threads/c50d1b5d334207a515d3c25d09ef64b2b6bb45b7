<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/37ed623c7e539c1e991c5be604e4a7aa?s=50"></div><header><strong>hello world takes almost 1MB of RAM</strong> from <string>Karl Pickett</string> &lt;karl.pickett at gmail.com&gt;<p>March  4, 2016 at 03:00:00pm</p></header><div class="content"><p>On ubuntu 14.4,<br>$ swiftc -v<br>Swift version 3.0-dev (LLVM b361b0fc05, Clang 11493b0f62, Swift 24a0c3de75)<br>Target: x86_64-unknown-linux-gnu<br></p><p>Sample program, compiled with simply &quot;swiftc t.swift&quot;.<br></p><p>$ cat t.swift<br>import Foundation<br>print(&quot;hello, world\n&quot;)<br>while true {<br>    sleep(1)<br>}<br></p><p>pmap -XX &lt;pid&gt; shows me 4870KB RSS, 880KB of which is private dirty /<br>anonymous.  So every additional copy you start takes 880KB of RAM.   (Our<br>use case has thousands of processes running)<br></p><p>For compariso:<br>- a dynamically linked C/glibc program takes 88KB<br>- a dynamically linked C++/glibc,libstdc++ program takes 172KB<br>- a statically linked C++/glibc,libstdc++ program takes 64KB<br>- a statically linked musl c program takes just 16KB<br></p><p>Is this on the roadmap for improvement?<br></p><p>- Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160304/c50d45b7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>hello world takes almost 1MB of RAM</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March  4, 2016 at 01:00:00pm</p></header><div class="content"><p>+Nadav<br></p><p>On Fri, Mar 4, 2016 at 1:30 PM, Karl Pickett via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; On ubuntu 14.4,<br>&gt; $ swiftc -v<br>&gt; Swift version 3.0-dev (LLVM b361b0fc05, Clang 11493b0f62, Swift 24a0c3de75)<br>&gt; Target: x86_64-unknown-linux-gnu<br>&gt;<br>&gt; Sample program, compiled with simply &quot;swiftc t.swift&quot;.<br>&gt;<br>&gt; $ cat t.swift<br>&gt; import Foundation<br>&gt; print(&quot;hello, world\n&quot;)<br>&gt; while true {<br>&gt;     sleep(1)<br>&gt; }<br>&gt;<br>&gt; pmap -XX &lt;pid&gt; shows me 4870KB RSS, 880KB of which is private dirty /<br>&gt; anonymous.  So every additional copy you start takes 880KB of RAM.   (Our<br>&gt; use case has thousands of processes running)<br>&gt;<br>&gt; For compariso:<br>&gt; - a dynamically linked C/glibc program takes 88KB<br>&gt; - a dynamically linked C++/glibc,libstdc++ program takes 172KB<br>&gt; - a statically linked C++/glibc,libstdc++ program takes 64KB<br>&gt; - a statically linked musl c program takes just 16KB<br>&gt;<br>&gt; Is this on the roadmap for improvement?<br>&gt;<br>&gt; - Karl<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br></p><p><br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18c60397fcda8f42900d42ba4db4f029?s=50"></div><header><strong>hello world takes almost 1MB of RAM</strong> from <string>Nadav Rotem</string> &lt;nrotem at apple.com&gt;<p>March  4, 2016 at 02:00:00pm</p></header><div class="content"><p>Hi Karl, <br></p><p>&gt; On Mar 4, 2016, at 1:30 PM, Karl Pickett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; On ubuntu 14.4, <br>&gt; $ swiftc -v<br>&gt; Swift version 3.0-dev (LLVM b361b0fc05, Clang 11493b0f62, Swift 24a0c3de75)<br>&gt; Target: x86_64-unknown-linux-gnu<br></p><p>Thanks for reporting this. <br></p><p>&gt; <br>&gt; Sample program, compiled with simply &quot;swiftc t.swift&quot;.<br>&gt; <br>&gt; $ cat t.swift <br>&gt; import Foundation<br>&gt; print(&quot;hello, world\n&quot;)<br>&gt; while true {<br>&gt;     sleep(1)<br>&gt; }<br></p><p>&gt; <br>&gt; pmap -XX &lt;pid&gt; shows me 4870KB RSS, 880KB of which is private dirty / anonymous.  So every additional copy you start takes 880KB of RAM.   (Our use case has thousands of processes running)<br></p><p>I compiled your program on my mac and I am seeing different numbers. On my machine, &quot;vmmap -dirty” reports ~120K of dirty memory. I wonder why there&#39;s a big difference between Mac and Linux.<br></p><p>Swift has memory overhead that’s related to caching of protocol conformances and generic metadata. Basically, Swift does not recompute type properties and does not check protocol conformances over and over again, because these operations are expensive in terms of runtime. Instead, Swift maintains a cache. <br></p><p>The ‘print’ function is a pretty big function, so in order to reduce code size in the user app we decided to keep ‘print&#39; in the standard library and not clone-and-optimize it into every single user app. The problem is that the optimizer can’t clone-and-specialize print, so print has to work with generic types. When swift works with generic types it has to access generic metadata and allocate memory for this metadata. <br></p><p>Let’s try to figure out what’s taking all the memory. Try placing a breakpoint in “main”, and then after you stop at main you can place another breakpoint in “malloc”. This will allow you to separate between allocations that happen before ‘main’ and allocations made by Swift. On my machine I am seeing allocations that come from “swift_getExistentialTypeMetadata”, “swift_getGenericMetadata”, and “swift_conformsToProtocol”. This is expected. Are you seeing other memory allocations?<br></p><p>Why are you running thousands of processes?  What are you trying to build? <br></p><p>&gt; <br>&gt; For compariso:<br>&gt; - a dynamically linked C/glibc program takes 88KB<br>&gt; - a dynamically linked C++/glibc,libstdc++ program takes 172KB<br>&gt; - a statically linked C++/glibc,libstdc++ program takes 64KB<br>&gt; - a statically linked musl c program takes just 16KB<br>&gt; <br>&gt; Is this on the roadmap for improvement?  <br></p><p>Yes, we would like to reduce Swift’s memory usage, but there is no plan to remove the protocol conformance/metadata caches. <br></p><p>Thanks,<br>Nadav<br></p><p>&gt; <br>&gt; - Karl<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>hello world takes almost 1MB of RAM</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  5, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Mar 4, 2016, at 2:43 PM, Nadav Rotem via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi Karl, <br>&gt; <br>&gt;&gt; On Mar 4, 2016, at 1:30 PM, Karl Pickett via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On ubuntu 14.4, <br>&gt;&gt; $ swiftc -v<br>&gt;&gt; Swift version 3.0-dev (LLVM b361b0fc05, Clang 11493b0f62, Swift 24a0c3de75)<br>&gt;&gt; Target: x86_64-unknown-linux-gnu<br>&gt; <br>&gt; Thanks for reporting this. <br>&gt; <br>&gt;&gt; <br>&gt;&gt; Sample program, compiled with simply &quot;swiftc t.swift&quot;.<br>&gt;&gt; <br>&gt;&gt; $ cat t.swift <br>&gt;&gt; import Foundation<br>&gt;&gt; print(&quot;hello, world\n&quot;)<br>&gt;&gt; while true {<br>&gt;&gt;    sleep(1)<br>&gt;&gt; }<br>&gt; <br>&gt;&gt; <br>&gt;&gt; pmap -XX &lt;pid&gt; shows me 4870KB RSS, 880KB of which is private dirty / anonymous.  So every additional copy you start takes 880KB of RAM.   (Our use case has thousands of processes running)<br>&gt; <br>&gt; I compiled your program on my mac and I am seeing different numbers. On my machine, &quot;vmmap -dirty” reports ~120K of dirty memory. I wonder why there&#39;s a big difference between Mac and Linux.<br>&gt; <br>&gt; Swift has memory overhead that’s related to caching of protocol conformances and generic metadata. Basically, Swift does not recompute type properties and does not check protocol conformances over and over again, because these operations are expensive in terms of runtime. Instead, Swift maintains a cache. <br>&gt; <br>&gt; The ‘print’ function is a pretty big function, so in order to reduce code size in the user app we decided to keep ‘print&#39; in the standard library and not clone-and-optimize it into every single user app. The problem is that the optimizer can’t clone-and-specialize print, so print has to work with generic types. When swift works with generic types it has to access generic metadata and allocate memory for this metadata. <br>&gt; <br>&gt; Let’s try to figure out what’s taking all the memory. Try placing a breakpoint in “main”, and then after you stop at main you can place another breakpoint in “malloc”. This will allow you to separate between allocations that happen before ‘main’ and allocations made by Swift. On my machine I am seeing allocations that come from “swift_getExistentialTypeMetadata”, “swift_getGenericMetadata”, and “swift_conformsToProtocol”. This is expected. Are you seeing other memory allocations?<br>&gt; <br>&gt; Why are you running thousands of processes?  What are you trying to build? <br>&gt; <br>&gt;&gt; <br>&gt;&gt; For compariso:<br>&gt;&gt; - a dynamically linked C/glibc program takes 88KB<br>&gt;&gt; - a dynamically linked C++/glibc,libstdc++ program takes 172KB<br>&gt;&gt; - a statically linked C++/glibc,libstdc++ program takes 64KB<br>&gt;&gt; - a statically linked musl c program takes just 16KB<br>&gt;&gt; <br>&gt;&gt; Is this on the roadmap for improvement?  <br>&gt; <br>&gt; Yes, we would like to reduce Swift’s memory usage, but there is no plan to remove the protocol conformance/metadata caches. <br></p><p>We might be able to bypass the protocol conformance cache in common cases. Strings are by far the most common thing printed, so if print did an early check for String operands and directly dispatched it, we&#39;d avoid warming up the conformance cache on something simple like print(&quot;Hello world&quot;). We might want to consider alternative designs for customized printing that rely less on expensive runtime machinery too.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
