<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  7, 2016 at 04:00:00am</p></header><div class="content"><p>As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br></p><p>Here are my reasons for allowing them:<br></p><p>1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br></p><p>2. potential opportunity to build an educational library to help explain expressions (see below)<br></p><p>infix operator plus { associativity left precedence 200 }<br></p><p>public func plus (lhs: Int, rhs: Int) -&gt; Int {<br>    <br>    return lhs + rhs<br>    <br>}<br></p><p>let totalApples = 5 plus 5<br></p><p>3. potential to write more like a sentence (this isn’t as high of a need, but again a good for entry into the language) <br></p><p>postfix operator oz { }<br>postfix operator cup { }<br>postfix operator gal { }<br></p><p>public func oz (inout _ lhs: Double) -&gt; Double {<br>    <br>    return lhs<br>    <br>}<br></p><p>public func cup (inout _ lhs: Double) -&gt; Double {<br>    <br>    return lhs *= 8.0 <br>    <br>}<br></p><p>public func gal (inout _ lhs: Double) -&gt; Double {<br>    <br>    return lhs *= 128.0<br>    <br>}<br></p><p>let totalLiquidInOunces = 5oz plus 2cup plus 1gal<br></p><p><br>I spent awhile looking to make sure this hasn’t been proposed before. I apologize if it is a repeat.<br></p><p>Thanks<br></p><p> Nerd . Designer . Developer<br>Jo Albright<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/26917f6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 11:00:00am</p></header><div class="content"><p>In a discussion about adding $ to the operator character set (it currently is an identifier character), Chris said that any token must be unambiguously either an identifier or an operator even before operators are &quot;discovered&quot;, and that&#39;s why the identifier character sets and operator character sets have no overlap right now.<br></p><p>&quot;as&quot; and &quot;is&quot; are not operators, they&#39;re keywords that were hard-coded into the grammar.<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 04:31:10, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt; <br>&gt; Here are my reasons for allowing them:<br>&gt; <br>&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt; <br>&gt; 2. potential opportunity to build an educational library to help explain expressions (see below)<br>&gt; <br>&gt; infix operator plus { associativity left precedence 200 }<br>&gt; <br>&gt; public func plus (lhs: Int, rhs: Int) -&gt; Int {<br>&gt;     <br>&gt;     return lhs + rhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; let totalApples = 5 plus 5<br>&gt; <br>&gt; 3. potential to write more like a sentence (this isn’t as high of a need, but again a good for entry into the language) <br>&gt; <br>&gt; postfix operator oz { }<br>&gt; postfix operator cup { }<br>&gt; postfix operator gal { }<br>&gt; <br>&gt; public func oz (inout _ lhs: Double) -&gt; Double {<br>&gt;     <br>&gt;     return lhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; public func cup (inout _ lhs: Double) -&gt; Double {<br>&gt;     <br>&gt;     return lhs *= 8.0 <br>&gt;     <br>&gt; }<br>&gt; <br>&gt; public func gal (inout _ lhs: Double) -&gt; Double {<br>&gt;     <br>&gt;     return lhs *= 128.0<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; let totalLiquidInOunces = 5oz plus 2cup plus 1gal<br>&gt; <br>&gt; <br>&gt; I spent awhile looking to make sure this hasn’t been proposed before. I apologize if it is a repeat.<br>&gt; <br>&gt; Thanks<br>&gt; <br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/ff3a5947/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>Jo, it sounds like you&#39;re describing infix functions. If you want to bring<br>up a concrete example, Kotlin has this implementation and it&#39;s fantastic<br>for creating your own syntactic sugar.<br></p><p>On Thu, Jan 7, 2016, 11:31 AM Félix Cloutier &lt;swift-evolution at swift.org&gt;<br>wrote:<br></p><p>&gt; In a discussion about adding $ to the operator character set (it currently<br>&gt; is an identifier character), Chris said that any token must be<br>&gt; unambiguously either an identifier or an operator even before operators are<br>&gt; &quot;discovered&quot;, and that&#39;s why the identifier character sets and operator<br>&gt; character sets have no overlap right now.<br>&gt;<br>&gt; &quot;as&quot; and &quot;is&quot; are not operators, they&#39;re keywords that were hard-coded<br>&gt; into the grammar.<br>&gt;<br>&gt; Félix<br>&gt;<br>&gt; Le 7 janv. 2016 à 04:31:10, Jo Albright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; As my obsession grows with custom operators. I have come across wanting to<br>&gt; use small words or 1-2 alphabetical characters as custom operators. I<br>&gt; noticed that “as” and “is” are character based operators and figured it<br>&gt; wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;<br>&gt; Here are my reasons for allowing them:<br>&gt;<br>&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|”<br>&gt;<br>&gt; 2. potential opportunity to build an educational library to help explain<br>&gt; expressions (see below)<br>&gt;<br>&gt; infix operator plus { associativity left precedence 200 }<br>&gt;<br>&gt; public func plus (lhs: Int, rhs: Int) -&gt; Int {<br>&gt;<br>&gt;     return lhs + rhs<br>&gt;<br>&gt; }<br>&gt;<br>&gt; let totalApples = 5 plus 5<br>&gt;<br>&gt; 3. potential to write more like a sentence (this isn’t as high of a need,<br>&gt; but again a good for entry into the language)<br>&gt;<br>&gt; postfix operator oz { }<br>&gt; postfix operator cup { }<br>&gt; postfix operator gal { }<br>&gt;<br>&gt; public func oz (inout _ lhs: Double) -&gt; Double {<br>&gt;<br>&gt;     return lhs<br>&gt;<br>&gt; }<br>&gt;<br>&gt; public func cup (inout _ lhs: Double) -&gt; Double {<br>&gt;<br>&gt;     return lhs *= 8.0<br>&gt;<br>&gt; }<br>&gt;<br>&gt; public func gal (inout _ lhs: Double) -&gt; Double {<br>&gt;<br>&gt;     return lhs *= 128.0<br>&gt;<br>&gt; }<br>&gt;<br>&gt; let totalLiquidInOunces = 5oz plus 2cup plus 1gal<br>&gt;<br>&gt;<br>&gt; I spent awhile looking to make sure this hasn’t been proposed before. I<br>&gt; apologize if it is a repeat.<br>&gt;<br>&gt; Thanks<br>&gt;<br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/68a86549/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  7, 2016 at 02:00:00pm</p></header><div class="content"><p>Answers inline.<br></p><p> Nerd . Designer . Developer<br>Jo Albright<br></p><p><br>&gt; On Jan 7, 2016, at 11:53 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; <br>&gt; Jo, it sounds like you&#39;re describing infix functions. If you want to bring up a concrete example, Kotlin has this implementation and it&#39;s fantastic for creating your own syntactic sugar.<br>&gt; <br></p><p>I am not looking to make the language change. Just want to open up flexibility for naming custom operators.<br></p><p>Currently working on a syntax sugar library for CoreGraphics drawing. Would be nice if I could do something like this :<br></p><p>typealias Point = (x: CGFloat,y: CGFloat)<br>typealias Curve = (a1: Point, a1: Point, p: Point)<br></p><p>infix operator m { associativity left precedence 200 }<br>infix operator l { associativity left precedence 200 }<br>infix operator c { associativity left precedence 200 }<br>infix operator fill { associativity left precedence 200 }<br></p><p>public func m (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>    <br>    CGContextMoveToPoint(lhs, rhs.x, rhs.y); return lhs<br>    <br>}<br></p><p>public func l (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>    <br>    CGContextAddLineToPoint(lhs, rhs.x, rhs.y); return lhs<br>    <br>}<br></p><p>public func c (lhs: CGContextRef?, rhs: Curve) -&gt; CGContextRef? {<br>    <br>    CGContextAddCurveToPoint(lhs, rhs.a1.x, rhs.a1.y, rhs.a2.x, rhs.a2.y, rhs.p.x, rhs.p.y); return lhs<br>    <br>}<br></p><p>public func fill (lhs: CGContextRef?, rhs: UIColor) {<br>    <br>    rhs.set()<br>    CGContextFillPath(lhs)<br>    <br>}<br></p><p>func drawRect(rect: CGRect) {<br>    <br>    UIGraphicsGetCurrentContext() m (10,10) l (20,20) fill UIColor.redColor()<br>    <br>}<br></p><p>I am also dreaming up a library that is not for app development, but education purposes only. I would love to have the ability to build multiple libraries that are based on different fields (economics, food, sports, etc). These libraries would be written to help students learn to write code with the focus on their favorite activities. This library would be for kids and teens to explore how to write code (possibly even adults that are looking to change fields and trying to get their head around how code works). <br></p><p>Football : (note… just through this together, would be more polished and thought out if it becomes a possibility)<br></p><p>typealias Score = Int<br>typealias Yardage = Double<br></p><p><br>struct Team {<br></p><p>	var totalYards = Yardage<br></p><p>}<br></p><p>infix operator gain { associativity left precedence 200 }<br></p><p>public func gain (inout lhs: Team, rhs: Yardage) {<br>    <br>    lhs.totalYards += rhs<br>    <br>}<br></p><p>func runPlay() {<br>    <br>    offense gain 12<br>    <br>}<br></p><p><br>&gt; On Thu, Jan 7, 2016, 11:31 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; In a discussion about adding $ to the operator character set (it currently is an identifier character), Chris said that any token must be unambiguously either an identifier or an operator even before operators are &quot;discovered&quot;, and that&#39;s why the identifier character sets and operator character sets have no overlap right now.<br>&gt; <br>&gt; &quot;as&quot; and &quot;is&quot; are not operators, they&#39;re keywords that were hard-coded into the grammar.<br></p><p>I believe having them on the operator page is confusing then. Maybe there should be an explanation on there that they are not actually operators, but just work like them… thoughts?<br>...<br>Closed range<br>None<br>Range, 135<br>is<br>Type check<br>Left associative<br>Cast, 132<br>as, as?, and as!<br>Type cast<br>Left associative<br>Cast, 132<br>??<br>Nil Coalescing<br>Right associative<br>Nil Coalescing, 131<br></p><p>&gt; Félix<br>&gt; <br>&gt;&gt; Le 7 janv. 2016 à 04:31:10, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;&gt; <br>&gt;&gt; Here are my reasons for allowing them:<br>&gt;&gt; <br>&gt;&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt;&gt; <br>&gt;&gt; 2. potential opportunity to build an educational library to help explain expressions (see below)<br>&gt;&gt; <br>&gt;&gt; infix operator plus { associativity left precedence 200 }<br>&gt;&gt; <br>&gt;&gt; public func plus (lhs: Int, rhs: Int) -&gt; Int {<br>&gt;&gt;     <br>&gt;&gt;     return lhs + rhs<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let totalApples = 5 plus 5<br>&gt;&gt; <br>&gt;&gt; 3. potential to write more like a sentence (this isn’t as high of a need, but again a good for entry into the language) <br>&gt;&gt; <br>&gt;&gt; postfix operator oz { }<br>&gt;&gt; postfix operator cup { }<br>&gt;&gt; postfix operator gal { }<br>&gt;&gt; <br>&gt;&gt; public func oz (inout _ lhs: Double) -&gt; Double {<br>&gt;&gt;     <br>&gt;&gt;     return lhs<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func cup (inout _ lhs: Double) -&gt; Double {<br>&gt;&gt;     <br>&gt;&gt;     return lhs *= 8.0 <br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public func gal (inout _ lhs: Double) -&gt; Double {<br>&gt;&gt;     <br>&gt;&gt;     return lhs *= 128.0<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let totalLiquidInOunces = 5oz plus 2cup plus 1gal<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I spent awhile looking to make sure this hasn’t been proposed before. I apologize if it is a repeat.<br>&gt;&gt; <br>&gt;&gt; Thanks<br>&gt;&gt; <br>&gt;&gt;  Nerd . Designer . Developer<br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/c1dd7d38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4b25144c09555e7d5b5e288469e011ef?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Félix Cloutier</string> &lt;felixcca at yahoo.ca&gt;<p>January  7, 2016 at 02:00:00pm</p></header><div class="content"><p>What I meant is that they&#39;re not operators in the sense that they are defined in a library. These two keywords may semantically be operators, but they are hardcoded in the language grammar to be recognized as operators. Most operators (+, -, /, %, *, etc) are not. See https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID480 &lt;https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/zzSummaryOfTheGrammar.html#//apple_ref/doc/uid/TP40014097-CH38-ID480&gt;<br></p><p>Félix<br></p><p>&gt; Le 7 janv. 2016 à 14:14:23, Jo Albright &lt;me at jo2.co&gt; a écrit :<br>&gt; <br>&gt; Answers inline.<br>&gt; <br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 11:53 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Jo, it sounds like you&#39;re describing infix functions. If you want to bring up a concrete example, Kotlin has this implementation and it&#39;s fantastic for creating your own syntactic sugar.<br>&gt;&gt; <br>&gt; <br>&gt; I am not looking to make the language change. Just want to open up flexibility for naming custom operators.<br>&gt; <br>&gt; Currently working on a syntax sugar library for CoreGraphics drawing. Would be nice if I could do something like this :<br>&gt; <br>&gt; typealias Point = (x: CGFloat,y: CGFloat)<br>&gt; typealias Curve = (a1: Point, a1: Point, p: Point)<br>&gt; <br>&gt; infix operator m { associativity left precedence 200 }<br>&gt; infix operator l { associativity left precedence 200 }<br>&gt; infix operator c { associativity left precedence 200 }<br>&gt; infix operator fill { associativity left precedence 200 }<br>&gt; <br>&gt; public func m (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>&gt;     <br>&gt;     CGContextMoveToPoint(lhs, rhs.x, rhs.y); return lhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; public func l (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>&gt;     <br>&gt;     CGContextAddLineToPoint(lhs, rhs.x, rhs.y); return lhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; public func c (lhs: CGContextRef?, rhs: Curve) -&gt; CGContextRef? {<br>&gt;     <br>&gt;     CGContextAddCurveToPoint(lhs, rhs.a1.x, rhs.a1.y, rhs.a2.x, rhs.a2.y, rhs.p.x, rhs.p.y); return lhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; public func fill (lhs: CGContextRef?, rhs: UIColor) {<br>&gt;     <br>&gt;     rhs.set()<br>&gt;     CGContextFillPath(lhs)<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; func drawRect(rect: CGRect) {<br>&gt;     <br>&gt;     UIGraphicsGetCurrentContext() m (10,10) l (20,20) fill UIColor.redColor()<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; I am also dreaming up a library that is not for app development, but education purposes only. I would love to have the ability to build multiple libraries that are based on different fields (economics, food, sports, etc). These libraries would be written to help students learn to write code with the focus on their favorite activities. This library would be for kids and teens to explore how to write code (possibly even adults that are looking to change fields and trying to get their head around how code works). <br>&gt; <br>&gt; Football : (note… just through this together, would be more polished and thought out if it becomes a possibility)<br>&gt; <br>&gt; typealias Score = Int<br>&gt; typealias Yardage = Double<br>&gt; <br>&gt; <br>&gt; struct Team {<br>&gt; <br>&gt; 	var totalYards = Yardage<br>&gt; <br>&gt; }<br>&gt; <br>&gt; infix operator gain { associativity left precedence 200 }<br>&gt; <br>&gt; public func gain (inout lhs: Team, rhs: Yardage) {<br>&gt;     <br>&gt;     lhs.totalYards += rhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; func runPlay() {<br>&gt;     <br>&gt;     offense gain 12<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; <br>&gt;&gt; On Thu, Jan 7, 2016, 11:31 AM Félix Cloutier &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; In a discussion about adding $ to the operator character set (it currently is an identifier character), Chris said that any token must be unambiguously either an identifier or an operator even before operators are &quot;discovered&quot;, and that&#39;s why the identifier character sets and operator character sets have no overlap right now.<br>&gt;&gt; <br>&gt;&gt; &quot;as&quot; and &quot;is&quot; are not operators, they&#39;re keywords that were hard-coded into the grammar.<br>&gt; <br>&gt; I believe having them on the operator page is confusing then. Maybe there should be an explanation on there that they are not actually operators, but just work like them… thoughts?<br>&gt; ...<br>&gt; Closed range<br>&gt; None<br>&gt; Range, 135<br>&gt; is<br>&gt; Type check<br>&gt; Left associative<br>&gt; Cast, 132<br>&gt; as, as?, and as!<br>&gt; Type cast<br>&gt; Left associative<br>&gt; Cast, 132<br>&gt; ??<br>&gt; Nil Coalescing<br>&gt; Right associative<br>&gt; Nil Coalescing, 131<br>&gt; <br>&gt;&gt; Félix<br>&gt;&gt; <br>&gt;&gt;&gt; Le 7 janv. 2016 à 04:31:10, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are my reasons for allowing them:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. potential opportunity to build an educational library to help explain expressions (see below)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator plus { associativity left precedence 200 }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func plus (lhs: Int, rhs: Int) -&gt; Int {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     return lhs + rhs<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let totalApples = 5 plus 5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. potential to write more like a sentence (this isn’t as high of a need, but again a good for entry into the language) <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; postfix operator oz { }<br>&gt;&gt;&gt; postfix operator cup { }<br>&gt;&gt;&gt; postfix operator gal { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func oz (inout _ lhs: Double) -&gt; Double {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     return lhs<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func cup (inout _ lhs: Double) -&gt; Double {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     return lhs *= 8.0 <br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func gal (inout _ lhs: Double) -&gt; Double {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     return lhs *= 128.0<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let totalLiquidInOunces = 5oz plus 2cup plus 1gal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I spent awhile looking to make sure this hasn’t been proposed before. I apologize if it is a repeat.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Nerd . Designer . Developer<br>&gt;&gt;&gt; Jo Albright<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/1af93402/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  7, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 1:31 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt; <br>&gt; Here are my reasons for allowing them:<br>&gt; <br>&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br></p><p>Check out Replace Logical Operators (&amp;&amp;, ||, etc) with words like &quot;and&quot; and “or&quot;:<br>https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br></p><p>There is very small win here of “x foo y” over &quot;x.foo(y)”?<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/e822adfa/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  7, 2016 at 08:00:00pm</p></header><div class="content"><p>Chris - I really appreciate that you take the time to entertain &amp; respond to proposals. <br></p><p>&gt; On Jan 7, 2016, at 7:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 1:31 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;&gt; <br>&gt;&gt; Here are my reasons for allowing them:<br>&gt;&gt; <br>&gt;&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt; <br>&gt; Check out Replace Logical Operators (&amp;&amp;, ||, etc) with words like &quot;and&quot; and “or&quot;:<br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>I completely agree with that proposal being rejected. I am not asking to replace existing language grammar. My desire is for the support of alphabetical characters for custom operators to allow third party libraries to have their own unique grammar.<br> <br>&gt; There is very small win here of “x foo y” over &quot;x.foo(y)”?<br></p><p>And I completely agree that function/method syntax can easily suffice for normal circumstances. Just trying to see how far Swift can be stretched.<br></p><p> Nerd . Designer . Developer<br>Jo Albright<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/215b7c5a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  7, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 5:26 PM, Jo Albright &lt;me at jo2.co&gt; wrote:<br>&gt; <br>&gt; Chris - I really appreciate that you take the time to entertain &amp; respond to proposals. <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 7:24 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 1:31 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here are my reasons for allowing them:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt;&gt; <br>&gt;&gt; Check out Replace Logical Operators (&amp;&amp;, ||, etc) with words like &quot;and&quot; and “or&quot;:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt; I completely agree with that proposal being rejected. I am not asking to replace existing language grammar. My desire is for the support of alphabetical characters for custom operators to allow third party libraries to have their own unique grammar.<br>&gt;  <br>&gt;&gt; There is very small win here of “x foo y” over &quot;x.foo(y)”?<br>&gt; <br>&gt; And I completely agree that function/method syntax can easily suffice for normal circumstances. Just trying to see how far Swift can be stretched.<br></p><p>Hi Jo,<br></p><p>The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/4fc85825/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  7, 2016 at 09:00:00pm</p></header><div class="content"><p>Some other languages provide special syntax to use a binary function as<br>infix:<br></p><p><br>Haskell:<br>    foo a b    -- is equivalent to<br>    a `foo` b<br></p><p>Mathematica:<br>    Foo[a, b]  (*is equivalent to*)<br>    a~Foo~b<br></p><p><br>Jacob<br></p><p>On Thu, Jan 7, 2016 at 9:42 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jan 7, 2016, at 5:26 PM, Jo Albright &lt;me at jo2.co&gt; wrote:<br>&gt;<br>&gt; Chris - I really appreciate that you take the time to entertain &amp; respond<br>&gt; to proposals.<br>&gt;<br>&gt; On Jan 7, 2016, at 7:24 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 7, 2016, at 1:31 AM, Jo Albright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; As my obsession grows with custom operators. I have come across wanting to<br>&gt; use small words or 1-2 alphabetical characters as custom operators. I<br>&gt; noticed that “as” and “is” are character based operators and figured it<br>&gt; wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;<br>&gt; Here are my reasons for allowing them:<br>&gt;<br>&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|”<br>&gt;<br>&gt;<br>&gt; Check out Replace Logical Operators (&amp;&amp;, ||, etc) with words like &quot;and&quot;<br>&gt; and “or&quot;:<br>&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md<br>&gt;<br>&gt;<br>&gt; I completely agree with that proposal being rejected. I am not asking to<br>&gt; replace existing language grammar. My desire is for the support of<br>&gt; alphabetical characters for custom operators to allow *third party<br>&gt; libraries* to have their own unique grammar.<br>&gt;<br>&gt;<br>&gt; There is very small win here of “x foo y” over &quot;x.foo(y)”?<br>&gt;<br>&gt;<br>&gt; And I completely agree that function/method syntax can easily suffice for<br>&gt; normal circumstances. Just trying to see how far Swift can be stretched.<br>&gt;<br>&gt;<br>&gt; Hi Jo,<br>&gt;<br>&gt; The rationale is the same - the design of Swift really wants operators and<br>&gt; identifiers to be partitioned into different namespaces.  Violating that<br>&gt; would make it impossible to parse a swift file without parsing all of its<br>&gt; imports.  This is a mistake that C made (you have to parse all the headers<br>&gt; a file uses to reliably parse the file) that we don’t want to replicate in<br>&gt; Swift.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/980f5143/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0e8516d3703e35b7df26986815b23e7a?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Robert Widmann</string> &lt;devteam.codafi at gmail.com&gt;<p>January  7, 2016 at 10:00:00pm</p></header><div class="content"><p>I’d love to have this specific form of this proposal happen.  [Were it not that backticks are for naming things after reserved words!]<br></p><p>&gt; On Jan 7, 2016, at 10:49 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some other languages provide special syntax to use a binary function as infix:<br>&gt; <br>&gt; <br>&gt; Haskell:<br>&gt;     foo a b    -- is equivalent to<br>&gt;     a `foo` b<br>&gt; <br>&gt; Mathematica:<br>&gt;     Foo[a, b]  (*is equivalent to*)<br>&gt;     a~Foo~b<br>&gt; <br>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 9:42 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 5:26 PM, Jo Albright &lt;me at jo2.co &lt;mailto:me at jo2.co&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Chris - I really appreciate that you take the time to entertain &amp; respond to proposals. <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 7:24 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 1:31 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are my reasons for allowing them:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Check out Replace Logical Operators (&amp;&amp;, ||, etc) with words like &quot;and&quot; and “or&quot;:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt;&gt; I completely agree with that proposal being rejected. I am not asking to replace existing language grammar. My desire is for the support of alphabetical characters for custom operators to allow third party libraries to have their own unique grammar.<br>&gt;&gt;  <br>&gt;&gt;&gt; There is very small win here of “x foo y” over &quot;x.foo(y)”?<br>&gt;&gt; <br>&gt;&gt; And I completely agree that function/method syntax can easily suffice for normal circumstances. Just trying to see how far Swift can be stretched.<br>&gt; <br>&gt; Hi Jo,<br>&gt; <br>&gt; The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160107/fb81dfcd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>January  7, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some other languages provide special syntax to use a binary function as infix:<br>&gt; <br>&gt; Haskell:<br>&gt;     foo a b    -- is equivalent to<br>&gt;     a `foo` b<br>&gt; <br>&gt; Mathematica:<br>&gt;     Foo[a, b]  (*is equivalent to*)<br>&gt;     a~Foo~b<br></p><p>Swift&#39;s features make that solution trickier: free functions versus methods; named parameters.<br></p><p>Alternative: Reserve one of the operator characters as an operator introducer. Everything from that character to the next whitespace is an operator name. This would allow non-operator characters in operator names while still preserving the strict operator/identifier separation.<br></p><p>    // • is the operator introducer character<br>    infix operator •times …<br>    infix operator •mod …<br>    x = a •times b •mod 8<br></p><p>Limitations:<br>You still can&#39;t use an unadorned word as an operator name.<br>You can&#39;t use such an operator without whitespace (unlike operators whose names use operator characters only). <br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Some other languages provide special syntax to use a binary function as infix:<br>&gt; <br>&gt; <br>&gt; Haskell:<br>&gt;     foo a b    -- is equivalent to<br>&gt;     a `foo` b<br>&gt; <br>&gt; Mathematica:<br>&gt;     Foo[a, b]  (*is equivalent to*)<br>&gt;     a~Foo~b<br></p><p>Ok, then yes, introducing a magic syntax would be technically feasible (though not backticks, since they are used for something else).<br></p><p>This is still extremely unlikely to be accepted though.  Additional language complexity needs to pay for itself, and the win here is so small that it doesn’t seem worth it.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  8, 2016 at 04:00:00pm</p></header><div class="content"><p>I promise, this is my last idea to be thrown at this. Instead of characters in operators...<br></p><p>Would the core team be open to having an operatoralias keyword that allows an operator to be masked by an identifier.<br></p><p>Learning &amp; Teaching Example :<br></p><p>operatoralias plus = +<br></p><p>let apples = 5 + 5<br>let apples = 5 plus 5<br></p><p>With extension :<br></p><p>let apples = 5 . plus ( 5 )<br></p><p>---------------------------------------------------------------------------------<br></p><p>Learning &amp; Teaching Example :<br></p><p>operatoralias incrementedBy = +=<br></p><p>updatedValue += 10<br>updatedValue incrementedBy 10<br></p><p>With extension :<br></p><p>updatedValue . incrementedBy ( 10 )<br></p><p>---------------------------------------------------------------------------------<br></p><p>Readability &amp; Code Reduction Example :<br></p><p>typealias Point = (x: CGFloat,y: CGFloat)<br></p><p>infix operator &gt;&gt;&gt;&gt; { }<br></p><p>func &gt;&gt;&gt;&gt; (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>    <br>    CGContextMoveToPoint(lhs, rhs.x, rhs.y); return lhs<br>    <br>}<br></p><p>operatoralias moveTo = &gt;&gt;&gt;&gt; // operator alias for custom operator<br></p><p>let context = UIGraphicsGetCurrentContext()<br></p><p>context moveTo (10,10) addLineTo (20,20) strokeWith UIColor.redColor()<br></p><p>Or if SVG letters used (less readable, but also less footprint) :<br></p><p>context M (10,10) L (20,20) stroke UIColor.redColor()<br></p><p>I know this looks a lot like a chained method and very close to the same amount of code to be written… however it is slightly easier to read without all of the function punctuation in between :<br></p><p>context.moveTo(10,10)?.addLineTo(20,20)?.strokeWith.(UIColor.redColor())<br></p><p><br>I believe there is an opportunity here that won’t truly be appreciated until it is in use. But will not argue that it is very close to what is currently available and does not have a huge impact in the current vision of things.<br></p><p>Thanks for humoring my imagination. :) <br></p><p><br> Nerd . Designer . Developer<br>Jo Albright<br></p><p><br>&gt; On Jan 8, 2016, at 2:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Some other languages provide special syntax to use a binary function as infix:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Haskell:<br>&gt;&gt;    foo a b    -- is equivalent to<br>&gt;&gt;    a `foo` b<br>&gt;&gt; <br>&gt;&gt; Mathematica:<br>&gt;&gt;    Foo[a, b]  (*is equivalent to*)<br>&gt;&gt;    a~Foo~b<br>&gt; <br>&gt; Ok, then yes, introducing a magic syntax would be technically feasible (though not backticks, since they are used for something else).<br>&gt; <br>&gt; This is still extremely unlikely to be accepted though.  Additional language complexity needs to pay for itself, and the win here is so small that it doesn’t seem worth it.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/224659df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  8, 2016 at 10:00:00pm</p></header><div class="content"><p>Jo, maybe it&#39;s time to explore infix functions as a potential solution? I<br>don&#39;t see infix functions under the commonly proposed list.<br></p><p>On Fri, Jan 8, 2016, 4:28 PM Jo Albright via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I promise, this is my last idea to be thrown at this. Instead of<br>&gt; characters in operators...<br>&gt;<br>&gt; Would the core team be open to having an *operatoralias* keyword that<br>&gt; allows an operator to be masked by an identifier.<br>&gt;<br>&gt; Learning &amp; Teaching Example :<br>&gt;<br>&gt; operatoralias plus = +<br>&gt;<br>&gt; let apples = 5 + 5<br>&gt; let apples = 5 plus 5<br>&gt;<br>&gt; With extension :<br>&gt;<br>&gt; let apples = 5 . plus ( 5 )<br>&gt;<br>&gt;<br>&gt; ---------------------------------------------------------------------------------<br>&gt;<br>&gt; Learning &amp; Teaching Example :<br>&gt;<br>&gt; operatoralias incrementedBy = +=<br>&gt;<br>&gt; updatedValue += 10<br>&gt; updatedValue incrementedBy 10<br>&gt;<br>&gt; With extension :<br>&gt;<br>&gt; updatedValue . incrementedBy ( 10 )<br>&gt;<br>&gt;<br>&gt; ---------------------------------------------------------------------------------<br>&gt;<br>&gt; Readability &amp; Code Reduction Example :<br>&gt;<br>&gt; typealias Point = (x: CGFloat,y: CGFloat)<br>&gt;<br>&gt; infix operator &gt;&gt;&gt;&gt; { }<br>&gt;<br>&gt; func &gt;&gt;&gt;&gt; (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>&gt;<br>&gt;<br>&gt;     CGContextMoveToPoint(lhs, rhs.x, rhs.y); return lhs<br>&gt;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; operatoralias moveTo = &gt;&gt;&gt;&gt; // operator alias for custom operator<br>&gt;<br>&gt; let context = UIGraphicsGetCurrentContext()<br>&gt;<br>&gt; context moveTo (10,10) addLineTo (20,20) strokeWith UIColor.redColor()<br>&gt;<br>&gt; Or if SVG letters used (less readable, but also less footprint) :<br>&gt;<br>&gt; context M (10,10) L (20,20) stroke UIColor.redColor()<br>&gt;<br>&gt; I know this looks a lot like a chained method and very close to the same<br>&gt; amount of code to be written… however it is slightly easier to read without<br>&gt; all of the function punctuation in between :<br>&gt;<br>&gt; context.moveTo(10,10)?.addLineTo(20,20)?.strokeWith.(UIColor.redColor())<br>&gt;<br>&gt;<br>&gt; I believe there is an opportunity here that won’t truly be appreciated<br>&gt; until it is in use. But will not argue that it is very close to what is<br>&gt; currently available and does not have a huge impact in the current vision<br>&gt; of things.<br>&gt;<br>&gt; Thanks for humoring my imagination. :)<br>&gt;<br>&gt;<br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt;<br>&gt;<br>&gt; On Jan 8, 2016, at 2:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Some other languages provide special syntax to use a binary function as<br>&gt; infix:<br>&gt;<br>&gt;<br>&gt; Haskell:<br>&gt;    foo a b    -- is equivalent to<br>&gt;    a `foo` b<br>&gt;<br>&gt; Mathematica:<br>&gt;    Foo[a, b]  (*is equivalent to*)<br>&gt;    a~Foo~b<br>&gt;<br>&gt;<br>&gt; Ok, then yes, introducing a magic syntax would be technically feasible<br>&gt; (though not backticks, since they are used for something else).<br>&gt;<br>&gt; This is still extremely unlikely to be accepted though.  Additional<br>&gt; language complexity needs to pay for itself, and the win here is so small<br>&gt; that it doesn’t seem worth it.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/690bb1b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jan 8, 2016, at 2:43 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; Jo, maybe it&#39;s time to explore infix functions as a potential solution? I don&#39;t see infix functions under the commonly proposed list.<br>&gt; <br>I just added them.  To repeat what has been said several times on this thread, the problem being solved here is not important enough to be worth complicating the language for.<br></p><p>-Chris<br></p><p><br>&gt; <br>&gt; On Fri, Jan 8, 2016, 4:28 PM Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I promise, this is my last idea to be thrown at this. Instead of characters in operators...<br>&gt; <br>&gt; Would the core team be open to having an operatoralias keyword that allows an operator to be masked by an identifier.<br>&gt; <br>&gt; Learning &amp; Teaching Example :<br>&gt; <br>&gt; operatoralias plus = +<br>&gt; <br>&gt; let apples = 5 + 5<br>&gt; let apples = 5 plus 5<br>&gt; <br>&gt; With extension :<br>&gt; <br>&gt; let apples = 5 . plus ( 5 )<br>&gt; <br>&gt; ---------------------------------------------------------------------------------<br>&gt; <br>&gt; Learning &amp; Teaching Example :<br>&gt; <br>&gt; operatoralias incrementedBy = +=<br>&gt; <br>&gt; updatedValue += 10<br>&gt; updatedValue incrementedBy 10<br>&gt; <br>&gt; With extension :<br>&gt; <br>&gt; updatedValue . incrementedBy ( 10 )<br>&gt; <br>&gt; ---------------------------------------------------------------------------------<br>&gt; <br>&gt; Readability &amp; Code Reduction Example :<br>&gt; <br>&gt; typealias Point = (x: CGFloat,y: CGFloat)<br>&gt; <br>&gt; infix operator &gt;&gt;&gt;&gt; { }<br>&gt; <br>&gt; func &gt;&gt;&gt;&gt; (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>&gt;     <br>&gt;     CGContextMoveToPoint(lhs, rhs.x, rhs.y); return lhs<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; operatoralias moveTo = &gt;&gt;&gt;&gt; // operator alias for custom operator<br>&gt; <br>&gt; let context = UIGraphicsGetCurrentContext()<br>&gt; <br>&gt; context moveTo (10,10) addLineTo (20,20) strokeWith UIColor.redColor()<br>&gt; <br>&gt; Or if SVG letters used (less readable, but also less footprint) :<br>&gt; <br>&gt; context M (10,10) L (20,20) stroke UIColor.redColor()<br>&gt; <br>&gt; I know this looks a lot like a chained method and very close to the same amount of code to be written… however it is slightly easier to read without all of the function punctuation in between :<br>&gt; <br>&gt; context.moveTo(10,10)?.addLineTo(20,20)?.strokeWith.(UIColor.redColor())<br>&gt; <br>&gt; <br>&gt; I believe there is an opportunity here that won’t truly be appreciated until it is in use. But will not argue that it is very close to what is currently available and does not have a huge impact in the current vision of things.<br>&gt; <br>&gt; Thanks for humoring my imagination. :) <br>&gt; <br>&gt; <br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 8, 2016, at 2:26 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Some other languages provide special syntax to use a binary function as infix:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Haskell:<br>&gt;&gt;&gt;    foo a b    -- is equivalent to<br>&gt;&gt;&gt;    a `foo` b<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Mathematica:<br>&gt;&gt;&gt;    Foo[a, b]  (*is equivalent to*)<br>&gt;&gt;&gt;    a~Foo~b<br>&gt;&gt; <br>&gt;&gt; Ok, then yes, introducing a magic syntax would be technically feasible (though not backticks, since they are used for something else).<br>&gt;&gt; <br>&gt;&gt; This is still extremely unlikely to be accepted though.  Additional language complexity needs to pay for itself, and the win here is so small that it doesn’t seem worth it.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/16758ebf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January  9, 2016 at 07:00:00pm</p></header><div class="content"><p>Chris, hmm... Can you really say that this is the only problem that would<br>warrant infix functions? To say what you just seemingly implies that you<br>believe the use cases outlined here are the only reason one would want<br>infix operators, and that the use cases outlined here don&#39;t warrant infix<br>functions.<br></p><p>I&#39;m sure there are plenty more reasons for implementing infix functions and<br>I think it would be reactionary to effectively discourage their<br>consideration on the basis of one tangentially related email chain.<br></p><p>On Sat, Jan 9, 2016, 1:53 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jan 8, 2016, at 2:43 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Jo, maybe it&#39;s time to explore infix functions as a potential solution? I<br>&gt; don&#39;t see infix functions under the commonly proposed list.<br>&gt;<br>&gt; I just added them.  To repeat what has been said several times on this<br>&gt; thread, the problem being solved here is not important enough to be worth<br>&gt; complicating the language for.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Fri, Jan 8, 2016, 4:28 PM Jo Albright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I promise, this is my last idea to be thrown at this. Instead of<br>&gt;&gt; characters in operators...<br>&gt;&gt;<br>&gt;&gt; Would the core team be open to having an *operatoralias* keyword that<br>&gt;&gt; allows an operator to be masked by an identifier.<br>&gt;&gt;<br>&gt;&gt; Learning &amp; Teaching Example :<br>&gt;&gt;<br>&gt;&gt; operatoralias plus = +<br>&gt;&gt;<br>&gt;&gt; let apples = 5 + 5<br>&gt;&gt; let apples = 5 plus 5<br>&gt;&gt;<br>&gt;&gt; With extension :<br>&gt;&gt;<br>&gt;&gt; let apples = 5 . plus ( 5 )<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ---------------------------------------------------------------------------------<br>&gt;&gt;<br>&gt;&gt; Learning &amp; Teaching Example :<br>&gt;&gt;<br>&gt;&gt; operatoralias incrementedBy = +=<br>&gt;&gt;<br>&gt;&gt; updatedValue += 10<br>&gt;&gt; updatedValue incrementedBy 10<br>&gt;&gt;<br>&gt;&gt; With extension :<br>&gt;&gt;<br>&gt;&gt; updatedValue . incrementedBy ( 10 )<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ---------------------------------------------------------------------------------<br>&gt;&gt;<br>&gt;&gt; Readability &amp; Code Reduction Example :<br>&gt;&gt;<br>&gt;&gt; typealias Point = (x: CGFloat,y: CGFloat)<br>&gt;&gt;<br>&gt;&gt; infix operator &gt;&gt;&gt;&gt; { }<br>&gt;&gt;<br>&gt;&gt; func &gt;&gt;&gt;&gt; (lhs: CGContextRef?, rhs: Point) -&gt; CGContextRef? {<br>&gt;&gt;<br>&gt;&gt;     CGContextMoveToPoint(lhs, rhs.x, rhs.y); return lhs<br>&gt;&gt;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; operatoralias moveTo = &gt;&gt;&gt;&gt; // operator alias for custom operator<br>&gt;&gt;<br>&gt;&gt; let context = UIGraphicsGetCurrentContext()<br>&gt;&gt;<br>&gt;&gt; context moveTo (10,10) addLineTo (20,20) strokeWith UIColor.redColor()<br>&gt;&gt;<br>&gt;&gt; Or if SVG letters used (less readable, but also less footprint) :<br>&gt;&gt;<br>&gt;&gt; context M (10,10) L (20,20) stroke UIColor.redColor()<br>&gt;&gt;<br>&gt;&gt; I know this looks a lot like a chained method and very close to the same<br>&gt;&gt; amount of code to be written… however it is slightly easier to read without<br>&gt;&gt; all of the function punctuation in between :<br>&gt;&gt;<br>&gt;&gt; context.moveTo(10,10)?.addLineTo(20,20)?.strokeWith.(UIColor.redColor())<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I believe there is an opportunity here that won’t truly be appreciated<br>&gt;&gt; until it is in use. But will not argue that it is very close to what is<br>&gt;&gt; currently available and does not have a huge impact in the current vision<br>&gt;&gt; of things.<br>&gt;&gt;<br>&gt;&gt; Thanks for humoring my imagination. :)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  Nerd . Designer . Developer<br>&gt;&gt; Jo Albright<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 8, 2016, at 2:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Some other languages provide special syntax to use a binary function as<br>&gt;&gt; infix:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Haskell:<br>&gt;&gt;    foo a b    -- is equivalent to<br>&gt;&gt;    a `foo` b<br>&gt;&gt;<br>&gt;&gt; Mathematica:<br>&gt;&gt;    Foo[a, b]  (*is equivalent to*)<br>&gt;&gt;    a~Foo~b<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Ok, then yes, introducing a magic syntax would be technically feasible<br>&gt;&gt; (though not backticks, since they are used for something else).<br>&gt;&gt;<br>&gt;&gt; This is still extremely unlikely to be accepted though.  Additional<br>&gt;&gt; language complexity needs to pay for itself, and the win here is so small<br>&gt;&gt; that it doesn’t seem worth it.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/a6bdfd73/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jan 9, 2016, at 11:56 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; Chris, hmm... Can you really say that this is the only problem that would warrant infix functions? To say what you just seemingly implies that you believe the use cases outlined here are the only reason one would want infix operators, and that the use cases outlined here don&#39;t warrant infix functions.<br>&gt; <br>&gt; I&#39;m sure there are plenty more reasons for implementing infix functions and I think it would be reactionary to effectively discourage their consideration on the basis of one tangentially related email chain.<br>&gt; <br>I’m saying that I cannot personally imagine a use-case compelling enough to make the language more complicated for (including the ones listed on the thread).  If you can, please share them and we can discuss it.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/c64d0e5e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/998d3d631acb87e0aa687abc0085f990?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>André Videla</string> &lt;zephyz at me.com&gt;<p>January 10, 2016 at 02:00:00am</p></header><div class="content"><p>Maybe this wan&#39;t the original idea but I have a proposition that is both parseable and useful<br></p><p>Imagine you have this struct<br>struct Person {<br>    let name: String<br>    let age: Int<br>}<br></p><p>and you want to use an operator to compare their fields because you do that often.<br>Typically you would do something along those lines:<br></p><p>func &lt;(lhs: Person, rhs: Person) -&gt; Bool {<br>    return lhs.age &lt; rhs.age<br>}<br></p><p>func &lt;&lt;(lhs: Person, rhs: Person) -&gt; Bool {<br>    return lhs.name &lt; rhs.name<br>}<br></p><p>and then use it like so<br></p><p>let john = Person(name: &quot;John&quot;, age: 12)<br>let steve = Person(name: &quot;Steve&quot;, age: 14)<br></p><p>john &lt; steve<br>john &lt;&lt; steve<br></p><p>The point isn&#39;t that &quot;&lt;&quot; and &quot;&lt;&lt;&quot; are bad operators for this purpose but that operators quickly become confusing when abused.<br>I think one great solution would be to allow alphanumeric character after the operator head like so: <br></p><p>func &lt;age(lhs: Person, rhs: Person) -&gt; Bool {…}<br></p><p>func &lt;name(lhs: Person, rhs: Person) -&gt; Bool {…}<br></p><p>john &lt;age steve<br>john &lt;name steve<br></p><p>and the grammar would need to be changed to:<br></p><p>operator -&gt; operator-head operator-characters<br>operator-characters -&gt; operator-characters operator-tail<br>operator-tail -&gt; operator-characters<br>operator-tail -&gt; alphanumeric alphanumeric?<br></p><p>or something similar<br></p><p>Extra:<br>If we extend this idea further we could even imagine nice operators like<br></p><p>john &lt;⎮age⎮ steve<br>john &gt;⎮name⎮ steve<br></p><p>And I will argue that this is more both readable and desirable than john.compareAge(steve) or john.lessThanAge(steve) even though that&#39;s what it years of Obj-C and OOP tells us to do.<br></p><p>&gt; On 10 Jan 2016, at 02:23, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jan 9, 2016, at 11:56 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com &lt;mailto:dennis.s.lysenko at gmail.com&gt;&gt; wrote:<br>&gt;&gt; Chris, hmm... Can you really say that this is the only problem that would warrant infix functions? To say what you just seemingly implies that you believe the use cases outlined here are the only reason one would want infix operators, and that the use cases outlined here don&#39;t warrant infix functions.<br>&gt;&gt; <br>&gt;&gt; I&#39;m sure there are plenty more reasons for implementing infix functions and I think it would be reactionary to effectively discourage their consideration on the basis of one tangentially related email chain.<br>&gt;&gt; <br>&gt; I’m saying that I cannot personally imagine a use-case compelling enough to make the language more complicated for (including the ones listed on the thread).  If you can, please share them and we can discuss it.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/5273e16c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January 10, 2016 at 03:00:00am</p></header><div class="content"><p>Chris, perhaps there is a disconnect in our perceptions of the commonly<br>proposed list. Based on the way you and others have referenced the commonly<br>proposed list, it comes off as a blacklist of sorts. That is, &quot;it&#39;s on the<br>commonly proposed list&quot; seems to be seen as an argument against a proposal.<br>I only worry that the mere presence of something on the commonly proposed<br>list will serve as a deterrent to legitimate proposals involving it in the<br>future.<br></p><p>If you have taken that into consideration when deciding to place infix<br>functions on the commonly proposed list then fair enough. I just feel that<br>infix functions have not been discussed nearly as much as, say,<br>&quot;indentation over brace syntax&quot; or &quot;getting rid of ternary&quot;, and it&#39;s a bit<br>preemptive to put such a dent in potential future discussion because you<br>personally cannot imagine a use case warranting the language change.<br></p><p>Out of curiosity, has there even been a top-level proposal for infix<br>functions that generated significant discussion?<br></p><p>On Sat, Jan 9, 2016 at 5:23 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jan 9, 2016, at 11:56 AM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Chris, hmm... Can you really say that this is the only problem that would<br>&gt; warrant infix functions? To say what you just seemingly implies that you<br>&gt; believe the use cases outlined here are the only reason one would want<br>&gt; infix operators, and that the use cases outlined here don&#39;t warrant infix<br>&gt; functions.<br>&gt;<br>&gt; I&#39;m sure there are plenty more reasons for implementing infix functions<br>&gt; and I think it would be reactionary to effectively discourage their<br>&gt; consideration on the basis of one tangentially related email chain.<br>&gt;<br>&gt; I’m saying that I cannot personally imagine a use-case compelling enough<br>&gt; to make the language more complicated for (including the ones listed on the<br>&gt; thread).  If you can, please share them and we can discuss it.<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/5828e8b6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>January  9, 2016 at 09:00:00pm</p></header><div class="content"><p>On Jan 9, 2016, at 7:50 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; Chris, perhaps there is a disconnect in our perceptions of the commonly proposed list. Based on the way you and others have referenced the commonly proposed list, it comes off as a blacklist of sorts. That is, &quot;it&#39;s on the commonly proposed list&quot; seems to be seen as an argument against a proposal. I only worry that the mere presence of something on the commonly proposed list will serve as a deterrent to legitimate proposals involving it in the future. <br></p><p>Hi Dennis,<br></p><p>I’m sorry for the confusion on this.  The very first paragraph of that page says:<br></p><p>… If you&#39;re interested in pursuing something in this space, please familiarize yourself with the discussions that we have already had. In order to bring one of these topics up, you&#39;ll be expected to add new information to the discussion, not just say &quot;I really want this&quot; or &quot;This exists in some other language and I liked it there&quot;.<br></p><p>The intention is to avoid re-treading old ground, not to say that something is impossible.<br></p><p>&gt; If you have taken that into consideration when deciding to place infix functions on the commonly proposed list then fair enough. I just feel that infix functions have not been discussed nearly as much as, say, &quot;indentation over brace syntax&quot; or &quot;getting rid of ternary&quot;, and it&#39;s a bit preemptive to put such a dent in potential future discussion because you personally cannot imagine a use case warranting the language change.<br>&gt; <br>&gt; Out of curiosity, has there even been a top-level proposal for infix functions that generated significant discussion?<br></p><p>Yes, it has come up several times in different contexts.  The advantage of “x foo bar” (potentially with sigils around foo) over “x.foo(bar)” has consistently been seen as not worth adding complexity for.  Perhaps you are thinking of something else?<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160109/babc5e05/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>January 10, 2016 at 06:00:00am</p></header><div class="content"><p>Sorry Chris, seems as though I misinterpreted. I guess I was arguing the<br>principle more than the specific example here; apologies if I derailed the<br>thread a bit. At the risk of derailing the thread further, since I still<br>have your attention and am not sure where else to raise such a suggestion:<br>have you or other members of the Swift team considered talking to the team<br>behind Kotlin? Kotlin has been loosely touted as &quot;Swift for the<br>JVM/android&quot; and may share some motivation with Swift--modern functionality<br>and interoperability with a very well-known, older language. In spite of<br>how much the two languages differ in key areas, maybe the two teams could<br>share and discuss motivation behind previous language decisions. Not sure<br>if there is a precedent for that kind of interaction so feel free to<br>disregard.<br></p><p>On Sun, Jan 10, 2016, 12:30 AM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt; On Jan 9, 2016, at 7:50 PM, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Chris, perhaps there is a disconnect in our perceptions of the commonly<br>&gt; proposed list. Based on the way you and others have referenced the commonly<br>&gt; proposed list, it comes off as a blacklist of sorts. That is, &quot;it&#39;s on the<br>&gt; commonly proposed list&quot; seems to be seen as an argument against a proposal.<br>&gt; I only worry that the mere presence of something on the commonly proposed<br>&gt; list will serve as a deterrent to legitimate proposals involving it in the<br>&gt; future.<br>&gt;<br>&gt;<br>&gt; Hi Dennis,<br>&gt;<br>&gt; I’m sorry for the confusion on this.  The very first paragraph of that<br>&gt; page says:<br>&gt;<br>&gt; … If you&#39;re interested in pursuing something in this space, please<br>&gt; familiarize yourself with the discussions that we have already had. In<br>&gt; order to bring one of these topics up, you&#39;ll be expected to add new<br>&gt; information to the discussion, not just say &quot;I really want this&quot; or &quot;This<br>&gt; exists in some other language and I liked it there&quot;.<br>&gt;<br>&gt;<br>&gt; The intention is to avoid re-treading old ground, not to say that<br>&gt; something is impossible.<br>&gt;<br>&gt; If you have taken that into consideration when deciding to place infix<br>&gt; functions on the commonly proposed list then fair enough. I just feel that<br>&gt; infix functions have not been discussed nearly as much as, say,<br>&gt; &quot;indentation over brace syntax&quot; or &quot;getting rid of ternary&quot;, and it&#39;s a bit<br>&gt; preemptive to put such a dent in potential future discussion because you<br>&gt; personally cannot imagine a use case warranting the language change.<br>&gt;<br>&gt; Out of curiosity, has there even been a top-level proposal for infix<br>&gt; functions that generated significant discussion?<br>&gt;<br>&gt;<br>&gt; Yes, it has come up several times in different contexts.  The advantage of<br>&gt; “x foo bar” (potentially with sigils around foo) over “x.foo(bar)” has<br>&gt; consistently been seen as not worth adding complexity for.  Perhaps you are<br>&gt; thinking of something else?<br>&gt;<br>&gt; -Chris<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160110/e6a4291e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>January  8, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jan 7, 2016, at 9:49 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Some other languages provide special syntax to use a binary function as infix:<br>&gt; <br>&gt; <br>&gt; Haskell:<br>&gt;     foo a b    -- is equivalent to<br>&gt;     a `foo` b<br>&gt; <br>&gt; Mathematica:<br>&gt;     Foo[a, b]  (*is equivalent to*)<br>&gt;     a~Foo~b<br></p><p>You could implement the Mathematica one yourself:<br></p><p>operator infix ~ { associativity left }<br></p><p>struct Section&lt;T, U, V&gt; { var lhs: T, op: (T,U) -&gt; V }<br></p><p>func ~&lt;T, U, V&gt;(lhs: T, op: (T, U) -&gt; V) -&gt; Section&lt;T,U,V&gt; {<br>  return Section(lhs: lhs, op: op)<br>}<br></p><p>func ~&lt;T, U, V&gt;(section: Section&lt;T, U, V&gt;, rhs: U) -&gt; V {<br>  return section.op(section.lhs, rhs)<br>}<br></p><p>though I don&#39;t really see how x `foo` y is a real improvement over x.foo(y).<br></p><p>-Joe<br></p><p>&gt; <br>&gt; Jacob<br>&gt; <br>&gt; On Thu, Jan 7, 2016 at 9:42 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Jan 7, 2016, at 5:26 PM, Jo Albright &lt;me at jo2.co &lt;mailto:me at jo2.co&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Chris - I really appreciate that you take the time to entertain &amp; respond to proposals. <br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 7, 2016, at 7:24 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Jan 7, 2016, at 1:31 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As my obsession grows with custom operators. I have come across wanting to use small words or 1-2 alphabetical characters as custom operators. I noticed that “as” and “is” are character based operators and figured it wouldn’t hurt to propose the allowance of character based custom operators.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here are my reasons for allowing them:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. easier to read “within” vs “&gt;*&lt;“ or “|*|” <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Check out Replace Logical Operators (&amp;&amp;, ||, etc) with words like &quot;and&quot; and “or&quot;:<br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md &lt;https://github.com/apple/swift-evolution/blob/master/commonly_proposed.md&gt;<br>&gt;&gt; I completely agree with that proposal being rejected. I am not asking to replace existing language grammar. My desire is for the support of alphabetical characters for custom operators to allow third party libraries to have their own unique grammar.<br>&gt;&gt;  <br>&gt;&gt;&gt; There is very small win here of “x foo y” over &quot;x.foo(y)”?<br>&gt;&gt; <br>&gt;&gt; And I completely agree that function/method syntax can easily suffice for normal circumstances. Just trying to see how far Swift can be stretched.<br>&gt; <br>&gt; Hi Jo,<br>&gt; <br>&gt; The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/fd250f45/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/07fd59204e51d141632898356a6c1d00?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jo Albright</string> &lt;me at jo2.co&gt;<p>January  8, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br></p><p><br></p><p>Thanks Chris. I now understand the reasoning for separating the two groups. I don’t have a background in language creation, so whatever I can learn from these email lists is awesome. I have already gained a ton of knowledge following these conversations.<br></p><p><br>&gt; Alternative: Reserve one of the operator characters as an operator introducer. Everything from that character to the next whitespace is an operator name. This would allow non-operator characters in operator names while still preserving the strict operator/identifier separation.<br>&gt; <br>&gt;    // • is the operator introducer character<br>&gt;    infix operator •times …<br>&gt;    infix operator •mod …<br>&gt;    x = a •times b •mod 8<br>&gt; <br>&gt; Limitations:<br>&gt; You still can&#39;t use an unadorned word as an operator name.<br>&gt; You can&#39;t use such an operator without whitespace (unlike operators whose names use operator characters only). <br></p><p><br></p><p>Oooooo … that is a very cool alternative Greg. Honestly went into this proposal thinking there was no possibility, but now I have a glimmer of hope.<br></p><p>Using “•” (option + 8 on keyboard) would be great since it is accessible through key combo, but isn’t widely used in normal expressions.<br></p><p>What is needed to prove worth of such a feature to be added?<br></p><p><br> Nerd . Designer . Developer<br>Jo Albright<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/48e07c71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>January  8, 2016 at 12:00:00am</p></header><div class="content"><p>I&#39;d be hesitant to support something like this. • is a very natural choice<br>for a binary operator by itself, and restricting it to require the use of<br>spaces seems unfortunate.<br></p><p>Re: free functions vs. methods: why does this matter? Supposing `foo` were<br>the syntax (bad choice, because it already has another meaning, but bear<br>with me), then you could disambiguate &quot;a `foo` b&quot; vs &quot;a `self.foo` b&quot; just<br>as you can with regular function calls.<br></p><p>Re: named parameters: there are two clear choices:<br>- Restrict such a syntax to functions without named parameters (seems<br>acceptable to me).<br>- Ignore parameter names, allowing any binary function to be used<br>(challenges with disambiguation, which I believe has had some discussion in<br>the other thread about function names).<br></p><p>This might be a crazy idea, but is it possible to support &quot;a myfunc b&quot;<br>without any extra delimiters? As far as I can tell, there&#39;s currently no<br>way this could parse as a valid expression, so there&#39;s no ambiguity to<br>resolve, although I imagine it would be hard to make diagnostics work well.<br>I&#39;m not sure how this would play with precedence, but that hasn&#39;t been<br>discussed for any of the other solutions either.<br></p><p>Jacob Bandes-Storch<br></p><p>On Fri, Jan 8, 2016 at 12:29 AM, Jo Albright via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; The rationale is the same - the design of Swift really wants operators and<br>&gt; identifiers to be partitioned into different namespaces.  Violating that<br>&gt; would make it impossible to parse a swift file without parsing all of its<br>&gt; imports.  This is a mistake that C made (you have to parse all the headers<br>&gt; a file uses to reliably parse the file) that we don’t want to replicate in<br>&gt; Swift.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Thanks Chris. I now understand the reasoning for separating the two<br>&gt; groups. I don’t have a background in language creation, so whatever I can<br>&gt; learn from these email lists is awesome. I have already gained a ton of<br>&gt; knowledge following these conversations.<br>&gt;<br>&gt;<br>&gt; Alternative: Reserve one of the operator characters as an operator<br>&gt; introducer. Everything from that character to the next whitespace is an<br>&gt; operator name. This would allow non-operator characters in operator names<br>&gt; while still preserving the strict operator/identifier separation.<br>&gt;<br>&gt;    // • is the operator introducer character<br>&gt;    infix operator •times …<br>&gt;    infix operator •mod …<br>&gt;    x = a •times b •mod 8<br>&gt;<br>&gt; Limitations:<br>&gt; You still can&#39;t use an unadorned word as an operator name.<br>&gt; You can&#39;t use such an operator without whitespace (unlike operators whose<br>&gt; names use operator characters only).<br>&gt;<br>&gt;<br>&gt;<br>&gt; Oooooo … that is a very cool alternative Greg. Honestly went into this<br>&gt; proposal thinking there was no possibility, but now I have a glimmer of<br>&gt; hope.<br>&gt;<br>&gt; Using “•” (option + 8 on keyboard) would be great since it is accessible<br>&gt; through key combo, but isn’t widely used in normal expressions.<br>&gt;<br>&gt; What is needed to prove worth of such a feature to be added?<br>&gt;<br>&gt;<br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160108/4691baa3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March 28, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Am 08.01.2016 um 09:38 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;d be hesitant to support something like this. • is a very natural choice for a binary operator by itself, and restricting it to require the use of spaces seems unfortunate.<br></p><p>What about if • would have to begin and end an operator containing letters?<br></p><p>x = a •times• b •mod• 8<br></p><p>This looks more symmetrically (like Haskell’s backticks) and wouldn’t need the restriction to require spaces.<br></p><p>Or maybe<br></p><p>x = a ‹times› b ‹mod› 8<br></p><p>Also easily typeable on a Mac keyboard.<br></p><p><br></p><p>&gt; Re: free functions vs. methods: why does this matter? Supposing `foo` were the syntax (bad choice, because it already has another meaning, but bear with me), then you could disambiguate &quot;a `foo` b&quot; vs &quot;a `self.foo` b&quot; just as you can with regular function calls.<br></p><p>Indeed.<br></p><p>-Thorsten<br></p><p><br>&gt; Re: named parameters: there are two clear choices:<br>&gt; - Restrict such a syntax to functions without named parameters (seems acceptable to me).<br>&gt; - Ignore parameter names, allowing any binary function to be used (challenges with disambiguation, which I believe has had some discussion in the other thread about function names).<br>&gt; <br>&gt; This might be a crazy idea, but is it possible to support &quot;a myfunc b&quot; without any extra delimiters? As far as I can tell, there&#39;s currently no way this could parse as a valid expression, so there&#39;s no ambiguity to resolve, although I imagine it would be hard to make diagnostics work well. I&#39;m not sure how this would play with precedence, but that hasn&#39;t been discussed for any of the other solutions either.<br>&gt; <br>&gt; Jacob Bandes-Storch<br>&gt; <br>&gt; On Fri, Jan 8, 2016 at 12:29 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br>&gt; <br>&gt; <br>&gt; <br>&gt; Thanks Chris. I now understand the reasoning for separating the two groups. I don’t have a background in language creation, so whatever I can learn from these email lists is awesome. I have already gained a ton of knowledge following these conversations.<br>&gt; <br>&gt; <br>&gt;&gt; Alternative: Reserve one of the operator characters as an operator introducer. Everything from that character to the next whitespace is an operator name. This would allow non-operator characters in operator names while still preserving the strict operator/identifier separation.<br>&gt;&gt; <br>&gt;&gt;    // • is the operator introducer character<br>&gt;&gt;    infix operator •times …<br>&gt;&gt;    infix operator •mod …<br>&gt;&gt;    x = a •times b •mod 8<br>&gt;&gt; <br>&gt;&gt; Limitations:<br>&gt;&gt; You still can&#39;t use an unadorned word as an operator name.<br>&gt;&gt; You can&#39;t use such an operator without whitespace (unlike operators whose names use operator characters only). <br>&gt; <br>&gt; <br>&gt; <br>&gt; Oooooo … that is a very cool alternative Greg. Honestly went into this proposal thinking there was no possibility, but now I have a glimmer of hope.<br>&gt; <br>&gt; Using “•” (option + 8 on keyboard) would be great since it is accessible through key combo, but isn’t widely used in normal expressions.<br>&gt; <br>&gt; What is needed to prove worth of such a feature to be added?<br>&gt; <br>&gt; <br>&gt;  Nerd . Designer . Developer<br>&gt; Jo Albright<br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/bfab54d6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>• is the dot product operator.<br></p><p>Sent from my iPhone<br></p><p>&gt; On Mar 28, 2016, at 10:21, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Am 08.01.2016 um 09:38 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; I&#39;d be hesitant to support something like this. • is a very natural choice for a binary operator by itself, and restricting it to require the use of spaces seems unfortunate.<br>&gt; <br>&gt; What about if • would have to begin and end an operator containing letters?<br>&gt; <br>&gt; x = a •times• b •mod• 8<br>&gt; <br>&gt; This looks more symmetrically (like Haskell’s backticks) and wouldn’t need the restriction to require spaces.<br>&gt; <br>&gt; Or maybe<br>&gt; <br>&gt; x = a ‹times› b ‹mod› 8<br>&gt; <br>&gt; Also easily typeable on a Mac keyboard.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Re: free functions vs. methods: why does this matter? Supposing `foo` were the syntax (bad choice, because it already has another meaning, but bear with me), then you could disambiguate &quot;a `foo` b&quot; vs &quot;a `self.foo` b&quot; just as you can with regular function calls.<br>&gt; <br>&gt; Indeed.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Re: named parameters: there are two clear choices:<br>&gt;&gt; - Restrict such a syntax to functions without named parameters (seems acceptable to me).<br>&gt;&gt; - Ignore parameter names, allowing any binary function to be used (challenges with disambiguation, which I believe has had some discussion in the other thread about function names).<br>&gt;&gt; <br>&gt;&gt; This might be a crazy idea, but is it possible to support &quot;a myfunc b&quot; without any extra delimiters? As far as I can tell, there&#39;s currently no way this could parse as a valid expression, so there&#39;s no ambiguity to resolve, although I imagine it would be hard to make diagnostics work well. I&#39;m not sure how this would play with precedence, but that hasn&#39;t been discussed for any of the other solutions either.<br>&gt;&gt; <br>&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 8, 2016 at 12:29 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks Chris. I now understand the reasoning for separating the two groups. I don’t have a background in language creation, so whatever I can learn from these email lists is awesome. I have already gained a ton of knowledge following these conversations.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternative: Reserve one of the operator characters as an operator introducer. Everything from that character to the next whitespace is an operator name. This would allow non-operator characters in operator names while still preserving the strict operator/identifier separation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // • is the operator introducer character<br>&gt;&gt;&gt;&gt;    infix operator •times …<br>&gt;&gt;&gt;&gt;    infix operator •mod …<br>&gt;&gt;&gt;&gt;    x = a •times b •mod 8<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Limitations:<br>&gt;&gt;&gt;&gt; You still can&#39;t use an unadorned word as an operator name.<br>&gt;&gt;&gt;&gt; You can&#39;t use such an operator without whitespace (unlike operators whose names use operator characters only). <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oooooo … that is a very cool alternative Greg. Honestly went into this proposal thinking there was no possibility, but now I have a glimmer of hope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Using “•” (option + 8 on keyboard) would be great since it is accessible through key combo, but isn’t widely used in normal expressions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What is needed to prove worth of such a feature to be added?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  Nerd . Designer . Developer<br>&gt;&gt;&gt; Jo Albright<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/5a7eb932/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March 28, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Mar 28, 2016, at 9:21 AM, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Also easily typeable on a Mac keyboard.<br></p><p>It&#39;s been pointed out to me that while this is true in the US, it is not so true on other keyboard layouts.<br></p><p>-- E<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160328/5e34e067/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 29, 2016 at 11:00:00am</p></header><div class="content"><p>Personally I prefer the requirement of spaces; if you require a method to have textual operators without spaces then IMO it’s probably not a good place to use a textual operator in the first place.<br></p><p>I like the space requirement as it essentially lets textual operators be custom keywords, for example the recent thread on striding for loops, we could do the following:<br></p><p>	for eachIndex in 1 ..&lt; 10 by 2 { … }<br></p><p>With the “by” defined as a custom operator on Range, rather than defining a new keyword or for loop variant (since it’s still essentially a for in loop). It’s really just a nicer alternative to: (1 ..&lt; 10).by(2).<br></p><p>&gt; On 28 Mar 2016, at 16:21, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Am 08.01.2016 um 09:38 schrieb Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt; I&#39;d be hesitant to support something like this. • is a very natural choice for a binary operator by itself, and restricting it to require the use of spaces seems unfortunate.<br>&gt; <br>&gt; What about if • would have to begin and end an operator containing letters?<br>&gt; <br>&gt; x = a •times• b •mod• 8<br>&gt; <br>&gt; This looks more symmetrically (like Haskell’s backticks) and wouldn’t need the restriction to require spaces.<br>&gt; <br>&gt; Or maybe<br>&gt; <br>&gt; x = a ‹times› b ‹mod› 8<br>&gt; <br>&gt; Also easily typeable on a Mac keyboard.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Re: free functions vs. methods: why does this matter? Supposing `foo` were the syntax (bad choice, because it already has another meaning, but bear with me), then you could disambiguate &quot;a `foo` b&quot; vs &quot;a `self.foo` b&quot; just as you can with regular function calls.<br>&gt; <br>&gt; Indeed.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Re: named parameters: there are two clear choices:<br>&gt;&gt; - Restrict such a syntax to functions without named parameters (seems acceptable to me).<br>&gt;&gt; - Ignore parameter names, allowing any binary function to be used (challenges with disambiguation, which I believe has had some discussion in the other thread about function names).<br>&gt;&gt; <br>&gt;&gt; This might be a crazy idea, but is it possible to support &quot;a myfunc b&quot; without any extra delimiters? As far as I can tell, there&#39;s currently no way this could parse as a valid expression, so there&#39;s no ambiguity to resolve, although I imagine it would be hard to make diagnostics work well. I&#39;m not sure how this would play with precedence, but that hasn&#39;t been discussed for any of the other solutions either.<br>&gt;&gt; <br>&gt;&gt; Jacob Bandes-Storch<br>&gt;&gt; <br>&gt;&gt; On Fri, Jan 8, 2016 at 12:29 AM, Jo Albright via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; The rationale is the same - the design of Swift really wants operators and identifiers to be partitioned into different namespaces.  Violating that would make it impossible to parse a swift file without parsing all of its imports.  This is a mistake that C made (you have to parse all the headers a file uses to reliably parse the file) that we don’t want to replicate in Swift.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Thanks Chris. I now understand the reasoning for separating the two groups. I don’t have a background in language creation, so whatever I can learn from these email lists is awesome. I have already gained a ton of knowledge following these conversations.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Alternative: Reserve one of the operator characters as an operator introducer. Everything from that character to the next whitespace is an operator name. This would allow non-operator characters in operator names while still preserving the strict operator/identifier separation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // • is the operator introducer character<br>&gt;&gt;&gt;    infix operator •times …<br>&gt;&gt;&gt;    infix operator •mod …<br>&gt;&gt;&gt;    x = a •times b •mod 8<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Limitations:<br>&gt;&gt;&gt; You still can&#39;t use an unadorned word as an operator name.<br>&gt;&gt;&gt; You can&#39;t use such an operator without whitespace (unlike operators whose names use operator characters only). <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Oooooo … that is a very cool alternative Greg. Honestly went into this proposal thinking there was no possibility, but now I have a glimmer of hope.<br>&gt;&gt; <br>&gt;&gt; Using “•” (option + 8 on keyboard) would be great since it is accessible through key combo, but isn’t widely used in normal expressions.<br>&gt;&gt; <br>&gt;&gt; What is needed to prove worth of such a feature to be added?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  Nerd . Designer . Developer<br>&gt;&gt; Jo Albright<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160329/2050b160/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>Allowing Characters for use as Custom Operators</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>March 30, 2016 at 11:00:00am</p></header><div class="content"><p>Scala allows a method with one argument to be used infix with spaces either<br>side, this would allow<br></p><p>for index in 1 ..&lt; 10 by 2 { ... }<br></p><p><br>if Range had a by method.<br></p><p>This feature has proved popular in Scala.<br></p><p>  -- Howard.<br></p><p>On 29 March 2016 at 21:37, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Personally I prefer the requirement of spaces; if you require a method to<br>&gt; have textual operators without spaces then IMO it’s probably not a good<br>&gt; place to use a textual operator in the first place.<br>&gt;<br>&gt; I like the space requirement as it essentially lets textual operators be<br>&gt; custom keywords, for example the recent thread on striding for loops, we<br>&gt; could do the following:<br>&gt;<br>&gt; for eachIndex in 1 ..&lt; 10 by 2 { … }<br>&gt;<br>&gt; With the “by” defined as a custom operator on Range, rather than defining<br>&gt; a new keyword or for loop variant (since it’s still essentially a for in<br>&gt; loop). It’s really just a nicer alternative to: (1 ..&lt; 10).by(2).<br>&gt;<br>&gt; On 28 Mar 2016, at 16:21, Thorsten Seitz via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Am 08.01.2016 um 09:38 schrieb Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I&#39;d be hesitant to support something like this. • is a very natural choice<br>&gt; for a binary operator by itself, and restricting it to require the use of<br>&gt; spaces seems unfortunate.<br>&gt;<br>&gt;<br>&gt; What about if • would have to begin and end an operator containing letters?<br>&gt;<br>&gt; x = a •times• b •mod• 8<br>&gt;<br>&gt; This looks more symmetrically (like Haskell’s backticks) and wouldn’t need<br>&gt; the restriction to require spaces.<br>&gt;<br>&gt; Or maybe<br>&gt;<br>&gt; x = a ‹times› b ‹mod› 8<br>&gt;<br>&gt; Also easily typeable on a Mac keyboard.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Re: free functions vs. methods: why does this matter? Supposing `foo` were<br>&gt; the syntax (bad choice, because it already has another meaning, but bear<br>&gt; with me), then you could disambiguate &quot;a `foo` b&quot; vs &quot;a `self.foo` b&quot; just<br>&gt; as you can with regular function calls.<br>&gt;<br>&gt;<br>&gt; Indeed.<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;<br>&gt; Re: named parameters: there are two clear choices:<br>&gt; - Restrict such a syntax to functions without named parameters (seems<br>&gt; acceptable to me).<br>&gt; - Ignore parameter names, allowing any binary function to be used<br>&gt; (challenges with disambiguation, which I believe has had some discussion in<br>&gt; the other thread about function names).<br>&gt;<br>&gt; This might be a crazy idea, but is it possible to support &quot;a myfunc b&quot;<br>&gt; without any extra delimiters? As far as I can tell, there&#39;s currently no<br>&gt; way this could parse as a valid expression, so there&#39;s no ambiguity to<br>&gt; resolve, although I imagine it would be hard to make diagnostics work well.<br>&gt; I&#39;m not sure how this would play with precedence, but that hasn&#39;t been<br>&gt; discussed for any of the other solutions either.<br>&gt;<br>&gt; Jacob Bandes-Storch<br>&gt;<br>&gt; On Fri, Jan 8, 2016 at 12:29 AM, Jo Albright via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; The rationale is the same - the design of Swift really wants operators<br>&gt;&gt; and identifiers to be partitioned into different namespaces.  Violating<br>&gt;&gt; that would make it impossible to parse a swift file without parsing all of<br>&gt;&gt; its imports.  This is a mistake that C made (you have to parse all the<br>&gt;&gt; headers a file uses to reliably parse the file) that we don’t want to<br>&gt;&gt; replicate in Swift.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Thanks Chris. I now understand the reasoning for separating the two<br>&gt;&gt; groups. I don’t have a background in language creation, so whatever I can<br>&gt;&gt; learn from these email lists is awesome. I have already gained a ton of<br>&gt;&gt; knowledge following these conversations.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Alternative: Reserve one of the operator characters as an operator<br>&gt;&gt; introducer. Everything from that character to the next whitespace is an<br>&gt;&gt; operator name. This would allow non-operator characters in operator names<br>&gt;&gt; while still preserving the strict operator/identifier separation.<br>&gt;&gt;<br>&gt;&gt;    // • is the operator introducer character<br>&gt;&gt;    infix operator •times …<br>&gt;&gt;    infix operator •mod …<br>&gt;&gt;    x = a •times b •mod 8<br>&gt;&gt;<br>&gt;&gt; Limitations:<br>&gt;&gt; You still can&#39;t use an unadorned word as an operator name.<br>&gt;&gt; You can&#39;t use such an operator without whitespace (unlike operators whose<br>&gt;&gt; names use operator characters only).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Oooooo … that is a very cool alternative Greg. Honestly went into this<br>&gt;&gt; proposal thinking there was no possibility, but now I have a glimmer of<br>&gt;&gt; hope.<br>&gt;&gt;<br>&gt;&gt; Using “•” (option + 8 on keyboard) would be great since it is accessible<br>&gt;&gt; through key combo, but isn’t widely used in normal expressions.<br>&gt;&gt;<br>&gt;&gt; What is needed to prove worth of such a feature to be added?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  Nerd . Designer . Developer<br>&gt;&gt; Jo Albright<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160330/ce0726ea/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
