<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6b81089e81d6bb1e14b5adb746725de1?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Alexis</string> &lt;abeingessner at apple.com&gt;<p>November  4, 2016 at 07:00:00pm</p></header><div class="content"><p>The swift standard library has this nasty little pattern/problem in it:<br></p><p>The types in the core library want to know about several types defined in foundation: NSString, NSArray, NSDictionary, etc. But core is imported by Foundation, so it can’t (circular references between modules). Thankfully, everything in ObjC is pretty opaquely defined and uniform, and Swift knows how to hook into that uniform layout. So the core library defines Shadow Protocols which provide whatever subset of that type’s API is considered interesting. These protocols are then used in place of the ObjC types. There’s also some magic compiler hooks so core lib types can subclass those foundation types.<br></p><p>However there’s sometimes two Shadow Protocols: one that defines the APIs the stdlib should provide (_NSFooCore), and one that extends that with extra APIs the stdlib wants to consume (_NSFoo). This leads to an awkward situation: as far as the runtime is concerned, the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do because it’s all just a big lie to hook into ObjC message passing with a bit of type safety, but the runtime doesn’t. So if you try to do a safe type cast, it will fail. This leads to a situation where we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive refactoring hazard.<br></p><p>For instance, there was a struct-containing-a-class that was being cast to _NSFoo in HashedCollections. This happened to work (but was probably still a violation of strict aliasing?) because the struct’s only field was the class. However the struct was later changed to a class, which silently made the cast completely incorrect, banishing the real _NSFoo to the shadow (protocol) realm.<br></p><p>Can we do anything better here? Note that there’s a few places where we also cast an AnyObject into an _NSFoo, but there’s some chance this is all legacy junk that can be updated to at least use _NSFooCore, if not _NSFoo itself.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161104/3b5ec8a1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>November  4, 2016 at 05:00:00pm</p></header><div class="content"><p>If the casts are always in one direction, can you make one protocol refine another?<br></p><p>Also note that @objc protocols are self-conforming as long as they don’t contain initializers or static methods, but I’m not sure if that helps.<br></p><p>&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt; <br>&gt; The types in the core library want to know about several types defined in foundation: NSString, NSArray, NSDictionary, etc. But core is imported by Foundation, so it can’t (circular references between modules). Thankfully, everything in ObjC is pretty opaquely defined and uniform, and Swift knows how to hook into that uniform layout. So the core library defines Shadow Protocols which provide whatever subset of that type’s API is considered interesting. These protocols are then used in place of the ObjC types. There’s also some magic compiler hooks so core lib types can subclass those foundation types.<br>&gt; <br>&gt; However there’s sometimes two Shadow Protocols: one that defines the APIs the stdlib should provide (_NSFooCore), and one that extends that with extra APIs the stdlib wants to consume (_NSFoo). This leads to an awkward situation: as far as the runtime is concerned, the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do because it’s all just a big lie to hook into ObjC message passing with a bit of type safety, but the runtime doesn’t. So if you try to do a safe type cast, it will fail. This leads to a situation where we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive refactoring hazard.<br>&gt; <br>&gt; For instance, there was a struct-containing-a-class that was being cast to _NSFoo in HashedCollections. This happened to work (but was probably still a violation of strict aliasing?) because the struct’s only field was the class. However the struct was later changed to a class, which silently made the cast completely incorrect, banishing the real _NSFoo to the shadow (protocol) realm.<br>&gt; <br>&gt; Can we do anything better here? Note that there’s a few places where we also cast an AnyObject into an _NSFoo, but there’s some chance this is all legacy junk that can be updated to at least use _NSFooCore, if not _NSFoo itself.<br>&gt; _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20161104/648741d7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Casting shadow protocols</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>November  8, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Nov 4, 2016, at 4:29 PM, Alexis via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; The swift standard library has this nasty little pattern/problem in it:<br>&gt; <br>&gt; The types in the core library want to know about several types defined in foundation: NSString, NSArray, NSDictionary, etc. But core is imported by Foundation, so it can’t (circular references between modules). Thankfully, everything in ObjC is pretty opaquely defined and uniform, and Swift knows how to hook into that uniform layout. So the core library defines Shadow Protocols which provide whatever subset of that type’s API is considered interesting. These protocols are then used in place of the ObjC types. There’s also some magic compiler hooks so core lib types can subclass those foundation types.<br>&gt; <br>&gt; However there’s sometimes two Shadow Protocols: one that defines the APIs the stdlib should provide (_NSFooCore), and one that extends that with extra APIs the stdlib wants to consume (_NSFoo). This leads to an awkward situation: as far as the runtime is concerned, the stdlib’s _NSFooCores don’t conform to _NSFoo! We know they do because it’s all just a big lie to hook into ObjC message passing with a bit of type safety, but the runtime doesn’t. So if you try to do a safe type cast, it will fail. This leads to a situation where we sprinkle code with unsafeBitCast’s to _NSFoo which is a massive refactoring hazard.<br>&gt; <br>&gt; For instance, there was a struct-containing-a-class that was being cast to _NSFoo in HashedCollections. This happened to work (but was probably still a violation of strict aliasing?) because the struct’s only field was the class. However the struct was later changed to a class, which silently made the cast completely incorrect, banishing the real _NSFoo to the shadow (protocol) realm.<br>&gt; <br>&gt; Can we do anything better here? Note that there’s a few places where we also cast an AnyObject into an _NSFoo, but there’s some chance this is all legacy junk that can be updated to at least use _NSFooCore, if not _NSFoo itself.<br></p><p>The casting is largely just to get the compiler to let you call ObjC methods on an object reference, right? We could sidestep the undefined-ness of unsafeBitCast perhaps by just giving the standard library a `Builtin.objc_msgSend` that takes a selector and a bag of arguments, and performs the method call with ObjC method semantics.<br></p><p>-Joe<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
