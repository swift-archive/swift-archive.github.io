<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/389ea0cf26e2a2d4646bf580da2fb6b5?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Martin R</string> &lt;martinr448 at gmail.com&gt;<p>August 17, 2016 at 07:00:00pm</p></header><div class="content"><p>I am trying to figure out how to work correctly with the new UnsafeRawPointer API (from https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md ).<br></p><p>Here my concrete example: The connect() system call takes a (const struct sockaddr *address) parameter, but one actually passes the address of a struct sockaddr_in or sockaddr_in6 (or ...).<br></p><p>In Swift 2.2 this could be done as<br></p><p>    var addr = sockaddr_in() // or sockaddr_in6()<br>    // fill addr fields ...<br>    let sock = socket(PF_INET, SOCK_STREAM, 0)<br></p><p>    let result = withUnsafePointer(&amp;addr) {<br>        connect(sock, UnsafePointer($0), socklen_t(strideofValue(addr)))<br>    }<br></p><p>With the latest Swift from Xcode 8 beta 6, unsafe pointers cannot be simply initialized from a different kind of unsafe pointer anymore. I came up with two different solutions: <br></p><p>    let result = withUnsafePointer(to: &amp;addr) {<br>        connect(sock,<br>                UnsafeRawPointer($0).assumingMemoryBound(to: sockaddr.self),<br>                socklen_t(MemoryLayout&lt;sockaddr_in&gt;.stride))<br>    }<br></p><p>or<br></p><p>    let result = withUnsafePointer(to: &amp;addr) {<br>        $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {<br>            connect(sock, $0, socklen_t(MemoryLayout&lt;sockaddr_in&gt;.stride))<br>        }<br>    }<br></p><p>which both compile and run correctly.<br></p><p>My questions are:<br>- Are both solutions correct, should one be preferred, or are both wrong?<br>- Can the same be achieved simpler?<br></p><p>Thanks,<br>Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>August 18, 2016 at 08:00:00am</p></header><div class="content"><p>On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; - Are both solutions correct, should one be preferred, or are both wrong?<br></p><p>Your `withMemoryRebound` solution is correct.<br></p><p>&gt; - Can the same be achieved simpler?<br></p><p>Not without introducing a layer of abstraction.<br></p><p>In my case I introduced an abstract `Address` type (basically a wrapper around `sockaddr_storage`) and then added a method to that object which calls a closure with the right parameters (actually, multiple such methods, depending on whether I’m calling something like `connect` which takes an address, or `getpeername`, which returns one).  This approach concentrates all the ugly in one place, making the rest of my BSD Sockets code much cleaner.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Aug 18, 2016, at 12:28 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; - Are both solutions correct, should one be preferred, or are both wrong?<br>&gt; <br>&gt; Your `withMemoryRebound` solution is correct.<br></p><p>Absolutely, withMemoryRebound is always safe. You can use it whenever you just need to reinterpret memory at a call site and know the number of values stored that memory location. In this case it’s “easy&quot; because you’re dealing a single sockaddr_in.<br></p><p>The UnsafeRawPointer proposal is the definitive reference<br>https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;<br></p><p>But this migration guide is more approachable… it’s still WIP:<br>https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585<br></p><p>&gt;&gt; - Can the same be achieved simpler?<br>&gt; <br>&gt; Not without introducing a layer of abstraction.<br>&gt; <br>&gt; In my case I introduced an abstract `Address` type (basically a wrapper around `sockaddr_storage`) and then added a method to that object which calls a closure with the right parameters (actually, multiple such methods, depending on whether I’m calling something like `connect` which takes an address, or `getpeername`, which returns one).  This approach concentrates all the ugly in one place, making the rest of my BSD Sockets code much cleaner.<br></p><p>This is an annoying UpdatePointer migration case because it falls under the category of misbehaving C APIs that we deliberately don&#39;t want to encourage in Swift.<br></p><p>The only good answer is to provide a Swift wrapper on top of the socket API as Quinn has done. It would be nice to post that code at some point so users of the socket API can copy-paste into their project.<br></p><p>-Andy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160819/f527810c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/17d2af4afb70023e28e655d17471a018?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Michael Gottesman</string> &lt;mgottesman at apple.com&gt;<p>August 19, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 1:58 PM, Andrew Trick via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Aug 18, 2016, at 12:28 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; - Are both solutions correct, should one be preferred, or are both wrong?<br>&gt;&gt; <br>&gt;&gt; Your `withMemoryRebound` solution is correct.<br>&gt; <br>&gt; Absolutely, withMemoryRebound is always safe. You can use it whenever you just need to reinterpret memory at a call site and know the number of values stored that memory location. In this case it’s “easy&quot; because you’re dealing a single sockaddr_in.<br>&gt; <br>&gt; The UnsafeRawPointer proposal is the definitive reference<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;<br>&gt; <br>&gt; But this migration guide is more approachable… it’s still WIP:<br>&gt; https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585 &lt;https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585&gt;<br>&gt; <br>&gt;&gt;&gt; - Can the same be achieved simpler?<br>&gt;&gt; <br>&gt;&gt; Not without introducing a layer of abstraction.<br>&gt;&gt; <br>&gt;&gt; In my case I introduced an abstract `Address` type (basically a wrapper around `sockaddr_storage`) and then added a method to that object which calls a closure with the right parameters (actually, multiple such methods, depending on whether I’m calling something like `connect` which takes an address, or `getpeername`, which returns one).  This approach concentrates all the ugly in one place, making the rest of my BSD Sockets code much cleaner.<br>&gt; <br>&gt; This is an annoying UpdatePointer migration case because it falls under the category of misbehaving C APIs that we deliberately don&#39;t want to encourage in Swift.<br>&gt; <br>&gt; The only good answer is to provide a Swift wrapper on top of the socket API as Quinn has done. It would be nice to post that code at some point so users of the socket API can copy-paste into their project.<br></p><p>I wonder if we could provide it via an overlay or if it is a more general thing that could use a generic/protocol? Just a random thought.<br></p><p>&gt; <br>&gt; -Andy<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160819/368deff0/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>August 22, 2016 at 05:00:00pm</p></header><div class="content"><p>On 18 Aug 2016, at 08:28, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; In my case I introduced an abstract `Address` type (basically a wrapper around `sockaddr_storage`) and then added a method to that object which calls a closure with the right parameters (actually, multiple such methods, depending on whether I’m calling something like `connect` which takes an address, or `getpeername`, which returns one).  This approach concentrates all the ugly in one place, making the rest of my BSD Sockets code much cleaner.<br></p><p>I’ve been revisiting this issue recently and decided to tidy up my code enough to share with others.  It’s pasted in below.  Bon apétit!<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p><p>---------------------------------------------------------------------------<br>import Darwin<br></p><p>extension sockaddr_storage {<br></p><p>    /// Calls a closure with traditional BSD Sockets address parameters.<br>    ///<br>    /// This is used to call BSD Sockets routines like `connect`, which accept their <br>    /// address as an `sa` and `saLen` pair.  For example:<br>    ///<br>    ///     let ss: sockaddr_storage = …<br>    ///     let connectResult = ss.withSockAddr { (sa, saLen) in<br>    ///         connect(fd, sa, saLen)<br>    ///     }    <br>    ///<br>    /// - parameter body: A closure to call with `self` referenced appropriately for calling <br>    ///   BSD Sockets APIs that take an address.<br>    ///<br>    /// - throws: Any error thrown by `body`.<br>    ///<br>    /// - returns: Any result returned by `body`.<br>    <br>    func withSockAddr&lt;ReturnType&gt;(_ body: (_ sa: UnsafePointer&lt;sockaddr&gt;, _ saLen: socklen_t) throws -&gt; ReturnType) rethrows -&gt; ReturnType {<br>        // We need to create a mutable copy of `self` so that we can pass it to `withUnsafePointer(to:_:)`.<br>        var ss = self<br>        // Get a typed unsafe pointer to `ss`.<br>        return try withUnsafePointer(to: &amp;ss) {<br>            // Temporarily view that as `sockaddr` while we call `body`.<br>            try $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {<br>                try body($0, socklen_t(self.ss_len))<br>            }<br>        }<br>    }<br></p><p>    /// Calls a closure such that it can return an address based on traditional BSD Sockets parameters. <br>    ///<br>    /// This is used to call BSD Sockets routines like `accept`, which return a value (the file <br>    /// descriptor) and an address via memory pointed to by `sa` and `saLen` parameters.  For example:<br>    /// <br>    ///     let (acceptResult, peerAddr) = sockaddr_storage.fromSockAddr { (_ sa: UnsafeMutablePointer&lt;sockaddr&gt;, _ saLen: inout socklen_t) in<br>    ///         return accept(fd, sa, &amp;saLen)<br>    ///     }<br>    ///<br>    /// - parameter body: A closure to call with parameters appropriate for calling BSD Sockets APIs <br>    ///   that return an address.<br>    ///<br>    /// - throws: Any error thrown by `body`.<br>    ///<br>    /// - returns: A tuple consistent of the result returned by `body` and an address set up by <br>    ///   `body` via its `sa` and `saLen` parameters.<br></p><p>    static func fromSockAddr&lt;ReturnType&gt;(_ body: (_ sa: UnsafeMutablePointer&lt;sockaddr&gt;, _ saLen: inout socklen_t) throws -&gt; ReturnType) rethrows -&gt; (ReturnType, sockaddr_storage) {<br>        // We need a mutable `sockaddr_storage` so that we can pass it to `withUnsafePointer(to:_:)`.<br>        var ss = sockaddr_storage()<br>        // Similarly, we need a mutable copy of our length for the benefit of `saLen`.<br>        var saLen = socklen_t(MemoryLayout&lt;sockaddr_storage&gt;.size)<br>        // Get a typed unsafe pointer to `ss`.<br>        let result = try withUnsafePointer(to: &amp;ss) {<br>            // Temporarily view that as `sockaddr` while we call `body`.<br>            try $0.withMemoryRebound(to: sockaddr.self, capacity: 1) {<br>                try body($0, &amp;saLen)<br>            }<br>        }<br>        return (result, ss)<br>    }<br></p><p>    /// Calls a closure with an address parameter of a user-specified type.<br>    ///<br>    /// This makes it easy to access the fields of an address as the appropriate type.  For example:<br>    /// <br>    ///     let sin: sockaddr_storage = … initialise with an AF_INET address …<br>    ///     sin.withSockAddrType { (sin: inout sockaddr_in) in<br>    ///         print(sin.sin_len)<br>    ///         print(UInt16(bigEndian: sin.sin_port))<br>    ///     }<br>    ///<br>    /// In this case the closure returns void, but there may be other circumstances where it&#39;s useful <br>    /// to have a return type.<br>    ///<br>    /// - note: `body` takes an inout parameter for the sake of folks who need to take <br>    ///   a pointer to elements of that parameter.  We ignore any changes that the `body` <br>    ///   might make to this value.  Without this affordance, the following code would not <br>    ///   work:<br>    ///<br>    ///         let sus: sockaddr_storage = … initialise with an AF_UNIX address …<br>    ///         sus.withSockAddrType { (sun: inout sockaddr_un) in<br>    ///             print(sun.sun_len)<br>    ///             print(String(cString: &amp;sun.sun_path.0))<br>    ///         }<br>    ///<br>    /// - parameter body: A closure to call with `self` referenced via an arbitrary type.<br>    ///   Careful with that axe, Eugene.<br>    ///<br>    /// - throws: Any error thrown by `body`.<br>    ///<br>    /// - returns: Any result returned by `body`.<br>    ///<br>    /// - precondition: `AddrType` must not be larger than `sockaddr_storage`.<br></p><p>    func withSockAddrType&lt;AddrType, ReturnType&gt;(_ body: (_ sax: inout AddrType) throws -&gt; ReturnType) rethrows -&gt; ReturnType {<br>        precondition(MemoryLayout&lt;AddrType&gt;.size &lt;= MemoryLayout&lt;sockaddr_storage&gt;.size)<br>        // We need to create a mutable copy of `self` so that we can pass it to `withUnsafePointer(to:_:)`.<br>        var ss = self<br>        // Get a typed unsafe pointer to `ss`.<br>        return try withUnsafeMutablePointer(to: &amp;ss) {  <br>            // Temporarily view that as `AddrType` while we call `body`.<br>            try $0.withMemoryRebound(to: AddrType.self, capacity: 1) { <br>                try body(&amp;$0.pointee)<br>            }<br>        }<br>    }<br></p><p>    /// Calls a closure such that it can return an address via a user-specified type.<br>    ///<br>    /// This is useful if you want to create an address from a specific sockaddr_xxx <br>    /// type that you initialise piecemeal.  For example:<br>    /// <br>    ///     let (_, sin) = sockaddr_storage.fromSockAddr { (sin: inout sockaddr_in) in<br>    ///         sin.sin_family = sa_family_t(AF_INET)<br>    ///         sin.sin_len = UInt8(MemoryLayout&lt;sockaddr_in&gt;.size)<br>    ///         sin.sin_port = (12345 as in_port_t).bigEndian<br>    ///     }<br>    /// <br>    /// In this case the closure returns void, but there may be other circumstances where it&#39;s useful <br>    /// to have a return type.<br>    ///<br>    /// - parameter body: A closure to call with parameters appropriate for returning an address.<br>    ///<br>    /// - throws: Any error thrown by `body`.<br>    ///<br>    /// - returns: A tuple consistent of the result returned by `body` and an address set <br>    ///   up by `body` via the `sax` inout parameter.<br>    ///<br>    /// - precondition: `AddrType` must not be larger than `sockaddr_storage`.<br></p><p>    static func fromSockAddr&lt;AddrType, ReturnType&gt;(_ body: (_ sax: inout AddrType) throws -&gt; ReturnType) rethrows -&gt; (ReturnType, sockaddr_storage) {<br>        precondition(MemoryLayout&lt;AddrType&gt;.size &lt;= MemoryLayout&lt;sockaddr_storage&gt;.size)<br>        // We need a mutable `sockaddr_storage` so that we can pass it to `withUnsafePointer(to:_:)`.<br>        var ss = sockaddr_storage()<br>        // Get a typed unsafe pointer to `ss`.<br>        let result = try withUnsafePointer(to: &amp;ss) {<br>            // Temporarily view that as `AddrType` while we call `body`.<br>            try $0.withMemoryRebound(to: AddrType.self, capacity: 1) {<br>                try body(&amp;$0.pointee)<br>            }<br>        }<br>        return (result, ss)<br>    }<br>}<br>---------------------------------------------------------------------------<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
