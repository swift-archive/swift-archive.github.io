<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>Hi everyone!<br></p><p>I’m experimenting with this functional selection sort code and I wonder if anyone could help me simplify the portion indicated below.<br></p><p><br>// Swift 3<br></p><p>func selectionSort(_ array: [Int]) -&gt; [Int] {<br></p><p>    guard array.count &gt; 1, let minElement = array.min() else {<br>        return array<br>    }<br></p><p>    let indexOfMinElement = array.index(of: minElement)!<br></p><p>    // All of this just to filter out the first smallest element and return the rest<br>    // Also tried ‘suffix(from:)&#39; here, but couldn’t make it work properly<br>    let rest = array.enumerated()<br>                    .filter({ index, _ in index != indexOfMinElement })<br>                    .map({ _, element in element })<br></p><p>    return [minElement] + selectionSort(rest)<br>}<br></p><p><br>By the way, it feels really weird to chain method calls like this in Swift 3, particularly due to the mixing of terms of art (e.g. “filter” and “map”) with other methods that follow the -ed/-ing rules from the API guidelines (e.g. enumerated).<br></p><p>Best,<br></p><p>— A<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160628/a61de4b5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5daa1633e5f933f7901a26b0329015cd?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Aaron Bohannon</string> &lt;aaron678 at gmail.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>I think that&#39;s about as simple as you can make it unless you allow yourself<br>to remove more than one element at a time when the minimum appears more<br>than once.<br></p><p>Here&#39;s the question I find interesting: what&#39;s the simplest way to change<br>that code into a version based on lazy collections?  After all, there would<br>arguably be some real practical value to a lazy recursive selection sort in<br>cases where only a relatively small prefix of the resulting collection was<br>expected to be needed.  I took a stab at making your code lazy but quickly<br>realized that it wasn&#39;t going to be as easy as I thought.<br></p><p><br></p><p>On Tue, Jun 28, 2016 at 8:50 AM, Adriano Ferreira via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone!<br>&gt;<br>&gt; I’m experimenting with this functional selection sort code and I wonder if<br>&gt; anyone could help me simplify the portion indicated below.<br>&gt;<br>&gt;<br>&gt; // Swift 3<br>&gt;<br>&gt; func selectionSort(_ array: [Int]) -&gt; [Int] {<br>&gt;<br>&gt;     guard array.count &gt; 1, let minElement = array.min() else {<br>&gt;         return array<br>&gt;     }<br>&gt;<br>&gt;     let indexOfMinElement = array.index(of: minElement)!<br>&gt;<br>&gt;     // All of this just to filter out the first smallest element and<br>&gt; return the rest<br>&gt;     // Also tried ‘suffix(from:)&#39; here, but couldn’t make it work properly<br>&gt;     let rest = array.enumerated()<br>&gt;                     .filter({ index, _ in index != indexOfMinElement })<br>&gt;                     .map({ _, element in element })<br>&gt;<br>&gt;     return [minElement] + selectionSort(rest)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; By the way, it feels really weird to chain method calls like this in Swift<br>&gt; 3, particularly due to the mixing of terms of art (e.g. “filter” and “map”)<br>&gt; with other methods that follow the -ed/-ing rules from the API<br>&gt; guidelines (e.g. enumerated).<br>&gt;<br>&gt; Best,<br>&gt;<br>&gt; — A<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160628/255caf09/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>June 28, 2016 at 09:00:00pm</p></header><div class="content"><p>I’m not sure if you wanted to stick with the pure functional approach, but<br>here’s an alternative that uses Range&lt;Int&gt; to take care of most of the work.<br></p><p>func selectionSort(_ array: [Int]) -&gt; [Int] {<br>    guard let minValue = array.min(), let index = array.index(of: minValue)<br>else {<br>        return []<br>    }<br></p><p>    let ranges = [0..&lt;index, index.advanced(by: 1)..&lt;array.endIndex]<br>    return [minValue] + selectionSort(ranges.flatMap { array[$0] })<br>}<br></p><p><br>On Tue, Jun 28, 2016 at 7:20 PM, Aaron Bohannon via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I think that&#39;s about as simple as you can make it unless you allow<br>&gt; yourself to remove more than one element at a time when the minimum appears<br>&gt; more than once.<br>&gt;<br>&gt; Here&#39;s the question I find interesting: what&#39;s the simplest way to change<br>&gt; that code into a version based on lazy collections?  After all, there would<br>&gt; arguably be some real practical value to a lazy recursive selection sort in<br>&gt; cases where only a relatively small prefix of the resulting collection was<br>&gt; expected to be needed.  I took a stab at making your code lazy but quickly<br>&gt; realized that it wasn&#39;t going to be as easy as I thought.<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Tue, Jun 28, 2016 at 8:50 AM, Adriano Ferreira via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Hi everyone!<br>&gt;&gt;<br>&gt;&gt; I’m experimenting with this functional selection sort code and I wonder<br>&gt;&gt; if anyone could help me simplify the portion indicated below.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; // Swift 3<br>&gt;&gt;<br>&gt;&gt; func selectionSort(_ array: [Int]) -&gt; [Int] {<br>&gt;&gt;<br>&gt;&gt;     guard array.count &gt; 1, let minElement = array.min() else {<br>&gt;&gt;         return array<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     let indexOfMinElement = array.index(of: minElement)!<br>&gt;&gt;<br>&gt;&gt;     // All of this just to filter out the first smallest element and<br>&gt;&gt; return the rest<br>&gt;&gt;     // Also tried ‘suffix(from:)&#39; here, but couldn’t make it work<br>&gt;&gt; properly<br>&gt;&gt;     let rest = array.enumerated()<br>&gt;&gt;                     .filter({ index, _ in index != indexOfMinElement })<br>&gt;&gt;                     .map({ _, element in element })<br>&gt;&gt;<br>&gt;&gt;     return [minElement] + selectionSort(rest)<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; By the way, it feels really weird to chain method calls like this in<br>&gt;&gt; Swift 3, particularly due to the mixing of terms of art (e.g. “filter” and<br>&gt;&gt; “map”) with other methods that follow the -ed/-ing rules from the API<br>&gt;&gt; guidelines (e.g. enumerated).<br>&gt;&gt;<br>&gt;&gt; Best,<br>&gt;&gt;<br>&gt;&gt; — A<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160628/de43a202/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 28, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; <br>&gt; On Jun 28, 2016, at 8:18 PM, Dan Loewenherz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not sure if you wanted to stick with the pure functional approach, but here’s an alternative that uses Range&lt;Int&gt; to take care of most of the work.<br>&gt; <br>&gt; func selectionSort(_ array: [Int]) -&gt; [Int] {<br>&gt;     guard let minValue = array.min(), let index = array.index(of: minValue) else {<br>&gt;         return []<br>&gt;     }<br>&gt; <br>&gt;     let ranges = [0..&lt;index, index.advanced(by: 1)..&lt;array.endIndex]<br>&gt;     return [minValue] + selectionSort(ranges.flatMap { array[$0] })<br>&gt; }<br>&gt; <br></p><p>Most everyone is doing two passes, one to get the minimum value, another to get its index.<br>I aesthetically prefer using enumerate to do both at once.<br></p><p>-- E<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f0154768aeec561194e651b0bca02d9?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Dan Loewenherz</string> &lt;dan at lionheartsw.com&gt;<p>June 29, 2016 at 12:00:00am</p></header><div class="content"><p>On Tue, Jun 28, 2016 at 9:58 PM, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br></p><p>&gt; Most everyone is doing two passes, one to get the minimum value, another<br>&gt; to get its index.<br>&gt; I aesthetically prefer using enumerate to do both at once.<br>&gt;<br>&gt; -- E<br>&gt;<br></p><p>Makes sense. Here’s a revision. It’s not as simple, but it does just one<br>pass through the array:<br></p><p><br>func selectionSort(_ array: [Int]) -&gt; [Int] {<br></p><p>    guard let first = array.first else { return [] }<br></p><p>    let (index, minValue) = array.enumerated().reduce((0, first)) { (carry,<br>item) in<br></p><p>        if item.element &lt; carry.1 { return item } else { return carry }<br></p><p>    }<br></p><p><br>    let ranges = [0..&lt;index, index.advanced(by: 1)..&lt;array.endIndex]<br></p><p>    return [minValue] + selectionSort(ranges.flatMap { array[$0] })<br></p><p>}<br></p><p>~Dan<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160629/e3ca2568/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>June 29, 2016 at 11:00:00pm</p></header><div class="content"><p>Was trying to using some functional programming concepts while also using as little memory as possible.  The big advantage of using a selections sort is that it sorts w/o having to allocation additional memory.  This still violates that, but it’s closer.  :)<br></p><p>func selectionSort(_ array: inout [Int]) {<br>    for index in 0..&lt;array.count {<br>        // .1 is value .0 is the index on the enumeration<br>        let minElement = array.enumerated().dropFirst(index).min(isOrderedBefore: { $0.1 &lt; $1.1 } )<br>        if index != minElement!.0 {<br>            swap(&amp;array[index], &amp;array[minElement!.0])<br>        }<br>    }<br>}<br></p><p>or using recursion:<br></p><p>func selectionSort(_ array: inout [Int], index: Int = 0) {<br>    if index &lt; array.count {<br>        // .1 is value .0 is the index on the enumeration<br>        let minElement = array.indexed().dropFirst(index).min(isOrderedBefore: { $0.1 &lt; $1.1 } )<br>        if index != minElement!.0 {<br>            swap(&amp;array[index], &amp;array[minElement!.0])<br>        }<br>        selectionSort(&amp;array, index: index+1)<br>    }<br>}<br></p><p><br></p><p>On 6/28/16, 10:58 PM, &quot;swift-users-bounces at swift.org on behalf of Erica Sadun via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br></p><p>&gt; <br>&gt; On Jun 28, 2016, at 8:18 PM, Dan Loewenherz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not sure if you wanted to stick with the pure functional approach, but here’s an alternative that uses Range&lt;Int&gt; to take care of most of the work.<br>&gt; <br>&gt; func selectionSort(_ array: [Int]) -&gt; [Int] {<br>&gt;     guard let minValue = array.min(), let index = array.index(of: minValue) else {<br>&gt;         return []<br>&gt;     }<br>&gt; <br>&gt;     let ranges = [0..&lt;index, index.advanced(by: 1)..&lt;array.endIndex]<br>&gt;     return [minValue] + selectionSort(ranges.flatMap { array[$0] })<br>&gt; }<br>&gt; <br></p><p>Most everyone is doing two passes, one to get the minimum value, another to get its index.<br>I aesthetically prefer using enumerate to do both at once.<br></p><p>-- E<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/18be32aa5ee2c4aa6ba2f23cf6ac42f7?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Tod Cunningham</string> &lt;tcunningham at vectorform.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>This was bugging me last night, as I still didn’t like the solution.  What about something like:<br></p><p>func selectionSort(_ originalArray: [Int]) -&gt; [Int] {<br>    var array = originalArray<br>    for index in 0..&lt;array.count {<br>        let minIndex = array.indices.clamped(to: index..&lt;x.count).min(isOrderedBefore: { array[$0] &lt; array[$1] })<br>        if index != minIndex {<br>            swap(&amp;array[index], &amp;array[minIndex!])<br>        }<br>    }<br>    return array<br>}<br></p><p><br></p><p>On 6/29/16, 7:12 PM, &quot;swift-users-bounces at swift.org on behalf of Tod Cunningham via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br></p><p>Was trying to using some functional programming concepts while also using as little memory as possible.  The big advantage of using a selections sort is that it sorts w/o having to allocation additional memory.  This still violates that, but it’s closer.  :)<br></p><p>func selectionSort(_ array: inout [Int]) {<br>    for index in 0..&lt;array.count {<br>        // .1 is value .0 is the index on the enumeration<br>        let minElement = array.enumerated().dropFirst(index).min(isOrderedBefore: { $0.1 &lt; $1.1 } )<br>        if index != minElement!.0 {<br>            swap(&amp;array[index], &amp;array[minElement!.0])<br>        }<br>    }<br>}<br></p><p>or using recursion:<br></p><p>func selectionSort(_ array: inout [Int], index: Int = 0) {<br>    if index &lt; array.count {<br>        // .1 is value .0 is the index on the enumeration<br>        let minElement = array.indexed().dropFirst(index).min(isOrderedBefore: { $0.1 &lt; $1.1 } )<br>        if index != minElement!.0 {<br>            swap(&amp;array[index], &amp;array[minElement!.0])<br>        }<br>        selectionSort(&amp;array, index: index+1)<br>    }<br>}<br></p><p><br></p><p>On 6/28/16, 10:58 PM, &quot;swift-users-bounces at swift.org on behalf of Erica Sadun via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br></p><p>&gt; <br>&gt; On Jun 28, 2016, at 8:18 PM, Dan Loewenherz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m not sure if you wanted to stick with the pure functional approach, but here’s an alternative that uses Range&lt;Int&gt; to take care of most of the work.<br>&gt; <br>&gt; func selectionSort(_ array: [Int]) -&gt; [Int] {<br>&gt;     guard let minValue = array.min(), let index = array.index(of: minValue) else {<br>&gt;         return []<br>&gt;     }<br>&gt; <br>&gt;     let ranges = [0..&lt;index, index.advanced(by: 1)..&lt;array.endIndex]<br>&gt;     return [minValue] + selectionSort(ranges.flatMap { array[$0] })<br>&gt; }<br>&gt; <br></p><p>Most everyone is doing two passes, one to get the minimum value, another to get its index.<br>I aesthetically prefer using enumerate to do both at once.<br></p><p>-- E<br></p><p>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>_______________________________________________<br>swift-users mailing list<br>swift-users at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-users<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9f3e3f9871fd088e42df4509aa724367?s=50"></div><header><strong>Simplify chained calls</strong> from <string>Adriano Ferreira</string> &lt;adriano.ferreira at me.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>Hi Tod, thanks for sharing your ideas. Much appreciated!<br></p><p>Feel free to take a look at my playground where I explore many other alternative implementations.<br></p><p>https://github.com/adrfer/Sort/tree/swift-3<br></p><p>Best,<br></p><p>— A<br></p><p>&gt; On Jun 30, 2016, at 11:32 AM, Tod Cunningham via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; This was bugging me last night, as I still didn’t like the solution.  What about something like:<br>&gt; <br>&gt; func selectionSort(_ originalArray: [Int]) -&gt; [Int] {<br>&gt;    var array = originalArray<br>&gt;    for index in 0..&lt;array.count {<br>&gt;        let minIndex = array.indices.clamped(to: index..&lt;x.count).min(isOrderedBefore: { array[$0] &lt; array[$1] })<br>&gt;        if index != minIndex {<br>&gt;            swap(&amp;array[index], &amp;array[minIndex!])<br>&gt;        }<br>&gt;    }<br>&gt;    return array<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; On 6/29/16, 7:12 PM, &quot;swift-users-bounces at swift.org on behalf of Tod Cunningham via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Was trying to using some functional programming concepts while also using as little memory as possible.  The big advantage of using a selections sort is that it sorts w/o having to allocation additional memory.  This still violates that, but it’s closer.  :)<br>&gt; <br>&gt; func selectionSort(_ array: inout [Int]) {<br>&gt;    for index in 0..&lt;array.count {<br>&gt;        // .1 is value .0 is the index on the enumeration<br>&gt;        let minElement = array.enumerated().dropFirst(index).min(isOrderedBefore: { $0.1 &lt; $1.1 } )<br>&gt;        if index != minElement!.0 {<br>&gt;            swap(&amp;array[index], &amp;array[minElement!.0])<br>&gt;        }<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; or using recursion:<br>&gt; <br>&gt; func selectionSort(_ array: inout [Int], index: Int = 0) {<br>&gt;    if index &lt; array.count {<br>&gt;        // .1 is value .0 is the index on the enumeration<br>&gt;        let minElement = array.indexed().dropFirst(index).min(isOrderedBefore: { $0.1 &lt; $1.1 } )<br>&gt;        if index != minElement!.0 {<br>&gt;            swap(&amp;array[index], &amp;array[minElement!.0])<br>&gt;        }<br>&gt;        selectionSort(&amp;array, index: index+1)<br>&gt;    }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt; On 6/28/16, 10:58 PM, &quot;swift-users-bounces at swift.org on behalf of Erica Sadun via swift-users&quot; &lt;swift-users-bounces at swift.org on behalf of swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 28, 2016, at 8:18 PM, Dan Loewenherz via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I’m not sure if you wanted to stick with the pure functional approach, but here’s an alternative that uses Range&lt;Int&gt; to take care of most of the work.<br>&gt;&gt; <br>&gt;&gt; func selectionSort(_ array: [Int]) -&gt; [Int] {<br>&gt;&gt;    guard let minValue = array.min(), let index = array.index(of: minValue) else {<br>&gt;&gt;        return []<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;    let ranges = [0..&lt;index, index.advanced(by: 1)..&lt;array.endIndex]<br>&gt;&gt;    return [minValue] + selectionSort(ranges.flatMap { array[$0] })<br>&gt;&gt; }<br>&gt;&gt; <br>&gt; <br>&gt; Most everyone is doing two passes, one to get the minimum value, another to get its index.<br>&gt; I aesthetically prefer using enumerate to do both at once.<br>&gt; <br>&gt; -- E<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
