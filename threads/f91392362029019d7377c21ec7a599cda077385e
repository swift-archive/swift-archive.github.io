<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  3, 2016 at 05:00:00pm</p></header><div class="content"><p>To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try to write up a proposal on type narrowing in Swift.<br>Please give your feedback on the functionality proposed, as well as the clarity of the proposal/examples themselves; I&#39;ve tried to keep it straightforward, but I do tend towards being overly verbose, I&#39;ve always tried to have the examples build upon one another to show how it all stacks up.<br></p><p><br></p><p>Type Narrowing<br></p><p>Proposal: SE-NNNN &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>Author: Haravikk &lt;https://github.com/haravikk&gt;<br>Status: Awaiting review<br>Review manager: TBD<br> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#introduction&gt;Introduction<br></p><p>This proposal is to introduce type-narrowing to Swift, enabling the type-checker to automatically infer a narrower type from context such as conditionals.<br></p><p>Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#motivation&gt;Motivation<br></p><p>Currently in Swift there are various pieces of boilerplate required in order to manually narrow types. The most obvious is in the case of polymorphism:<br></p><p>let foo:A = B() // B extends A<br>if foo is B {<br>    (foo as B).someMethodSpecificToB()<br>}<br>But also in the case of unwrapping of optionals:<br></p><p>var foo:A? = A()<br>if var foo = foo { // foo is now unwrapped and shadowed<br>    foo.someMethod()<br>    foo!.someMutatingMethod() // Can&#39;t be done<br>}<br> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#proposed-solution&gt;Proposed solution<br></p><p>The proposed solution to the boiler-plate is to introduce type-narrowing, essentially a finer grained knowledge of type based upon context. Thus as any contextual clue indicating a more or less specific type are encountered, the type of the variable will reflect this from that point onwards.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#detailed-design&gt;Detailed design<br></p><p>The concept of type-narrowing would essentially treat all variables as having not just a single type, but instead as having a stack of increasingly specific (narrow) types.<br></p><p>Whenever a contextual clue such as a conditional is encountered, the type checker will infer whether this narrows the type, and add the new narrow type to the stack from that point onwards. Whenever the type widens again narrower types are popped from the stack.<br></p><p>Here are the above examples re-written to take advantage of type-narrowing:<br></p><p>let foo:A = B() // B extends A<br>if foo is B { // B is added to foo&#39;s type stack<br>    foo.someMethodSpecificToB()<br>}<br>// B is popped from foo&#39;s type stack<br>var foo:A? = A()<br>if foo != nil { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>   foo.someMethod()<br>   foo.someMutatingMethod() // Can modify mutable original<br>}<br>// Optional&lt;A&gt;.some is popped from foo&#39;s type stack<br> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#enum-types&gt;Enum Types<br></p><p>As seen in the simple optional example, to implement optional support each case in an enum is considered be a unique sub-type of the enum itself, thus allowing narrowing to nil (.none) and non-nil (.some) types.<br></p><p>This behaviour actually enables some other useful behaviours, specifically, if a value is known to be either nil or non-nil then the need to unwrap or force unwrap the value can be eliminated entirely, with the compiler able to produce errors if these are used incorrectly, for example:<br></p><p>var foo:A? = A()<br>foo.someMethod() // A is non-nil, no operators required!<br>foo = nil<br>foo!.someMethod() // Error: foo is always nil at this point<br>However, unwrapping of the value is only possible if the case contains either no value at all, or contains a single value able to satisfy the variable&#39;s original type requirements. In other words, the value stored in Optional&lt;A&gt;.some satisfies the type requirements of var foo:A?, thus it is implicitly unwrapped for use. For general enums this likely means no cases are implicitly unwrapped unless using a type of Any.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#type-widening&gt;Type Widening<br></p><p>In some cases a type may be narrowed, only to be used in a way that makes no sense for the narrowed type. In cases such as these the operation is tested against each type in the stack to determine whether the type must instead be widened. If a widened type is found it is selected (with re-narrowing where possible) otherwise an error is produced as normal.<br></p><p>For example:<br></p><p>let foo:A? = A()<br>if (foo != nil) { // Type of foo is Optional&lt;A&gt;.some<br>    foo.someMethod()<br>    foo = nil // Type of foo is widened to Optional&lt;A&gt;, then re-narrowed to Optional&lt;A&gt;.none<br>} // Type of foo is Optional&lt;A&gt;.none<br>foo.someMethod() // Error: foo is always nil at this point<br> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#multiple-conditions-and-branching&gt;Multiple Conditions and Branching<br></p><p>When dealing with complex conditionals or branches, all paths must agree on a common type for narrowing to occur. For example:<br></p><p>let foo:A? = B() // B extends A<br>let bar:C = C() // C extends B<br></p><p>if (foo != nil) || (foo == bar) { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>    if foo is B { // Optional&lt;B&gt;.some is added to foo&#39;s type stack<br>        foo.someMethodSpecificToB()<br>    } // Optional&lt;B&gt;.some is popped from foo&#39;s type stack<br>    foo = nil // Type of foo is re-narrowed as Optional&lt;A&gt;.none<br>} // Type of foo is Optional&lt;A&gt;.none in all branches<br>foo.someMethod() // Error: foo is always nil at this point<br>Here we can see that the extra condition (foo == bar) does not prevent type-narrowing, as the variable bar cannot be nil so both conditions require a type of Optional&lt;A&gt;.some as a minimum.<br></p><p>In this example foo is also nil at the end of both branches, thus its type can remain narrowed past this point.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#context-triggers&gt;Context Triggers<br></p><p>Trigger	Impact<br>as	Explicitly narrows a type with as! failing and as? narrowing to Type? instead when this is not possible.<br>is	Anywhere a type is tested will allow the type-checker to infer the new type if there was a match (and other conditions agree).<br>case	Any form of exhaustive test on an enum type allows it to be narrowed either to that case or the opposite, e.g- foo != nil eliminates .none, leaving only .some as the type, which can then be implicitly unwrapped (see Enum Types above).<br>=	Assigning a value to a type will either narrow it if the new value is a sub-type, or will trigger widening to find a new common type, before attempting to re-narrow from there.<br>There may be other triggers that should be considered.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#impact-on-existing-code&gt;Impact on existing code<br></p><p>Although this change is technically additive, it will impact any code in which there are currently errors that type-narrowing would have detected; for example, attempting to manipulate a predictably nil value.<br></p><p> &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#alternatives-considered&gt;Alternatives considered<br></p><p>One of the main advantages of type-narrowing is that it functions as an alternative to other features. This includes alternative syntax for shadowing/unwrapping of optionals, in which case type-narrowing allows an optional to be implicitly unwrapped simply by testing it, and without the need to introduce any new syntax.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/f913385e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>November  3, 2016 at 10:00:00am</p></header><div class="content"><p>Great. I&#39;d like to see something like this. Couple of comments:<br></p><p>You don&#39;t explicitly address overload selection. Do you intend it to<br>be affected?<br></p><p>Impact on existing code section could be more descriptive.<br></p><p>On Thursday, November 3, 2016, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try<br>&gt; to write up a proposal on type narrowing in Swift.<br>&gt; Please give your feedback on the functionality proposed, as well as the<br>&gt; clarity of the proposal/examples themselves; I&#39;ve tried to keep it<br>&gt; straightforward, but I do tend towards being overly verbose, I&#39;ve always<br>&gt; tried to have the examples build upon one another to show how it all stacks<br>&gt; up.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Type Narrowing<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;    - Author: Haravikk &lt;https://github.com/haravikk&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal is to introduce type-narrowing to Swift, enabling the<br>&gt; type-checker to automatically infer a narrower type from context such as<br>&gt; conditionals.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently in Swift there are various pieces of boilerplate required in<br>&gt; order to manually narrow types. The most obvious is in the case of<br>&gt; polymorphism:<br>&gt;<br>&gt; let foo:A = B() // B extends A<br>&gt; if foo is B {<br>&gt;     (foo as B).someMethodSpecificToB()<br>&gt; }<br>&gt;<br>&gt; But also in the case of unwrapping of optionals:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if var foo = foo { // foo is now unwrapped and shadowed<br>&gt;     foo.someMethod()<br>&gt;     foo!.someMutatingMethod() // Can&#39;t be done<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution to the boiler-plate is to introduce type-narrowing,<br>&gt; essentially a finer grained knowledge of type based upon context. Thus as<br>&gt; any contextual clue indicating a more or less specific type are<br>&gt; encountered, the type of the variable will reflect this from that point<br>&gt; onwards.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The concept of type-narrowing would essentially treat all variables as<br>&gt; having not just a single type, but instead as having a stack of<br>&gt; increasingly specific (narrow) types.<br>&gt;<br>&gt; Whenever a contextual clue such as a conditional is encountered, the type<br>&gt; checker will infer whether this narrows the type, and add the new narrow<br>&gt; type to the stack from that point onwards. Whenever the type widens again<br>&gt; narrower types are popped from the stack.<br>&gt;<br>&gt; Here are the above examples re-written to take advantage of type-narrowing:<br>&gt;<br>&gt; let foo:A = B() // B extends A<br>&gt; if foo is B { // B is added to foo&#39;s type stack<br>&gt;     foo.someMethodSpecificToB()<br>&gt; }<br>&gt; // B is popped from foo&#39;s type stack<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if foo != nil { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;    foo.someMethod()<br>&gt;    foo.someMutatingMethod() // Can modify mutable original<br>&gt; }<br>&gt; // Optional&lt;A&gt;.some is popped from foo&#39;s type stack<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#enum-types&gt;Enum<br>&gt; Types<br>&gt;<br>&gt; As seen in the simple optional example, to implement optional support each<br>&gt; case in an enum is considered be a unique sub-type of the enum itself,<br>&gt; thus allowing narrowing to nil (.none) and non-nil (.some) types.<br>&gt;<br>&gt; This behaviour actually enables some other useful behaviours,<br>&gt; specifically, if a value is known to be either nil or non-nil then the<br>&gt; need to unwrap or force unwrap the value can be eliminated entirely, with<br>&gt; the compiler able to produce errors if these are used incorrectly, for<br>&gt; example:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; foo.someMethod() // A is non-nil, no operators required!<br>&gt; foo = nil<br>&gt; foo!.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt; However, unwrapping of the value is only possible if the case contains<br>&gt; either no value at all, or contains a single value able to satisfy the<br>&gt; variable&#39;s original type requirements. In other words, the value stored in<br>&gt; Optional&lt;A&gt;.some satisfies the type requirements of var foo:A?, thus it<br>&gt; is implicitly unwrapped for use. For general enums this likely means no<br>&gt; cases are implicitly unwrapped unless using a type of Any.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#type-widening&gt;Type<br>&gt; Widening<br>&gt;<br>&gt; In some cases a type may be narrowed, only to be used in a way that makes<br>&gt; no sense for the narrowed type. In cases such as these the operation is<br>&gt; tested against each type in the stack to determine whether the type must<br>&gt; instead be widened. If a widened type is found it is selected (with<br>&gt; re-narrowing where possible) otherwise an error is produced as normal.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; let foo:A? = A()<br>&gt; if (foo != nil) { // Type of foo is Optional&lt;A&gt;.some<br>&gt;     foo.someMethod()<br>&gt;     foo = nil // Type of foo is widened to Optional&lt;A&gt;, then re-narrowed to Optional&lt;A&gt;.none<br>&gt; } // Type of foo is Optional&lt;A&gt;.none<br>&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#multiple-conditions-and-branching&gt;Multiple<br>&gt; Conditions and Branching<br>&gt;<br>&gt; When dealing with complex conditionals or branches, all paths must agree<br>&gt; on a common type for narrowing to occur. For example:<br>&gt;<br>&gt; let foo:A? = B() // B extends A<br>&gt; let bar:C = C() // C extends B<br>&gt;<br>&gt; if (foo != nil) || (foo == bar) { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;     if foo is B { // Optional&lt;B&gt;.some is added to foo&#39;s type stack<br>&gt;         foo.someMethodSpecificToB()<br>&gt;     } // Optional&lt;B&gt;.some is popped from foo&#39;s type stack<br>&gt;     foo = nil // Type of foo is re-narrowed as Optional&lt;A&gt;.none<br>&gt; } // Type of foo is Optional&lt;A&gt;.none in all branches<br>&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt; Here we can see that the extra condition (foo == bar) does not prevent<br>&gt; type-narrowing, as the variable bar cannot be nil so both conditions<br>&gt; require a type of Optional&lt;A&gt;.some as a minimum.<br>&gt;<br>&gt; In this example foo is also nil at the end of both branches, thus its<br>&gt; type can remain narrowed past this point.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#context-triggers&gt;Context<br>&gt; Triggers<br>&gt; TriggerImpact<br>&gt; as Explicitly narrows a type with as! failing and as? narrowing to Type? instead<br>&gt; when this is not possible.<br>&gt; is Anywhere a type is tested will allow the type-checker to infer the new<br>&gt; type if there was a match (and other conditions agree).<br>&gt; case Any form of exhaustive test on an enum type allows it to be narrowed<br>&gt; either to that case or the opposite, e.g- foo != nil eliminates .none,<br>&gt; leaving only .some as the type, which can then be implicitly unwrapped<br>&gt; (see Enum Types above).<br>&gt; = Assigning a value to a type will either narrow it if the new value is a<br>&gt; sub-type, or will trigger widening to find a new common type, before<br>&gt; attempting to re-narrow from there.<br>&gt;<br>&gt; There may be other triggers that should be considered.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Although this change is technically additive, it will impact any code in<br>&gt; which there are currently errors that type-narrowing would have detected;<br>&gt; for example, attempting to manipulate a predictably nil value.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; One of the main advantages of type-narrowing is that it functions as an<br>&gt; alternative to other features. This includes alternative syntax for<br>&gt; shadowing/unwrapping of optionals, in which case type-narrowing allows an<br>&gt; optional to be implicitly unwrapped simply by testing it, and without the<br>&gt; need to introduce any new syntax.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/56f575be/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November  3, 2016 at 03:00:00pm</p></header><div class="content"><p>This looks like a lot of complexity for very little gain.<br></p><p>Aside from any implementation concerns, this proposal substantially<br>increases the cognitive load on developers. To figure out what a piece of<br>code means, someone reading it will have to mentally keep track of a “type<br>stack” for every variable. That is the opposite of “clarity at the point of<br>use”.<br></p><p>For the motivating examples, there is already a much cleaner solution:<br></p><p>(foo as? B)?.someMethodSpecificToB()<br></p><p>Even in the case where foo gets passed as an argument to a function that<br>takes a B, so optional chaining is not available, we are still okay. If foo<br>is an instance of a struct, then passing it to a function won’t change its<br>value so we can write:<br></p><p>if let newFoo = foo as? B {<br>    funcThatTakesB(newFoo)<br>}<br></p><p>And if foo is an instance of a class, then the same thing *still* works,<br>because any changes the function makes to newFoo are also observed in foo<br>since they reference the same object.<br></p><p>• • •<br></p><p>The proposal’s other example is actually a great illustration of why<br>shadowing is undesirable. After all, simply binding to a different name<br>solves the so-called problem, *and* lets us bind to a constant:<br></p><p>var foo: A? = A()<br>if let newFoo = foo {<br>    newFoo.someMethod()<br>    foo!.someMutatingMethod()  // Works now!<br>}<br></p><p>Full disclosure: both this and the original example have a *deeper*<br>problem, which is that they are not thread-safe. If foo is modified between<br>the conditional binding and the force-unwrap, the force-unwrap could fail.<br>Sure, that can’t happen when foo is a local variable like this, but if it<br>were a property of a class then it could.<br></p><p>Moreover, the proposed “solution” has the same concurrency failure, but<br>hides it even worse because the force-unwrap operator doesn’t even appear<br>in the code:<br></p><p>var foo:A? = A()<br>if foo != nil {<br>   foo.someMethod()          // Bad news!<br>   foo.someMutatingMethod()  // Bad news!<br>}<br></p><p>In summary, I do not see sufficient motivation for this proposal. The<br>motivation which I do see appears superfluous. The problem being described<br>already has an elegant solution in Swift. And the proposed changes<br>introduce an exceptionally taxing cognitive burden on developers just to<br>figure out what the type of a variable is on any given line of code.<br></p><p>Plus, in the face of concurrency, such implicit type-narrowing has the<br>potential to hide serious issues.<br></p><p>Nevin<br></p><p><br>On Thu, Nov 3, 2016 at 1:04 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try<br>&gt; to write up a proposal on type narrowing in Swift.<br>&gt; Please give your feedback on the functionality proposed, as well as the<br>&gt; clarity of the proposal/examples themselves; I&#39;ve tried to keep it<br>&gt; straightforward, but I do tend towards being overly verbose, I&#39;ve always<br>&gt; tried to have the examples build upon one another to show how it all stacks<br>&gt; up.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Type Narrowing<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;    - Author: Haravikk &lt;https://github.com/haravikk&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal is to introduce type-narrowing to Swift, enabling the<br>&gt; type-checker to automatically infer a narrower type from context such as<br>&gt; conditionals.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently in Swift there are various pieces of boilerplate required in<br>&gt; order to manually narrow types. The most obvious is in the case of<br>&gt; polymorphism:<br>&gt;<br>&gt; let foo:A = B() // B extends A<br>&gt; if foo is B {<br>&gt;     (foo as B).someMethodSpecificToB()<br>&gt; }<br>&gt;<br>&gt; But also in the case of unwrapping of optionals:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if var foo = foo { // foo is now unwrapped and shadowed<br>&gt;     foo.someMethod()<br>&gt;     foo!.someMutatingMethod() // Can&#39;t be done<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution to the boiler-plate is to introduce type-narrowing,<br>&gt; essentially a finer grained knowledge of type based upon context. Thus as<br>&gt; any contextual clue indicating a more or less specific type are<br>&gt; encountered, the type of the variable will reflect this from that point<br>&gt; onwards.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The concept of type-narrowing would essentially treat all variables as<br>&gt; having not just a single type, but instead as having a stack of<br>&gt; increasingly specific (narrow) types.<br>&gt;<br>&gt; Whenever a contextual clue such as a conditional is encountered, the type<br>&gt; checker will infer whether this narrows the type, and add the new narrow<br>&gt; type to the stack from that point onwards. Whenever the type widens again<br>&gt; narrower types are popped from the stack.<br>&gt;<br>&gt; Here are the above examples re-written to take advantage of type-narrowing:<br>&gt;<br>&gt; let foo:A = B() // B extends A<br>&gt; if foo is B { // B is added to foo&#39;s type stack<br>&gt;     foo.someMethodSpecificToB()<br>&gt; }<br>&gt; // B is popped from foo&#39;s type stack<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if foo != nil { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;    foo.someMethod()<br>&gt;    foo.someMutatingMethod() // Can modify mutable original<br>&gt; }<br>&gt; // Optional&lt;A&gt;.some is popped from foo&#39;s type stack<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#enum-types&gt;Enum<br>&gt; Types<br>&gt;<br>&gt; As seen in the simple optional example, to implement optional support each<br>&gt; case in an enum is considered be a unique sub-type of the enum itself,<br>&gt; thus allowing narrowing to nil (.none) and non-nil (.some) types.<br>&gt;<br>&gt; This behaviour actually enables some other useful behaviours,<br>&gt; specifically, if a value is known to be either nil or non-nil then the<br>&gt; need to unwrap or force unwrap the value can be eliminated entirely, with<br>&gt; the compiler able to produce errors if these are used incorrectly, for<br>&gt; example:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; foo.someMethod() // A is non-nil, no operators required!<br>&gt; foo = nil<br>&gt; foo!.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt; However, unwrapping of the value is only possible if the case contains<br>&gt; either no value at all, or contains a single value able to satisfy the<br>&gt; variable&#39;s original type requirements. In other words, the value stored in<br>&gt; Optional&lt;A&gt;.some satisfies the type requirements of var foo:A?, thus it<br>&gt; is implicitly unwrapped for use. For general enums this likely means no<br>&gt; cases are implicitly unwrapped unless using a type of Any.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#type-widening&gt;Type<br>&gt; Widening<br>&gt;<br>&gt; In some cases a type may be narrowed, only to be used in a way that makes<br>&gt; no sense for the narrowed type. In cases such as these the operation is<br>&gt; tested against each type in the stack to determine whether the type must<br>&gt; instead be widened. If a widened type is found it is selected (with<br>&gt; re-narrowing where possible) otherwise an error is produced as normal.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; let foo:A? = A()<br>&gt; if (foo != nil) { // Type of foo is Optional&lt;A&gt;.some<br>&gt;     foo.someMethod()<br>&gt;     foo = nil // Type of foo is widened to Optional&lt;A&gt;, then re-narrowed to Optional&lt;A&gt;.none<br>&gt; } // Type of foo is Optional&lt;A&gt;.none<br>&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#multiple-conditions-and-branching&gt;Multiple<br>&gt; Conditions and Branching<br>&gt;<br>&gt; When dealing with complex conditionals or branches, all paths must agree<br>&gt; on a common type for narrowing to occur. For example:<br>&gt;<br>&gt; let foo:A? = B() // B extends A<br>&gt; let bar:C = C() // C extends B<br>&gt;<br>&gt; if (foo != nil) || (foo == bar) { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;     if foo is B { // Optional&lt;B&gt;.some is added to foo&#39;s type stack<br>&gt;         foo.someMethodSpecificToB()<br>&gt;     } // Optional&lt;B&gt;.some is popped from foo&#39;s type stack<br>&gt;     foo = nil // Type of foo is re-narrowed as Optional&lt;A&gt;.none<br>&gt; } // Type of foo is Optional&lt;A&gt;.none in all branches<br>&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt; Here we can see that the extra condition (foo == bar) does not prevent<br>&gt; type-narrowing, as the variable bar cannot be nil so both conditions<br>&gt; require a type of Optional&lt;A&gt;.some as a minimum.<br>&gt;<br>&gt; In this example foo is also nil at the end of both branches, thus its<br>&gt; type can remain narrowed past this point.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#context-triggers&gt;Context<br>&gt; Triggers<br>&gt; TriggerImpact<br>&gt; as Explicitly narrows a type with as! failing and as? narrowing to Type? instead<br>&gt; when this is not possible.<br>&gt; is Anywhere a type is tested will allow the type-checker to infer the new<br>&gt; type if there was a match (and other conditions agree).<br>&gt; case Any form of exhaustive test on an enum type allows it to be narrowed<br>&gt; either to that case or the opposite, e.g- foo != nil eliminates .none,<br>&gt; leaving only .some as the type, which can then be implicitly unwrapped<br>&gt; (see Enum Types above).<br>&gt; = Assigning a value to a type will either narrow it if the new value is a<br>&gt; sub-type, or will trigger widening to find a new common type, before<br>&gt; attempting to re-narrow from there.<br>&gt;<br>&gt; There may be other triggers that should be considered.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Although this change is technically additive, it will impact any code in<br>&gt; which there are currently errors that type-narrowing would have detected;<br>&gt; for example, attempting to manipulate a predictably nil value.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; One of the main advantages of type-narrowing is that it functions as an<br>&gt; alternative to other features. This includes alternative syntax for<br>&gt; shadowing/unwrapping of optionals, in which case type-narrowing allows an<br>&gt; optional to be implicitly unwrapped simply by testing it, and without the<br>&gt; need to introduce any new syntax.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/4801ebd7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>November  3, 2016 at 07:00:00pm</p></header><div class="content"><p>This proposal seems well-reasoned, but like Nevin I worry about the<br>interactions between type narrowing, reference types or capture of mutable<br>values, and concurrency or async. How will these things play together?<br></p><p>On Thu, Nov 3, 2016 at 14:23 Nevin Brackett-Rozinsky via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; This looks like a lot of complexity for very little gain.<br>&gt;<br>&gt; Aside from any implementation concerns, this proposal substantially<br>&gt; increases the cognitive load on developers. To figure out what a piece of<br>&gt; code means, someone reading it will have to mentally keep track of a “type<br>&gt; stack” for every variable. That is the opposite of “clarity at the point of<br>&gt; use”.<br>&gt;<br>&gt; For the motivating examples, there is already a much cleaner solution:<br>&gt;<br>&gt; (foo as? B)?.someMethodSpecificToB()<br>&gt;<br>&gt; Even in the case where foo gets passed as an argument to a function that<br>&gt; takes a B, so optional chaining is not available, we are still okay. If foo<br>&gt; is an instance of a struct, then passing it to a function won’t change its<br>&gt; value so we can write:<br>&gt;<br>&gt; if let newFoo = foo as? B {<br>&gt;     funcThatTakesB(newFoo)<br>&gt; }<br>&gt;<br>&gt; And if foo is an instance of a class, then the same thing *still* works,<br>&gt; because any changes the function makes to newFoo are also observed in foo<br>&gt; since they reference the same object.<br>&gt;<br>&gt; • • •<br>&gt;<br>&gt; The proposal’s other example is actually a great illustration of why<br>&gt; shadowing is undesirable. After all, simply binding to a different name<br>&gt; solves the so-called problem, *and* lets us bind to a constant:<br>&gt;<br>&gt; var foo: A? = A()<br>&gt; if let newFoo = foo {<br>&gt;     newFoo.someMethod()<br>&gt;     foo!.someMutatingMethod()  // Works now!<br>&gt; }<br>&gt;<br>&gt; Full disclosure: both this and the original example have a *deeper*<br>&gt; problem, which is that they are not thread-safe. If foo is modified between<br>&gt; the conditional binding and the force-unwrap, the force-unwrap could fail.<br>&gt; Sure, that can’t happen when foo is a local variable like this, but if it<br>&gt; were a property of a class then it could.<br>&gt;<br>&gt; Moreover, the proposed “solution” has the same concurrency failure, but<br>&gt; hides it even worse because the force-unwrap operator doesn’t even appear<br>&gt; in the code:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if foo != nil {<br>&gt;    foo.someMethod()          // Bad news!<br>&gt;    foo.someMutatingMethod()  // Bad news!<br>&gt; }<br>&gt;<br>&gt; In summary, I do not see sufficient motivation for this proposal. The<br>&gt; motivation which I do see appears superfluous. The problem being described<br>&gt; already has an elegant solution in Swift. And the proposed changes<br>&gt; introduce an exceptionally taxing cognitive burden on developers just to<br>&gt; figure out what the type of a variable is on any given line of code.<br>&gt;<br>&gt; Plus, in the face of concurrency, such implicit type-narrowing has the<br>&gt; potential to hide serious issues.<br>&gt;<br>&gt; Nevin<br>&gt;<br>&gt;<br>&gt; On Thu, Nov 3, 2016 at 1:04 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try<br>&gt; to write up a proposal on type narrowing in Swift.<br>&gt; Please give your feedback on the functionality proposed, as well as the<br>&gt; clarity of the proposal/examples themselves; I&#39;ve tried to keep it<br>&gt; straightforward, but I do tend towards being overly verbose, I&#39;ve always<br>&gt; tried to have the examples build upon one another to show how it all stacks<br>&gt; up.<br>&gt;<br>&gt;<br>&gt;<br>&gt; Type Narrowing<br>&gt;<br>&gt;    - Proposal: SE-NNNN<br>&gt;    &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;    - Author: Haravikk &lt;https://github.com/haravikk&gt;<br>&gt;    - Status: Awaiting review<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal is to introduce type-narrowing to Swift, enabling the<br>&gt; type-checker to automatically infer a narrower type from context such as<br>&gt; conditionals.<br>&gt;<br>&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently in Swift there are various pieces of boilerplate required in<br>&gt; order to manually narrow types. The most obvious is in the case of<br>&gt; polymorphism:<br>&gt;<br>&gt; let foo:A = B() // B extends A<br>&gt; if foo is B {<br>&gt;     (foo as B).someMethodSpecificToB()<br>&gt; }<br>&gt;<br>&gt; But also in the case of unwrapping of optionals:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if var foo = foo { // foo is now unwrapped and shadowed<br>&gt;     foo.someMethod()<br>&gt;     foo!.someMutatingMethod() // Can&#39;t be done<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#proposed-solution&gt;Proposed<br>&gt; solution<br>&gt;<br>&gt; The proposed solution to the boiler-plate is to introduce type-narrowing,<br>&gt; essentially a finer grained knowledge of type based upon context. Thus as<br>&gt; any contextual clue indicating a more or less specific type are<br>&gt; encountered, the type of the variable will reflect this from that point<br>&gt; onwards.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#detailed-design&gt;Detailed<br>&gt; design<br>&gt;<br>&gt; The concept of type-narrowing would essentially treat all variables as<br>&gt; having not just a single type, but instead as having a stack of<br>&gt; increasingly specific (narrow) types.<br>&gt;<br>&gt; Whenever a contextual clue such as a conditional is encountered, the type<br>&gt; checker will infer whether this narrows the type, and add the new narrow<br>&gt; type to the stack from that point onwards. Whenever the type widens again<br>&gt; narrower types are popped from the stack.<br>&gt;<br>&gt; Here are the above examples re-written to take advantage of type-narrowing:<br>&gt;<br>&gt; let foo:A = B() // B extends A<br>&gt; if foo is B { // B is added to foo&#39;s type stack<br>&gt;     foo.someMethodSpecificToB()<br>&gt; }<br>&gt; // B is popped from foo&#39;s type stack<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if foo != nil { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;    foo.someMethod()<br>&gt;    foo.someMutatingMethod() // Can modify mutable original<br>&gt; }<br>&gt; // Optional&lt;A&gt;.some is popped from foo&#39;s type stack<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#enum-types&gt;Enum<br>&gt; Types<br>&gt;<br>&gt; As seen in the simple optional example, to implement optional support each<br>&gt; case in an enum is considered be a unique sub-type of the enum itself,<br>&gt; thus allowing narrowing to nil (.none) and non-nil (.some) types.<br>&gt;<br>&gt; This behaviour actually enables some other useful behaviours,<br>&gt; specifically, if a value is known to be either nil or non-nil then the<br>&gt; need to unwrap or force unwrap the value can be eliminated entirely, with<br>&gt; the compiler able to produce errors if these are used incorrectly, for<br>&gt; example:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; foo.someMethod() // A is non-nil, no operators required!<br>&gt; foo = nil<br>&gt; foo!.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt; However, unwrapping of the value is only possible if the case contains<br>&gt; either no value at all, or contains a single value able to satisfy the<br>&gt; variable&#39;s original type requirements. In other words, the value stored in<br>&gt; Optional&lt;A&gt;.some satisfies the type requirements of var foo:A?, thus it<br>&gt; is implicitly unwrapped for use. For general enums this likely means no<br>&gt; cases are implicitly unwrapped unless using a type of Any.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#type-widening&gt;Type<br>&gt; Widening<br>&gt;<br>&gt; In some cases a type may be narrowed, only to be used in a way that makes<br>&gt; no sense for the narrowed type. In cases such as these the operation is<br>&gt; tested against each type in the stack to determine whether the type must<br>&gt; instead be widened. If a widened type is found it is selected (with<br>&gt; re-narrowing where possible) otherwise an error is produced as normal.<br>&gt;<br>&gt; For example:<br>&gt;<br>&gt; let foo:A? = A()<br>&gt; if (foo != nil) { // Type of foo is Optional&lt;A&gt;.some<br>&gt;     foo.someMethod()<br>&gt;     foo = nil // Type of foo is widened to Optional&lt;A&gt;, then re-narrowed to Optional&lt;A&gt;.none<br>&gt; } // Type of foo is Optional&lt;A&gt;.none<br>&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#multiple-conditions-and-branching&gt;Multiple<br>&gt; Conditions and Branching<br>&gt;<br>&gt; When dealing with complex conditionals or branches, all paths must agree<br>&gt; on a common type for narrowing to occur. For example:<br>&gt;<br>&gt; let foo:A? = B() // B extends A<br>&gt; let bar:C = C() // C extends B<br>&gt;<br>&gt; if (foo != nil) || (foo == bar) { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;     if foo is B { // Optional&lt;B&gt;.some is added to foo&#39;s type stack<br>&gt;         foo.someMethodSpecificToB()<br>&gt;     } // Optional&lt;B&gt;.some is popped from foo&#39;s type stack<br>&gt;     foo = nil // Type of foo is re-narrowed as Optional&lt;A&gt;.none<br>&gt; } // Type of foo is Optional&lt;A&gt;.none in all branches<br>&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;<br>&gt; Here we can see that the extra condition (foo == bar) does not prevent<br>&gt; type-narrowing, as the variable bar cannot be nil so both conditions<br>&gt; require a type of Optional&lt;A&gt;.some as a minimum.<br>&gt;<br>&gt; In this example foo is also nil at the end of both branches, thus its<br>&gt; type can remain narrowed past this point.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#context-triggers&gt;Context<br>&gt; Triggers<br>&gt; TriggerImpact<br>&gt; as Explicitly narrows a type with as! failing and as? narrowing to Type? instead<br>&gt; when this is not possible.<br>&gt; is Anywhere a type is tested will allow the type-checker to infer the new<br>&gt; type if there was a match (and other conditions agree).<br>&gt; case Any form of exhaustive test on an enum type allows it to be narrowed<br>&gt; either to that case or the opposite, e.g- foo != nil eliminates .none,<br>&gt; leaving only .some as the type, which can then be implicitly unwrapped<br>&gt; (see Enum Types above).<br>&gt; = Assigning a value to a type will either narrow it if the new value is a<br>&gt; sub-type, or will trigger widening to find a new common type, before<br>&gt; attempting to re-narrow from there.<br>&gt;<br>&gt; There may be other triggers that should be considered.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#impact-on-existing-code&gt;Impact<br>&gt; on existing code<br>&gt;<br>&gt; Although this change is technically additive, it will impact any code in<br>&gt; which there are currently errors that type-narrowing would have detected;<br>&gt; for example, attempting to manipulate a predictably nil value.<br>&gt;<br>&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#alternatives-considered&gt;Alternatives<br>&gt; considered<br>&gt; One of the main advantages of type-narrowing is that it functions as an<br>&gt; alternative to other features. This includes alternative syntax for<br>&gt; shadowing/unwrapping of optionals, in which case type-narrowing allows an<br>&gt; optional to be implicitly unwrapped simply by testing it, and without the<br>&gt; need to introduce any new syntax.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/9cbc6a62/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  3, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 3 Nov 2016, at 19:23, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; For the motivating examples, there is already a much cleaner solution:<br>&gt; (foo as? B)?.someMethodSpecificToB()<br></p><p>Eh, kinda; you&#39;ve taken an example showing branching and boiled it down into a single line; what if my intention was to call multiple B specific methods on foo? I think you&#39;ve seen a simple example and tried to simplify it further, but I suppose I could put another method call in it to clarify.<br></p><p>&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers.<br></p><p>I&#39;m not so sure of this; the type is never going to be wider than what you originally set, so at the very least you can do whatever its original explicit type or inferred type would let you do, the main difference is that if you do something that makes no sense anymore then the type-checker can inform you of this. Otherwise if you know you&#39;ve narrowed the type, then you can do things with that narrowed type and either the type-checker will allow it, or inform you that it&#39;s not possible, thus warning you that your conditional(s) etc. don&#39;t work as intended.<br></p><p>Really the burden is no different to the techniques that already exist; if you&#39;ve tested a value with `is` then you know what the type is within that block of code, this is just ensuring that the type checker also knows it. Likewise with an optional, if you test that it&#39;s not nil then you know it&#39;s not, and so should the type-checker.<br></p><p>I should probably put more under motivation about why this feature works for the example cases given, and what the impact is on a larger scale; as the narrowing has the potential to pick up a bunch of little errors that standard type-checking alone may not, the trick is coming up with the example code to show it that isn&#39;t enormous, as I&#39;m trying to avoid too much complexity in the Motivation section so I can build up the examples; maybe I&#39;ll add an &quot;Advantages&quot; section further down to detail more of what can be done *after* demonstrating the feature in stages, rather than trying to do it at the start.<br></p><p>&gt; the proposed “solution” has the same concurrency failure, but hides it even worse because the force-unwrap operator doesn’t even appear in the code:<br>&gt; <br>&gt; var foo:A? = A()<br>&gt; if foo != nil {<br>&gt;    foo.someMethod()          // Bad news!<br>&gt;    foo.someMutatingMethod()  // Bad news!<br>&gt; }<br></p><p>Actually the issue is visible in the code; it&#39;s the conditional. If you can&#39;t trust `foo` not to change then testing its value and then acting upon the result without some form of local copy or locking is the part that explicitly isn&#39;t thread safe.<br></p><p>I&#39;m not really sure of the need to focus on thread safety issues here as I&#39;m not sure they&#39;re unique to this feature, or even to optionals; anything that is part of a shared class and thus potentially shared with other threads is unsafe, whether it&#39;s optional or not. While optionals might produce errors if force unwrapped and nil, they just as easily might not but end up with inconsistent values instead, so I&#39;m not sure having the force unwrap operators actually makes you any safer; put another way, if you&#39;re relying on force unwrapping to catch thread safety issues then I&#39;m not sure that&#39;s a good strategy, as it can only detect the issues at runtime, and only if the exact conditions necessary actually occur to trigger the failure.<br></p><p>I don&#39;t know what&#39;s planned for Swift&#39;s native concurrency support, but personally I&#39;m hoping we might get a feature of classes that requires them (and/or their methods) to be marked as explicitly safe (except where it can be inferred), producing warnings otherwise, forcing developers to consider if their type/method has been properly reviewed for thread safety. Thread safety after all really is specific to classes, which are mostly discouraged in Swift anyway, so it makes sense to focus efforts towards making classes safer, and that you&#39;re handling your struct copies efficiently.<br></p><p>&gt;&gt; On Thu, Nov 3, 2016 at 1:04 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try to write up a proposal on type narrowing in Swift.<br>&gt;&gt; Please give your feedback on the functionality proposed, as well as the clarity of the proposal/examples themselves; I&#39;ve tried to keep it straightforward, but I do tend towards being overly verbose, I&#39;ve always tried to have the examples build upon one another to show how it all stacks up.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Type Narrowing<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;&gt; Author: Haravikk &lt;https://github.com/haravikk&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal is to introduce type-narrowing to Swift, enabling the type-checker to automatically infer a narrower type from context such as conditionals.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Currently in Swift there are various pieces of boilerplate required in order to manually narrow types. The most obvious is in the case of polymorphism:<br>&gt;&gt; <br>&gt;&gt; let foo:A = B() // B extends A<br>&gt;&gt; if foo is B {<br>&gt;&gt;     (foo as B).someMethodSpecificToB()<br>&gt;&gt; }<br>&gt;&gt; But also in the case of unwrapping of optionals:<br>&gt;&gt; <br>&gt;&gt; var foo:A? = A()<br>&gt;&gt; if var foo = foo { // foo is now unwrapped and shadowed<br>&gt;&gt;     foo.someMethod()<br>&gt;&gt;     foo!.someMutatingMethod() // Can&#39;t be done<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#proposed-solution&gt;Proposed solution<br>&gt;&gt; <br>&gt;&gt; The proposed solution to the boiler-plate is to introduce type-narrowing, essentially a finer grained knowledge of type based upon context. Thus as any contextual clue indicating a more or less specific type are encountered, the type of the variable will reflect this from that point onwards.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#detailed-design&gt;Detailed design<br>&gt;&gt; <br>&gt;&gt; The concept of type-narrowing would essentially treat all variables as having not just a single type, but instead as having a stack of increasingly specific (narrow) types.<br>&gt;&gt; <br>&gt;&gt; Whenever a contextual clue such as a conditional is encountered, the type checker will infer whether this narrows the type, and add the new narrow type to the stack from that point onwards. Whenever the type widens again narrower types are popped from the stack.<br>&gt;&gt; <br>&gt;&gt; Here are the above examples re-written to take advantage of type-narrowing:<br>&gt;&gt; <br>&gt;&gt; let foo:A = B() // B extends A<br>&gt;&gt; if foo is B { // B is added to foo&#39;s type stack<br>&gt;&gt;     foo.someMethodSpecificToB()<br>&gt;&gt; }<br>&gt;&gt; // B is popped from foo&#39;s type stack<br>&gt;&gt; var foo:A? = A()<br>&gt;&gt; if foo != nil { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;&gt;    foo.someMethod()<br>&gt;&gt;    foo.someMutatingMethod() // Can modify mutable original<br>&gt;&gt; }<br>&gt;&gt; // Optional&lt;A&gt;.some is popped from foo&#39;s type stack<br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#enum-types&gt;Enum Types<br>&gt;&gt; <br>&gt;&gt; As seen in the simple optional example, to implement optional support each case in an enum is considered be a unique sub-type of the enum itself, thus allowing narrowing to nil (.none) and non-nil (.some) types.<br>&gt;&gt; <br>&gt;&gt; This behaviour actually enables some other useful behaviours, specifically, if a value is known to be either nil or non-nil then the need to unwrap or force unwrap the value can be eliminated entirely, with the compiler able to produce errors if these are used incorrectly, for example:<br>&gt;&gt; <br>&gt;&gt; var foo:A? = A()<br>&gt;&gt; foo.someMethod() // A is non-nil, no operators required!<br>&gt;&gt; foo = nil<br>&gt;&gt; foo!.someMethod() // Error: foo is always nil at this point<br>&gt;&gt; However, unwrapping of the value is only possible if the case contains either no value at all, or contains a single value able to satisfy the variable&#39;s original type requirements. In other words, the value stored in Optional&lt;A&gt;.some satisfies the type requirements of var foo:A?, thus it is implicitly unwrapped for use. For general enums this likely means no cases are implicitly unwrapped unless using a type of Any.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#type-widening&gt;Type Widening<br>&gt;&gt; <br>&gt;&gt; In some cases a type may be narrowed, only to be used in a way that makes no sense for the narrowed type. In cases such as these the operation is tested against each type in the stack to determine whether the type must instead be widened. If a widened type is found it is selected (with re-narrowing where possible) otherwise an error is produced as normal.<br>&gt;&gt; <br>&gt;&gt; For example:<br>&gt;&gt; <br>&gt;&gt; let foo:A? = A()<br>&gt;&gt; if (foo != nil) { // Type of foo is Optional&lt;A&gt;.some<br>&gt;&gt;     foo.someMethod()<br>&gt;&gt;     foo = nil // Type of foo is widened to Optional&lt;A&gt;, then re-narrowed to Optional&lt;A&gt;.none<br>&gt;&gt; } // Type of foo is Optional&lt;A&gt;.none<br>&gt;&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#multiple-conditions-and-branching&gt;Multiple Conditions and Branching<br>&gt;&gt; <br>&gt;&gt; When dealing with complex conditionals or branches, all paths must agree on a common type for narrowing to occur. For example:<br>&gt;&gt; <br>&gt;&gt; let foo:A? = B() // B extends A<br>&gt;&gt; let bar:C = C() // C extends B<br>&gt;&gt; <br>&gt;&gt; if (foo != nil) || (foo == bar) { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;&gt;     if foo is B { // Optional&lt;B&gt;.some is added to foo&#39;s type stack<br>&gt;&gt;         foo.someMethodSpecificToB()<br>&gt;&gt;     } // Optional&lt;B&gt;.some is popped from foo&#39;s type stack<br>&gt;&gt;     foo = nil // Type of foo is re-narrowed as Optional&lt;A&gt;.none<br>&gt;&gt; } // Type of foo is Optional&lt;A&gt;.none in all branches<br>&gt;&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;&gt; Here we can see that the extra condition (foo == bar) does not prevent type-narrowing, as the variable bar cannot be nil so both conditions require a type of Optional&lt;A&gt;.some as a minimum.<br>&gt;&gt; <br>&gt;&gt; In this example foo is also nil at the end of both branches, thus its type can remain narrowed past this point.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#context-triggers&gt;Context Triggers<br>&gt;&gt; <br>&gt;&gt; Trigger	Impact<br>&gt;&gt; as	Explicitly narrows a type with as! failing and as? narrowing to Type? instead when this is not possible.<br>&gt;&gt; is	Anywhere a type is tested will allow the type-checker to infer the new type if there was a match (and other conditions agree).<br>&gt;&gt; case	Any form of exhaustive test on an enum type allows it to be narrowed either to that case or the opposite, e.g- foo != nil eliminates .none, leaving only .some as the type, which can then be implicitly unwrapped (see Enum Types above).<br>&gt;&gt; =	Assigning a value to a type will either narrow it if the new value is a sub-type, or will trigger widening to find a new common type, before attempting to re-narrow from there.<br>&gt;&gt; There may be other triggers that should be considered.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#impact-on-existing-code&gt;Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Although this change is technically additive, it will impact any code in which there are currently errors that type-narrowing would have detected; for example, attempting to manipulate a predictably nil value.<br>&gt;&gt; <br>&gt;&gt;  &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#alternatives-considered&gt;Alternatives considered<br>&gt;&gt; <br>&gt;&gt; One of the main advantages of type-narrowing is that it functions as an alternative to other features. This includes alternative syntax for shadowing/unwrapping of optionals, in which case type-narrowing allows an optional to be implicitly unwrapped simply by testing it, and without the need to introduce any new syntax.<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/85c3cc78/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November  3, 2016 at 06:00:00pm</p></header><div class="content"><p>Okay, I think I found an actual shortcoming that type narrowing might<br>address, namely mutating a property in place if it is a subtype. Here is a<br>small example setup:<br></p><p>protocol A { var x: Int {get} }<br>struct B: A { var x: Int }<br>struct C { var a: A }<br>var c = C(a: B(x: 4))<br></p><p>Note that “A” does not promise the “x” property will be mutable, while B<br>does. I use “x: Int” as a minimal example, but any solution should also<br>work for more complex scenarios.<br></p><p>Now suppose we wish to test whether “c.a” is of type B, and if so change<br>its “x” value. We could, of course, make a local copy, mutate it, and<br>reassign to “c.a”. But if those operations are expensive we would rather<br>avoid doing so. And if B uses copy-on-write, we would want to remove the<br>value from “c” entirely so that we hopefully have a unique reference. This<br>is hard to get right.<br></p><p>We would prefer to write something like the following:<br></p><p>(c.a as? B)?.x = 12<br></p><p>But that does not currently work, resulting in the error “Cannot assign to<br>immutable expression of type &#39;Int&#39;”.<br></p><p>Will the proposed type-narrowing feature provide a simple way to mutate<br>“c.a” in place, contingent upon its being of type B?<br></p><p>How does it compare to an alternative such as inout return values, which<br>could preserve mutability in the above?<br></p><p>• • •<br></p><p>If we are going to have any sort of type narrowing, I would strongly prefer<br>that it be explicit. For example we could use a keyword such as “rebind” to<br>narrow the type of an existing symbol in a scope:<br></p><p>if rebind c.a as B {<br>    c.a.x = 12<br>}<br></p><p>Furthermore, I think the proposal to treat enum cases as types is a major<br>change to Swift’s type system, and probably introduces many unforeseen<br>headaches. It also smells somewhat of a backdoor way for union types to<br>sneak into the language.<br></p><p>Also, irrespective of everything else, you really need to make the<br>“Motivation” section of your proposal a lot stronger. That section should<br>stand on its own and make people understand exactly what problem you are<br>trying to solve and why it is important.<br></p><p>Nevin<br></p><p><br>On Thu, Nov 3, 2016 at 5:43 PM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt;<br>&gt; On 3 Nov 2016, at 19:23, Nevin Brackett-Rozinsky &lt;<br>&gt; nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; For the motivating examples, there is already a much cleaner solution:<br>&gt; (foo as? B)?.someMethodSpecificToB()<br>&gt;<br>&gt;<br>&gt; Eh, kinda; you&#39;ve taken an example showing branching and boiled it down<br>&gt; into a single line; what if my intention was to call multiple B specific<br>&gt; methods on foo? I think you&#39;ve seen a simple example and tried to simplify<br>&gt; it further, but I suppose I could put another method call in it to clarify.<br>&gt;<br>&gt; Aside from any implementation concerns, this proposal substantially<br>&gt; increases the cognitive load on developers.<br>&gt;<br>&gt;<br>&gt; I&#39;m not so sure of this; the type is never going to be wider than what you<br>&gt; originally set, so at the very least you can do whatever its original<br>&gt; explicit type or inferred type would let you do, the main difference is<br>&gt; that if you do something that makes no sense anymore then the type-checker<br>&gt; can inform you of this. Otherwise if you know you&#39;ve narrowed the type,<br>&gt; then you can do things with that narrowed type and either the type-checker<br>&gt; will allow it, or inform you that it&#39;s not possible, thus warning you that<br>&gt; your conditional(s) etc. don&#39;t work as intended.<br>&gt;<br>&gt; Really the burden is no different to the techniques that already exist; if<br>&gt; you&#39;ve tested a value with `is` then *you* know what the type is within<br>&gt; that block of code, this is just ensuring that the type checker also knows<br>&gt; it. Likewise with an optional, if you test that it&#39;s not nil then you know<br>&gt; it&#39;s not, and so should the type-checker.<br>&gt;<br>&gt; I should probably put more under motivation about why this feature works<br>&gt; for the example cases given, and what the impact is on a larger scale; as<br>&gt; the narrowing has the potential to pick up a bunch of little errors that<br>&gt; standard type-checking alone may not, the trick is coming up with the<br>&gt; example code to show it that isn&#39;t enormous, as I&#39;m trying to avoid too<br>&gt; much complexity in the Motivation section so I can build up the examples;<br>&gt; maybe I&#39;ll add an &quot;Advantages&quot; section further down to detail more of what<br>&gt; can be done *after* demonstrating the feature in stages, rather than trying<br>&gt; to do it at the start.<br>&gt;<br>&gt; the proposed “solution” has the same concurrency failure, but hides it<br>&gt; even worse because the force-unwrap operator doesn’t even appear in the<br>&gt; code:<br>&gt;<br>&gt; var foo:A? = A()<br>&gt; if foo != nil {<br>&gt;    foo.someMethod()          // Bad news!<br>&gt;    foo.someMutatingMethod()  // Bad news!<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Actually the issue *is* visible in the code; it&#39;s the conditional. If you<br>&gt; can&#39;t trust `foo` not to change then testing its value and then acting upon<br>&gt; the result without some form of local copy or locking is the part that<br>&gt; explicitly isn&#39;t thread safe.<br>&gt;<br>&gt; I&#39;m not really sure of the need to focus on thread safety issues here as<br>&gt; I&#39;m not sure they&#39;re unique to this feature, or even to optionals; anything<br>&gt; that is part of a shared class and thus potentially shared with other<br>&gt; threads is unsafe, whether it&#39;s optional or not. While optionals might<br>&gt; produce errors if force unwrapped and nil, they just as easily might not<br>&gt; but end up with inconsistent values instead, so I&#39;m not sure having the<br>&gt; force unwrap operators actually makes you any safer; put another way, if<br>&gt; you&#39;re relying on force unwrapping to catch thread safety issues then I&#39;m<br>&gt; not sure that&#39;s a good strategy, as it can only detect the issues at<br>&gt; runtime, and only if the exact conditions necessary actually occur to<br>&gt; trigger the failure.<br>&gt;<br>&gt; I don&#39;t know what&#39;s planned for Swift&#39;s native concurrency support, but<br>&gt; personally I&#39;m hoping we might get a feature of classes that requires them<br>&gt; (and/or their methods) to be marked as explicitly safe (except where it can<br>&gt; be inferred), producing warnings otherwise, forcing developers to consider<br>&gt; if their type/method has been properly reviewed for thread safety. Thread<br>&gt; safety after all really is specific to classes, which are mostly<br>&gt; discouraged in Swift anyway, so it makes sense to focus efforts towards<br>&gt; making classes safer, and that you&#39;re handling your struct copies<br>&gt; efficiently.<br>&gt;<br>&gt; On Thu, Nov 3, 2016 at 1:04 PM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try<br>&gt;&gt; to write up a proposal on type narrowing in Swift.<br>&gt;&gt; Please give your feedback on the functionality proposed, as well as the<br>&gt;&gt; clarity of the proposal/examples themselves; I&#39;ve tried to keep it<br>&gt;&gt; straightforward, but I do tend towards being overly verbose, I&#39;ve always<br>&gt;&gt; tried to have the examples build upon one another to show how it all stacks<br>&gt;&gt; up.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Type Narrowing<br>&gt;&gt;<br>&gt;&gt;    - Proposal: SE-NNNN<br>&gt;&gt;    &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;&gt;    - Author: Haravikk &lt;https://github.com/haravikk&gt;<br>&gt;&gt;    - Status: Awaiting review<br>&gt;&gt;    - Review manager: TBD<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#introduction&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; This proposal is to introduce type-narrowing to Swift, enabling the<br>&gt;&gt; type-checker to automatically infer a narrower type from context such as<br>&gt;&gt; conditionals.<br>&gt;&gt;<br>&gt;&gt; Swift-evolution thread: Discussion thread topic for that proposal<br>&gt;&gt; &lt;http://news.gmane.org/gmane.comp.lang.swift.evolution&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#motivation&gt;<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Currently in Swift there are various pieces of boilerplate required in<br>&gt;&gt; order to manually narrow types. The most obvious is in the case of<br>&gt;&gt; polymorphism:<br>&gt;&gt;<br>&gt;&gt; let foo:A = B() // B extends A<br>&gt;&gt; if foo is B {<br>&gt;&gt;     (foo as B).someMethodSpecificToB()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But also in the case of unwrapping of optionals:<br>&gt;&gt;<br>&gt;&gt; var foo:A? = A()<br>&gt;&gt; if var foo = foo { // foo is now unwrapped and shadowed<br>&gt;&gt;     foo.someMethod()<br>&gt;&gt;     foo!.someMutatingMethod() // Can&#39;t be done<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#proposed-solution&gt;Proposed<br>&gt;&gt; solution<br>&gt;&gt;<br>&gt;&gt; The proposed solution to the boiler-plate is to introduce type-narrowing,<br>&gt;&gt; essentially a finer grained knowledge of type based upon context. Thus as<br>&gt;&gt; any contextual clue indicating a more or less specific type are<br>&gt;&gt; encountered, the type of the variable will reflect this from that point<br>&gt;&gt; onwards.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#detailed-design&gt;Detailed<br>&gt;&gt; design<br>&gt;&gt;<br>&gt;&gt; The concept of type-narrowing would essentially treat all variables as<br>&gt;&gt; having not just a single type, but instead as having a stack of<br>&gt;&gt; increasingly specific (narrow) types.<br>&gt;&gt;<br>&gt;&gt; Whenever a contextual clue such as a conditional is encountered, the type<br>&gt;&gt; checker will infer whether this narrows the type, and add the new narrow<br>&gt;&gt; type to the stack from that point onwards. Whenever the type widens again<br>&gt;&gt; narrower types are popped from the stack.<br>&gt;&gt;<br>&gt;&gt; Here are the above examples re-written to take advantage of<br>&gt;&gt; type-narrowing:<br>&gt;&gt;<br>&gt;&gt; let foo:A = B() // B extends A<br>&gt;&gt; if foo is B { // B is added to foo&#39;s type stack<br>&gt;&gt;     foo.someMethodSpecificToB()<br>&gt;&gt; }<br>&gt;&gt; // B is popped from foo&#39;s type stack<br>&gt;&gt;<br>&gt;&gt; var foo:A? = A()<br>&gt;&gt; if foo != nil { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;&gt;    foo.someMethod()<br>&gt;&gt;    foo.someMutatingMethod() // Can modify mutable original<br>&gt;&gt; }<br>&gt;&gt; // Optional&lt;A&gt;.some is popped from foo&#39;s type stack<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#enum-types&gt;Enum<br>&gt;&gt; Types<br>&gt;&gt;<br>&gt;&gt; As seen in the simple optional example, to implement optional support<br>&gt;&gt; each case in an enum is considered be a unique sub-type of the enum<br>&gt;&gt; itself, thus allowing narrowing to nil (.none) and non-nil (.some) types.<br>&gt;&gt;<br>&gt;&gt; This behaviour actually enables some other useful behaviours,<br>&gt;&gt; specifically, if a value is known to be either nil or non-nil then the<br>&gt;&gt; need to unwrap or force unwrap the value can be eliminated entirely, with<br>&gt;&gt; the compiler able to produce errors if these are used incorrectly, for<br>&gt;&gt; example:<br>&gt;&gt;<br>&gt;&gt; var foo:A? = A()<br>&gt;&gt; foo.someMethod() // A is non-nil, no operators required!<br>&gt;&gt; foo = nil<br>&gt;&gt; foo!.someMethod() // Error: foo is always nil at this point<br>&gt;&gt;<br>&gt;&gt; However, unwrapping of the value is only possible if the case contains<br>&gt;&gt; either no value at all, or contains a single value able to satisfy the<br>&gt;&gt; variable&#39;s original type requirements. In other words, the value stored in<br>&gt;&gt; Optional&lt;A&gt;.some satisfies the type requirements of var foo:A?, thus it<br>&gt;&gt; is implicitly unwrapped for use. For general enums this likely means no<br>&gt;&gt; cases are implicitly unwrapped unless using a type of Any.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#type-widening&gt;Type<br>&gt;&gt; Widening<br>&gt;&gt;<br>&gt;&gt; In some cases a type may be narrowed, only to be used in a way that makes<br>&gt;&gt; no sense for the narrowed type. In cases such as these the operation is<br>&gt;&gt; tested against each type in the stack to determine whether the type must<br>&gt;&gt; instead be widened. If a widened type is found it is selected (with<br>&gt;&gt; re-narrowing where possible) otherwise an error is produced as normal.<br>&gt;&gt;<br>&gt;&gt; For example:<br>&gt;&gt;<br>&gt;&gt; let foo:A? = A()<br>&gt;&gt; if (foo != nil) { // Type of foo is Optional&lt;A&gt;.some<br>&gt;&gt;     foo.someMethod()<br>&gt;&gt;     foo = nil // Type of foo is widened to Optional&lt;A&gt;, then re-narrowed to Optional&lt;A&gt;.none<br>&gt;&gt; } // Type of foo is Optional&lt;A&gt;.none<br>&gt;&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#multiple-conditions-and-branching&gt;Multiple<br>&gt;&gt; Conditions and Branching<br>&gt;&gt;<br>&gt;&gt; When dealing with complex conditionals or branches, all paths must agree<br>&gt;&gt; on a common type for narrowing to occur. For example:<br>&gt;&gt;<br>&gt;&gt; let foo:A? = B() // B extends A<br>&gt;&gt; let bar:C = C() // C extends B<br>&gt;&gt;<br>&gt;&gt; if (foo != nil) || (foo == bar) { // Optional&lt;A&gt;.some is added to foo&#39;s type stack<br>&gt;&gt;     if foo is B { // Optional&lt;B&gt;.some is added to foo&#39;s type stack<br>&gt;&gt;         foo.someMethodSpecificToB()<br>&gt;&gt;     } // Optional&lt;B&gt;.some is popped from foo&#39;s type stack<br>&gt;&gt;     foo = nil // Type of foo is re-narrowed as Optional&lt;A&gt;.none<br>&gt;&gt; } // Type of foo is Optional&lt;A&gt;.none in all branches<br>&gt;&gt; foo.someMethod() // Error: foo is always nil at this point<br>&gt;&gt;<br>&gt;&gt; Here we can see that the extra condition (foo == bar) does not prevent<br>&gt;&gt; type-narrowing, as the variable bar cannot be nil so both conditions<br>&gt;&gt; require a type of Optional&lt;A&gt;.some as a minimum.<br>&gt;&gt;<br>&gt;&gt; In this example foo is also nil at the end of both branches, thus its<br>&gt;&gt; type can remain narrowed past this point.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#context-triggers&gt;Context<br>&gt;&gt; Triggers<br>&gt;&gt; TriggerImpact<br>&gt;&gt; as Explicitly narrows a type with as! failing and as? narrowing to Type? instead<br>&gt;&gt; when this is not possible.<br>&gt;&gt; is Anywhere a type is tested will allow the type-checker to infer the<br>&gt;&gt; new type if there was a match (and other conditions agree).<br>&gt;&gt; case Any form of exhaustive test on an enum type allows it to be<br>&gt;&gt; narrowed either to that case or the opposite, e.g- foo != nil eliminates<br>&gt;&gt; .none, leaving only .some as the type, which can then be implicitly<br>&gt;&gt; unwrapped (see Enum Types above).<br>&gt;&gt; = Assigning a value to a type will either narrow it if the new value is<br>&gt;&gt; a sub-type, or will trigger widening to find a new common type, before<br>&gt;&gt; attempting to re-narrow from there.<br>&gt;&gt;<br>&gt;&gt; There may be other triggers that should be considered.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#impact-on-existing-code&gt;Impact<br>&gt;&gt; on existing code<br>&gt;&gt;<br>&gt;&gt; Although this change is technically additive, it will impact any code in<br>&gt;&gt; which there are currently errors that type-narrowing would have detected;<br>&gt;&gt; for example, attempting to manipulate a predictably nil value.<br>&gt;&gt;<br>&gt;&gt; &lt;https://github.com/Haravikk/swift-evolution/tree/master/proposals#alternatives-considered&gt;Alternatives<br>&gt;&gt; considered<br>&gt;&gt; One of the main advantages of type-narrowing is that it functions as an<br>&gt;&gt; alternative to other features. This includes alternative syntax for<br>&gt;&gt; shadowing/unwrapping of optionals, in which case type-narrowing allows an<br>&gt;&gt; optional to be implicitly unwrapped simply by testing it, and without the<br>&gt;&gt; need to introduce any new syntax.<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161103/ab8ca4eb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  6, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 3 Nov 2016, at 22:56, Nevin Brackett-Rozinsky &lt;nevin.brackettrozinsky at gmail.com&gt; wrote:<br>&gt; <br>&gt; Okay, I think I found an actual shortcoming that type narrowing might address, namely mutating a property in place if it is a subtype. Here is a small example setup:<br>&gt; <br>&gt; protocol A { var x: Int {get} }<br>&gt; struct B: A { var x: Int }<br>&gt; struct C { var a: A }<br>&gt; var c = C(a: B(x: 4))<br>&gt; <br>&gt; Note that “A” does not promise the “x” property will be mutable, while B does. I use “x: Int” as a minimal example, but any solution should also work for more complex scenarios.<br>&gt; <br>&gt; Now suppose we wish to test whether “c.a” is of type B, and if so change its “x” value. We could, of course, make a local copy, mutate it, and reassign to “c.a”. But if those operations are expensive we would rather avoid doing so. And if B uses copy-on-write, we would want to remove the value from “c” entirely so that we hopefully have a unique reference. This is hard to get right.<br>&gt; <br>&gt; We would prefer to write something like the following:<br>&gt; <br>&gt; (c.a as? B)?.x = 12<br>&gt; <br>&gt; But that does not currently work, resulting in the error “Cannot assign to immutable expression of type &#39;Int&#39;”.<br>&gt; <br>&gt; Will the proposed type-narrowing feature provide a simple way to mutate “c.a” in place, contingent upon its being of type B?<br>&gt; How does it compare to an alternative such as inout return values, which could preserve mutability in the above?<br></p><p>That&#39;s a good example, and yes it should be possible for type-narrowing to simplify stuff like this, I&#39;ll add a section on that I should probably go into more detail on how I intend working with narrowed mutable values to work, as for the advantage vs inout it&#39;s really just a matter of simplicity I think; using type narrowing should allow it to just work without having to pass to methods or design the API specifically for that kind of thing.<br></p><p><br></p><p>&gt; If we are going to have any sort of type narrowing, I would strongly prefer that it be explicit. For example we could use a keyword such as “rebind” to narrow the type of an existing symbol in a scope:<br>&gt; <br>&gt; if rebind c.a as B {<br>&gt;     c.a.x = 12<br>&gt; }<br></p><p>I don&#39;t see what&#39;s really gained by making it explicit vs implicit; if the condition was c.a is B then I&#39;m not sure how that&#39;s any less clear?<br></p><p>&gt; Furthermore, I think the proposal to treat enum cases as types is a major change to Swift’s type system, and probably introduces many unforeseen headaches. It also smells somewhat of a backdoor way for union types to sneak into the language.<br></p><p>I&#39;d say that in a sense enums are types, after all they can have unique associated value types of their own. Really though my intent is primarily to support optionals, but I figure it makes sense to try and do it from the perspective of general purpose enums since that&#39;s all optionals really are anyway.<br></p><p><br>Also, I&#39;ve been thinking about thread safety and it occurs to me that type narrowing could actually be of significant benefit to it, rather than a detriment.<br></p><p>Consider:<br></p><p>	struct Foo { var value:Int }<br>	struct Bar { var foo?:Foo }<br></p><p>	var a = Foo(value: 5)<br>	var b = Bar(foo: a)<br></p><p>	b.foo.value = 10<br></p><p>Now, in this case we&#39;re only dealing with structs, and we know that b.foo has a value, thus b.foo.value is nice and safe; in fact no force unwrapping needs to occur behind the scenes, it can optimise away completely.<br></p><p>Instead, let&#39;s assume Bar is a class we&#39;re handling in a potentially shared way:<br></p><p>	class Bar { var foo?:Foo }<br></p><p>	func myMethod(bar:Bar) {<br>		b.foo = new Foo(5) // We now know that b.foo shouldn&#39;t be nil<br>		b.foo!.value = 10<br>	}<br></p><p>In this case, since Bar is a class we don&#39;t have total control over, we can&#39;t be certain that b.foo is non-nil when we try to modify it a second time; as a result, type-narrowing won&#39;t occur (because it&#39;s a class from another scope), however, because the type-checker knows that bar.foo should have a value, we can actually issue a more informative error message if force unwrapping fails, e.g- concurrent modification error.<br></p><p>In other words, we can potentially use it to help detect concurrency issues. It&#39;s another thing that&#39;s going to require a section on the proposal though, I have a feeling it&#39;s going to get pretty big!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161106/142f6771/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>November  9, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; This looks like a lot of complexity for very little gain.<br>&gt; <br>&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers. To figure out what a piece of code means, someone reading it will have to mentally keep track of a “type stack” for every variable. That is the opposite of “clarity at the point of use”.<br></p><p>Very well said. I think this is perhaps the number one complaint I have about the proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/b57ab847/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 09 Nov 2016, at 07:51, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This looks like a lot of complexity for very little gain.<br>&gt;&gt; <br>&gt;&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers. To figure out what a piece of code means, someone reading it will have to mentally keep track of a “type stack” for every variable. That is the opposite of “clarity at the point of use”.<br>&gt; <br>&gt; Very well said. I think this is perhaps the number one complaint I have about the proposal.<br></p><p>Exactly.<br>-1.<br></p><p><br>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>November  6, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Nov 3, 2016, at 10:04 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try to write up a proposal on type narrowing in Swift.<br>&gt; Please give your feedback on the functionality proposed, as well as the clarity of the proposal/examples themselves; I&#39;ve tried to keep it straightforward, but I do tend towards being overly verbose, I&#39;ve always tried to have the examples build upon one another to show how it all stacks up.<br></p><p>FWIW, we have specifically considered something like this proposal in the past.  You didn’t mention it, but the ?: operator is a specific example that frequently comes up.  People often expect to be able to do something like:<br></p><p>	… = foo is B ? foo.bMethod() : …<br></p><p>which is the same sort of flow sensitive type refinement as you’re proposing here.  This topic also came up in the design discussion around #available (which shipped in Swift 2, but was discussed much earlier), because unavailable decls could be available as optionals when not specifically checked for.<br></p><p>This is just MHO, but while I have been in favor of this in the (distant) past, I became convinced that this would be a bad idea when it comes to code maintenance over the long term.  With our current (intentional shadowing based) design, you can always jump to the definition of a value to see where it was defined, and definitions always specify a type.  Introducing flow senstitive type refinement breaks this model because the type of a decl depends not just on its declaration, but on a potentially arbitrary number of imperative checks that occur between the declaration and the use.  This can make it much more difficult to understand code.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>November  7, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 7 nov. 2016 à 04:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On Nov 3, 2016, at 10:04 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to try to write up a proposal on type narrowing in Swift.<br>&gt;&gt; Please give your feedback on the functionality proposed, as well as the clarity of the proposal/examples themselves; I&#39;ve tried to keep it straightforward, but I do tend towards being overly verbose, I&#39;ve always tried to have the examples build upon one another to show how it all stacks up.<br>&gt; <br>&gt; FWIW, we have specifically considered something like this proposal in the past.  You didn’t mention it, but the ?: operator is a specific example that frequently comes up.  People often expect to be able to do something like:<br>&gt; <br>&gt; 	… = foo is B ? foo.bMethod() : …<br>&gt; <br></p><p>For the case of the ?: operator, I think it can be replaced by a ?? operator for most cases:<br></p><p>… = (foo as B)?.bMethod() ?? …<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  7, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 7 Nov 2016, at 03:52, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; Introducing flow senstitive type refinement breaks this model because the type of a decl depends not just on its declaration, but on a potentially arbitrary number of imperative checks that occur between the declaration and the use.  This can make it much more difficult to understand code.<br></p><p>This seems like more of a challenge for the IDE; if it can tap into the type-checker then it can determine what the narrowed type is at any given point in your code, indeed I would expect it to for the purposes of auto-completion anyway. I know you don&#39;t necessarily want a language that&#39;s reliant on good IDE support, but if you&#39;re doing something complex enough where this would become a problem and NOT using a good IDE then it seems kind of like a self-inflicted problem to me.<br></p><p>Even so there&#39;s nothing in this feature that would prevent you from using shadowing if you want to, for example if a block is especially large and you feel it adds clarity.<br></p><p>Actually though I&#39;d say that for maintenance narrowing may be better, as it can clarify what a type is supposed to be at a given point, and if you break the narrowing then you&#39;ll create errors and warning that show you how you&#39;ve changed the meaning of the code. Consider for example:<br></p><p>	func doSomething(value:Int?) {<br>		if (value == nil) { value = 5 } // value is narrow to Optional&lt;Int&gt;.some<br></p><p>		// Lots of really important code that never causes value to become nil<br></p><p>		print(value!.description)<br>	}<br></p><p>Say you come back later and decide to remove the conditional at the top, now that value!, though a fair assumption at the time, can cause a runtime failure. With narrowing however you wouldn&#39;t have had to force unwrap because of the known non-nil value, but your change will break that, resulting in an error that forces you to fix it.<br></p><p><br>I&#39;m still struggling how best to phrase my motivation section; so far I seem to have an increasingly large grab-bag of individual problems that type-narrowing can solve, with no way to put it more succinctly.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/cc5fc5ba/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November  7, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;d personally not make this automatic, but require explicit action from the developer.<br></p><p>In case of nullability, I have previously suggested &quot;nonnil&quot; keyword:<br></p><p>let foo: String? = &quot;Hello World&quot;<br>guard nonnil foo else {<br>    return<br>}<br></p><p>In which way you explicitly request the type narrowing. Or:<br></p><p>let foo: Any<br>guard foo as String else {<br>    return<br>}<br></p><p>I.e. not using &quot;is&quot; which returns a boolean, but using the cast operator, which IMHO makes more sense and prevents from unintentional type narrowing...<br></p><p><br>&gt; On Nov 7, 2016, at 12:34 PM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Nov 2016, at 03:52, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; Introducing flow senstitive type refinement breaks this model because the type of a decl depends not just on its declaration, but on a potentially arbitrary number of imperative checks that occur between the declaration and the use.  This can make it much more difficult to understand code.<br>&gt; <br>&gt; This seems like more of a challenge for the IDE; if it can tap into the type-checker then it can determine what the narrowed type is at any given point in your code, indeed I would expect it to for the purposes of auto-completion anyway. I know you don&#39;t necessarily want a language that&#39;s reliant on good IDE support, but if you&#39;re doing something complex enough where this would become a problem and NOT using a good IDE then it seems kind of like a self-inflicted problem to me.<br>&gt; <br>&gt; Even so there&#39;s nothing in this feature that would prevent you from using shadowing if you want to, for example if a block is especially large and you feel it adds clarity.<br>&gt; <br>&gt; Actually though I&#39;d say that for maintenance narrowing may be better, as it can clarify what a type is supposed to be at a given point, and if you break the narrowing then you&#39;ll create errors and warning that show you how you&#39;ve changed the meaning of the code. Consider for example:<br>&gt; <br>&gt; 	func doSomething(value:Int?) {<br>&gt; 		if (value == nil) { value = 5 } // value is narrow to Optional&lt;Int&gt;.some<br>&gt; <br>&gt; 		// Lots of really important code that never causes value to become nil<br>&gt; <br>&gt; 		print(value!.description)<br>&gt; 	}<br>&gt; <br>&gt; Say you come back later and decide to remove the conditional at the top, now that value!, though a fair assumption at the time, can cause a runtime failure. With narrowing however you wouldn&#39;t have had to force unwrap because of the known non-nil value, but your change will break that, resulting in an error that forces you to fix it.<br>&gt; <br>&gt; <br>&gt; I&#39;m still struggling how best to phrase my motivation section; so far I seem to have an increasingly large grab-bag of individual problems that type-narrowing can solve, with no way to put it more succinctly.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/2b3a305f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  7, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 7 Nov 2016, at 11:58, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; I&#39;d personally not make this automatic, but require explicit action from the developer.<br>&gt; <br>&gt; In case of nullability, I have previously suggested &quot;nonnil&quot; keyword:<br>&gt; <br>&gt; let foo: String? = &quot;Hello World&quot;<br>&gt; guard nonnil foo else {<br>&gt;     return<br>&gt; }<br>&gt; <br>&gt; In which way you explicitly request the type narrowing. Or:<br>&gt; <br>&gt; let foo: Any<br>&gt; guard foo as String else {<br>&gt;     return<br>&gt; }<br>&gt; <br>&gt; I.e. not using &quot;is&quot; which returns a boolean, but using the cast operator, which IMHO makes more sense and prevents from unintentional type narrowing…<br></p><p>Normally I&#39;m a proponent of being more rather than less explicit, but the biggest draw of type-narrowing to me is that you&#39;re *already* telling the type-checker, it&#39;s really just confirming what you know automatically.<br></p><p>So if I do:<br></p><p>	if foo is String {<br>		// Do lots of non-string stuff<br>		(foo as String).somethingStringSpecific<br>	}<br></p><p>On the last line of the block the type-checker is able to remind me that I already know that foo is a String, so I don&#39;t need to cast it.<br></p><p>Really when it comes down to it the type-narrowing never takes anything away from you; you can always handle the value as a less specific (wider) type if you want to, but if you want to treat it like a String because you know it&#39;s one, then you can do that too.<br></p><p>I&#39;m concerned that if the feature had to be explicit, it would lack discoverability, and really the point is almost to get rid of the need to do things explicitly when you don&#39;t need to. It&#39;s like type inference on overdrive in a way.<br></p><p><br>I guess I just don&#39;t see why you&#39;d think that &quot;guard nonnil foo&quot; is really more explicit than &quot;guard foo != nil&quot;, in both cases you know that foo can&#39;t be nil past that point, so is a new keyword really justified?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/494ade16/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November  7, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 2:08 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Nov 2016, at 11:58, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I&#39;d personally not make this automatic, but require explicit action from the developer.<br>&gt;&gt; <br>&gt;&gt; In case of nullability, I have previously suggested &quot;nonnil&quot; keyword:<br>&gt;&gt; <br>&gt;&gt; let foo: String? = &quot;Hello World&quot;<br>&gt;&gt; guard nonnil foo else {<br>&gt;&gt;     return<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; In which way you explicitly request the type narrowing. Or:<br>&gt;&gt; <br>&gt;&gt; let foo: Any<br>&gt;&gt; guard foo as String else {<br>&gt;&gt;     return<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I.e. not using &quot;is&quot; which returns a boolean, but using the cast operator, which IMHO makes more sense and prevents from unintentional type narrowing…<br>&gt; <br>&gt; Normally I&#39;m a proponent of being more rather than less explicit, but the biggest draw of type-narrowing to me is that you&#39;re *already* telling the type-checker, it&#39;s really just confirming what you know automatically.<br>&gt; <br>&gt; So if I do:<br>&gt; <br>&gt; 	if foo is String {<br>&gt; 		// Do lots of non-string stuff<br>&gt; 		(foo as String).somethingStringSpecific<br>&gt; 	}<br>&gt; <br>&gt; On the last line of the block the type-checker is able to remind me that I already know that foo is a String, so I don&#39;t need to cast it.<br>&gt; <br>&gt; Really when it comes down to it the type-narrowing never takes anything away from you; you can always handle the value as a less specific (wider) type if you want to, but if you want to treat it like a String because you know it&#39;s one, then you can do that too.<br>&gt; <br>&gt; I&#39;m concerned that if the feature had to be explicit, it would lack discoverability, and really the point is almost to get rid of the need to do things explicitly when you don&#39;t need to. It&#39;s like type inference on overdrive in a way.<br>&gt; <br>&gt; <br>&gt; I guess I just don&#39;t see why you&#39;d think that &quot;guard nonnil foo&quot; is really more explicit than &quot;guard foo != nil&quot;, in both cases you know that foo can&#39;t be nil past that point, so is a new keyword really justified?<br></p><p>I&#39;m simply worried a little about unwanted effects and additional compiler &quot;cleverness&quot;. I&#39;d simply much rather opt-in to it using a keyword or a slightly different syntax. And instead of<br></p><p>	if foo is String { ... }<br></p><p>I&#39;d prefer<br></p><p>	if foo as? String { ... }<br></p><p>which is syntactically closer to<br></p><p>	if let foo = foo as? String { ... }<br></p><p>which is generally what we&#39;re after.<br></p><p>Also, it would maintain code compatibility. The current proposal would change semantics of the code - mostly when comparing to nil.<br></p><p>Xcode&#39;s migration is &quot;nice&quot;, but I&#39;d like to point out that migration to Swift 3 of my project took 6 hours (!) and I spent almost 2 more days manually changing what the migrator didn&#39;t manage to do on its own. And that was one of my projects. I really don&#39;t want to go through this once more.<br></p><p>Not to mention the already growing non-macOS base of Swift users.<br></p><p>I know now is the time for the last incompatible changes, but are the benefits of implicit type narrowing so great to warrant this?<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/db7313c8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 7 Nov 2016, at 16:29, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; I&#39;m simply worried a little about unwanted effects and additional compiler &quot;cleverness&quot;.<br></p><p>I don&#39;t believe there should be any; either the type is narrowed or it isn&#39;t, if you rely on it being a type the type-checker can&#39;t verify, you&#39;ll get an error, otherwise you won&#39;t. There shouldn&#39;t be scope for anything unexpected.<br></p><p>&gt; Xcode&#39;s migration is &quot;nice&quot;, but I&#39;d like to point out that migration to Swift 3 of my project took 6 hours (!) and I spent almost 2 more days manually changing what the migrator didn&#39;t manage to do on its own. And that was one of my projects. I really don&#39;t want to go through this once more.<br></p><p>I agree, but the only code that should be affected by this is code where there is unwrapping that can be determined to either be redundant, or is definitely incorrect; in the former case it will only be a warning (so you can remove force unwrapping that is no longer needed) and in the latter it will be an error because the type-checker has actually identified something that will definitely cause a run-time error.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>November  7, 2016 at 02:00:00pm</p></header><div class="content"><p>I am mostly opposed because I don&#39;t see how this could avoid being<br>complicated to explain compiler magic. Making this accessible as a feature<br>for our types and operations would be a challenge and doesn&#39;t look to have<br>a worthwhile yield for the effort. We can accomplish most, if not all, of<br>this with shadowing.<br></p><p>TJ<br></p><p>On Mon, Nov 7, 2016 at 2:03 PM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On 7 Nov 2016, at 16:29, Charlie Monroe &lt;charlie at charliemonroe.net&gt;<br>&gt; wrote:<br>&gt; &gt; I&#39;m simply worried a little about unwanted effects and additional<br>&gt; compiler &quot;cleverness&quot;.<br>&gt;<br>&gt; I don&#39;t believe there should be any; either the type is narrowed or it<br>&gt; isn&#39;t, if you rely on it being a type the type-checker can&#39;t verify, you&#39;ll<br>&gt; get an error, otherwise you won&#39;t. There shouldn&#39;t be scope for anything<br>&gt; unexpected.<br>&gt;<br>&gt; &gt; Xcode&#39;s migration is &quot;nice&quot;, but I&#39;d like to point out that migration to<br>&gt; Swift 3 of my project took 6 hours (!) and I spent almost 2 more days<br>&gt; manually changing what the migrator didn&#39;t manage to do on its own. And<br>&gt; that was one of my projects. I really don&#39;t want to go through this once<br>&gt; more.<br>&gt;<br>&gt; I agree, but the only code that should be affected by this is code where<br>&gt; there is unwrapping that can be determined to either be redundant, or is<br>&gt; definitely incorrect; in the former case it will only be a warning (so you<br>&gt; can remove force unwrapping that is no longer needed) and in the latter it<br>&gt; will be an error because the type-checker has actually identified something<br>&gt; that will definitely cause a run-time error.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/e0a66643/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>November  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Nov 7, 2016, at 8:03 PM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 7 Nov 2016, at 16:29, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt;&gt; I&#39;m simply worried a little about unwanted effects and additional compiler &quot;cleverness&quot;.<br>&gt; <br>&gt; I don&#39;t believe there should be any; either the type is narrowed or it isn&#39;t, if you rely on it being a type the type-checker can&#39;t verify, you&#39;ll get an error, otherwise you won&#39;t. There shouldn&#39;t be scope for anything unexpected.<br></p><p>True. <br></p><p>I&#39;m simply worried about the compiler speed in general, that&#39;s what I meant by &quot;cleverness&quot;. The implicit variable typing and other features of Swift already IMHO make it incredibly slow and various features analyzing the code in order to determine the correct type can slow it even further. For comparison, a 100KLOC project of mine in pure Swift takes about 8 minutes to compile, vs. 3 minutes when it was in ObjC. With no optimizations turned on.<br></p><p>But I agree that designing a language around the compiler speed is wrong, but I believe designing the language without taking it into account is just as wrong. It&#39;s not worth designing features that would make the compilation so slow it would render the language unusable.<br></p><p>Note that I have only very limited experience with compiler implementation, I&#39;ve only made a few minor things with Clang a few years back, so please feel free to correct me.<br></p><p>&gt;&gt; Xcode&#39;s migration is &quot;nice&quot;, but I&#39;d like to point out that migration to Swift 3 of my project took 6 hours (!) and I spent almost 2 more days manually changing what the migrator didn&#39;t manage to do on its own. And that was one of my projects. I really don&#39;t want to go through this once more.<br>&gt; <br>&gt; I agree, but the only code that should be affected by this is code where there is unwrapping that can be determined to either be redundant, or is definitely incorrect; in the former case it will only be a warning (so you can remove force unwrapping that is no longer needed) and in the latter it will be an error because the type-checker has actually identified something that will definitely cause a run-time error.<br></p><p><br>There are two cases:<br></p><p>if foo != nil { <br>    foo!.doSomething() <br>}<br></p><p>Currently, accessing a non-optional value with ! produces an error:<br></p><p>let foo = Bar()<br>foo!.doSomething() // ERROR<br></p><p>Second:<br></p><p>if foo != nil { <br>    // Using ? to be extra cautious, if foo is var<br>    foo?.doSomething() <br>}<br></p><p>This again currently produces an error:<br></p><p>let foo = Bar()<br>foo?.doSomething() // ERROR<br></p><p>Which is generally, what would semantically happen - the variable would loose it optionality. Or am I wrong?<br></p><p>Which would require migration, where within all scopes, where you check if a a variable is not nil, it removes all ? and !...<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/2510523c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  8, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 7 Nov 2016, at 19:31, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; There are two cases:<br>&gt; <br>&gt; if foo != nil { <br>&gt;     foo!.doSomething() <br>&gt; }<br>&gt; <br>&gt; Currently, accessing a non-optional value with ! produces an error:<br>&gt; <br>&gt; let foo = Bar()<br>&gt; foo!.doSomething() // ERROR<br>&gt; <br>&gt; Second:<br>&gt; <br>&gt; if foo != nil { <br>&gt;     // Using ? to be extra cautious, if foo is var<br>&gt;     foo?.doSomething() <br>&gt; }<br>&gt; <br>&gt; This again currently produces an error:<br>&gt; <br>&gt; let foo = Bar()<br>&gt; foo?.doSomething() // ERROR<br>&gt; <br>&gt; Which is generally, what would semantically happen - the variable would loose it optionality. Or am I wrong?<br></p><p>I probably haven&#39;t clarified well enough but under type-narrowing these would be warnings rather than errors; i.e- the general type of foo is still Optional, the type-checker merely knows that it can&#39;t be nil at that point, so would inform you that the ? or ! are unnecessary.<br></p><p>This is what I was trying to get at in the type-widening section; basically, if you have a variable whose type is narrowed, but do something that makes no sense for the narrowed type, then the type is widened until either a match is found or it can&#39;t go any wider (producing an error as normal).<br></p><p>So in your examples foo is Optional&lt;Bar&gt;.some, as a result the ? and ! operators make no sense, so the type is widened back to Optional&lt;Bar&gt; where it does make sense and the code compiles, but a warning is produced to inform you that you don&#39;t need to use those operators.<br></p><p>&gt; On 7 Nov 2016, at 19:31, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; I agree that designing a language around the compiler speed is wrong, but I believe designing the language without taking it into account is just as wrong. It&#39;s not worth designing features that would make the compilation so slow it would render the language unusable.<br>&gt; <br>&gt; Note that I have only very limited experience with compiler implementation, I&#39;ve only made a few minor things with Clang a few years back, so please feel free to correct me.<br></p><p>I&#39;m not that familiar with the actual architecture either, but narrowing *should* be fairly simple; basically any time the compiler hits a condition or statement defined as a narrowing trigger, it pops the new narrower type onto a stack of types for that variable (in that branch). Now whenever the compiler reaches another statement for that variable (method call etc.) it resolves it first against the narrowest type, otherwise it goes up the stack (widening) till it finds a match or fails.<br></p><p>When a branch closes with a stack of types, the compiler will compare to other branches to see which type is the narrowest that they have in common; this is actually fairly simple (shorten the stack for each branch to the length of the shortest stack, then discard elements until the current one is a match for all branches, thus you now know what the narrowest type is past that point).<br></p><p>So, for types that never narrow there should be no speed difference, while for narrowed types there shouldn&#39;t be much of a difference, as these stacks of types shouldn&#39;t get very large in most cases (I&#39;d expect anything more than three to be pretty rare).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/56e8677d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>November  8, 2016 at 12:00:00pm</p></header><div class="content"><p>If I correctly understand the proposal, I&#39;m -1 on this.<br></p><p>(1) You can define different methods with the same name on T and<br>Optional&lt;T&gt; (description is such an example). Then what does this do?<br></p><p>// someMethod is defined both for T and T?<br>// var foo: T?<br>if foo != nil {<br>    foo.someMethod()<br>}<br></p><p>I say there is a clear expectation that foo.someMethod() should call the<br>method of T?, even inside the if block, since this is how the dot works.<br>However, according to the proposal it will call another method (or become<br>an error?).<br></p><p>I think the languages that use optional narrowing are the ones where T? is<br>not a separate type, so that it cannot have its own methods.<br></p><p>(2) Should this work?<br></p><p>// compilcatedStuff is a method of T<br>// class A { var foo: T? }<br></p><p>if foo != nil {<br>    foo.compilcatedStuff()<br>    foo.compilcatedStuff()<br>    foo.compilcatedStuff()<br>}<br></p><p>Suppose the compiler doesn&#39;t have enough information about compilcatedStuff<br>to know what happens inside. Then it&#39;s possible that foo.compilcatedStuff<br>will actually change foo (for example, foo could be a relationship and<br>compilcatedStuff may be deleting the relationship). So, what is the<br>suggestion for this example? Perhaps<br></p><p>if foo != nil {<br>    foo.compilcatedStuff()<br>    foo?.compilcatedStuff()<br>    foo?.compilcatedStuff()<br>}<br></p><p>or some other choice?<br></p><p><br>On Tue, Nov 8, 2016 at 9:44 AM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 7 Nov 2016, at 19:31, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; There are two cases:<br>&gt;<br>&gt; if foo != nil {<br>&gt;     foo!.doSomething()<br>&gt; }<br>&gt;<br>&gt;<br>&gt; Currently, accessing a non-optional value with ! produces an error:<br>&gt;<br>&gt; let foo = Bar()<br>&gt; foo!.doSomething() // ERROR<br>&gt;<br>&gt;<br>&gt; Second:<br>&gt;<br>&gt; if foo != nil {<br>&gt;     // Using ? to be extra cautious, if foo is var<br>&gt;     foo?.doSomething()<br>&gt; }<br>&gt;<br>&gt;<br>&gt; This again currently produces an error:<br>&gt;<br>&gt; let foo = Bar()<br>&gt; foo?.doSomething() // ERROR<br>&gt;<br>&gt;<br>&gt; Which is generally, what would semantically happen - the variable would<br>&gt; loose it optionality. Or am I wrong?<br>&gt;<br>&gt;<br>&gt; I probably haven&#39;t clarified well enough but under type-narrowing these<br>&gt; would be warnings rather than errors; i.e- the general type of foo is still<br>&gt; Optional, the type-checker merely knows that it can&#39;t be nil at that point,<br>&gt; so would inform you that the ? or ! are unnecessary.<br>&gt;<br>&gt; This is what I was trying to get at in the type-widening section;<br>&gt; basically, if you have a variable whose type is narrowed, but do something<br>&gt; that makes no sense for the narrowed type, then the type is widened until<br>&gt; either a match is found or it can&#39;t go any wider (producing an error as<br>&gt; normal).<br>&gt;<br>&gt; So in your examples foo is Optional&lt;Bar&gt;.some, as a result the ? and !<br>&gt; operators make no sense, so the type is widened back to Optional&lt;Bar&gt; where<br>&gt; it does make sense and the code compiles, but a warning is produced to<br>&gt; inform you that you don&#39;t need to use those operators.<br>&gt;<br>&gt; On 7 Nov 2016, at 19:31, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; I agree that designing a language around the compiler speed is wrong, but<br>&gt; I believe designing the language without taking it into account is just as<br>&gt; wrong. It&#39;s not worth designing features that would make the compilation so<br>&gt; slow it would render the language unusable.<br>&gt;<br>&gt; Note that I have only very limited experience with compiler<br>&gt; implementation, I&#39;ve only made a few minor things with Clang a few years<br>&gt; back, so please feel free to correct me.<br>&gt;<br>&gt;<br>&gt; I&#39;m not that familiar with the actual architecture either, but narrowing<br>&gt; *should* be fairly simple; basically any time the compiler hits a condition<br>&gt; or statement defined as a narrowing trigger, it pops the new narrower type<br>&gt; onto a stack of types for that variable (in that branch). Now whenever the<br>&gt; compiler reaches another statement for that variable (method call etc.) it<br>&gt; resolves it first against the narrowest type, otherwise it goes up the<br>&gt; stack (widening) till it finds a match or fails.<br>&gt;<br>&gt; When a branch closes with a stack of types, the compiler will compare to<br>&gt; other branches to see which type is the narrowest that they have in common;<br>&gt; this is actually fairly simple (shorten the stack for each branch to the<br>&gt; length of the shortest stack, then discard elements until the current one<br>&gt; is a match for all branches, thus you now know what the narrowest type is<br>&gt; past that point).<br>&gt;<br>&gt; So, for types that never narrow there should be no speed difference, while<br>&gt; for narrowed types there shouldn&#39;t be much of a difference, as these stacks<br>&gt; of types shouldn&#39;t get very large in most cases (I&#39;d expect anything more<br>&gt; than three to be pretty rare).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161108/50c93277/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  9, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 8 Nov 2016, at 12:22, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; (1) You can define different methods with the same name on T and Optional&lt;T&gt; (description is such an example). Then what does this do?<br>&gt; <br>&gt; // someMethod is defined both for T and T?<br>&gt; // var foo: T?<br>&gt; if foo != nil {<br>&gt;     foo.someMethod()<br>&gt; }<br>&gt; <br>&gt; I say there is a clear expectation that foo.someMethod() should call the method of T?, even inside the if block, since this is how the dot works. However, according to the proposal it will call another method (or become an error?).<br>&gt; <br>&gt; I think the languages that use optional narrowing are the ones where T? is not a separate type, so that it cannot have its own methods.<br></p><p>Hmm, that is definitely a wrinkle in the plan; it&#39;s very much an edge case (someone defining something on optionals that they probably shouldn&#39;t) but not an easy one to resolve. I suppose I&#39;ll have to amend the proposal to suggest type widening in that case, such that you would need to use ! or ? as normal to specify the unwrapped value. The tricky part is that it means the value would have to be widened from the start, otherwise you&#39;d be accessing the value in two different ways in the same block of code, which would mean that narrowing would need to be blocked if there&#39;s an incompatible statement further down… ugh, perhaps a keyword will be necessary then? I was really hoping to avoid having to add one though.<br></p><p>&gt; (2) Should this work?<br>&gt; <br>&gt; // compilcatedStuff is a method of T<br>&gt; // class A { var foo: T? }<br>&gt; <br>&gt; if foo != nil {<br>&gt;     foo.compilcatedStuff()<br>&gt;     foo.compilcatedStuff()<br>&gt;     foo.compilcatedStuff()<br>&gt; }<br>&gt; <br>&gt; Suppose the compiler doesn&#39;t have enough information about compilcatedStuff to know what happens inside. Then it&#39;s possible that foo.compilcatedStuff will actually change foo (for example, foo could be a relationship and compilcatedStuff may be deleting the relationship). So, what is the suggestion for this example? Perhaps<br>&gt; <br>&gt; if foo != nil {<br>&gt;     foo.compilcatedStuff()<br>&gt;     foo?.compilcatedStuff()<br>&gt;     foo?.compilcatedStuff()<br>&gt; }<br>&gt; <br>&gt; or some other choice?<br></p><p>What do you imagine being inside .complicatedStuff()? It shouldn&#39;t be possible for it to change foo to nil, as even if .complicatedStuff() reassigned this, it would be doing so as type T.<br></p><p>&gt; On 9 Nov 2016, at 06:51, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; This looks like a lot of complexity for very little gain.<br>&gt;&gt; <br>&gt; <br>&gt;&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers. To figure out what a piece of code means, someone reading it will have to mentally keep track of a “type stack” for every variable. That is the opposite of “clarity at the point of use”.<br>&gt; <br>&gt; Very well said. I think this is perhaps the number one complaint I have about the proposal.<br></p><p><br>Did you see my response to this? There should be no particular cognitive load increase; think of the feature like type inference, the idea here is that the type-checker is gaining the same knowledge that you already have, i.e- you know something isn&#39;t nil, so the type-checker should too.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/33632606/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>November  9, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; What do you imagine being inside .complicatedStuff()? It shouldn&#39;t be<br>possible for it to change foo to nil, as even if .complicatedStuff()<br>reassigned this, it would be doing so as type T.<br></p><p>Why do you think so? All objects can be changed in any method. Let&#39;s rename<br>foo to pet and complicatedStuff to setFree to give a specific example:<br></p><p>class Pet {<br>    var owner: Person?<br>    func setFree()<br>    {<br>       // Maintain the relationship correctness.<br>        owner?.pet = nil<br>        owner = nil<br>    }<br>}<br></p><p>class Person {<br></p><p>var pet: Pet?<br></p><p>func ... {<br>  if pet != nil {<br>    pet.setFree() // this sets pet = nil<br>    pet.setFree() // ???? what does this do ????<br>    pet.setFree()<br>  }<br>}<br>}<br></p><p>On Wed, Nov 9, 2016 at 10:51 AM Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt; On 8 Nov 2016, at 12:22, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;<br>&gt; (1) You can define different methods with the same name on T and<br>&gt; Optional&lt;T&gt; (description is such an example). Then what does this do?<br>&gt;<br>&gt; // someMethod is defined both for T and T?<br>&gt; // var foo: T?<br>&gt; if foo != nil {<br>&gt;     foo.someMethod()<br>&gt; }<br>&gt;<br>&gt; I say there is a clear expectation that foo.someMethod() should call the<br>&gt; method of T?, even inside the if block, since this is how the dot works.<br>&gt; However, according to the proposal it will call another method (or become<br>&gt; an error?).<br>&gt;<br>&gt; I think the languages that use optional narrowing are the ones where T? is<br>&gt; not a separate type, so that it cannot have its own methods.<br>&gt;<br>&gt;<br>&gt; Hmm, that is definitely a wrinkle in the plan; it&#39;s very much an edge case<br>&gt; (someone defining something on optionals that they probably shouldn&#39;t) but<br>&gt; not an easy one to resolve. I suppose I&#39;ll have to amend the proposal to<br>&gt; suggest type widening in that case, such that you would need to use ! or ?<br>&gt; as normal to specify the unwrapped value. The tricky part is that it means<br>&gt; the value would have to be widened from the start, otherwise you&#39;d be<br>&gt; accessing the value in two different ways in the same block of code, which<br>&gt; would mean that narrowing would need to be blocked if there&#39;s an<br>&gt; incompatible statement further down… ugh, perhaps a keyword will be<br>&gt; necessary then? I was really hoping to avoid having to add one though.<br>&gt;<br>&gt; (2) Should this work?<br>&gt;<br>&gt; // compilcatedStuff is a method of T<br>&gt; // class A { var foo: T? }<br>&gt;<br>&gt; if foo != nil {<br>&gt;     foo.compilcatedStuff()<br>&gt;     foo.compilcatedStuff()<br>&gt;     foo.compilcatedStuff()<br>&gt; }<br>&gt;<br>&gt; Suppose the compiler doesn&#39;t have enough information about<br>&gt; compilcatedStuff to know what happens inside. Then it&#39;s possible<br>&gt; that foo.compilcatedStuff will actually change foo (for example, foo could<br>&gt; be a relationship and compilcatedStuff may be deleting the relationship).<br>&gt; So, what is the suggestion for this example? Perhaps<br>&gt;<br>&gt; if foo != nil {<br>&gt;     foo.compilcatedStuff()<br>&gt;     foo?.compilcatedStuff()<br>&gt;     foo?.compilcatedStuff()<br>&gt; }<br>&gt;<br>&gt; or some other choice?<br>&gt;<br>&gt;<br>&gt; What do you imagine being inside .complicatedStuff()? It shouldn&#39;t be<br>&gt; possible for it to change foo to nil, as even if .complicatedStuff()<br>&gt; reassigned this, it would be doing so as type T.<br>&gt;<br>&gt; On 9 Nov 2016, at 06:51, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; This looks like a lot of complexity for very little gain.<br>&gt;<br>&gt;<br>&gt; Aside from any implementation concerns, this proposal substantially<br>&gt; increases the cognitive load on developers. To figure out what a piece of<br>&gt; code means, someone reading it will have to mentally keep track of a “type<br>&gt; stack” for every variable. That is the opposite of “clarity at the point of<br>&gt; use”.<br>&gt;<br>&gt;<br>&gt; Very well said. I think this is perhaps the number one complaint I have<br>&gt; about the proposal.<br>&gt;<br>&gt;<br>&gt; Did you see my response to this? There should be no particular cognitive<br>&gt; load increase; think of the feature like type inference, the idea here is<br>&gt; that the type-checker is gaining the same knowledge that you already have,<br>&gt; i.e- you know something isn&#39;t nil, so the type-checker should too.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/e661ba72/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  9, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 9 Nov 2016, at 10:00, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt; <br>&gt; &gt; What do you imagine being inside .complicatedStuff()? It shouldn&#39;t be possible for it to change foo to nil, as even if .complicatedStuff() reassigned this, it would be doing so as type T.<br>&gt; <br>&gt; Why do you think so? All objects can be changed in any method. Let&#39;s rename foo to pet and complicatedStuff to setFree to give a specific example:<br>&gt; <br>&gt; class Pet {<br>&gt;     var owner: Person?<br>&gt;     func setFree() <br>&gt;     {<br>&gt;        // Maintain the relationship correctness.<br>&gt;         owner?.pet = nil<br>&gt;         owner = nil<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Person { <br>&gt; <br>&gt; var pet: Pet? <br>&gt; <br>&gt; func ... {<br>&gt;   if pet != nil {<br>&gt;     pet.setFree() // this sets pet = nil<br>&gt;     pet.setFree() // ???? what does this do ????<br>&gt;     pet.setFree()<br>&gt;   }<br>&gt; }<br>&gt; }<br></p><p>Ah, this comes back to the issue of class concurrency problems; the solution to this is that class references won&#39;t be narrowed, but the type-narrowing checks will still note cases that *could* have been narrowed, so that they can produce concurrency errors at runtime rather than the more generic error.<br></p><p>I just realised I never did provide a link to the working copy of the proposal, you can view some of the updates I&#39;ve made here, which includes a note on classes and concurrency:<br>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md<br></p><p>Though there is still a lot to do, especially if I&#39;m going to have to change the proposal to use a keyword instead to avoid the Optional&lt;T&gt; to T method shadowing problem.<br></p><p>So yeah, in other words I&#39;m assuming narrowing only on structs, as these are the only types where it is possible for the type-checker to be certain; though this could be extended to classes in future if we gain some attribute for indicating when they are &quot;safe&quot; (e.g- changed through copy-on-write, thus safe for narrowing).<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  9, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On 09 Nov 2016, at 10:51, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 8 Nov 2016, at 12:22, ilya &lt;ilya.nikokoshev at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (1) You can define different methods with the same name on T and Optional&lt;T&gt; (description is such an example). Then what does this do?<br>&gt;&gt; <br>&gt;&gt; // someMethod is defined both for T and T?<br>&gt;&gt; // var foo: T?<br>&gt;&gt; if foo != nil {<br>&gt;&gt;     foo.someMethod()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I say there is a clear expectation that foo.someMethod() should call the method of T?, even inside the if block, since this is how the dot works. However, according to the proposal it will call another method (or become an error?).<br>&gt;&gt; <br>&gt;&gt; I think the languages that use optional narrowing are the ones where T? is not a separate type, so that it cannot have its own methods.<br>&gt; <br>&gt; Hmm, that is definitely a wrinkle in the plan; it&#39;s very much an edge case (someone defining something on optionals that they probably shouldn&#39;t) but not an easy one to resolve. I suppose I&#39;ll have to amend the proposal to suggest type widening in that case, such that you would need to use ! or ? as normal to specify the unwrapped value. The tricky part is that it means the value would have to be widened from the start, otherwise you&#39;d be accessing the value in two different ways in the same block of code, which would mean that narrowing would need to be blocked if there&#39;s an incompatible statement further down… ugh, perhaps a keyword will be necessary then? I was really hoping to avoid having to add one though.<br>&gt; <br>&gt;&gt; (2) Should this work?<br>&gt;&gt; <br>&gt;&gt; // compilcatedStuff is a method of T<br>&gt;&gt; // class A { var foo: T? }<br>&gt;&gt; <br>&gt;&gt; if foo != nil {<br>&gt;&gt;     foo.compilcatedStuff()<br>&gt;&gt;     foo.compilcatedStuff()<br>&gt;&gt;     foo.compilcatedStuff()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Suppose the compiler doesn&#39;t have enough information about compilcatedStuff to know what happens inside. Then it&#39;s possible that foo.compilcatedStuff will actually change foo (for example, foo could be a relationship and compilcatedStuff may be deleting the relationship). So, what is the suggestion for this example? Perhaps<br>&gt;&gt; <br>&gt;&gt; if foo != nil {<br>&gt;&gt;     foo.compilcatedStuff()<br>&gt;&gt;     foo?.compilcatedStuff()<br>&gt;&gt;     foo?.compilcatedStuff()<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; or some other choice?<br>&gt; <br>&gt; What do you imagine being inside .complicatedStuff()? It shouldn&#39;t be possible for it to change foo to nil, as even if .complicatedStuff() reassigned this, it would be doing so as type T.<br>&gt; <br>&gt;&gt; On 9 Nov 2016, at 06:51, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This looks like a lot of complexity for very little gain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers. To figure out what a piece of code means, someone reading it will have to mentally keep track of a “type stack” for every variable. That is the opposite of “clarity at the point of use”.<br>&gt;&gt; <br>&gt;&gt; Very well said. I think this is perhaps the number one complaint I have about the proposal.<br>&gt; <br>&gt; Did you see my response to this? There should be no particular cognitive load increase; think of the feature like type inference, the idea here is that the type-checker is gaining the same knowledge that you already have, i.e- you know something isn&#39;t nil, so the type-checker should too.<br></p><p>Locally in short routines yes.<br>But in larger modules and non-local this does not apply.<br>Imo it should always be possible to look at a type declaration and -from that- derive all necessary knowledge about the type.<br>Besides when using a narrowed type as a parameter for an optional it must be automatically be widened again? hence you would mentally keep track of the status of that variable.<br></p><p><br></p><p><br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 9 Nov 2016, at 12:19, Rien &lt;Rien at balancingrock.nl&gt; wrote:<br>&gt;&gt; On 9 Nov 2016, at 06:51, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This looks like a lot of complexity for very little gain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers. To figure out what a piece of code means, someone reading it will have to mentally keep track of a “type stack” for every variable. That is the opposite of “clarity at the point of use”.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Very well said. I think this is perhaps the number one complaint I have about the proposal.<br>&gt;&gt; <br>&gt;&gt; Did you see my response to this? There should be no particular cognitive load increase; think of the feature like type inference, the idea here is that the type-checker is gaining the same knowledge that you already have, i.e- you know something isn&#39;t nil, so the type-checker should too.<br>&gt; <br>&gt; Locally in short routines yes.<br>&gt; But in larger modules and non-local this does not apply.<br></p><p>I&#39;m not sure what you mean; type-narrowing doesn&#39;t occur across scopes, ultimately you will always have some starting type where the variable was declared as a property, function argument or local variable, and it is narrow only where it is used, and the narrowing only occurs within that scope for as long as it is relevant.<br></p><p>In other words, the narrowing is always local. If you know your method takes an optional string for example then you know that that variable is still an optional string throughout that method, type-narrowing just helps to guarantee that it is nil or non-nil where you expect it to be.<br></p><p>&gt; Imo it should always be possible to look at a type declaration and -from that- derive all necessary knowledge about the type.<br></p><p>As I say, narrowing never changes the type; if you have a variable with a declared type of Foo, that is narrowed to Bar, then it is because Bar extends Foo and thus is compatible with it, giving you access to any additional methods of Bar without interfering with what you know of Foo.<br></p><p>&gt; Besides when using a narrowed type as a parameter for an optional it must be automatically be widened again? hence you would mentally keep track of the status of that variable.<br></p><p>I&#39;m not sure I follow this question; do you mean something like this:<br></p><p>	func someMethod(foo:Foo?) {<br>		var bar:Foo? = nil // bar is Optional&lt;Foo&gt;.none<br>		if (foo != nil) { // foo is Optional&lt;Foo&gt;.some<br>			bar = foo // both foo and bar are Optional&lt;Foo&gt;.some<br>		}<br>		// both foo and bar are Optional&lt;Foo&gt; (alternative branch places no mutual guarantee on type)<br>		if bar != nil { // bar is Optional&lt;Foo&gt;.some<br>			bar.someMutatingMethod()<br>		}<br>	}<br></p><p>But these are all things that the developer knows; bar can&#39;t be non-nil until a value for it is set, foo is definitely non-nil within the block etc. The only difference here is that instead of the developer having to use ! unnecessarily (or risk making a mistake) they can just use their knowledge of what it is to interact directly, as the type-checker will now also know the same thing.<br></p><p>However, with the Optional&lt;T&gt; to T method shadowing issue it seems we probably will need to require a keyword, or at the very least restrict automatic narrowing to polymorphism. For optionals the code will have to look something like this:<br></p><p>	func someMethod(foo:Foo?) {<br>		var bar:Foo? = nil<br>		if unwrap foo {<br>			bar = foo<br>		}<br></p><p>		if unwrap bar {<br>			bar.someMutatingMethod()<br>		}<br>	}<br></p><p>The difference here is that unlike shadowing (if let foo = foo), if foo were mutable then it could still be mutated directly, no need to do it with force unwrapping. Of course in these simple examples you could just use the question mark operator instead, but pretend we&#39;re doing more than one thing per conditional 😉<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/c4016d22/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>November  9, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; The difference here is that unlike shadowing (if let foo = foo), if foo<br>were mutable then it could still be mutated directly, no need to do it with<br>force unwrapping.<br></p><p>FWIW, there is no need for force unwrapping in any case.<br></p><p>var bar:Foo? = nil<br></p><p>if let real_foo = foo {<br>bar = real_foo<br>}<br></p><p>if var bar_copy = bar {<br>bar_copy.someMutatingMethod()<br>                        bar = bar_copy<br>}<br></p><p>On Wed, Nov 9, 2016 at 3:28 PM Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt; On 9 Nov 2016, at 12:19, Rien &lt;Rien at balancingrock.nl&gt; wrote:<br>&gt;<br>&gt; On 9 Nov 2016, at 06:51, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;<br>&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; This looks like a lot of complexity for very little gain.<br>&gt;<br>&gt; Aside from any implementation concerns, this proposal substantially<br>&gt; increases the cognitive load on developers. To figure out what a piece of<br>&gt; code means, someone reading it will have to mentally keep track of a “type<br>&gt; stack” for every variable. That is the opposite of “clarity at the point of<br>&gt; use”.<br>&gt;<br>&gt;<br>&gt; Very well said. I think this is perhaps the number one complaint I have<br>&gt; about the proposal.<br>&gt;<br>&gt;<br>&gt; Did you see my response to this? There should be no particular cognitive<br>&gt; load increase; think of the feature like type inference, the idea here is<br>&gt; that the type-checker is gaining the same knowledge that you already have,<br>&gt; i.e- you know something isn&#39;t nil, so the type-checker should too.<br>&gt;<br>&gt;<br>&gt; Locally in short routines yes.<br>&gt; But in larger modules and non-local this does not apply.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure what you mean; type-narrowing doesn&#39;t occur across scopes,<br>&gt; ultimately you will always have some starting type where the variable was<br>&gt; declared as a property, function argument or local variable, and it is<br>&gt; narrow only where it is used, and the narrowing only occurs within that<br>&gt; scope for as long as it is relevant.<br>&gt;<br>&gt; In other words, the narrowing is always local. If you know your method<br>&gt; takes an optional string for example then you know that that variable is<br>&gt; still an optional string throughout that method, type-narrowing just helps<br>&gt; to guarantee that it is nil or non-nil where you expect it to be.<br>&gt;<br>&gt; Imo it should always be possible to look at a type declaration and -from<br>&gt; that- derive all necessary knowledge about the type.<br>&gt;<br>&gt;<br>&gt; As I say, narrowing never changes the type; if you have a variable with a<br>&gt; declared type of Foo, that is narrowed to Bar, then it is because Bar<br>&gt; extends Foo and thus is compatible with it, giving you access to any<br>&gt; additional methods of Bar without interfering with what you know of Foo.<br>&gt;<br>&gt; Besides when using a narrowed type as a parameter for an optional it must<br>&gt; be automatically be widened again? hence you would mentally keep track of<br>&gt; the status of that variable.<br>&gt;<br>&gt;<br>&gt; I&#39;m not sure I follow this question; do you mean something like this:<br>&gt;<br>&gt; func someMethod(foo:Foo?) {<br>&gt; var bar:Foo? = nil // bar is Optional&lt;Foo&gt;.none<br>&gt; if (foo != nil) { // foo is Optional&lt;Foo&gt;.some<br>&gt; bar = foo // both foo and bar are Optional&lt;Foo&gt;.some<br>&gt; }<br>&gt; // both foo and bar are Optional&lt;Foo&gt; (alternative branch places no mutual<br>&gt; guarantee on type)<br>&gt; if bar != nil { // bar is Optional&lt;Foo&gt;.some<br>&gt; bar.someMutatingMethod()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; But these are all things that the developer knows; bar can&#39;t be non-nil<br>&gt; until a value for it is set, foo is definitely non-nil within the block<br>&gt; etc. The only difference here is that instead of the developer having to<br>&gt; use ! unnecessarily (or risk making a mistake) they can just use their<br>&gt; knowledge of what it is to interact directly, as the type-checker will now<br>&gt; also know the same thing.<br>&gt;<br>&gt; However, with the Optional&lt;T&gt; to T method shadowing issue it seems we<br>&gt; probably will need to require a keyword, or at the very least restrict<br>&gt; automatic narrowing to polymorphism. For optionals the code will have to<br>&gt; look something like this:<br>&gt;<br>&gt; func someMethod(foo:Foo?) {<br>&gt; var bar:Foo? = nil<br>&gt; if unwrap foo {<br>&gt; bar = foo<br>&gt; }<br>&gt;<br>&gt; if unwrap bar {<br>&gt; bar.someMutatingMethod()<br>&gt; }<br>&gt; }<br>&gt;<br>&gt; The difference here is that unlike shadowing (if let foo = foo), if foo<br>&gt; were mutable then it could still be mutated directly, no need to do it with<br>&gt; force unwrapping. Of course in these simple examples you could just use the<br>&gt; question mark operator instead, but pretend we&#39;re doing more than one thing<br>&gt; per conditional 😉<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161109/3775193b/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/eddffe5cd2c817d61892d77edf66b6b2?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Rien</string> &lt;Rien at Balancingrock.nl&gt;<p>November  9, 2016 at 04:00:00pm</p></header><div class="content"><p>I get narrowing, and have admittedly often wished for it myself. Hence I have kept out of this discussion.<br>But the argument for cognitive overload is imo convincing.<br></p><p>When we create examples, there is almost no (or even negative) cognitive load associated with narrowing.<br>However when you get a piece of code in front of you with 10+ optionals, 5 if-statements deep with loops intermixed, and you have to find where the nil-error occurs?<br>It would drive me nuts… especially in these kind of cases:<br></p><p>if foo != nil {<br>	…<br>	foo = newFoo()<br>	…<br>	if foo != nil {<br>	…<br>	}<br>}<br></p><p>Mind you, I am against automagic narrowing because I like things to be simple, but it is not a make or break deal.<br></p><p>Btw, I think that using a keyword makes it more palatable.<br></p><p>if unwrap foo {<br>	…<br>	foo = newFoo()<br>	…<br>	if unwrap foo {<br>	…<br>	}<br>}<br></p><p>Now it is clear that something is done to foo, its no longer a compare with side effects but an operation on foo itself.<br></p><p>Regards,<br>Rien<br></p><p>Site: http://balancingrock.nl<br>Blog: http://swiftrien.blogspot.com<br>Github: http://github.com/Swiftrien<br>Project: http://swiftfire.nl<br></p><p><br></p><p><br>&gt; On 09 Nov 2016, at 15:28, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 9 Nov 2016, at 12:19, Rien &lt;Rien at balancingrock.nl&gt; wrote:<br>&gt;&gt;&gt; On 9 Nov 2016, at 06:51, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; On 3 Nov 2016, at 20:23, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This looks like a lot of complexity for very little gain.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Aside from any implementation concerns, this proposal substantially increases the cognitive load on developers. To figure out what a piece of code means, someone reading it will have to mentally keep track of a “type stack” for every variable. That is the opposite of “clarity at the point of use”.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Very well said. I think this is perhaps the number one complaint I have about the proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you see my response to this? There should be no particular cognitive load increase; think of the feature like type inference, the idea here is that the type-checker is gaining the same knowledge that you already have, i.e- you know something isn&#39;t nil, so the type-checker should too.<br>&gt;&gt; <br>&gt;&gt; Locally in short routines yes.<br>&gt;&gt; But in larger modules and non-local this does not apply.<br>&gt; <br>&gt; I&#39;m not sure what you mean; type-narrowing doesn&#39;t occur across scopes, ultimately you will always have some starting type where the variable was declared as a property, function argument or local variable, and it is narrow only where it is used, and the narrowing only occurs within that scope for as long as it is relevant.<br>&gt; <br>&gt; In other words, the narrowing is always local. If you know your method takes an optional string for example then you know that that variable is still an optional string throughout that method, type-narrowing just helps to guarantee that it is nil or non-nil where you expect it to be.<br>&gt; <br>&gt;&gt; Imo it should always be possible to look at a type declaration and -from that- derive all necessary knowledge about the type.<br>&gt; <br>&gt; As I say, narrowing never changes the type; if you have a variable with a declared type of Foo, that is narrowed to Bar, then it is because Bar extends Foo and thus is compatible with it, giving you access to any additional methods of Bar without interfering with what you know of Foo.<br>&gt; <br>&gt;&gt; Besides when using a narrowed type as a parameter for an optional it must be automatically be widened again? hence you would mentally keep track of the status of that variable.<br>&gt; <br>&gt; I&#39;m not sure I follow this question; do you mean something like this:<br>&gt; <br>&gt; 	func someMethod(foo:Foo?) {<br>&gt; 		var bar:Foo? = nil // bar is Optional&lt;Foo&gt;.none<br>&gt; 		if (foo != nil) { // foo is Optional&lt;Foo&gt;.some<br>&gt; 			bar = foo // both foo and bar are Optional&lt;Foo&gt;.some<br>&gt; 		}<br>&gt; 		// both foo and bar are Optional&lt;Foo&gt; (alternative branch places no mutual guarantee on type)<br>&gt; 		if bar != nil { // bar is Optional&lt;Foo&gt;.some<br>&gt; 			bar.someMutatingMethod()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; But these are all things that the developer knows; bar can&#39;t be non-nil until a value for it is set, foo is definitely non-nil within the block etc. The only difference here is that instead of the developer having to use ! unnecessarily (or risk making a mistake) they can just use their knowledge of what it is to interact directly, as the type-checker will now also know the same thing.<br>&gt; <br>&gt; However, with the Optional&lt;T&gt; to T method shadowing issue it seems we probably will need to require a keyword, or at the very least restrict automatic narrowing to polymorphism. For optionals the code will have to look something like this:<br>&gt; <br>&gt; 	func someMethod(foo:Foo?) {<br>&gt; 		var bar:Foo? = nil<br>&gt; 		if unwrap foo {<br>&gt; 			bar = foo<br>&gt; 		}<br>&gt; <br>&gt; 		if unwrap bar {<br>&gt; 			bar.someMutatingMethod()<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; The difference here is that unlike shadowing (if let foo = foo), if foo were mutable then it could still be mutated directly, no need to do it with force unwrapping. Of course in these simple examples you could just use the question mark operator instead, but pretend we&#39;re doing more than one thing per conditional 😉<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November  9, 2016 at 06:00:00pm</p></header><div class="content"><p>So I&#39;m trying to re-write the proposal with the use of a keyword for unwrapping in mind, to keep it simpler for myself I&#39;ve done this as two separate proposals for the time being, one for simpler unwrapping of optionals, and one for type-narrowing of polymorphic types:<br></p><p>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md<br>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md<br></p><p>In addition to feedback on each proposal, I&#39;m interested to know whether people think it is better to keep these separate? They&#39;re still very similar features, but the differences make it pretty awkward to keep them in one big proposal.<br></p><p>I&#39;ve also given up on integrating enums generically into it; as I don&#39;t think it&#39;s possible to do it in a similar enough way, and some extension to pattern matching would probably be better anyway.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>November 10, 2016 at 10:00:00am</p></header><div class="content"><p>So a lot of concerns here especially ilya&#39;s are ones that wouldn&#39;t be<br>brought up if people looked at existing successful implementations like<br>Kotlin where they are clearly solved. (fyi, answer is only narrowing with<br>immutable values.)<br></p><p>Personally I think type narrowing with explicit opt-in has no value. All or<br>nothing, the whole meat of the proposal is in it being implicit.<br></p><p>I see too many people predisposed to considering this as if it&#39;s &quot;compiler<br>magic&quot; to the point where I don&#39;t feel the cost of arguing is worth what it<br>would bring to the language. Sure, it&#39;s a nice piece of syntax sugar but<br>it&#39;s not going to revolutionise it, and if it makes compilation times even<br>slower I&#39;m probably against it - xcode in general has been driving me up a<br>wall lately with a matter of minutes for compiling and signing our (not<br>huge) project, so any compiler speed improvements take on increased<br>precedence for me.<br></p><p>Just my 2c.<br></p><p>Dennis<br></p><p>On Wed, Nov 9, 2016, 13:52 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; So I&#39;m trying to re-write the proposal with the use of a keyword for<br>&gt; unwrapping in mind, to keep it simpler for myself I&#39;ve done this as two<br>&gt; separate proposals for the time being, one for simpler unwrapping of<br>&gt; optionals, and one for type-narrowing of polymorphic types:<br>&gt;<br>&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md<br>&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md<br>&gt;<br>&gt; In addition to feedback on each proposal, I&#39;m interested to know whether<br>&gt; people think it is better to keep these separate? They&#39;re still very<br>&gt; similar features, but the differences make it pretty awkward to keep them<br>&gt; in one big proposal.<br>&gt;<br>&gt; I&#39;ve also given up on integrating enums generically into it; as I don&#39;t<br>&gt; think it&#39;s possible to do it in a similar enough way, and some extension to<br>&gt; pattern matching would probably be better anyway.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/2ad2f09b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 10, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 10 Nov 2016, at 10:32, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt; wrote:<br>&gt; So a lot of concerns here especially ilya&#39;s are ones that wouldn&#39;t be brought up if people looked at existing successful implementations like Kotlin where they are clearly solved. (fyi, answer is only narrowing with immutable values.)<br>&gt; <br>&gt; Personally I think type narrowing with explicit opt-in has no value. All or nothing, the whole meat of the proposal is in it being implicit.<br>&gt; <br>Right you are, I think an explicit keyword is only required for optionals; stripping them out into their own proposal simplifies things considerably. I&#39;ve tweaked the type-narrowing specific proposal to return implicit narrowing (or explicit via the is keyword and assignment, depending upon how you want to look at it).<br></p><p>I do think there is still value in handling reference types as well, but I&#39;m proposing that this is done with a new force is! keyword which forces the narrowing (but causes a runtime concurrent modification error if the type no longer matches what the type-checker expects), as well as a new @concurrency(safe) attribute that can be used to indicate variables that posses a safe reference to an instance, e.g- for types that use a storage class for copy-on-write functionality, or where the value is local to a method etc. (though this isn&#39;t enforced).<br>&gt; if it makes compilation times even slower I&#39;m probably against it - xcode in general has been driving me up a wall lately with a matter of minutes for compiling and signing our (not huge) project, so any compiler speed improvements take on increased precedence for me.<br>&gt; <br>While I agree that the current performance can leave a lot to be desired, I don&#39;t think that this should actually slow it down by any meaningful amount; most variables won&#39;t narrow so will just be a single type as normal, and with optionals removed from the narrowing process the type-checker should only ever need to compare against the narrowest type on the stack, i.e- the only time wider types are considered is when you assign a wider type to a narrowed variable, and that&#39;s just popping types off the stack to get the new current type.<br></p><p>But yeah, if it were have a big impact on performance I&#39;d recommend delaying it until major optimisation work has been done, but I don&#39;t see that it should make much of a difference, and it really shouldn&#39;t be any more of a burden than shadowing is today.<br></p><p>&gt;&gt; On Wed, Nov 9, 2016, 13:52 Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; So I&#39;m trying to re-write the proposal with the use of a keyword for unwrapping in mind, to keep it simpler for myself I&#39;ve done this as two separate proposals for the time being, one for simpler unwrapping of optionals, and one for type-narrowing of polymorphic types:<br>&gt;&gt; <br>&gt;&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md&gt;<br>&gt;&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;&gt; <br>&gt;&gt; In addition to feedback on each proposal, I&#39;m interested to know whether people think it is better to keep these separate? They&#39;re still very similar features, but the differences make it pretty awkward to keep them in one big proposal.<br>&gt;&gt; <br>&gt;&gt; I&#39;ve also given up on integrating enums generically into it; as I don&#39;t think it&#39;s possible to do it in a similar enough way, and some extension to pattern matching would probably be better anyway.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/d55b1c40/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>November 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Haravikk,<br></p><p>I think you missed ilya’s point with the owner/pet example:<br></p><p>// This is inside the Owner class...func freeMyPetIfIHaveOne {<br>  if pet != nil {<br>    pet.setFree() // this sets pet = nil<br>    // self.pet is now nil - not due to concurrency, it was set to nil<br>on this thread in the function above.<br>    // However, the compiler considers it a non-optional at this point<br>    pet.doStuff() // Compiler allows, bad things happen!<br>  }<br>}<br></p><p>As Dennis mentioned, narrowing only works for immutable values, and since<br>optionals are always mutable it defeats the whole justification for it. I<br>like the concept, but maybe it should be for immutables only?<br>​<br></p><p>On Thu, 10 Nov 2016 at 11:27 Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 10 Nov 2016, at 10:32, Dennis Lysenko &lt;dennis.s.lysenko at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; So a lot of concerns here especially ilya&#39;s are ones that wouldn&#39;t be<br>&gt; brought up if people looked at existing successful implementations like<br>&gt; Kotlin where they are clearly solved. (fyi, answer is only narrowing with<br>&gt; immutable values.)<br>&gt;<br>&gt; Personally I think type narrowing with explicit opt-in has no value. All<br>&gt; or nothing, the whole meat of the proposal is in it being implicit.<br>&gt;<br>&gt; Right you are, I think an explicit keyword is only required for optionals;<br>&gt; stripping them out into their own proposal simplifies things considerably.<br>&gt; I&#39;ve tweaked the type-narrowing specific proposal to return implicit<br>&gt; narrowing (or explicit via the is keyword and assignment, depending upon<br>&gt; how you want to look at it).<br>&gt;<br>&gt; I do think there is still value in handling reference types as well, but<br>&gt; I&#39;m proposing that this is done with a new force is! keyword which forces<br>&gt; the narrowing (but causes a runtime concurrent modification error if the<br>&gt; type no longer matches what the type-checker expects), as well as a new<br>&gt; @concurrency(safe) attribute that can be used to indicate variables that<br>&gt; posses a safe reference to an instance, e.g- for types that use a storage<br>&gt; class for copy-on-write functionality, or where the value is local to a<br>&gt; method etc. (though this isn&#39;t enforced).<br>&gt;<br>&gt; if it makes compilation times even slower I&#39;m probably against it - xcode<br>&gt; in general has been driving me up a wall lately with a matter of minutes<br>&gt; for compiling and signing our (not huge) project, so any compiler speed<br>&gt; improvements take on increased precedence for me.<br>&gt;<br>&gt; While I agree that the current performance can leave a lot to be desired,<br>&gt; I don&#39;t think that this should actually slow it down by any meaningful<br>&gt; amount; most variables won&#39;t narrow so will just be a single type as<br>&gt; normal, and with optionals removed from the narrowing process the<br>&gt; type-checker should only ever need to compare against the narrowest type on<br>&gt; the stack, i.e- the only time wider types are considered is when you assign<br>&gt; a wider type to a narrowed variable, and that&#39;s just popping types off the<br>&gt; stack to get the new current type.<br>&gt;<br>&gt; But yeah, if it were have a big impact on performance I&#39;d recommend<br>&gt; delaying it until major optimisation work has been done, but I don&#39;t see<br>&gt; that it should make much of a difference, and it really shouldn&#39;t be any<br>&gt; more of a burden than shadowing is today.<br>&gt;<br>&gt; On Wed, Nov 9, 2016, 13:52 Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; So I&#39;m trying to re-write the proposal with the use of a keyword for<br>&gt; unwrapping in mind, to keep it simpler for myself I&#39;ve done this as two<br>&gt; separate proposals for the time being, one for simpler unwrapping of<br>&gt; optionals, and one for type-narrowing of polymorphic types:<br>&gt;<br>&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md<br>&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md<br>&gt;<br>&gt; In addition to feedback on each proposal, I&#39;m interested to know whether<br>&gt; people think it is better to keep these separate? They&#39;re still very<br>&gt; similar features, but the differences make it pretty awkward to keep them<br>&gt; in one big proposal.<br>&gt;<br>&gt; I&#39;ve also given up on integrating enums generically into it; as I don&#39;t<br>&gt; think it&#39;s possible to do it in a similar enough way, and some extension to<br>&gt; pattern matching would probably be better anyway.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/2b0037e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 10 Nov 2016, at 16:53, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Haravikk,<br>&gt; <br>&gt; I think you missed ilya’s point with the owner/pet example:<br>&gt; <br>&gt; // This is inside the Owner class...<br>&gt; func freeMyPetIfIHaveOne {<br>&gt;   if pet != nil {<br>&gt;     pet.setFree() // this sets pet = nil<br>&gt;     // self.pet is now nil - not due to concurrency, it was set to nil on this thread in the function above.<br>&gt;     // However, the compiler considers it a non-optional at this point<br>&gt;     pet.doStuff() // Compiler allows, bad things happen!<br>&gt;   }<br>&gt; }<br>&gt; As Dennis mentioned, narrowing only works for immutable values, and since optionals are always mutable it defeats the whole justification for it. I like the concept, but maybe it should be for immutables only?<br>&gt; <br>If pet is of type Optional&lt;T&gt; then a .setFree() method on T cannot set self = nil, as self is of type T only in that scope.<br></p><p>The only way you can do something like that is to declare the setFree() method on Optional where Element:T, but that won&#39;t work on the updated proposal which uses a keyword to explicitly unwrap the variable (to avoid precisely that kind of Optional&lt;T&gt; vs T method conflict), you can view the updated proposals here:<br></p><p>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md&gt;<br>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br></p><p>I&#39;ve also checked and a similar case like this for polymorphic types shouldn&#39;t be an issue either, as you can&#39;t assign self to a wider (or even orthogonal) type.<br></p><p>In other words, the only way that .setFree() can make changes that would break narrowing would be to have a reference to the instance you&#39;re working with, which is what the proposals now guard against. But for value types this should not be an issue at all.<br></p><p>This is all of course unless I&#39;m missing something else, but I tried in a playground and I can&#39;t assign anything to self that would break narrowing/unwrapping that I can see, except through a reference type.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/eeeaabd8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14f382feb5f0dd3d3700edf8d6156aa9?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Jay Abbott</string> &lt;jay at abbott.me.uk&gt;<p>November 10, 2016 at 09:00:00pm</p></header><div class="content"><p>Consider this code:<br></p><p>struct Pet {<br>    let name: String<br>    weak var owner: Person?<br></p><p>    init(name: String, owner: Person?) {<br>        self.name = name<br>        self.owner = owner<br>        owner?.pet = self<br>    }<br></p><p>    mutating func transferOwnership(to newOwner: Person) {<br>        let previousOwner = owner<br>        owner = newOwner<br>        newOwner.pet = self<br>        if(previousOwner != nil) {<br>            previousOwner!.pet = nil<br>        }<br>    }<br></p><p>    func feed() {<br>    }<br>}<br>class Person {<br>    let name: String<br>    var pet: Pet?<br></p><p>    init(name: String) {<br>        self.name = name<br>    }<br></p><p>    func givePetAway(to someone: Person) {<br>        if pet != nil {<br>            pet!.transferOwnership(to: someone)<br>            //pet!.feed()<br>        }<br>    }<br>}<br>let bert = Person(name: &quot;Bert&quot;)let ernie = Person(name: &quot;Ernie&quot;)var<br>elmo = Pet(name: &quot;Elmo&quot;, owner: nil)<br></p><p>elmo.transferOwnership(to: bert)print(&quot;Bert&#39;s pet is \(bert.pet) -<br>Ernie&#39;s pet is \(ernie.pet)&quot;)<br></p><p>bert.givePetAway(to: ernie)print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s<br>pet is \(ernie.pet)&quot;)<br></p><p>This works as expected, but if you uncomment pet!.feed() in givePetAway(to:)<br>it will crash, because the mutating function modifies the two-way<br>relationship between pet and owner.<br></p><p>In the code I use if pet != nil to demonstrate, in your proposal for unwrap,<br>if I used it to unwrap pet (a value-type, but accessed through self so it<br>can be modified after unwrapping because it’s not nil at the moment) the<br>compiler would assume I could use it and pet.feed() would crash, just as<br>pet!.feed() does now. In your proposal for type narrowing, it would be the<br>same problem. This is like your foo.value example from the proposal.<br></p><p>I don’t think you can get around the fact that the compiler can’t guarantee<br>a type-narrowed or even unwrapped mutable value, which is why if let works<br>as it does with an immutable snapshot.<br></p><p>However, type narrowing for immutable values would still be good.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161110/b768721a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 11, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On 10 Nov 2016, at 21:42, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt; <br>&gt; Consider this code:<br>&gt; <br>&gt; struct Pet {<br>&gt;     let name: String<br>&gt;     weak var owner: Person?<br>&gt; <br>&gt;     init(name: String, owner: Person?) {<br>&gt;         self.name = name<br>&gt;         self.owner = owner<br>&gt;         owner?.pet = self<br>&gt;     }<br>&gt; <br>&gt;     mutating func transferOwnership(to newOwner: Person) {<br>&gt;         let previousOwner = owner<br>&gt;         owner = newOwner<br>&gt;         newOwner.pet = self<br>&gt;         if(previousOwner != nil) {<br>&gt;             previousOwner!.pet = nil<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt;     func feed() {<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; class Person {<br>&gt;     let name: String<br>&gt;     var pet: Pet?<br>&gt; <br>&gt;     init(name: String) {<br>&gt;         self.name = name<br>&gt;     }<br>&gt; <br>&gt;     func givePetAway(to someone: Person) {<br>&gt;         if pet != nil {<br>&gt;             pet!.transferOwnership(to: someone)<br>&gt;             //pet!.feed()<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let bert = Person(name: &quot;Bert&quot;)<br>&gt; let ernie = Person(name: &quot;Ernie&quot;)<br>&gt; var elmo = Pet(name: &quot;Elmo&quot;, owner: nil)<br>&gt; <br>&gt; elmo.transferOwnership(to: bert)<br>&gt; print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt; <br>&gt; bert.givePetAway(to: ernie)<br>&gt; print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt; This works as expected, but if you uncomment pet!.feed() in givePetAway(to:) it will crash, because the mutating function modifies the two-way relationship between pet and owner.<br>&gt; <br>&gt; In the code I use if pet != nil to demonstrate, in your proposal for unwrap, if I used it to unwrap pet (a value-type, but accessed through self so it can be modified after unwrapping because it’s not nil at the moment) the compiler would assume I could use it and pet.feed() would crash, just as pet!.feed() does now. In your proposal for type narrowing, it would be the same problem. This is like your foo.value example from the proposal.<br>&gt; <br>&gt; I don’t think you can get around the fact that the compiler can’t guarantee a type-narrowed or even unwrapped mutable value, which is why if let works as it does with an immutable snapshot.<br>&gt; <br>&gt; However, type narrowing for immutable values would still be good.<br>&gt; <br></p><p>This isn&#39;t a problem of mutability, it&#39;s a problem due to the use of a reference type (Person); this is what the classes and concurrency section is supposed to be describing, but perhaps I haven&#39;t made it clear enough. So in the example you&#39;ve given self.pet can&#39;t be unwrapped because self is a reference type, thus you need to either use force unwrapping either with the unwrap! keyword or direct force unwrapping like you&#39;ve used (since behind the scenes it&#39;s the same thing).<br></p><p>You are right though that the resulting error isn&#39;t necessarily a concurrency issue, so I&#39;ll make a note of this for the proposed new error, and also clarify that the reference type restriction doesn&#39;t just apply to the property itself, but also to whatever it belongs to (and so-on up the chain, so if any part of foo.bar.a.b.c is a reference type it can&#39;t be soft unwrapped).<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/55662cfb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>November 13, 2016 at 02:00:00am</p></header><div class="content"><p>That&#39;s a good point in Jay&#39;s example and from what I can tell a good way to<br>address it, Haravikk.<br></p><p>I&#39;ve done some work in a language that only provides type narrowing for<br>immutable types (that&#39;d be Kotlin as I&#39;ve mentioned before) and whenever<br>I&#39;ve used it it feels like the only thing it&#39;s really been missing is the<br>&quot;if let&quot; construct allowing you to bind and unwrap mutable values, which<br>leads me to think that synergistically, in Swift, this would be fantastic.<br>The main benefit probably is that it would allow code to read much better.<br></p><p>I think the &quot;type stack&quot; phrasing in the proposal is throwing some people<br>for a loop making them think it&#39;ll have way more mental overhead than it<br>actually does in practice...really, in practice, I&#39;ve used this either (a)<br>for checking nullity or (b) for checking for a specific subclass. There&#39;s<br>little to no mental overhead in either of those cases, as your &quot;type stack&quot;<br>is simply 2-long (this was an Int? outside of this conditional block, and<br>it&#39;s an Int inside. This was a UIViewController outside of this conditional<br>block, and it&#39;s a UINavigationController inside.)<br></p><p>While it may not be a panacea that allows new applications that no one<br>could have thought of, I have no doubt that it would greatly improve the<br>experience of coding in the language by, as you said, allowing more<br>flexibility in expressiveness. Regardless of one&#39;s opinion on the efficacy<br>of this feature as a whole, there *are* frequent situations where this<br>feature leads to substantially better-reading code. The &quot;unwrap&quot; keyword<br>proposed in another thread, critically, solves only *half* of the  problems<br>that this proposal solves (as far as I could tell from reading a few emails<br>in the chain, it left the subclass inference completely untouched). Ability<br>to say &quot;if (controller is SongSelectionViewController) {<br>controller.search(for: &quot;mozart&quot;) }&quot; is mentally freeing and helps me stay<br>in coder zen.<br></p><p>IMO, it would effectively be the cream cheese icing on the top of the<br>carrot cake of Swift&#39;s unwrapping and type inference features. A good<br>tasteful cream cheese icing always improves a carrot cake.<br></p><p>The question then becomes, is it really worth the implementation time? This<br>is something that, presumably, someone from the Swift team would need to be<br>involved in answering.<br></p><p>On Fri, Nov 11, 2016 at 10:52 AM Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 10 Nov 2016, at 21:42, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; Consider this code:<br>&gt;<br>&gt; struct Pet {<br>&gt;     let name: String<br>&gt;     weak var owner: Person?<br>&gt;<br>&gt;     init(name: String, owner: Person?) {<br>&gt;         self.name = name<br>&gt;         self.owner = owner<br>&gt;         owner?.pet = self<br>&gt;     }<br>&gt;<br>&gt;     mutating func transferOwnership(to newOwner: Person) {<br>&gt;         let previousOwner = owner<br>&gt;         owner = newOwner<br>&gt;         newOwner.pet = self<br>&gt;         if(previousOwner != nil) {<br>&gt;             previousOwner!.pet = nil<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func feed() {<br>&gt;     }<br>&gt; }<br>&gt; class Person {<br>&gt;     let name: String<br>&gt;     var pet: Pet?<br>&gt;<br>&gt;     init(name: String) {<br>&gt;         self.name = name<br>&gt;     }<br>&gt;<br>&gt;     func givePetAway(to someone: Person) {<br>&gt;         if pet != nil {<br>&gt;             pet!.transferOwnership(to: someone)<br>&gt;             //pet!.feed()<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; let bert = Person(name: &quot;Bert&quot;)let ernie = Person(name: &quot;Ernie&quot;)var elmo = Pet(name: &quot;Elmo&quot;, owner: nil)<br>&gt;<br>&gt; elmo.transferOwnership(to: bert)print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt;<br>&gt; bert.givePetAway(to: ernie)print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt;<br>&gt; This works as expected, but if you uncomment pet!.feed() in<br>&gt; givePetAway(to:) it will crash, because the mutating function modifies<br>&gt; the two-way relationship between pet and owner.<br>&gt;<br>&gt; In the code I use if pet != nil to demonstrate, in your proposal for<br>&gt; unwrap, if I used it to unwrap pet (a value-type, but accessed through<br>&gt; self so it can be modified after unwrapping because it’s not nil at the<br>&gt; moment) the compiler would assume I could use it and pet.feed() would<br>&gt; crash, just as pet!.feed() does now. In your proposal for type narrowing,<br>&gt; it would be the same problem. This is like your foo.value example from<br>&gt; the proposal.<br>&gt;<br>&gt; I don’t think you can get around the fact that the compiler can’t<br>&gt; guarantee a type-narrowed or even unwrapped mutable value, which is why if<br>&gt; let works as it does with an immutable snapshot.<br>&gt;<br>&gt; However, type narrowing for immutable values would still be good.<br>&gt;<br>&gt; This isn&#39;t a problem of mutability, it&#39;s a problem due to the use of a<br>&gt; reference type (Person); this is what the classes and concurrency section<br>&gt; is supposed to be describing, but perhaps I haven&#39;t made it clear enough.<br>&gt; So in the example you&#39;ve given self.pet can&#39;t be unwrapped because self is<br>&gt; a reference type, thus you need to either use force unwrapping either with<br>&gt; the unwrap! keyword or direct force unwrapping like you&#39;ve used (since<br>&gt; behind the scenes it&#39;s the same thing).<br>&gt;<br>&gt; You are right though that the resulting error isn&#39;t necessarily a<br>&gt; concurrency issue, so I&#39;ll make a note of this for the proposed new error,<br>&gt; and also clarify that the reference type restriction doesn&#39;t just apply to<br>&gt; the property itself, but also to whatever it belongs to (and so-on up the<br>&gt; chain, so if any part of foo.bar.a.b.c is a reference type it can&#39;t be soft<br>&gt; unwrapped).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161113/0a346e63/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>November 13, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; Le 13 nov. 2016 à 03:37, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; That&#39;s a good point in Jay&#39;s example and from what I can tell a good way to address it, Haravikk. <br>&gt; <br>&gt; I&#39;ve done some work in a language that only provides type narrowing for immutable types (that&#39;d be Kotlin as I&#39;ve mentioned before) and whenever I&#39;ve used it it feels like the only thing it&#39;s really been missing is the &quot;if let&quot; construct allowing you to bind and unwrap mutable values, which leads me to think that synergistically, in Swift, this would be fantastic. The main benefit probably is that it would allow code to read much better.<br></p><p>IMHO, the Kotlin solution is flaw. The fact that type narrowing does not works for var and that there is no simple way to unwrap optional just force the developer either to introduce local variable, or to use the force unwrap operator.<br>Moreover, introducing a unwrap syntax (if let) like in swift would just result in having 2 different and inconsistent way to do the same thing.<br></p><p>&gt; I think the &quot;type stack&quot; phrasing in the proposal is throwing some people for a loop making them think it&#39;ll have way more mental overhead than it actually does in practice...really, in practice, I&#39;ve used this either (a) for checking nullity or (b) for checking for a specific subclass. There&#39;s little to no mental overhead in either of those cases, as your &quot;type stack&quot; is simply 2-long (this was an Int? outside of this conditional block, and it&#39;s an Int inside. This was a UIViewController outside of this conditional block, and it&#39;s a UINavigationController inside.)<br>&gt; <br>&gt; While it may not be a panacea that allows new applications that no one could have thought of, I have no doubt that it would greatly improve the experience of coding in the language by, as you said, allowing more flexibility in expressiveness. Regardless of one&#39;s opinion on the efficacy of this feature as a whole, there *are* frequent situations where this feature leads to substantially better-reading code. The &quot;unwrap&quot; keyword proposed in another thread, critically, solves only half of the  problems that this proposal solves (as far as I could tell from reading a few emails in the chain, it left the subclass inference completely untouched). Ability to say &quot;if (controller is SongSelectionViewController) { controller.search(for: &quot;mozart&quot;) }&quot; is mentally freeing and helps me stay in coder zen. <br>&gt; <br>&gt; IMO, it would effectively be the cream cheese icing on the top of the carrot cake of Swift&#39;s unwrapping and type inference features. A good tasteful cream cheese icing always improves a carrot cake. <br>&gt; <br>&gt; The question then becomes, is it really worth the implementation time? This is something that, presumably, someone from the Swift team would need to be involved in answering. <br>&gt; <br>&gt; On Fri, Nov 11, 2016 at 10:52 AM Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On 10 Nov 2016, at 21:42, Jay Abbott &lt;jay at abbott.me.uk &lt;mailto:jay at abbott.me.uk&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Consider this code:<br>&gt;&gt; <br>&gt;&gt; struct Pet {<br>&gt;&gt;     let name: String<br>&gt;&gt;     weak var owner: Person?<br>&gt;&gt; <br>&gt;&gt;     init(name: String, owner: Person?) {<br>&gt;&gt;         self.name = name<br>&gt;&gt;         self.owner = owner<br>&gt;&gt;         owner?.pet = self<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     mutating func transferOwnership(to newOwner: Person) {<br>&gt;&gt;         let previousOwner = owner<br>&gt;&gt;         owner = newOwner<br>&gt;&gt;         newOwner.pet = self<br>&gt;&gt;         if(previousOwner != nil) {<br>&gt;&gt;             previousOwner!.pet = nil<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func feed() {<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Person {<br>&gt;&gt;     let name: String<br>&gt;&gt;     var pet: Pet?<br>&gt;&gt; <br>&gt;&gt;     init(name: String) {<br>&gt;&gt;         self.name = name<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     func givePetAway(to someone: Person) {<br>&gt;&gt;         if pet != nil {<br>&gt;&gt;             pet!.transferOwnership(to: someone)<br>&gt;&gt;             //pet!.feed()<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let bert = Person(name: &quot;Bert&quot;)<br>&gt;&gt; let ernie = Person(name: &quot;Ernie&quot;)<br>&gt;&gt; var elmo = Pet(name: &quot;Elmo&quot;, owner: nil)<br>&gt;&gt; <br>&gt;&gt; elmo.transferOwnership(to: bert)<br>&gt;&gt; print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt;&gt; <br>&gt;&gt; bert.givePetAway(to: ernie)<br>&gt;&gt; print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt;&gt; This works as expected, but if you uncomment pet!.feed() in givePetAway(to:) it will crash, because the mutating function modifies the two-way relationship between pet and owner.<br>&gt;&gt; <br>&gt;&gt; In the code I use if pet != nil to demonstrate, in your proposal for unwrap, if I used it to unwrap pet (a value-type, but accessed through self so it can be modified after unwrapping because it’s not nil at the moment) the compiler would assume I could use it and pet.feed() would crash, just as pet!.feed() does now. In your proposal for type narrowing, it would be the same problem. This is like your foo.value example from the proposal.<br>&gt;&gt; <br>&gt;&gt; I don’t think you can get around the fact that the compiler can’t guarantee a type-narrowed or even unwrapped mutable value, which is why if let works as it does with an immutable snapshot.<br>&gt;&gt; <br>&gt;&gt; However, type narrowing for immutable values would still be good.<br>&gt;&gt; <br>&gt; <br>&gt; This isn&#39;t a problem of mutability, it&#39;s a problem due to the use of a reference type (Person); this is what the classes and concurrency section is supposed to be describing, but perhaps I haven&#39;t made it clear enough. So in the example you&#39;ve given self.pet can&#39;t be unwrapped because self is a reference type, thus you need to either use force unwrapping either with the unwrap! keyword or direct force unwrapping like you&#39;ve used (since behind the scenes it&#39;s the same thing).<br>&gt; <br>&gt; You are right though that the resulting error isn&#39;t necessarily a concurrency issue, so I&#39;ll make a note of this for the proposed new error, and also clarify that the reference type restriction doesn&#39;t just apply to the property itself, but also to whatever it belongs to (and so-on up the chain, so if any part of foo.bar.a.b.c is a reference type it can&#39;t be soft unwrapped).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161113/bde58d33/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4de621aec7ff90a03f5b9b21e790bc66?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Dennis Lysenko</string> &lt;dennis.s.lysenko at gmail.com&gt;<p>November 14, 2016 at 02:00:00am</p></header><div class="content"><p>Jean-Daniel, I agree with the first part of your assessment fully, which in<br>my opinion is actually why I think the Kotlin style combined with the Swift<br>style would pull in the best of both worlds and create a complete solution.<br>I do share some of your reservation in the second part of your assessment,<br>which is why I&#39;m a little hesitant on the proposal, but as I&#39;ve described<br>before I think it would help expressiveness.<br></p><p>On Sun, Nov 13, 2016 at 11:16 AM Jean-Daniel &lt;dev at xenonium.com&gt; wrote:<br></p><p>&gt; Le 13 nov. 2016 à 03:37, Dennis Lysenko via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt; That&#39;s a good point in Jay&#39;s example and from what I can tell a good way<br>&gt; to address it, Haravikk.<br>&gt;<br>&gt; I&#39;ve done some work in a language that only provides type narrowing for<br>&gt; immutable types (that&#39;d be Kotlin as I&#39;ve mentioned before) and whenever<br>&gt; I&#39;ve used it it feels like the only thing it&#39;s really been missing is the<br>&gt; &quot;if let&quot; construct allowing you to bind and unwrap mutable values, which<br>&gt; leads me to think that synergistically, in Swift, this would be fantastic.<br>&gt; The main benefit probably is that it would allow code to read much better.<br>&gt;<br>&gt;<br>&gt; IMHO, the Kotlin solution is flaw. The fact that type narrowing does not<br>&gt; works for var and that there is no simple way to unwrap optional just force<br>&gt; the developer either to introduce local variable, or to use the force<br>&gt; unwrap operator.<br>&gt; Moreover, introducing a unwrap syntax (if let) like in swift would just<br>&gt; result in having 2 different and inconsistent way to do the same thing.<br>&gt;<br>&gt; I think the &quot;type stack&quot; phrasing in the proposal is throwing some people<br>&gt; for a loop making them think it&#39;ll have way more mental overhead than it<br>&gt; actually does in practice...really, in practice, I&#39;ve used this either (a)<br>&gt; for checking nullity or (b) for checking for a specific subclass. There&#39;s<br>&gt; little to no mental overhead in either of those cases, as your &quot;type stack&quot;<br>&gt; is simply 2-long (this was an Int? outside of this conditional block, and<br>&gt; it&#39;s an Int inside. This was a UIViewController outside of this conditional<br>&gt; block, and it&#39;s a UINavigationController inside.)<br>&gt;<br>&gt; While it may not be a panacea that allows new applications that no one<br>&gt; could have thought of, I have no doubt that it would greatly improve the<br>&gt; experience of coding in the language by, as you said, allowing more<br>&gt; flexibility in expressiveness. Regardless of one&#39;s opinion on the efficacy<br>&gt; of this feature as a whole, there *are* frequent situations where this<br>&gt; feature leads to substantially better-reading code. The &quot;unwrap&quot; keyword<br>&gt; proposed in another thread, critically, solves only *half* of the<br>&gt;  problems that this proposal solves (as far as I could tell from reading a<br>&gt; few emails in the chain, it left the subclass inference completely<br>&gt; untouched). Ability to say &quot;if (controller is SongSelectionViewController)<br>&gt; { controller.search(for: &quot;mozart&quot;) }&quot; is mentally freeing and helps me stay<br>&gt; in coder zen.<br>&gt;<br>&gt; IMO, it would effectively be the cream cheese icing on the top of the<br>&gt; carrot cake of Swift&#39;s unwrapping and type inference features. A good<br>&gt; tasteful cream cheese icing always improves a carrot cake.<br>&gt;<br>&gt; The question then becomes, is it really worth the implementation time?<br>&gt; This is something that, presumably, someone from the Swift team would need<br>&gt; to be involved in answering.<br>&gt;<br>&gt; On Fri, Nov 11, 2016 at 10:52 AM Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 10 Nov 2016, at 21:42, Jay Abbott &lt;jay at abbott.me.uk&gt; wrote:<br>&gt;<br>&gt; Consider this code:<br>&gt;<br>&gt; struct Pet {<br>&gt;     let name: String<br>&gt;     weak var owner: Person?<br>&gt;<br>&gt;     init(name: String, owner: Person?) {<br>&gt;         self.name = name<br>&gt;         self.owner = owner<br>&gt;         owner?.pet = self<br>&gt;     }<br>&gt;<br>&gt;     mutating func transferOwnership(to newOwner: Person) {<br>&gt;         let previousOwner = owner<br>&gt;         owner = newOwner<br>&gt;         newOwner.pet = self<br>&gt;         if(previousOwner != nil) {<br>&gt;             previousOwner!.pet = nil<br>&gt;         }<br>&gt;     }<br>&gt;<br>&gt;     func feed() {<br>&gt;     }<br>&gt; }<br>&gt; class Person {<br>&gt;     let name: String<br>&gt;     var pet: Pet?<br>&gt;<br>&gt;     init(name: String) {<br>&gt;         self.name = name<br>&gt;     }<br>&gt;<br>&gt;     func givePetAway(to someone: Person) {<br>&gt;         if pet != nil {<br>&gt;             pet!.transferOwnership(to: someone)<br>&gt;             //pet!.feed()<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; let bert = Person(name: &quot;Bert&quot;)let ernie = Person(name: &quot;Ernie&quot;)var elmo = Pet(name: &quot;Elmo&quot;, owner: nil)<br>&gt;<br>&gt; elmo.transferOwnership(to: bert)print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt;<br>&gt; bert.givePetAway(to: ernie)print(&quot;Bert&#39;s pet is \(bert.pet) - Ernie&#39;s pet is \(ernie.pet)&quot;)<br>&gt;<br>&gt; This works as expected, but if you uncomment pet!.feed() in<br>&gt; givePetAway(to:) it will crash, because the mutating function modifies<br>&gt; the two-way relationship between pet and owner.<br>&gt;<br>&gt; In the code I use if pet != nil to demonstrate, in your proposal for<br>&gt; unwrap, if I used it to unwrap pet (a value-type, but accessed through<br>&gt; self so it can be modified after unwrapping because it’s not nil at the<br>&gt; moment) the compiler would assume I could use it and pet.feed() would<br>&gt; crash, just as pet!.feed() does now. In your proposal for type narrowing,<br>&gt; it would be the same problem. This is like your foo.value example from<br>&gt; the proposal.<br>&gt;<br>&gt; I don’t think you can get around the fact that the compiler can’t<br>&gt; guarantee a type-narrowed or even unwrapped mutable value, which is why if<br>&gt; let works as it does with an immutable snapshot.<br>&gt;<br>&gt; However, type narrowing for immutable values would still be good.<br>&gt;<br>&gt; This isn&#39;t a problem of mutability, it&#39;s a problem due to the use of a<br>&gt; reference type (Person); this is what the classes and concurrency section<br>&gt; is supposed to be describing, but perhaps I haven&#39;t made it clear enough.<br>&gt; So in the example you&#39;ve given self.pet can&#39;t be unwrapped because self is<br>&gt; a reference type, thus you need to either use force unwrapping either with<br>&gt; the unwrap! keyword or direct force unwrapping like you&#39;ve used (since<br>&gt; behind the scenes it&#39;s the same thing).<br>&gt;<br>&gt; You are right though that the resulting error isn&#39;t necessarily a<br>&gt; concurrency issue, so I&#39;ll make a note of this for the proposed new error,<br>&gt; and also clarify that the reference type restriction doesn&#39;t just apply to<br>&gt; the property itself, but also to whatever it belongs to (and so-on up the<br>&gt; chain, so if any part of foo.bar.a.b.c is a reference type it can&#39;t be soft<br>&gt; unwrapped).<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/85dc3966/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 14, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On 13 Nov 2016, at 16:16, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Le 13 nov. 2016 à 03:37, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; That&#39;s a good point in Jay&#39;s example and from what I can tell a good way to address it, Haravikk. <br>&gt;&gt; <br>&gt;&gt; I&#39;ve done some work in a language that only provides type narrowing for immutable types (that&#39;d be Kotlin as I&#39;ve mentioned before) and whenever I&#39;ve used it it feels like the only thing it&#39;s really been missing is the &quot;if let&quot; construct allowing you to bind and unwrap mutable values, which leads me to think that synergistically, in Swift, this would be fantastic. The main benefit probably is that it would allow code to read much better.<br>&gt; <br>&gt; IMHO, the Kotlin solution is flaw. The fact that type narrowing does not works for var and that there is no simple way to unwrap optional just force the developer either to introduce local variable, or to use the force unwrap operator.<br>&gt; Moreover, introducing a unwrap syntax (if let) like in swift would just result in having 2 different and inconsistent way to do the same thing.<br></p><p>I&#39;ll have to take a closer look at how Kotlin does this when I get a chance, but how would this affect the two proposals as they currently stand?<br></p><p>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md<br>https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md<br></p><p>These keep automatic narrowing of polymorphic types, but requires explicit narrow/unwrapping of optionals (because we can define methods/properties on Optional there&#39;s no other choice unfortunately); it would work for both mutable and immutable values, but mutable reference types require an extra step due to the potential for unsafe operations.<br></p><p>I think that&#39;s about as flexible as we&#39;re going to be able to get without introducing other difficulties.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161114/da1644cc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0f5f87c6d6b2f41c3ac647171eb30e34?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Jean-Daniel</string> &lt;dev at xenonium.com&gt;<p>November 15, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Le 14 nov. 2016 à 10:10, Haravikk &lt;swift-evolution at haravikk.me&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 13 Nov 2016, at 16:16, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Le 13 nov. 2016 à 03:37, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s a good point in Jay&#39;s example and from what I can tell a good way to address it, Haravikk. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;ve done some work in a language that only provides type narrowing for immutable types (that&#39;d be Kotlin as I&#39;ve mentioned before) and whenever I&#39;ve used it it feels like the only thing it&#39;s really been missing is the &quot;if let&quot; construct allowing you to bind and unwrap mutable values, which leads me to think that synergistically, in Swift, this would be fantastic. The main benefit probably is that it would allow code to read much better.<br>&gt;&gt; <br>&gt;&gt; IMHO, the Kotlin solution is flaw. The fact that type narrowing does not works for var and that there is no simple way to unwrap optional just force the developer either to introduce local variable, or to use the force unwrap operator.<br>&gt;&gt; Moreover, introducing a unwrap syntax (if let) like in swift would just result in having 2 different and inconsistent way to do the same thing.<br>&gt; <br>&gt; I&#39;ll have to take a closer look at how Kotlin does this when I get a chance, but how would this affect the two proposals as they currently stand?<br>&gt; <br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md&gt;<br>&gt; <br>&gt; These keep automatic narrowing of polymorphic types, but requires explicit narrow/unwrapping of optionals (because we can define methods/properties on Optional there&#39;s no other choice unfortunately); it would work for both mutable and immutable values, but mutable reference types require an extra step due to the potential for unsafe operations.<br>&gt; <br>&gt; I think that&#39;s about as flexible as we&#39;re going to be able to get without introducing other difficulties.<br></p><p>While the proposals try to be less restrictive than Kotlin, I don’t like the way they handle concurrency.<br>All usage of the ‘!’ operator in swift guarantee a crash at the call site if something is wrong (try!, as!, optional!, …). In the proposals, the ‘!’ operator means that the app may crash at call site or may crash later.<br></p><p><br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/99a31481/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 15, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 15 Nov 2016, at 07:19, Jean-Daniel &lt;dev at xenonium.com&gt; wrote:<br>&gt;&gt; Le 14 nov. 2016 à 10:10, Haravikk &lt;swift-evolution at haravikk.me &lt;mailto:swift-evolution at haravikk.me&gt;&gt; a écrit :<br>&gt;&gt;&gt; On 13 Nov 2016, at 16:16, Jean-Daniel via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; Le 13 nov. 2016 à 03:37, Dennis Lysenko via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s a good point in Jay&#39;s example and from what I can tell a good way to address it, Haravikk. <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;ve done some work in a language that only provides type narrowing for immutable types (that&#39;d be Kotlin as I&#39;ve mentioned before) and whenever I&#39;ve used it it feels like the only thing it&#39;s really been missing is the &quot;if let&quot; construct allowing you to bind and unwrap mutable values, which leads me to think that synergistically, in Swift, this would be fantastic. The main benefit probably is that it would allow code to read much better.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO, the Kotlin solution is flaw. The fact that type narrowing does not works for var and that there is no simple way to unwrap optional just force the developer either to introduce local variable, or to use the force unwrap operator.<br>&gt;&gt;&gt; Moreover, introducing a unwrap syntax (if let) like in swift would just result in having 2 different and inconsistent way to do the same thing.<br>&gt;&gt; <br>&gt;&gt; I&#39;ll have to take a closer look at how Kotlin does this when I get a chance, but how would this affect the two proposals as they currently stand?<br>&gt;&gt; <br>&gt;&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-type-narrowing.md&gt;<br>&gt;&gt; https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md &lt;https://github.com/Haravikk/swift-evolution/blob/master/proposals/NNNN-optional-unwrapping.md&gt;<br>&gt;&gt; <br>&gt;&gt; These keep automatic narrowing of polymorphic types, but requires explicit narrow/unwrapping of optionals (because we can define methods/properties on Optional there&#39;s no other choice unfortunately); it would work for both mutable and immutable values, but mutable reference types require an extra step due to the potential for unsafe operations.<br>&gt;&gt; <br>&gt;&gt; I think that&#39;s about as flexible as we&#39;re going to be able to get without introducing other difficulties.<br>&gt; <br>&gt; While the proposals try to be less restrictive than Kotlin, I don’t like the way they handle concurrency.<br>&gt; All usage of the ‘!’ operator in swift guarantee a crash at the call site if something is wrong (try!, as!, optional!, …). In the proposals, the ‘!’ operator means that the app may crash at call site or may crash later.<br></p><p>The error should still be associated with the line that actually failed, the only difference here is that the type-checking or force-unwrapping is handled for you behind the scenes, as you&#39;ve opted into it for that scope by forcing the unwrap/narrowing to occur. Put another way; when you force unwrap/narrow a reference type, it is treated like an implicitly unwrapped Optional or implicitly narrowed type, so is checked for correctness as necessary.<br></p><p>Since narrowing/unwrapping has (sort of) occurred, we can produce an error that better highlights the problem, e.g- &quot;Force unwrapped reference was set to nil by another method or thread&quot;, as the unwrap/narrowing functionality ensures that you can&#39;t do it in the current scope without it being detected. The error that requires you to use force unwrapping/narrowing can likewise be more specific, e.g- &quot;Reference type foo cannot be unwrapped/narrowed safely&quot; (I suck at writing error messages btw), the idea being to encourage developers to consider why and decide for themselves whether it&#39;s better to force the unwrap/narrowing (because they&#39;re confident it will work) or to instead work with a copy and put it back later, use locking etc. etc.<br></p><p>The only other component is an attribute to indicate when a reference is safe; I&#39;m favouring something like @concurrency(safe), but the difficulty is whether it&#39;s enough to just indicate this or if it also needs to be enforced somehow. I might use the attribute for example on a property I know will be used in a copy-on-write style, but is it feasible to enforce that, perhaps with some kind of behaviour similar to no-escape? It becomes tough to consider every possible case for something like that, and it&#39;d probably need some other supporting features, like a @copy attribute for return types so we can account for methods methods that produce a new copy of an instance (e.g- if your return type has the @copy attribute then it can&#39;t return self). It&#39;s probably more of a separate proposal though for how we&#39;ll handle concurrency and reference types natively.<br></p><p>Little bit off track there, but the short version is; forcing the unwrap/narrowing doesn&#39;t make your code any more or less safe for references, it just removes the need for force-unwrap or type check everything manually.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161115/16c13456/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>[Proposal] Type Narrowing</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November  7, 2016 at 12:00:00pm</p></header><div class="content"><p>The more I think about it, the more I realize what I actually want is an<br>“alias” or “view” or “lens” that will let me give a new name to an existing<br>entity, without copying or moving it.<br></p><p>This is useful in general if you need to work “down the rabbit hole”, so<br>you could write something like:<br></p><p>alias size = anArray[idx].someProperty.size<br>// Work with “size” as a shorthand, including mutations<br></p><p>In the situation from my previous example, where we only want to take<br>action when the nested property is a certain type, it might look like:<br></p><p>if alias b = c.a as? B {<br>    b.x = 12<br>}<br></p><p>I think this sort of feature is far more versatile than type-narrowing, and<br>it retains the clarity of type information in source code.<br></p><p>Nevin<br></p><p><br>On Sun, Nov 6, 2016 at 10:52 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Nov 3, 2016, at 10:04 AM, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; To avoid hijacking the guard let x = x thread entirely I&#39;ve decided to<br>&gt; try to write up a proposal on type narrowing in Swift.<br>&gt; &gt; Please give your feedback on the functionality proposed, as well as the<br>&gt; clarity of the proposal/examples themselves; I&#39;ve tried to keep it<br>&gt; straightforward, but I do tend towards being overly verbose, I&#39;ve always<br>&gt; tried to have the examples build upon one another to show how it all stacks<br>&gt; up.<br>&gt;<br>&gt; FWIW, we have specifically considered something like this proposal in the<br>&gt; past.  You didn’t mention it, but the ?: operator is a specific example<br>&gt; that frequently comes up.  People often expect to be able to do something<br>&gt; like:<br>&gt;<br>&gt;         … = foo is B ? foo.bMethod() : …<br>&gt;<br>&gt; which is the same sort of flow sensitive type refinement as you’re<br>&gt; proposing here.  This topic also came up in the design discussion around<br>&gt; #available (which shipped in Swift 2, but was discussed much earlier),<br>&gt; because unavailable decls could be available as optionals when not<br>&gt; specifically checked for.<br>&gt;<br>&gt; This is just MHO, but while I have been in favor of this in the (distant)<br>&gt; past, I became convinced that this would be a bad idea when it comes to<br>&gt; code maintenance over the long term.  With our current (intentional<br>&gt; shadowing based) design, you can always jump to the definition of a value<br>&gt; to see where it was defined, and definitions always specify a type.<br>&gt; Introducing flow senstitive type refinement breaks this model because the<br>&gt; type of a decl depends not just on its declaration, but on a potentially<br>&gt; arbitrary number of imperative checks that occur between the declaration<br>&gt; and the use.  This can make it much more difficult to understand code.<br>&gt;<br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161107/fec07a9e/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
