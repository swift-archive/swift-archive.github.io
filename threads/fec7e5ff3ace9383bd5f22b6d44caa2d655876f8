<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/64e7c3f106cb83b50891f5dcccde198b?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>Joe Pamer</string> &lt;jpamer at apple.com&gt;<p>April 18, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi everyone,<br></p><p>Prior to Swift 1.2, conversions between bridged Swift value types and their associated Objective-C types could be implicitly inferred in both directions. For example, you could pass an NSString object to a function expecting a String value, and vice versa.<br></p><p>In time we found this model to be less than perfect for a variety of reasons:<br>Allowing implicit conversions between types that lack a subtype relationship felt wrong in the context of our type system.<br>Importing Foundation would lead to subtle changes in how seemingly simple bodies of code were type checked.<br>The specific rules implemented by the compiler to support implicit bridging conversions were complex and ad-hoc.<br>Looking at the Swift code that had been written up until 1.2, these kinds of implicit conversions did not appear terribly common. (And where they were present, it wasn’t clear if users actually knew they were taking place.)<br></p><p>In short, these conversions generally lead to a more confusing and unpredictable user model. So, for Swift 1.2, we sought to eliminate implicit bridging conversions entirely, and instead direct users to use explicit bridging casts in their place. (E.g., “nsStrObj as String”.)<br></p><p>Unfortunately, when it came time to roll out these changes, we noticed that some native Objective-C APIs were now more difficult to work with in Swift 1.2. Specifically, because global Objective-C NSString* constants are imported into Swift as having type String, APIs that relied on string-constant lookups into dictionaries imported as [NSObject : AnyObject] failed to compile. E.g.<br></p><p>var s : NSAttributedString<br>let SomeNSFontAttributeName : String // As per the importer.<br></p><p>let attrs = s.attributesAtIndex(0, effectiveRange:nil) // In Swift 2, ‘attrs’ has type [NSObject : AnyObject]<br>let fontName = attrs[SomeNSFontAttributeName] // This will fail to compile without an implicit conversion from String to NSString.<br></p><p>For this reason, we decided to make a compromise. We would require explicit bridging casts when converting from a bridged Objective-C type to its associated Swift value type (E.g., NSString -&gt; String), but not the other way around. This would improve the status quo somewhat, and would also avoid breaking user code in a needless/painful fashion until we could get better API annotations in place.<br></p><p>With the introduction of Objective-C generics last year, along with all of the awesome improvements to API importing happening for Swift 3, I think it’s time that we take another look at completing this work. Taking a look back at last year’s “problematic” APIs, all of them now surface richer type information when imported into Swift 3. As a result, the remaining implicit bridging conversions now feel far less necessary, since Objective-C APIs are now more commonly exposed in terms of their appropriate bridged Swift value types. (For instance, in Swift 3, the above reference to attrs will import as [String : AnyObject].)<br></p><p>I propose that we fully eliminate implicit bridging conversions in Swift 3. This would mean that some users might have to introduce introduce a few more ‘as’ casts in their code, but we would remove another special case from Swift&#39;s type system  and be able to further simplify the compiler. If anyone is curious and would like to take this model for a spin, I’ve pushed an experimental branch that implements this proposed change, inhibit-implicit-conversions.<br></p><p>Thoughts?<br></p><p>Thanks!<br>- Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/fec776f8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>April 18, 2016 at 10:00:00pm</p></header><div class="content"><p>Is it true that some CF APIs, such as these, are still imported as CFString<br>instead of String?<br></p><p>https://github.com/apple/swift-3-api-guidelines-review/blob/swift-3/Platforms/OSX/CoreText/CTFontTraits.swift#L2-L9<br></p><p>On Mon, Apr 18, 2016 at 8:21 PM, Joe Pamer via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hi everyone,<br>&gt;<br>&gt; Prior to Swift 1.2, conversions between bridged Swift value types and<br>&gt; their associated Objective-C types could be implicitly inferred in both<br>&gt; directions. For example, you could pass an NSString object to a function<br>&gt; expecting a String value, and vice versa.<br>&gt;<br>&gt; In time we found this model to be less than perfect for a variety of<br>&gt; reasons:<br>&gt;<br>&gt;    - Allowing implicit conversions between types that lack a subtype<br>&gt;    relationship felt wrong in the context of our type system.<br>&gt;    - Importing Foundation would lead to subtle changes in how seemingly<br>&gt;    simple bodies of code were type checked.<br>&gt;    - The specific rules implemented by the compiler to support implicit<br>&gt;    bridging conversions were complex and ad-hoc.<br>&gt;    - Looking at the Swift code that had been written up until 1.2, these<br>&gt;    kinds of implicit conversions did not appear terribly common. (And where<br>&gt;    they *were* present, it wasn’t clear if users actually knew they were<br>&gt;    taking place.)<br>&gt;<br>&gt;<br>&gt; In short, these conversions generally lead to a more confusing and<br>&gt; unpredictable user model. So, for Swift 1.2, we sought to eliminate<br>&gt; implicit bridging conversions entirely, and instead direct users to use<br>&gt; explicit bridging casts in their place. (E.g., “nsStrObj as String”.)<br>&gt;<br>&gt; Unfortunately, when it came time to roll out these changes, we noticed<br>&gt; that some native Objective-C APIs were now more difficult to work with in<br>&gt; Swift 1.2. Specifically, because global Objective-C NSString* constants<br>&gt; are imported into Swift as having type String, APIs that relied on<br>&gt; string-constant lookups into dictionaries imported as [NSObject :<br>&gt; AnyObject] failed to compile. E.g.<br>&gt;<br>&gt; var s : NSAttributedString<br>&gt; let SomeNSFontAttributeName : String // As per the importer.<br>&gt;<br>&gt; let attrs = s.attributesAtIndex(0, effectiveRange:nil) // In Swift 2,<br>&gt; ‘attrs’ has type [NSObject : AnyObject]<br>&gt; let fontName = attrs[SomeNSFontAttributeName] // This will fail to compile<br>&gt; without an implicit conversion from String to NSString.<br>&gt;<br>&gt; For this reason, we decided to make a compromise. We would require<br>&gt; explicit bridging casts when converting from a bridged Objective-C type to<br>&gt; its associated Swift value type (E.g., NSString -&gt; String), but not the<br>&gt; other way around. This would improve the status quo somewhat, and would<br>&gt; also avoid breaking user code in a needless/painful fashion until we could<br>&gt; get better API annotations in place.<br>&gt;<br>&gt; With the introduction of Objective-C generics last year, along with all of<br>&gt; the awesome improvements to API importing happening for Swift 3, I think<br>&gt; it’s time that we take another look at completing this work. Taking a look<br>&gt; back at last year’s “problematic” APIs, all of them now surface richer type<br>&gt; information when imported into Swift 3. As a result, the remaining implicit<br>&gt; bridging conversions now feel far less necessary, since Objective-C APIs<br>&gt; are now more commonly exposed in terms of their appropriate bridged Swift<br>&gt; value types. (For instance, in Swift 3, the above reference to attrs will<br>&gt; import as [String : AnyObject].)<br>&gt;<br>&gt; I propose that we fully eliminate implicit bridging conversions in Swift<br>&gt; 3. This would mean that some users might have to introduce introduce a few<br>&gt; more ‘as’ casts in their code, but we would remove another special case<br>&gt; from Swift&#39;s type system  and be able to further simplify the compiler. If<br>&gt; anyone is curious and would like to take this model for a spin, I’ve pushed<br>&gt; an experimental branch that implements this proposed change,<br>&gt; inhibit-implicit-conversions.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Thanks!<br>&gt; - Joe<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160418/14fd322a/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>April 19, 2016 at 03:00:00pm</p></header><div class="content"><p>I fully support this proposal. IMO we should be moving forward and improve <br>Swift, separate it from ObjC and explicitly bridge when needed.<br></p><p>On 19.04.2016 6:21, Joe Pamer via swift-evolution wrote:<br>&gt; Hi everyone,<br>&gt;<br>&gt; Prior to Swift 1.2, conversions between bridged Swift value types and their<br>&gt; associated Objective-C types could be implicitly inferred in both<br>&gt; directions. For example, you could pass an NSString object to a function<br>&gt; expecting a String value, and vice versa.<br>&gt;<br>&gt; In time we found this model to be less than perfect for a variety of reasons:<br>&gt;<br>&gt;   * Allowing implicit conversions between types that lack a subtype<br>&gt;     relationship felt wrong in the context of our type system.<br>&gt;   * Importing Foundation would lead to subtle changes in how seemingly<br>&gt;     simple bodies of code were type checked.<br>&gt;   * The specific rules implemented by the compiler to support implicit<br>&gt;     bridging conversions were complex and ad-hoc.<br>&gt;   * Looking at the Swift code that had been written up until 1.2, these<br>&gt;     kinds of implicit conversions did not appear terribly common. (And<br>&gt;     where they /were/ present, it wasn’t clear if users actually knew they<br>&gt;     were taking place.)<br>&gt;<br>&gt;<br>&gt; In short, these conversions generally lead to a more confusing and<br>&gt; unpredictable user model. So, for Swift 1.2, we sought to eliminate<br>&gt; implicit bridging conversions entirely, and instead direct users to use<br>&gt; explicit bridging casts in their place. (E.g., “nsStrObj as String”.)<br>&gt;<br>&gt; Unfortunately, when it came time to roll out these changes, we noticed that<br>&gt; some native Objective-C APIs were now more difficult to work with in Swift<br>&gt; 1.2. Specifically, because global Objective-C NSString* constants are<br>&gt; imported into Swift as having type String, APIs that relied on<br>&gt; string-constant lookups into dictionaries imported as [NSObject :<br>&gt; AnyObject] failed to compile. E.g.<br>&gt;<br>&gt;     var s : NSAttributedString<br>&gt;     let SomeNSFontAttributeName : String // As per the importer.<br>&gt;<br>&gt;     let attrs = s.attributesAtIndex(0, effectiveRange:nil) // In Swift 2,<br>&gt;     ‘attrs’ has type [NSObject : AnyObject]<br>&gt;     let fontName = attrs[SomeNSFontAttributeName] // This will fail to<br>&gt;     compile without an implicit conversion from String to NSString.<br>&gt;<br>&gt; For this reason, we decided to make a compromise. We would require explicit<br>&gt; bridging casts when converting from a bridged Objective-C type to its<br>&gt; associated Swift value type (E.g., NSString -&gt; String), but not the other<br>&gt; way around. This would improve the status quo somewhat, and would also<br>&gt; avoid breaking user code in a needless/painful fashion until we could get<br>&gt; better API annotations in place.<br>&gt;<br>&gt; With the introduction of Objective-C generics last year, along with all of<br>&gt; the awesome improvements to API importing happening for Swift 3, I think<br>&gt; it’s time that we take another look at completing this work. Taking a look<br>&gt; back at last year’s “problematic” APIs, all of them now surface richer type<br>&gt; information when imported into Swift 3. As a result, the remaining implicit<br>&gt; bridging conversions now feel far less necessary, since Objective-C APIs<br>&gt; are now more commonly exposed in terms of their appropriate bridged Swift<br>&gt; value types. (For instance, in Swift 3, the above reference to attrs will<br>&gt; import as [String : AnyObject].)<br>&gt;<br>&gt; I propose that we fully eliminate implicit bridging conversions in Swift 3.<br>&gt; This would mean that some users might have to introduce introduce a few<br>&gt; more ‘as’ casts in their code, but we would remove another special case<br>&gt; from Swift&#39;s type system  and be able to further simplify the compiler. If<br>&gt; anyone is curious and would like to take this model for a spin, I’ve pushed<br>&gt; an experimental branch that implements this proposed<br>&gt; change, inhibit-implicit-conversions.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Thanks!<br>&gt; - Joe<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 19, 2016 at 01:00:00pm</p></header><div class="content"><p>+1 from me; I’ve been dealing with a lot of conversion and yet it’s still pretty confusing largely because of the implicit conversions, it also goes against (pure) Swift’s elegant yet strictly typed checking system.<br></p><p>&gt; On 19 Apr 2016, at 04:21, Joe Pamer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi everyone,<br>&gt; <br>&gt; Prior to Swift 1.2, conversions between bridged Swift value types and their associated Objective-C types could be implicitly inferred in both directions. For example, you could pass an NSString object to a function expecting a String value, and vice versa.<br>&gt; <br>&gt; In time we found this model to be less than perfect for a variety of reasons:<br>&gt; Allowing implicit conversions between types that lack a subtype relationship felt wrong in the context of our type system.<br>&gt; Importing Foundation would lead to subtle changes in how seemingly simple bodies of code were type checked.<br>&gt; The specific rules implemented by the compiler to support implicit bridging conversions were complex and ad-hoc.<br>&gt; Looking at the Swift code that had been written up until 1.2, these kinds of implicit conversions did not appear terribly common. (And where they were present, it wasn’t clear if users actually knew they were taking place.)<br>&gt; <br>&gt; In short, these conversions generally lead to a more confusing and unpredictable user model. So, for Swift 1.2, we sought to eliminate implicit bridging conversions entirely, and instead direct users to use explicit bridging casts in their place. (E.g., “nsStrObj as String”.)<br>&gt; <br>&gt; Unfortunately, when it came time to roll out these changes, we noticed that some native Objective-C APIs were now more difficult to work with in Swift 1.2. Specifically, because global Objective-C NSString* constants are imported into Swift as having type String, APIs that relied on string-constant lookups into dictionaries imported as [NSObject : AnyObject] failed to compile. E.g.<br>&gt; <br>&gt; var s : NSAttributedString<br>&gt; let SomeNSFontAttributeName : String // As per the importer.<br>&gt; <br>&gt; let attrs = s.attributesAtIndex(0, effectiveRange:nil) // In Swift 2, ‘attrs’ has type [NSObject : AnyObject]<br>&gt; let fontName = attrs[SomeNSFontAttributeName] // This will fail to compile without an implicit conversion from String to NSString.<br>&gt; <br>&gt; For this reason, we decided to make a compromise. We would require explicit bridging casts when converting from a bridged Objective-C type to its associated Swift value type (E.g., NSString -&gt; String), but not the other way around. This would improve the status quo somewhat, and would also avoid breaking user code in a needless/painful fashion until we could get better API annotations in place.<br>&gt; <br>&gt; With the introduction of Objective-C generics last year, along with all of the awesome improvements to API importing happening for Swift 3, I think it’s time that we take another look at completing this work. Taking a look back at last year’s “problematic” APIs, all of them now surface richer type information when imported into Swift 3. As a result, the remaining implicit bridging conversions now feel far less necessary, since Objective-C APIs are now more commonly exposed in terms of their appropriate bridged Swift value types. (For instance, in Swift 3, the above reference to attrs will import as [String : AnyObject].)<br>&gt; <br>&gt; I propose that we fully eliminate implicit bridging conversions in Swift 3. This would mean that some users might have to introduce introduce a few more ‘as’ casts in their code, but we would remove another special case from Swift&#39;s type system  and be able to further simplify the compiler. If anyone is curious and would like to take this model for a spin, I’ve pushed an experimental branch that implements this proposed change, inhibit-implicit-conversions.<br>&gt; <br>&gt; Thoughts?<br>&gt; <br>&gt; Thanks!<br>&gt; - Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/b05bb42b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8083ad16248b8c031cc10d44f47aa442?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>T.J. Usiyan</string> &lt;griotspeak at gmail.com&gt;<p>April 19, 2016 at 09:00:00am</p></header><div class="content"><p>+1 from me<br></p><p>On Tue, Apr 19, 2016 at 8:42 AM, Haravikk via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; +1 from me; I’ve been dealing with a lot of conversion and yet it’s still<br>&gt; pretty confusing largely because of the implicit conversions, it also goes<br>&gt; against (pure) Swift’s elegant yet strictly typed checking system.<br>&gt;<br>&gt; On 19 Apr 2016, at 04:21, Joe Pamer via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Hi everyone,<br>&gt;<br>&gt; Prior to Swift 1.2, conversions between bridged Swift value types and<br>&gt; their associated Objective-C types could be implicitly inferred in both<br>&gt; directions. For example, you could pass an NSString object to a function<br>&gt; expecting a String value, and vice versa.<br>&gt;<br>&gt; In time we found this model to be less than perfect for a variety of<br>&gt; reasons:<br>&gt;<br>&gt;    - Allowing implicit conversions between types that lack a subtype<br>&gt;    relationship felt wrong in the context of our type system.<br>&gt;    - Importing Foundation would lead to subtle changes in how seemingly<br>&gt;    simple bodies of code were type checked.<br>&gt;    - The specific rules implemented by the compiler to support implicit<br>&gt;    bridging conversions were complex and ad-hoc.<br>&gt;    - Looking at the Swift code that had been written up until 1.2, these<br>&gt;    kinds of implicit conversions did not appear terribly common. (And where<br>&gt;    they *were* present, it wasn’t clear if users actually knew they were<br>&gt;    taking place.)<br>&gt;<br>&gt;<br>&gt; In short, these conversions generally lead to a more confusing and<br>&gt; unpredictable user model. So, for Swift 1.2, we sought to eliminate<br>&gt; implicit bridging conversions entirely, and instead direct users to use<br>&gt; explicit bridging casts in their place. (E.g., “nsStrObj as String”.)<br>&gt;<br>&gt; Unfortunately, when it came time to roll out these changes, we noticed<br>&gt; that some native Objective-C APIs were now more difficult to work with in<br>&gt; Swift 1.2. Specifically, because global Objective-C NSString* constants<br>&gt; are imported into Swift as having type String, APIs that relied on<br>&gt; string-constant lookups into dictionaries imported as [NSObject :<br>&gt; AnyObject] failed to compile. E.g.<br>&gt;<br>&gt; var s : NSAttributedString<br>&gt; let SomeNSFontAttributeName : String // As per the importer.<br>&gt;<br>&gt; let attrs = s.attributesAtIndex(0, effectiveRange:nil) // In Swift 2,<br>&gt; ‘attrs’ has type [NSObject : AnyObject]<br>&gt; let fontName = attrs[SomeNSFontAttributeName] // This will fail to compile<br>&gt; without an implicit conversion from String to NSString.<br>&gt;<br>&gt; For this reason, we decided to make a compromise. We would require<br>&gt; explicit bridging casts when converting from a bridged Objective-C type to<br>&gt; its associated Swift value type (E.g., NSString -&gt; String), but not the<br>&gt; other way around. This would improve the status quo somewhat, and would<br>&gt; also avoid breaking user code in a needless/painful fashion until we could<br>&gt; get better API annotations in place.<br>&gt;<br>&gt; With the introduction of Objective-C generics last year, along with all of<br>&gt; the awesome improvements to API importing happening for Swift 3, I think<br>&gt; it’s time that we take another look at completing this work. Taking a look<br>&gt; back at last year’s “problematic” APIs, all of them now surface richer type<br>&gt; information when imported into Swift 3. As a result, the remaining implicit<br>&gt; bridging conversions now feel far less necessary, since Objective-C APIs<br>&gt; are now more commonly exposed in terms of their appropriate bridged Swift<br>&gt; value types. (For instance, in Swift 3, the above reference to attrs will<br>&gt; import as [String : AnyObject].)<br>&gt;<br>&gt; I propose that we fully eliminate implicit bridging conversions in Swift<br>&gt; 3. This would mean that some users might have to introduce introduce a few<br>&gt; more ‘as’ casts in their code, but we would remove another special case<br>&gt; from Swift&#39;s type system  and be able to further simplify the compiler. If<br>&gt; anyone is curious and would like to take this model for a spin, I’ve pushed<br>&gt; an experimental branch that implements this proposed change,<br>&gt; inhibit-implicit-conversions.<br>&gt;<br>&gt; Thoughts?<br>&gt;<br>&gt; Thanks!<br>&gt; - Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/75b3fa7c/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>April 19, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On Apr 18, 2016, at 8:21 PM, Joe Pamer via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I propose that we fully eliminate implicit bridging conversions in Swift 3. This would mean that some users might have to introduce introduce a few more ‘as’ casts in their code, but we would remove another special case from Swift&#39;s type system  and be able to further simplify the compiler. If anyone is curious and would like to take this model for a spin, I’ve pushed an experimental branch that implements this proposed change, inhibit-implicit-conversions.<br></p><p>What happens with string literals? Are they implicitly converted to NSString as necessary? Which of the following will be legal?<br></p><p>    import Foundation<br>    func s(_ str: String) { }<br>    func ns(_ str: NSString) { }<br></p><p>    let str: String = &quot;foo&quot;<br>    let nsstr: NSString = &quot;foo&quot;<br></p><p>    NSLog(&quot;foo&quot;)<br>    NSLog(str)<br>    NSLog(nsstr)<br></p><p>    s(&quot;foo&quot;)<br>    s(str)<br>    s(nsstr)<br></p><p>    ns(&quot;foo&quot;)<br>    ns(str)<br>    ns(nsstr)<br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/f7c018bf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/64e7c3f106cb83b50891f5dcccde198b?s=50"></div><header><strong>[Pitch] Fully eliminate implicit bridging conversions in Swift 3</strong> from <string>Joe Pamer</string> &lt;jpamer at apple.com&gt;<p>April 19, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Apr 19, 2016, at 7:28 AM, Greg Parker &lt;gparker at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 18, 2016, at 8:21 PM, Joe Pamer via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I propose that we fully eliminate implicit bridging conversions in Swift 3. This would mean that some users might have to introduce introduce a few more ‘as’ casts in their code, but we would remove another special case from Swift&#39;s type system  and be able to further simplify the compiler. If anyone is curious and would like to take this model for a spin, I’ve pushed an experimental branch that implements this proposed change, inhibit-implicit-conversions.<br>&gt; <br>&gt; What happens with string literals? Are they implicitly converted to NSString as necessary?<br></p><p>Sort of - yes. The types of literal expressions are always inferred from context, so for string literals they will be inferred as NSString or String as necessary. <br></p><p>&gt; Which of the following will be legal?<br>&gt; <br>&gt;     import Foundation<br>&gt;     func s(_ str: String) { }<br>&gt;     func ns(_ str: NSString) { }<br>&gt; <br>&gt;     let str: String = &quot;foo&quot;<br>&gt;     let nsstr: NSString = &quot;foo&quot;<br>&gt; <br>&gt;     NSLog(&quot;foo”)<br></p><p>legal<br></p><p>&gt;     NSLog(str)<br></p><p>legal - the NSLog initializer is imported as having type func NSLog(_ format: String, _ args: CVarArg...)<br></p><p>&gt;     NSLog(nstr)<br></p><p>illegal, per the imported initializer declaration above<br></p><p>&gt; <br>&gt;     s(&quot;foo”)<br></p><p>legal<br></p><p>&gt;     s(str)<br></p><p>legal<br></p><p>&gt;     s(nsstr)<br></p><p>illegal<br></p><p>&gt; <br>&gt;     ns(&quot;foo”)<br></p><p>legal<br></p><p>&gt;     ns(str)<br></p><p>illegal<br></p><p>&gt;     ns(nsstr)<br></p><p>legal<br></p><p>Thanks,<br>- Joe<br></p><p>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com &lt;mailto:gparker at apple.com&gt;     Runtime Wrangler<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160419/51e970c9/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
