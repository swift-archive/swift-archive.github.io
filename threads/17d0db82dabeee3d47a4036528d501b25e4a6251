<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>id-as-Any and ObjC generic parameters</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>Suppose we are calling a function that is generic over T, where T: AnyObject.  This comes up when e.g. calling an initializer for an ObjC generic class.<br></p><p>Today we allow conversions from [String] to [NSString], String to NSString, and [String] to [T], but we do not allow a conversion from String to T.  The concrete conversions are allowed because there is a bridging conversion from String to NSString.  The generic &quot;scalar&quot; conversion is not allowed because the type-checker&#39;s enumeration of possible supertypes does not consider bridged types.  The generic array conversion is allowed because the special-case code that governs collection up-casting in the type-checker immediately turns the generic argument into its bridged type and so bypasses that flaw.<br></p><p>One goal of the id-as-Any import change is to remove the implicit bridging conversions and the widespread use of AnyObject constraints.  As part of this, [U] will convert to [V] only when U is convertible to V.  This implies that both of the generic conversions above would be rejected.<br></p><p>With no other changes, this means that when calling an ObjC generic initializer, e.g.:<br>  @interface Generic&lt;T&gt;<br>  - (id) initWithArray: (NSArray&lt;T&gt; *) array;<br>  @end<br>it will not be possible to pass a [String] (inferring T == NSObject).  This is technically a regression.<br></p><p>Well, maybe we don&#39;t care.<br></p><p>If we do care, one option is to try to bridge generic parameters and their constraints.  Effectively, this would mean removing the implicitly AnyObject constraint on all ObjC generic parameters.  If we did this, it would be possible to pass a [String] to the initializer of Generic, and inferring T == String; SILGen would then recognize the need to bridge to NSArray&lt;NSString&gt; when passing the argument.  But this is a fair amount of work that I think is new to the plan.<br></p><p>Thoughts?<br></p><p>John.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>id-as-Any and ObjC generic parameters</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>July  7, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 17:26, John McCall via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Suppose we are calling a function that is generic over T, where T: AnyObject.  This comes up when e.g. calling an initializer for an ObjC generic class.<br>&gt; <br>&gt; Today we allow conversions from [String] to [NSString], String to NSString, and [String] to [T], but we do not allow a conversion from String to T.  The concrete conversions are allowed because there is a bridging conversion from String to NSString.  The generic &quot;scalar&quot; conversion is not allowed because the type-checker&#39;s enumeration of possible supertypes does not consider bridged types.  The generic array conversion is allowed because the special-case code that governs collection up-casting in the type-checker immediately turns the generic argument into its bridged type and so bypasses that flaw.<br>&gt; <br>&gt; One goal of the id-as-Any import change is to remove the implicit bridging conversions and the widespread use of AnyObject constraints.  As part of this, [U] will convert to [V] only when U is convertible to V.  This implies that both of the generic conversions above would be rejected.<br>&gt; <br>&gt; With no other changes, this means that when calling an ObjC generic initializer, e.g.:<br>&gt;  @interface Generic&lt;T&gt;<br>&gt;  - (id) initWithArray: (NSArray&lt;T&gt; *) array;<br>&gt;  @end<br>&gt; it will not be possible to pass a [String] (inferring T == NSObject).  This is technically a regression.<br>&gt; <br>&gt; Well, maybe we don&#39;t care.<br>&gt; <br>&gt; If we do care, one option is to try to bridge generic parameters and their constraints.  Effectively, this would mean removing the implicitly AnyObject constraint on all ObjC generic parameters.  If we did this, it would be possible to pass a [String] to the initializer of Generic, and inferring T == String; SILGen would then recognize the need to bridge to NSArray&lt;NSString&gt; when passing the argument.  But this is a fair amount of work that I think is new to the plan.<br>&gt; <br>&gt; Thoughts?<br></p><p>I don’t think it’s the end of the world to have to say this explicitly. We’re not removing the explicit ‘as’ conversion, and the type of Generic won’t be Generic&lt;String&gt; anyway; it’ll be Generic&lt;NSString&gt;.<br></p><p>Jordan<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>id-as-Any and ObjC generic parameters</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July  7, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 5:26 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt; <br>&gt; Suppose we are calling a function that is generic over T, where T: AnyObject.  This comes up when e.g. calling an initializer for an ObjC generic class.<br>&gt; <br>&gt; Today we allow conversions from [String] to [NSString], String to NSString, and [String] to [T], but we do not allow a conversion from String to T.  The concrete conversions are allowed because there is a bridging conversion from String to NSString.  The generic &quot;scalar&quot; conversion is not allowed because the type-checker&#39;s enumeration of possible supertypes does not consider bridged types.  The generic array conversion is allowed because the special-case code that governs collection up-casting in the type-checker immediately turns the generic argument into its bridged type and so bypasses that flaw.<br>&gt; <br>&gt; One goal of the id-as-Any import change is to remove the implicit bridging conversions and the widespread use of AnyObject constraints.  As part of this, [U] will convert to [V] only when U is convertible to V.  This implies that both of the generic conversions above would be rejected.<br>&gt; <br>&gt; With no other changes, this means that when calling an ObjC generic initializer, e.g.:<br>&gt;  @interface Generic&lt;T&gt;<br>&gt;  - (id) initWithArray: (NSArray&lt;T&gt; *) array;<br>&gt;  @end<br>&gt; it will not be possible to pass a [String] (inferring T == NSObject).  This is technically a regression.<br>&gt; <br>&gt; Well, maybe we don&#39;t care.<br>&gt; <br>&gt; If we do care, one option is to try to bridge generic parameters and their constraints.  Effectively, this would mean removing the implicitly AnyObject constraint on all ObjC generic parameters.  If we did this, it would be possible to pass a [String] to the initializer of Generic, and inferring T == String; SILGen would then recognize the need to bridge to NSArray&lt;NSString&gt; when passing the argument.  But this is a fair amount of work that I think is new to the plan.<br>&gt; <br>&gt; Thoughts?<br></p><p>I tried to subset handling generic parameters out. While it&#39;s definitely a possibility, it seems like something we could tackle in an additive fashion later, since removing the &#39;AnyObject&#39; constraint from generics is &quot;just&quot; removing requirements. I think we can live with the lack of conversion in ObjC generics. It&#39;s already the case that ObjC generic covariance doesn&#39;t carry over to Swift, and I don&#39;t think we have bandwidth to make that work for this release either.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>id-as-Any and ObjC generic parameters</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>July  8, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 7, 2016, at 8:17 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; On Jul 7, 2016, at 5:26 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Suppose we are calling a function that is generic over T, where T: AnyObject.  This comes up when e.g. calling an initializer for an ObjC generic class.<br>&gt;&gt; <br>&gt;&gt; Today we allow conversions from [String] to [NSString], String to NSString, and [String] to [T], but we do not allow a conversion from String to T.  The concrete conversions are allowed because there is a bridging conversion from String to NSString.  The generic &quot;scalar&quot; conversion is not allowed because the type-checker&#39;s enumeration of possible supertypes does not consider bridged types.  The generic array conversion is allowed because the special-case code that governs collection up-casting in the type-checker immediately turns the generic argument into its bridged type and so bypasses that flaw.<br>&gt;&gt; <br>&gt;&gt; One goal of the id-as-Any import change is to remove the implicit bridging conversions and the widespread use of AnyObject constraints.  As part of this, [U] will convert to [V] only when U is convertible to V.  This implies that both of the generic conversions above would be rejected.<br>&gt;&gt; <br>&gt;&gt; With no other changes, this means that when calling an ObjC generic initializer, e.g.:<br>&gt;&gt; @interface Generic&lt;T&gt;<br>&gt;&gt; - (id) initWithArray: (NSArray&lt;T&gt; *) array;<br>&gt;&gt; @end<br>&gt;&gt; it will not be possible to pass a [String] (inferring T == NSObject).  This is technically a regression.<br>&gt;&gt; <br>&gt;&gt; Well, maybe we don&#39;t care.<br>&gt;&gt; <br>&gt;&gt; If we do care, one option is to try to bridge generic parameters and their constraints.  Effectively, this would mean removing the implicitly AnyObject constraint on all ObjC generic parameters.  If we did this, it would be possible to pass a [String] to the initializer of Generic, and inferring T == String; SILGen would then recognize the need to bridge to NSArray&lt;NSString&gt; when passing the argument.  But this is a fair amount of work that I think is new to the plan.<br>&gt;&gt; <br>&gt;&gt; Thoughts?<br>&gt; <br>&gt; I tried to subset handling generic parameters out. While it&#39;s definitely a possibility, it seems like something we could tackle in an additive fashion later, since removing the &#39;AnyObject&#39; constraint from generics is &quot;just&quot; removing requirements. I think we can live with the lack of conversion in ObjC generics. It&#39;s already the case that ObjC generic covariance doesn&#39;t carry over to Swift, and I don&#39;t think we have bandwidth to make that work for this release either.<br></p><p>Okay.  Between Jordan&#39;s response and yours, I&#39;m convinced that we can just regress here.<br></p><p>John.<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
