<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Proposal Link: https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md<br></p><p>The review of &quot;SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib&quot; ran from May 19…23, 2016. The proposal has been *accepted* with one minor naming-related change:<br></p><p>- Feedback from the community &amp; core team is positive.<br>- Core team discussed whether it made sense to add just the first form, or whether it made sense to add both.  They agree that although the form using an explicit state is much more infrequently used, when it is necessary, it is extremely helpful to have.  It is also useful to consider both as a pair. <br>- On naming, the core team agrees with the community that “sequence(first:next:)” is a better name than &quot;sequence(initial:next:)”.  &quot;sequence(state:next:)” is approved as-is.<br></p><p>Thank you to Kevin Ballard and Erica Sadun for proposing this both in SE-0045 and in SE-0094, an implementation of these functions would be welcome!  <br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>[Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>Great news!<br></p><p>I&#39;ve filed a bug for this in JIRA: https://bugs.swift.org/browse/SR-1622<br></p><p><br>On Wed, May 25, 2016 at 7:44 PM, Chris Lattner via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Proposal Link:<br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md<br>&gt;<br>&gt; The review of &quot;SE-0094: Add sequence(initial:next:) and<br>&gt; sequence(state:next:) to the stdlib&quot; ran from May 19…23, 2016. The proposal<br>&gt; has been *accepted* with one minor naming-related change:<br>&gt;<br>&gt; - Feedback from the community &amp; core team is positive.<br>&gt; - Core team discussed whether it made sense to add just the first form, or<br>&gt; whether it made sense to add both.  They agree that although the form using<br>&gt; an explicit state is much more infrequently used, when it is necessary, it<br>&gt; is extremely helpful to have.  It is also useful to consider both as a pair.<br>&gt; - On naming, the core team agrees with the community that<br>&gt; “sequence(first:next:)” is a better name than &quot;sequence(initial:next:)”.<br>&gt; &quot;sequence(state:next:)” is approved as-is.<br>&gt;<br>&gt; Thank you to Kevin Ballard and Erica Sadun for proposing this both in<br>&gt; SE-0045 and in SE-0094, an implementation of these functions would be<br>&gt; welcome!<br>&gt;<br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/34c0e34e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 25, 2016 at 07:00:00pm</p></header><div class="content"><p>And I&#39;ve just grabbed that bug, and will whip up an initial<br>implementation shortly :D<br> <br>I&#39;m also going to update the proposal with the name change in a minute.<br> <br>-Kevin Ballard<br> <br>On Wed, May 25, 2016, at 07:54 PM, Jacob Bandes-Storch via swift-evolution wrote:<br>&gt; Great news!<br>&gt;<br>&gt; I&#39;ve filed a bug for this in JIRA:<br>&gt; https://bugs.swift.org/browse/SR-1622<br>&gt;<br>&gt;<br>&gt; On Wed, May 25, 2016 at 7:44 PM, Chris Lattner via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; Proposal Link:<br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0094-sequence-function.md<br>&gt;&gt;<br>&gt;&gt;  The review of &quot;SE-0094: Add sequence(initial:next:) and<br>&gt;&gt;  sequence(state:next:) to the stdlib&quot; ran from May 19…23, 2016. The<br>&gt;&gt;  proposal has been *accepted* with one minor naming-related change:<br>&gt;&gt;<br>&gt;&gt;  - Feedback from the community &amp; core team is positive.<br>&gt;&gt;  - Core team discussed whether it made sense to add just the first<br>&gt;&gt;    form, or whether it made sense to add both.  They agree that<br>&gt;&gt;    although the form using an explicit state is much more<br>&gt;&gt;    infrequently used, when it is necessary, it is extremely helpful<br>&gt;&gt;    to have.  It is also useful to consider both as a pair.<br>&gt;&gt;  - On naming, the core team agrees with the community that<br>&gt;&gt;    “sequence(first:next:)” is a better name than<br>&gt;&gt;    &quot;sequence(initial:next:)”.  &quot;sequence(state:next:)” is approved<br>&gt;&gt;    as-is.<br>&gt;&gt;<br>&gt;&gt;  Thank you to Kevin Ballard and Erica Sadun for proposing this both<br>&gt;&gt;  in SE-0045 and in SE-0094, an implementation of these functions<br>&gt;&gt;  would be welcome!<br>&gt;&gt;<br>&gt;&gt;  -Chris Lattner<br>&gt;&gt;  Review Manager<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;  swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br> <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/c44c74cc/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>On Thu, May 19, 2016, at 05:52 PM, Kevin Ballard wrote (on a<br>different thread):<br>&gt; After having given this some thought, it seems apparent that<br>&gt; `sequence(state:next:)` is  equivalent to `AnyIterator({ ... })` where<br>&gt; the closure captures a single mutable variable. The microbenchmark<br>&gt; performance may differ slightly, as the AnyIterator version will<br>&gt; allocate a box on the heap to hold the captured variable (assuming it<br>&gt; can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the<br>&gt; functionality is the same.<br> <br>For the record, I just realized that the type signature of<br>UnfoldSequence&lt;T&gt; actually requires that we do heap allocation as well,<br>because this type can only be used for the stateful version if we erase<br>the state type by capturing it in a closure.<br> <br>As part of implementing this, I&#39;m going to go ahead and modify the type<br>signature to UnfoldSequence&lt;T, State&gt;, with `state(first:next:)`<br>returning the type UnfoldSequence&lt;T, T?&gt;. I think it&#39;s better to diverge<br>slightly from the proposal than it is to introduce unnecessary (albeit<br>small) performance cost. I hope there are no objections.<br> <br>-Kevin Ballard<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/b3979011/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On May 25, 2016, at 8:39 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Thu, May 19, 2016, at 05:52 PM, Kevin Ballard wrote (on a different thread):<br>&gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same. <br>&gt;  <br>&gt; For the record, I just realized that the type signature of UnfoldSequence&lt;T&gt; actually requires that we do heap allocation as well, because this type can only be used for the stateful version if we erase the state type by capturing it in a closure.<br>&gt;  <br>&gt; As part of implementing this, I&#39;m going to go ahead and modify the type signature to UnfoldSequence&lt;T, State&gt;, with `state(first:next:)` returning the type UnfoldSequence&lt;T, T?&gt;. I think it&#39;s better to diverge slightly from the proposal than it is to introduce unnecessary (albeit small) performance cost. I hope there are no objections.<br></p><p>That makes sense to me - the core team review discussion did not specifically discuss the return type in question, nor its naming.  In my opinion, these implementation concerns can be handled by patch review process.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 25, 2016 at 08:00:00pm</p></header><div class="content"><p>On Wed, May 25, 2016, at 08:49 PM, Chris Lattner wrote:<br>&gt; <br>&gt; &gt; On May 25, 2016, at 8:39 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; On Thu, May 19, 2016, at 05:52 PM, Kevin Ballard wrote (on a different thread):<br>&gt; &gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same. <br>&gt; &gt;  <br>&gt; &gt; For the record, I just realized that the type signature of UnfoldSequence&lt;T&gt; actually requires that we do heap allocation as well, because this type can only be used for the stateful version if we erase the state type by capturing it in a closure.<br>&gt; &gt;  <br>&gt; &gt; As part of implementing this, I&#39;m going to go ahead and modify the type signature to UnfoldSequence&lt;T, State&gt;, with `state(first:next:)` returning the type UnfoldSequence&lt;T, T?&gt;. I think it&#39;s better to diverge slightly from the proposal than it is to introduce unnecessary (albeit small) performance cost. I hope there are no objections.<br></p><p>And of course I spoke too soon, because T? isn&#39;t the right state to handle this. It looks like I&#39;ll end up going with UnfoldSequence&lt;T, (T?, Bool)&gt;. Slightly ugly, but most people won&#39;t be typing it that often, and we&#39;ve had worse (such as LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Self.Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt;, which is quite a mouthful).<br></p><p>&gt; That makes sense to me - the core team review discussion did not specifically discuss the return type in question, nor its naming.  In my opinion, these implementation concerns can be handled by patch review process.<br></p><p>Glad to hear it.<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c74c15ba14b1096d4e42900ddd2dacd0?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Patrick Smith</string> &lt;pgwsmith at gmail.com&gt;<p>May 26, 2016 at 01:00:00pm</p></header><div class="content"><p>Just a dumb question, can you have two different types? UnfoldSequence and UnfoldStateSequence? Then they can have more focused generic parameters.<br></p><p><br>&gt; On 26 May 2016, at 1:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Wed, May 25, 2016, at 08:49 PM, Chris Lattner wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On May 25, 2016, at 8:39 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Thu, May 19, 2016, at 05:52 PM, Kevin Ballard wrote (on a different thread):<br>&gt;&gt;&gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; For the record, I just realized that the type signature of UnfoldSequence&lt;T&gt; actually requires that we do heap allocation as well, because this type can only be used for the stateful version if we erase the state type by capturing it in a closure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As part of implementing this, I&#39;m going to go ahead and modify the type signature to UnfoldSequence&lt;T, State&gt;, with `state(first:next:)` returning the type UnfoldSequence&lt;T, T?&gt;. I think it&#39;s better to diverge slightly from the proposal than it is to introduce unnecessary (albeit small) performance cost. I hope there are no objections.<br>&gt; <br>&gt; And of course I spoke too soon, because T? isn&#39;t the right state to handle this. It looks like I&#39;ll end up going with UnfoldSequence&lt;T, (T?, Bool)&gt;. Slightly ugly, but most people won&#39;t be typing it that often, and we&#39;ve had worse (such as LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Self.Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt;, which is quite a mouthful).<br>&gt; <br>&gt;&gt; That makes sense to me - the core team review discussion did not specifically discuss the return type in question, nor its naming.  In my opinion, these implementation concerns can be handled by patch review process.<br>&gt; <br>&gt; Glad to hear it.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 25, 2016 at 09:00:00pm</p></header><div class="content"><p>We could, but my plan was to implement sequence(first:next:) as a call to sequence(state:next:). I could of course implement it twice, but that would presumably result in slightly larger code size and a larger API surface (because there&#39;s a whole extra type there). I think this sort of thing can be hashed out in patch review if anyone feels strongly about it.<br></p><p>-Kevin Ballard<br></p><p>On Wed, May 25, 2016, at 08:56 PM, Patrick Smith wrote:<br>&gt; Just a dumb question, can you have two different types? UnfoldSequence and UnfoldStateSequence? Then they can have more focused generic parameters.<br>&gt; <br>&gt; <br>&gt; &gt; On 26 May 2016, at 1:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; <br>&gt; &gt; On Wed, May 25, 2016, at 08:49 PM, Chris Lattner wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt;&gt; On May 25, 2016, at 8:39 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; On Thu, May 19, 2016, at 05:52 PM, Kevin Ballard wrote (on a different thread):<br>&gt; &gt;&gt;&gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same. <br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; For the record, I just realized that the type signature of UnfoldSequence&lt;T&gt; actually requires that we do heap allocation as well, because this type can only be used for the stateful version if we erase the state type by capturing it in a closure.<br>&gt; &gt;&gt;&gt; <br>&gt; &gt;&gt;&gt; As part of implementing this, I&#39;m going to go ahead and modify the type signature to UnfoldSequence&lt;T, State&gt;, with `state(first:next:)` returning the type UnfoldSequence&lt;T, T?&gt;. I think it&#39;s better to diverge slightly from the proposal than it is to introduce unnecessary (albeit small) performance cost. I hope there are no objections.<br>&gt; &gt; <br>&gt; &gt; And of course I spoke too soon, because T? isn&#39;t the right state to handle this. It looks like I&#39;ll end up going with UnfoldSequence&lt;T, (T?, Bool)&gt;. Slightly ugly, but most people won&#39;t be typing it that often, and we&#39;ve had worse (such as LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Self.Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt;, which is quite a mouthful).<br>&gt; &gt; <br>&gt; &gt;&gt; That makes sense to me - the core team review discussion did not specifically discuss the return type in question, nor its naming.  In my opinion, these implementation concerns can be handled by patch review process.<br>&gt; &gt; <br>&gt; &gt; Glad to hear it.<br>&gt; &gt; <br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>[swift-evolution-announce] [Accepted with Revision] SE-0094: Add sequence(initial:next:) and sequence(state:next:) to the stdlib</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>May 25, 2016 at 09:00:00pm</p></header><div class="content"><p>That being said, since we now have generic typealiases, I could presumably just have something like<br></p><p>public typealias UnfoldFirstSequence&lt;T&gt; = UnfoldSequence&lt;T, (T?, Bool)&gt;<br></p><p>-Kevin Ballard<br></p><p>On Wed, May 25, 2016, at 09:01 PM, Kevin Ballard wrote:<br>&gt; We could, but my plan was to implement sequence(first:next:) as a call to sequence(state:next:). I could of course implement it twice, but that would presumably result in slightly larger code size and a larger API surface (because there&#39;s a whole extra type there). I think this sort of thing can be hashed out in patch review if anyone feels strongly about it.<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; <br>&gt; On Wed, May 25, 2016, at 08:56 PM, Patrick Smith wrote:<br>&gt; &gt; Just a dumb question, can you have two different types? UnfoldSequence and UnfoldStateSequence? Then they can have more focused generic parameters.<br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; &gt; On 26 May 2016, at 1:51 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; On Wed, May 25, 2016, at 08:49 PM, Chris Lattner wrote:<br>&gt; &gt; &gt;&gt; <br>&gt; &gt; &gt;&gt;&gt; On May 25, 2016, at 8:39 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt; &gt;&gt;&gt; <br>&gt; &gt; &gt;&gt;&gt; On Thu, May 19, 2016, at 05:52 PM, Kevin Ballard wrote (on a different thread):<br>&gt; &gt; &gt;&gt;&gt;&gt; After having given this some thought, it seems apparent that `sequence(state:next:)` is equivalent to `AnyIterator({ ... })` where the closure captures a single mutable variable. The microbenchmark performance may differ slightly, as the AnyIterator version will allocate a box on the heap to hold the captured variable (assuming it can&#39;t get inlined entirely), whereas UnfoldSequence won&#39;t. But the functionality is the same. <br>&gt; &gt; &gt;&gt;&gt; <br>&gt; &gt; &gt;&gt;&gt; For the record, I just realized that the type signature of UnfoldSequence&lt;T&gt; actually requires that we do heap allocation as well, because this type can only be used for the stateful version if we erase the state type by capturing it in a closure.<br>&gt; &gt; &gt;&gt;&gt; <br>&gt; &gt; &gt;&gt;&gt; As part of implementing this, I&#39;m going to go ahead and modify the type signature to UnfoldSequence&lt;T, State&gt;, with `state(first:next:)` returning the type UnfoldSequence&lt;T, T?&gt;. I think it&#39;s better to diverge slightly from the proposal than it is to introduce unnecessary (albeit small) performance cost. I hope there are no objections.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; And of course I spoke too soon, because T? isn&#39;t the right state to handle this. It looks like I&#39;ll end up going with UnfoldSequence&lt;T, (T?, Bool)&gt;. Slightly ugly, but most people won&#39;t be typing it that often, and we&#39;ve had worse (such as LazyMapSequence&lt;LazyFilterSequence&lt;LazyMapSequence&lt;Self.Elements, ElementOfResult?&gt;&gt;, ElementOfResult&gt;, which is quite a mouthful).<br>&gt; &gt; &gt; <br>&gt; &gt; &gt;&gt; That makes sense to me - the core team review discussion did not specifically discuss the return type in question, nor its naming.  In my opinion, these implementation concerns can be handled by patch review process.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; Glad to hear it.<br>&gt; &gt; &gt; <br>&gt; &gt; &gt; -Kevin Ballard<br>&gt; &gt; &gt; _______________________________________________<br>&gt; &gt; &gt; swift-evolution mailing list<br>&gt; &gt; &gt; swift-evolution at swift.org<br>&gt; &gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
