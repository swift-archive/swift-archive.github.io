<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 22, 2016 at 12:00:00am</p></header><div class="content"><p>Howdy,<br>I think that the SignedNumberType should implement a method called sign<br>that will return -1 for negative numbers, 0 for 0 and 1 for positive<br>numbers. This is similar to the signum method in e.g. Java and similarly<br>called methods in other languages.<br></p><p>The implementation is fairly straight forward<br></p><p>extension SignedNumberType {<br>  var sign: Self {<br>    if self == 0 {<br>      return 0<br>    }<br>    else if self &gt; 0 {<br>      return 1<br>    }<br>    return -1<br>  }<br>}<br></p><p>I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0)<br>but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/326b7ad2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 22, 2016 at 10:00:00am</p></header><div class="content"><p>This should do the trick:<br></p><p>extension SignedNumberType {<br>     <br>    var sign: Self {<br>         <br>        if self == (0 as Self) {<br>            return (0 as Self)<br>        } else if self &gt; (0 as Self) {<br>            return (1 as Self)<br>        }<br>        return (-1 as Self)<br>    }<br>}<br></p><p><br>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Mai 2016 bei 09:08:37, Adam Nemecek via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Howdy,<br>I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br></p><p>The implementation is fairly straight forward<br></p><p>extension SignedNumberType {<br>  var sign: Self {<br>    if self == 0 {<br>      return 0<br>    }<br>    else if self &gt; 0 {<br>      return 1<br>    }<br>    return -1<br>  }<br>} <br></p><p>I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/c0664c26/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>May 22, 2016 at 10:00:00am</p></header><div class="content"><p>Whoops didn’t check that your example worked as well :D<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Mai 2016 bei 10:27:17, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>This should do the trick:<br></p><p>extension SignedNumberType {<br>      <br>    var sign: Self {<br>          <br>        if self == (0 as Self) {<br>            return (0 as Self)<br>        } else if self &gt; (0 as Self) {<br>            return (1 as Self)<br>        }<br>        return (-1 as Self)<br>    }<br>}<br></p><p><br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br></p><p>Am 22. Mai 2016 bei 09:08:37, Adam Nemecek via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>Howdy,<br>I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br></p><p>The implementation is fairly straight forward<br></p><p>extension SignedNumberType {<br>  var sign: Self {<br>    if self == 0 {<br>      return 0<br>    }<br>    else if self &gt; 0 {<br>      return 1<br>    }<br>    return -1<br>  }<br>} <br></p><p>I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br></p><p><br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160522/bc56119a/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 23, 2016 at 08:00:00am</p></header><div class="content"><p>Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br></p><p>In other words, anywhere that I might do this:<br></p><p>	if myValue.sign &gt; 0 { … }<br></p><p>I could just as easily do:<br></p><p>	if myValue &gt; 0 { … }<br></p><p>To the same end result surely? Unless I’m missing something it seems redundant.<br></p><p>If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br></p><p>&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Howdy,<br>&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt; <br>&gt; The implementation is fairly straight forward<br>&gt; <br>&gt; extension SignedNumberType {<br>&gt;   var sign: Self {<br>&gt;     if self == 0 {<br>&gt;       return 0<br>&gt;     }<br>&gt;     else if self &gt; 0 {<br>&gt;       return 1<br>&gt;     }<br>&gt;     return -1<br>&gt;   }<br>&gt; } <br>&gt; <br>&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/4a6d215a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 23, 2016 at 01:00:00am</p></header><div class="content"><p>It&#39;s not for branching based on the value, it&#39;s for calculating<br>mathematical functions with the sign retrieved from the value. So for the<br>same reason, no it should not be an enum. It should be the same type as the<br>type it&#39;s called on. It&#39;s that way in Haskell as well<br></p><p>http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:signum<br></p><p>This function is basically in every language<br></p><p>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign<br></p><p>https://docs.oracle.com/javase/7/docs/api/java/lang/Math.html#signum(double)<br></p><p>http://en.cppreference.com/w/cpp/numeric/math/signbit<br></p><p>https://golang.org/pkg/math/#Signbit<br></p><p>https://msdn.microsoft.com/en-us/library/system.math.sign(v=vs.110).aspx<br></p><p>It&#39;s used a bunch e.g. in dsp but also in mathematics<br></p><p>https://www.quora.com/What-are-the-real-life-applications-of-Signum-function<br></p><p>This quote somewhat summarizes it &quot;So signum shows up in many places where<br>discontinuous jumps must be written in closed form.&quot;<br></p><p><br></p><p>On Mon, May 23, 2016 at 12:29 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>wrote:<br></p><p>&gt; Could you give an example of this method’s usage? Surely your value is<br>&gt; either positive, negative or zero already, so this method doesn’t return<br>&gt; anything more useful.<br>&gt;<br>&gt; In other words, anywhere that I might do this:<br>&gt;<br>&gt; if myValue.sign &gt; 0 { … }<br>&gt;<br>&gt; I could just as easily do:<br>&gt;<br>&gt; if myValue &gt; 0 { … }<br>&gt;<br>&gt; To the same end result surely? Unless I’m missing something it seems<br>&gt; redundant.<br>&gt;<br>&gt; If there is a use-case for this, would it make more sense to have the<br>&gt; return type as an enum with cases for Positive, Negative and Zero?<br>&gt;<br>&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Howdy,<br>&gt; I think that the SignedNumberType should implement a method called sign<br>&gt; that will return -1 for negative numbers, 0 for 0 and 1 for positive<br>&gt; numbers. This is similar to the signum method in e.g. Java and similarly<br>&gt; called methods in other languages.<br>&gt;<br>&gt; The implementation is fairly straight forward<br>&gt;<br>&gt; extension SignedNumberType {<br>&gt;   var sign: Self {<br>&gt;     if self == 0 {<br>&gt;       return 0<br>&gt;     }<br>&gt;     else if self &gt; 0 {<br>&gt;       return 1<br>&gt;     }<br>&gt;     return -1<br>&gt;   }<br>&gt; }<br>&gt;<br>&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0)<br>&gt; but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/feff3cf4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e4e0303aba733d146ad141a9f38202c5?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Adam Nemecek</string> &lt;adamnemecek at gmail.com&gt;<p>May 23, 2016 at 01:00:00am</p></header><div class="content"><p>Oh and also machine learning. Search for sign or signum and machine<br>learning, you&#39;ll find a lot of results.<br></p><p>On Mon, May 23, 2016 at 1:26 AM, Adam Nemecek &lt;adamnemecek at gmail.com&gt; wrote:<br></p><p>&gt; It&#39;s not for branching based on the value, it&#39;s for calculating<br>&gt; mathematical functions with the sign retrieved from the value. So for the<br>&gt; same reason, no it should not be an enum. It should be the same type as the<br>&gt; type it&#39;s called on. It&#39;s that way in Haskell as well<br>&gt;<br>&gt; http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:signum<br>&gt;<br>&gt; This function is basically in every language<br>&gt;<br>&gt;<br>&gt; https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign<br>&gt;<br>&gt;<br>&gt; https://docs.oracle.com/javase/7/docs/api/java/lang/Math.html#signum(double)<br>&gt;<br>&gt; http://en.cppreference.com/w/cpp/numeric/math/signbit<br>&gt;<br>&gt; https://golang.org/pkg/math/#Signbit<br>&gt;<br>&gt; https://msdn.microsoft.com/en-us/library/system.math.sign(v=vs.110).aspx<br>&gt;<br>&gt; It&#39;s used a bunch e.g. in dsp but also in mathematics<br>&gt;<br>&gt;<br>&gt; https://www.quora.com/What-are-the-real-life-applications-of-Signum-function<br>&gt;<br>&gt; This quote somewhat summarizes it &quot;So signum shows up in many places where<br>&gt; discontinuous jumps must be written in closed form.&quot;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Mon, May 23, 2016 at 12:29 AM, Haravikk &lt;swift-evolution at haravikk.me&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Could you give an example of this method’s usage? Surely your value is<br>&gt;&gt; either positive, negative or zero already, so this method doesn’t return<br>&gt;&gt; anything more useful.<br>&gt;&gt;<br>&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt;<br>&gt;&gt; if myValue.sign &gt; 0 { … }<br>&gt;&gt;<br>&gt;&gt; I could just as easily do:<br>&gt;&gt;<br>&gt;&gt; if myValue &gt; 0 { … }<br>&gt;&gt;<br>&gt;&gt; To the same end result surely? Unless I’m missing something it seems<br>&gt;&gt; redundant.<br>&gt;&gt;<br>&gt;&gt; If there is a use-case for this, would it make more sense to have the<br>&gt;&gt; return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt;<br>&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Howdy,<br>&gt;&gt; I think that the SignedNumberType should implement a method called sign<br>&gt;&gt; that will return -1 for negative numbers, 0 for 0 and 1 for positive<br>&gt;&gt; numbers. This is similar to the signum method in e.g. Java and similarly<br>&gt;&gt; called methods in other languages.<br>&gt;&gt;<br>&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;<br>&gt;&gt; extension SignedNumberType {<br>&gt;&gt;   var sign: Self {<br>&gt;&gt;     if self == 0 {<br>&gt;&gt;       return 0<br>&gt;&gt;     }<br>&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;       return 1<br>&gt;&gt;     }<br>&gt;&gt;     return -1<br>&gt;&gt;   }<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0)<br>&gt;&gt; but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/894c399b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 23, 2016 at 01:00:00pm</p></header><div class="content"><p>The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br></p><p>enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br></p><p>    case Negative<br>    case Zero<br>    case Positive<br>	<br>    var signum: NumberType {<br>        switch self {<br>        case .Negative:<br>            return -1 as NumberType<br>        case .Zero:<br>            return 0 as NumberType<br>        case .Positive:<br>            return 1 as NumberType<br>        }<br>    }<br>	<br>}<br></p><p>extension SignedNumberType {<br>    var sign: IntegerSign&lt;Self&gt; {<br>        if self == 0 {<br>            return .Zero<br>        } else if self &gt; 0 {<br>            return .Positive<br>        } else {<br>            return .Negative<br>        }<br>    }<br>}<br></p><p>Charlie<br></p><p>&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt; <br>&gt; In other words, anywhere that I might do this:<br>&gt; <br>&gt; 	if myValue.sign &gt; 0 { … }<br>&gt; <br>&gt; I could just as easily do:<br>&gt; <br>&gt; 	if myValue &gt; 0 { … }<br>&gt; <br>&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt; <br>&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt; <br>&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Howdy,<br>&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt; <br>&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt; <br>&gt;&gt; extension SignedNumberType {<br>&gt;&gt;   var sign: Self {<br>&gt;&gt;     if self == 0 {<br>&gt;&gt;       return 0<br>&gt;&gt;     }<br>&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;       return 1<br>&gt;&gt;     }<br>&gt;&gt;     return -1<br>&gt;&gt;   }<br>&gt;&gt; } <br>&gt;&gt; <br>&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/47ee83e2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 23, 2016 at 11:00:00pm</p></header><div class="content"><p>Can we make it RawRepresentable? That way signum can just return self.rawValue<br></p><p>Sent from my iPhone<br></p><p>&gt; On May 23, 2016, at 06:05, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br>&gt; <br>&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br>&gt; <br>&gt;     case Negative<br>&gt;     case Zero<br>&gt;     case Positive<br>&gt; 	<br>&gt;     var signum: NumberType {<br>&gt;         switch self {<br>&gt;         case .Negative:<br>&gt;             return -1 as NumberType<br>&gt;         case .Zero:<br>&gt;             return 0 as NumberType<br>&gt;         case .Positive:<br>&gt;             return 1 as NumberType<br>&gt;         }<br>&gt;     }<br>&gt; 	<br>&gt; }<br>&gt; <br>&gt; extension SignedNumberType {<br>&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;         if self == 0 {<br>&gt;             return .Zero<br>&gt;         } else if self &gt; 0 {<br>&gt;             return .Positive<br>&gt;         } else {<br>&gt;             return .Negative<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Charlie<br>&gt; <br>&gt;&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt;&gt; <br>&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt; <br>&gt;&gt; 	if myValue.sign &gt; 0 { … }<br>&gt;&gt; <br>&gt;&gt; I could just as easily do:<br>&gt;&gt; <br>&gt;&gt; 	if myValue &gt; 0 { … }<br>&gt;&gt; <br>&gt;&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt;&gt; <br>&gt;&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt; <br>&gt;&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Howdy,<br>&gt;&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;   var sign: Self {<br>&gt;&gt;&gt;     if self == 0 {<br>&gt;&gt;&gt;       return 0<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;&gt;       return 1<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/032c643e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 24, 2016 at 06:00:00am</p></header><div class="content"><p>Sure, that&#39;s a good idea, though I&#39;d personally use the signum var, since using rawValue seems like a bit of an abuse of the fact the enum is defined this way and doesn&#39;t help readability of the code:<br></p><p>enum IntegerSign&lt;NumberType: SignedNumberType&gt;: RawRepresentable {<br></p><p>    case Negative<br>    case Zero<br>    case Positive<br>    <br>    init?(rawValue: NumberType) {<br>        if rawValue == -1 {<br>            self = .Negative<br>        } else if rawValue == 0 {<br>            self = .Zero<br>        } else if rawValue == 1 {<br>            self = .Positive<br>        } else {<br>            return nil<br>        }<br>    }<br>    <br>    var rawValue: NumberType {<br>        return self.signum<br>    }<br>    <br>    var signum: NumberType {<br>        switch self {<br>        case .Negative:<br>            return -1 as NumberType<br>        case .Zero:<br>            return 0 as NumberType<br>        case .Positive:<br>            return 1 as NumberType<br>        }<br>    }<br>    <br>}<br></p><p>extension SignedNumberType {<br>    var sign: IntegerSign&lt;Self&gt; {<br>        if self == 0 {<br>            return .Zero<br>        } else if self &gt; 0 {<br>            return .Positive<br>        } else {<br>            return .Negative<br>        }<br>    }<br>}<br></p><p><br></p><p>&gt; On May 24, 2016, at 6:09 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; Can we make it RawRepresentable? That way signum can just return self.rawValue<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On May 23, 2016, at 06:05, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br>&gt;&gt; <br>&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br>&gt;&gt; <br>&gt;&gt;     case Negative<br>&gt;&gt;     case Zero<br>&gt;&gt;     case Positive<br>&gt;&gt; 	<br>&gt;&gt;     var signum: NumberType {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .Negative:<br>&gt;&gt;             return -1 as NumberType<br>&gt;&gt;         case .Zero:<br>&gt;&gt;             return 0 as NumberType<br>&gt;&gt;         case .Positive:<br>&gt;&gt;             return 1 as NumberType<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; 	<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SignedNumberType {<br>&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;         if self == 0 {<br>&gt;&gt;             return .Zero<br>&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;             return .Positive<br>&gt;&gt;         } else {<br>&gt;&gt;             return .Negative<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if myValue.sign &gt; 0 { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I could just as easily do:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	if myValue &gt; 0 { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Howdy,<br>&gt;&gt;&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;   var sign: Self {<br>&gt;&gt;&gt;&gt;     if self == 0 {<br>&gt;&gt;&gt;&gt;       return 0<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;       return 1<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/c787344f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 24, 2016 at 12:00:00am</p></header><div class="content"><p>Sorry, I misspoke. I just meant define it like this:<br>public enum IntegerSign&lt;T: SignedIntegerType&gt; : Int {<br>    case Negative = -1<br>    case Zero = 0<br>    case Positive = 1<br>    public var signum: T {<br>        return T(self.rawValue.toIntMax())<br>    }<br>}<br></p><p>Although, come to think of it, I’m not sure if that’s an exact drop-in replacement for your code, since it’s `SignedIntegerType` instead of `SignedNumberType`<br></p><p>-Dave Sweeris<br></p><p>&gt; On May 23, 2016, at 11:48 PM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Sure, that&#39;s a good idea, though I&#39;d personally use the signum var, since using rawValue seems like a bit of an abuse of the fact the enum is defined this way and doesn&#39;t help readability of the code:<br>&gt; <br>&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt;: RawRepresentable {<br>&gt; <br>&gt;     case Negative<br>&gt;     case Zero<br>&gt;     case Positive<br>&gt;     <br>&gt;     init?(rawValue: NumberType) {<br>&gt;         if rawValue == -1 {<br>&gt;             self = .Negative<br>&gt;         } else if rawValue == 0 {<br>&gt;             self = .Zero<br>&gt;         } else if rawValue == 1 {<br>&gt;             self = .Positive<br>&gt;         } else {<br>&gt;             return nil<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt;     var rawValue: NumberType {<br>&gt;         return self.signum<br>&gt;     }<br>&gt;     <br>&gt;     var signum: NumberType {<br>&gt;         switch self {<br>&gt;         case .Negative:<br>&gt;             return -1 as NumberType<br>&gt;         case .Zero:<br>&gt;             return 0 as NumberType<br>&gt;         case .Positive:<br>&gt;             return 1 as NumberType<br>&gt;         }<br>&gt;     }<br>&gt;     <br>&gt; }<br>&gt; <br>&gt; extension SignedNumberType {<br>&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;         if self == 0 {<br>&gt;             return .Zero<br>&gt;         } else if self &gt; 0 {<br>&gt;             return .Positive<br>&gt;         } else {<br>&gt;             return .Negative<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On May 24, 2016, at 6:09 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can we make it RawRepresentable? That way signum can just return self.rawValue<br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On May 23, 2016, at 06:05, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     case Negative<br>&gt;&gt;&gt;     case Zero<br>&gt;&gt;&gt;     case Positive<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt;     var signum: NumberType {<br>&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;         case .Negative:<br>&gt;&gt;&gt;             return -1 as NumberType<br>&gt;&gt;&gt;         case .Zero:<br>&gt;&gt;&gt;             return 0 as NumberType<br>&gt;&gt;&gt;         case .Positive:<br>&gt;&gt;&gt;             return 1 as NumberType<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; 	<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;&gt;         if self == 0 {<br>&gt;&gt;&gt;             return .Zero<br>&gt;&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;&gt;             return .Positive<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             return .Negative<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if myValue.sign &gt; 0 { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I could just as easily do:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	if myValue &gt; 0 { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Howdy,<br>&gt;&gt;&gt;&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;&gt;   var sign: Self {<br>&gt;&gt;&gt;&gt;&gt;     if self == 0 {<br>&gt;&gt;&gt;&gt;&gt;       return 0<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;&gt;       return 1<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/21e7709d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 24, 2016 at 08:00:00am</p></header><div class="content"><p>Yes, but here, the rawValue is Int - in my code, the rawValue is NumberType, which IMHO makes more sense...<br></p><p>&gt; On May 24, 2016, at 7:36 AM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; Sorry, I misspoke. I just meant define it like this:<br>&gt; public enum IntegerSign&lt;T: SignedIntegerType&gt; : Int {<br>&gt;     case Negative = -1<br>&gt;     case Zero = 0<br>&gt;     case Positive = 1<br>&gt;     public var signum: T {<br>&gt;         return T(self.rawValue.toIntMax())<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; Although, come to think of it, I’m not sure if that’s an exact drop-in replacement for your code, since it’s `SignedIntegerType` instead of `SignedNumberType`<br>&gt; <br>&gt; -Dave Sweeris<br>&gt; <br>&gt;&gt; On May 23, 2016, at 11:48 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sure, that&#39;s a good idea, though I&#39;d personally use the signum var, since using rawValue seems like a bit of an abuse of the fact the enum is defined this way and doesn&#39;t help readability of the code:<br>&gt;&gt; <br>&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt;: RawRepresentable {<br>&gt;&gt; <br>&gt;&gt;     case Negative<br>&gt;&gt;     case Zero<br>&gt;&gt;     case Positive<br>&gt;&gt;     <br>&gt;&gt;     init?(rawValue: NumberType) {<br>&gt;&gt;         if rawValue == -1 {<br>&gt;&gt;             self = .Negative<br>&gt;&gt;         } else if rawValue == 0 {<br>&gt;&gt;             self = .Zero<br>&gt;&gt;         } else if rawValue == 1 {<br>&gt;&gt;             self = .Positive<br>&gt;&gt;         } else {<br>&gt;&gt;             return nil<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var rawValue: NumberType {<br>&gt;&gt;         return self.signum<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     var signum: NumberType {<br>&gt;&gt;         switch self {<br>&gt;&gt;         case .Negative:<br>&gt;&gt;             return -1 as NumberType<br>&gt;&gt;         case .Zero:<br>&gt;&gt;             return 0 as NumberType<br>&gt;&gt;         case .Positive:<br>&gt;&gt;             return 1 as NumberType<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SignedNumberType {<br>&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;         if self == 0 {<br>&gt;&gt;             return .Zero<br>&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;             return .Positive<br>&gt;&gt;         } else {<br>&gt;&gt;             return .Negative<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 24, 2016, at 6:09 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can we make it RawRepresentable? That way signum can just return self.rawValue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 06:05, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     case Negative<br>&gt;&gt;&gt;&gt;     case Zero<br>&gt;&gt;&gt;&gt;     case Positive<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;     var signum: NumberType {<br>&gt;&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;&gt;         case .Negative:<br>&gt;&gt;&gt;&gt;             return -1 as NumberType<br>&gt;&gt;&gt;&gt;         case .Zero:<br>&gt;&gt;&gt;&gt;             return 0 as NumberType<br>&gt;&gt;&gt;&gt;         case .Positive:<br>&gt;&gt;&gt;&gt;             return 1 as NumberType<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;         if self == 0 {<br>&gt;&gt;&gt;&gt;             return .Zero<br>&gt;&gt;&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;             return .Positive<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;             return .Negative<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	if myValue.sign &gt; 0 { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I could just as easily do:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	if myValue &gt; 0 { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Howdy,<br>&gt;&gt;&gt;&gt;&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;&gt;&gt;   var sign: Self {<br>&gt;&gt;&gt;&gt;&gt;&gt;     if self == 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;       return 0<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;       return 1<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/dcab9226/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>The RawValue is an Int, but signum is a T, which I thought was the point. I tried saying `T: IntegerLiteralConvertible`, and making RawValue = T, but the playground didn’t like that. Maybe with some of Swift 3’s generic enhancements, it could be that simple.<br></p><p>In any case, it sounds like this might be a moot point… I was hoping raw values could be exploited to simplify the code, but if it can’t work, it can’t work.<br></p><p>- Dave Sweeris<br></p><p>&gt; On May 24, 2016, at 1:41 AM, Charlie Monroe &lt;charlie at charliemonroe.net&gt; wrote:<br>&gt; <br>&gt; Yes, but here, the rawValue is Int - in my code, the rawValue is NumberType, which IMHO makes more sense...<br>&gt; <br>&gt;&gt; On May 24, 2016, at 7:36 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sorry, I misspoke. I just meant define it like this:<br>&gt;&gt; public enum IntegerSign&lt;T: SignedIntegerType&gt; : Int {<br>&gt;&gt;     case Negative = -1<br>&gt;&gt;     case Zero = 0<br>&gt;&gt;     case Positive = 1<br>&gt;&gt;     public var signum: T {<br>&gt;&gt;         return T(self.rawValue.toIntMax())<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Although, come to think of it, I’m not sure if that’s an exact drop-in replacement for your code, since it’s `SignedIntegerType` instead of `SignedNumberType`<br>&gt;&gt; <br>&gt;&gt; -Dave Sweeris<br>&gt;&gt; <br>&gt;&gt;&gt; On May 23, 2016, at 11:48 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sure, that&#39;s a good idea, though I&#39;d personally use the signum var, since using rawValue seems like a bit of an abuse of the fact the enum is defined this way and doesn&#39;t help readability of the code:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt;: RawRepresentable {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     case Negative<br>&gt;&gt;&gt;     case Zero<br>&gt;&gt;&gt;     case Positive<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init?(rawValue: NumberType) {<br>&gt;&gt;&gt;         if rawValue == -1 {<br>&gt;&gt;&gt;             self = .Negative<br>&gt;&gt;&gt;         } else if rawValue == 0 {<br>&gt;&gt;&gt;             self = .Zero<br>&gt;&gt;&gt;         } else if rawValue == 1 {<br>&gt;&gt;&gt;             self = .Positive<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var rawValue: NumberType {<br>&gt;&gt;&gt;         return self.signum<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     var signum: NumberType {<br>&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;         case .Negative:<br>&gt;&gt;&gt;             return -1 as NumberType<br>&gt;&gt;&gt;         case .Zero:<br>&gt;&gt;&gt;             return 0 as NumberType<br>&gt;&gt;&gt;         case .Positive:<br>&gt;&gt;&gt;             return 1 as NumberType<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;&gt;         if self == 0 {<br>&gt;&gt;&gt;             return .Zero<br>&gt;&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;&gt;             return .Positive<br>&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;             return .Negative<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 24, 2016, at 6:09 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can we make it RawRepresentable? That way signum can just return self.rawValue<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 23, 2016, at 06:05, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     case Negative<br>&gt;&gt;&gt;&gt;&gt;     case Zero<br>&gt;&gt;&gt;&gt;&gt;     case Positive<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;     var signum: NumberType {<br>&gt;&gt;&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;&gt;&gt;         case .Negative:<br>&gt;&gt;&gt;&gt;&gt;             return -1 as NumberType<br>&gt;&gt;&gt;&gt;&gt;         case .Zero:<br>&gt;&gt;&gt;&gt;&gt;             return 0 as NumberType<br>&gt;&gt;&gt;&gt;&gt;         case .Positive:<br>&gt;&gt;&gt;&gt;&gt;             return 1 as NumberType<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;&gt;         if self == 0 {<br>&gt;&gt;&gt;&gt;&gt;             return .Zero<br>&gt;&gt;&gt;&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;&gt;             return .Positive<br>&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;             return .Negative<br>&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if myValue.sign &gt; 0 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I could just as easily do:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	if myValue &gt; 0 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Howdy,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var sign: Self {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     if self == 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/88381957/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 25, 2016 at 01:00:00pm</p></header><div class="content"><p>Ok, how about this? The compiler currently crashes when compiling this, but IMHO it is (or should be) valid code.<br></p><p>enum IntegerSign&lt;NumberType: SignedNumberType&gt;: NumberType {<br>    <br>    case Negative = -1<br>    case Zero = 0<br>    case Positive = 1<br>    <br>    var signum: NumberType {<br>        return self.rawValue<br>    }<br>    <br>}<br></p><p>extension SignedNumberType {<br>    var sign: IntegerSign&lt;Self&gt; {<br>        if self == 0 {<br>            return .Zero<br>        } else if self &gt; 0 {<br>            return .Positive<br>        } else {<br>            return .Negative<br>        }<br>    }<br>}<br></p><p><br></p><p><br>&gt; On May 24, 2016, at 8:48 PM, David Sweeris &lt;davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt; The RawValue is an Int, but signum is a T, which I thought was the point. I tried saying `T: IntegerLiteralConvertible`, and making RawValue = T, but the playground didn’t like that. Maybe with some of Swift 3’s generic enhancements, it could be that simple.<br>&gt; <br>&gt; In any case, it sounds like this might be a moot point… I was hoping raw values could be exploited to simplify the code, but if it can’t work, it can’t work.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; On May 24, 2016, at 1:41 AM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, but here, the rawValue is Int - in my code, the rawValue is NumberType, which IMHO makes more sense...<br>&gt;&gt; <br>&gt;&gt;&gt; On May 24, 2016, at 7:36 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, I misspoke. I just meant define it like this:<br>&gt;&gt;&gt; public enum IntegerSign&lt;T: SignedIntegerType&gt; : Int {<br>&gt;&gt;&gt;     case Negative = -1<br>&gt;&gt;&gt;     case Zero = 0<br>&gt;&gt;&gt;     case Positive = 1<br>&gt;&gt;&gt;     public var signum: T {<br>&gt;&gt;&gt;         return T(self.rawValue.toIntMax())<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Although, come to think of it, I’m not sure if that’s an exact drop-in replacement for your code, since it’s `SignedIntegerType` instead of `SignedNumberType`<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 23, 2016, at 11:48 PM, Charlie Monroe &lt;charlie at charliemonroe.net &lt;mailto:charlie at charliemonroe.net&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sure, that&#39;s a good idea, though I&#39;d personally use the signum var, since using rawValue seems like a bit of an abuse of the fact the enum is defined this way and doesn&#39;t help readability of the code:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt;: RawRepresentable {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     case Negative<br>&gt;&gt;&gt;&gt;     case Zero<br>&gt;&gt;&gt;&gt;     case Positive<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init?(rawValue: NumberType) {<br>&gt;&gt;&gt;&gt;         if rawValue == -1 {<br>&gt;&gt;&gt;&gt;             self = .Negative<br>&gt;&gt;&gt;&gt;         } else if rawValue == 0 {<br>&gt;&gt;&gt;&gt;             self = .Zero<br>&gt;&gt;&gt;&gt;         } else if rawValue == 1 {<br>&gt;&gt;&gt;&gt;             self = .Positive<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;             return nil<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var rawValue: NumberType {<br>&gt;&gt;&gt;&gt;         return self.signum<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     var signum: NumberType {<br>&gt;&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;&gt;         case .Negative:<br>&gt;&gt;&gt;&gt;             return -1 as NumberType<br>&gt;&gt;&gt;&gt;         case .Zero:<br>&gt;&gt;&gt;&gt;             return 0 as NumberType<br>&gt;&gt;&gt;&gt;         case .Positive:<br>&gt;&gt;&gt;&gt;             return 1 as NumberType<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;         if self == 0 {<br>&gt;&gt;&gt;&gt;             return .Zero<br>&gt;&gt;&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;             return .Positive<br>&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;             return .Negative<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 24, 2016, at 6:09 AM, David Sweeris &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can we make it RawRepresentable? That way signum can just return self.rawValue<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 06:05, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The clean way would be to make it an enum with var signum that would return -1, 0, 1:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum IntegerSign&lt;NumberType: SignedNumberType&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     case Negative<br>&gt;&gt;&gt;&gt;&gt;&gt;     case Zero<br>&gt;&gt;&gt;&gt;&gt;&gt;     case Positive<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt;     var signum: NumberType {<br>&gt;&gt;&gt;&gt;&gt;&gt;         switch self {<br>&gt;&gt;&gt;&gt;&gt;&gt;         case .Negative:<br>&gt;&gt;&gt;&gt;&gt;&gt;             return -1 as NumberType<br>&gt;&gt;&gt;&gt;&gt;&gt;         case .Zero:<br>&gt;&gt;&gt;&gt;&gt;&gt;             return 0 as NumberType<br>&gt;&gt;&gt;&gt;&gt;&gt;         case .Positive:<br>&gt;&gt;&gt;&gt;&gt;&gt;             return 1 as NumberType<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; 	<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;&gt;&gt;     var sign: IntegerSign&lt;Self&gt; {<br>&gt;&gt;&gt;&gt;&gt;&gt;         if self == 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;             return .Zero<br>&gt;&gt;&gt;&gt;&gt;&gt;         } else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;             return .Positive<br>&gt;&gt;&gt;&gt;&gt;&gt;         } else {<br>&gt;&gt;&gt;&gt;&gt;&gt;             return .Negative<br>&gt;&gt;&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Charlie<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On May 23, 2016, at 9:29 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Could you give an example of this method’s usage? Surely your value is either positive, negative or zero already, so this method doesn’t return anything more useful.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In other words, anywhere that I might do this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if myValue.sign &gt; 0 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I could just as easily do:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	if myValue &gt; 0 { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; To the same end result surely? Unless I’m missing something it seems redundant.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; If there is a use-case for this, would it make more sense to have the return type as an enum with cases for Positive, Negative and Zero?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 22 May 2016, at 08:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Howdy,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The implementation is fairly straight forward<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   var sign: Self {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     if self == 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return 0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     else if self &gt; 0 {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;       return 1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     return -1<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/759ba6ff/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/4ab486d7597af4cfe0be33a762150848?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Dany St-Amant</string> &lt;dsa.mls at icloud.com&gt;<p>May 23, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; Le 22 mai 2016 à 03:07, Adam Nemecek via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Howdy,<br>&gt; I think that the SignedNumberType should implement a method called sign that will return -1 for negative numbers, 0 for 0 and 1 for positive numbers. This is similar to the signum method in e.g. Java and similarly called methods in other languages.<br>&gt; <br>&gt; The implementation is fairly straight forward<br>&gt; <br>&gt; extension SignedNumberType {<br>&gt;   var sign: Self {<br>&gt;     if self == 0 {<br>&gt;       return 0<br>&gt;     }<br>&gt;     else if self &gt; 0 {<br>&gt;       return 1<br>&gt;     }<br>&gt;     return -1<br>&gt;   }<br>&gt; } <br>&gt; <br>&gt; I was trying to implement is without branching by doing (x &gt; 0) - (x &lt; 0) but I couldn&#39;t get the types right so I&#39;m open to suggestions.<br>&gt; <br></p><p>Challenge accepted… Removed the if/else if, at the cost of double function call to a tri-op:<br></p><p>extension Bool {<br>    func as01&lt;T:SignedNumberType&gt;() -&gt; T { return self ? 1 : 0 }<br>}<br></p><p>extension SignedNumberType {<br>    var sign: Self { return (self &gt; 0).as01() - (self &lt; 0).as01() }<br>}<br></p><p><br>Dany<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160523/81a73fdf/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 24, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 23 May 2016, at 20:19, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Challenge accepted… Removed the if/else if, at the cost of double function call to a tri-op:<br>&gt; <br>&gt; extension Bool {<br>&gt;     func as01&lt;T:SignedNumberType&gt;() -&gt; T { return self ? 1 : 0 }<br>&gt; }<br>&gt; <br>&gt; extension SignedNumberType {<br>&gt;     var sign: Self { return (self &gt; 0).as01() - (self &lt; 0).as01() }<br>&gt; }<br></p><p>I don’t believe this solves the problem; I think you’ve really just moved the branching into the as01() method.<br></p><p>I think the more correct solution would be for all integer types to have a required Bool initialiser in a protocol somewhere, this way you could just do:<br></p><p>	var sign:Self { return Self(boolValue: self &gt; 0) - Self(boolValue: self &lt; 0) }<br></p><p>Since all integer types should be able to do this by just extending the value to fit, rather than testing it. I’m not completely up-to-date on the integer changes that will be in Swift 3, but perhaps conversion from bool will be easier in future, in Swift 2.2 it’s not really treated as a number type for conversion purposes, which is disappointing.<br></p><p>Also apologies for my initial misunderstanding of the need for this sign property, no idea how I managed to get such a mental block as it’s obviously very useful for multiplication when account for sign and a few other cases. Anyway, I’m a +1, though implementation is definitely trickier than it seems it should be, thanks to some of Swift’s number-related quirks!<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/41290a30/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>May 24, 2016 at 01:00:00pm</p></header><div class="content"><p>That depends... Does “x = a ? b : c” and &quot;if a {x = b} else {x = c}” compile down to the same machine code? I know of one arch where “?:” takes 0 cycles, but I don’t know if there’s a difference on x86 or ARM.<br></p><p>Either way, I’d think that just doing the comparison within `sign` would be faster, since it doesn’t create two extra Bools and SignedNumberTypes.<br></p><p>- Dave Sweeris<br></p><p>&gt; On May 24, 2016, at 6:33 AM, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 23 May 2016, at 20:19, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Challenge accepted… Removed the if/else if, at the cost of double function call to a tri-op:<br>&gt;&gt; <br>&gt;&gt; extension Bool {<br>&gt;&gt;     func as01&lt;T:SignedNumberType&gt;() -&gt; T { return self ? 1 : 0 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SignedNumberType {<br>&gt;&gt;     var sign: Self { return (self &gt; 0).as01() - (self &lt; 0).as01() }<br>&gt;&gt; }<br>&gt; <br>&gt; I don’t believe this solves the problem; I think you’ve really just moved the branching into the as01() method.<br>&gt; <br>&gt; I think the more correct solution would be for all integer types to have a required Bool initialiser in a protocol somewhere, this way you could just do:<br>&gt; <br>&gt; 	var sign:Self { return Self(boolValue: self &gt; 0) - Self(boolValue: self &lt; 0) }<br>&gt; <br>&gt; Since all integer types should be able to do this by just extending the value to fit, rather than testing it. I’m not completely up-to-date on the integer changes that will be in Swift 3, but perhaps conversion from bool will be easier in future, in Swift 2.2 it’s not really treated as a number type for conversion purposes, which is disappointing.<br>&gt; <br>&gt; Also apologies for my initial misunderstanding of the need for this sign property, no idea how I managed to get such a mental block as it’s obviously very useful for multiplication when account for sign and a few other cases. Anyway, I’m a +1, though implementation is definitely trickier than it seems it should be, thanks to some of Swift’s number-related quirks!<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160524/f8e00612/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/be09ed656d5d90501c958b001261f218?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Jeremy Pereira</string> &lt;jeremy.j.pereira at googlemail.com&gt;<p>May 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On 24 May 2016, at 12:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 23 May 2016, at 20:19, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Challenge accepted… Removed the if/else if, at the cost of double function call to a tri-op:<br>&gt;&gt; <br>&gt;&gt; extension Bool {<br>&gt;&gt;     func as01&lt;T:SignedNumberType&gt;() -&gt; T { return self ? 1 : 0 }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SignedNumberType {<br>&gt;&gt;     var sign: Self { return (self &gt; 0).as01() - (self &lt; 0).as01() }<br>&gt;&gt; }<br>&gt; <br>&gt; I don’t believe this solves the problem; I think you’ve really just moved the branching into the as01() method.<br>&gt; <br>&gt; I think the more correct solution would be for all integer types to have a required Bool initialiser in a protocol somewhere, this way you could just do:<br>&gt; <br>&gt; 	var sign:Self { return Self(boolValue: self &gt; 0) - Self(boolValue: self &lt; 0) }<br></p><p>Aren’t you just hiding the branches in the initialiser there?<br></p><p>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Add the sign method to the SignedNumberType protocol.</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>May 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On 25 May 2016, at 16:51, Jeremy Pereira &lt;jeremy.j.pereira at googlemail.com&gt; wrote:<br>&gt;&gt; On 24 May 2016, at 12:33, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; On 23 May 2016, at 20:19, Dany St-Amant via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Challenge accepted… Removed the if/else if, at the cost of double function call to a tri-op:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Bool {<br>&gt;&gt;&gt;    func as01&lt;T:SignedNumberType&gt;() -&gt; T { return self ? 1 : 0 }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension SignedNumberType {<br>&gt;&gt;&gt;    var sign: Self { return (self &gt; 0).as01() - (self &lt; 0).as01() }<br>&gt;&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; I don’t believe this solves the problem; I think you’ve really just moved the branching into the as01() method.<br>&gt;&gt; <br>&gt;&gt; I think the more correct solution would be for all integer types to have a required Bool initialiser in a protocol somewhere, this way you could just do:<br>&gt;&gt; <br>&gt;&gt; 	var sign:Self { return Self(boolValue: self &gt; 0) - Self(boolValue: self &lt; 0) }<br>&gt; <br>&gt; Aren’t you just hiding the branches in the initialiser there?<br></p><p>Shouldn’t have to but possibly yeah; the booleans are just 1-bit values, so they can be extended to fit any integer type, but currently the ability to convert them seems lacking. There’s supposed to be something being done about improving the ability to use numeric types interchangeably (e.g- you should be able to freely fire an Int16 into an Int32 with implicit casting since it definitely fits), but I don’t know if Bool will be included in that or not.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160525/db6adcd1/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
