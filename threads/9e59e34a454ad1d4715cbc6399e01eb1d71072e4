<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 26, 2016 at 08:00:00pm</p></header><div class="content"><p>Can’t a Sequence be potentially infinite, whereas a collection has a defined count/endIndex?  Other than that, I agree with your statement.<br></p><p>Here is what I see as the appropriate structure:<br></p><p>Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>Sequence: Guaranteed non-destructive multi-pass (vends Iterators), potentially infinite, (should be subscript-able, gain most of collection, but lose anything that relies on it ending)<br>Collection: Multi-pass, guaranteed finite, (no changes from current form, except extra inits from Iterator/Sequence with end conditions)<br></p><p>Right now we are allowed to have an infinite sequence, but calling dropLast or non-lazy map will cause an infinite loop.  These cases could be made much safer by considering the potentially infinite and finite cases separately...<br></p><p>Thanks,<br>Jon<br></p><p>&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; &gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt; &gt;<br>&gt; &gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt; &gt;<br>&gt; &gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt; &gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt; &gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt; &gt;&gt; <br>&gt; &gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt; &gt;&gt; detail here:<br>&gt; &gt;&gt; <br>&gt; &gt;&gt; * Would you remove Sequence?<br>&gt; &gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt; &gt; No, I would just remove the allowance in the documentation and API<br>&gt; &gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt; &gt; interface to getting access to repeatable iteration, without the need<br>&gt; &gt; for meeting the other requirements for Collection.<br>&gt; <br>&gt; That would be wrong unless there exist substantial examples of a<br>&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt; trivial to prove that no such examples exist.<br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160626/9e5972e4/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can’t a Sequence be potentially infinite, whereas a collection has a defined count/endIndex?  Other than that, I agree with your statement.<br>&gt; <br>&gt; Here is what I see as the appropriate structure:<br>&gt; <br>&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators), potentially infinite, (should be subscript-able, gain most of collection, but lose anything that relies on it ending)<br>&gt; Collection: Multi-pass, guaranteed finite, (no changes from current form, except extra inits from Iterator/Sequence with end conditions)<br>&gt; <br>&gt; Right now we are allowed to have an infinite sequence, but calling dropLast or non-lazy map will cause an infinite loop.  These cases could be made much safer by considering the potentially infinite and finite cases separately…<br></p><p>I think this is pointing in the right general direction.  It would make working with `Sequence` much more straightforward and allow us to depend on the multi-pass property that is true in practice of the most common models of `Sequence`.<br></p><p>But I agree that we should give much more careful consideration to finite / infinite generally and for..in specifically.<br></p><p>Now that I have been thinking about the finite / infinite distinction more closely I have begun to notice a lot of code that is written generically using `Sequence` where a for..in loop is really what is required, however the “finite sequence” precondition is not explicitly stated.  Interestingly, this is the case with the standard library’s eager `map` (but not the case with `dropLast` which explicitly notes the precondition).  I have been somewhat surprised to realize how common this “bug” is (i.e. not stating a precondition).  I think we have gotten away with it thus far because the sequences most people use most of the time in practice are finite.  But that doesn’t mean we should accept this as good enough - IMO it is way to easy to forget to document this precondition (and obviously easier for users to overlook than preconditions that are actually encoded in the type system, violations of which are caught at compile time).<br></p><p>The fact that this pattern is so pervasive is what I meant when I said for..in “naturally” requires a finite sequence. <br></p><p>IMO it’s better to encode preconditions in the type system when that is practical, and especially when the precondition is shared by a vast majority of code written using a particular construct (in this case a for..in loop written using the most generic for..in-able protocol).<br></p><p>I think the safest solution is to take the position that writing an infinite loop is relatively uncommon and is a more “advanced” technique, and thus should be done explicitly.  Do people really write infinite loops often enough that the convenience of using for..in when writing infinite loops outweighs the safety benefit of preventing accidental infinite loops?  I haven’t seen a compelling argument for this.  <br></p><p>If we adopt that position then for..in would need to be built on top of a guaranteed finite construct.  This would allow programmers to continue writing generic code agains the most generic for..in-able construct while eliminating a precondition that is often (usually?) unstated and likely unconsidered.  <br></p><p>If we do decide to move forward with infinite for..in loops I think we need to establish strong guidance around how to properly write generic code with these protocols.  Should such code really be constrained to `Collection` rather than `Sequence` (i.e. should a potentially infinite `Sequence` have an eager map)?  If this is the guidance, should it be paired with guidance that all finite sequences should conform to `Collection`?  Or is it sufficient to just educate developers about this issue and expect people to document the “finite Sequence” precondition when the constraint is `Sequence` rather than `Collection`?  <br></p><p>I hope we will give serious consideration to these questions while this topic is open for discussion.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com &lt;http://david-at-alkaline-solutions.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt; &gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt; &gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt; &gt;&gt; detail here:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; * Would you remove Sequence?<br>&gt;&gt; &gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt; &gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt; &gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt; &gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt; &gt; for meeting the other requirements for Collection.<br>&gt;&gt; <br>&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/73aacecc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt; defined count/endIndex?  Other than that, I agree with your<br>&gt;<br>&gt;&gt; statement.<br>&gt;&gt; <br>&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt; <br>&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt; <br>&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt; finite cases separately…<br>&gt;<br>&gt; I think this is pointing in the right general direction.  It would<br>&gt; make working with `Sequence` much more straightforward and allow us to<br>&gt; depend on the multi-pass property that is true in practice of the most<br>&gt; common models of `Sequence`.<br>&gt;<br>&gt; But I agree that we should give much more careful consideration to<br>&gt; finite / infinite generally and for..in specifically.<br>&gt;<br>&gt; Now that I have been thinking about the finite / infinite distinction<br>&gt; more closely I have begun to notice a lot of code that is written<br>&gt; generically using `Sequence` where a for..in loop is really what is<br>&gt; required, however the “finite sequence” precondition is not explicitly<br>&gt; stated.  Interestingly, this is the case with the standard library’s<br>&gt; eager `map` (but not the case with `dropLast` which explicitly notes<br>&gt; the precondition).  I have been somewhat surprised to realize how<br>&gt; common this “bug” is (i.e. not stating a precondition).  I think we<br>&gt; have gotten away with it thus far because the sequences most people<br>&gt; use most of the time in practice are finite.  But that doesn’t mean we<br>&gt; should accept this as good enough - IMO it is way to easy to forget to<br>&gt; document this precondition (and obviously easier for users to overlook<br>&gt; than preconditions that are actually encoded in the type system,<br>&gt; violations of which are caught at compile time).<br>&gt;<br>&gt; The fact that this pattern is so pervasive is what I meant when I said<br>&gt; for..in “naturally” requires a finite sequence.<br>&gt;<br>&gt; IMO it’s better to encode preconditions in the type system when that<br>&gt; is practical, and especially when the precondition is shared by a vast<br>&gt; majority of code written using a particular construct (in this case a<br>&gt; for..in loop written using the most generic for..in-able protocol).<br>&gt;<br>&gt; I think the safest solution is to take the position that writing an<br>&gt; infinite loop is relatively uncommon and is a more “advanced”<br>&gt; technique, and thus should be done explicitly.  Do people really write<br>&gt; infinite loops often enough that the convenience of using for..in when<br>&gt; writing infinite loops outweighs the safety benefit of preventing<br>&gt; accidental infinite loops?  I haven’t seen a compelling argument for<br>&gt; this.<br></p><p>Good questions.  I&#39;d also add: “do infinite sequences come up often<br>enough that accidentally looping on them forever is a problem?”<br></p><p>&gt; If we adopt that position then for..in would need to be built on top<br>&gt; of a guaranteed finite construct.  This would allow programmers to<br>&gt; continue writing generic code agains the most generic for..in-able<br>&gt; construct while eliminating a precondition that is often (usually?)<br>&gt; unstated and likely unconsidered.<br>&gt;<br>&gt; If we do decide to move forward with infinite for..in loops I think we<br>&gt; need to establish strong guidance around how to properly write generic<br>&gt; code with these protocols.  Should such code really be constrained to<br>&gt; `Collection` rather than `Sequence` (i.e. should a potentially<br>&gt; infinite `Sequence` have an eager map)?  If this is the guidance,<br>&gt; should it be paired with guidance that all finite sequences should<br>&gt; conform to `Collection`?  Or is it sufficient to just educate<br>&gt; developers about this issue and expect people to document the “finite<br>&gt; Sequence” precondition when the constraint is `Sequence` rather than<br>&gt; `Collection`?<br>&gt;<br>&gt; I hope we will give serious consideration to these questions while<br>&gt; this topic is open for discussion.<br>&gt;<br>&gt; -Matthew<br>&gt;<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com<br>&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt; &gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt; &gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt; &gt;&gt; detail here:<br>&gt;&gt;&gt; &gt;&gt; <br>&gt;&gt;&gt; &gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt; &gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt; &gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt; &gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt; &gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt; &gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your<br>&gt;&gt; <br>&gt;&gt;&gt; statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt; finite cases separately…<br>&gt;&gt; <br>&gt;&gt; I think this is pointing in the right general direction.  It would<br>&gt;&gt; make working with `Sequence` much more straightforward and allow us to<br>&gt;&gt; depend on the multi-pass property that is true in practice of the most<br>&gt;&gt; common models of `Sequence`.<br>&gt;&gt; <br>&gt;&gt; But I agree that we should give much more careful consideration to<br>&gt;&gt; finite / infinite generally and for..in specifically.<br>&gt;&gt; <br>&gt;&gt; Now that I have been thinking about the finite / infinite distinction<br>&gt;&gt; more closely I have begun to notice a lot of code that is written<br>&gt;&gt; generically using `Sequence` where a for..in loop is really what is<br>&gt;&gt; required, however the “finite sequence” precondition is not explicitly<br>&gt;&gt; stated.  Interestingly, this is the case with the standard library’s<br>&gt;&gt; eager `map` (but not the case with `dropLast` which explicitly notes<br>&gt;&gt; the precondition).  I have been somewhat surprised to realize how<br>&gt;&gt; common this “bug” is (i.e. not stating a precondition).  I think we<br>&gt;&gt; have gotten away with it thus far because the sequences most people<br>&gt;&gt; use most of the time in practice are finite.  But that doesn’t mean we<br>&gt;&gt; should accept this as good enough - IMO it is way to easy to forget to<br>&gt;&gt; document this precondition (and obviously easier for users to overlook<br>&gt;&gt; than preconditions that are actually encoded in the type system,<br>&gt;&gt; violations of which are caught at compile time).<br>&gt;&gt; <br>&gt;&gt; The fact that this pattern is so pervasive is what I meant when I said<br>&gt;&gt; for..in “naturally” requires a finite sequence.<br>&gt;&gt; <br>&gt;&gt; IMO it’s better to encode preconditions in the type system when that<br>&gt;&gt; is practical, and especially when the precondition is shared by a vast<br>&gt;&gt; majority of code written using a particular construct (in this case a<br>&gt;&gt; for..in loop written using the most generic for..in-able protocol).<br>&gt;&gt; <br>&gt;&gt; I think the safest solution is to take the position that writing an<br>&gt;&gt; infinite loop is relatively uncommon and is a more “advanced”<br>&gt;&gt; technique, and thus should be done explicitly.  Do people really write<br>&gt;&gt; infinite loops often enough that the convenience of using for..in when<br>&gt;&gt; writing infinite loops outweighs the safety benefit of preventing<br>&gt;&gt; accidental infinite loops?  I haven’t seen a compelling argument for<br>&gt;&gt; this.<br>&gt; <br>&gt; Good questions.  I&#39;d also add: “do infinite sequences come up often<br>&gt; enough that accidentally looping on them forever is a problem?”<br></p><p>That’s a good question as well.  In practice the frequency of infinite sequences likely depends on the domain.<br></p><p>IMO this falls into the same category as “do single pass sequences come up often enough that attempting to iterate over them twice is a problem.  To paraphrase your previous post:<br></p><p>&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt; (you can’t assume it is finite!) on it, so they write libraries<br>&gt; of functions that may iterate a Sequence to termination.  They test<br>&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt; and Ranges, which happen to be finite.  Their tests pass!  But their<br>&gt; constraints are wrong, their whole model of how to write generic code<br>&gt; over sequences is wrong, and some of their code is wrong.<br>&gt; <br>&gt; IMO this is a problematic programming model.<br></p><p><br>I definitely don’t mean to put words in your mouth here, but the logical structure of the argument appears identical to me regardless of which issue it is applied to.  I am only trying to make that point.<br></p><p>&gt; <br>&gt;&gt; If we adopt that position then for..in would need to be built on top<br>&gt;&gt; of a guaranteed finite construct.  This would allow programmers to<br>&gt;&gt; continue writing generic code agains the most generic for..in-able<br>&gt;&gt; construct while eliminating a precondition that is often (usually?)<br>&gt;&gt; unstated and likely unconsidered.<br>&gt;&gt; <br>&gt;&gt; If we do decide to move forward with infinite for..in loops I think we<br>&gt;&gt; need to establish strong guidance around how to properly write generic<br>&gt;&gt; code with these protocols.  Should such code really be constrained to<br>&gt;&gt; `Collection` rather than `Sequence` (i.e. should a potentially<br>&gt;&gt; infinite `Sequence` have an eager map)?  If this is the guidance,<br>&gt;&gt; should it be paired with guidance that all finite sequences should<br>&gt;&gt; conform to `Collection`?  Or is it sufficient to just educate<br>&gt;&gt; developers about this issue and expect people to document the “finite<br>&gt;&gt; Sequence” precondition when the constraint is `Sequence` rather than<br>&gt;&gt; `Collection`?<br>&gt;&gt; <br>&gt;&gt; I hope we will give serious consideration to these questions while<br>&gt;&gt; this topic is open for discussion.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com<br>&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a2c4c655/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 12:00:00pm</p></header><div class="content"><p>on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; statement.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt;&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt;&gt; finite cases separately…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think this is pointing in the right general direction.  It would<br>&gt;&gt;&gt; make working with `Sequence` much more straightforward and allow us to<br>&gt;&gt;&gt; depend on the multi-pass property that is true in practice of the most<br>&gt;&gt;&gt; common models of `Sequence`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But I agree that we should give much more careful consideration to<br>&gt;&gt;&gt; finite / infinite generally and for..in specifically.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now that I have been thinking about the finite / infinite distinction<br>&gt;&gt;&gt; more closely I have begun to notice a lot of code that is written<br>&gt;&gt;&gt; generically using `Sequence` where a for..in loop is really what is<br>&gt;&gt;&gt; required, however the “finite sequence” precondition is not explicitly<br>&gt;&gt;&gt; stated.  Interestingly, this is the case with the standard library’s<br>&gt;&gt;&gt; eager `map` (but not the case with `dropLast` which explicitly notes<br>&gt;&gt;&gt; the precondition).  I have been somewhat surprised to realize how<br>&gt;&gt;&gt; common this “bug” is (i.e. not stating a precondition).  I think we<br>&gt;&gt;&gt; have gotten away with it thus far because the sequences most people<br>&gt;&gt;&gt; use most of the time in practice are finite.  But that doesn’t mean we<br>&gt;&gt;&gt; should accept this as good enough - IMO it is way to easy to forget to<br>&gt;&gt;&gt; document this precondition (and obviously easier for users to overlook<br>&gt;&gt;&gt; than preconditions that are actually encoded in the type system,<br>&gt;&gt;&gt; violations of which are caught at compile time).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that this pattern is so pervasive is what I meant when I said<br>&gt;&gt;&gt; for..in “naturally” requires a finite sequence.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO it’s better to encode preconditions in the type system when that<br>&gt;&gt;&gt; is practical, and especially when the precondition is shared by a vast<br>&gt;&gt;&gt; majority of code written using a particular construct (in this case a<br>&gt;&gt;&gt; for..in loop written using the most generic for..in-able protocol).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think the safest solution is to take the position that writing an<br>&gt;&gt;&gt; infinite loop is relatively uncommon and is a more “advanced”<br>&gt;&gt;&gt; technique, and thus should be done explicitly.  Do people really write<br>&gt;&gt;&gt; infinite loops often enough that the convenience of using for..in when<br>&gt;&gt;&gt; writing infinite loops outweighs the safety benefit of preventing<br>&gt;&gt;&gt; accidental infinite loops?  I haven’t seen a compelling argument for<br>&gt;&gt;&gt; this.<br>&gt;&gt; <br>&gt;&gt; Good questions.  I&#39;d also add: “do infinite sequences come up often<br>&gt;&gt; enough that accidentally looping on them forever is a problem?”<br>&gt;<br>&gt; That’s a good question as well.  In practice the frequency of infinite<br>&gt; sequences likely depends on the domain.<br>&gt;<br>&gt; IMO this falls into the same category as “do single pass sequences<br>&gt; come up often enough that attempting to iterate over them twice is a<br>&gt; problem.  To paraphrase your previous post:<br>&gt;<br>&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt; (you can’t assume it is finite!) on it, so they write libraries<br>&gt;&gt; of functions that may iterate a Sequence to termination.  They test<br>&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt; and Ranges, which happen to be finite.  Their tests pass!  But their<br>&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt; <br>&gt;&gt; IMO this is a problematic programming model.<br>&gt;<br>&gt; I definitely don’t mean to put words in your mouth here, but the<br>&gt; logical structure of the argument appears identical to me regardless<br>&gt; of which issue it is applied to.  I am only trying to make that point.<br></p><p>Oh, I fully agree.  We&#39;re *in* this discussion because neither<br>single-pass nor infinite sequences come up very often.  It raises the<br>question of whether the conceptual framework ought to accomodate them at<br>all, and if they should be included, how they should be represented.<br></p><p>The quotation you cited above isn&#39;t arguing that single-pass sequences<br>are important enough to represent.  It is trying to point out that the<br>refinement relationship between single- and multipass sequences has an<br>undesirable effect.  I&#39;m certain the same thing could occur for infinite<br>and finite sequences.<br></p><p>FWIW, Max pointed out to me on Friday that Scala&#39;s concept for<br>possibly-single-pass sequences is called “TraversibleOnce.”  I think<br>that name goes a long way to solving the problem.  I&#39;m not sure how we&#39;d<br>apply the same idea to finite/infinite sequences, though.<br></p><p>&gt;&gt;&gt; If we adopt that position then for..in would need to be built on top<br>&gt;&gt;&gt; of a guaranteed finite construct.  This would allow programmers to<br>&gt;&gt;&gt; continue writing generic code agains the most generic for..in-able<br>&gt;&gt;&gt; construct while eliminating a precondition that is often (usually?)<br>&gt;&gt;&gt; unstated and likely unconsidered.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we do decide to move forward with infinite for..in loops I think we<br>&gt;&gt;&gt; need to establish strong guidance around how to properly write generic<br>&gt;&gt;&gt; code with these protocols.  Should such code really be constrained to<br>&gt;&gt;&gt; `Collection` rather than `Sequence` (i.e. should a potentially<br>&gt;&gt;&gt; infinite `Sequence` have an eager map)?  If this is the guidance,<br>&gt;&gt;&gt; should it be paired with guidance that all finite sequences should<br>&gt;&gt;&gt; conform to `Collection`?  Or is it sufficient to just educate<br>&gt;&gt;&gt; developers about this issue and expect people to document the “finite<br>&gt;&gt;&gt; Sequence” precondition when the constraint is `Sequence` rather than<br>&gt;&gt;&gt; `Collection`?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I hope we will give serious consideration to these questions while<br>&gt;&gt;&gt; this topic is open for discussion.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 2:41 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; statement.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt;&gt;&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt;&gt;&gt; finite cases separately…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think this is pointing in the right general direction.  It would<br>&gt;&gt;&gt;&gt; make working with `Sequence` much more straightforward and allow us to<br>&gt;&gt;&gt;&gt; depend on the multi-pass property that is true in practice of the most<br>&gt;&gt;&gt;&gt; common models of `Sequence`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But I agree that we should give much more careful consideration to<br>&gt;&gt;&gt;&gt; finite / infinite generally and for..in specifically.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now that I have been thinking about the finite / infinite distinction<br>&gt;&gt;&gt;&gt; more closely I have begun to notice a lot of code that is written<br>&gt;&gt;&gt;&gt; generically using `Sequence` where a for..in loop is really what is<br>&gt;&gt;&gt;&gt; required, however the “finite sequence” precondition is not explicitly<br>&gt;&gt;&gt;&gt; stated.  Interestingly, this is the case with the standard library’s<br>&gt;&gt;&gt;&gt; eager `map` (but not the case with `dropLast` which explicitly notes<br>&gt;&gt;&gt;&gt; the precondition).  I have been somewhat surprised to realize how<br>&gt;&gt;&gt;&gt; common this “bug” is (i.e. not stating a precondition).  I think we<br>&gt;&gt;&gt;&gt; have gotten away with it thus far because the sequences most people<br>&gt;&gt;&gt;&gt; use most of the time in practice are finite.  But that doesn’t mean we<br>&gt;&gt;&gt;&gt; should accept this as good enough - IMO it is way to easy to forget to<br>&gt;&gt;&gt;&gt; document this precondition (and obviously easier for users to overlook<br>&gt;&gt;&gt;&gt; than preconditions that are actually encoded in the type system,<br>&gt;&gt;&gt;&gt; violations of which are caught at compile time).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The fact that this pattern is so pervasive is what I meant when I said<br>&gt;&gt;&gt;&gt; for..in “naturally” requires a finite sequence.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO it’s better to encode preconditions in the type system when that<br>&gt;&gt;&gt;&gt; is practical, and especially when the precondition is shared by a vast<br>&gt;&gt;&gt;&gt; majority of code written using a particular construct (in this case a<br>&gt;&gt;&gt;&gt; for..in loop written using the most generic for..in-able protocol).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think the safest solution is to take the position that writing an<br>&gt;&gt;&gt;&gt; infinite loop is relatively uncommon and is a more “advanced”<br>&gt;&gt;&gt;&gt; technique, and thus should be done explicitly.  Do people really write<br>&gt;&gt;&gt;&gt; infinite loops often enough that the convenience of using for..in when<br>&gt;&gt;&gt;&gt; writing infinite loops outweighs the safety benefit of preventing<br>&gt;&gt;&gt;&gt; accidental infinite loops?  I haven’t seen a compelling argument for<br>&gt;&gt;&gt;&gt; this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Good questions.  I&#39;d also add: “do infinite sequences come up often<br>&gt;&gt;&gt; enough that accidentally looping on them forever is a problem?”<br>&gt;&gt; <br>&gt;&gt; That’s a good question as well.  In practice the frequency of infinite<br>&gt;&gt; sequences likely depends on the domain.<br>&gt;&gt; <br>&gt;&gt; IMO this falls into the same category as “do single pass sequences<br>&gt;&gt; come up often enough that attempting to iterate over them twice is a<br>&gt;&gt; problem.  To paraphrase your previous post:<br>&gt;&gt; <br>&gt;&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt;&gt; (you can’t assume it is finite!) on it, so they write libraries<br>&gt;&gt;&gt; of functions that may iterate a Sequence to termination.  They test<br>&gt;&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt;&gt; and Ranges, which happen to be finite.  Their tests pass!  But their<br>&gt;&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO this is a problematic programming model.<br>&gt;&gt; <br>&gt;&gt; I definitely don’t mean to put words in your mouth here, but the<br>&gt;&gt; logical structure of the argument appears identical to me regardless<br>&gt;&gt; of which issue it is applied to.  I am only trying to make that point.<br>&gt; <br>&gt; Oh, I fully agree.  We&#39;re *in* this discussion because neither<br>&gt; single-pass nor infinite sequences come up very often.  It raises the<br>&gt; question of whether the conceptual framework ought to accomodate them at<br>&gt; all, and if they should be included, how they should be represented.<br></p><p>We’ve considered good practical examples of both.  They exist and people use them.  I think we’re better off having a common vocabulary for them rather than requiring everyone who uses these concepts to invent their own.  <br></p><p>I agree that the question of how best to represent them is crucial.<br></p><p>&gt; <br>&gt; The quotation you cited above isn&#39;t arguing that single-pass sequences<br>&gt; are important enough to represent.  It is trying to point out that the<br>&gt; refinement relationship between single- and multipass sequences has an<br>&gt; undesirable effect.  I&#39;m certain the same thing could occur for infinite<br>&gt; and finite sequences.<br></p><p>I’m not sure I agree.  Neither are clearly modeled in the current library so I don’t think we know what the impact would be if they were.  I’m willing to bet that people would choose the correct constraints if they were available (modeled accurately in the standard library, well documented, etc).<br></p><p>What both of these *definitely* have in common is that they are purely semantic requirements that cannot be stated explicitly as requirements using syntax of the language.  You have reminded us many times that protocols should not just be about syntax, but should also emphasize semantics.  We shouldn’t shy away from introducing a protocol that doesn’t add any syntactic requirements if it is necessary to capture important semantic requirements.<br></p><p>&gt; <br>&gt; FWIW, Max pointed out to me on Friday that Scala&#39;s concept for<br>&gt; possibly-single-pass sequences is called “TraversibleOnce.”  I think<br>&gt; that name goes a long way to solving the problem.  I&#39;m not sure how we&#39;d<br>&gt; apply the same idea to finite/infinite sequences, though.<br></p><p>I’ve was thinking about how to best represent these while mowing the lawn this afternoon and had an interesting thought.  If we add one additional protocol and pin down some of the semantics that have been discussed in this thread we could have a pretty straightforward model that captures the various semantics using a protocol in each of 4 quadrants:<br></p><p>                        Single Pass                               Multi Pass<br></p><p>                                                                           <br>Potentially                                                           Sequence<br>Infinite              IteratorProtocol  &lt;-------------------------|   makeIterator()<br>                                  |                                                |<br>                                  |                                        Collection<br>Finite                FiniteIteratorProtocol  &lt;-------------------  makeIterator()<br></p><p><br>The semantic refinement on `Sequence` is that it must now produce a new iterator every time one is requested (and they must all produce identical sequences of values as long as the sequence was not mutated in between calls to `makeIterator`).<br></p><p>The semantic refinement on `Collection` is that it must now be finite and its `Iterator` must conform to `FiniteIteratorProtocol` rather than `IteratorProtocol`.<br></p><p>`FiniteIteratorProtocol` is the new protocol which introduces the semantic requirement that calls to `next` must “eventually” produce `nil`.  “Eventually” might be a bit fuzzy but should carry the intent that your program won’t hang or be killed by the OS (i.e. diverge) if you iterate until `nil` is reached.<br></p><p>You mentioned in another thread that for..in wouldn’t necessarily have to use a single protocol (or refinement relationship).  Under this model I would propose that we make for..in operate on top of `FiniteIteratorProtocol`, but also have the ability to get the iterator from a `Collection`.  (I’m using still advocating for restricting the for..in sugar to finite iteration but the same idea would work at the “potentially infinite” level using `IteratorProtocol and `Sequence`).  The only change from current state (aside from the finite restriction) is to allow you to directly provide an iterator to the for..in loop rathe than requiring the compiler to get a new one via a call to `makeIterator`.<br></p><p>If we do adopt something like this model, I think a couple of guidelines are clear regardless of whether for..in works exclusively with finite concepts or also admits potentially infinite ones.  All code that requires terminating iteration should be written with `Collection` or `FiniteIteratorProtocol`, not `Sequence` or `IteratorProtocol`.  Following from this, all finite sequences should conform to `Collection`, not just `Sequence` so it can continue to work with all code that requires finite sequences.  One advantage of restricting for..in to the finite concepts is that it encourages people to follow this guideline so that their types will be usable with for..in, finite constraints, etc.<br></p><p>In order to make it easy to follow the second guideline, the library should strive to make it as easy as possible to implement forward only `Collection` if you can vend an iterator and guarantee it is finite.  Ideally it would be no more difficult than it is to implement `Sequence` today.  Further customization of the implementation would be done as an optimization, not just to achieve basic capabilities.<br></p><p>One other topic that came up is whether the single pass concepts should be required to have reference semantics.  If we go in that direction it is clear that in the previous model `IteratorProtocol` would have a class requirement which would be inherited by `FiniteIteratorProtocol`.<br></p><p>However, I am not convinced we should require reference semantics here.  This requirement doesn’t exist today and I haven’t heard anyone say it has directly been a problem.  The problem seems to be the due to the fact that `Sequence` is missing a semantic requirement everyone expects.  I don’t know the rationale that was originally behind that decision and am curious.  Is it because for..in works via `Sequence` and it was desirable to have for..in work with single pass sequences?  The above suggested tweak to how for..in addresses that.<br></p><p>Further, consider an algorithm which has multiple “choices” available and would like to be able to take advantage of backtracking.  This can be achieved trivially with value semantic iterators by simply making a copy at any time during iteration and returning to the copy if a dead end is reached.  You could sort of mimic this with a reference semantic iterator by conforming the iterator itself to `Sequence` or `Collection` and calling `makeIterator` to “clone” it.  Obviously this would only be possible with intimate knowledge of the iterator and would usually not be possible retroactively, whereas it would be trivial to take advantage of iterators that have value semantics.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; If we adopt that position then for..in would need to be built on top<br>&gt;&gt;&gt;&gt; of a guaranteed finite construct.  This would allow programmers to<br>&gt;&gt;&gt;&gt; continue writing generic code agains the most generic for..in-able<br>&gt;&gt;&gt;&gt; construct while eliminating a precondition that is often (usually?)<br>&gt;&gt;&gt;&gt; unstated and likely unconsidered.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we do decide to move forward with infinite for..in loops I think we<br>&gt;&gt;&gt;&gt; need to establish strong guidance around how to properly write generic<br>&gt;&gt;&gt;&gt; code with these protocols.  Should such code really be constrained to<br>&gt;&gt;&gt;&gt; `Collection` rather than `Sequence` (i.e. should a potentially<br>&gt;&gt;&gt;&gt; infinite `Sequence` have an eager map)?  If this is the guidance,<br>&gt;&gt;&gt;&gt; should it be paired with guidance that all finite sequences should<br>&gt;&gt;&gt;&gt; conform to `Collection`?  Or is it sufficient to just educate<br>&gt;&gt;&gt;&gt; developers about this issue and expect people to document the “finite<br>&gt;&gt;&gt;&gt; Sequence” precondition when the constraint is `Sequence` rather than<br>&gt;&gt;&gt;&gt; `Collection`?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I hope we will give serious consideration to these questions while<br>&gt;&gt;&gt;&gt; this topic is open for discussion.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com &lt;http://david-at-alkaline-solutions.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;http://swift.org/ &lt;http://swift.org/&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/123a15bc/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 27, 2016, at 2:41 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 27, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt;&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; statement.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt;&gt;&gt;&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt;&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt;&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt;&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt;&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt;&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt;&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt;&gt;&gt;&gt; finite cases separately…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think this is pointing in the right general direction.  It would<br>&gt;&gt;&gt;&gt;&gt; make working with `Sequence` much more straightforward and allow us to<br>&gt;&gt;&gt;&gt;&gt; depend on the multi-pass property that is true in practice of the most<br>&gt;&gt;&gt;&gt;&gt; common models of `Sequence`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But I agree that we should give much more careful consideration to<br>&gt;&gt;&gt;&gt;&gt; finite / infinite generally and for..in specifically.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now that I have been thinking about the finite / infinite distinction<br>&gt;&gt;&gt;&gt;&gt; more closely I have begun to notice a lot of code that is written<br>&gt;&gt;&gt;&gt;&gt; generically using `Sequence` where a for..in loop is really what is<br>&gt;&gt;&gt;&gt;&gt; required, however the “finite sequence” precondition is not explicitly<br>&gt;&gt;&gt;&gt;&gt; stated.  Interestingly, this is the case with the standard library’s<br>&gt;&gt;&gt;&gt;&gt; eager `map` (but not the case with `dropLast` which explicitly notes<br>&gt;&gt;&gt;&gt;&gt; the precondition).  I have been somewhat surprised to realize how<br>&gt;&gt;&gt;&gt;&gt; common this “bug” is (i.e. not stating a precondition).  I think we<br>&gt;&gt;&gt;&gt;&gt; have gotten away with it thus far because the sequences most people<br>&gt;&gt;&gt;&gt;&gt; use most of the time in practice are finite.  But that doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt; should accept this as good enough - IMO it is way to easy to forget to<br>&gt;&gt;&gt;&gt;&gt; document this precondition (and obviously easier for users to overlook<br>&gt;&gt;&gt;&gt;&gt; than preconditions that are actually encoded in the type system,<br>&gt;&gt;&gt;&gt;&gt; violations of which are caught at compile time).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The fact that this pattern is so pervasive is what I meant when I said<br>&gt;&gt;&gt;&gt;&gt; for..in “naturally” requires a finite sequence.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO it’s better to encode preconditions in the type system when that<br>&gt;&gt;&gt;&gt;&gt; is practical, and especially when the precondition is shared by a vast<br>&gt;&gt;&gt;&gt;&gt; majority of code written using a particular construct (in this case a<br>&gt;&gt;&gt;&gt;&gt; for..in loop written using the most generic for..in-able protocol).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think the safest solution is to take the position that writing an<br>&gt;&gt;&gt;&gt;&gt; infinite loop is relatively uncommon and is a more “advanced”<br>&gt;&gt;&gt;&gt;&gt; technique, and thus should be done explicitly.  Do people really write<br>&gt;&gt;&gt;&gt;&gt; infinite loops often enough that the convenience of using for..in when<br>&gt;&gt;&gt;&gt;&gt; writing infinite loops outweighs the safety benefit of preventing<br>&gt;&gt;&gt;&gt;&gt; accidental infinite loops?  I haven’t seen a compelling argument for<br>&gt;&gt;&gt;&gt;&gt; this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Good questions.  I&#39;d also add: “do infinite sequences come up often<br>&gt;&gt;&gt;&gt; enough that accidentally looping on them forever is a problem?”<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s a good question as well.  In practice the frequency of infinite<br>&gt;&gt;&gt; sequences likely depends on the domain.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO this falls into the same category as “do single pass sequences<br>&gt;&gt;&gt; come up often enough that attempting to iterate over them twice is a<br>&gt;&gt;&gt; problem.  To paraphrase your previous post:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt;&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt;&gt;&gt; (you can’t assume it is finite!) on it, so they write libraries<br>&gt;&gt;&gt;&gt; of functions that may iterate a Sequence to termination.  They test<br>&gt;&gt;&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt;&gt;&gt; and Ranges, which happen to be finite.  Their tests pass!  But their<br>&gt;&gt;&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt;&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO this is a problematic programming model.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely don’t mean to put words in your mouth here, but the<br>&gt;&gt;&gt; logical structure of the argument appears identical to me regardless<br>&gt;&gt;&gt; of which issue it is applied to.  I am only trying to make that point.<br>&gt;&gt; <br>&gt;&gt; Oh, I fully agree.  We&#39;re *in* this discussion because neither<br>&gt;&gt; single-pass nor infinite sequences come up very often.  It raises the<br>&gt;&gt; question of whether the conceptual framework ought to accomodate them at<br>&gt;&gt; all, and if they should be included, how they should be represented.<br>&gt;<br>&gt; We’ve considered good practical examples of both.  They exist and<br>&gt; people use them.  I think we’re better off having a common vocabulary<br>&gt; for them rather than requiring everyone who uses these concepts to<br>&gt; invent their own.<br>&gt;<br>&gt; I agree that the question of how best to represent them is crucial.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; The quotation you cited above isn&#39;t arguing that single-pass sequences<br>&gt;&gt; are important enough to represent.  It is trying to point out that the<br>&gt;&gt; refinement relationship between single- and multipass sequences has an<br>&gt;&gt; undesirable effect.  I&#39;m certain the same thing could occur for infinite<br>&gt;&gt; and finite sequences.<br>&gt;<br>&gt; I’m not sure I agree.  Neither are clearly modeled in the current<br>&gt; library so I don’t think we know what the impact would be if they<br>&gt; were.  I’m willing to bet that people would choose the correct<br>&gt; constraints if they were available (modeled accurately in the standard<br>&gt; library, well documented, etc).<br></p><p>IMO it&#39;s just a symptom of concept refinement when the available models<br>almost all conform to the more-refined concept.<br></p><p>&gt; What both of these *definitely* have in common is that they are purely<br>&gt; semantic requirements that cannot be stated explicitly as requirements<br>&gt; using syntax of the language.  You have reminded us many times that<br>&gt; protocols should not just be about syntax, but should also emphasize<br>&gt; semantics.  We shouldn’t shy away from introducing a protocol that<br>&gt; doesn’t add any syntactic requirements if it is necessary to capture<br>&gt; important semantic requirements.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; FWIW, Max pointed out to me on Friday that Scala&#39;s concept for<br>&gt;&gt; possibly-single-pass sequences is called “TraversibleOnce.”  I think<br>&gt;&gt; that name goes a long way to solving the problem.  I&#39;m not sure how we&#39;d<br>&gt;&gt; apply the same idea to finite/infinite sequences, though.<br>&gt;<br>&gt; I’ve was thinking about how to best represent these while mowing the<br>&gt; lawn this afternoon and had an interesting thought.  If we add one<br>&gt; additional protocol and pin down some of the semantics that have been<br>&gt; discussed in this thread we could have a pretty straightforward model<br>&gt; that captures the various semantics using a protocol in each of 4<br>&gt; quadrants:<br>&gt;<br>&gt;                         Single Pass                               Multi Pass<br>&gt;<br>&gt; Potentially                                                           Sequence<br>&gt; Infinite              IteratorProtocol  &lt;-------------------------|   makeIterator()<br>&gt;                                   |                                                |<br>&gt;                                   |                                        Collection<br>&gt; Finite                FiniteIteratorProtocol  &lt;-------------------  makeIterator()<br>&gt;<br>&gt; The semantic refinement on `Sequence` is that it must now produce a<br>&gt; new iterator every time one is requested (and they must all produce<br>&gt; identical sequences of values as long as the sequence was not mutated<br>&gt; in between calls to `makeIterator`).<br>&gt;<br>&gt; The semantic refinement on `Collection` is that it must now be finite<br>&gt; and its `Iterator` must conform to `FiniteIteratorProtocol` rather<br>&gt; than `IteratorProtocol`.<br>&gt;<br>&gt; `FiniteIteratorProtocol` is the new protocol which introduces the<br>&gt; semantic requirement that calls to `next` must “eventually” produce<br>&gt; `nil`.  “Eventually” might be a bit fuzzy but should carry the intent<br>&gt; that your program won’t hang or be killed by the OS (i.e. diverge) if<br>&gt; you iterate until `nil` is reached.<br></p><p><br>I talked to Dmitri and Max about all this last night and I think we have<br>a simpler answer, which we&#39;ll post shortly.  Please let us know if you<br>think it is missing something.<br></p><p>&gt; You mentioned in another thread that for..in wouldn’t necessarily have<br>&gt; to use a single protocol (or refinement relationship).  Under this<br>&gt; model I would propose that we make for..in operate on top of<br>&gt; `FiniteIteratorProtocol`, but also have the ability to get the<br>&gt; iterator from a `Collection`.  (I’m using still advocating for<br>&gt; restricting the for..in sugar to finite iteration but the same idea<br>&gt; would work at the “potentially infinite” level using `IteratorProtocol<br>&gt; and `Sequence`).  The only change from current state (aside from the<br>&gt; finite restriction) is to allow you to directly provide an iterator to<br>&gt; the for..in loop rathe than requiring the compiler to get a new one<br>&gt; via a call to `makeIterator`.<br>&gt;<br>&gt; If we do adopt something like this model, I think a couple of<br>&gt; guidelines are clear regardless of whether for..in works exclusively<br>&gt; with finite concepts or also admits potentially infinite ones.  All<br>&gt; code that requires terminating iteration should be written with<br>&gt; `Collection` or `FiniteIteratorProtocol`, not `Sequence` or<br>&gt; `IteratorProtocol`.  Following from this, all finite sequences should<br>&gt; conform to `Collection`, not just `Sequence` so it can continue to<br>&gt; work with all code that requires finite sequences.  One advantage of<br>&gt; restricting for..in to the finite concepts is that it encourages<br>&gt; people to follow this guideline so that their types will be usable<br>&gt; with for..in, finite constraints, etc.<br>&gt;<br>&gt; In order to make it easy to follow the second guideline, the library<br>&gt; should strive to make it as easy as possible to implement forward only<br>&gt; `Collection` if you can vend an iterator and guarantee it is finite.<br>&gt; Ideally it would be no more difficult than it is to implement<br>&gt; `Sequence` today.  Further customization of the implementation would<br>&gt; be done as an optimization, not just to achieve basic capabilities.<br>&gt;<br>&gt; One other topic that came up is whether the single pass concepts<br>&gt; should be required to have reference semantics.  If we go in that<br>&gt; direction it is clear that in the previous model `IteratorProtocol`<br>&gt; would have a class requirement which would be inherited by<br>&gt; `FiniteIteratorProtocol`.<br>&gt;<br>&gt; However, I am not convinced we should require reference semantics<br>&gt; here.  This requirement doesn’t exist today and I haven’t heard anyone<br>&gt; say it has directly been a problem.  The problem seems to be the due<br>&gt; to the fact that `Sequence` is missing a semantic requirement everyone<br>&gt; expects.  I don’t know the rationale that was originally behind that<br>&gt; decision and am curious.  Is it because for..in works via `Sequence`<br>&gt; and it was desirable to have for..in work with single pass sequences?<br>&gt; The above suggested tweak to how for..in addresses that.<br>&gt;<br>&gt; Further, consider an algorithm which has multiple “choices” available<br>&gt; and would like to be able to take advantage of backtracking.  This can<br>&gt; be achieved trivially with value semantic iterators by simply making a<br>&gt; copy at any time during iteration and returning to the copy if a dead<br>&gt; end is reached.  You could sort of mimic this with a reference<br>&gt; semantic iterator by conforming the iterator itself to `Sequence` or<br>&gt; `Collection` and calling `makeIterator` to “clone” it.  Obviously this<br>&gt; would only be possible with intimate knowledge of the iterator and<br>&gt; would usually not be possible retroactively, whereas it would be<br>&gt; trivial to take advantage of iterators that have value semantics.<br></p><p>Seems to me that in either case you need intimate knowledge of the<br>iterator.  You either need to know that it has value semantics, or that<br>it conforms to Sequence, right?<br></p><p>&gt; -Matthew<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we adopt that position then for..in would need to be built on top<br>&gt;&gt;&gt;&gt;&gt; of a guaranteed finite construct.  This would allow programmers to<br>&gt;&gt;&gt;&gt;&gt; continue writing generic code agains the most generic for..in-able<br>&gt;&gt;&gt;&gt;&gt; construct while eliminating a precondition that is often (usually?)<br>&gt;&gt;&gt;&gt;&gt; unstated and likely unconsidered.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we do decide to move forward with infinite for..in loops I think we<br>&gt;&gt;&gt;&gt;&gt; need to establish strong guidance around how to properly write generic<br>&gt;&gt;&gt;&gt;&gt; code with these protocols.  Should such code really be constrained to<br>&gt;&gt;&gt;&gt;&gt; `Collection` rather than `Sequence` (i.e. should a potentially<br>&gt;&gt;&gt;&gt;&gt; infinite `Sequence` have an eager map)?  If this is the guidance,<br>&gt;&gt;&gt;&gt;&gt; should it be paired with guidance that all finite sequences should<br>&gt;&gt;&gt;&gt;&gt; conform to `Collection`?  Or is it sufficient to just educate<br>&gt;&gt;&gt;&gt;&gt; developers about this issue and expect people to document the “finite<br>&gt;&gt;&gt;&gt;&gt; Sequence” precondition when the constraint is `Sequence` rather than<br>&gt;&gt;&gt;&gt;&gt; `Collection`?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I hope we will give serious consideration to these questions while<br>&gt;&gt;&gt;&gt;&gt; this topic is open for discussion.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com &lt;http://david-at-alkaline-solutions.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;http://swift.org/ &lt;http://swift.org/&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 12:44 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 2:41 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 27, 2016, at 11:46 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&lt;mailto:dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Mon Jun 27 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 26, 2016, at 10:56 PM, Jonathan Hull via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; &lt;mailto:swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; statement.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; finite cases separately…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think this is pointing in the right general direction.  It would<br>&gt;&gt;&gt;&gt;&gt;&gt; make working with `Sequence` much more straightforward and allow us to<br>&gt;&gt;&gt;&gt;&gt;&gt; depend on the multi-pass property that is true in practice of the most<br>&gt;&gt;&gt;&gt;&gt;&gt; common models of `Sequence`.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; But I agree that we should give much more careful consideration to<br>&gt;&gt;&gt;&gt;&gt;&gt; finite / infinite generally and for..in specifically.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now that I have been thinking about the finite / infinite distinction<br>&gt;&gt;&gt;&gt;&gt;&gt; more closely I have begun to notice a lot of code that is written<br>&gt;&gt;&gt;&gt;&gt;&gt; generically using `Sequence` where a for..in loop is really what is<br>&gt;&gt;&gt;&gt;&gt;&gt; required, however the “finite sequence” precondition is not explicitly<br>&gt;&gt;&gt;&gt;&gt;&gt; stated.  Interestingly, this is the case with the standard library’s<br>&gt;&gt;&gt;&gt;&gt;&gt; eager `map` (but not the case with `dropLast` which explicitly notes<br>&gt;&gt;&gt;&gt;&gt;&gt; the precondition).  I have been somewhat surprised to realize how<br>&gt;&gt;&gt;&gt;&gt;&gt; common this “bug” is (i.e. not stating a precondition).  I think we<br>&gt;&gt;&gt;&gt;&gt;&gt; have gotten away with it thus far because the sequences most people<br>&gt;&gt;&gt;&gt;&gt;&gt; use most of the time in practice are finite.  But that doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt; should accept this as good enough - IMO it is way to easy to forget to<br>&gt;&gt;&gt;&gt;&gt;&gt; document this precondition (and obviously easier for users to overlook<br>&gt;&gt;&gt;&gt;&gt;&gt; than preconditions that are actually encoded in the type system,<br>&gt;&gt;&gt;&gt;&gt;&gt; violations of which are caught at compile time).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The fact that this pattern is so pervasive is what I meant when I said<br>&gt;&gt;&gt;&gt;&gt;&gt; for..in “naturally” requires a finite sequence.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; IMO it’s better to encode preconditions in the type system when that<br>&gt;&gt;&gt;&gt;&gt;&gt; is practical, and especially when the precondition is shared by a vast<br>&gt;&gt;&gt;&gt;&gt;&gt; majority of code written using a particular construct (in this case a<br>&gt;&gt;&gt;&gt;&gt;&gt; for..in loop written using the most generic for..in-able protocol).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I think the safest solution is to take the position that writing an<br>&gt;&gt;&gt;&gt;&gt;&gt; infinite loop is relatively uncommon and is a more “advanced”<br>&gt;&gt;&gt;&gt;&gt;&gt; technique, and thus should be done explicitly.  Do people really write<br>&gt;&gt;&gt;&gt;&gt;&gt; infinite loops often enough that the convenience of using for..in when<br>&gt;&gt;&gt;&gt;&gt;&gt; writing infinite loops outweighs the safety benefit of preventing<br>&gt;&gt;&gt;&gt;&gt;&gt; accidental infinite loops?  I haven’t seen a compelling argument for<br>&gt;&gt;&gt;&gt;&gt;&gt; this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Good questions.  I&#39;d also add: “do infinite sequences come up often<br>&gt;&gt;&gt;&gt;&gt; enough that accidentally looping on them forever is a problem?”<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s a good question as well.  In practice the frequency of infinite<br>&gt;&gt;&gt;&gt; sequences likely depends on the domain.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO this falls into the same category as “do single pass sequences<br>&gt;&gt;&gt;&gt; come up often enough that attempting to iterate over them twice is a<br>&gt;&gt;&gt;&gt; problem.  To paraphrase your previous post:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt;&gt;&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt;&gt;&gt;&gt; (you can’t assume it is finite!) on it, so they write libraries<br>&gt;&gt;&gt;&gt;&gt; of functions that may iterate a Sequence to termination.  They test<br>&gt;&gt;&gt;&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt;&gt;&gt;&gt; and Ranges, which happen to be finite.  Their tests pass!  But their<br>&gt;&gt;&gt;&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt;&gt;&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; IMO this is a problematic programming model.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely don’t mean to put words in your mouth here, but the<br>&gt;&gt;&gt;&gt; logical structure of the argument appears identical to me regardless<br>&gt;&gt;&gt;&gt; of which issue it is applied to.  I am only trying to make that point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Oh, I fully agree.  We&#39;re *in* this discussion because neither<br>&gt;&gt;&gt; single-pass nor infinite sequences come up very often.  It raises the<br>&gt;&gt;&gt; question of whether the conceptual framework ought to accomodate them at<br>&gt;&gt;&gt; all, and if they should be included, how they should be represented.<br>&gt;&gt; <br>&gt;&gt; We’ve considered good practical examples of both.  They exist and<br>&gt;&gt; people use them.  I think we’re better off having a common vocabulary<br>&gt;&gt; for them rather than requiring everyone who uses these concepts to<br>&gt;&gt; invent their own.<br>&gt;&gt; <br>&gt;&gt; I agree that the question of how best to represent them is crucial.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The quotation you cited above isn&#39;t arguing that single-pass sequences<br>&gt;&gt;&gt; are important enough to represent.  It is trying to point out that the<br>&gt;&gt;&gt; refinement relationship between single- and multipass sequences has an<br>&gt;&gt;&gt; undesirable effect.  I&#39;m certain the same thing could occur for infinite<br>&gt;&gt;&gt; and finite sequences.<br>&gt;&gt; <br>&gt;&gt; I’m not sure I agree.  Neither are clearly modeled in the current<br>&gt;&gt; library so I don’t think we know what the impact would be if they<br>&gt;&gt; were.  I’m willing to bet that people would choose the correct<br>&gt;&gt; constraints if they were available (modeled accurately in the standard<br>&gt;&gt; library, well documented, etc).<br>&gt; <br>&gt; IMO it&#39;s just a symptom of concept refinement when the available models<br>&gt; almost all conform to the more-refined concept.<br></p><p>I think I see what you mean.  However, if there are algorithms that can be expressed in terms of the weaker concept that are also useful (and performant) with the more refined concept that would be an argument for explicitly modeling the refinement relationship.  I don’t know how often this happens in practice though (and I haven’t done any analysis of whether this argument would be applicable to the current thread or not).<br></p><p>&gt; <br>&gt;&gt; What both of these *definitely* have in common is that they are purely<br>&gt;&gt; semantic requirements that cannot be stated explicitly as requirements<br>&gt;&gt; using syntax of the language.  You have reminded us many times that<br>&gt;&gt; protocols should not just be about syntax, but should also emphasize<br>&gt;&gt; semantics.  We shouldn’t shy away from introducing a protocol that<br>&gt;&gt; doesn’t add any syntactic requirements if it is necessary to capture<br>&gt;&gt; important semantic requirements.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; FWIW, Max pointed out to me on Friday that Scala&#39;s concept for<br>&gt;&gt;&gt; possibly-single-pass sequences is called “TraversibleOnce.”  I think<br>&gt;&gt;&gt; that name goes a long way to solving the problem.  I&#39;m not sure how we&#39;d<br>&gt;&gt;&gt; apply the same idea to finite/infinite sequences, though.<br>&gt;&gt; <br>&gt;&gt; I’ve was thinking about how to best represent these while mowing the<br>&gt;&gt; lawn this afternoon and had an interesting thought.  If we add one<br>&gt;&gt; additional protocol and pin down some of the semantics that have been<br>&gt;&gt; discussed in this thread we could have a pretty straightforward model<br>&gt;&gt; that captures the various semantics using a protocol in each of 4<br>&gt;&gt; quadrants:<br>&gt;&gt; <br>&gt;&gt;                        Single Pass                               Multi Pass<br>&gt;&gt; <br>&gt;&gt; Potentially                                                           Sequence<br>&gt;&gt; Infinite              IteratorProtocol  &lt;-------------------------|   makeIterator()<br>&gt;&gt;                                  |                                                |<br>&gt;&gt;                                  |                                        Collection<br>&gt;&gt; Finite                FiniteIteratorProtocol  &lt;-------------------  makeIterator()<br>&gt;&gt; <br>&gt;&gt; The semantic refinement on `Sequence` is that it must now produce a<br>&gt;&gt; new iterator every time one is requested (and they must all produce<br>&gt;&gt; identical sequences of values as long as the sequence was not mutated<br>&gt;&gt; in between calls to `makeIterator`).<br>&gt;&gt; <br>&gt;&gt; The semantic refinement on `Collection` is that it must now be finite<br>&gt;&gt; and its `Iterator` must conform to `FiniteIteratorProtocol` rather<br>&gt;&gt; than `IteratorProtocol`.<br>&gt;&gt; <br>&gt;&gt; `FiniteIteratorProtocol` is the new protocol which introduces the<br>&gt;&gt; semantic requirement that calls to `next` must “eventually” produce<br>&gt;&gt; `nil`.  “Eventually” might be a bit fuzzy but should carry the intent<br>&gt;&gt; that your program won’t hang or be killed by the OS (i.e. diverge) if<br>&gt;&gt; you iterate until `nil` is reached.<br>&gt; <br>&gt; <br>&gt; I talked to Dmitri and Max about all this last night and I think we have<br>&gt; a simpler answer, which we&#39;ll post shortly.  Please let us know if you<br>&gt; think it is missing something.<br></p><p>Looking forward to seeing what you post. <br></p><p>&gt; <br>&gt;&gt; You mentioned in another thread that for..in wouldn’t necessarily have<br>&gt;&gt; to use a single protocol (or refinement relationship).  Under this<br>&gt;&gt; model I would propose that we make for..in operate on top of<br>&gt;&gt; `FiniteIteratorProtocol`, but also have the ability to get the<br>&gt;&gt; iterator from a `Collection`.  (I’m using still advocating for<br>&gt;&gt; restricting the for..in sugar to finite iteration but the same idea<br>&gt;&gt; would work at the “potentially infinite” level using `IteratorProtocol<br>&gt;&gt; and `Sequence`).  The only change from current state (aside from the<br>&gt;&gt; finite restriction) is to allow you to directly provide an iterator to<br>&gt;&gt; the for..in loop rathe than requiring the compiler to get a new one<br>&gt;&gt; via a call to `makeIterator`.<br>&gt;&gt; <br>&gt;&gt; If we do adopt something like this model, I think a couple of<br>&gt;&gt; guidelines are clear regardless of whether for..in works exclusively<br>&gt;&gt; with finite concepts or also admits potentially infinite ones.  All<br>&gt;&gt; code that requires terminating iteration should be written with<br>&gt;&gt; `Collection` or `FiniteIteratorProtocol`, not `Sequence` or<br>&gt;&gt; `IteratorProtocol`.  Following from this, all finite sequences should<br>&gt;&gt; conform to `Collection`, not just `Sequence` so it can continue to<br>&gt;&gt; work with all code that requires finite sequences.  One advantage of<br>&gt;&gt; restricting for..in to the finite concepts is that it encourages<br>&gt;&gt; people to follow this guideline so that their types will be usable<br>&gt;&gt; with for..in, finite constraints, etc.<br>&gt;&gt; <br>&gt;&gt; In order to make it easy to follow the second guideline, the library<br>&gt;&gt; should strive to make it as easy as possible to implement forward only<br>&gt;&gt; `Collection` if you can vend an iterator and guarantee it is finite.<br>&gt;&gt; Ideally it would be no more difficult than it is to implement<br>&gt;&gt; `Sequence` today.  Further customization of the implementation would<br>&gt;&gt; be done as an optimization, not just to achieve basic capabilities.<br>&gt;&gt; <br>&gt;&gt; One other topic that came up is whether the single pass concepts<br>&gt;&gt; should be required to have reference semantics.  If we go in that<br>&gt;&gt; direction it is clear that in the previous model `IteratorProtocol`<br>&gt;&gt; would have a class requirement which would be inherited by<br>&gt;&gt; `FiniteIteratorProtocol`.<br>&gt;&gt; <br>&gt;&gt; However, I am not convinced we should require reference semantics<br>&gt;&gt; here.  This requirement doesn’t exist today and I haven’t heard anyone<br>&gt;&gt; say it has directly been a problem.  The problem seems to be the due<br>&gt;&gt; to the fact that `Sequence` is missing a semantic requirement everyone<br>&gt;&gt; expects.  I don’t know the rationale that was originally behind that<br>&gt;&gt; decision and am curious.  Is it because for..in works via `Sequence`<br>&gt;&gt; and it was desirable to have for..in work with single pass sequences?<br>&gt;&gt; The above suggested tweak to how for..in addresses that.<br>&gt;&gt; <br>&gt;&gt; Further, consider an algorithm which has multiple “choices” available<br>&gt;&gt; and would like to be able to take advantage of backtracking.  This can<br>&gt;&gt; be achieved trivially with value semantic iterators by simply making a<br>&gt;&gt; copy at any time during iteration and returning to the copy if a dead<br>&gt;&gt; end is reached.  You could sort of mimic this with a reference<br>&gt;&gt; semantic iterator by conforming the iterator itself to `Sequence` or<br>&gt;&gt; `Collection` and calling `makeIterator` to “clone” it.  Obviously this<br>&gt;&gt; would only be possible with intimate knowledge of the iterator and<br>&gt;&gt; would usually not be possible retroactively, whereas it would be<br>&gt;&gt; trivial to take advantage of iterators that have value semantics.<br>&gt; <br>&gt; Seems to me that in either case you need intimate knowledge of the<br>&gt; iterator.  You either need to know that it has value semantics, or that<br>&gt; it conforms to Sequence, right?<br></p><p>My argument here was in regards to an iterator that wasn’t initially designed with this use case in mind and which may exist in a module you don’t control.  <br></p><p>If iterators can have value semantics it is likely that simple iterators often *will* have value semantics.  This means that it would be possible to use them in this way with no further effort.  <br></p><p>It is far less likely that iterators will conform to `Sequence`.  That means you would need to add the `Sequence` conformance if you wanted to use them in this use case.  Adding `Sequence` conformance requires much more intimate knowledge of implementation details, not just semantic properties.  Most of the time it will not be possible to add the `Sequence` conformance retroactively even if the iterator could conform in theory.<br></p><p>This use case seems interesting enough to at least deserve some consideration before we decide to require iterators to have reference semantics.  IMO the fact that `next` is a mutating requirement provides a pretty strong indication of the destructive / consuming semantics of using an iterator.  Requiring reference semantics gives up flexibility and I’m not completely convinced it adds clarity (but still keeping an open mind about this).<br></p><p>I think a significant part of the trouble with `Sequence` is that `makeIterator` is *not* marked as mutating despite the fact that the current semantics do not allow the sequence to be consumed more than once and the common models of `Sequence` are all value types.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we adopt that position then for..in would need to be built on top<br>&gt;&gt;&gt;&gt;&gt;&gt; of a guaranteed finite construct.  This would allow programmers to<br>&gt;&gt;&gt;&gt;&gt;&gt; continue writing generic code agains the most generic for..in-able<br>&gt;&gt;&gt;&gt;&gt;&gt; construct while eliminating a precondition that is often (usually?)<br>&gt;&gt;&gt;&gt;&gt;&gt; unstated and likely unconsidered.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we do decide to move forward with infinite for..in loops I think we<br>&gt;&gt;&gt;&gt;&gt;&gt; need to establish strong guidance around how to properly write generic<br>&gt;&gt;&gt;&gt;&gt;&gt; code with these protocols.  Should such code really be constrained to<br>&gt;&gt;&gt;&gt;&gt;&gt; `Collection` rather than `Sequence` (i.e. should a potentially<br>&gt;&gt;&gt;&gt;&gt;&gt; infinite `Sequence` have an eager map)?  If this is the guidance,<br>&gt;&gt;&gt;&gt;&gt;&gt; should it be paired with guidance that all finite sequences should<br>&gt;&gt;&gt;&gt;&gt;&gt; conform to `Collection`?  Or is it sufficient to just educate<br>&gt;&gt;&gt;&gt;&gt;&gt; developers about this issue and expect people to document the “finite<br>&gt;&gt;&gt;&gt;&gt;&gt; Sequence” precondition when the constraint is `Sequence` rather than<br>&gt;&gt;&gt;&gt;&gt;&gt; `Collection`?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I hope we will give serious consideration to these questions while<br>&gt;&gt;&gt;&gt;&gt;&gt; this topic is open for discussion.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com &lt;http://david-at-alkaline-solutions.com/&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/ &lt;http://david-at-alkaline-solutions.com/&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt; &lt;http://swift.org/ &lt;http://swift.org/&gt;&gt; &lt;http://swift.org/ &lt;http://swift.org/&gt; &lt;http://swift.org/ &lt;http://swift.org/&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/dcee684f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; This use case seems interesting enough to at least deserve some consideration before we decide to require iterators to have reference semantics.  IMO the fact that `next` is a mutating requirement provides a pretty strong indication of the destructive / consuming semantics of using an iterator.  Requiring reference semantics gives up flexibility and I’m not completely convinced it adds clarity (but still keeping an open mind about this).<br></p><p>My feeling is that, except for the trivial case of IndexingIterator and other iterators over collections, all iterators *should* need reference semantics. If your iterator can offer value semantics, then you should convert it into a Collection to gain the benefits of indices. If it can&#39;t offer value semantics, then you should write it as a class so those reference semantics are obvious. This would get rid of the really ugly caveat that&#39;s always festered at the heart of Iterator:<br></p><p>&gt;&gt;&gt; Obtain each separate iterator from separate calls to the sequence&#39;s makeIterator() method rather than by copying. Copying an iterator is safe, but advancing one copy of an iterator by calling its next() method may invalidate other copies of that iterator. for-in loops are safe in this regard.<br></p><p>The underlying cause of this requirement is that you can&#39;t know whether a given iterator is a value type or a reference type. Let&#39;s fix that.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 3:33 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This use case seems interesting enough to at least deserve some consideration before we decide to require iterators to have reference semantics.  IMO the fact that `next` is a mutating requirement provides a pretty strong indication of the destructive / consuming semantics of using an iterator.  Requiring reference semantics gives up flexibility and I’m not completely convinced it adds clarity (but still keeping an open mind about this).<br>&gt; <br>&gt; My feeling is that, except for the trivial case of IndexingIterator and other iterators over collections, all iterators *should* need reference semantics. If your iterator can offer value semantics, then you should convert it into a Collection to gain the benefits of indices.<br></p><p>Assuming we are going to pin down the requirement that Collection be finite (in the sense that iterating over the whole collection is practical in a real program running on a real device that is available today) then it is trivial to come up with value semantic iterators that cannot conform to Collection.  For example, iterators over infinite mathematical sequences.<br></p><p>&gt; If it can&#39;t offer value semantics, then you should write it as a class so those reference semantics are obvious.<br></p><p>I agree with this.<br></p><p>&gt; This would get rid of the really ugly caveat that&#39;s always festered at the heart of Iterator:<br>&gt; <br>&gt;&gt;&gt;&gt; Obtain each separate iterator from separate calls to the sequence&#39;s makeIterator() method rather than by copying. Copying an iterator is safe, but advancing one copy of an iterator by calling its next() method may invalidate other copies of that iterator. for-in loops are safe in this regard.<br>&gt; <br>&gt; The underlying cause of this requirement is that you can&#39;t know whether a given iterator is a value type or a reference type. Let&#39;s fix that.<br></p><p>I would like to see us eventually have a way to specify a generic constraint indicating value semantics regardless of what happens with iterators.  If we gain that capability you *can* know that you have a value semantic iterator when you use that constraint.  <br></p><p>I am not firmly opposed to making iterators require reference semantics but I don’t think the pros and cons have been thoroughly discussed on the list yet so I am pointing out what I think are interesting use cases for value semantic iterators.<br></p><p>Swift is a language that embraces value semantics.  Many common iterators *can* be implemented with value semantics.  Just because we can’t implement *all* iterators with value semantics doesn’t mean we should require them to have reference semantics.  It just means you can’t *assume* value semantics when working with iterators in generic code unless / until we have a way to specify a value semantics constraint.  That’s not necessarily a bad thing especially when it leaves the door open to interesting future possibilities.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 29, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 3:33 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; This use case seems interesting enough to at least deserve some consideration before we decide to require iterators to have reference semantics.  IMO the fact that `next` is a mutating requirement provides a pretty strong indication of the destructive / consuming semantics of using an iterator.  Requiring reference semantics gives up flexibility and I’m not completely convinced it adds clarity (but still keeping an open mind about this).<br>&gt;&gt; <br>&gt;&gt; My feeling is that, except for the trivial case of IndexingIterator and other iterators over collections, all iterators *should* need reference semantics. If your iterator can offer value semantics, then you should convert it into a Collection to gain the benefits of indices.<br>&gt; <br>&gt; Assuming we are going to pin down the requirement that Collection be finite (in the sense that iterating over the whole collection is practical in a real program running on a real device that is available today) then it is trivial to come up with value semantic iterators that cannot conform to Collection.  For example, iterators over infinite mathematical sequences.<br>&gt; <br>&gt;&gt; If it can&#39;t offer value semantics, then you should write it as a class so those reference semantics are obvious.<br>&gt; <br>&gt; I agree with this.<br>&gt; <br>&gt;&gt; This would get rid of the really ugly caveat that&#39;s always festered at the heart of Iterator:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Obtain each separate iterator from separate calls to the sequence&#39;s makeIterator() method rather than by copying. Copying an iterator is safe, but advancing one copy of an iterator by calling its next() method may invalidate other copies of that iterator. for-in loops are safe in this regard.<br>&gt;&gt; <br>&gt;&gt; The underlying cause of this requirement is that you can&#39;t know whether a given iterator is a value type or a reference type. Let&#39;s fix that.<br>&gt; <br>&gt; I would like to see us eventually have a way to specify a generic constraint indicating value semantics regardless of what happens with iterators.  If we gain that capability you *can* know that you have a value semantic iterator when you use that constraint.  <br>&gt; <br>&gt; I am not firmly opposed to making iterators require reference semantics but I don’t think the pros and cons have been thoroughly discussed on the list yet so I am pointing out what I think are interesting use cases for value semantic iterators.<br>&gt; <br>&gt; Swift is a language that embraces value semantics.  Many common iterators *can* be implemented with value semantics.  Just because we can’t implement *all* iterators with value semantics doesn’t mean we should require them to have reference semantics.  It just means you can’t *assume* value semantics when working with iterators in generic code unless / until we have a way to specify a value semantics constraint.  That’s not necessarily a bad thing especially when it leaves the door open to interesting future possibilities.<br>&gt; <br>&gt; -Matthew<br></p><p>I&#39;m kind of undecided about this personally. I think one of the problems with Swift is that the only indication that you have a reference type is that you can declare it as a constant, yet still call mutating methods upon it, this isn&#39;t a very positive way of identifying it however. This may be more of a GUI/IDE issue though, in that something being a class isn&#39;t always that obvious at a glance.<br></p><p>I wonder, could we somehow force iterators stored in variables to be passed via inout? This would make it pretty clear that you&#39;re using the same iterator and not a copy in all cases, encouraging you to obtain another if you really do need to perform multiple passes.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br></p><p>&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt; <br>&gt;&gt; -Matthew<br>&gt;<br>&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt; problems with Swift is that the only indication that you have a<br>&gt; reference type is that you can declare it as a constant, yet still<br>&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;<br>&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt; obtain another if you really do need to perform multiple passes.<br></p><p>I&#39;m going to push single-pass iteration on the stack briefly and talk<br>about the topic that&#39;s been under discussion here: infinite multipass<br>sequences.<br></p><p>## Fitting “Infinite Multipass” Into the Model<br></p><p>It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>happen, the standard library team thinks the right design is roughly<br>this:<br></p><p>  /// A multipass sequence that may be infinite<br>  protocol Collection {<br></p><p>    // Only eager algorithms that can terminate available here<br>    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>  <br>    // all lazy algorithms available here<br>    var lazy: ...<br></p><p>    var startIndex: Index<br>    var endIndex: Index // possibly not reachable from startIndex<br></p><p>    associatedtype SubSequence : Collection<br>    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>  }<br></p><p>  protocol FiniteCollection : Collection {<br></p><p>    // All eager algorithms available here<br>    func map(...) -&gt;<br>    var count: ...<br>  }<br></p><p>  protocol BidirectionalCollection : Collection { ... }<br></p><p>  protocol RandomAccessCollection : BidirectionalCollection { ... }<br></p><p>Q: Why should there be indices on an infinite multipass sequence?  <br>A: Because the operations on indices apply equally well whether the<br>   sequence is finite or not.  Find the index of a value in the<br>   sequence, slice the sequence, find again, etc.<br></p><p>Q: Why is there an endIndex on an infinite seque?<br>A: So you can write algorithms such as index(where:) once.<br></p><p>Q: Why not allow endIndex to have a different type from startIndex?<br>A: It appears to offer insufficient benefit for the associated<br>   complexity in typical usage.  A classic use case that argues for a<br>   different endIndex type is the null-terminated C string.  But you<br>   can&#39;t index one of those safely without actually counting the length,<br>   and once you&#39;ve done that you can make the endIndex an Int.<br></p><p>## Single Pass Iteration<br></p><p>The refinement relationship between Sequence and Collection is<br>problematic, because it means either:<br></p><p>a) algorithms such as map on single-pass sequences claim to be<br>   nonmutating even though it&#39;s a lie (status quo)<br></p><p>b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>   sequences. IMO that would be totally unacceptable.<br></p><p>If we drop the refinement, we can have a saner world.  We also don&#39;t<br>need to separate Sequence and Iterator anymore.  We can simply drop<br>Sequence altogether, and the protocol for single-pass iteration becomes<br>Iterator.<br></p><p>### Mutation and Reference Semantics<br></p><p>Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>argue over the definition of copy for classes; this is the one built<br>into the lowest level of the language—I refer to the other one, that<br>requires allocation, as “clone”).<br></p><p>Anything you do with a sequence that&#39;s truly single-pass mutates the<br>sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>has reference semantics. One day we may be able to model single-pass<br>sequences with “move-only” value types, which cannot be copied. You can<br>find move-only types in languages like Rust and C++, but they are not<br>supported by Swift today.  So it seems reasonable that all Iterators in<br>Swift today should be modeled as classes.<br></p><p>The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>means that mutating methods on a class constrained protocol can&#39;t be<br>labeled as such.  So consuming operations on a class-constrained<br>Iterator protocol would not be labeled as mutating.<br></p><p>The standard library team is currently trying to evaluate the tradeoffs<br>in this area.  One possibility under consideration is simply dropping<br>support for single-pass sequences until Swift can support move-only<br>value types and/or gets a mutation model for class instances.  It would<br>be very interesting to know about any real-world models of single-pass<br>sequences that people are using in Swift, since we don&#39;t supply any in<br>the standard library.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 30, 2016 at 05:00:00pm</p></header><div class="content"><p>If Iterators become reference types that model single-pass sequences and<br>becomes for-in-able, as the write-up suggests, couldn&#39;t Sequence be<br>stipulated to be multipass and retain its refinement relationship with<br>Collection?<br></p><p>On Thu, Jun 30, 2016 at 12:26 Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt; &gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt; &gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt; &gt;&gt; should require them to have reference semantics.  It just means you<br>&gt; &gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt; &gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt; &gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt; &gt;&gt; leaves the door open to interesting future possibilities.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; -Matthew<br>&gt; &gt;<br>&gt; &gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt; &gt; problems with Swift is that the only indication that you have a<br>&gt; &gt; reference type is that you can declare it as a constant, yet still<br>&gt; &gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt; &gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt; &gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt; &gt;<br>&gt; &gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt; &gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt; &gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt; &gt; obtain another if you really do need to perform multiple passes.<br>&gt;<br>&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt; sequences.<br>&gt;<br>&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;<br>&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt; happen, the standard library team thinks the right design is roughly<br>&gt; this:<br>&gt;<br>&gt;   /// A multipass sequence that may be infinite<br>&gt;   protocol Collection {<br>&gt;<br>&gt;     // Only eager algorithms that can terminate available here<br>&gt;     func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;<br>&gt;     // all lazy algorithms available here<br>&gt;     var lazy: ...<br>&gt;<br>&gt;     var startIndex: Index<br>&gt;     var endIndex: Index // possibly not reachable from startIndex<br>&gt;<br>&gt;     associatedtype SubSequence : Collection<br>&gt;     // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;   }<br>&gt;<br>&gt;   protocol FiniteCollection : Collection {<br>&gt;<br>&gt;     // All eager algorithms available here<br>&gt;     func map(...) -&gt;<br>&gt;     var count: ...<br>&gt;   }<br>&gt;<br>&gt;   protocol BidirectionalCollection : Collection { ... }<br>&gt;<br>&gt;   protocol RandomAccessCollection : BidirectionalCollection { ... }<br>&gt;<br>&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt; A: Because the operations on indices apply equally well whether the<br>&gt;    sequence is finite or not.  Find the index of a value in the<br>&gt;    sequence, slice the sequence, find again, etc.<br>&gt;<br>&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;<br>&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;    complexity in typical usage.  A classic use case that argues for a<br>&gt;    different endIndex type is the null-terminated C string.  But you<br>&gt;    can&#39;t index one of those safely without actually counting the length,<br>&gt;    and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;<br>&gt; ## Single Pass Iteration<br>&gt;<br>&gt; The refinement relationship between Sequence and Collection is<br>&gt; problematic, because it means either:<br>&gt;<br>&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;    nonmutating even though it&#39;s a lie (status quo)<br>&gt;<br>&gt; b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>&gt;    sequences. IMO that would be totally unacceptable.<br>&gt;<br>&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt; Sequence altogether, and the protocol for single-pass iteration becomes<br>&gt; Iterator.<br>&gt;<br>&gt; ### Mutation and Reference Semantics<br>&gt;<br>&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>&gt; argue over the definition of copy for classes; this is the one built<br>&gt; into the lowest level of the language—I refer to the other one, that<br>&gt; requires allocation, as “clone”).<br>&gt;<br>&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt; has reference semantics. One day we may be able to model single-pass<br>&gt; sequences with “move-only” value types, which cannot be copied. You can<br>&gt; find move-only types in languages like Rust and C++, but they are not<br>&gt; supported by Swift today.  So it seems reasonable that all Iterators in<br>&gt; Swift today should be modeled as classes.<br>&gt;<br>&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt; Iterator protocol would not be labeled as mutating.<br>&gt;<br>&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt; in this area.  One possibility under consideration is simply dropping<br>&gt; support for single-pass sequences until Swift can support move-only<br>&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt; be very interesting to know about any real-world models of single-pass<br>&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt; the standard library.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/c4ad842b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jun 30 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; If Iterators become reference types that model single-pass sequences and<br>&gt; becomes for-in-able, as the write-up suggests, couldn&#39;t Sequence be<br>&gt; stipulated to be multipass and retain its refinement relationship with<br>&gt; Collection?<br></p><p>AFAIK there is no interesting multipass Sequence that cannot reasonably be<br>made to support indexing.<br></p><p>There *is* existing code that exposes multipass data structures without<br>exposing the ability to compare iteration state for equality.  In every<br>case I can think of, index equality could easily have been exposed, but<br>wasn&#39;t.These designs can&#39;t be adapted to model Collection.<br></p><p>Those designs are real, but I am unconvinced they are worth supporting<br>directly with a separate protocol in the standard library; I&#39;m willing<br>to accept the idea that those data structures will simply be limited to<br>modeling Iterator.<br></p><p>&gt; On Thu, Jun 30, 2016 at 12:26 Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt; &gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt; &gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt; &gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt; &gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt; &gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt; &gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt; &gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; -Matthew<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt; &gt; problems with Swift is that the only indication that you have a<br>&gt;&gt; &gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt; &gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt; &gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt; &gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt; &gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt; &gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt; &gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;<br>&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt; sequences.<br>&gt;&gt;<br>&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;<br>&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt; happen, the standard library team thinks the right design is roughly<br>&gt;&gt; this:<br>&gt;&gt;<br>&gt;&gt;   /// A multipass sequence that may be infinite<br>&gt;&gt;   protocol Collection {<br>&gt;&gt;<br>&gt;&gt;     // Only eager algorithms that can terminate available here<br>&gt;&gt;     func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;<br>&gt;&gt;     // all lazy algorithms available here<br>&gt;&gt;     var lazy: ...<br>&gt;&gt;<br>&gt;&gt;     var startIndex: Index<br>&gt;&gt;     var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;<br>&gt;&gt;     associatedtype SubSequence : Collection<br>&gt;&gt;     // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   protocol FiniteCollection : Collection {<br>&gt;&gt;<br>&gt;&gt;     // All eager algorithms available here<br>&gt;&gt;     func map(...) -&gt;<br>&gt;&gt;     var count: ...<br>&gt;&gt;   }<br>&gt;&gt;<br>&gt;&gt;   protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;<br>&gt;&gt;   protocol RandomAccessCollection : BidirectionalCollection { ... }<br>&gt;&gt;<br>&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;    sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;    sequence, slice the sequence, find again, etc.<br>&gt;&gt;<br>&gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt;<br>&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;    complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;    different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;    can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;    and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt;<br>&gt;&gt; ## Single Pass Iteration<br>&gt;&gt;<br>&gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt; problematic, because it means either:<br>&gt;&gt;<br>&gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt;    nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt;<br>&gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>&gt;&gt;    sequences. IMO that would be totally unacceptable.<br>&gt;&gt;<br>&gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt; Sequence altogether, and the protocol for single-pass iteration becomes<br>&gt;&gt; Iterator.<br>&gt;&gt;<br>&gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt;<br>&gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>&gt;&gt; argue over the definition of copy for classes; this is the one built<br>&gt;&gt; into the lowest level of the language—I refer to the other one, that<br>&gt;&gt; requires allocation, as “clone”).<br>&gt;&gt;<br>&gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt; sequences with “move-only” value types, which cannot be copied. You can<br>&gt;&gt; find move-only types in languages like Rust and C++, but they are not<br>&gt;&gt; supported by Swift today.  So it seems reasonable that all Iterators in<br>&gt;&gt; Swift today should be modeled as classes.<br>&gt;&gt;<br>&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt;&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt;&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt;&gt; Iterator protocol would not be labeled as mutating.<br>&gt;&gt;<br>&gt;&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt;&gt; in this area.  One possibility under consideration is simply dropping<br>&gt;&gt; support for single-pass sequences until Swift can support move-only<br>&gt;&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt; the standard library.<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 30 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; If Iterators become reference types that model single-pass sequences and<br>&gt;&gt; becomes for-in-able, as the write-up suggests, couldn&#39;t Sequence be<br>&gt;&gt; stipulated to be multipass and retain its refinement relationship with<br>&gt;&gt; Collection?<br>&gt; <br>&gt; AFAIK there is no interesting multipass Sequence that cannot reasonably be<br>&gt; made to support indexing.<br>&gt; <br>&gt; There *is* existing code that exposes multipass data structures without<br>&gt; exposing the ability to compare iteration state for equality.  <br></p><p>It’s worth noting that indices require comparability, not just equality.  I think comparability might cause more difficulty than equality (but haven’t thought too hard about it).<br></p><p>&gt; In every<br>&gt; case I can think of, index equality could easily have been exposed, but<br>&gt; wasn&#39;t.These designs can&#39;t be adapted to model Collection.<br></p><p>Why can’t they be adapted to model Collection if equality could have been exposed?  Is it because comparability would be difficult?<br></p><p>&gt; <br>&gt; Those designs are real, but I am unconvinced they are worth supporting<br>&gt; directly with a separate protocol in the standard library; I&#39;m willing<br>&gt; to accept the idea that those data structures will simply be limited to<br>&gt; modeling Iterator.<br></p><p>Can you elaborate on what designs / data structures you’re talking about here?<br></p><p>&gt; <br>&gt;&gt; On Thu, Jun 30, 2016 at 12:26 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt; happen, the standard library team thinks the right design is roughly<br>&gt;&gt;&gt; this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;  protocol Collection {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // all lazy algorithms available here<br>&gt;&gt;&gt;    var lazy: ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    var startIndex: Index<br>&gt;&gt;&gt;    var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    associatedtype SubSequence : Collection<br>&gt;&gt;&gt;    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol FiniteCollection : Collection {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;    // All eager algorithms available here<br>&gt;&gt;&gt;    func map(...) -&gt;<br>&gt;&gt;&gt;    var count: ...<br>&gt;&gt;&gt;  }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protocol RandomAccessCollection : BidirectionalCollection { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt;&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;&gt;   sequence, slice the sequence, find again, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;&gt;   complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;&gt;   different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;&gt;   can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;&gt;   and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Single Pass Iteration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt;&gt; problematic, because it means either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt;&gt;   nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>&gt;&gt;&gt;   sequences. IMO that would be totally unacceptable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt;&gt; Sequence altogether, and the protocol for single-pass iteration becomes<br>&gt;&gt;&gt; Iterator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>&gt;&gt;&gt; argue over the definition of copy for classes; this is the one built<br>&gt;&gt;&gt; into the lowest level of the language—I refer to the other one, that<br>&gt;&gt;&gt; requires allocation, as “clone”).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt;&gt; sequences with “move-only” value types, which cannot be copied. You can<br>&gt;&gt;&gt; find move-only types in languages like Rust and C++, but they are not<br>&gt;&gt;&gt; supported by Swift today.  So it seems reasonable that all Iterators in<br>&gt;&gt;&gt; Swift today should be modeled as classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt;&gt;&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt;&gt;&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt;&gt;&gt; Iterator protocol would not be labeled as mutating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt;&gt;&gt; in this area.  One possibility under consideration is simply dropping<br>&gt;&gt;&gt; support for single-pass sequences until Swift can support move-only<br>&gt;&gt;&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt;&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt;&gt; the standard library.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/3548e93d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 30, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jun 30 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; If Iterators become reference types that model single-pass sequences and<br>&gt;&gt;&gt; becomes for-in-able, as the write-up suggests, couldn&#39;t Sequence be<br>&gt;&gt;&gt; stipulated to be multipass and retain its refinement relationship with<br>&gt;&gt;&gt; Collection?<br>&gt;&gt; <br>&gt;&gt; AFAIK there is no interesting multipass Sequence that cannot reasonably be<br>&gt;&gt; made to support indexing.<br>&gt;&gt; <br>&gt;&gt; There *is* existing code that exposes multipass data structures without<br>&gt;&gt; exposing the ability to compare iteration state for equality.  <br>&gt;<br>&gt; It’s worth noting that indices require comparability, not just<br>&gt; equality.  I think comparability might cause more difficulty than<br>&gt; equality (but haven’t thought too hard about it).<br></p><p>It does, but I am ever more strongly motivated to drop the comparability<br>requirement.<br></p><p>&gt;&gt; In every case I can think of, index equality could easily have been<br>&gt;&gt; exposed, but wasn&#39;t.These designs can&#39;t be adapted to model<br>&gt;&gt; Collection.<br>&gt;<br>&gt; Why can’t they be adapted to model Collection if equality could have<br>&gt; been exposed?  Is it because comparability would be difficult?<br></p><p>Comparabile refines Equatable, so it&#39;s at *least* as hard ;-)<br></p><p>&gt;&gt; Those designs are real, but I am unconvinced they are worth supporting<br>&gt;&gt; directly with a separate protocol in the standard library; I&#39;m willing<br>&gt;&gt; to accept the idea that those data structures will simply be limited to<br>&gt;&gt; modeling Iterator.<br>&gt;<br>&gt; Can you elaborate on what designs / data structures you’re talking<br>&gt; about here?<br></p><p>Cocoa Dictionaries and Sets are examples.  The enumeration interface<br>doesn&#39;t have any facility for copying or comparing enumeration state.<br></p><p>&gt;&gt;&gt; On Thu, Jun 30, 2016 at 12:26 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt;&gt; happen, the standard library team thinks the right design is roughly<br>&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;&gt;  protocol Collection {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;&gt;    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // all lazy algorithms available here<br>&gt;&gt;&gt;&gt;    var lazy: ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    var startIndex: Index<br>&gt;&gt;&gt;&gt;    var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    associatedtype SubSequence : Collection<br>&gt;&gt;&gt;&gt;    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  protocol FiniteCollection : Collection {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;    // All eager algorithms available here<br>&gt;&gt;&gt;&gt;    func map(...) -&gt;<br>&gt;&gt;&gt;&gt;    var count: ...<br>&gt;&gt;&gt;&gt;  }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  protocol RandomAccessCollection : BidirectionalCollection { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt;&gt;&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;&gt;&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;&gt;&gt;   sequence, slice the sequence, find again, etc.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt;&gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;&gt;&gt;   complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;&gt;&gt;   different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;&gt;&gt;   can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;&gt;&gt;   and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Single Pass Iteration<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt;&gt;&gt; problematic, because it means either:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt;&gt;&gt;   nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>&gt;&gt;&gt;&gt;   sequences. IMO that would be totally unacceptable.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt;&gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt;&gt;&gt; Sequence altogether, and the protocol for single-pass iteration becomes<br>&gt;&gt;&gt;&gt; Iterator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>&gt;&gt;&gt;&gt; argue over the definition of copy for classes; this is the one built<br>&gt;&gt;&gt;&gt; into the lowest level of the language—I refer to the other one, that<br>&gt;&gt;&gt;&gt; requires allocation, as “clone”).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt;&gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt;&gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt;&gt;&gt; sequences with “move-only” value types, which cannot be copied. You can<br>&gt;&gt;&gt;&gt; find move-only types in languages like Rust and C++, but they are not<br>&gt;&gt;&gt;&gt; supported by Swift today.  So it seems reasonable that all Iterators in<br>&gt;&gt;&gt;&gt; Swift today should be modeled as classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt;&gt;&gt;&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt;&gt;&gt;&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt;&gt;&gt;&gt; Iterator protocol would not be labeled as mutating.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt;&gt;&gt;&gt; in this area.  One possibility under consideration is simply dropping<br>&gt;&gt;&gt;&gt; support for single-pass sequences until Swift can support move-only<br>&gt;&gt;&gt;&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt;&gt;&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt;&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt;&gt;&gt; the standard library.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 11:07 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Thu Jun 30 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If Iterators become reference types that model single-pass sequences and<br>&gt;&gt;&gt;&gt; becomes for-in-able, as the write-up suggests, couldn&#39;t Sequence be<br>&gt;&gt;&gt;&gt; stipulated to be multipass and retain its refinement relationship with<br>&gt;&gt;&gt;&gt; Collection?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; AFAIK there is no interesting multipass Sequence that cannot reasonably be<br>&gt;&gt;&gt; made to support indexing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There *is* existing code that exposes multipass data structures without<br>&gt;&gt;&gt; exposing the ability to compare iteration state for equality.  <br>&gt;&gt; <br>&gt;&gt; It’s worth noting that indices require comparability, not just<br>&gt;&gt; equality.  I think comparability might cause more difficulty than<br>&gt;&gt; equality (but haven’t thought too hard about it).<br>&gt; <br>&gt; It does, but I am ever more strongly motivated to drop the comparability<br>&gt; requirement.<br></p><p>Dropping that would eliminate the questions that are still lingering in my mind about getting rid of `Sequence`.<br></p><p>Are there any important algorithms that rely on the ability to compare indices?<br></p><p>&gt; <br>&gt;&gt;&gt; In every case I can think of, index equality could easily have been<br>&gt;&gt;&gt; exposed, but wasn&#39;t.These designs can&#39;t be adapted to model<br>&gt;&gt;&gt; Collection.<br>&gt;&gt; <br>&gt;&gt; Why can’t they be adapted to model Collection if equality could have<br>&gt;&gt; been exposed?  Is it because comparability would be difficult?<br>&gt; <br>&gt; Comparabile refines Equatable, so it&#39;s at *least* as hard ;-)<br></p><p>Right.  You only mentioned that index equality could have been exposed but didn’t mention comparability.  I was wondering whether the potential additional difficulty is why they couldn’t model Collection.<br></p><p>&gt; <br>&gt;&gt;&gt; Those designs are real, but I am unconvinced they are worth supporting<br>&gt;&gt;&gt; directly with a separate protocol in the standard library; I&#39;m willing<br>&gt;&gt;&gt; to accept the idea that those data structures will simply be limited to<br>&gt;&gt;&gt; modeling Iterator.<br>&gt;&gt; <br>&gt;&gt; Can you elaborate on what designs / data structures you’re talking<br>&gt;&gt; about here?<br>&gt; <br>&gt; Cocoa Dictionaries and Sets are examples.  The enumeration interface<br>&gt; doesn&#39;t have any facility for copying or comparing enumeration state.<br></p><p>What impact would that have on the bridged value types (which is how we should be using those in Swift).<br></p><p>&gt; <br>&gt;&gt;&gt;&gt; On Thu, Jun 30, 2016 at 12:26 Dave Abrahams via swift-evolution &lt;<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt;&gt;&gt; happen, the standard library team thinks the right design is roughly<br>&gt;&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;&gt;&gt;   func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // all lazy algorithms available here<br>&gt;&gt;&gt;&gt;&gt;   var lazy: ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   var startIndex: Index<br>&gt;&gt;&gt;&gt;&gt;   var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   associatedtype SubSequence : Collection<br>&gt;&gt;&gt;&gt;&gt;   // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol FiniteCollection : Collection {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   // All eager algorithms available here<br>&gt;&gt;&gt;&gt;&gt;   func map(...) -&gt;<br>&gt;&gt;&gt;&gt;&gt;   var count: ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol RandomAccessCollection : BidirectionalCollection { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt;&gt;&gt;&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;&gt;&gt;&gt;  sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;&gt;&gt;&gt;  sequence, slice the sequence, find again, etc.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt;&gt;&gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;&gt;&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;&gt;&gt;&gt;  complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;&gt;&gt;&gt;  different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;&gt;&gt;&gt;  can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;&gt;&gt;&gt;  and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Single Pass Iteration<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt;&gt;&gt;&gt; problematic, because it means either:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt;&gt;&gt;&gt;  nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>&gt;&gt;&gt;&gt;&gt;  sequences. IMO that would be totally unacceptable.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt;&gt;&gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt;&gt;&gt;&gt; Sequence altogether, and the protocol for single-pass iteration becomes<br>&gt;&gt;&gt;&gt;&gt; Iterator.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>&gt;&gt;&gt;&gt;&gt; argue over the definition of copy for classes; this is the one built<br>&gt;&gt;&gt;&gt;&gt; into the lowest level of the language—I refer to the other one, that<br>&gt;&gt;&gt;&gt;&gt; requires allocation, as “clone”).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt;&gt;&gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt;&gt;&gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt;&gt;&gt;&gt; sequences with “move-only” value types, which cannot be copied. You can<br>&gt;&gt;&gt;&gt;&gt; find move-only types in languages like Rust and C++, but they are not<br>&gt;&gt;&gt;&gt;&gt; supported by Swift today.  So it seems reasonable that all Iterators in<br>&gt;&gt;&gt;&gt;&gt; Swift today should be modeled as classes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt;&gt;&gt;&gt;&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt;&gt;&gt;&gt;&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt;&gt;&gt;&gt;&gt; Iterator protocol would not be labeled as mutating.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt;&gt;&gt;&gt;&gt; in this area.  One possibility under consideration is simply dropping<br>&gt;&gt;&gt;&gt;&gt; support for single-pass sequences until Swift can support move-only<br>&gt;&gt;&gt;&gt;&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt;&gt;&gt;&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt;&gt;&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt;&gt;&gt;&gt; the standard library.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; Dave<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Dave<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 11:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 11:07 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 30, 2016, at 5:32 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Thu Jun 30 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com &lt;http://xiaodi.wu-at-gmail.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If Iterators become reference types that model single-pass sequences and<br>&gt;&gt;&gt;&gt;&gt; becomes for-in-able, as the write-up suggests, couldn&#39;t Sequence be<br>&gt;&gt;&gt;&gt;&gt; stipulated to be multipass and retain its refinement relationship with<br>&gt;&gt;&gt;&gt;&gt; Collection?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; AFAIK there is no interesting multipass Sequence that cannot reasonably be<br>&gt;&gt;&gt;&gt; made to support indexing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There *is* existing code that exposes multipass data structures without<br>&gt;&gt;&gt;&gt; exposing the ability to compare iteration state for equality.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It’s worth noting that indices require comparability, not just<br>&gt;&gt;&gt; equality.  I think comparability might cause more difficulty than<br>&gt;&gt;&gt; equality (but haven’t thought too hard about it).<br>&gt;&gt; <br>&gt;&gt; It does, but I am ever more strongly motivated to drop the comparability<br>&gt;&gt; requirement.<br>&gt;<br>&gt; Dropping that would eliminate the questions that are still lingering<br>&gt; in my mind about getting rid of `Sequence`.<br>&gt;<br>&gt; Are there any important algorithms that rely on the ability to compare<br>&gt; indices?<br></p><p>No.  When the collection has random access, you can always measure<br>distance using the collection and use its sign.  Algorithms that depend<br>on that ability all require random access anyawy.  If the collection is<br>not random-access but the Index type is comparable, you can use that as<br>well, which may make some new things possible.<br></p><p>&gt;&gt;&gt;&gt; In every case I can think of, index equality could easily have been<br>&gt;&gt;&gt;&gt; exposed, but wasn&#39;t.These designs can&#39;t be adapted to model<br>&gt;&gt;&gt;&gt; Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Why can’t they be adapted to model Collection if equality could have<br>&gt;&gt;&gt; been exposed?  Is it because comparability would be difficult?<br>&gt;&gt; <br>&gt;&gt; Comparabile refines Equatable, so it&#39;s at *least* as hard ;-)<br>&gt;<br>&gt; Right.  You only mentioned that index equality could have been exposed<br>&gt; but didn’t mention comparability.  I was wondering whether the<br>&gt; potential additional difficulty is why they couldn’t model Collection.<br>&gt;<br>&gt;&gt;&gt;&gt; Those designs are real, but I am unconvinced they are worth supporting<br>&gt;&gt;&gt;&gt; directly with a separate protocol in the standard library; I&#39;m willing<br>&gt;&gt;&gt;&gt; to accept the idea that those data structures will simply be limited to<br>&gt;&gt;&gt;&gt; modeling Iterator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you elaborate on what designs / data structures you’re talking<br>&gt;&gt;&gt; about here?<br>&gt;&gt; <br>&gt;&gt; Cocoa Dictionaries and Sets are examples.  The enumeration interface<br>&gt;&gt; doesn&#39;t have any facility for copying or comparing enumeration state.<br>&gt;<br>&gt; What impact would that have on the bridged value types (which is how<br>&gt; we should be using those in Swift).<br></p><p>None.  Today we have a horrible workaround in Swift to make those model<br>Collection: storing an array of keys.  At some point we can get<br>Foundation to do do something friendlier for us, but in the meantime,<br>that still works.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 10:26 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;  It would<br>&gt; be very interesting to know about any real-world models of single-pass<br>&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt; the standard library.<br>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>I already gave an example of this earlier in the thread:<br></p><p>&gt;&gt; I use it in a LazyRowSequence&lt;T: SqlModelConvertible&gt; where querying Sqlite in WAL mode allows multiple concurrent readers to get point-in-time snapshots of the database. The query can’t be replayed without buffering all the rows in memory because Sqlite’s step functions are not bi-directional. In some cases we are talking about tens of thousands of rows (or even hundreds of thousands) and the ability to avoid buffering them is a feature, not a bug.<br></p><p>IMHO the typical case for single-pass is IO. In this case it would work just as well as LazyRowIterator&lt;T&gt; assuming the language allows for-in on an iterator.<br></p><p>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/a08f028f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jun 30 2016, Russ Bishop &lt;xenadu-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 30, 2016, at 10:26 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;  It would<br>&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt; the standard library.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Dave<br>&gt;<br>&gt; I already gave an example of this earlier in the thread:<br></p><p>Yes, I remember that one.  It&#39;s not that I believe these things don&#39;t<br>exist at all; I&#39;m trying to get a read on how important it is that they<br>fit into the standard library&#39;s protocol framework.  For that, I need to<br>know if they are very common.<br></p><p>&gt;&gt;&gt; I use it in a LazyRowSequence&lt;T: SqlModelConvertible&gt; where<br>&gt;&gt;&gt; querying Sqlite in WAL mode allows multiple concurrent readers to<br>&gt;&gt;&gt; get point-in-time snapshots of the database. The query can’t be<br>&gt;&gt;&gt; replayed without buffering all the rows in memory because Sqlite’s<br>&gt;&gt;&gt; step functions are not bi-directional. In some cases we are talking<br>&gt;&gt;&gt; about tens of thousands of rows (or even hundreds of thousands) and<br>&gt;&gt;&gt; the ability to avoid buffering them is a feature, not a bug.<br>&gt;<br>&gt; IMHO the typical case for single-pass is IO. <br></p><p>Yes.  Also, truly-random number generators.<br></p><p>&gt; In this case it would work just as well as LazyRowIterator&lt;T&gt; assuming<br>&gt; the language allows for-in on an iterator.<br></p><p>So, you&#39;re not interested in using algorithms like map and filter on<br>these things?<br></p><p>If it was just about for-in, we could say you can for-in over any<br>instance of<br></p><p>   ()-&gt;T? <br></p><p>for example.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 3:37 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt;&gt; I use it in a LazyRowSequence&lt;T: SqlModelConvertible&gt; where<br>&gt;&gt;&gt;&gt; querying Sqlite in WAL mode allows multiple concurrent readers to<br>&gt;&gt;&gt;&gt; get point-in-time snapshots of the database. The query can’t be<br>&gt;&gt;&gt;&gt; replayed without buffering all the rows in memory because Sqlite’s<br>&gt;&gt;&gt;&gt; step functions are not bi-directional. In some cases we are talking<br>&gt;&gt;&gt;&gt; about tens of thousands of rows (or even hundreds of thousands) and<br>&gt;&gt;&gt;&gt; the ability to avoid buffering them is a feature, not a bug.<br>&gt;&gt; <br>&gt;&gt; IMHO the typical case for single-pass is IO. <br>&gt; <br>&gt; Yes.  Also, truly-random number generators.<br>&gt; <br>&gt;&gt; In this case it would work just as well as LazyRowIterator&lt;T&gt; assuming<br>&gt;&gt; the language allows for-in on an iterator.<br>&gt; <br>&gt; So, you&#39;re not interested in using algorithms like map and filter on<br>&gt; these things?<br>&gt; <br>&gt; If it was just about for-in, we could say you can for-in over any<br>&gt; instance of<br>&gt; <br>&gt;   ()-&gt;T? <br>&gt; <br></p><p>Fair point; we actually do take advantage of the lazy versions of filter and map. <br></p><p>Does it make sense to say that single-pass sequences are always lazy?<br></p><p>               Iterable<br>          /                    \<br>	 /                       \<br>  LazyIterable      EagerIterable<br>       |                             |<br> LazyCollection       Collection<br></p><p><br></p><p>LazyCollection is a wrapper around Collection so you can still use .lazy the way you would today.<br>LazyIterables are single-pass.<br>EagerIterables are multi-pass.<br></p><p><br></p><p>Maybe this doesn’t work because we’re talking about somewhat orthogonal things? I could imagine trying to model the idea of single vs multi pass and lazy vs eager separately:<br></p><p>&gt; protocol Iterable {<br>&gt;     associatedtype Iterator: IteratorProtocol<br>&gt;     associatedtype Element = Iterator.Element<br>&gt;     func makeIterator() -&gt; Iterator<br>&gt; }<br>&gt; protocol MultiIterable: Iterable { }<br>&gt; protocol SingleIterable: Iterable { }<br>&gt; protocol LazyIterable: Iterable { }<br>&gt; protocol EagerIterable: Iterable { }<br>&gt; <br>&gt; extension MultiIterable where Self: EagerIterable {<br>&gt;     func map&lt;U&gt;(t: @noescape (Element) -&gt; U) -&gt; [U] { }<br>&gt; }<br>&gt; <br>&gt; extension MultiIterable where Self: LazyIterable {<br>&gt;     func map&lt;U&gt;(t: (Element) -&gt; U) -&gt; LazyMapMultiIterable&lt;Self&gt; { }<br>&gt; }<br>&gt; <br>&gt; extension SingleIterable where Self: LazyIterable {<br>&gt;     func map&lt;U&gt;(t: (Element) -&gt; U) -&gt; LazyMapSingleIterable&lt;Self&gt; { }<br>&gt; }<br></p><p><br>I guess it comes back to what you and others have pointed out - it might not be worth the effort to provide this level of flexibility.<br></p><p>Russ<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/7c0b44ea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 30, 2016 at 04:00:00pm</p></header><div class="content"><p>on Thu Jun 30 2016, Russ Bishop &lt;xenadu-AT-gmail.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 30, 2016, at 3:37 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I use it in a LazyRowSequence&lt;T: SqlModelConvertible&gt; where<br>&gt;&gt;&gt;&gt;&gt; querying Sqlite in WAL mode allows multiple concurrent readers to<br>&gt;<br>&gt;&gt;&gt;&gt;&gt; get point-in-time snapshots of the database. The query can’t be<br>&gt;&gt;&gt;&gt;&gt; replayed without buffering all the rows in memory because Sqlite’s<br>&gt;&gt;&gt;&gt;&gt; step functions are not bi-directional. In some cases we are talking<br>&gt;&gt;&gt;&gt;&gt; about tens of thousands of rows (or even hundreds of thousands) and<br>&gt;&gt;&gt;&gt;&gt; the ability to avoid buffering them is a feature, not a bug.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMHO the typical case for single-pass is IO. <br>&gt;&gt; <br>&gt;&gt; Yes.  Also, truly-random number generators.<br>&gt;&gt; <br>&gt;&gt;&gt; In this case it would work just as well as LazyRowIterator&lt;T&gt; assuming<br>&gt;&gt;&gt; the language allows for-in on an iterator.<br>&gt;&gt; <br>&gt;&gt; So, you&#39;re not interested in using algorithms like map and filter on<br>&gt;&gt; these things?<br>&gt;&gt; <br>&gt;&gt; If it was just about for-in, we could say you can for-in over any<br>&gt;&gt; instance of<br>&gt;&gt; <br>&gt;&gt;   ()-&gt;T? <br>&gt;&gt; <br>&gt;<br>&gt; Fair point; we actually do take advantage of the lazy versions of<br>&gt; filter and map.<br>&gt;<br>&gt; Does it make sense to say that single-pass sequences are always lazy?<br></p><p>It might.  Would it be inconvenient?<br></p><p>&gt;<br>&gt;                Iterable<br>&gt;           /                    \<br>&gt; 	 /                       \<br>&gt;   LazyIterable      EagerIterable<br>&gt;        |                             |<br>&gt;  LazyCollection       Collection<br>&gt;<br>&gt; LazyCollection is a wrapper around Collection so you can still use<br>&gt; .lazy the way you would today.<br></p><p>Is it a protocol?  Wrappers are usually generics.<br></p><p>&gt; <br>&gt; LazyIterables are single-pass.  EagerIterables are multi-pass.<br>&gt; Maybe this doesn’t work because we’re talking about somewhat<br>&gt; orthogonal things? I could imagine trying to model the idea of single<br>&gt; vs multi pass and lazy vs eager separately:<br></p><p>The goal of generic programming is not to separate every idea into its<br>own protocol.  Discovering the natural dependency relationships and<br>clusters of requirements and capabilities is a crucial part of it.  As<br>far as I can tell, lazy operations are always appropriate.<br></p><p>&gt;<br>&gt;&gt; protocol Iterable {<br>&gt;&gt;     associatedtype Iterator: IteratorProtocol<br>&gt;&gt;     associatedtype Element = Iterator.Element<br>&gt;&gt;     func makeIterator() -&gt; Iterator<br>&gt;&gt; }<br>&gt;&gt; protocol MultiIterable: Iterable { }<br>&gt;&gt; protocol SingleIterable: Iterable { }<br>&gt;&gt; protocol LazyIterable: Iterable { }<br>&gt;&gt; protocol EagerIterable: Iterable { }<br>&gt;&gt; <br>&gt;&gt; extension MultiIterable where Self: EagerIterable {<br>&gt;&gt;     func map&lt;U&gt;(t: @noescape (Element) -&gt; U) -&gt; [U] { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension MultiIterable where Self: LazyIterable {<br>&gt;&gt;     func map&lt;U&gt;(t: (Element) -&gt; U) -&gt; LazyMapMultiIterable&lt;Self&gt; { }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension SingleIterable where Self: LazyIterable {<br>&gt;&gt;     func map&lt;U&gt;(t: (Element) -&gt; U) -&gt; LazyMapSingleIterable&lt;Self&gt; { }<br>&gt;&gt; }<br>&gt;<br>&gt; I guess it comes back to what you and others have pointed out - it<br>&gt; might not be worth the effort to provide this level of flexibility.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 18:26, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt; A: Because the operations on indices apply equally well whether the<br>&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;   sequence, slice the sequence, find again, etc.<br></p><p>Would it not make more sense for sequences that can benefit from subscripts to just conform to Indexable? It seems like having basically all of the Collection-specific methods on Sequence too would be confusing, and dilute any nothing that these are sequences where elements are supposed to be consumed in-order, as it would give the illusion that you can skip around with the convenience of an array.<br></p><p>There&#39;s also the issue of how you would even index something that&#39;s potentially infinite; you&#39;d need to use a big integer in which case you could end up with your indices growing to infinite size over time? It may not be very obvious that this could be the case.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/13ac405c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 30, 2016 at 03:00:00pm</p></header><div class="content"><p>on Thu Jun 30 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br></p><p>&gt;&gt; On 30 Jun 2016, at 18:26, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;   sequence, slice the sequence, find again, etc.<br>&gt;<br>&gt; Would it not make more sense for sequences that can benefit from<br>&gt; subscripts to just conform to Indexable? <br></p><p>All multi-pass sequences can benefit from subscripts.<br></p><p>&gt; It seems like having basically all of the Collection-specific methods<br>&gt; on Sequence too would be confusing, and dilute any nothing that these<br>&gt; are sequences where elements are supposed to be consumed in-order, as<br>&gt; it would give the illusion that you can skip around with the<br>&gt; convenience of an array.<br></p><p>If traversal consumes the sequence, it is a single-pass thing.<br></p><p>&gt; There&#39;s also the issue of how you would even index something that&#39;s<br>&gt; potentially infinite; you&#39;d need to use a big integer in which case<br>&gt; you could end up with your indices growing to infinite size over time?<br></p><p>It&#39;s trivial; the index contains the iteration state.  The only<br>fundamental difference between the constraints on Iterator and the<br>constraints on an Index is that Iterator doesn&#39;t support comparison for<br>equality.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  1, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 30 Jun 2016, at 23:39, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; All multi-pass sequences can benefit from subscripts.<br></p><p>Sorry, not really what I meant, but rather; how many sequences are really going to use them?<br></p><p>&gt; It&#39;s trivial; the index contains the iteration state.  The only<br>&gt; fundamental difference between the constraints on Iterator and the<br>&gt; constraints on an Index is that Iterator doesn&#39;t support comparison for<br>&gt; equality.<br></p><p>Won&#39;t this make implementing sequences more complex? Sequences are currently dead easy to implement, and to implement in an ad-hoc way via AnySequence(body:), how would that be done under this required indexing scheme? I just feel like things are easiest if Sequence is simply tweaked to require that it&#39;s iterators must be non-destructive, as implementing them will be just as easy, at which point it&#39;s just a matter of separating out which methods take Sequences and which take Iterators.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  1, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 12:34 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt; <br>&gt; Sequences are currently dead easy to implement, and to implement in an ad-hoc way via AnySequence(body:), how would that be done under this required indexing scheme?<br></p><p>`sequence(state:next:)` could be adapted into a possibly-infinite `Collection`, and it&#39;s not much more difficult to use than `AnySequence`. (Although it would be more efficient to use a custom iterator for it than it would be to iterate with its indices.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 07:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Brent Royal-Gordon &lt;brent-AT-architechies.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 12:34 AM, Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Sequences are currently dead easy to implement, and to implement in<br>&gt;&gt; an ad-hoc way via AnySequence(body:), how would that be done under<br>&gt;&gt; this required indexing scheme?<br>&gt;<br>&gt; `sequence(state:next:)` could be adapted into a possibly-infinite<br>&gt; `Collection`, and it&#39;s not much more difficult to use than<br>&gt; `AnySequence`.<br></p><p>Yes, the state would gain an Equatable constraint, that&#39;s all.<br></p><p>&gt; (Although it would be more efficient to use a custom<br>&gt; iterator for it than it would be to iterate with its indices.)<br></p><p>Whether the resulting collection is going to be efficient after<br>optimization depends on many factors.  I can easily imagine this being<br>optimal:<br></p><p>  for i in collection(<br>     first: 0, next: { state in state &lt; 100 ? state + 5 : nil }) {<br>     print(i)<br>  }<br></p><p>However, it is true that the most reliable path to efficiency is always<br>going to be to encode the state and next in a protocol conformance<br></p><p>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 07:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br></p><p>&gt;&gt; On 30 Jun 2016, at 23:39, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; All multi-pass sequences can benefit from subscripts.<br>&gt;<br>&gt; Sorry, not really what I meant, but rather; how many sequences are<br>&gt; really going to use them?<br></p><p>The subscript and index aren&#39;t there for the sequence&#39;s benefit, and you<br>can&#39;t know how users will want to use the sequence.  The whole point of<br>making a type conform to a generic protocol is that you can&#39;t anticipate<br>all of the type&#39;s uses, so you want to make it work with as much other<br>code as possible.  If I&#39;m defining a new sequence type, how can I know<br>whether someone might want to use index(of:) or slicing on it?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 9:47 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 01 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 23:39, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; All multi-pass sequences can benefit from subscripts.<br>&gt;&gt; <br>&gt;&gt; Sorry, not really what I meant, but rather; how many sequences are<br>&gt;&gt; really going to use them?<br>&gt; <br>&gt; The subscript and index aren&#39;t there for the sequence&#39;s benefit, and you<br>&gt; can&#39;t know how users will want to use the sequence.  The whole point of<br>&gt; making a type conform to a generic protocol is that you can&#39;t anticipate<br>&gt; all of the type&#39;s uses, so you want to make it work with as much other<br>&gt; code as possible.  If I&#39;m defining a new sequence type, how can I know<br>&gt; whether someone might want to use index(of:) or slicing on it?<br></p><p>This isn’t entirely true.  Sometimes we know *exactly* how a type will be used in an application.  It conforms to a generic protocol in order to take advantage of pre-existing generic code (algorithms, etc) in the standard library (or other libraries).  <br></p><p>If the library contains algorithms expressed in terms of the weakest constraints possible (i.e. the current `Sequence` algorithms) sometimes we can accomplish what is necessary without needing to implement additional members on our type, even if it is possible to implement them and theoretically useful (but not useful to the current requirements of the application).<br></p><p>That said, I generally like the direction you suggesting.  <br></p><p>I have been considering the incremental complexity of conforming to `Collection` rather than `Sequence` carefully.  The one place that I still need to think further about is the `Comparable` requirement on indices and whether that might lead to nontrivial complexity over a `Sequence` conformance.  <br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 9:47 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 01 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On 30 Jun 2016, at 23:39, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; All multi-pass sequences can benefit from subscripts.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sorry, not really what I meant, but rather; how many sequences are<br>&gt;&gt;&gt; really going to use them?<br>&gt;&gt; <br>&gt;&gt; The subscript and index aren&#39;t there for the sequence&#39;s benefit, and you<br>&gt;&gt; can&#39;t know how users will want to use the sequence.  The whole point of<br>&gt;&gt; making a type conform to a generic protocol is that you can&#39;t anticipate<br>&gt;&gt; all of the type&#39;s uses, so you want to make it work with as much other<br>&gt;&gt; code as possible.  If I&#39;m defining a new sequence type, how can I know<br>&gt;&gt; whether someone might want to use index(of:) or slicing on it?<br>&gt;<br>&gt; This isn’t entirely true.  Sometimes we know *exactly* how a type will<br>&gt; be used in an application.  It conforms to a generic protocol in order<br>&gt; to take advantage of pre-existing generic code (algorithms, etc) in<br>&gt; the standard library (or other libraries).<br>&gt;<br>&gt; If the library contains algorithms expressed in terms of the weakest<br>&gt; constraints possible (i.e. the current `Sequence` algorithms)<br>&gt; sometimes we can accomplish what is necessary without needing to<br>&gt; implement additional members on our type, even if it is possible to<br>&gt; implement them and theoretically useful (but not useful to the current<br>&gt; requirements of the application).<br></p><p>Yes, but requirements clustering is absolutely essential to creating<br>coherent generic libraries.  Otherwise you end up with a billion little<br>granular protocols, to no real purpose.<br></p><p>&gt; That said, I generally like the direction you suggesting.  <br>&gt;<br>&gt; I have been considering the incremental complexity of conforming to<br>&gt; `Collection` rather than `Sequence` carefully.  The one place that I<br>&gt; still need to think further about is the `Comparable` requirement on<br>&gt; indices and whether that might lead to nontrivial complexity over a<br>&gt; `Sequence` conformance.<br></p><p>It might, but let&#39;s drop it.  The only *real* reason we have it is to<br>provide nice precondition checking for Range construction, and we can<br>simply make that conditional on comparability.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 11:54 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 9:47 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 01 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 30 Jun 2016, at 23:39, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; All multi-pass sequences can benefit from subscripts.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sorry, not really what I meant, but rather; how many sequences are<br>&gt;&gt;&gt;&gt; really going to use them?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The subscript and index aren&#39;t there for the sequence&#39;s benefit, and you<br>&gt;&gt;&gt; can&#39;t know how users will want to use the sequence.  The whole point of<br>&gt;&gt;&gt; making a type conform to a generic protocol is that you can&#39;t anticipate<br>&gt;&gt;&gt; all of the type&#39;s uses, so you want to make it work with as much other<br>&gt;&gt;&gt; code as possible.  If I&#39;m defining a new sequence type, how can I know<br>&gt;&gt;&gt; whether someone might want to use index(of:) or slicing on it?<br>&gt;&gt; <br>&gt;&gt; This isn’t entirely true.  Sometimes we know *exactly* how a type will<br>&gt;&gt; be used in an application.  It conforms to a generic protocol in order<br>&gt;&gt; to take advantage of pre-existing generic code (algorithms, etc) in<br>&gt;&gt; the standard library (or other libraries).<br>&gt;&gt; <br>&gt;&gt; If the library contains algorithms expressed in terms of the weakest<br>&gt;&gt; constraints possible (i.e. the current `Sequence` algorithms)<br>&gt;&gt; sometimes we can accomplish what is necessary without needing to<br>&gt;&gt; implement additional members on our type, even if it is possible to<br>&gt;&gt; implement them and theoretically useful (but not useful to the current<br>&gt;&gt; requirements of the application).<br>&gt; <br>&gt; Yes, but requirements clustering is absolutely essential to creating<br>&gt; coherent generic libraries.  Otherwise you end up with a billion little<br>&gt; granular protocols, to no real purpose.<br>&gt; <br>&gt;&gt; That said, I generally like the direction you suggesting.  <br>&gt;&gt; <br>&gt;&gt; I have been considering the incremental complexity of conforming to<br>&gt;&gt; `Collection` rather than `Sequence` carefully.  The one place that I<br>&gt;&gt; still need to think further about is the `Comparable` requirement on<br>&gt;&gt; indices and whether that might lead to nontrivial complexity over a<br>&gt;&gt; `Sequence` conformance.<br>&gt; <br>&gt; It might, but let&#39;s drop it.  The only *real* reason we have it is to<br>&gt; provide nice precondition checking for Range construction, and we can<br>&gt; simply make that conditional on comparability.<br></p><p>Cool.  This sounds like a good approach.<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/67161175/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 5:39 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Thu Jun 30 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 30 Jun 2016, at 18:26, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt;&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;&gt;  sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;&gt;  sequence, slice the sequence, find again, etc.<br>&gt;&gt; <br>&gt;&gt; Would it not make more sense for sequences that can benefit from<br>&gt;&gt; subscripts to just conform to Indexable? <br>&gt; <br>&gt; All multi-pass sequences can benefit from subscripts.<br>&gt; <br>&gt;&gt; It seems like having basically all of the Collection-specific methods<br>&gt;&gt; on Sequence too would be confusing, and dilute any nothing that these<br>&gt;&gt; are sequences where elements are supposed to be consumed in-order, as<br>&gt;&gt; it would give the illusion that you can skip around with the<br>&gt;&gt; convenience of an array.<br>&gt; <br>&gt; If traversal consumes the sequence, it is a single-pass thing.<br></p><p>It’s also worth noting that Collection does not imply the ability to skip around “with the convenience of an array” if that means skipping around in constant time.  You need RandomAccessCollection to get that guarantee.<br></p><p>&gt; <br>&gt;&gt; There&#39;s also the issue of how you would even index something that&#39;s<br>&gt;&gt; potentially infinite; you&#39;d need to use a big integer in which case<br>&gt;&gt; you could end up with your indices growing to infinite size over time?<br>&gt; <br>&gt; It&#39;s trivial; the index contains the iteration state.  The only<br>&gt; fundamental difference between the constraints on Iterator and the<br>&gt; constraints on an Index is that Iterator doesn&#39;t support comparison for<br>&gt; equality.<br></p><p>Not just equality, but also general `Comparable` (you’re not considering changing that are you?).<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 30, 2016, at 5:39 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Thu Jun 30 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On 30 Jun 2016, at 18:26, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt;&gt;&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;&gt;&gt;  sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;&gt;&gt;  sequence, slice the sequence, find again, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it not make more sense for sequences that can benefit from<br>&gt;&gt;&gt; subscripts to just conform to Indexable? <br>&gt;&gt; <br>&gt;&gt; All multi-pass sequences can benefit from subscripts.<br>&gt;&gt; <br>&gt;&gt;&gt; It seems like having basically all of the Collection-specific methods<br>&gt;&gt;&gt; on Sequence too would be confusing, and dilute any nothing that these<br>&gt;&gt;&gt; are sequences where elements are supposed to be consumed in-order, as<br>&gt;&gt;&gt; it would give the illusion that you can skip around with the<br>&gt;&gt;&gt; convenience of an array.<br>&gt;&gt; <br>&gt;&gt; If traversal consumes the sequence, it is a single-pass thing.<br>&gt;<br>&gt; It’s also worth noting that Collection does not imply the ability to<br>&gt; skip around “with the convenience of an array” if that means skipping<br>&gt; around in constant time.  You need RandomAccessCollection to get that<br>&gt; guarantee.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; There&#39;s also the issue of how you would even index something that&#39;s<br>&gt;&gt;&gt; potentially infinite; you&#39;d need to use a big integer in which case<br>&gt;&gt;&gt; you could end up with your indices growing to infinite size over time?<br>&gt;&gt; <br>&gt;&gt; It&#39;s trivial; the index contains the iteration state.  The only<br>&gt;&gt; fundamental difference between the constraints on Iterator and the<br>&gt;&gt; constraints on an Index is that Iterator doesn&#39;t support comparison for<br>&gt;&gt; equality.<br>&gt;<br>&gt; Not just equality, but also general `Comparable` (you’re not<br>&gt; considering changing that are you?).<br></p><p>As noted elsewhere: yes, I am strongly considering that.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Matthew<br>&gt;&gt; <br>&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt; <br>&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt; <br>&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt; sequences.<br>&gt; <br>&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt; <br>&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt; happen<br></p><p>I definitely think it’s worth doing.  I really appreciate the attention that the library team has given to this.<br></p><p>&gt; , the standard library team thinks the right design is roughly<br>&gt; this:<br>&gt; <br>&gt;  /// A multipass sequence that may be infinite<br>&gt;  protocol Collection {<br>&gt; <br>&gt;    // Only eager algorithms that can terminate available here<br>&gt;    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt; <br>&gt;    // all lazy algorithms available here<br>&gt;    var lazy: ...<br>&gt; <br>&gt;    var startIndex: Index<br>&gt;    var endIndex: Index // possibly not reachable from startIndex<br>&gt; <br>&gt;    associatedtype SubSequence : Collection<br>&gt;    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;  }<br>&gt; <br>&gt;  protocol FiniteCollection : Collection {<br>&gt; <br>&gt;    // All eager algorithms available here<br>&gt;    func map(...) -&gt;<br>&gt;    var count: ...<br>&gt;  }<br>&gt; <br>&gt;  protocol BidirectionalCollection : Collection { ... }<br>&gt; <br>&gt;  protocol RandomAccessCollection : BidirectionalCollection { … }<br></p><p>Does this design entirely break with the relationship between collections and iterators (dropping `makeIterator` as a protocol requirement)?  <br></p><p>If so, would for..in (over collections) be built on top of indices and use `formIndex(after:)`?  Would it require a finite collection (unless we add `until` to the language and then allow `for..in..until` to work with infinite collections)?<br></p><p>Would we still retain `IndexingIterator`even if we break the relationship in the protocol requirements? <br></p><p>Would it still be possible to do things like zip a multi-pass sequence with a single-pass sequence (assuming we keep single-pass sequences or add them back eventually)?  This seems like a use case worth supporting in some way.<br></p><p><br>One subtle change I think this implies is that things like `LazyFilterSequence` can implement `makeIterator` with constant complexity, deferring the O(N) complexity to the first call to `next`.  `startIndex` for `LazyFilterCollection` currently has O(N) complexity.  The complexity of a complete iteration doesn’t change and probably isn’t a big deal, but it’s worth noting.<br></p><p><br></p><p>I’ve been looking at some code that wraps a sequence and considering how it would be impacted.  With iterators it looks like this:<br></p><p>guard let element = base.next()<br>  else { return nil }<br></p><p><br>With collections and indices it would look something like this:<br></p><p>base.formIndex(after: &amp;index)<br>guard index != baseEndIndex<br>   else { return endIndex }<br></p><p>let element = base[index]<br></p><p>That’s not too bad but it is more verbose.  If we’re going to push people towards collections and indices we should try to make common patterns like “update the iteration state and return the next element if there is one&quot; simpler.  This could be accomplished with an extension method along these lines:<br></p><p>guard let element = base.formIndex(after: &amp;index, .returningOptionalElement)<br>    else { return endIndex }<br></p><p>With an implementation something like:<br></p><p>enum FormIndexResult {<br>    .returningOptionalElement<br>}<br>extension Collection {<br>    func formIndex(after i: inout Self.Index, _ result: FormIndexResult) -&gt; Self.Element?<br>}<br></p><p>This would provide similar functionality to `IndexingIterator` without coupling the storage of `elements` and `position` (which is important if you’re wrapping a collection and need to wrap the collection and its indices independently).<br></p><p>&gt; <br>&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt; A: Because the operations on indices apply equally well whether the<br>&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;   sequence, slice the sequence, find again, etc.<br>&gt; <br>&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt; A: So you can write algorithms such as index(where:) once.<br>&gt; <br>&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;   complexity in typical usage.  A classic use case that argues for a<br>&gt;   different endIndex type is the null-terminated C string.  But you<br>&gt;   can&#39;t index one of those safely without actually counting the length,<br>&gt;   and once you&#39;ve done that you can make the endIndex an Int.<br></p><p>It’s also worth nothing that we can use `Optional` with `nil` as the `endIndex` sentinel if necessary.<br></p><p>&gt; <br>&gt; ## Single Pass Iteration<br>&gt; <br>&gt; The refinement relationship between Sequence and Collection is<br>&gt; problematic, because it means either:<br>&gt; <br>&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;   nonmutating even though it&#39;s a lie (status quo)<br>&gt; <br>&gt; b) those algorithms can&#39;t be used on immutable (“let bound”) multipass<br>&gt;   sequences. IMO that would be totally unacceptable.<br>&gt; <br>&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt; Sequence altogether, and the protocol for single-pass iteration becomes<br>&gt; Iterator.<br></p><p>Makes sense to me.<br></p><p>&gt; <br>&gt; ### Mutation and Reference Semantics<br>&gt; <br>&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please not<br>&gt; argue over the definition of copy for classes; this is the one built<br>&gt; into the lowest level of the language—I refer to the other one, that<br>&gt; requires allocation, as “clone”).<br>&gt; <br>&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt; has reference semantics. One day we may be able to model single-pass<br>&gt; sequences with “move-only” value types, which cannot be copied. You can<br>&gt; find move-only types in languages like Rust and C++, but they are not<br>&gt; supported by Swift today.  So it seems reasonable that all Iterators in<br>&gt; Swift today should be modeled as classes.<br></p><p>I think this makes a lot of sense in the model you are proposing.  All multipass structures are collections.  Any sequence that can only support a single pass is modeled as an iterator which inherently has identity.  Making this distinction strong will prevent any confusion.<br></p><p>&gt; <br>&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt; Iterator protocol would not be labeled as mutating.<br>&gt; <br>&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt; in this area.  One possibility under consideration is simply dropping<br>&gt; support for single-pass sequences until Swift can support move-only<br>&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt; be very interesting to know about any real-world models of single-pass<br>&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt; the standard library.<br></p><p>I’m happy to see you mention a mutation model for class instances!  (I don’t mean to sidetrack the discussion, but would love to see that someday)<br></p><p>I don’t have any objection to dropping support for single-pass sequences temporarily.  It’s possible that I would feel differently if I was making use of them in my own code but I’m not.<br></p><p>In the meantime, people would be able to implement their own protocol for single pass sequences.  What they would lose is for..in as well as the standard library algorithms.  I’m not sure how many people this would impact or how big the impact would be for them.  We have seen a couple of examples in this discussion, but probably not enough to asses the overall impact.<br></p><p>One thing you don’t mention here is a distinction between finite and infinite single-pass sequences (iterators).  I don’t know if the finite / infinite distinction is as important here, but wanted to point it out.  Obviously if we remove support single-pass sequences now we could defer that discussion until we’re ready to bring back support for them.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 09:00:00am</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt; <br>&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt; sequences.<br>&gt;&gt; <br>&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt; <br>&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt; happen<br>&gt;<br>&gt; I definitely think it’s worth doing.  <br></p><p>Opinions are nice, but rationales are better.  How will we understand<br>*why* it&#39;s worth doing?<br></p><p>&gt; I really appreciate the attention that the library team has given to<br>&gt; this.<br>&gt;<br>&gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt; this:<br>&gt;&gt; <br>&gt;&gt;  /// A multipass sequence that may be infinite<br>&gt;&gt;  protocol Collection {<br>&gt;&gt; <br>&gt;&gt;    // Only eager algorithms that can terminate available here<br>&gt;&gt;    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt; <br>&gt;&gt;    // all lazy algorithms available here<br>&gt;&gt;    var lazy: ...<br>&gt;&gt; <br>&gt;&gt;    var startIndex: Index<br>&gt;&gt;    var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt; <br>&gt;&gt;    associatedtype SubSequence : Collection<br>&gt;&gt;    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  protocol FiniteCollection : Collection {<br>&gt;&gt; <br>&gt;&gt;    // All eager algorithms available here<br>&gt;&gt;    func map(...) -&gt;<br>&gt;&gt;    var count: ...<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt;  protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt; <br>&gt;&gt;  protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;<br>&gt; Does this design entirely break with the relationship between<br>&gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt; collection (unless we add `until` to the language and then allow<br>&gt; `for..in..until` to work with infinite collections)?<br></p><p>All of these points are up for discussion.  John McCall pointed out to<br>me that an index-based for..in would make it possible to implement<br></p><p>  for inout x in y { mutate(&amp;x) }<br></p><p>&gt; Would we still retain `IndexingIterator`even if we break the<br>&gt; relationship in the protocol requirements?<br></p><p>Yes: it should be possible to implement Collection algorithms in terms<br>of Iterator algorithms, and IndexingIterator provides the means.  That<br>said, I think the makeIterator requirement does little harm, especially<br>when it can be defaulted for Collections.<br></p><p>&gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt; add them back eventually)?  This seems like a use case worth<br>&gt; supporting in some way.<br></p><p>Yes.  If you can create an Iterator from a Collection, and you can zip<br>Iterators, you can do this.<br></p><p>&gt; One subtle change I think this implies is that things like<br>&gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt; complexity, deferring the O(N) complexity to the first call to `next`.<br></p><p>I don&#39;t believe that&#39;s a difference, though I could be wrong.<br></p><p>&gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt; The complexity of a complete iteration doesn’t change and probably<br>&gt; isn’t a big deal, but it’s worth noting.<br></p><p>Filtered collection views always require a bit of hand-waving around<br>performance guarantees; I don&#39;t think that changes.<br></p><p>&gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt; how it would be impacted.  With iterators it looks like this:<br>&gt;<br>&gt; guard let element = base.next()<br>&gt;   else { return nil }<br>&gt;<br>&gt; With collections and indices it would look something like this:<br>&gt;<br>&gt; base.formIndex(after: &amp;index)<br>&gt; guard index != baseEndIndex<br>&gt;    else { return endIndex }<br>&gt;<br>&gt; let element = base[index]<br>&gt;<br>&gt; That’s not too bad but it is more verbose.  <br></p><p>Sequence today is a single-pass thing.  If you are wrapping Sequence<br>today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>to deal with indices.<br></p><p>&gt; If we’re going to push people towards collections and indices we<br>&gt; should try to make common patterns like “update the iteration state<br>&gt; and return the next element if there is one&quot; simpler.  <br></p><p>That&#39;s IndexingIterator.<br></p><p>&gt; This could be accomplished with an extension method along these lines:<br>&gt;<br>&gt; guard let element = base.formIndex(after: &amp;index,<br>&gt; .returningOptionalElement)<br>&gt;     else { return endIndex }<br>&gt;<br>&gt; With an implementation something like:<br>&gt;<br>&gt; enum FormIndexResult {<br>&gt;     .returningOptionalElement<br>&gt; }<br>&gt; extension Collection {<br>&gt;     func formIndex(after i: inout Self.Index, _ result:<br>&gt; FormIndexResult) -&gt; Self.Element?<br>&gt; }<br>&gt;<br>&gt; This would provide similar functionality to `IndexingIterator` without<br>&gt; coupling the storage of `elements` and `position` (which is important<br>&gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt; its indices independently).<br></p><p>I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>you have in mind?<br></p><p>&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;   sequence, slice the sequence, find again, etc.<br>&gt;&gt; <br>&gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt; <br>&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;<br>&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;    complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;    different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;    can&#39;t index one of those safely without actually counting the<br>&gt;&gt;    length,<br>&gt;&gt;    and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;<br>&gt; It’s also worth nothing that we can use `Optional` with `nil` as the<br>&gt; `endIndex` sentinel if necessary.<br></p><p>True, that&#39;s a useful technique when there&#39;s no underlying storage in<br>the collection (e.g. a fibonacci sequence)<br></p><p>&gt;&gt; <br>&gt;&gt; ## Single Pass Iteration<br>&gt;&gt; <br>&gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt; problematic, because it means either:<br>&gt;&gt; <br>&gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt;   nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt; <br>&gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”)<br>&gt;&gt;   multipass sequences. IMO that would be totally unacceptable.<br>&gt;&gt; <br>&gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt; Sequence altogether, and the protocol for single-pass iteration<br>&gt;&gt; becomes Iterator.<br>&gt;<br>&gt; Makes sense to me.<br>&gt;<br>&gt;&gt; <br>&gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt; <br>&gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please<br>&gt;&gt; not argue over the definition of copy for classes; this is the one<br>&gt;&gt; built into the lowest level of the language—I refer to the other one,<br>&gt;&gt; that requires allocation, as “clone”).<br>&gt;&gt; <br>&gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt; sequences with “move-only” value types, which cannot be copied. You<br>&gt;&gt; can find move-only types in languages like Rust and C++, but they are<br>&gt;&gt; not supported by Swift today.  So it seems reasonable that all<br>&gt;&gt; Iterators in Swift today should be modeled as classes.<br>&gt;<br>&gt; I think this makes a lot of sense in the model you are proposing.  All<br>&gt; multipass structures are collections.  Any sequence that can only<br>&gt; support a single pass is modeled as an iterator which inherently has<br>&gt; identity.  Making this distinction strong will prevent any confusion.<br>&gt;<br>&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes,<br>&gt;&gt; though, means that mutating methods on a class constrained protocol<br>&gt;&gt; can&#39;t be labeled as such.  So consuming operations on a<br>&gt;&gt; class-constrained Iterator protocol would not be labeled as mutating.<br>&gt;&gt; <br>&gt;&gt; The standard library team is currently trying to evaluate the<br>&gt;&gt; tradeoffs in this area.  One possibility under consideration is<br>&gt;&gt; simply dropping support for single-pass sequences until Swift can<br>&gt;&gt; support move-only value types and/or gets a mutation model for class<br>&gt;&gt; instances.  It would be very interesting to know about any real-world<br>&gt;&gt; models of single-pass sequences that people are using in Swift, since<br>&gt;&gt; we don&#39;t supply any in the standard library.<br>&gt;<br>&gt; I’m happy to see you mention a mutation model for class instances!  (I<br>&gt; don’t mean to sidetrack the discussion, but would love to see that<br>&gt; someday)<br>&gt;<br>&gt; I don’t have any objection to dropping support for single-pass<br>&gt; sequences temporarily.  It’s possible that I would feel differently if<br>&gt; I was making use of them in my own code but I’m not.<br></p><p>On second thought, I believe it is important to have a way to support<br>existing “partially formed” multipass sequences that don&#39;t expose<br>copying or equality for their iteration states.  Iterator is the right<br>way to do that.  So I think we need to keep Iterator around.<br></p><p>&gt; In the meantime, people would be able to implement their own protocol<br>&gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt; the standard library algorithms.  I’m not sure how many people this<br>&gt; would impact or how big the impact would be for them.  We have seen a<br>&gt; couple of examples in this discussion, but probably not enough to<br>&gt; asses the overall impact.<br>&gt;<br>&gt; One thing you don’t mention here is a distinction between finite and<br>&gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt; finite / infinite distinction is as important here, but wanted to<br>&gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt; now we could defer that discussion until we’re ready to bring back<br>&gt; support for them.<br></p><p>There are a few possible answers I can think of:<br></p><p>1. Do the “obvious” thing and create a separate protocol for finite<br>   single-pass sequences<br></p><p>2. Decide that the combination of infinite and single-pass is rare<br>   enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>   ask people handling them to be careful and not, e.g., try to “count”<br>   them.<br></p><p>3. Decide that everything on a single-pass sequence is lazy. Since you<br>   can only take a single pass anyway, people won&#39;t observe their<br>   closures being called more often than necessary, which was the main<br>   motivator for making map, filter, et. al eager on collections without<br>   an explicit .lazy.<br></p><p>Implications of #3:<br></p><p>* Any “partially-formed” multipass sequences (modeling only Iterator)<br>  would be free to expose an accurate underestimatedCount, thereby<br>  optimizing the process of copying into an array. The lazy filter<br>  Iterator adaptor would have an underestimatedCount of 0.<br></p><p>* All algorithms that require multiple passes, such as sorted(), would<br>  be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>  other MutableCollection) and sort that in-place.  Of course,<br>  constructing an Array from an Iterator could still go on forever if<br>  the Iterator turned out to be infinite, which means, at some level #3<br>  is just a refinement of #2 that makes it less error-prone.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July  1, 2016 at 12:00:00pm</p></header><div class="content"><p>On Fri, Jul 1, 2016 at 11:51 AM, Dave Abrahams via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;<br>&gt; &gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt; &gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt; &gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt; &gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt; &gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt; &gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt; &gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt; &gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt; &gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt; &gt;&gt;&gt;&gt;<br>&gt; &gt;&gt;&gt;&gt; -Matthew<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt; &gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt; &gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt; &gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt; &gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt; &gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt; &gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt; &gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt; &gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt; &gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt; &gt;&gt; sequences.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt; &gt;&gt; happen<br>&gt; &gt;<br>&gt; &gt; I definitely think it’s worth doing.<br>&gt;<br>&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt; *why* it&#39;s worth doing?<br>&gt;<br>&gt; &gt; I really appreciate the attention that the library team has given to<br>&gt; &gt; this.<br>&gt; &gt;<br>&gt; &gt;&gt; , the standard library team thinks the right design is roughly<br>&gt; &gt;&gt; this:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  /// A multipass sequence that may be infinite<br>&gt; &gt;&gt;  protocol Collection {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    // Only eager algorithms that can terminate available here<br>&gt; &gt;&gt;    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    // all lazy algorithms available here<br>&gt; &gt;&gt;    var lazy: ...<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    var startIndex: Index<br>&gt; &gt;&gt;    var endIndex: Index // possibly not reachable from startIndex<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    associatedtype SubSequence : Collection<br>&gt; &gt;&gt;    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt; &gt;&gt;  }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  protocol FiniteCollection : Collection {<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;    // All eager algorithms available here<br>&gt; &gt;&gt;    func map(...) -&gt;<br>&gt; &gt;&gt;    var count: ...<br>&gt; &gt;&gt;  }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  protocol BidirectionalCollection : Collection { ... }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;  protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt; &gt;<br>&gt; &gt; Does this design entirely break with the relationship between<br>&gt; &gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt; &gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt; &gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt; &gt; collection (unless we add `until` to the language and then allow<br>&gt; &gt; `for..in..until` to work with infinite collections)?<br>&gt;<br>&gt; All of these points are up for discussion.  John McCall pointed out to<br>&gt; me that an index-based for..in would make it possible to implement<br>&gt;<br>&gt;   for inout x in y { mutate(&amp;x) }<br>&gt;<br>&gt; &gt; Would we still retain `IndexingIterator`even if we break the<br>&gt; &gt; relationship in the protocol requirements?<br>&gt;<br>&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt; when it can be defaulted for Collections.<br>&gt;<br>&gt; &gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt; &gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt; &gt; add them back eventually)?  This seems like a use case worth<br>&gt; &gt; supporting in some way.<br>&gt;<br>&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt; Iterators, you can do this.<br>&gt;<br>&gt; &gt; One subtle change I think this implies is that things like<br>&gt; &gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt; &gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt;<br>&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br>&gt;<br>&gt; &gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt; &gt; The complexity of a complete iteration doesn’t change and probably<br>&gt; &gt; isn’t a big deal, but it’s worth noting.<br>&gt;<br>&gt; Filtered collection views always require a bit of hand-waving around<br>&gt; performance guarantees; I don&#39;t think that changes.<br>&gt;<br>&gt; &gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt; &gt; how it would be impacted.  With iterators it looks like this:<br>&gt; &gt;<br>&gt; &gt; guard let element = base.next()<br>&gt; &gt;   else { return nil }<br>&gt; &gt;<br>&gt; &gt; With collections and indices it would look something like this:<br>&gt; &gt;<br>&gt; &gt; base.formIndex(after: &amp;index)<br>&gt; &gt; guard index != baseEndIndex<br>&gt; &gt;    else { return endIndex }<br>&gt; &gt;<br>&gt; &gt; let element = base[index]<br>&gt; &gt;<br>&gt; &gt; That’s not too bad but it is more verbose.<br>&gt;<br>&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt; to deal with indices.<br>&gt;<br>&gt; &gt; If we’re going to push people towards collections and indices we<br>&gt; &gt; should try to make common patterns like “update the iteration state<br>&gt; &gt; and return the next element if there is one&quot; simpler.<br>&gt;<br>&gt; That&#39;s IndexingIterator.<br>&gt;<br>&gt; &gt; This could be accomplished with an extension method along these lines:<br>&gt; &gt;<br>&gt; &gt; guard let element = base.formIndex(after: &amp;index,<br>&gt; &gt; .returningOptionalElement)<br>&gt; &gt;     else { return endIndex }<br>&gt; &gt;<br>&gt; &gt; With an implementation something like:<br>&gt; &gt;<br>&gt; &gt; enum FormIndexResult {<br>&gt; &gt;     .returningOptionalElement<br>&gt; &gt; }<br>&gt; &gt; extension Collection {<br>&gt; &gt;     func formIndex(after i: inout Self.Index, _ result:<br>&gt; &gt; FormIndexResult) -&gt; Self.Element?<br>&gt; &gt; }<br>&gt; &gt;<br>&gt; &gt; This would provide similar functionality to `IndexingIterator` without<br>&gt; &gt; coupling the storage of `elements` and `position` (which is important<br>&gt; &gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt; &gt; its indices independently).<br>&gt;<br>&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt; you have in mind?<br>&gt;<br>&gt; &gt;&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt; &gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt; &gt;&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt; &gt;&gt;   sequence, slice the sequence, find again, etc.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt; &gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt; &gt;&gt;    complexity in typical usage.  A classic use case that argues for a<br>&gt; &gt;&gt;    different endIndex type is the null-terminated C string.  But you<br>&gt; &gt;&gt;    can&#39;t index one of those safely without actually counting the<br>&gt; &gt;&gt;    length,<br>&gt; &gt;&gt;    and once you&#39;ve done that you can make the endIndex an Int.<br>&gt; &gt;<br>&gt; &gt; It’s also worth nothing that we can use `Optional` with `nil` as the<br>&gt; &gt; `endIndex` sentinel if necessary.<br>&gt;<br>&gt; True, that&#39;s a useful technique when there&#39;s no underlying storage in<br>&gt; the collection (e.g. a fibonacci sequence)<br>&gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ## Single Pass Iteration<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt; &gt;&gt; problematic, because it means either:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt; &gt;&gt;   nonmutating even though it&#39;s a lie (status quo)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”)<br>&gt; &gt;&gt;   multipass sequences. IMO that would be totally unacceptable.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt; &gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt; &gt;&gt; Sequence altogether, and the protocol for single-pass iteration<br>&gt; &gt;&gt; becomes Iterator.<br>&gt; &gt;<br>&gt; &gt; Makes sense to me.<br>&gt; &gt;<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; ### Mutation and Reference Semantics<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please<br>&gt; &gt;&gt; not argue over the definition of copy for classes; this is the one<br>&gt; &gt;&gt; built into the lowest level of the language—I refer to the other one,<br>&gt; &gt;&gt; that requires allocation, as “clone”).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt; &gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt; &gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt; &gt;&gt; sequences with “move-only” value types, which cannot be copied. You<br>&gt; &gt;&gt; can find move-only types in languages like Rust and C++, but they are<br>&gt; &gt;&gt; not supported by Swift today.  So it seems reasonable that all<br>&gt; &gt;&gt; Iterators in Swift today should be modeled as classes.<br>&gt; &gt;<br>&gt; &gt; I think this makes a lot of sense in the model you are proposing.  All<br>&gt; &gt; multipass structures are collections.  Any sequence that can only<br>&gt; &gt; support a single pass is modeled as an iterator which inherently has<br>&gt; &gt; identity.  Making this distinction strong will prevent any confusion.<br>&gt; &gt;<br>&gt; &gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes,<br>&gt; &gt;&gt; though, means that mutating methods on a class constrained protocol<br>&gt; &gt;&gt; can&#39;t be labeled as such.  So consuming operations on a<br>&gt; &gt;&gt; class-constrained Iterator protocol would not be labeled as mutating.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The standard library team is currently trying to evaluate the<br>&gt; &gt;&gt; tradeoffs in this area.  One possibility under consideration is<br>&gt; &gt;&gt; simply dropping support for single-pass sequences until Swift can<br>&gt; &gt;&gt; support move-only value types and/or gets a mutation model for class<br>&gt; &gt;&gt; instances.  It would be very interesting to know about any real-world<br>&gt; &gt;&gt; models of single-pass sequences that people are using in Swift, since<br>&gt; &gt;&gt; we don&#39;t supply any in the standard library.<br>&gt; &gt;<br>&gt; &gt; I’m happy to see you mention a mutation model for class instances!  (I<br>&gt; &gt; don’t mean to sidetrack the discussion, but would love to see that<br>&gt; &gt; someday)<br>&gt; &gt;<br>&gt; &gt; I don’t have any objection to dropping support for single-pass<br>&gt; &gt; sequences temporarily.  It’s possible that I would feel differently if<br>&gt; &gt; I was making use of them in my own code but I’m not.<br>&gt;<br>&gt; On second thought, I believe it is important to have a way to support<br>&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt; copying or equality for their iteration states.  Iterator is the right<br>&gt; way to do that.  So I think we need to keep Iterator around.<br>&gt;<br>&gt; &gt; In the meantime, people would be able to implement their own protocol<br>&gt; &gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt; &gt; the standard library algorithms.  I’m not sure how many people this<br>&gt; &gt; would impact or how big the impact would be for them.  We have seen a<br>&gt; &gt; couple of examples in this discussion, but probably not enough to<br>&gt; &gt; asses the overall impact.<br>&gt; &gt;<br>&gt; &gt; One thing you don’t mention here is a distinction between finite and<br>&gt; &gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt; &gt; finite / infinite distinction is as important here, but wanted to<br>&gt; &gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt; &gt; now we could defer that discussion until we’re ready to bring back<br>&gt; &gt; support for them.<br>&gt;<br>&gt; There are a few possible answers I can think of:<br>&gt;<br>&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;    single-pass sequences<br>&gt;<br>&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;    enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;    ask people handling them to be careful and not, e.g., try to “count”<br>&gt;    them.<br>&gt;<br></p><p>Not really feeling sufficiently in my element (excuse the pun) to comment<br>on most of this discussion, but here I thought I&#39;d chime in. What&#39;s<br>interesting about your two examples (/dev/urandom, temperature sensor) is<br>that, though single-pass, they should be insensitive to destructive<br>consumption, no? By which I mean, if some function returns 5 elements from<br>the &quot;sequence&quot;, in both scenarios it would be undetectable whether it<br>consumes 5, 10 or 15 elements in the process, IIUC. Are there other<br>examples of infinite, single-pass sequences where destructive consumption<br>would make a difference?<br></p><p><br>&gt;<br>&gt; 3. Decide that everything on a single-pass sequence is lazy. Since you<br>&gt;    can only take a single pass anyway, people won&#39;t observe their<br>&gt;    closures being called more often than necessary, which was the main<br>&gt;    motivator for making map, filter, et. al eager on collections without<br>&gt;    an explicit .lazy.<br>&gt;<br>&gt; Implications of #3:<br>&gt;<br>&gt; * Any “partially-formed” multipass sequences (modeling only Iterator)<br>&gt;   would be free to expose an accurate underestimatedCount, thereby<br>&gt;   optimizing the process of copying into an array. The lazy filter<br>&gt;   Iterator adaptor would have an underestimatedCount of 0.<br>&gt;<br>&gt; * All algorithms that require multiple passes, such as sorted(), would<br>&gt;   be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>&gt;   other MutableCollection) and sort that in-place.  Of course,<br>&gt;   constructing an Array from an Iterator could still go on forever if<br>&gt;   the Iterator turned out to be infinite, which means, at some level #3<br>&gt;   is just a refinement of #2 that makes it less error-prone.<br>&gt;<br>&gt; --<br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/8ace6b4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 01:00:00pm</p></header><div class="content"><p>on Fri Jul 01 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 1, 2016 at 11:51 AM, Dave Abrahams via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; &gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt; &gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt; &gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt; &gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt; &gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt; &gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt; &gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt; &gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt; &gt;&gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt; &gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt; &gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt; &gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt; &gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt; &gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt; &gt;&gt;&gt;<br>&gt;&gt; &gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt; &gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt; &gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt; &gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt; &gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt; &gt;&gt; sequences.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt; &gt;&gt; happen<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I definitely think it’s worth doing.<br>&gt;&gt;<br>&gt;&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt;&gt; *why* it&#39;s worth doing?<br>&gt;&gt;<br>&gt;&gt; &gt; I really appreciate the attention that the library team has given to<br>&gt;&gt; &gt; this.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt; &gt;&gt; this:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;  /// A multipass sequence that may be infinite<br>&gt;&gt; &gt;&gt;  protocol Collection {<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    // Only eager algorithms that can terminate available here<br>&gt;&gt; &gt;&gt;    func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    // all lazy algorithms available here<br>&gt;&gt; &gt;&gt;    var lazy: ...<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    var startIndex: Index<br>&gt;&gt; &gt;&gt;    var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    associatedtype SubSequence : Collection<br>&gt;&gt; &gt;&gt;    // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt; &gt;&gt;  }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;  protocol FiniteCollection : Collection {<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;    // All eager algorithms available here<br>&gt;&gt; &gt;&gt;    func map(...) -&gt;<br>&gt;&gt; &gt;&gt;    var count: ...<br>&gt;&gt; &gt;&gt;  }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;  protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt;  protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Does this design entirely break with the relationship between<br>&gt;&gt; &gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt;&gt; &gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt;&gt; &gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt;&gt; &gt; collection (unless we add `until` to the language and then allow<br>&gt;&gt; &gt; `for..in..until` to work with infinite collections)?<br>&gt;&gt;<br>&gt;&gt; All of these points are up for discussion.  John McCall pointed out to<br>&gt;&gt; me that an index-based for..in would make it possible to implement<br>&gt;&gt;<br>&gt;&gt;   for inout x in y { mutate(&amp;x) }<br>&gt;&gt;<br>&gt;&gt; &gt; Would we still retain `IndexingIterator`even if we break the<br>&gt;&gt; &gt; relationship in the protocol requirements?<br>&gt;&gt;<br>&gt;&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt;&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt;&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt;&gt; when it can be defaulted for Collections.<br>&gt;&gt;<br>&gt;&gt; &gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt;&gt; &gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt;&gt; &gt; add them back eventually)?  This seems like a use case worth<br>&gt;&gt; &gt; supporting in some way.<br>&gt;&gt;<br>&gt;&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt;&gt; Iterators, you can do this.<br>&gt;&gt;<br>&gt;&gt; &gt; One subtle change I think this implies is that things like<br>&gt;&gt; &gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt;&gt; &gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt;&gt;<br>&gt;&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br>&gt;&gt;<br>&gt;&gt; &gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt;&gt; &gt; The complexity of a complete iteration doesn’t change and probably<br>&gt;&gt; &gt; isn’t a big deal, but it’s worth noting.<br>&gt;&gt;<br>&gt;&gt; Filtered collection views always require a bit of hand-waving around<br>&gt;&gt; performance guarantees; I don&#39;t think that changes.<br>&gt;&gt;<br>&gt;&gt; &gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt;&gt; &gt; how it would be impacted.  With iterators it looks like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; guard let element = base.next()<br>&gt;&gt; &gt;   else { return nil }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; With collections and indices it would look something like this:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; base.formIndex(after: &amp;index)<br>&gt;&gt; &gt; guard index != baseEndIndex<br>&gt;&gt; &gt;    else { return endIndex }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; let element = base[index]<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That’s not too bad but it is more verbose.<br>&gt;&gt;<br>&gt;&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt;&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt;&gt; to deal with indices.<br>&gt;&gt;<br>&gt;&gt; &gt; If we’re going to push people towards collections and indices we<br>&gt;&gt; &gt; should try to make common patterns like “update the iteration state<br>&gt;&gt; &gt; and return the next element if there is one&quot; simpler.<br>&gt;&gt;<br>&gt;&gt; That&#39;s IndexingIterator.<br>&gt;&gt;<br>&gt;&gt; &gt; This could be accomplished with an extension method along these lines:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; guard let element = base.formIndex(after: &amp;index,<br>&gt;&gt; &gt; .returningOptionalElement)<br>&gt;&gt; &gt;     else { return endIndex }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; With an implementation something like:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; enum FormIndexResult {<br>&gt;&gt; &gt;     .returningOptionalElement<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt; extension Collection {<br>&gt;&gt; &gt;     func formIndex(after i: inout Self.Index, _ result:<br>&gt;&gt; &gt; FormIndexResult) -&gt; Self.Element?<br>&gt;&gt; &gt; }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This would provide similar functionality to `IndexingIterator` without<br>&gt;&gt; &gt; coupling the storage of `elements` and `position` (which is important<br>&gt;&gt; &gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt;&gt; &gt; its indices independently).<br>&gt;&gt;<br>&gt;&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt;&gt; you have in mind?<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; Q: Why should there be indices on an infinite multipass sequence?<br>&gt;&gt; &gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt; &gt;&gt;   sequence is finite or not.  Find the index of a value in the<br>&gt;&gt; &gt;&gt;   sequence, slice the sequence, find again, etc.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt; &gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt; &gt;&gt;    complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt; &gt;&gt;    different endIndex type is the null-terminated C string.  But you<br>&gt;&gt; &gt;&gt;    can&#39;t index one of those safely without actually counting the<br>&gt;&gt; &gt;&gt;    length,<br>&gt;&gt; &gt;&gt;    and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It’s also worth nothing that we can use `Optional` with `nil` as the<br>&gt;&gt; &gt; `endIndex` sentinel if necessary.<br>&gt;&gt;<br>&gt;&gt; True, that&#39;s a useful technique when there&#39;s no underlying storage in<br>&gt;&gt; the collection (e.g. a fibonacci sequence)<br>&gt;&gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ## Single Pass Iteration<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt; &gt;&gt; problematic, because it means either:<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt; &gt;&gt;   nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”)<br>&gt;&gt; &gt;&gt;   multipass sequences. IMO that would be totally unacceptable.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt; &gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt; &gt;&gt; Sequence altogether, and the protocol for single-pass iteration<br>&gt;&gt; &gt;&gt; becomes Iterator.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Makes sense to me.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please<br>&gt;&gt; &gt;&gt; not argue over the definition of copy for classes; this is the one<br>&gt;&gt; &gt;&gt; built into the lowest level of the language—I refer to the other one,<br>&gt;&gt; &gt;&gt; that requires allocation, as “clone”).<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt; &gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt; &gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt; &gt;&gt; sequences with “move-only” value types, which cannot be copied. You<br>&gt;&gt; &gt;&gt; can find move-only types in languages like Rust and C++, but they are<br>&gt;&gt; &gt;&gt; not supported by Swift today.  So it seems reasonable that all<br>&gt;&gt; &gt;&gt; Iterators in Swift today should be modeled as classes.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I think this makes a lot of sense in the model you are proposing.  All<br>&gt;&gt; &gt; multipass structures are collections.  Any sequence that can only<br>&gt;&gt; &gt; support a single pass is modeled as an iterator which inherently has<br>&gt;&gt; &gt; identity.  Making this distinction strong will prevent any confusion.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes,<br>&gt;&gt; &gt;&gt; though, means that mutating methods on a class constrained protocol<br>&gt;&gt; &gt;&gt; can&#39;t be labeled as such.  So consuming operations on a<br>&gt;&gt; &gt;&gt; class-constrained Iterator protocol would not be labeled as mutating.<br>&gt;&gt; &gt;&gt;<br>&gt;&gt; &gt;&gt; The standard library team is currently trying to evaluate the<br>&gt;&gt; &gt;&gt; tradeoffs in this area.  One possibility under consideration is<br>&gt;&gt; &gt;&gt; simply dropping support for single-pass sequences until Swift can<br>&gt;&gt; &gt;&gt; support move-only value types and/or gets a mutation model for class<br>&gt;&gt; &gt;&gt; instances.  It would be very interesting to know about any real-world<br>&gt;&gt; &gt;&gt; models of single-pass sequences that people are using in Swift, since<br>&gt;&gt; &gt;&gt; we don&#39;t supply any in the standard library.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I’m happy to see you mention a mutation model for class instances!  (I<br>&gt;&gt; &gt; don’t mean to sidetrack the discussion, but would love to see that<br>&gt;&gt; &gt; someday)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; I don’t have any objection to dropping support for single-pass<br>&gt;&gt; &gt; sequences temporarily.  It’s possible that I would feel differently if<br>&gt;&gt; &gt; I was making use of them in my own code but I’m not.<br>&gt;&gt;<br>&gt;&gt; On second thought, I believe it is important to have a way to support<br>&gt;&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt;&gt; copying or equality for their iteration states.  Iterator is the right<br>&gt;&gt; way to do that.  So I think we need to keep Iterator around.<br>&gt;&gt;<br>&gt;&gt; &gt; In the meantime, people would be able to implement their own protocol<br>&gt;&gt; &gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt;&gt; &gt; the standard library algorithms.  I’m not sure how many people this<br>&gt;&gt; &gt; would impact or how big the impact would be for them.  We have seen a<br>&gt;&gt; &gt; couple of examples in this discussion, but probably not enough to<br>&gt;&gt; &gt; asses the overall impact.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; One thing you don’t mention here is a distinction between finite and<br>&gt;&gt; &gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt;&gt; &gt; finite / infinite distinction is as important here, but wanted to<br>&gt;&gt; &gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt;&gt; &gt; now we could defer that discussion until we’re ready to bring back<br>&gt;&gt; &gt; support for them.<br>&gt;&gt;<br>&gt;&gt; There are a few possible answers I can think of:<br>&gt;&gt;<br>&gt;&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;&gt;    single-pass sequences<br>&gt;&gt;<br>&gt;&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;&gt;    enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;&gt;    ask people handling them to be careful and not, e.g., try to “count”<br>&gt;&gt;    them.<br>&gt;&gt;<br>&gt;<br>&gt; Not really feeling sufficiently in my element (excuse the pun) to comment<br>&gt; on most of this discussion, but here I thought I&#39;d chime in. What&#39;s<br>&gt; interesting about your two examples (/dev/urandom, temperature sensor) is<br>&gt; that, though single-pass, they should be insensitive to destructive<br>&gt; consumption, no? By which I mean, if some function returns 5 elements from<br>&gt; the &quot;sequence&quot;, in both scenarios it would be undetectable whether it<br>&gt; consumes 5, 10 or 15 elements in the process, IIUC. Are there other<br>&gt; examples of infinite, single-pass sequences where destructive consumption<br>&gt; would make a difference?<br></p><p>You can construct an example where it&#39;s detectable if you know enough<br>about the sequence.  For example, you could zip together elements from<br>0..&lt;∞ with /dev/urandom, and you would have a single-pass sequence where<br>the number of consumed elements was detectable.<br></p><p>I don&#39;t understand how the detectability of how many elements were<br>consumed is relevant to the design, though.<br>-- <br>Dave<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 11:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt; happen<br>&gt;&gt; <br>&gt;&gt; I definitely think it’s worth doing.  <br>&gt; <br>&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt; *why* it&#39;s worth doing?<br></p><p>I agree.  <br></p><p>The rationale has been discussed quite a bit already in this thread.  The current protocols do not provide the semantics many people are assuming in their code, leading to a lot of code that is incorrect despite the fact that it usually works in practice.  <br></p><p>This is especially frequent in the case of the finite assumption.  This assumption is so common it seems very wise to me to encode it as a semantic requirement in a protocol.<br></p><p>IMO these are problem worth addressing, especially now that we have a good handle on what a solution would look like.  <br></p><p>&gt; <br>&gt;&gt; I really appreciate the attention that the library team has given to<br>&gt;&gt; this.<br>&gt;&gt; <br>&gt;&gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt;&gt; this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; /// A multipass sequence that may be infinite<br>&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;   func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // all lazy algorithms available here<br>&gt;&gt;&gt;   var lazy: ...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   var startIndex: Index<br>&gt;&gt;&gt;   var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   associatedtype SubSequence : Collection<br>&gt;&gt;&gt;   // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol FiniteCollection : Collection {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   // All eager algorithms available here<br>&gt;&gt;&gt;   func map(...) -&gt;<br>&gt;&gt;&gt;   var count: ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;&gt; <br>&gt;&gt; Does this design entirely break with the relationship between<br>&gt;&gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt;&gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt;&gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt;&gt; collection (unless we add `until` to the language and then allow<br>&gt;&gt; `for..in..until` to work with infinite collections)?<br>&gt; <br>&gt; All of these points are up for discussion.  <br></p><p>Cool.  I think the collection for..in has some nice advantages, but since it sounds like we’ll probably keep Iterator around it might be best to take the approach of making them both work.<br></p><p>You already know that I would prefer to see the current for..in built on finite sequences and allow for..in..unitl to be used with infinite sequences if we add that in the future.  :)<br></p><p>&gt; John McCall pointed out to<br>&gt; me that an index-based for..in would make it possible to implement<br>&gt; <br>&gt;  for inout x in y { mutate(&amp;x) }<br></p><p>That would be very nice!<br></p><p>I think it might also increase performance.  I don’t know exactly how for..in is implemented today, but the implementation of IndexingIterator compares position to endIndex.  If for..in is also comparing checking the optional for nil that’s an extra comparison.  We shouldn&#39;t need to actually construct the optional in the first place using an index-based for..in.  Maybe optimizations like this already exist?  But even if they do, it seems like they wouldn’t be possible in some cases where the type of the sequence isn’t statically known.<br></p><p>&gt; <br>&gt;&gt; Would we still retain `IndexingIterator`even if we break the<br>&gt;&gt; relationship in the protocol requirements?<br>&gt; <br>&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt; when it can be defaulted for Collections.<br></p><p>I like this answer.<br></p><p>&gt; <br>&gt;&gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt;&gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt;&gt; add them back eventually)?  This seems like a use case worth<br>&gt;&gt; supporting in some way.<br>&gt; <br>&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt; Iterators, you can do this.<br></p><p>Yes, of course.  I’m glad we would keep this relationship in tact.<br></p><p>&gt; <br>&gt;&gt; One subtle change I think this implies is that things like<br>&gt;&gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt;&gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt; <br>&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br></p><p>You’re right, I was wrong.  `LazyFilterSequence` just constructs an iterator and returns it.  `LazyFilterCollection` has to loop until it finds the first item matching the predicate in its `startIndex` implementation.  The part I was missing is that `IndexingIterator` gets the `startIndex` in its initializer.<br></p><p>&gt; <br>&gt;&gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt;&gt; The complexity of a complete iteration doesn’t change and probably<br>&gt;&gt; isn’t a big deal, but it’s worth noting.<br>&gt; <br>&gt; Filtered collection views always require a bit of hand-waving around<br>&gt; performance guarantees; I don&#39;t think that changes.<br>&gt; <br>&gt;&gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt;&gt; how it would be impacted.  With iterators it looks like this:<br>&gt;&gt; <br>&gt;&gt; guard let element = base.next()<br>&gt;&gt;  else { return nil }<br>&gt;&gt; <br>&gt;&gt; With collections and indices it would look something like this:<br>&gt;&gt; <br>&gt;&gt; base.formIndex(after: &amp;index)<br>&gt;&gt; guard index != baseEndIndex<br>&gt;&gt;   else { return endIndex }<br>&gt;&gt; <br>&gt;&gt; let element = base[index]<br>&gt;&gt; <br>&gt;&gt; That’s not too bad but it is more verbose.  <br>&gt; <br>&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt; to deal with indices.<br>&gt; <br>&gt;&gt; If we’re going to push people towards collections and indices we<br>&gt;&gt; should try to make common patterns like “update the iteration state<br>&gt;&gt; and return the next element if there is one&quot; simpler.  <br>&gt; <br>&gt; That&#39;s IndexingIterator.<br></p><p>Cool, I wrote this thinking that was going away.<br></p><p>&gt; <br>&gt;&gt; This could be accomplished with an extension method along these lines:<br>&gt;&gt; <br>&gt;&gt; guard let element = base.formIndex(after: &amp;index,<br>&gt;&gt; .returningOptionalElement)<br>&gt;&gt;    else { return endIndex }<br>&gt;&gt; <br>&gt;&gt; With an implementation something like:<br>&gt;&gt; <br>&gt;&gt; enum FormIndexResult {<br>&gt;&gt;    .returningOptionalElement<br>&gt;&gt; }<br>&gt;&gt; extension Collection {<br>&gt;&gt;    func formIndex(after i: inout Self.Index, _ result:<br>&gt;&gt; FormIndexResult) -&gt; Self.Element?<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; This would provide similar functionality to `IndexingIterator` without<br>&gt;&gt; coupling the storage of `elements` and `position` (which is important<br>&gt;&gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt;&gt; its indices independently).<br>&gt; <br>&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt; you have in mind?<br></p><p>The idea was to provide functionality similar to `IndexingIterator` in the sense the following code would provide equivalent functionality to `iterator.next()` but expressed in terms of a collection and an index:<br></p><p>let optionalElement = myCollection.formIndex(after: &amp;myIndex, . returningOptionalElement)<br></p><p>vs<br></p><p>let optionalElement = myIterator.next()<br></p><p>The single case enum is just there to provide a label that differentiates the overload.<br></p><p>If we’re keeping IndexingIterator this probably isn’t necessary.  I still have a use case for it but it is rather obscure.  IndexingIterator probably covers the vast majority of use cases.<br></p><p>&gt; <br>&gt;&gt;&gt; Q: Why should there be indices on an infinite multipass sequence?  <br>&gt;&gt;&gt; A: Because the operations on indices apply equally well whether the<br>&gt;&gt;&gt;  sequence is finite or not.  Find the index of a value in the<br>&gt;&gt;&gt;  sequence, slice the sequence, find again, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why is there an endIndex on an infinite seque?<br>&gt;&gt;&gt; A: So you can write algorithms such as index(where:) once.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;&gt;   complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;&gt;   different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;&gt;   can&#39;t index one of those safely without actually counting the<br>&gt;&gt;&gt;   length,<br>&gt;&gt;&gt;   and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt; <br>&gt;&gt; It’s also worth nothing that we can use `Optional` with `nil` as the<br>&gt;&gt; `endIndex` sentinel if necessary.<br>&gt; <br>&gt; True, that&#39;s a useful technique when there&#39;s no underlying storage in<br>&gt; the collection (e.g. a fibonacci sequence)<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ## Single Pass Iteration<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The refinement relationship between Sequence and Collection is<br>&gt;&gt;&gt; problematic, because it means either:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; a) algorithms such as map on single-pass sequences claim to be<br>&gt;&gt;&gt;  nonmutating even though it&#39;s a lie (status quo)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; b) those algorithms can&#39;t be used on immutable (“let bound”)<br>&gt;&gt;&gt;  multipass sequences. IMO that would be totally unacceptable.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we drop the refinement, we can have a saner world.  We also don&#39;t<br>&gt;&gt;&gt; need to separate Sequence and Iterator anymore.  We can simply drop<br>&gt;&gt;&gt; Sequence altogether, and the protocol for single-pass iteration<br>&gt;&gt;&gt; becomes Iterator.<br>&gt;&gt; <br>&gt;&gt; Makes sense to me.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ### Mutation and Reference Semantics<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Everything in Swift is copiable via `let copy = thing` (let&#39;s please<br>&gt;&gt;&gt; not argue over the definition of copy for classes; this is the one<br>&gt;&gt;&gt; built into the lowest level of the language—I refer to the other one,<br>&gt;&gt;&gt; that requires allocation, as “clone”).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Anything you do with a sequence that&#39;s truly single-pass mutates the<br>&gt;&gt;&gt; sequence *and of its copies*.  Therefore, such a type *fundamentally*<br>&gt;&gt;&gt; has reference semantics. One day we may be able to model single-pass<br>&gt;&gt;&gt; sequences with “move-only” value types, which cannot be copied. You<br>&gt;&gt;&gt; can find move-only types in languages like Rust and C++, but they are<br>&gt;&gt;&gt; not supported by Swift today.  So it seems reasonable that all<br>&gt;&gt;&gt; Iterators in Swift today should be modeled as classes.<br>&gt;&gt; <br>&gt;&gt; I think this makes a lot of sense in the model you are proposing.  All<br>&gt;&gt; multipass structures are collections.  Any sequence that can only<br>&gt;&gt; support a single pass is modeled as an iterator which inherently has<br>&gt;&gt; identity.  Making this distinction strong will prevent any confusion.<br>&gt;&gt; <br>&gt;&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes,<br>&gt;&gt;&gt; though, means that mutating methods on a class constrained protocol<br>&gt;&gt;&gt; can&#39;t be labeled as such.  So consuming operations on a<br>&gt;&gt;&gt; class-constrained Iterator protocol would not be labeled as mutating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library team is currently trying to evaluate the<br>&gt;&gt;&gt; tradeoffs in this area.  One possibility under consideration is<br>&gt;&gt;&gt; simply dropping support for single-pass sequences until Swift can<br>&gt;&gt;&gt; support move-only value types and/or gets a mutation model for class<br>&gt;&gt;&gt; instances.  It would be very interesting to know about any real-world<br>&gt;&gt;&gt; models of single-pass sequences that people are using in Swift, since<br>&gt;&gt;&gt; we don&#39;t supply any in the standard library.<br>&gt;&gt; <br>&gt;&gt; I’m happy to see you mention a mutation model for class instances!  (I<br>&gt;&gt; don’t mean to sidetrack the discussion, but would love to see that<br>&gt;&gt; someday)<br>&gt;&gt; <br>&gt;&gt; I don’t have any objection to dropping support for single-pass<br>&gt;&gt; sequences temporarily.  It’s possible that I would feel differently if<br>&gt;&gt; I was making use of them in my own code but I’m not.<br>&gt; <br>&gt; On second thought, I believe it is important to have a way to support<br>&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt; copying or equality for their iteration states.  <br></p><p>Can you provide examples of these?  I’m having difficulty thinking of one.<br></p><p>&gt; Iterator is the right way to do that.  So I think we need to keep Iterator around.<br></p><p>I don’t have any objection to keeping it either. :)  Hopefully we’d still be able to improve the design in the future if / when new enabling language features come along.<br></p><p>&gt; <br>&gt;&gt; In the meantime, people would be able to implement their own protocol<br>&gt;&gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt;&gt; the standard library algorithms.  I’m not sure how many people this<br>&gt;&gt; would impact or how big the impact would be for them.  We have seen a<br>&gt;&gt; couple of examples in this discussion, but probably not enough to<br>&gt;&gt; asses the overall impact.<br>&gt;&gt; <br>&gt;&gt; One thing you don’t mention here is a distinction between finite and<br>&gt;&gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt;&gt; finite / infinite distinction is as important here, but wanted to<br>&gt;&gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt;&gt; now we could defer that discussion until we’re ready to bring back<br>&gt;&gt; support for them.<br>&gt; <br>&gt; There are a few possible answers I can think of:<br>&gt; <br>&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;   single-pass sequences<br>&gt; <br>&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;   enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;   ask people handling them to be careful and not, e.g., try to “count”<br>&gt;   them.<br>&gt; <br>&gt; 3. Decide that everything on a single-pass sequence is lazy. Since you<br>&gt;   can only take a single pass anyway, people won&#39;t observe their<br>&gt;   closures being called more often than necessary, which was the main<br>&gt;   motivator for making map, filter, et. al eager on collections without<br>&gt;   an explicit .lazy.<br>&gt; <br>&gt; Implications of #3:<br>&gt; <br>&gt; * Any “partially-formed” multipass sequences (modeling only Iterator)<br>&gt;  would be free to expose an accurate underestimatedCount, thereby<br>&gt;  optimizing the process of copying into an array. The lazy filter<br>&gt;  Iterator adaptor would have an underestimatedCount of 0.<br>&gt; <br>&gt; * All algorithms that require multiple passes, such as sorted(), would<br>&gt;  be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>&gt;  other MutableCollection) and sort that in-place.  Of course,<br>&gt;  constructing an Array from an Iterator could still go on forever if<br>&gt;  the Iterator turned out to be infinite, which means, at some level #3<br>&gt;  is just a refinement of #2 that makes it less error-prone.<br></p><p>Do you lean towards any of these?<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/d18da374/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 04:00:00pm</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 11:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt;&gt; happen<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I definitely think it’s worth doing.  <br>&gt;&gt; <br>&gt;&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt;&gt; *why* it&#39;s worth doing?<br>&gt;<br>&gt; I agree.  <br>&gt;<br>&gt; The rationale has been discussed quite a bit already in this thread.<br>&gt; The current protocols do not provide the semantics many people are<br>&gt; assuming in their code, leading to a lot of code that is incorrect<br>&gt; despite the fact that it usually works in practice.<br>&gt;<br>&gt; This is especially frequent in the case of the finite assumption.<br>&gt; This assumption is so common it seems very wise to me to encode it as<br>&gt; a semantic requirement in a protocol.<br>&gt;<br>&gt; IMO these are problem worth addressing, especially now that we have a<br>&gt; good handle on what a solution would look like.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; I really appreciate the attention that the library team has given to<br>&gt;&gt;&gt; this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;&gt;   func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // all lazy algorithms available here<br>&gt;&gt;&gt;&gt;   var lazy: ...<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   var startIndex: Index<br>&gt;&gt;&gt;&gt;   var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   associatedtype SubSequence : Collection<br>&gt;&gt;&gt;&gt;   // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol FiniteCollection : Collection {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   // All eager algorithms available here<br>&gt;&gt;&gt;&gt;   func map(...) -&gt;<br>&gt;&gt;&gt;&gt;   var count: ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Does this design entirely break with the relationship between<br>&gt;&gt;&gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt;&gt;&gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt;&gt;&gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt;&gt;&gt; collection (unless we add `until` to the language and then allow<br>&gt;&gt;&gt; `for..in..until` to work with infinite collections)?<br>&gt;&gt; <br>&gt;&gt; All of these points are up for discussion.  <br>&gt;<br>&gt; Cool.  I think the collection for..in has some nice advantages, but<br>&gt; since it sounds like we’ll probably keep Iterator around it might be<br>&gt; best to take the approach of making them both work.<br>&gt;<br>&gt; You already know that I would prefer to see the current for..in built<br>&gt; on finite sequences and allow for..in..unitl to be used with infinite<br>&gt; sequences if we add that in the future.  :)<br>&gt;<br>&gt;&gt; John McCall pointed out to<br>&gt;&gt; me that an index-based for..in would make it possible to implement<br>&gt;&gt; <br>&gt;&gt;  for inout x in y { mutate(&amp;x) }<br>&gt;<br>&gt; That would be very nice!<br>&gt;<br>&gt; I think it might also increase performance.  I don’t know exactly how<br>&gt; for..in is implemented today, but the implementation of<br>&gt; IndexingIterator compares position to endIndex.  If for..in is also<br>&gt; comparing checking the optional for nil that’s an extra comparison.<br>&gt; We shouldn&#39;t need to actually construct the optional in the first<br>&gt; place using an index-based for..in.  Maybe optimizations like this<br>&gt; already exist?  But even if they do, it seems like they wouldn’t be<br>&gt; possible in some cases where the type of the sequence isn’t statically<br>&gt; known.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Would we still retain `IndexingIterator`even if we break the<br>&gt;&gt;&gt; relationship in the protocol requirements?<br>&gt;&gt; <br>&gt;&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt;&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt;&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt;&gt; when it can be defaulted for Collections.<br>&gt;<br>&gt; I like this answer.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt;&gt;&gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt;&gt;&gt; add them back eventually)?  This seems like a use case worth<br>&gt;&gt;&gt; supporting in some way.<br>&gt;&gt; <br>&gt;&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt;&gt; Iterators, you can do this.<br>&gt;<br>&gt; Yes, of course.  I’m glad we would keep this relationship in tact.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; One subtle change I think this implies is that things like<br>&gt;&gt;&gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt;&gt;&gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt;&gt; <br>&gt;&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br>&gt;<br>&gt; You’re right, I was wrong.  `LazyFilterSequence` just constructs an<br>&gt; iterator and returns it.  `LazyFilterCollection` has to loop until it<br>&gt; finds the first item matching the predicate in its `startIndex`<br>&gt; implementation.  The part I was missing is that `IndexingIterator`<br>&gt; gets the `startIndex` in its initializer.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt;&gt;&gt; The complexity of a complete iteration doesn’t change and probably<br>&gt;&gt;&gt; isn’t a big deal, but it’s worth noting.<br>&gt;&gt; <br>&gt;&gt; Filtered collection views always require a bit of hand-waving around<br>&gt;&gt; performance guarantees; I don&#39;t think that changes.<br>&gt;&gt; <br>&gt;&gt;&gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt;&gt;&gt; how it would be impacted.  With iterators it looks like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let element = base.next()<br>&gt;&gt;&gt;  else { return nil }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With collections and indices it would look something like this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; base.formIndex(after: &amp;index)<br>&gt;&gt;&gt; guard index != baseEndIndex<br>&gt;&gt;&gt;   else { return endIndex }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let element = base[index]<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That’s not too bad but it is more verbose.  <br>&gt;&gt; <br>&gt;&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt;&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt;&gt; to deal with indices.<br>&gt;&gt; <br>&gt;&gt;&gt; If we’re going to push people towards collections and indices we<br>&gt;&gt;&gt; should try to make common patterns like “update the iteration state<br>&gt;&gt;&gt; and return the next element if there is one&quot; simpler.  <br>&gt;&gt; <br>&gt;&gt; That&#39;s IndexingIterator.<br>&gt;<br>&gt; Cool, I wrote this thinking that was going away.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; This could be accomplished with an extension method along these lines:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; guard let element = base.formIndex(after: &amp;index,<br>&gt;&gt;&gt; .returningOptionalElement)<br>&gt;&gt;&gt;    else { return endIndex }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With an implementation something like:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; enum FormIndexResult {<br>&gt;&gt;&gt;    .returningOptionalElement<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;    func formIndex(after i: inout Self.Index, _ result:<br>&gt;&gt;&gt; FormIndexResult) -&gt; Self.Element?<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would provide similar functionality to `IndexingIterator` without<br>&gt;&gt;&gt; coupling the storage of `elements` and `position` (which is important<br>&gt;&gt;&gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt;&gt;&gt; its indices independently).<br>&gt;&gt; <br>&gt;&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt;&gt; you have in mind?<br>&gt;<br>&gt; The idea was to provide functionality similar to `IndexingIterator` in<br>&gt; the sense the following code would provide equivalent functionality to<br>&gt; `iterator.next()` but expressed in terms of a collection and an index:<br>&gt;<br>&gt; let optionalElement = myCollection.formIndex(after: &amp;myIndex, . returningOptionalElement)<br>&gt;<br>&gt; vs<br>&gt;<br>&gt; let optionalElement = myIterator.next()<br>&gt;<br>&gt; The single case enum is just there to provide a label that<br>&gt; differentiates the overload.<br>&gt;<br>&gt; If we’re keeping IndexingIterator this probably isn’t necessary.  I<br>&gt; still have a use case for it but it is rather obscure.<br></p><p>I can imagine wanting a design like the above for cases where<br>implementing the endIndex requires adding an extra bit of state, e.g. in<br></p><p>  struct LazyPrefix&lt;Base: Collection&gt; : Collection {<br>    init(_ base: Base, where: (C.Element)-&gt;Bool)<br>    ...<br>  }<br></p><p>you don&#39;t want to traverse the base collection eagerly just to come up<br>with an endIndex, so you store an optional Base.Index in<br>LazyPrefix.Index, which is nil for the endIndex.  In these cases, index<br>comparison is less efficient than it might otherwise be.<br></p><p>But my answer for these cases is simple: simply use a specialized<br>Iterator that will be more efficient than IndexingIterator.  Is there a<br>reason that doesn&#39;t work for your case?<br></p><p>&gt;&gt; On second thought, I believe it is important to have a way to support<br>&gt;&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt;&gt; copying or equality for their iteration states.  <br>&gt;<br>&gt; Can you provide examples of these?  I’m having difficulty thinking of<br>&gt; one.<br></p><p>NSSet is an example.<br></p><p>&gt;&gt; Iterator is the right way to do that.  So I think we need to keep<br>&gt;&gt; Iterator around.<br>&gt;<br>&gt; I don’t have any objection to keeping it either. :) Hopefully we’d<br>&gt; still be able to improve the design in the future if / when new<br>&gt; enabling language features come along.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; In the meantime, people would be able to implement their own protocol<br>&gt;&gt;&gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt;&gt;&gt; the standard library algorithms.  I’m not sure how many people this<br>&gt;&gt;&gt; would impact or how big the impact would be for them.  We have seen a<br>&gt;&gt;&gt; couple of examples in this discussion, but probably not enough to<br>&gt;&gt;&gt; asses the overall impact.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One thing you don’t mention here is a distinction between finite and<br>&gt;&gt;&gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt;&gt;&gt; finite / infinite distinction is as important here, but wanted to<br>&gt;&gt;&gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt;&gt;&gt; now we could defer that discussion until we’re ready to bring back<br>&gt;&gt;&gt; support for them.<br>&gt;&gt; <br>&gt;&gt; There are a few possible answers I can think of:<br>&gt;&gt; <br>&gt;&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;&gt;   single-pass sequences<br>&gt;&gt; <br>&gt;&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;&gt;   enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;&gt;   ask people handling them to be careful and not, e.g., try to “count”<br>&gt;&gt;   them.<br>&gt;&gt; <br>&gt;&gt; 3. Decide that everything on a single-pass sequence is lazy. Since you<br>&gt;&gt;   can only take a single pass anyway, people won&#39;t observe their<br>&gt;&gt;   closures being called more often than necessary, which was the main<br>&gt;&gt;   motivator for making map, filter, et. al eager on collections without<br>&gt;&gt;   an explicit .lazy.<br>&gt;&gt; <br>&gt;&gt; Implications of #3:<br>&gt;&gt; <br>&gt;&gt; * Any “partially-formed” multipass sequences (modeling only Iterator)<br>&gt;&gt;  would be free to expose an accurate underestimatedCount, thereby<br>&gt;&gt;  optimizing the process of copying into an array. The lazy filter<br>&gt;&gt;  Iterator adaptor would have an underestimatedCount of 0.<br>&gt;&gt; <br>&gt;&gt; * All algorithms that require multiple passes, such as sorted(), would<br>&gt;&gt;  be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>&gt;&gt;  other MutableCollection) and sort that in-place.  Of course,<br>&gt;&gt;  constructing an Array from an Iterator could still go on forever if<br>&gt;&gt;  the Iterator turned out to be infinite, which means, at some level #3<br>&gt;&gt;  is just a refinement of #2 that makes it less error-prone.<br>&gt;<br>&gt; Do you lean towards any of these?<br></p><p>Yes, #3.  <br></p><p>We can always make the few operations that have to be eager—such as<br>Array construction from an Iterator—explicit with a label or something:<br></p><p>      Array(claimingFiniteness: someIterator)<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  1, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 6:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 11:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt; &lt;http://matthew-at-anandabits.com/ &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me &lt;http://swift-evolution-at-haravikk.me/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt;&gt;&gt; happen<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I definitely think it’s worth doing.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt;&gt;&gt; *why* it&#39;s worth doing?<br>&gt;&gt; <br>&gt;&gt; I agree.  <br>&gt;&gt; <br>&gt;&gt; The rationale has been discussed quite a bit already in this thread.<br>&gt;&gt; The current protocols do not provide the semantics many people are<br>&gt;&gt; assuming in their code, leading to a lot of code that is incorrect<br>&gt;&gt; despite the fact that it usually works in practice.<br>&gt;&gt; <br>&gt;&gt; This is especially frequent in the case of the finite assumption.<br>&gt;&gt; This assumption is so common it seems very wise to me to encode it as<br>&gt;&gt; a semantic requirement in a protocol.<br>&gt;&gt; <br>&gt;&gt; IMO these are problem worth addressing, especially now that we have a<br>&gt;&gt; good handle on what a solution would look like.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I really appreciate the attention that the library team has given to<br>&gt;&gt;&gt;&gt; this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;&gt;&gt;  func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  // all lazy algorithms available here<br>&gt;&gt;&gt;&gt;&gt;  var lazy: ...<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  var startIndex: Index<br>&gt;&gt;&gt;&gt;&gt;  var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  associatedtype SubSequence : Collection<br>&gt;&gt;&gt;&gt;&gt;  // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol FiniteCollection : Collection {<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  // All eager algorithms available here<br>&gt;&gt;&gt;&gt;&gt;  func map(...) -&gt;<br>&gt;&gt;&gt;&gt;&gt;  var count: ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Does this design entirely break with the relationship between<br>&gt;&gt;&gt;&gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt;&gt;&gt;&gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt;&gt;&gt;&gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt;&gt;&gt;&gt; collection (unless we add `until` to the language and then allow<br>&gt;&gt;&gt;&gt; `for..in..until` to work with infinite collections)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; All of these points are up for discussion.  <br>&gt;&gt; <br>&gt;&gt; Cool.  I think the collection for..in has some nice advantages, but<br>&gt;&gt; since it sounds like we’ll probably keep Iterator around it might be<br>&gt;&gt; best to take the approach of making them both work.<br>&gt;&gt; <br>&gt;&gt; You already know that I would prefer to see the current for..in built<br>&gt;&gt; on finite sequences and allow for..in..unitl to be used with infinite<br>&gt;&gt; sequences if we add that in the future.  :)<br>&gt;&gt; <br>&gt;&gt;&gt; John McCall pointed out to<br>&gt;&gt;&gt; me that an index-based for..in would make it possible to implement<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; for inout x in y { mutate(&amp;x) }<br>&gt;&gt; <br>&gt;&gt; That would be very nice!<br>&gt;&gt; <br>&gt;&gt; I think it might also increase performance.  I don’t know exactly how<br>&gt;&gt; for..in is implemented today, but the implementation of<br>&gt;&gt; IndexingIterator compares position to endIndex.  If for..in is also<br>&gt;&gt; comparing checking the optional for nil that’s an extra comparison.<br>&gt;&gt; We shouldn&#39;t need to actually construct the optional in the first<br>&gt;&gt; place using an index-based for..in.  Maybe optimizations like this<br>&gt;&gt; already exist?  But even if they do, it seems like they wouldn’t be<br>&gt;&gt; possible in some cases where the type of the sequence isn’t statically<br>&gt;&gt; known.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would we still retain `IndexingIterator`even if we break the<br>&gt;&gt;&gt;&gt; relationship in the protocol requirements?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt;&gt;&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt;&gt;&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt;&gt;&gt; when it can be defaulted for Collections.<br>&gt;&gt; <br>&gt;&gt; I like this answer.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt;&gt;&gt;&gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt;&gt;&gt;&gt; add them back eventually)?  This seems like a use case worth<br>&gt;&gt;&gt;&gt; supporting in some way.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt;&gt;&gt; Iterators, you can do this.<br>&gt;&gt; <br>&gt;&gt; Yes, of course.  I’m glad we would keep this relationship in tact.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One subtle change I think this implies is that things like<br>&gt;&gt;&gt;&gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt;&gt;&gt;&gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br>&gt;&gt; <br>&gt;&gt; You’re right, I was wrong.  `LazyFilterSequence` just constructs an<br>&gt;&gt; iterator and returns it.  `LazyFilterCollection` has to loop until it<br>&gt;&gt; finds the first item matching the predicate in its `startIndex`<br>&gt;&gt; implementation.  The part I was missing is that `IndexingIterator`<br>&gt;&gt; gets the `startIndex` in its initializer.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt;&gt;&gt;&gt; The complexity of a complete iteration doesn’t change and probably<br>&gt;&gt;&gt;&gt; isn’t a big deal, but it’s worth noting.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Filtered collection views always require a bit of hand-waving around<br>&gt;&gt;&gt; performance guarantees; I don&#39;t think that changes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt;&gt;&gt;&gt; how it would be impacted.  With iterators it looks like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let element = base.next()<br>&gt;&gt;&gt;&gt; else { return nil }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With collections and indices it would look something like this:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; base.formIndex(after: &amp;index)<br>&gt;&gt;&gt;&gt; guard index != baseEndIndex<br>&gt;&gt;&gt;&gt;  else { return endIndex }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let element = base[index]<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That’s not too bad but it is more verbose.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt;&gt;&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt;&gt;&gt; to deal with indices.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we’re going to push people towards collections and indices we<br>&gt;&gt;&gt;&gt; should try to make common patterns like “update the iteration state<br>&gt;&gt;&gt;&gt; and return the next element if there is one&quot; simpler.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s IndexingIterator.<br>&gt;&gt; <br>&gt;&gt; Cool, I wrote this thinking that was going away.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This could be accomplished with an extension method along these lines:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; guard let element = base.formIndex(after: &amp;index,<br>&gt;&gt;&gt;&gt; .returningOptionalElement)<br>&gt;&gt;&gt;&gt;   else { return endIndex }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With an implementation something like:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; enum FormIndexResult {<br>&gt;&gt;&gt;&gt;   .returningOptionalElement<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;&gt;   func formIndex(after i: inout Self.Index, _ result:<br>&gt;&gt;&gt;&gt; FormIndexResult) -&gt; Self.Element?<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would provide similar functionality to `IndexingIterator` without<br>&gt;&gt;&gt;&gt; coupling the storage of `elements` and `position` (which is important<br>&gt;&gt;&gt;&gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt;&gt;&gt;&gt; its indices independently).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt;&gt;&gt; you have in mind?<br>&gt;&gt; <br>&gt;&gt; The idea was to provide functionality similar to `IndexingIterator` in<br>&gt;&gt; the sense the following code would provide equivalent functionality to<br>&gt;&gt; `iterator.next()` but expressed in terms of a collection and an index:<br>&gt;&gt; <br>&gt;&gt; let optionalElement = myCollection.formIndex(after: &amp;myIndex, . returningOptionalElement)<br>&gt;&gt; <br>&gt;&gt; vs<br>&gt;&gt; <br>&gt;&gt; let optionalElement = myIterator.next()<br>&gt;&gt; <br>&gt;&gt; The single case enum is just there to provide a label that<br>&gt;&gt; differentiates the overload.<br>&gt;&gt; <br>&gt;&gt; If we’re keeping IndexingIterator this probably isn’t necessary.  I<br>&gt;&gt; still have a use case for it but it is rather obscure.<br>&gt; <br>&gt; I can imagine wanting a design like the above for cases where<br>&gt; implementing the endIndex requires adding an extra bit of state, e.g. in<br>&gt; <br>&gt;  struct LazyPrefix&lt;Base: Collection&gt; : Collection {<br>&gt;    init(_ base: Base, where: (C.Element)-&gt;Bool)<br>&gt;    ...<br>&gt;  }<br>&gt; <br>&gt; you don&#39;t want to traverse the base collection eagerly just to come up<br>&gt; with an endIndex, so you store an optional Base.Index in<br>&gt; LazyPrefix.Index, which is nil for the endIndex.  In these cases, index<br>&gt; comparison is less efficient than it might otherwise be.<br>&gt; <br>&gt; But my answer for these cases is simple: simply use a specialized<br>&gt; Iterator that will be more efficient than IndexingIterator.  Is there a<br>&gt; reason that doesn&#39;t work for your case?<br></p><p>I would index a custom iterator in my case, but I am talking about code that would live inside the implementation of `index(after:)` in the `Collection` conformance of a wrapper `Collection` that bears some resemblance to `LazyFlattenCollection`.  In this case you are receiving your `Index` which wraps `Base.Index`.<br></p><p>Like I said, this is a pretty obscure case and I would never suggest including it on the grounds of a use case that is only relevant to `index(after:)` implementations in wrapper collections. :)  I brought it because I thought you may have been suggesting a more drastic change that removed the collection iterators.<br></p><p>&gt; <br>&gt;&gt;&gt; On second thought, I believe it is important to have a way to support<br>&gt;&gt;&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt;&gt;&gt; copying or equality for their iteration states.  <br>&gt;&gt; <br>&gt;&gt; Can you provide examples of these?  I’m having difficulty thinking of<br>&gt;&gt; one.<br>&gt; <br>&gt; NSSet is an example.<br>&gt; <br>&gt;&gt;&gt; Iterator is the right way to do that.  So I think we need to keep<br>&gt;&gt;&gt; Iterator around.<br>&gt;&gt; <br>&gt;&gt; I don’t have any objection to keeping it either. :) Hopefully we’d<br>&gt;&gt; still be able to improve the design in the future if / when new<br>&gt;&gt; enabling language features come along.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the meantime, people would be able to implement their own protocol<br>&gt;&gt;&gt;&gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt;&gt;&gt;&gt; the standard library algorithms.  I’m not sure how many people this<br>&gt;&gt;&gt;&gt; would impact or how big the impact would be for them.  We have seen a<br>&gt;&gt;&gt;&gt; couple of examples in this discussion, but probably not enough to<br>&gt;&gt;&gt;&gt; asses the overall impact.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One thing you don’t mention here is a distinction between finite and<br>&gt;&gt;&gt;&gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt;&gt;&gt;&gt; finite / infinite distinction is as important here, but wanted to<br>&gt;&gt;&gt;&gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt;&gt;&gt;&gt; now we could defer that discussion until we’re ready to bring back<br>&gt;&gt;&gt;&gt; support for them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are a few possible answers I can think of:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;&gt;&gt;  single-pass sequences<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;&gt;&gt;  enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;&gt;&gt;  ask people handling them to be careful and not, e.g., try to “count”<br>&gt;&gt;&gt;  them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 3. Decide that everything on a single-pass sequence is lazy. Since you<br>&gt;&gt;&gt;  can only take a single pass anyway, people won&#39;t observe their<br>&gt;&gt;&gt;  closures being called more often than necessary, which was the main<br>&gt;&gt;&gt;  motivator for making map, filter, et. al eager on collections without<br>&gt;&gt;&gt;  an explicit .lazy.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Implications of #3:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Any “partially-formed” multipass sequences (modeling only Iterator)<br>&gt;&gt;&gt; would be free to expose an accurate underestimatedCount, thereby<br>&gt;&gt;&gt; optimizing the process of copying into an array. The lazy filter<br>&gt;&gt;&gt; Iterator adaptor would have an underestimatedCount of 0.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * All algorithms that require multiple passes, such as sorted(), would<br>&gt;&gt;&gt; be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>&gt;&gt;&gt; other MutableCollection) and sort that in-place.  Of course,<br>&gt;&gt;&gt; constructing an Array from an Iterator could still go on forever if<br>&gt;&gt;&gt; the Iterator turned out to be infinite, which means, at some level #3<br>&gt;&gt;&gt; is just a refinement of #2 that makes it less error-prone.<br>&gt;&gt; <br>&gt;&gt; Do you lean towards any of these?<br>&gt; <br>&gt; Yes, #3.  <br>&gt; <br>&gt; We can always make the few operations that have to be eager—such as<br>&gt; Array construction from an Iterator—explicit with a label or something:<br>&gt; <br>&gt;      Array(claimingFiniteness: someIterator)<br></p><p>This makes sense.  Finite single-pass iterators can always be added in the future if compelling use cases emerge. We’re not taking anything away.  <br></p><p>All of the code I have looked at that makes a finite assumption would be converted to require `Collection` in the new model.<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160701/bd75a5cd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  1, 2016 at 07:00:00pm</p></header><div class="content"><p>on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 6:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;<br>&gt;&gt;&gt;&gt; On Jul 1, 2016, at 11:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me &lt;http://swift-evolution-at-haravikk.me/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt;&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt;&gt;&gt;&gt; happen<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I definitely think it’s worth doing.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt;&gt;&gt;&gt; *why* it&#39;s worth doing?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The rationale has been discussed quite a bit already in this thread.<br>&gt;&gt;&gt; The current protocols do not provide the semantics many people are<br>&gt;&gt;&gt; assuming in their code, leading to a lot of code that is incorrect<br>&gt;&gt;&gt; despite the fact that it usually works in practice.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is especially frequent in the case of the finite assumption.<br>&gt;&gt;&gt; This assumption is so common it seems very wise to me to encode it as<br>&gt;&gt;&gt; a semantic requirement in a protocol.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO these are problem worth addressing, especially now that we have a<br>&gt;&gt;&gt; good handle on what a solution would look like.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I really appreciate the attention that the library team has given to<br>&gt;&gt;&gt;&gt;&gt; this.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt;&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;&gt;&gt;&gt;  func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // all lazy algorithms available here<br>&gt;&gt;&gt;&gt;&gt;&gt;  var lazy: ...<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  var startIndex: Index<br>&gt;&gt;&gt;&gt;&gt;&gt;  var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  associatedtype SubSequence : Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;  // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol FiniteCollection : Collection {<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  // All eager algorithms available here<br>&gt;&gt;&gt;&gt;&gt;&gt;  func map(...) -&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;  var count: ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Does this design entirely break with the relationship between<br>&gt;&gt;&gt;&gt;&gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt;&gt;&gt;&gt;&gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt;&gt;&gt;&gt;&gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt;&gt;&gt;&gt;&gt; collection (unless we add `until` to the language and then allow<br>&gt;&gt;&gt;&gt;&gt; `for..in..until` to work with infinite collections)?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; All of these points are up for discussion.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cool.  I think the collection for..in has some nice advantages, but<br>&gt;&gt;&gt; since it sounds like we’ll probably keep Iterator around it might be<br>&gt;&gt;&gt; best to take the approach of making them both work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You already know that I would prefer to see the current for..in built<br>&gt;&gt;&gt; on finite sequences and allow for..in..unitl to be used with infinite<br>&gt;&gt;&gt; sequences if we add that in the future.  :)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; John McCall pointed out to<br>&gt;&gt;&gt;&gt; me that an index-based for..in would make it possible to implement<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; for inout x in y { mutate(&amp;x) }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be very nice!<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think it might also increase performance.  I don’t know exactly how<br>&gt;&gt;&gt; for..in is implemented today, but the implementation of<br>&gt;&gt;&gt; IndexingIterator compares position to endIndex.  If for..in is also<br>&gt;&gt;&gt; comparing checking the optional for nil that’s an extra comparison.<br>&gt;&gt;&gt; We shouldn&#39;t need to actually construct the optional in the first<br>&gt;&gt;&gt; place using an index-based for..in.  Maybe optimizations like this<br>&gt;&gt;&gt; already exist?  But even if they do, it seems like they wouldn’t be<br>&gt;&gt;&gt; possible in some cases where the type of the sequence isn’t statically<br>&gt;&gt;&gt; known.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would we still retain `IndexingIterator`even if we break the<br>&gt;&gt;&gt;&gt;&gt; relationship in the protocol requirements?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt;&gt;&gt;&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt;&gt;&gt;&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt;&gt;&gt;&gt; when it can be defaulted for Collections.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I like this answer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt;&gt;&gt;&gt;&gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt;&gt;&gt;&gt;&gt; add them back eventually)?  This seems like a use case worth<br>&gt;&gt;&gt;&gt;&gt; supporting in some way.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt;&gt;&gt;&gt; Iterators, you can do this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, of course.  I’m glad we would keep this relationship in tact.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One subtle change I think this implies is that things like<br>&gt;&gt;&gt;&gt;&gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt;&gt;&gt;&gt;&gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You’re right, I was wrong.  `LazyFilterSequence` just constructs an<br>&gt;&gt;&gt; iterator and returns it.  `LazyFilterCollection` has to loop until it<br>&gt;&gt;&gt; finds the first item matching the predicate in its `startIndex`<br>&gt;&gt;&gt; implementation.  The part I was missing is that `IndexingIterator`<br>&gt;&gt;&gt; gets the `startIndex` in its initializer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt;&gt;&gt;&gt;&gt; The complexity of a complete iteration doesn’t change and probably<br>&gt;&gt;&gt;&gt;&gt; isn’t a big deal, but it’s worth noting.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Filtered collection views always require a bit of hand-waving around<br>&gt;&gt;&gt;&gt; performance guarantees; I don&#39;t think that changes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt;&gt;&gt;&gt;&gt; how it would be impacted.  With iterators it looks like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let element = base.next()<br>&gt;&gt;&gt;&gt;&gt; else { return nil }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With collections and indices it would look something like this:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; base.formIndex(after: &amp;index)<br>&gt;&gt;&gt;&gt;&gt; guard index != baseEndIndex<br>&gt;&gt;&gt;&gt;&gt;  else { return endIndex }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let element = base[index]<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That’s not too bad but it is more verbose.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt;&gt;&gt;&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt;&gt;&gt;&gt; to deal with indices.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If we’re going to push people towards collections and indices we<br>&gt;&gt;&gt;&gt;&gt; should try to make common patterns like “update the iteration state<br>&gt;&gt;&gt;&gt;&gt; and return the next element if there is one&quot; simpler.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That&#39;s IndexingIterator.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Cool, I wrote this thinking that was going away.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This could be accomplished with an extension method along these lines:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; guard let element = base.formIndex(after: &amp;index,<br>&gt;&gt;&gt;&gt;&gt; .returningOptionalElement)<br>&gt;&gt;&gt;&gt;&gt;   else { return endIndex }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With an implementation something like:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; enum FormIndexResult {<br>&gt;&gt;&gt;&gt;&gt;   .returningOptionalElement<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;&gt;&gt;   func formIndex(after i: inout Self.Index, _ result:<br>&gt;&gt;&gt;&gt;&gt; FormIndexResult) -&gt; Self.Element?<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would provide similar functionality to `IndexingIterator` without<br>&gt;&gt;&gt;&gt;&gt; coupling the storage of `elements` and `position` (which is important<br>&gt;&gt;&gt;&gt;&gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt;&gt;&gt;&gt;&gt; its indices independently).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt;&gt;&gt;&gt; you have in mind?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The idea was to provide functionality similar to `IndexingIterator` in<br>&gt;&gt;&gt; the sense the following code would provide equivalent functionality to<br>&gt;&gt;&gt; `iterator.next()` but expressed in terms of a collection and an index:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let optionalElement = myCollection.formIndex(after: &amp;myIndex, . returningOptionalElement)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; vs<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let optionalElement = myIterator.next()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The single case enum is just there to provide a label that<br>&gt;&gt;&gt; differentiates the overload.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we’re keeping IndexingIterator this probably isn’t necessary.  I<br>&gt;&gt;&gt; still have a use case for it but it is rather obscure.<br>&gt;&gt; <br>&gt;&gt; I can imagine wanting a design like the above for cases where<br>&gt;&gt; implementing the endIndex requires adding an extra bit of state, e.g. in<br>&gt;&gt; <br>&gt;&gt;  struct LazyPrefix&lt;Base: Collection&gt; : Collection {<br>&gt;&gt;    init(_ base: Base, where: (C.Element)-&gt;Bool)<br>&gt;&gt;    ...<br>&gt;&gt;  }<br>&gt;&gt; <br>&gt;&gt; you don&#39;t want to traverse the base collection eagerly just to come up<br>&gt;&gt; with an endIndex, so you store an optional Base.Index in<br>&gt;&gt; LazyPrefix.Index, which is nil for the endIndex.  In these cases, index<br>&gt;&gt; comparison is less efficient than it might otherwise be.<br>&gt;&gt; <br>&gt;&gt; But my answer for these cases is simple: simply use a specialized<br>&gt;&gt; Iterator that will be more efficient than IndexingIterator.  Is there a<br>&gt;&gt; reason that doesn&#39;t work for your case?<br>&gt;<br>&gt; I would index a custom iterator in my case,<br></p><p>I don&#39;t know what it means to index an iterator.<br></p><p>&gt; but I am talking about code that would live inside the implementation<br>&gt; of `index(after:)` in the `Collection` conformance of a wrapper<br>&gt; `Collection` that bears some resemblance to `LazyFlattenCollection`.<br>&gt; In this case you are receiving your `Index` which wraps `Base.Index`.<br></p><p>I don&#39;t understand, but maybe it doesn&#39;t matter.  FWIW, I&#39;m pretty<br>confident we could write a specialized Collection protocol that, given<br>some equatable State and a next() method, supplied all the basic<br>Collection requirements, for the cases where the Iterator is the most<br>efficient means of traversal, e.g.<br></p><p>      protocol IteratingCollection : Collection {<br>        associatedtype IterationState : Equatable<br>        func next(inout state: IterationState) -&gt; Element?<br>        func startState() -&gt; IterationState<br>      }<br></p><p>      extension IteratingCollection {<br>        // all the collection requirements implemented in terms<br>        // of startState() and next(...)<br>      }<br></p><p>&gt; Like I said, this is a pretty obscure case and I would never suggest<br>&gt; including it on the grounds of a use case that is only relevant to<br>&gt; `index(after:)` implementations in wrapper collections. :) I brought<br>&gt; it because I thought you may have been suggesting a more drastic<br>&gt; change that removed the collection iterators.<br></p><p>&gt;&gt; <br>&gt;&gt;&gt;&gt; On second thought, I believe it is important to have a way to support<br>&gt;&gt;&gt;&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt;&gt;&gt;&gt; copying or equality for their iteration states.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you provide examples of these?  I’m having difficulty thinking of<br>&gt;&gt;&gt; one.<br>&gt;&gt; <br>&gt;&gt; NSSet is an example.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Iterator is the right way to do that.  So I think we need to keep<br>&gt;&gt;&gt;&gt; Iterator around.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I don’t have any objection to keeping it either. :) Hopefully we’d<br>&gt;&gt;&gt; still be able to improve the design in the future if / when new<br>&gt;&gt;&gt; enabling language features come along.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the meantime, people would be able to implement their own protocol<br>&gt;&gt;&gt;&gt;&gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt;&gt;&gt;&gt;&gt; the standard library algorithms.  I’m not sure how many people this<br>&gt;&gt;&gt;&gt;&gt; would impact or how big the impact would be for them.  We have seen a<br>&gt;&gt;&gt;&gt;&gt; couple of examples in this discussion, but probably not enough to<br>&gt;&gt;&gt;&gt;&gt; asses the overall impact.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; One thing you don’t mention here is a distinction between finite and<br>&gt;&gt;&gt;&gt;&gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt;&gt;&gt;&gt;&gt; finite / infinite distinction is as important here, but wanted to<br>&gt;&gt;&gt;&gt;&gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt;&gt;&gt;&gt;&gt; now we could defer that discussion until we’re ready to bring back<br>&gt;&gt;&gt;&gt;&gt; support for them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are a few possible answers I can think of:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;&gt;&gt;&gt;  single-pass sequences<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;&gt;&gt;&gt;  enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;&gt;&gt;&gt;  ask people handling them to be careful and not, e.g., try to “count”<br>&gt;&gt;&gt;&gt;  them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 3. Decide that everything on a single-pass sequence is lazy. Since you<br>&gt;&gt;&gt;&gt;  can only take a single pass anyway, people won&#39;t observe their<br>&gt;&gt;&gt;&gt;  closures being called more often than necessary, which was the main<br>&gt;&gt;&gt;&gt;  motivator for making map, filter, et. al eager on collections without<br>&gt;&gt;&gt;&gt;  an explicit .lazy.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Implications of #3:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Any “partially-formed” multipass sequences (modeling only Iterator)<br>&gt;&gt;&gt;&gt; would be free to expose an accurate underestimatedCount, thereby<br>&gt;&gt;&gt;&gt; optimizing the process of copying into an array. The lazy filter<br>&gt;&gt;&gt;&gt; Iterator adaptor would have an underestimatedCount of 0.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * All algorithms that require multiple passes, such as sorted(), would<br>&gt;&gt;&gt;&gt; be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>&gt;&gt;&gt;&gt; other MutableCollection) and sort that in-place.  Of course,<br>&gt;&gt;&gt;&gt; constructing an Array from an Iterator could still go on forever if<br>&gt;&gt;&gt;&gt; the Iterator turned out to be infinite, which means, at some level #3<br>&gt;&gt;&gt;&gt; is just a refinement of #2 that makes it less error-prone.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you lean towards any of these?<br>&gt;&gt; <br>&gt;&gt; Yes, #3.  <br>&gt;&gt; <br>&gt;&gt; We can always make the few operations that have to be eager—such as<br>&gt;&gt; Array construction from an Iterator—explicit with a label or something:<br>&gt;&gt; <br>&gt;&gt;      Array(claimingFiniteness: someIterator)<br>&gt;<br>&gt; This makes sense.  Finite single-pass iterators can always be added in<br>&gt; the future if compelling use cases emerge. We’re not taking anything<br>&gt; away.<br>&gt;<br>&gt; All of the code I have looked at that makes a finite assumption would<br>&gt; be converted to require `Collection` in the new model.<br></p><p>I think you mean FiniteCollection, yes?<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  2, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 1, 2016, at 9:55 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 6:32 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com &lt;http://matthew-at-anandabits.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jul 1, 2016, at 11:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Fri Jul 01 2016, Matthew Johnson &lt;matthew-AT-anandabits.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/<br>&gt;&gt;&gt;&gt;&gt; &lt;http://matthew-at-anandabits.com/&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; on Wed Jun 29 2016, Haravikk &lt;swift-evolution-AT-haravikk.me &lt;http://swift-evolution-at-haravikk.me/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 29 Jun 2016, at 00:10, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift is a language that embraces value semantics.  Many common<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; iterators *can* be implemented with value semantics.  Just because we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t implement *all* iterators with value semantics doesn’t mean we<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; should require them to have reference semantics.  It just means you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; can’t *assume* value semantics when working with iterators in generic<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; code unless / until we have a way to specify a value semantics<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; constraint.  That’s not necessarily a bad thing especially when it<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; leaves the door open to interesting future possibilities.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Matthew<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m kind of undecided about this personally. I think one of the<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; problems with Swift is that the only indication that you have a<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; reference type is that you can declare it as a constant, yet still<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; call mutating methods upon it, this isn&#39;t a very positive way of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; identifying it however. This may be more of a GUI/IDE issue though, in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; that something being a class isn&#39;t always that obvious at a glance.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wonder, could we somehow force iterators stored in variables to be<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; passed via inout? This would make it pretty clear that you&#39;re using<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; the same iterator and not a copy in all cases, encouraging you to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; obtain another if you really do need to perform multiple passes.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m going to push single-pass iteration on the stack briefly and talk<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; about the topic that&#39;s been under discussion here: infinite multipass<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; sequences.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; ## Fitting “Infinite Multipass” Into the Model<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; It remains to be decided whether it&#39;s worth doing, but if it&#39;s to<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; happen<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I definitely think it’s worth doing.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Opinions are nice, but rationales are better.  How will we understand<br>&gt;&gt;&gt;&gt;&gt; *why* it&#39;s worth doing?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I agree.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The rationale has been discussed quite a bit already in this thread.<br>&gt;&gt;&gt;&gt; The current protocols do not provide the semantics many people are<br>&gt;&gt;&gt;&gt; assuming in their code, leading to a lot of code that is incorrect<br>&gt;&gt;&gt;&gt; despite the fact that it usually works in practice.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is especially frequent in the case of the finite assumption.<br>&gt;&gt;&gt;&gt; This assumption is so common it seems very wise to me to encode it as<br>&gt;&gt;&gt;&gt; a semantic requirement in a protocol.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; IMO these are problem worth addressing, especially now that we have a<br>&gt;&gt;&gt;&gt; good handle on what a solution would look like.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I really appreciate the attention that the library team has given to<br>&gt;&gt;&gt;&gt;&gt;&gt; this.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; , the standard library team thinks the right design is roughly<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; this:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; /// A multipass sequence that may be infinite<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Collection {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // Only eager algorithms that can terminate available here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func index(where predicate: (Element)-&gt;Bool) -&gt; Index<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // all lazy algorithms available here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var lazy: ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var startIndex: Index<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var endIndex: Index // possibly not reachable from startIndex<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; associatedtype SubSequence : Collection<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // do we need an associated FiniteSubsequence, e.g. for prefixes?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol FiniteCollection : Collection {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; // All eager algorithms available here<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; func map(...) -&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; var count: ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol BidirectionalCollection : Collection { ... }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol RandomAccessCollection : BidirectionalCollection { … }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Does this design entirely break with the relationship between<br>&gt;&gt;&gt;&gt;&gt;&gt; collections and iterators (dropping `makeIterator` as a protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; requirement)?  If so, would for..in (over collections) be built on top<br>&gt;&gt;&gt;&gt;&gt;&gt; of indices and use `formIndex(after:)`?  Would it require a finite<br>&gt;&gt;&gt;&gt;&gt;&gt; collection (unless we add `until` to the language and then allow<br>&gt;&gt;&gt;&gt;&gt;&gt; `for..in..until` to work with infinite collections)?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; All of these points are up for discussion.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cool.  I think the collection for..in has some nice advantages, but<br>&gt;&gt;&gt;&gt; since it sounds like we’ll probably keep Iterator around it might be<br>&gt;&gt;&gt;&gt; best to take the approach of making them both work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You already know that I would prefer to see the current for..in built<br>&gt;&gt;&gt;&gt; on finite sequences and allow for..in..unitl to be used with infinite<br>&gt;&gt;&gt;&gt; sequences if we add that in the future.  :)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; John McCall pointed out to<br>&gt;&gt;&gt;&gt;&gt; me that an index-based for..in would make it possible to implement<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for inout x in y { mutate(&amp;x) }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That would be very nice!<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think it might also increase performance.  I don’t know exactly how<br>&gt;&gt;&gt;&gt; for..in is implemented today, but the implementation of<br>&gt;&gt;&gt;&gt; IndexingIterator compares position to endIndex.  If for..in is also<br>&gt;&gt;&gt;&gt; comparing checking the optional for nil that’s an extra comparison.<br>&gt;&gt;&gt;&gt; We shouldn&#39;t need to actually construct the optional in the first<br>&gt;&gt;&gt;&gt; place using an index-based for..in.  Maybe optimizations like this<br>&gt;&gt;&gt;&gt; already exist?  But even if they do, it seems like they wouldn’t be<br>&gt;&gt;&gt;&gt; possible in some cases where the type of the sequence isn’t statically<br>&gt;&gt;&gt;&gt; known.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would we still retain `IndexingIterator`even if we break the<br>&gt;&gt;&gt;&gt;&gt;&gt; relationship in the protocol requirements?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes: it should be possible to implement Collection algorithms in terms<br>&gt;&gt;&gt;&gt;&gt; of Iterator algorithms, and IndexingIterator provides the means.  That<br>&gt;&gt;&gt;&gt;&gt; said, I think the makeIterator requirement does little harm, especially<br>&gt;&gt;&gt;&gt;&gt; when it can be defaulted for Collections.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I like this answer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Would it still be possible to do things like zip a multi-pass sequence<br>&gt;&gt;&gt;&gt;&gt;&gt; with a single-pass sequence (assuming we keep single-pass sequences or<br>&gt;&gt;&gt;&gt;&gt;&gt; add them back eventually)?  This seems like a use case worth<br>&gt;&gt;&gt;&gt;&gt;&gt; supporting in some way.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Yes.  If you can create an Iterator from a Collection, and you can zip<br>&gt;&gt;&gt;&gt;&gt; Iterators, you can do this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Yes, of course.  I’m glad we would keep this relationship in tact.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One subtle change I think this implies is that things like<br>&gt;&gt;&gt;&gt;&gt;&gt; `LazyFilterSequence` can implement `makeIterator` with constant<br>&gt;&gt;&gt;&gt;&gt;&gt; complexity, deferring the O(N) complexity to the first call to `next`.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I don&#39;t believe that&#39;s a difference, though I could be wrong.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You’re right, I was wrong.  `LazyFilterSequence` just constructs an<br>&gt;&gt;&gt;&gt; iterator and returns it.  `LazyFilterCollection` has to loop until it<br>&gt;&gt;&gt;&gt; finds the first item matching the predicate in its `startIndex`<br>&gt;&gt;&gt;&gt; implementation.  The part I was missing is that `IndexingIterator`<br>&gt;&gt;&gt;&gt; gets the `startIndex` in its initializer.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; `startIndex` for `LazyFilterCollection` currently has O(N) complexity.<br>&gt;&gt;&gt;&gt;&gt;&gt; The complexity of a complete iteration doesn’t change and probably<br>&gt;&gt;&gt;&gt;&gt;&gt; isn’t a big deal, but it’s worth noting.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Filtered collection views always require a bit of hand-waving around<br>&gt;&gt;&gt;&gt;&gt; performance guarantees; I don&#39;t think that changes.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I’ve been looking at some code that wraps a sequence and considering<br>&gt;&gt;&gt;&gt;&gt;&gt; how it would be impacted.  With iterators it looks like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard let element = base.next()<br>&gt;&gt;&gt;&gt;&gt;&gt; else { return nil }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With collections and indices it would look something like this:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; base.formIndex(after: &amp;index)<br>&gt;&gt;&gt;&gt;&gt;&gt; guard index != baseEndIndex<br>&gt;&gt;&gt;&gt;&gt;&gt; else { return endIndex }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let element = base[index]<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That’s not too bad but it is more verbose.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sequence today is a single-pass thing.  If you are wrapping Sequence<br>&gt;&gt;&gt;&gt;&gt; today presumably you&#39;d wrap an Iterator tomorrow, and you wouldn&#39;t have<br>&gt;&gt;&gt;&gt;&gt; to deal with indices.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; If we’re going to push people towards collections and indices we<br>&gt;&gt;&gt;&gt;&gt;&gt; should try to make common patterns like “update the iteration state<br>&gt;&gt;&gt;&gt;&gt;&gt; and return the next element if there is one&quot; simpler.  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That&#39;s IndexingIterator.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Cool, I wrote this thinking that was going away.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This could be accomplished with an extension method along these lines:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; guard let element = base.formIndex(after: &amp;index,<br>&gt;&gt;&gt;&gt;&gt;&gt; .returningOptionalElement)<br>&gt;&gt;&gt;&gt;&gt;&gt;  else { return endIndex }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With an implementation something like:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; enum FormIndexResult {<br>&gt;&gt;&gt;&gt;&gt;&gt;  .returningOptionalElement<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; extension Collection {<br>&gt;&gt;&gt;&gt;&gt;&gt;  func formIndex(after i: inout Self.Index, _ result:<br>&gt;&gt;&gt;&gt;&gt;&gt; FormIndexResult) -&gt; Self.Element?<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This would provide similar functionality to `IndexingIterator` without<br>&gt;&gt;&gt;&gt;&gt;&gt; coupling the storage of `elements` and `position` (which is important<br>&gt;&gt;&gt;&gt;&gt;&gt; if you’re wrapping a collection and need to wrap the collection and<br>&gt;&gt;&gt;&gt;&gt;&gt; its indices independently).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I&#39;m afraid I don&#39;t understand.  Could you be more explicit about what<br>&gt;&gt;&gt;&gt;&gt; you have in mind?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The idea was to provide functionality similar to `IndexingIterator` in<br>&gt;&gt;&gt;&gt; the sense the following code would provide equivalent functionality to<br>&gt;&gt;&gt;&gt; `iterator.next()` but expressed in terms of a collection and an index:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let optionalElement = myCollection.formIndex(after: &amp;myIndex, . returningOptionalElement)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; vs<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let optionalElement = myIterator.next()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The single case enum is just there to provide a label that<br>&gt;&gt;&gt;&gt; differentiates the overload.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If we’re keeping IndexingIterator this probably isn’t necessary.  I<br>&gt;&gt;&gt;&gt; still have a use case for it but it is rather obscure.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I can imagine wanting a design like the above for cases where<br>&gt;&gt;&gt; implementing the endIndex requires adding an extra bit of state, e.g. in<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct LazyPrefix&lt;Base: Collection&gt; : Collection {<br>&gt;&gt;&gt;   init(_ base: Base, where: (C.Element)-&gt;Bool)<br>&gt;&gt;&gt;   ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; you don&#39;t want to traverse the base collection eagerly just to come up<br>&gt;&gt;&gt; with an endIndex, so you store an optional Base.Index in<br>&gt;&gt;&gt; LazyPrefix.Index, which is nil for the endIndex.  In these cases, index<br>&gt;&gt;&gt; comparison is less efficient than it might otherwise be.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But my answer for these cases is simple: simply use a specialized<br>&gt;&gt;&gt; Iterator that will be more efficient than IndexingIterator.  Is there a<br>&gt;&gt;&gt; reason that doesn&#39;t work for your case?<br>&gt;&gt; <br>&gt;&gt; I would index a custom iterator in my case,<br>&gt; <br>&gt; I don&#39;t know what it means to index an iterator.<br></p><p>Wow, I have no idea how I feel ended up writing that.  I must have gotten distracted somehow.  I meant a custom iterator wouldn&#39;t be relevant in my case.<br></p><p>&gt; <br>&gt;&gt; but I am talking about code that would live inside the implementation<br>&gt;&gt; of `index(after:)` in the `Collection` conformance of a wrapper<br>&gt;&gt; `Collection` that bears some resemblance to `LazyFlattenCollection`.<br>&gt;&gt; In this case you are receiving your `Index` which wraps `Base.Index`.<br>&gt; <br>&gt; I don&#39;t understand, but maybe it doesn&#39;t matter.  <br></p><p>Sorry, maybe I would need to provide more context.  But it&#39;s not important as like I said, it is a relatively obscure case.<br></p><p>&gt; FWIW, I&#39;m pretty<br>&gt; confident we could write a specialized Collection protocol that, given<br>&gt; some equatable State and a next() method, supplied all the basic<br>&gt; Collection requirements, for the cases where the Iterator is the most<br>&gt; efficient means of traversal, e.g.<br>&gt; <br>&gt;      protocol IteratingCollection : Collection {<br>&gt;        associatedtype IterationState : Equatable<br>&gt;        func next(inout state: IterationState) -&gt; Element?<br>&gt;        func startState() -&gt; IterationState<br>&gt;      }<br>&gt; <br>&gt;      extension IteratingCollection {<br>&gt;        // all the collection requirements implemented in terms<br>&gt;        // of startState() and next(...)<br>&gt;      }<br></p><p>This would be cool.  It could be the basis of a method taking a start state and a closure (I think you mentioned a method like this earlier).<br></p><p>&gt; <br>&gt;&gt; Like I said, this is a pretty obscure case and I would never suggest<br>&gt;&gt; including it on the grounds of a use case that is only relevant to<br>&gt;&gt; `index(after:)` implementations in wrapper collections. :) I brought<br>&gt;&gt; it because I thought you may have been suggesting a more drastic<br>&gt;&gt; change that removed the collection iterators.<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On second thought, I believe it is important to have a way to support<br>&gt;&gt;&gt;&gt;&gt; existing “partially formed” multipass sequences that don&#39;t expose<br>&gt;&gt;&gt;&gt;&gt; copying or equality for their iteration states.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you provide examples of these?  I’m having difficulty thinking of<br>&gt;&gt;&gt;&gt; one.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; NSSet is an example.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Iterator is the right way to do that.  So I think we need to keep<br>&gt;&gt;&gt;&gt;&gt; Iterator around.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I don’t have any objection to keeping it either. :) Hopefully we’d<br>&gt;&gt;&gt;&gt; still be able to improve the design in the future if / when new<br>&gt;&gt;&gt;&gt; enabling language features come along.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the meantime, people would be able to implement their own protocol<br>&gt;&gt;&gt;&gt;&gt;&gt; for single pass sequences.  What they would lose is for..in as well as<br>&gt;&gt;&gt;&gt;&gt;&gt; the standard library algorithms.  I’m not sure how many people this<br>&gt;&gt;&gt;&gt;&gt;&gt; would impact or how big the impact would be for them.  We have seen a<br>&gt;&gt;&gt;&gt;&gt;&gt; couple of examples in this discussion, but probably not enough to<br>&gt;&gt;&gt;&gt;&gt;&gt; asses the overall impact.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; One thing you don’t mention here is a distinction between finite and<br>&gt;&gt;&gt;&gt;&gt;&gt; infinite single-pass sequences (iterators).  I don’t know if the<br>&gt;&gt;&gt;&gt;&gt;&gt; finite / infinite distinction is as important here, but wanted to<br>&gt;&gt;&gt;&gt;&gt;&gt; point it out.  Obviously if we remove support single-pass sequences<br>&gt;&gt;&gt;&gt;&gt;&gt; now we could defer that discussion until we’re ready to bring back<br>&gt;&gt;&gt;&gt;&gt;&gt; support for them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are a few possible answers I can think of:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 1. Do the “obvious” thing and create a separate protocol for finite<br>&gt;&gt;&gt;&gt;&gt; single-pass sequences<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 2. Decide that the combination of infinite and single-pass is rare<br>&gt;&gt;&gt;&gt;&gt; enough (/dev/urandom, temperature sensor) that it&#39;s better to just<br>&gt;&gt;&gt;&gt;&gt; ask people handling them to be careful and not, e.g., try to “count”<br>&gt;&gt;&gt;&gt;&gt; them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 3. Decide that everything on a single-pass sequence is lazy. Since you<br>&gt;&gt;&gt;&gt;&gt; can only take a single pass anyway, people won&#39;t observe their<br>&gt;&gt;&gt;&gt;&gt; closures being called more often than necessary, which was the main<br>&gt;&gt;&gt;&gt;&gt; motivator for making map, filter, et. al eager on collections without<br>&gt;&gt;&gt;&gt;&gt; an explicit .lazy.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Implications of #3:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Any “partially-formed” multipass sequences (modeling only Iterator)<br>&gt;&gt;&gt;&gt;&gt; would be free to expose an accurate underestimatedCount, thereby<br>&gt;&gt;&gt;&gt;&gt; optimizing the process of copying into an array. The lazy filter<br>&gt;&gt;&gt;&gt;&gt; Iterator adaptor would have an underestimatedCount of 0.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * All algorithms that require multiple passes, such as sorted(), would<br>&gt;&gt;&gt;&gt;&gt; be unavailable on Iterator.  You&#39;d have to construct an Array (or<br>&gt;&gt;&gt;&gt;&gt; other MutableCollection) and sort that in-place.  Of course,<br>&gt;&gt;&gt;&gt;&gt; constructing an Array from an Iterator could still go on forever if<br>&gt;&gt;&gt;&gt;&gt; the Iterator turned out to be infinite, which means, at some level #3<br>&gt;&gt;&gt;&gt;&gt; is just a refinement of #2 that makes it less error-prone.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you lean towards any of these?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Yes, #3.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We can always make the few operations that have to be eager—such as<br>&gt;&gt;&gt; Array construction from an Iterator—explicit with a label or something:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     Array(claimingFiniteness: someIterator)<br>&gt;&gt; <br>&gt;&gt; This makes sense.  Finite single-pass iterators can always be added in<br>&gt;&gt; the future if compelling use cases emerge. We’re not taking anything<br>&gt;&gt; away.<br>&gt;&gt; <br>&gt;&gt; All of the code I have looked at that makes a finite assumption would<br>&gt;&gt; be converted to require `Collection` in the new model.<br>&gt; <br>&gt; I think you mean FiniteCollection, yes?<br></p><p>Yes, sorry.<br></p><p>&gt; <br>&gt; -- <br>&gt; Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Trying my hardest to summarize the talking points of the conversation so far. Please let me know if I’ve missed any particular points:<br></p><p>- The thread was started (by yours truly) as an offshoot of another on-list conversation involving Dave Abrahams. In it, I voiced a concern that there were not enough legitimate needs for a single pass sequence as a core type (supporting concepts such as for..in) to warrant the possibility of single-pass behavior in Sequence when writing dependent algorithms<br>	- There was a concern about the possible mutability of the methods causing complexities around standard naming, in particular the recurring effort to rename map/filter/reduce ‘terms of art’.<br>	- For example in the case of filter vs filtered, the immutably-named version might still destroy the ability to access the original data<br></p><p>- Dave Abrahams’s primary concern about the existing system is that the restriction that Sequence is single-pass is not intuitive, and that generalized functions over sequences would be tested with the commonly-available Sequences, all of which are multi-pass.<br>	- Considering single vs multi-pass can affect the algorithmic complexity and memory requirements of their code, this could be a considerably difficult bug to solve later on.<br>	- There is also a desire to simplify things by reducing the # of types if at all possible, and likewise a distaste for increasing the number of types or overall complexity<br>	- One example here would be that if single-pass sequences are rare, it may be possible to drop Sequence completely and just have Collection<br> <br>- Single-pass sequences seem to be very rare and centered around I/O. One interesting example given was a database row cursor.<br></p><p>- A concern was voiced (by yours truly) that Sequences, unlike Collections, can today be:<br>	- Single pass/destructive<br>	- Infinite<br>	- Non-indexed<br>and that the elimination of single pass behavior would not eliminate the other differentiating factors<br></p><p>It was countered that<br>	- Infinite sequences may be representable with Collection<br>	- It is possible to have the state in a programmatic generator be encoded in or as the Index in a collection, so even programmatic sequences can support indexes<br></p><p>- A single-pass sequence is likely best represented by not having implement Sequence, but rather having an Iterator implementation directly. <br>	- Such an Iterator should be a reference type rather than representing it as having value semantics - if you actually support value semantics, then your state should be self-contained and thus you can support multi-pass.<br>	- IteratorProtocol might gain several of the sequence methods, such as dropFirst() and prefix().<br>	- Scala’s name for a single-pass sequence is TraversableOnce, and such descriptive naming would be useful in developer understanding on how to use single-pass sequences<br>	- There was concern that the current model might be appropriate, and that the changes may be underestimating developers’ ability to deal with the complexity of single and multi pass sequences represented by the same type.<br></p><p>- It is a possibility that for..in would work with two distinct protocols (such as IteratorProtocol and Sequence) , rather than having single pass iteration be differentiated by where you are in an inheritance chain<br>	-There was also a concern that if we have a single root type that is for..in-able, we would [just be shuffling things around], e.g. calling Sequence multi-pass, and creating a new SinglePassSequence above it.<br></p><p>- While single-vs-multipass is a distinction which needs to be made, there is some disagreement over whether it makes sense to differentiate infinite vs finite sequences. A collection with UInt64.max elements is finite but is still effectively infinite in terms of computation time. E.g., algorithms might fail due to memory consumption or performance for a 2 billion entry collection the same as they would fail for an infinite one.<br></p><p>- There is a desire if possible to eliminate Sequence if possible, and just have Collection. However, Collection has the requirement of returning a finite count and is Indexable.<br>	- Indexable requires a Index which can be used to look up a collection value as an O(1) operation<br>	- Indexable is comparable/equatable, although there is a possibility that Comparable could be dropped to simplify implementation of Collections<br>	- Indexable requires a end index, which for an infinite Collection would be a synthetic value<br>	- Indexable incudes a distance between two indexes, thus having similar problems to Collection.count<br></p><p>- Around infinite sequences, there has been some discussion on whether it is worth differentiating them via different types to provide developer warning that they may be working with an infinite loop. There was discussion of a for..in..until syntax for this (I presume because for..in..while would be harder grammar-wise?). The justification is that requiring until requires the developer to reason about the infinite sequence.<br></p><p>- For computed sequences, it would be possible to use an iterator directly as the index, as the index is not required to be an Integer type to meet Collection requirements.<br></p><p>- There was a discussion of having a Iterator and FiniteIterator. It was also mentioned that Iterator could be func next() -&gt;T while FiniteIterator is func next() -&gt; T? . There was also discussion that there might be a PossiblyInfiniteIterator with Finite and Infinite iterators as subclasses.<br></p><p>- There was discussion about forcing value-semantic iterators to be Collections. This could be done by allowing for infinite Collections, using something similar to a value-semantic iterator as the Index, while reducing the requirements for Index to support such usage (e.g. drop Comparable)<br></p><p>- There was a strawman to move eager operations (map, etc) and count to a FiniteCollection sub-protocol of Collection.  (note: it was not clarified what other protocols Collection maintains, like Indexable, where Indexable still has requirements for functions like distance() )<br></p><p>- &quot;AFAIK there is no interesting multipass Sequence that cannot reasonably be made to support indexing.” -Dave Abrahams<br></p><p>- Discussion steered toward using sequence(first:next:) and sequence(state:next:) to create collections, and using this as a replacement for iterator/sequence usage<br></p><p>- If Iterator and Sequence are no longer part of multi-pass sequences, one could instead support for..in using formIndex and subscripting.<br>	- This would support subscript setters, and thus mutation of values in a for..in<br></p><p>- Dave Abrahams indicated a desire to support “partially formed” multipass sequences which cannot meet indexable requirements easy via the existing iterator system. An example given was collections imported from Foundation, such as NSSet.<br>	- Thus it would be likely that Collection would retain makeIterator. Thus iterators themselves would not give a destructive vs nondestructive guarantee.<br></p><p>- Three possible approaches were given for differentiating finite and infinite single-pass sequences, to protect against generalized algorithms that would go into an infinite loop when called:<br>	1. Separate protocols (provide count only on FiniteIterator)<br>	2. Implicit additional requirements from iterator source documentation (don’t call count on the /dev/urandom-backed iterator)<br>	3. Make all provided iterator methods lazy (instead of count, provide underestimateCount or possibly have count return an optional)<br></p><p>-DW<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jul 1, 2016, at 9:59 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;  complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;  different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;  can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;  and once you&#39;ve done that you can make the endIndex an Int.<br>&gt; <br>&gt; It’s also worth nothing that we can use `Optional` with `nil` as the `endIndex` sentinel if necessary.<br></p><p>I don’t believe this is true? Optional cannot support Equatable w/o generics changes. I believe we would need a different wrapper type.<br>&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt;&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt;&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt;&gt; Iterator protocol would not be labeled as mutating.<br>&gt;&gt; <br>&gt;&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt;&gt; in this area.  One possibility under consideration is simply dropping<br>&gt;&gt; support for single-pass sequences until Swift can support move-only<br>&gt;&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt; the standard library.<br>&gt; <br>&gt; I’m happy to see you mention a mutation model for class instances!  (I don’t mean to sidetrack the discussion, but would love to see that someday)<br>&gt; <br>&gt; I don’t have any objection to dropping support for single-pass sequences temporarily.  It’s possible that I would feel differently if I was making use of them in my own code but I’m not.<br></p><p>I might see an issue if there were enough single-pass sequences that we worried about them trying to wedge themselves into Collection.<br></p><p>&gt; In the meantime, people would be able to implement their own protocol for single pass sequences.  What they would lose is for..in as well as the standard library algorithms.  I’m not sure how many people this would impact or how big the impact would be for them.  We have seen a couple of examples in this discussion, but probably not enough to asses the overall impact.<br></p><p>I “feel” the model for Iterator as a separate possibly single-pass/infinite thing makes sense. But I also suspect unique requirements will come up for I/O use cases; who knows if some concurrency primitives might provide a better fit at that point in time?<br></p><p>-DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/defb7989/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>July  5, 2016 at 04:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jul 5, 2016, at 3:32 PM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Jul 1, 2016, at 9:59 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;&gt;  complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;&gt;  different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;&gt;  can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;&gt;  and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt; <br>&gt;&gt; It’s also worth nothing that we can use `Optional` with `nil` as the `endIndex` sentinel if necessary.<br>&gt; <br>&gt; I don’t believe this is true? Optional cannot support Equatable w/o generics changes. I believe we would need a different wrapper type.<br></p><p>That&#39;s true right now, but conditional conformances are very near the top, if not the top, item on the generics priority list.  I&#39;m hoping they make Swift 3.x rather than 4.0 (but have no knowledge of the likelihood of that).<br></p><p>&gt;&gt;&gt; The fact that Swift doesn&#39;t have a mutation model for classes, though,<br>&gt;&gt;&gt; means that mutating methods on a class constrained protocol can&#39;t be<br>&gt;&gt;&gt; labeled as such.  So consuming operations on a class-constrained<br>&gt;&gt;&gt; Iterator protocol would not be labeled as mutating.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The standard library team is currently trying to evaluate the tradeoffs<br>&gt;&gt;&gt; in this area.  One possibility under consideration is simply dropping<br>&gt;&gt;&gt; support for single-pass sequences until Swift can support move-only<br>&gt;&gt;&gt; value types and/or gets a mutation model for class instances.  It would<br>&gt;&gt;&gt; be very interesting to know about any real-world models of single-pass<br>&gt;&gt;&gt; sequences that people are using in Swift, since we don&#39;t supply any in<br>&gt;&gt;&gt; the standard library.<br>&gt;&gt; <br>&gt;&gt; I’m happy to see you mention a mutation model for class instances!  (I don’t mean to sidetrack the discussion, but would love to see that someday)<br>&gt;&gt; <br>&gt;&gt; I don’t have any objection to dropping support for single-pass sequences temporarily.  It’s possible that I would feel differently if I was making use of them in my own code but I’m not.<br>&gt; <br>&gt; I might see an issue if there were enough single-pass sequences that we worried about them trying to wedge themselves into Collection.<br>&gt; <br>&gt;&gt; In the meantime, people would be able to implement their own protocol for single pass sequences.  What they would lose is for..in as well as the standard library algorithms.  I’m not sure how many people this would impact or how big the impact would be for them.  We have seen a couple of examples in this discussion, but probably not enough to asses the overall impact.<br>&gt; <br>&gt; I “feel” the model for Iterator as a separate possibly single-pass/infinite thing makes sense. But I also suspect unique requirements will come up for I/O use cases; who knows if some concurrency primitives might provide a better fit at that point in time?<br>&gt; <br>&gt; -DW<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160705/f3dd8a78/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  5, 2016 at 02:00:00pm</p></header><div class="content"><p>on Tue Jul 05 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br></p><p>&gt;&gt; On Jul 1, 2016, at 9:59 AM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Jun 30, 2016, at 12:26 PM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Q: Why not allow endIndex to have a different type from startIndex?<br>&gt;&gt;&gt; A: It appears to offer insufficient benefit for the associated<br>&gt;&gt;&gt;  complexity in typical usage.  A classic use case that argues for a<br>&gt;&gt;&gt;  different endIndex type is the null-terminated C string.  But you<br>&gt;&gt;&gt;  can&#39;t index one of those safely without actually counting the length,<br>&gt;&gt;&gt;  and once you&#39;ve done that you can make the endIndex an Int.<br>&gt;&gt; <br>&gt;&gt; It’s also worth nothing that we can use `Optional` with `nil` as the `endIndex` sentinel if necessary.<br>&gt;<br>&gt; I don’t believe this is true? Optional cannot support Equatable w/o<br>&gt; generics changes. I believe we would need a different wrapper type.<br></p><p>Correct.<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 27, 2016 at 09:00:00am</p></header><div class="content"><p>I should be clear up-front about the main problem I&#39;m trying to solve:<br></p><p>Today, people see a beautiful, simple protocol (Sequence) to which many<br>things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>(assume you can make only a single-pass!) on it, so they write libraries<br>of functions that may make multiple passes over Sequences.  They test<br>their libraries with the most commonly-available Sequences, e.g. Arrays<br>and Ranges, which happen to be multi-pass.  Their tests pass!  But their<br>constraints are wrong, their whole model of how to write generic code<br>over sequences is wrong, and some of their code is wrong.<br></p><p>IMO this is a problematic programming model.<br></p><p>on Sun Jun 26 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br></p><p>&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt; defined count/endIndex?  Other than that, I agree with your statement.<br></p><p>I agree that that is currently what the documentation allows and requires.<br>Maybe we do need to separate finiteness from multipass-ness.  There&#39;s<br>certainly no reason one can&#39;t make multiple passes over a portion of an<br>infinite sequence.  <br></p><p>[Just to complicate things... I wonder if finiteness is really<br>meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>it&#39;s “effectively infinite.”]<br></p><p>&gt; Here is what I see as the appropriate structure:<br>&gt;<br>&gt; Iterator: Single destructive pass, potentially infinite, (should be<br>&gt; for-in able)<br></p><p>[Note: the best way to represent “single destructive pass” today is to<br>constrain Iterator to be a reference type.  Otherwise, it&#39;s both easy to<br>create an Iterator that can be used to make multiple passes (by<br>copying), and to create a truly single-pass Iterator that suggests it<br>has value semantics.  These are both potentially misleading situations]<br></p><p>&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt; collection, but lose anything that relies on it ending)<br>&gt;<br>&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt; form, except extra inits from Iterator/Sequence with end conditions)<br></p><p>This is a reasonable structure, but there are important details missing.<br></p><p>1. Presumably these are all for-in-able.  What makes something<br>   for-in-able?<br></p><p>2. Presumably Collection refines Sequence.  Does Sequence refine<br>   Iterator?  IMO that would create the same problematic programming<br>   model we have today.<br></p><p>Perhaps the language should accept types conforming to either of two<br>unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>them, with no refinement relationship) for for-in.<br></p><p>&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt; could be made much safer by considering the potentially infinite and<br>&gt; finite cases separately...<br></p><p>The other thing I am concerned about here is that we&#39;re addressing real<br>use-cases with these distinctions.  For example, do people commonly get<br>in trouble with infinite sequences today?<br></p><p>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt; &gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt; &gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt; &gt;&gt; wrote:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt; &gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt; &gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt; &gt;&gt; detail here:<br>&gt;&gt; &gt;&gt; <br>&gt;&gt; &gt;&gt; * Would you remove Sequence?<br>&gt;&gt; &gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt; &gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt; &gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt; &gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt; &gt; for meeting the other requirements for Collection.<br>&gt;&gt; <br>&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br></p><p>-- <br>-Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 11:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I should be clear up-front about the main problem I&#39;m trying to solve:<br>&gt; <br>&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt; (assume you can make only a single-pass!) on it, so they write libraries<br>&gt; of functions that may make multiple passes over Sequences.  They test<br>&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt; and Ranges, which happen to be multi-pass.  Their tests pass!  But their<br>&gt; constraints are wrong, their whole model of how to write generic code<br>&gt; over sequences is wrong, and some of their code is wrong.<br>&gt; <br>&gt; IMO this is a problematic programming model.<br>&gt; <br>&gt; on Sun Jun 26 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br>&gt; <br>&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt; defined count/endIndex?  Other than that, I agree with your statement.<br>&gt; <br>&gt; I agree that that is currently what the documentation allows and requires.<br>&gt; Maybe we do need to separate finiteness from multipass-ness.  There&#39;s<br>&gt; certainly no reason one can&#39;t make multiple passes over a portion of an<br>&gt; infinite sequence.  <br></p><p>Exactly.  It is perfectly reasonable to have an infinite, dynamically generated mathematical sequence and make multiple passes over a portion of it (for example, by zipping it with finite sequences, taking a prefix, etc).<br></p><p>&gt; <br>&gt; [Just to complicate things... I wonder if finiteness is really<br>&gt; meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>&gt; it&#39;s “effectively infinite.”]<br></p><p>Of course that is *possible* and not hard to do but it sounds like a degenerate case to me.  How often do such things arise *in practice*?  In reality I suspect we tend to have sequences that are either infinite or finite not just in a strict sense, but also in a practical sense.  <br></p><p>&gt; <br>&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt; <br>&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be<br>&gt;&gt; for-in able)<br>&gt; <br>&gt; [Note: the best way to represent “single destructive pass” today is to<br>&gt; constrain Iterator to be a reference type.  Otherwise, it&#39;s both easy to<br>&gt; create an Iterator that can be used to make multiple passes (by<br>&gt; copying), and to create a truly single-pass Iterator that suggests it<br>&gt; has value semantics.  These are both potentially misleading situations]<br>&gt; <br>&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt; <br>&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt; <br>&gt; This is a reasonable structure, but there are important details missing.<br>&gt; <br>&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;   for-in-able?<br>&gt; <br>&gt; 2. Presumably Collection refines Sequence.  Does Sequence refine<br>&gt;   Iterator?  IMO that would create the same problematic programming<br>&gt;   model we have today.<br>&gt; <br>&gt; Perhaps the language should accept types conforming to either of two<br>&gt; unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>&gt; them, with no refinement relationship) for for-in.<br>&gt; <br>&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt; finite cases separately...<br>&gt; <br>&gt; The other thing I am concerned about here is that we&#39;re addressing real<br>&gt; use-cases with these distinctions.  For example, do people commonly get<br>&gt; in trouble with infinite sequences today?<br></p><p>I think the same question can apply to destructive consumption of sequences.  I know people write code that assumes multi-pass and people also write code that assumes finiteness.  Do you know of cases where people commonly get into trouble with single pass sequences today?<br></p><p>I don’t know of specific cases where either has caused problems in practice but both leave plenty of room for trouble.  Enough that they deserve fixing IMO as they are pretty fundamental constructs that most Swift code relies upon.<br></p><p>-Matthew<br></p><p>&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/89e9af7c5754673419c8fac930319700?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Russ Bishop</string> &lt;xenadu at gmail.com&gt;<p>June 27, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 9:39 AM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Perhaps the language should accept types conforming to either of two<br>&gt; unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>&gt; them, with no refinement relationship) for for-in.<br>&gt; <br></p><p>The more I think about it the more I think this is a good model. Iterator is already single-use. Sequence then describes a type that can vend multiple iterators and is inherently multi-pass. I would argue the protocol is making this guarantee already, since makeIterator() naturally lends itself to multiple invocations.<br></p><p>In my example, LazyRowSequence becomes LazyRowIterator.<br></p><p><br>Russ<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/13947e10/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>Comments inline<br></p><p>&gt; On Jun 27, 2016, at 9:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; I should be clear up-front about the main problem I&#39;m trying to solve:<br>&gt; <br>&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt; (assume you can make only a single-pass!) on it, so they write libraries<br>&gt; of functions that may make multiple passes over Sequences.  They test<br>&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt; and Ranges, which happen to be multi-pass.  Their tests pass!  But their<br>&gt; constraints are wrong, their whole model of how to write generic code<br>&gt; over sequences is wrong, and some of their code is wrong.<br>&gt; <br>&gt; IMO this is a problematic programming model.<br>Agreed.<br></p><p><br>&gt; on Sun Jun 26 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt; defined count/endIndex?  Other than that, I agree with your statement.<br>&gt; <br>&gt; I agree that that is currently what the documentation allows and requires.<br>&gt; Maybe we do need to separate finiteness from multipass-ness.  There&#39;s<br>&gt; certainly no reason one can&#39;t make multiple passes over a portion of an<br>&gt; infinite sequence.<br>I have a use-case for this below.  Graphical manipulation using a repeatable sequence of random numbers.<br></p><p><br>&gt;  [Just to complicate things... I wonder if finiteness is really<br>&gt; meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>&gt; it&#39;s “effectively infinite.”]<br></p><p>See below… I am definitely guilty of this.  That said, if we had explicit infinite sequences (with subscripts), I would use those instead of collections for these use-cases.<br></p><p>&gt; <br>&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt; <br>&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be<br>&gt;&gt; for-in able)<br>&gt; <br>&gt; [Note: the best way to represent “single destructive pass” today is to<br>&gt; constrain Iterator to be a reference type.  Otherwise, it&#39;s both easy to<br>&gt; create an Iterator that can be used to make multiple passes (by<br>&gt; copying), and to create a truly single-pass Iterator that suggests it<br>&gt; has value semantics.  These are both potentially misleading situations]<br></p><p>Hmm… This is a really good point.  I can see why you are thinking of making it a reference type.<br></p><p>If a particular iterator can safely be cloned mid-stream, then it can provide its own interface to allow that.  The value type makes a promise which can’t always be kept.<br></p><p>&gt; <br>&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt; <br>&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt; <br>&gt; This is a reasonable structure, but there are important details missing.<br>&gt; <br>&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;   for-in-able?<br></p><p>I would think the potentially infinite should require for-in-until (even if you explicitly set until to false to create an infinite loop), but collection would allow for-in (with optional until).  That way you have to acknowledge the possibility of an infinite sequence/iterator.<br></p><p><br>&gt; 2. Presumably Collection refines Sequence.  Does Sequence refine<br>&gt;   Iterator?  IMO that would create the same problematic programming<br>&gt;   model we have today.<br>Sequence vends iterators. (a sequence is NOT a refinement of iterator, it just creates them as needed)<br></p><p>&gt; Perhaps the language should accept types conforming to either of two<br>&gt; unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>&gt; them, with no refinement relationship) for for-in.<br>Yes.<br></p><p><br>&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt; finite cases separately...<br>&gt; <br>&gt; The other thing I am concerned about here is that we&#39;re addressing real<br>&gt; use-cases with these distinctions.  For example, do people commonly get<br>&gt; in trouble with infinite sequences today?<br></p><p>Probably not… because they avoid infinite sequences to avoid getting into trouble.  I was bitten a few times early on (I assumed map was lazy) and just avoided them until recently.<br></p><p>I think they would be used more often if you could guarantee that their use was safe (i.e. being forced to consider the infinite possibility).  I would like to have a bunch of infinite sequences that could easily be refined to collections.  The ones I would use most often would be the natural numbers and random numbers.  Also imagine, an infinite sequence of random colors which look fairly good together.  Markov chains, die rolls… there are a lot of potential uses that become interesting once the threat of accidental infinite loop has been removed...<br></p><p>As a real world example of the &quot;effectively infinite” sequence, this weekend I created a Swift 3 collection of repeatable random values (of any type conforming to a protocol). I would have used sequence if the subscript behavior was available on it, since I do intend it to be an infinite sequence in most cases (Apologies for the lack of comments, it is not yet prepared for public consumption):<br>https://gist.github.com/jonhull/3655672529f8cf5b2eb248583d2cafb9<br></p><p>The use case here is to create a hand-drawn look for a CGPath by breaking it up into pieces and then jiggling the pieces about (using random CGVectors). I quickly realized that I needed a repeatable source of randomness (otherwise the drawing would move each time it was redrawn), and thus a multi-pass sequence.<br></p><p>I am a little bit nervous every time I use this, as it has the potential for an “effectively infinite” loop, but is proving useful throughout my project.<br></p><p>Thanks,<br>Jon<br></p><p>&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com &lt;http://david-at-alkaline-solutions.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; -Dave<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/5a8523b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 27, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Jun 27, 2016, at 8:32 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Comments inline<br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 9:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I should be clear up-front about the main problem I&#39;m trying to solve:<br>&gt;&gt; <br>&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt; (assume you can make only a single-pass!) on it, so they write libraries<br>&gt;&gt; of functions that may make multiple passes over Sequences.  They test<br>&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt; and Ranges, which happen to be multi-pass.  Their tests pass!  But their<br>&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt; <br>&gt;&gt; IMO this is a problematic programming model.<br>&gt; Agreed.<br>&gt; <br>&gt; <br>&gt;&gt;&gt; on Sun Jun 26 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your statement.<br>&gt;&gt; <br>&gt;&gt; I agree that that is currently what the documentation allows and requires.<br>&gt;&gt; Maybe we do need to separate finiteness from multipass-ness.  There&#39;s<br>&gt;&gt; certainly no reason one can&#39;t make multiple passes over a portion of an<br>&gt;&gt; infinite sequence.<br>&gt; I have a use-case for this below.  Graphical manipulation using a repeatable sequence of random numbers.<br>&gt; <br>&gt; <br>&gt;&gt;  [Just to complicate things... I wonder if finiteness is really<br>&gt;&gt; meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>&gt;&gt; it&#39;s “effectively infinite.”]<br>&gt; <br>&gt; See below… I am definitely guilty of this.  That said, if we had explicit infinite sequences (with subscripts), I would use those instead of collections for these use-cases.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be<br>&gt;&gt;&gt; for-in able)<br>&gt;&gt; <br>&gt;&gt; [Note: the best way to represent “single destructive pass” today is to<br>&gt;&gt; constrain Iterator to be a reference type.  Otherwise, it&#39;s both easy to<br>&gt;&gt; create an Iterator that can be used to make multiple passes (by<br>&gt;&gt; copying), and to create a truly single-pass Iterator that suggests it<br>&gt;&gt; has value semantics.  These are both potentially misleading situations]<br>&gt; <br>&gt; Hmm… This is a really good point.  I can see why you are thinking of making it a reference type.<br>&gt; <br>&gt; If a particular iterator can safely be cloned mid-stream, then it can provide its own interface to allow that.  The value type makes a promise which can’t always be kept.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt; <br>&gt;&gt; This is a reasonable structure, but there are important details missing.<br>&gt;&gt; <br>&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;   for-in-able?<br>&gt; <br>&gt; I would think the potentially infinite should require for-in-until (even if you explicitly set until to false to create an infinite loop), but collection would allow for-in (with optional until).  That way you have to acknowledge the possibility of an infinite sequence/iterator.<br></p><p>This is an interesting idea.  I think I like it!<br></p><p>&gt; <br>&gt; <br>&gt;&gt; 2. Presumably Collection refines Sequence.  Does Sequence refine<br>&gt;&gt;   Iterator?  IMO that would create the same problematic programming<br>&gt;&gt;   model we have today.<br>&gt; Sequence vends iterators. (a sequence is NOT a refinement of iterator, it just creates them as needed)<br>&gt; <br>&gt;&gt; Perhaps the language should accept types conforming to either of two<br>&gt;&gt; unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>&gt;&gt; them, with no refinement relationship) for for-in.<br>&gt; Yes.<br>&gt; <br>&gt; <br>&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt; finite cases separately...<br>&gt;&gt; <br>&gt;&gt; The other thing I am concerned about here is that we&#39;re addressing real<br>&gt;&gt; use-cases with these distinctions.  For example, do people commonly get<br>&gt;&gt; in trouble with infinite sequences today?<br>&gt; <br>&gt; Probably not… because they avoid infinite sequences to avoid getting into trouble.  I was bitten a few times early on (I assumed map was lazy) and just avoided them until recently.<br>&gt; <br>&gt; I think they would be used more often if you could guarantee that their use was safe (i.e. being forced to consider the infinite possibility).  I would like to have a bunch of infinite sequences that could easily be refined to collections.  The ones I would use most often would be the natural numbers and random numbers.  Also imagine, an infinite sequence of random colors which look fairly good together.  Markov chains, die rolls… there are a lot of potential uses that become interesting once the threat of accidental infinite loop has been removed...<br>&gt; <br>&gt; As a real world example of the &quot;effectively infinite” sequence, this weekend I created a Swift 3 collection of repeatable random values (of any type conforming to a protocol). I would have used sequence if the subscript behavior was available on it, since I do intend it to be an infinite sequence in most cases (Apologies for the lack of comments, it is not yet prepared for public consumption):<br>&gt; https://gist.github.com/jonhull/3655672529f8cf5b2eb248583d2cafb9<br>&gt; <br>&gt; The use case here is to create a hand-drawn look for a CGPath by breaking it up into pieces and then jiggling the pieces about (using random CGVectors). I quickly realized that I needed a repeatable source of randomness (otherwise the drawing would move each time it was redrawn), and thus a multi-pass sequence.<br></p><p>Thank you for sharing this example.  It&#39;s a good one.<br></p><p>&gt; <br>&gt; I am a little bit nervous every time I use this, as it has the potential for an “effectively infinite” loop, but is proving useful throughout my project.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/7cb620bb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>June 28, 2016 at 10:00:00am</p></header><div class="content"><p>on Mon Jun 27 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br></p><p>&gt; Comments inline<br>&gt;<br>&gt;&gt; On Jun 27, 2016, at 9:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I should be clear up-front about the main problem I&#39;m trying to solve:<br>&gt;&gt; <br>&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt; (assume you can make only a single-pass!) on it, so they write libraries<br>&gt;&gt; of functions that may make multiple passes over Sequences.  They test<br>&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt; and Ranges, which happen to be multi-pass.  Their tests pass!  But their<br>&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt; <br>&gt;&gt; IMO this is a problematic programming model.<br>&gt; Agreed.<br>&gt;<br>&gt;&gt; on Sun Jun 26 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your statement.<br>&gt;&gt; <br>&gt;&gt; I agree that that is currently what the documentation allows and requires.<br>&gt;&gt; Maybe we do need to separate finiteness from multipass-ness.  There&#39;s<br>&gt;&gt; certainly no reason one can&#39;t make multiple passes over a portion of an<br>&gt;&gt; infinite sequence.<br>&gt; I have a use-case for this below.  Graphical manipulation using a repeatable sequence of random numbers.<br>&gt;<br>&gt;&gt;  [Just to complicate things... I wonder if finiteness is really<br>&gt;&gt; meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>&gt;&gt; it&#39;s “effectively infinite.”]<br>&gt;<br>&gt; See below… I am definitely guilty of this.  That said, if we had<br>&gt; explicit infinite sequences (with subscripts), I would use those<br>&gt; instead of collections for these use-cases.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be<br>&gt;&gt;&gt; for-in able)<br>&gt;&gt; <br>&gt;&gt; [Note: the best way to represent “single destructive pass” today is to<br>&gt;&gt; constrain Iterator to be a reference type.  Otherwise, it&#39;s both easy to<br>&gt;&gt; create an Iterator that can be used to make multiple passes (by<br>&gt;&gt; copying), and to create a truly single-pass Iterator that suggests it<br>&gt;&gt; has value semantics.  These are both potentially misleading situations]<br>&gt;<br>&gt; Hmm… This is a really good point.  I can see why you are thinking of making it a reference type.<br>&gt;<br>&gt; If a particular iterator can safely be cloned mid-stream, then it can<br>&gt; provide its own interface to allow that.  The value type makes a<br>&gt; promise which can’t always be kept.<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt; <br>&gt;&gt; This is a reasonable structure, but there are important details missing.<br>&gt;&gt; <br>&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;   for-in-able?<br>&gt;<br>&gt; I would think the potentially infinite should require for-in-until<br>&gt; (even if you explicitly set until to false to create an infinite<br>&gt; loop), but collection would allow for-in (with optional until).  That<br>&gt; way you have to acknowledge the possibility of an infinite<br>&gt; sequence/iterator.<br></p><p>Are you proposing a new language feature?  We could also do this with<br></p><p>    for i in allIntegers.until(isPrime)<br></p><p>&gt;&gt; 2. Presumably Collection refines Sequence.  Does Sequence refine<br>&gt;&gt;   Iterator?  IMO that would create the same problematic programming<br>&gt;&gt;   model we have today.<br>&gt;<br>&gt; Sequence vends iterators. (a sequence is NOT a refinement of iterator,<br>&gt; it just creates them as needed)<br>&gt;<br>&gt;&gt; Perhaps the language should accept types conforming to either of two<br>&gt;&gt; unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>&gt;&gt; them, with no refinement relationship) for for-in.<br>&gt;<br>&gt; Yes.<br>&gt;<br>&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt; finite cases separately...<br>&gt;&gt; <br>&gt;&gt; The other thing I am concerned about here is that we&#39;re addressing real<br>&gt;&gt; use-cases with these distinctions.  For example, do people commonly get<br>&gt;&gt; in trouble with infinite sequences today?<br>&gt;<br>&gt; Probably not… because they avoid infinite sequences to avoid getting<br>&gt; into trouble.  I was bitten a few times early on (I assumed map was<br>&gt; lazy) and just avoided them until recently.<br>&gt;<br>&gt; I think they would be used more often if you could guarantee that<br>&gt; their use was safe (i.e. being forced to consider the infinite<br>&gt; possibility).  I would like to have a bunch of infinite sequences that<br>&gt; could easily be refined to collections.  The ones I would use most<br>&gt; often would be the natural numbers and random numbers.  Also imagine,<br>&gt; an infinite sequence of random colors which look fairly good together.<br>&gt; Markov chains, die rolls… there are a lot of potential uses that<br>&gt; become interesting once the threat of accidental infinite loop has<br>&gt; been removed...<br>&gt;<br>&gt; As a real world example of the &quot;effectively infinite” sequence, this<br>&gt; weekend I created a Swift 3 collection of repeatable random values (of<br>&gt; any type conforming to a protocol). I would have used sequence if the<br>&gt; subscript behavior was available on it, since I do intend it to be an<br>&gt; infinite sequence in most cases (Apologies for the lack of comments,<br>&gt; it is not yet prepared for public consumption):<br>&gt; https://gist.github.com/jonhull/3655672529f8cf5b2eb248583d2cafb9<br>&gt;<br>&gt; The use case here is to create a hand-drawn look for a CGPath by<br>&gt; breaking it up into pieces and then jiggling the pieces about (using<br>&gt; random CGVectors). I quickly realized that I needed a repeatable<br>&gt; source of randomness (otherwise the drawing would move each time it<br>&gt; was redrawn), and thus a multi-pass sequence.<br>&gt;<br>&gt; I am a little bit nervous every time I use this, as it has the<br>&gt; potential for an “effectively infinite” loop, but is proving useful<br>&gt; throughout my project.<br></p><p>Thanks for the example; that helps.<br></p><p>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com<br>&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; -Dave<br>&gt;<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 12:51 PM, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Mon Jun 27 2016, Jonathan Hull &lt;jhull-AT-gbis.com&gt; wrote:<br>&gt; <br>&gt;&gt; Comments inline<br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 27, 2016, at 9:39 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I should be clear up-front about the main problem I&#39;m trying to solve:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Today, people see a beautiful, simple protocol (Sequence) to which many<br>&gt;&gt;&gt; things conform. They don&#39;t recognize that there&#39;s a semantic restriction<br>&gt;&gt;&gt; (assume you can make only a single-pass!) on it, so they write libraries<br>&gt;&gt;&gt; of functions that may make multiple passes over Sequences.  They test<br>&gt;&gt;&gt; their libraries with the most commonly-available Sequences, e.g. Arrays<br>&gt;&gt;&gt; and Ranges, which happen to be multi-pass.  Their tests pass!  But their<br>&gt;&gt;&gt; constraints are wrong, their whole model of how to write generic code<br>&gt;&gt;&gt; over sequences is wrong, and some of their code is wrong.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; IMO this is a problematic programming model.<br>&gt;&gt; Agreed.<br>&gt;&gt; <br>&gt;&gt;&gt; on Sun Jun 26 2016, Jonathan Hull &lt;jhull-AT-gbis.com &lt;http://jhull-at-gbis.com/&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can’t a Sequence be potentially infinite, whereas a collection has a<br>&gt;&gt;&gt;&gt; defined count/endIndex?  Other than that, I agree with your statement.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I agree that that is currently what the documentation allows and requires.<br>&gt;&gt;&gt; Maybe we do need to separate finiteness from multipass-ness.  There&#39;s<br>&gt;&gt;&gt; certainly no reason one can&#39;t make multiple passes over a portion of an<br>&gt;&gt;&gt; infinite sequence.<br>&gt;&gt; I have a use-case for this below.  Graphical manipulation using a repeatable sequence of random numbers.<br>&gt;&gt; <br>&gt;&gt;&gt; [Just to complicate things... I wonder if finiteness is really<br>&gt;&gt;&gt; meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>&gt;&gt;&gt; it&#39;s “effectively infinite.”]<br>&gt;&gt; <br>&gt;&gt; See below… I am definitely guilty of this.  That said, if we had<br>&gt;&gt; explicit infinite sequences (with subscripts), I would use those<br>&gt;&gt; instead of collections for these use-cases.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is what I see as the appropriate structure:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Iterator: Single destructive pass, potentially infinite, (should be<br>&gt;&gt;&gt;&gt; for-in able)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; [Note: the best way to represent “single destructive pass” today is to<br>&gt;&gt;&gt; constrain Iterator to be a reference type.  Otherwise, it&#39;s both easy to<br>&gt;&gt;&gt; create an Iterator that can be used to make multiple passes (by<br>&gt;&gt;&gt; copying), and to create a truly single-pass Iterator that suggests it<br>&gt;&gt;&gt; has value semantics.  These are both potentially misleading situations]<br>&gt;&gt; <br>&gt;&gt; Hmm… This is a really good point.  I can see why you are thinking of making it a reference type.<br>&gt;&gt; <br>&gt;&gt; If a particular iterator can safely be cloned mid-stream, then it can<br>&gt;&gt; provide its own interface to allow that.  The value type makes a<br>&gt;&gt; promise which can’t always be kept.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators),<br>&gt;&gt;&gt;&gt; potentially infinite, (should be subscript-able, gain most of<br>&gt;&gt;&gt;&gt; collection, but lose anything that relies on it ending)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Collection: Multi-pass, guaranteed finite, (no changes from current<br>&gt;&gt;&gt;&gt; form, except extra inits from Iterator/Sequence with end conditions)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a reasonable structure, but there are important details missing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;&gt;  for-in-able?<br>&gt;&gt; <br>&gt;&gt; I would think the potentially infinite should require for-in-until<br>&gt;&gt; (even if you explicitly set until to false to create an infinite<br>&gt;&gt; loop), but collection would allow for-in (with optional until).  That<br>&gt;&gt; way you have to acknowledge the possibility of an infinite<br>&gt;&gt; sequence/iterator.<br>&gt; <br>&gt; Are you proposing a new language feature?  <br></p><p>That was my impression.  It’s an interesting idea.  It wouldn’t guarantee termination but would require developers to consider termination and therefore prevent accidents, which are the concerns I am raising.<br></p><p>&gt; We could also do this with<br>&gt; <br>&gt;    for i in allIntegers.until(isPrime)<br></p><p>Is `until` lazy or eager here?  I imagine you’re thinking it would be lazy because making it eager would introduce unnecessary allocation.  However, if it’s lazy it is an exception to the explicit laziness Swift has adopted.  <br></p><p>Wouldn’t it be better to require explicit laziness `allIntegers.lazy.until` if for..in is going to be require finite sequences and we’re going to use a library solution to support infinite sequences?  It’s more verbose but more consistent with how laziness is currently handled.  It also doesn’t privilege any specific operator (which isn’t necessary if we do this in the library).  <br></p><p>If we went with a language solution I imagine it would look something like this:<br></p><p>for i in allIntegers until i.isPrime &amp;&amp; i &gt; 1000 where i.isEven {<br>    // all even integers &lt; the first prime &gt; 1000<br>}<br></p><p>IIRC the `until` clause has already been discussed as syntactic sugar for early termination.  Its utility wouldn’t be limited to looping over infinite sequences, however it would be *required* when you loop over an infinite sequence.  <br></p><p>This sugar wouldn’t have to be introduced in Swift 3.  We could make for..in require finite sequences in Swift 3 and add it later if there is sufficient demand.  In the meantime people could iterate infinite sequences manually and / or we could add library support via lazy operators that select a prefix (if we are willing to live with the fact that in practice termination may depend on arguments to the operator).<br></p><p>&gt; <br>&gt;&gt;&gt; 2. Presumably Collection refines Sequence.  Does Sequence refine<br>&gt;&gt;&gt;  Iterator?  IMO that would create the same problematic programming<br>&gt;&gt;&gt;  model we have today.<br>&gt;&gt; <br>&gt;&gt; Sequence vends iterators. (a sequence is NOT a refinement of iterator,<br>&gt;&gt; it just creates them as needed)<br>&gt;&gt; <br>&gt;&gt;&gt; Perhaps the language should accept types conforming to either of two<br>&gt;&gt;&gt; unrelated protocols (your Sequence and Iterator, as you&#39;ve described<br>&gt;&gt;&gt; them, with no refinement relationship) for for-in.<br>&gt;&gt; <br>&gt;&gt; Yes.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; Right now we are allowed to have an infinite sequence, but calling<br>&gt;&gt;&gt;&gt; dropLast or non-lazy map will cause an infinite loop.  These cases<br>&gt;&gt;&gt;&gt; could be made much safer by considering the potentially infinite and<br>&gt;&gt;&gt;&gt; finite cases separately...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The other thing I am concerned about here is that we&#39;re addressing real<br>&gt;&gt;&gt; use-cases with these distinctions.  For example, do people commonly get<br>&gt;&gt;&gt; in trouble with infinite sequences today?<br>&gt;&gt; <br>&gt;&gt; Probably not… because they avoid infinite sequences to avoid getting<br>&gt;&gt; into trouble.  I was bitten a few times early on (I assumed map was<br>&gt;&gt; lazy) and just avoided them until recently.<br>&gt;&gt; <br>&gt;&gt; I think they would be used more often if you could guarantee that<br>&gt;&gt; their use was safe (i.e. being forced to consider the infinite<br>&gt;&gt; possibility).  I would like to have a bunch of infinite sequences that<br>&gt;&gt; could easily be refined to collections.  The ones I would use most<br>&gt;&gt; often would be the natural numbers and random numbers.  Also imagine,<br>&gt;&gt; an infinite sequence of random colors which look fairly good together.<br>&gt;&gt; Markov chains, die rolls… there are a lot of potential uses that<br>&gt;&gt; become interesting once the threat of accidental infinite loop has<br>&gt;&gt; been removed...<br>&gt;&gt; <br>&gt;&gt; As a real world example of the &quot;effectively infinite” sequence, this<br>&gt;&gt; weekend I created a Swift 3 collection of repeatable random values (of<br>&gt;&gt; any type conforming to a protocol). I would have used sequence if the<br>&gt;&gt; subscript behavior was available on it, since I do intend it to be an<br>&gt;&gt; infinite sequence in most cases (Apologies for the lack of comments,<br>&gt;&gt; it is not yet prepared for public consumption):<br>&gt;&gt; https://gist.github.com/jonhull/3655672529f8cf5b2eb248583d2cafb9<br>&gt;&gt; <br>&gt;&gt; The use case here is to create a hand-drawn look for a CGPath by<br>&gt;&gt; breaking it up into pieces and then jiggling the pieces about (using<br>&gt;&gt; random CGVectors). I quickly realized that I needed a repeatable<br>&gt;&gt; source of randomness (otherwise the drawing would move each time it<br>&gt;&gt; was redrawn), and thus a multi-pass sequence.<br>&gt;&gt; <br>&gt;&gt; I am a little bit nervous every time I use this, as it has the<br>&gt;&gt; potential for an “effectively infinite” loop, but is proving useful<br>&gt;&gt; throughout my project.<br>&gt; <br>&gt; Thanks for the example; that helps.<br>&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; on Wed Jun 22 2016, David Waite &lt;david-AT-alkaline-solutions.com<br>&gt;&gt;&gt;&gt;&gt; &lt;http://david-at-alkaline-solutions.com/&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jun 22, 2016, at 2:57 PM, Dave Abrahams via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;http://swift.org/&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; &lt;Ahem&gt; “Iterators,” please.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; That makes me happy - for some reason I thought it was still GeneratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; destructively, but such Generators would not conform to the needs of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Sequence. As such, the most significant impact would be the inability<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; to use such Generators in a for..in loop, <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Trying to evaluate this statement, it&#39;s clear we&#39;re missing lots of<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; detail here:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * Would you remove Sequence?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; * If so, what Protocol would embody “for...in-able?”<br>&gt;&gt;&gt;&gt;&gt;&gt; No, I would just remove the allowance in the documentation and API<br>&gt;&gt;&gt;&gt;&gt;&gt; design for a destructive/consuming iteration. Sequence would be the<br>&gt;&gt;&gt;&gt;&gt;&gt; interface to getting access to repeatable iteration, without the need<br>&gt;&gt;&gt;&gt;&gt;&gt; for meeting the other requirements for Collection.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; That would be wrong unless there exist substantial examples of a<br>&gt;&gt;&gt;&gt;&gt; multipass Sequence that *can&#39;t* meet the other requirements of<br>&gt;&gt;&gt;&gt;&gt; Collection without loss of efficiency.  And since I can write an adaptor<br>&gt;&gt;&gt;&gt;&gt; that turns any multipass sequence into a Collection, I think it&#39;s<br>&gt;&gt;&gt;&gt;&gt; trivial to prove that no such examples exist.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt;&gt; -Dave<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; -Dave<br>&gt;&gt; <br>&gt; <br>&gt; -- <br>&gt; Dave<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 28, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;&gt;&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;&gt;&gt; for-in-able?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would think the potentially infinite should require for-in-until<br>&gt;&gt;&gt; (even if you explicitly set until to false to create an infinite<br>&gt;&gt;&gt; loop), but collection would allow for-in (with optional until).  That<br>&gt;&gt;&gt; way you have to acknowledge the possibility of an infinite<br>&gt;&gt;&gt; sequence/iterator.<br>&gt;&gt; <br>&gt;&gt; Are you proposing a new language feature?  <br>&gt; <br>&gt; That was my impression.  It’s an interesting idea.  It wouldn’t guarantee termination but would require developers to consider termination and therefore prevent accidents, which are the concerns I am raising.<br></p><p>Yes, exactly.<br></p><p>&gt;&gt; We could also do this with<br>&gt;&gt; <br>&gt;&gt;   for i in allIntegers.until(isPrime)<br>&gt; <br>&gt; Is `until` lazy or eager here?  I imagine you’re thinking it would be lazy because making it eager would introduce unnecessary allocation.  However, if it’s lazy it is an exception to the explicit laziness Swift has adopted.  <br>&gt; <br>&gt; Wouldn’t it be better to require explicit laziness `allIntegers.lazy.until` if for..in is going to be require finite sequences and we’re going to use a library solution to support infinite sequences?  It’s more verbose but more consistent with how laziness is currently handled.  It also doesn’t privilege any specific operator (which isn’t necessary if we do this in the library).  <br></p><p>Everything with Iterators / Sequences should be lazy (because that is the only safe thing).  Collections would most likely still be eager.<br></p><p>In this case, ‘until&#39; is creating a collection (most likely an array), so it would be eager.  For an iterator, it would immediately drain and buffer it.  For a sequence, I guess it is whatever is most efficient.<br></p><p>&gt; If we went with a language solution I imagine it would look something like this:<br>&gt; <br>&gt; for i in allIntegers until i.isPrime &amp;&amp; i &gt; 1000 where i.isEven {<br>&gt;    // all even integers &lt; the first prime &gt; 1000<br>&gt; }<br>&gt; <br>&gt; IIRC the `until` clause has already been discussed as syntactic sugar for early termination.  Its utility wouldn’t be limited to looping over infinite sequences, however it would be *required* when you loop over an infinite sequence.  <br></p><p>Yeah, that is my thought as well.  I would also be ok with Dave’s suggestion as long as the path (compiler complain -&gt; Suggest Fix) is the same, so you still consider and deal with the infinite case.<br></p><p>I do like the look of the language feature better, of course...<br></p><p>&gt; This sugar wouldn’t have to be introduced in Swift 3.  We could make for..in require finite sequences in Swift 3 and add it later if there is sufficient demand.  In the meantime people could iterate infinite sequences manually and / or we could add library support via lazy operators that select a prefix (if we are willing to live with the fact that in practice termination may depend on arguments to the operator).<br></p><p>Ah, I just saw your point above.  allIntegers.until(isPrime) most likely needs to be eager, but that is the opposite of what we want for a for-in loop (it could have an early break), so the language feature might be quite a bit more efficient, and might actually be worthwhile (especially considering that people were already asking for it anyway).  I was indifferent to it, but I like it for this case…<br></p><p>Anyway, I am interested to see what they are cooking up for us (It may be much better than this)...<br></p><p>Thanks,<br>Jon<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/a0ae6a65/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 28, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 10:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;&gt;  for-in-able?<br>&gt;&gt; <br>&gt;&gt; I would think the potentially infinite should require for-in-until<br>&gt;&gt; (even if you explicitly set until to false to create an infinite<br>&gt;&gt; loop), but collection would allow for-in (with optional until).  That<br>&gt;&gt; way you have to acknowledge the possibility of an infinite<br>&gt;&gt; sequence/iterator.<br>&gt; <br>&gt; Are you proposing a new language feature?  We could also do this with<br>&gt; <br>&gt;    for i in allIntegers.until(isPrime)<br></p><p>I was, but I think I would be ok with this too, as long as the compiler caught the issue and suggested a fix.  The key is that we are forced to deal with the possibility of an infinite sequence/iterator.  Also:<br></p><p>for i in infSequence.maxLoops(3000)  //or a better name for this idea<br></p><p>Thanks,<br>Jon<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/ee0985fe/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>June 28, 2016 at 12:00:00pm</p></header><div class="content"><p>One more question on this.<br></p><p>How would we handle the opt-out safety for people who are intentionally trying to create an infinite loop?<br></p><p>I don’t think we can make .until() safely lazy for iterators which have reference semantics and are destructive single-pass, so it has to be eager.  If .until() is eager, then .until(false) will fall into an infinite loop before the for-in loop is even run.  <br></p><p>Maybe there just a way to plug an iterator/sequence directly in, and then silence the warning?  or we could do for-in-until...<br></p><p>Thanks,<br>Jon<br></p><p>&gt; On Jun 28, 2016, at 10:51 AM, Dave Abrahams &lt;dabrahams at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a reasonable structure, but there are important details missing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;&gt;  for-in-able?<br>&gt;&gt; <br>&gt;&gt; I would think the potentially infinite should require for-in-until<br>&gt;&gt; (even if you explicitly set until to false to create an infinite<br>&gt;&gt; loop), but collection would allow for-in (with optional until).  That<br>&gt;&gt; way you have to acknowledge the possibility of an infinite<br>&gt;&gt; sequence/iterator.<br>&gt; <br>&gt; Are you proposing a new language feature?  We could also do this with<br>&gt; <br>&gt;    for i in allIntegers.until(isPrime)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/dbc4bb79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>June 28, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On Jun 28, 2016, at 2:18 PM, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; One more question on this.<br>&gt; <br>&gt; How would we handle the opt-out safety for people who are intentionally trying to create an infinite loop?<br>&gt; <br>&gt; I don’t think we can make .until() safely lazy for iterators which have reference semantics and are destructive single-pass, so it has to be eager.  <br>&gt; If .until() is eager, then .until(false) will fall into an infinite loop before the for-in loop is even run.  <br></p><p>This is an argument against a library solution if iterators have reference semantics.  Any solution that requires eager behavior is not a good solution.<br></p><p>&gt; <br>&gt; Maybe there just a way to plug an iterator/sequence directly in, and then silence the warning?  or we could do for-in-until…<br> <br>I don’t think this should be a warning that can be silenced.  I think you are uncovering good reasons to go with a language supported solution.<br></p><p>This wouldn’t need to happen in Swift 3.  There have been other cases where we have adopted a “break it now in anticipation of making it better in the future” policy.  If we conclude that a language solution is warranted and can’t get it into Swift 3 that is ok IMO.  It is still possible to manually iterate infinite sequences.  This wouldn’t be that big a deal given that it is relatively infrequent.<br></p><p>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt;&gt; On Jun 28, 2016, at 10:51 AM, Dave Abrahams &lt;dabrahams at apple.com &lt;mailto:dabrahams at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a reasonable structure, but there are important details missing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 1. Presumably these are all for-in-able.  What makes something<br>&gt;&gt;&gt;&gt;  for-in-able?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would think the potentially infinite should require for-in-until<br>&gt;&gt;&gt; (even if you explicitly set until to false to create an infinite<br>&gt;&gt;&gt; loop), but collection would allow for-in (with optional until).  That<br>&gt;&gt;&gt; way you have to acknowledge the possibility of an infinite<br>&gt;&gt;&gt; sequence/iterator.<br>&gt;&gt; <br>&gt;&gt; Are you proposing a new language feature?  We could also do this with<br>&gt;&gt; <br>&gt;&gt;    for i in allIntegers.until(isPrime)<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160628/f3fd751a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; [Just to complicate things... I wonder if finiteness is really<br>&gt; meaningful.  It&#39;s easy to create a finite sequence that&#39;s so long that<br>&gt; it&#39;s “effectively infinite.”]<br></p><p>And similarly, operations like `first(while:)` on an infinite sequence might or might not produce an infinite sequence, depending on properties of the sequence and predicate which aren&#39;t expressed in the type system.<br></p><p>I think there are really three cases:<br></p><p>* Known finite<br>* Known infinite<br>* Unknown<br></p><p>The most obvious way to model this is as two subtypes:<br></p><p>		Possibly infinite<br>		/			\<br>	Infinite		Not infinite<br></p><p>A known-infinite iterator might refine unknown-infinite iterators like this:<br></p><p>	protocol InfiniteIteratorProtocol: IteratorProtocol {<br>		mutating func next() -&gt; Element	// Note that the return is non-Optional!<br>	}<br>	<br>	extension InfiniteIteratorProtocol {<br>		mutating func next() -&gt; Self.Element? { return .some(next()) }<br>	} <br></p><p>Refining unknown-infinite collections to provide known-infinite collections is trickier. I think we would want something like this:<br></p><p>	// We don&#39;t use Optional because its Comparable conformance puts `.none` <br>	// before, not after, `.some`.<br>	enum InfiniteCollectionIndex&lt;ConcreteIndex: Comparable&gt;: Comparable {<br>		case .element (ConcreteIndex)<br>		case .end<br>		<br>		var concreteIndex: ConcreteIndex {<br>			get {<br>				switch self {<br>				case .element(let i):<br>					return i<br>				case .end:<br>					preconditionFailure(&quot;Attempted to access the end of an infinite collection&quot;)<br>				}<br>			}<br>			set {<br>				self = .element(newValue)<br>			}<br>		}<br>	}<br>	func &lt; &lt;ConcreteIndex: Comparable&gt;(lhs: InfiniteCollectionIndex&lt;ConcreteIndex&gt;, rhs: InfiniteCollectionIndex&lt;ConcreteIndex&gt;) -&gt; Bool {<br>		switch (lhs, rhs) {<br>		case let (.element(lhsIndex), .element(rhsIndex)):<br>			return lhsIndex &lt; rhsIndex<br>		case (.element, .end):<br>			return true<br>		default:<br>			return false<br>		}<br>	}<br>	<br>	extension IndexingIterator: InfiniteIteratorProtocol where Elements: InfiniteCollection {}<br>		<br>	protocol InfiniteCollection: Collection where Index == InfiniteCollectionIndex&lt;ConcreteIndex&gt;, Iterator: InfiniteIteratorProtocol {<br>		typealias ConcreteIndex: Comparable<br>		<br>		var startConcreteIndex: ConcreteIndex { get }<br>		func index(after i: ConcreteIndex) -&gt; ConcreteIndex<br>		func formIndex(after i: inout ConcreteIndex)<br>		<br>		subscript(i: ConcreteIndex) { get }<br>	}<br>	extension InfiniteCollection {<br>		var startIndex: InfiniteCollectionIndex&lt;ConcreteIndex&gt; {<br>			return .element(startConcreteIndex)<br>		}<br>		var endIndex: InfiniteCollectionIndex&lt;ConcreteIndex&gt; {<br>			return .end<br>		}<br>		func index(after i: InfiniteCollectionIndex&lt;ConcreteIndex&gt;) -&gt; InfiniteCollectionIndex&lt;ConcreteIndex&gt; {<br>			return .element(index(after: i.concreteIndex))<br>		}<br>		func formIndex(after i: inout InfiniteCollectionIndex&lt;ConcreteIndex&gt;) {<br>			formIndex(after: &amp;i.concreteIndex)<br>		}<br>		subscript(i: InfiniteCollectionIndex&lt;ConcreteIndex&gt;) {<br>			return self[i.concreteIndex]<br>		}<br>	}<br>	// With corresponding InfiniteBidirectionalCollection and InfiniteRandomAccessCollection types<br></p><p>But the problem with this is, for all its complications, it probably doesn&#39;t actually provide much additional safety. &quot;Possibly infinite&quot; needs to have all the operations we ought to forbid on an infinite sequence or collection. All the &quot;infinite&quot; type can really do is provide runtime implementations that crash immediately; the type system can&#39;t prevent it.<br></p><p>The alternative is to have some kind of wrapper type you put around &quot;possibly infinite&quot; sequences/collections to essentially assert they&#39;re finite:<br></p><p>	// Forbidden:<br>	infiniteSequence.prefix(while: { $0 &lt; 100 }).map { … }<br>	// Instead, write:<br>	infiniteSequence.prefix(while: { $0 &lt; 100 }).assumingFinite.map { … }<br></p><p>But that once again brings us to the question: How important *is* it that we prevent greedy calls on known-infinite sequences? There aren&#39;t actually any known-infinite sequences in the standard library; even the `sequence` function can be terminated by returning `nil`. Known-infinite sequences are certainly a coherent concept, but are they something we need to model? And if not, is requiring people to say `assumingFinite` on calls where, as far as the type system is concerned, there *is* a possibility of a `nil` return really worth it?<br></p><p>(It *is* kind of a shame that we didn&#39;t keep lazy-by-default `map` and `filter`, because the lazy algorithms are usable on infinite sequences. But I understand why that wasn&#39;t possible.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Pitch] Remove destructive consumption from Sequence</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 27, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 04:56, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Can’t a Sequence be potentially infinite, whereas a collection has a defined count/endIndex?  Other than that, I agree with your statement.<br>&gt; <br>&gt; Here is what I see as the appropriate structure:<br>&gt; <br>&gt; Iterator: Single destructive pass, potentially infinite, (should be for-in able)<br>&gt; Sequence: Guaranteed non-destructive multi-pass (vends Iterators), potentially infinite, (should be subscript-able, gain most of collection, but lose anything that relies on it ending)<br>&gt; Collection: Multi-pass, guaranteed finite, (no changes from current form, except extra inits from Iterator/Sequence with end conditions)<br>&gt; <br>&gt; Right now we are allowed to have an infinite sequence, but calling dropLast or non-lazy map will cause an infinite loop.  These cases could be made much safer by considering the potentially infinite and finite cases separately...<br></p><p>This seems pretty reasonable to me, though I&#39;m not sure about subscripting Sequence, I mean you can always add that yourself to sequence types where it makes sense to them that way, but otherwise I think it&#39;s best to just keep it simple and leave Sequences as a type that vends iterators over the same values.<br></p><p>Some methods of sequence may need to be moved to iterators though, but in mutating form; things like .dropFirst() to skip elements, .first(where:) for skipping to a matching element and so-on. Iterator should probably also have the .underestimatedCount property so they can give a useful value if it can be known.<br></p><p>But yeah, I think the basic structure of this makes sense, as the potentially destructive nature of sequences doesn&#39;t seem that well known in my experience, and I often have to go back and check my code to be sure I&#39;ve avoid possible destructive usage; I&#39;ve never thought of trying to use iterators instead, might try changing some methods and see how that goes.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/fe29cc48/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
