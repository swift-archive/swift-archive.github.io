<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July  6, 2016 at 06:00:00pm</p></header><div class="content"><p>on Wed Jul 06 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On 6 Jul 2016, at 03:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; For example, with<br>&gt;&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt;&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt;&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt;<br>&gt; I think the question is why you need to retain indices in these cases?<br>&gt;<br>&gt; When it comes to these operations I wonder if we might want to<br>&gt; investigate something like a mutating iterator; you might still use an<br>&gt; index to jump to an initial position, but then use .insert(),<br>&gt; .remove() etc. methods of the iterator to perform modification without<br>&gt; the need to track indices at all. <br></p><p>There is no way, AFAIK, to implement important algorithms like rotate<br>binarySearch and several others, without having some representation of<br>position within a collection.<br></p><p>&gt; This is essentially how you want to edit trees anyway, as indexing<br>&gt; them isn&#39;t especially pretty, as it avoids the need to track the<br>&gt; indices at all for these operations, and many common cases should work<br>&gt; well when done as part of an iterator in this way.<br></p><p>I don&#39;t know what you mean by “track,” here.  We don&#39;t track the<br>indices of an array.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>July  6, 2016 at 11:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 20:41, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is no way, AFAIK, to implement important algorithms like rotate<br>&gt; binarySearch and several others, without having some representation of<br>&gt; position within a collection.<br></p><p>Do you need indices to be explicitly comparable for that, or will simply being able to test for equality and being within a &quot;range&quot; work? I realize that in most cases, testing an index for being in a range implies comparable, but what about multi-dimensional indices? Comparison isn&#39;t well defined for, say, 2D points, but in theory all the points within a circle or something  could be the indices for something.<br></p><p>- Dave Sweeris<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Dropping Comparable requirement for indices</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>July  7, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On 7 Jul 2016, at 02:41, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; on Wed Jul 06 2016, Haravikk &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; On 6 Jul 2016, at 03:39, Dave Abrahams via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; For example, with<br>&gt;&gt;&gt; Comparable indices, you can&#39;t build a linked list that supports<br>&gt;&gt;&gt; restructuring (e.g. insert, delete, splice) in O(1) without invalidating<br>&gt;&gt;&gt; indices... not even an unsafe linked list with reference semantics.<br>&gt;&gt; <br>&gt;&gt; I think the question is why you need to retain indices in these cases?<br>&gt;&gt; <br>&gt;&gt; When it comes to these operations I wonder if we might want to<br>&gt;&gt; investigate something like a mutating iterator; you might still use an<br>&gt;&gt; index to jump to an initial position, but then use .insert(),<br>&gt;&gt; .remove() etc. methods of the iterator to perform modification without<br>&gt;&gt; the need to track indices at all. <br>&gt; <br>&gt; There is no way, AFAIK, to implement important algorithms like rotate<br>&gt; binarySearch and several others, without having some representation of<br>&gt; position within a collection.<br>&gt; <br>&gt;&gt; This is essentially how you want to edit trees anyway, as indexing<br>&gt;&gt; them isn&#39;t especially pretty, as it avoids the need to track the<br>&gt;&gt; indices at all for these operations, and many common cases should work<br>&gt;&gt; well when done as part of an iterator in this way.<br>&gt; <br>&gt; I don&#39;t know what you mean by “track,” here.  We don&#39;t track the<br>&gt; indices of an array.<br></p><p>By track I just mean store in a variable.<br></p><p>As an example, consider removing multiple values using a closure:<br></p><p>	let delete:(Int) -&gt; Bool = { ($0 % 2) == 1 } // Delete all odd numbers<br>	let filtered = myArray.filter { !delete($0) } // Produces new copy of array with elements filtered<br></p><p>	// In-place removal<br>	var index = myArray.startIndex, indices:[Array&lt;Int&gt;.Index] = []<br>	for eachElement in myArray {<br>		if delete(eachElement) { indices.append(index) }<br>		myArray.formIndex(after: &amp;index)<br>	}<br>	for eachIndex in indices { myArray.remove(at: eachIndex }<br></p><p>The latter case only works with types where you know that there&#39;s a safe way to use the indices (removing in reverse order doesn&#39;t invalidate earlier indices of Array) so it&#39;s not suitable for generic collections. Since it requires iterating myArray anyway, then if the removals could be performed at the same time it would eliminate the need to store and then use indices at all, and would be a much better way to work with linked-lists, trees and so-on. So with a mutable iterator for example the in-place removal would look like:<br></p><p>	var iterator = myArray.makeMutatingIterator()<br>	while let eachElement = iterator.next() {<br>		if delete(eachElement) { iterator.remove() }<br>	}<br></p><p>Maybe this isn&#39;t directly applicable to this topic, but this for example seems like a better solution to the linked list problems raised than removing Comparable as a requirement which was my intended point, that perhaps this isn&#39;t necessary?<br></p><p>Otherwise I think the main issue with types that don&#39;t seem like they can implement Comparable is that they need a means of detecting that they&#39;ve been invalidated; arguably a singly-linked list&#39;s indices should become unusable if it has been changed, which could be done for example by giving the list a mutationCount value that is incremented each time it is mutated; indices would take a copy of this value and if they don&#39;t match, they produce a runtime error. Like so (heavily abridged):<br></p><p>	struct LinkedListIndex&lt;Element&gt; : Comparable {<br>		let mutationCount:Int<br>		var position:Int, node:LinkedListNode&lt;Element&gt;<br>	}<br>	func == &lt;E&gt;(lhs:LinkedListIndex&lt;E&gt;, rhs:LinkedListIndex&lt;E&gt;) { return lhs.position == rhs.position }<br>	func &lt; &lt;E&gt;(lhs:LinkedListIndex&lt;E&gt;, rhs:LinkedListIndex&lt;E&gt;) { return lhs.position &lt; rhs.position }<br></p><p>	class LinkedListNode&lt;Element&gt; {<br>		var element:Element, next:LinkedListNode&lt;Element&gt;?<br>		init(_ element:Element) { self.element = element }<br>	}<br></p><p>	struct LinkedList&lt;Element&gt; : Indexable {<br>		var mutationCount:Int = 0, head:LinkedListNode&lt;Element&gt;?, tail:LinkedListNode&lt;Element&gt;?<br></p><p>		typealias Index = LinkedListIndex<br>		var startIndex:Index { return LinkedListIndex(mutationCount: self.mutationCount, position: 0) }<br>		func formIndex(after i:inout Index) {<br>			precondition(i.mutationCount == self.mutationCount, &quot;Invalid index&quot;)<br>			i.position += 1<br>			i.node = i.node?.next<br>		}<br>		func index(after i:Index) -&gt; Index { var i = i; self.formIndex(after: &amp;i); return i }<br>		subscript(i:Index) -&gt; Element {<br>			precondition(i.mutationCount == self.mutationCount, &quot;Invalid index&quot;)<br>			return i.node!.element<br>		}<br></p><p>		mutating func append(_ element:Element) {<br>			let node = LinkedListNode(element)<br>			if self.tail == nil { self.head = node; self.tail = node }<br>			else { self.tail.next = node; self.tail = node }<br>			self.mutationCount = self.mutationCount &amp;+ 1<br>		}<br>	}<br></p><p>Please forgive typos/omissions, tried to keep it as short as possible. But yeah, this is essentially how I&#39;d try to implement a linked list, while retaining the Comparable constraint.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/e1b9f03f/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
