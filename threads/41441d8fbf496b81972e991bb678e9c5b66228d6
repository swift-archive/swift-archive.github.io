<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c23a24dd9f358575e9764f1a535e2ce0?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Mike Ferenduros</string> &lt;mike.ferenduros at gmail.com&gt;<p>August 20, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; &gt; On Aug 18, 2016, at 12:28 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote: <br>&gt; &gt; <br>&gt; &gt; <br>&gt; &gt; On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote: <br>&gt; &gt; <br>&gt; &gt;&gt; - Are both solutions correct, should one be preferred, or are both wrong? <br>&gt; &gt; <br>&gt; &gt; Your `withMemoryRebound` solution is correct. <br>&gt; Absolutely, withMemoryRebound is always safe. You can use it whenever you just need to reinterpret memory at a call site and know the number of values stored that memory location. In this case it’s “easy&quot; because you’re dealing a single sockaddr_in. The UnsafeRawPointer proposal is the definitive reference <br>&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt; But this migration guide is more approachable… it’s still WIP: <br>&gt; https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585<br></p><p>I’m running into the same issues, which is making me wonder withMemoryRebound - socket functions expect an UnsafePointer&lt;sockaddr&gt;, but the thing pointed to can actually be larger than a sockaddr (eg. sockaddr_in6 or sockaddr_storage). Is withMemoryRebound safe to use to cast pointers to differently-sized structures? In the case of UnsafeMutablePointer&lt;sockaddr&gt; it seems like you’re lying to the API about what memory may be modified… But if withMemoryRebound isn’t about providing that guarantee, what does it actually do vs eg. a dumb cast via OpaquePointer?<br></p><p><br>&gt; &gt;&gt; - Can the same be achieved simpler? <br>&gt; &gt; <br>&gt; &gt; Not without introducing a layer of abstraction. <br>&gt; &gt; <br>&gt; &gt; In my case I introduced an abstract `Address` type (basically a wrapper around `sockaddr_storage`) and then added a method to that object which calls a closure with the right parameters (actually, multiple such methods, depending on whether I’m calling something like `connect` which takes an address, or `getpeername`, which returns one). This approach concentrates all the ugly in one place, making the rest of my BSD Sockets code much cleaner. <br>&gt; This is an annoying UpdatePointer migration case because it falls under the category of misbehaving C APIs that we deliberately don&#39;t want to encourage in Swift. The only good answer is to provide a Swift wrapper on top of the socket API as Quinn has done. It would be nice to post that code at some point so users of the socket API can copy-paste into their project. -Andy<br></p><p>I do something similar in a sockaddr_in6 extension here, but it’s not great code at this point and not suggested for use: https://github.com/mike-ferenduros/SwiftySockets<br></p><p><br>PS: Apologies for the broken reply-chain, I just subscribed to the list and I missed the mail I’m replying to.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 19, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Aug 19, 2016, at 4:49 PM, Michael Ferenduros via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt;&gt; On Aug 18, 2016, at 12:28 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org&gt; wrote: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - Are both solutions correct, should one be preferred, or are both wrong? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your `withMemoryRebound` solution is correct. <br>&gt;&gt; Absolutely, withMemoryRebound is always safe. You can use it whenever you just need to reinterpret memory at a call site and know the number of values stored that memory location. In this case it’s “easy&quot; because you’re dealing a single sockaddr_in. The UnsafeRawPointer proposal is the definitive reference <br>&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt; But this migration guide is more approachable… it’s still WIP: <br>&gt;&gt; https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585<br>&gt; <br>&gt; I’m running into the same issues, which is making me wonder withMemoryRebound - socket functions expect an UnsafePointer&lt;sockaddr&gt;, but the thing pointed to can actually be larger than a sockaddr (eg. sockaddr_in6 or sockaddr_storage). Is withMemoryRebound safe to use to cast pointers to differently-sized structures? In the case of UnsafeMutablePointer&lt;sockaddr&gt; it seems like you’re lying to the API about what memory may be modified… But if withMemoryRebound isn’t about providing that guarantee, what does it actually do vs eg. a dumb cast via OpaquePointer?<br></p><p>Good point. I replied too hastily, but you’re about to find out why I didn’t go into details…<br></p><p>As you can see &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/UnsafePointer.swift.gyb#L371&gt;, withMemoryRebound(to: T.self, capacity: count) actually does this:<br>- (re)binds memory to `count` `T` values<br>- executes the closure<br>- (re)binds memory to `count` `Pointee` values<br></p><p>For `count == 1` and `MemoryLayout&lt;T&gt;.size &lt; MemoryLayout&lt;Pointee&gt;.size` this is valid and safe for &quot;compatible&quot; structs. The precondition on `withMemoryRebound` states that `T` must be layout compatible with `Pointee`.<br>  <br>  aggregates (tuples, array storage, and structs), are layout<br>  compatible with larger aggregates of the same kind if their common<br>  elements are mutually layout compatible.<br></p><p>I should really update withMemoryRebound&#39;s precondition to read:<br></p><p>  If `count == 1` then `T` must be layout compatible with<br>  `Pointee`. If `count &gt; 1`, then `T` must be mutually layout<br>  compatible with `Pointee`.<br></p><p>You may be wondering why it&#39;s necessary to bind and rebind memory if the structures are &quot;compatible&quot;. In general, you could have Swift code inside the closure that accesses `sockaddr` and swift code outside that accesses `sockaddr_in6`. We don&#39;t have a formal rule that says those two types are &quot;related&quot;, so that could be miscompiled. &quot;Related&quot; is a type system concept that has to do with child/subclass relationships, &quot;compatible&quot; is an ABI concept that has to do with in-memory representation of types.<br></p><p>That&#39;s the theory. But in practice, the optimizer is going to have to treat sockaddr and sockaddr_in6 as related types simply because they are both imported from C and are allowed to alias in C land. In fact, if they were defined in Swift they wouldn&#39;t even be compatible because their overlapping members are not mutually compatible.<br></p><p>Even if one of the types were not imported, an opaque pointer cast would still work in this particular case because Swift code is never actually dereferencing the sockaddr pointer. It&#39;s just being passed off to an external C API.<br></p><p>So, the only real reason not to use an opaque pointer cast in this case is that someone reading your code likely won&#39;t understand what makes it valid and why they can&#39;t do the same thing in their code.<br></p><p>Now, what about Martin&#39;s first version:<br></p><p>  UnsafeRawPointer($0).assumingMemoryBound(to: sockaddr_in.self)<br></p><p>The code that this generates is just as safe or unsafe as your opaque pointer cast except that you&#39;re now making an untrue assertion about the memory type (per the precondition on the assumingMemoryBound API &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/UnsafeRawPointer.swift.gyb#L187&gt;). A code verification tool--like a hypothetcial pointer sanitizer--could call you out on this.<br></p><p>&gt;&gt;&gt;&gt; - Can the same be achieved simpler? <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Not without introducing a layer of abstraction. <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my case I introduced an abstract `Address` type (basically a wrapper around `sockaddr_storage`) and then added a method to that object which calls a closure with the right parameters (actually, multiple such methods, depending on whether I’m calling something like `connect` which takes an address, or `getpeername`, which returns one). This approach concentrates all the ugly in one place, making the rest of my BSD Sockets code much cleaner. <br>&gt;&gt; This is an annoying UpdatePointer migration case because it falls under the category of misbehaving C APIs that we deliberately don&#39;t want to encourage in Swift. The only good answer is to provide a Swift wrapper on top of the socket API as Quinn has done. It would be nice to post that code at some point so users of the socket API can copy-paste into their project. -Andy<br>&gt; <br>&gt; I do something similar in a sockaddr_in6 extension here, but it’s not great code at this point and not suggested for use: https://github.com/mike-ferenduros/SwiftySockets &lt;https://github.com/mike-ferenduros/SwiftySockets&gt;<br></p><p>That&#39;s a start. And another great example of why we need UnsafeBytes!<br></p><p>-Andy<br></p><p>&gt; PS: Apologies for the broken reply-chain, I just subscribed to the list and I missed the mail I’m replying to.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160819/cfd266af/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c23a24dd9f358575e9764f1a535e2ce0?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Mike Ferenduros</string> &lt;mike.ferenduros at gmail.com&gt;<p>August 20, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On 20 Aug 2016, at 07:25, Andrew Trick &lt;atrick at apple.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Aug 19, 2016, at 4:49 PM, Michael Ferenduros via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On Aug 18, 2016, at 12:28 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org &lt;http://swift.org/&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org &lt;http://swift.org/&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - Are both solutions correct, should one be preferred, or are both wrong? <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your `withMemoryRebound` solution is correct. <br>&gt;&gt;&gt; Absolutely, withMemoryRebound is always safe. You can use it whenever you just need to reinterpret memory at a call site and know the number of values stored that memory location. In this case it’s “easy&quot; because you’re dealing a single sockaddr_in. The UnsafeRawPointer proposal is the definitive reference <br>&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;&gt; But this migration guide is more approachable… it’s still WIP: <br>&gt;&gt;&gt; https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585 &lt;https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585&gt;<br>&gt;&gt; <br>&gt;&gt; I’m running into the same issues, which is making me wonder withMemoryRebound - socket functions expect an UnsafePointer&lt;sockaddr&gt;, but the thing pointed to can actually be larger than a sockaddr (eg. sockaddr_in6 or sockaddr_storage). Is withMemoryRebound safe to use to cast pointers to differently-sized structures? In the case of UnsafeMutablePointer&lt;sockaddr&gt; it seems like you’re lying to the API about what memory may be modified… But if withMemoryRebound isn’t about providing that guarantee, what does it actually do vs eg. a dumb cast via OpaquePointer?<br>&gt; <br>&gt; Good point. I replied too hastily, but you’re about to find out why I didn’t go into details…<br>&gt; <br>&gt; As you can see &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/UnsafePointer.swift.gyb#L371&gt;, withMemoryRebound(to: T.self, capacity: count) actually does this:<br>&gt; - (re)binds memory to `count` `T` values<br>&gt; - executes the closure<br>&gt; - (re)binds memory to `count` `Pointee` values<br>&gt; <br>&gt; For `count == 1` and `MemoryLayout&lt;T&gt;.size &lt; MemoryLayout&lt;Pointee&gt;.size` this is valid and safe for &quot;compatible&quot; structs. The precondition on `withMemoryRebound` states that `T` must be layout compatible with `Pointee`.<br>&gt;   <br>&gt;   aggregates (tuples, array storage, and structs), are layout<br>&gt;   compatible with larger aggregates of the same kind if their common<br>&gt;   elements are mutually layout compatible.<br>&gt; <br>&gt; I should really update withMemoryRebound&#39;s precondition to read:<br>&gt; <br>&gt;   If `count == 1` then `T` must be layout compatible with<br>&gt;   `Pointee`. If `count &gt; 1`, then `T` must be mutually layout<br>&gt;   compatible with `Pointee`.<br>&gt; <br>&gt; You may be wondering why it&#39;s necessary to bind and rebind memory if the structures are &quot;compatible&quot;. In general, you could have Swift code inside the closure that accesses `sockaddr` and swift code outside that accesses `sockaddr_in6`. We don&#39;t have a formal rule that says those two types are &quot;related&quot;, so that could be miscompiled. &quot;Related&quot; is a type system concept that has to do with child/subclass relationships, &quot;compatible&quot; is an ABI concept that has to do with in-memory representation of types.<br>&gt; <br>&gt; That&#39;s the theory. But in practice, the optimizer is going to have to treat sockaddr and sockaddr_in6 as related types simply because they are both imported from C and are allowed to alias in C land. In fact, if they were defined in Swift they wouldn&#39;t even be compatible because their overlapping members are not mutually compatible.<br>&gt; <br>&gt; Even if one of the types were not imported, an opaque pointer cast would still work in this particular case because Swift code is never actually dereferencing the sockaddr pointer. It&#39;s just being passed off to an external C API.<br>&gt; <br>&gt; So, the only real reason not to use an opaque pointer cast in this case is that someone reading your code likely won&#39;t understand what makes it valid and why they can&#39;t do the same thing in their code.<br></p><p>Excellent, thanks for the explanation.<br></p><p>I just realised I was somehow misreading ‘rebound’ to imply something trampoline-like which made worry about copying / indirection :)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160820/1fca9f84/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6fe87aed0d64cdbc46378bf7596a7553?s=50"></div><header><strong>Pointer conversions between different sockaddr types</strong> from <string>Andrew Trick</string> &lt;atrick at apple.com&gt;<p>August 20, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Aug 20, 2016, at 4:02 AM, Michael Ferenduros via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On 20 Aug 2016, at 07:25, Andrew Trick &lt;atrick at apple.com &lt;mailto:atrick at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Aug 19, 2016, at 4:49 PM, Michael Ferenduros via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Aug 18, 2016, at 12:28 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org &lt;http://swift.org/&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 17 Aug 2016, at 18:55, Martin R via swift-users &lt;swift-users at swift.org &lt;http://swift.org/&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; - Are both solutions correct, should one be preferred, or are both wrong? <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Your `withMemoryRebound` solution is correct. <br>&gt;&gt;&gt;&gt; Absolutely, withMemoryRebound is always safe. You can use it whenever you just need to reinterpret memory at a call site and know the number of values stored that memory location. In this case it’s “easy&quot; because you’re dealing a single sockaddr_in. The UnsafeRawPointer proposal is the definitive reference <br>&gt;&gt;&gt;&gt; https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt; &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md&gt;&gt; But this migration guide is more approachable… it’s still WIP: <br>&gt;&gt;&gt;&gt; https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585 &lt;https://gist.github.com/atrick/0283ae0e284610fd21ad6ed3f454a585&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I’m running into the same issues, which is making me wonder withMemoryRebound - socket functions expect an UnsafePointer&lt;sockaddr&gt;, but the thing pointed to can actually be larger than a sockaddr (eg. sockaddr_in6 or sockaddr_storage). Is withMemoryRebound safe to use to cast pointers to differently-sized structures? In the case of UnsafeMutablePointer&lt;sockaddr&gt; it seems like you’re lying to the API about what memory may be modified… But if withMemoryRebound isn’t about providing that guarantee, what does it actually do vs eg. a dumb cast via OpaquePointer?<br>&gt;&gt; <br>&gt;&gt; Good point. I replied too hastily, but you’re about to find out why I didn’t go into details…<br>&gt;&gt; <br>&gt;&gt; As you can see &lt;https://github.com/apple/swift/blob/master/stdlib/public/core/UnsafePointer.swift.gyb#L371&gt;, withMemoryRebound(to: T.self, capacity: count) actually does this:<br>&gt;&gt; - (re)binds memory to `count` `T` values<br>&gt;&gt; - executes the closure<br>&gt;&gt; - (re)binds memory to `count` `Pointee` values<br>&gt;&gt; <br>&gt;&gt; For `count == 1` and `MemoryLayout&lt;T&gt;.size &lt; MemoryLayout&lt;Pointee&gt;.size` this is valid and safe for &quot;compatible&quot; structs. The precondition on `withMemoryRebound` states that `T` must be layout compatible with `Pointee`.<br>&gt;&gt;   <br>&gt;&gt;   aggregates (tuples, array storage, and structs), are layout<br>&gt;&gt;   compatible with larger aggregates of the same kind if their common<br>&gt;&gt;   elements are mutually layout compatible.<br>&gt;&gt; <br>&gt;&gt; I should really update withMemoryRebound&#39;s precondition to read:<br>&gt;&gt; <br>&gt;&gt;   If `count == 1` then `T` must be layout compatible with<br>&gt;&gt;   `Pointee`. If `count &gt; 1`, then `T` must be mutually layout<br>&gt;&gt;   compatible with `Pointee`.<br>&gt;&gt; <br>&gt;&gt; You may be wondering why it&#39;s necessary to bind and rebind memory if the structures are &quot;compatible&quot;. In general, you could have Swift code inside the closure that accesses `sockaddr` and swift code outside that accesses `sockaddr_in6`. We don&#39;t have a formal rule that says those two types are &quot;related&quot;, so that could be miscompiled. &quot;Related&quot; is a type system concept that has to do with child/subclass relationships, &quot;compatible&quot; is an ABI concept that has to do with in-memory representation of types.<br>&gt;&gt; <br>&gt;&gt; That&#39;s the theory. But in practice, the optimizer is going to have to treat sockaddr and sockaddr_in6 as related types simply because they are both imported from C and are allowed to alias in C land. In fact, if they were defined in Swift they wouldn&#39;t even be compatible because their overlapping members are not mutually compatible.<br>&gt;&gt; <br>&gt;&gt; Even if one of the types were not imported, an opaque pointer cast would still work in this particular case because Swift code is never actually dereferencing the sockaddr pointer. It&#39;s just being passed off to an external C API.<br>&gt;&gt; <br>&gt;&gt; So, the only real reason not to use an opaque pointer cast in this case is that someone reading your code likely won&#39;t understand what makes it valid and why they can&#39;t do the same thing in their code.<br>&gt; <br>&gt; Excellent, thanks for the explanation.<br>&gt; <br>&gt; I just realised I was somehow misreading ‘rebound’ to imply something trampoline-like which made worry about copying / indirection :)<br></p><p>&lt;groan&gt; The whole point of that method was to avoid punning!<br></p><p>-Andy<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160820/c6b1a0a6/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
