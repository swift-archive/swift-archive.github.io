<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ca58147038d0210e502aa8dd9e2bc5ce?s=50"></div><header><strong>Using ... as a concrete type conforming to protocol ... is not supported</strong> from <string>Jason Sadler</string> &lt;jason.sadler at gmail.com&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>I think Simon was referring to two separate problems in his post - first:<br></p><p>&gt; Using ‘KeyType&#39; as a concrete type conforming to protocol &#39;Hashable&#39; is not supported<br></p><p>And second:<br></p><p>&gt; type &#39;Key&#39; constrained to non-protocol type ‘String’<br></p><p>The first error (which is of particular interest to me) you can reproduce with only the first half, leaving out MyProtocol entirely:<br></p><p>public protocol KeyType : Hashable {<br>    <br>}<br></p><p>public protocol ValueType {<br>    <br>}<br></p><p>struct MyConcrete {<br>    let values : [KeyType: ValueType]<br>}<br></p><p>I’m fairly new to Swift, and this is my very first time on the mailing lists, so forgive me if this has been answered before…but this seems to me like an arbitrary shortcoming of the compiler and not an intentional language design decision. (As I understand, this comes out of the fact that protocols don’t conform to themselves…?)<br></p><p>I wonder if anyone knows whether there are any plans to look at this corner of the language and allow this use case.<br></p><p>(My particular use case can be seen here: https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400 … and the best information I’ve been able to find on this so far is here: http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927)<br></p><p>Thanks<br>Jason<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Using ... as a concrete type conforming to protocol ... is not supported</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On Mar 25, 2016, at 2:51 PM, Jason Sadler via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; (My particular use case can be seen here: https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400 &lt;https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400&gt; … and the best information I’ve been able to find on this so far is here: http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927 &lt;http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927&gt;)<br></p><p>Here is the best you can do for your particular use case:<br></p><p>protocol AnyEquatable { func equals(other: Any) -&gt; Bool }<br></p><p>func ==&lt;T: Equatable&gt;(lhs: T, rhs: Any) -&gt; Bool {<br>    <br>    if let rhs = rhs as? T { return lhs == rhs } else { return false }<br>}<br></p><p>extension Bool:   AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br></p><p>extension Int:    AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br></p><p>extension Double: AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br></p><p>extension String: AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br></p><p>extension Array {<br>    <br>    func indexOfAny(element : AnyEquatable) -&gt; Index? { return indexOf { element.equals($0) } }<br>}<br></p><p>var array: [Any] = [false, 1, 2.0, &quot;three&quot;]<br></p><p>array.indexOfAny(2.0)<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160325/f2f37e93/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Using ... as a concrete type conforming to protocol ... is not supported</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>March 25, 2016 at 05:00:00pm</p></header><div class="content"><p>You can also get a heterogenous dictionary, but it needs a type erasing helper box. With the following declarations:<br></p><p>public func ==&lt;T: Equatable&gt;(lhs: T, rhs: Any) -&gt; Bool {<br>    <br>    if let rhs = rhs as? T { return lhs == rhs } else { return false }<br>}<br></p><p>public struct AnyKey : Hashable {<br>    <br>    public let hashValue: Int<br>    public let key: Any<br>    public let equals: (AnyKey) -&gt; Bool<br>    <br>    init&lt;T: Hashable&gt;(_ key: T) {<br>        <br>        self.hashValue = key.hashValue<br>        self.key = key<br>        self.equals = { self.key as! T == $0.key }<br>    }<br>}<br></p><p>public func == (lhs: AnyKey, rhs: AnyKey) -&gt; Bool { lhs.equals(rhs) }<br></p><p>You can now create a heterogenous [AnyKey: Any] dictionary. Note that `AnyKey` is not very memory efficient.<br></p><p>&gt; On Mar 25, 2016, at 5:27 PM, Hooman Mehr &lt;hooman at mac.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 2:51 PM, Jason Sadler via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; (My particular use case can be seen here: https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400 &lt;https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400&gt; … and the best information I’ve been able to find on this so far is here: http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927 &lt;http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927&gt;)<br>&gt; <br>&gt; Here is the best you can do for your particular use case:<br>&gt; <br>&gt; protocol AnyEquatable { func equals(other: Any) -&gt; Bool }<br>&gt; <br>&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: Any) -&gt; Bool {<br>&gt;     <br>&gt;     if let rhs = rhs as? T { return lhs == rhs } else { return false }<br>&gt; }<br>&gt; <br>&gt; extension Bool:   AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt; <br>&gt; extension Int:    AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt; <br>&gt; extension Double: AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt; <br>&gt; extension String: AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt; <br>&gt; extension Array {<br>&gt;     <br>&gt;     func indexOfAny(element : AnyEquatable) -&gt; Index? { return indexOf { element.equals($0) } }<br>&gt; }<br>&gt; <br>&gt; var array: [Any] = [false, 1, 2.0, &quot;three&quot;]<br>&gt; <br>&gt; array.indexOfAny(2.0)<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160325/ffe830a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Using ... as a concrete type conforming to protocol ... is not supported</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>March 25, 2016 at 06:00:00pm</p></header><div class="content"><p>Oops! that is buggy. I should check syntax before posting…<br></p><p>Here is the corrected version:<br></p><p>public struct AnyKey : Hashable {<br>    <br>    public let hashValue: Int<br>    public let key: Any<br>    public let equals: (Any, AnyKey) -&gt; Bool<br>    <br>    init&lt;T: Hashable&gt;(_ key: T) {<br>        <br>        self.hashValue = key.hashValue<br>        self.key = key<br>        self.equals = { $0 as! T == $1.key }<br>    }<br>}<br></p><p>public func == (lhs: AnyKey, rhs: AnyKey) -&gt; Bool { return lhs.equals(lhs,rhs) }<br></p><p><br>&gt; On Mar 25, 2016, at 5:59 PM, Hooman Mehr via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; You can also get a heterogenous dictionary, but it needs a type erasing helper box. With the following declarations:<br>&gt; <br>&gt; public func ==&lt;T: Equatable&gt;(lhs: T, rhs: Any) -&gt; Bool {<br>&gt;     <br>&gt;     if let rhs = rhs as? T { return lhs == rhs } else { return false }<br>&gt; }<br>&gt; <br>&gt; public struct AnyKey : Hashable {<br>&gt;     <br>&gt;     public let hashValue: Int<br>&gt;     public let key: Any<br>&gt;     public let equals: (AnyKey) -&gt; Bool<br>&gt;     <br>&gt;     init&lt;T: Hashable&gt;(_ key: T) {<br>&gt;         <br>&gt;         self.hashValue = key.hashValue<br>&gt;         self.key = key<br>&gt;         self.equals = { self.key as! T == $0.key }<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; public func == (lhs: AnyKey, rhs: AnyKey) -&gt; Bool { lhs.equals(rhs) }<br>&gt; <br>&gt; You can now create a heterogenous [AnyKey: Any] dictionary. Note that `AnyKey` is not very memory efficient.<br>&gt; <br>&gt;&gt; On Mar 25, 2016, at 5:27 PM, Hooman Mehr &lt;hooman at mac.com &lt;mailto:hooman at mac.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 25, 2016, at 2:51 PM, Jason Sadler via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; (My particular use case can be seen here: https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400 &lt;https://gist.github.com/sadlerjw/2cc16b4375b02fe7f400&gt; … and the best information I’ve been able to find on this so far is here: http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927 &lt;http://stackoverflow.com/questions/33112559/protocol-doesnt-conform-to-itself/33524927#33524927&gt;)<br>&gt;&gt; <br>&gt;&gt; Here is the best you can do for your particular use case:<br>&gt;&gt; <br>&gt;&gt; protocol AnyEquatable { func equals(other: Any) -&gt; Bool }<br>&gt;&gt; <br>&gt;&gt; func ==&lt;T: Equatable&gt;(lhs: T, rhs: Any) -&gt; Bool {<br>&gt;&gt;     <br>&gt;&gt;     if let rhs = rhs as? T { return lhs == rhs } else { return false }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; extension Bool:   AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt;&gt; <br>&gt;&gt; extension Int:    AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt;&gt; <br>&gt;&gt; extension Double: AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt;&gt; <br>&gt;&gt; extension String: AnyEquatable { func equals(other: Any) -&gt; Bool { return self == other } }<br>&gt;&gt; <br>&gt;&gt; extension Array {<br>&gt;&gt;     <br>&gt;&gt;     func indexOfAny(element : AnyEquatable) -&gt; Index? { return indexOf { element.equals($0) } }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; var array: [Any] = [false, 1, 2.0, &quot;three&quot;]<br>&gt;&gt; <br>&gt;&gt; array.indexOfAny(2.0)<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160325/375b1283/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
