<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 11, 2016 at 10:00:00pm</p></header><div class="content"><p>I get this error in the following code: &quot;Type of expression is ambiguous without more context&quot;, on the DispatchQueue. But only if I mark it as &quot;lazy&quot;, and not if I don&#39;t. I&#39;m not sure why.<br></p><p>class<br>myClass<br>{<br>  lazy var myQ = DispatchQueue(label: &quot;Op&quot;, attributes: .concurrent)	// &lt;-- ERROR<br>                 ^Type of expression is ambiguous without more context<br>}<br></p><p>Would someone please explain? Thank you.<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>September 11, 2016 at 10:00:00pm</p></header><div class="content"><p>This problem seems to occur when using an initializer with some default<br>argument values. The following code also exhibits the issue:<br></p><p>struct Bar {<br>  init(x: Int, y: Int? = 42) { }<br>}<br></p><p>class Foo {<br>  lazy var myQ = Bar(x: 3)<br>}<br></p><p><br>I&#39;d recommend filing a bug at bugs.swift.org.<br></p><p>On Sun, Sep 11, 2016 at 10:19 PM, Rick Mann via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; I get this error in the following code: &quot;Type of expression is ambiguous<br>&gt; without more context&quot;, on the DispatchQueue. But only if I mark it as<br>&gt; &quot;lazy&quot;, and not if I don&#39;t. I&#39;m not sure why.<br>&gt;<br>&gt; class<br>&gt; myClass<br>&gt; {<br>&gt;   lazy var myQ = DispatchQueue(label: &quot;Op&quot;, attributes: .concurrent)    //<br>&gt; &lt;-- ERROR<br>&gt;                  ^Type of expression is ambiguous without more context<br>&gt; }<br>&gt;<br>&gt; Would someone please explain? Thank you.<br>&gt;<br>&gt; --<br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160911/3a2a4db6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 12, 2016 at 08:00:00am</p></header><div class="content"><p>On 12 Sep 2016, at 06:40, Jacob Bandes-Storch via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; I&#39;d recommend filing a bug at bugs.swift.org.<br></p><p>Agreed.<br></p><p>Also, you can work around this by adding a type.<br></p><p>  lazy var myQ: DispatchQueue = DispatchQueue(label: &quot;Op&quot;, attributes: .concurrent)<br></p><p>Also, with regards this specific example, be aware that lazy properties aren’t guaranteed to be initialised only once.  To quote “The Swift Programming Language”:<br></p><p>    If a property marked with the `lazy` modified is accessed by multiple <br>    threads simultaneously and the property has not yet been initialized, <br>    there is no guarantee that the property will be initialized only once.<br></p><p>I’m struggling to think of a case where that limitation is acceptable in the context of a dispatch queue (-:<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>September 12, 2016 at 03:00:00pm</p></header><div class="content"><p>It is not a bug. You must explicitly specify the variable&#39;s type if you use<br>`lazy` keyword. `lazy` means the variable will be initialized later, but<br>the compiler needs its type right now.<br></p><p>Zhaoxin<br></p><p>On Mon, Sep 12, 2016 at 3:02 PM, Quinn &quot;The Eskimo!&quot; via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 12 Sep 2016, at 06:40, Jacob Bandes-Storch via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; I&#39;d recommend filing a bug at bugs.swift.org.<br>&gt;<br>&gt; Agreed.<br>&gt;<br>&gt; Also, you can work around this by adding a type.<br>&gt;<br>&gt;   lazy var myQ: DispatchQueue = DispatchQueue(label: &quot;Op&quot;, attributes:<br>&gt; .concurrent)<br>&gt;<br>&gt; Also, with regards this specific example, be aware that lazy properties<br>&gt; aren’t guaranteed to be initialised only once.  To quote “The Swift<br>&gt; Programming Language”:<br>&gt;<br>&gt;     If a property marked with the `lazy` modified is accessed by multiple<br>&gt;     threads simultaneously and the property has not yet been initialized,<br>&gt;     there is no guarantee that the property will be initialized only once.<br>&gt;<br>&gt; I’m struggling to think of a case where that limitation is acceptable in<br>&gt; the context of a dispatch queue (-:<br>&gt;<br>&gt; Share and Enjoy<br>&gt; --<br>&gt; Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>&gt; Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160912/fab7e268/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 12, 2016 at 08:00:00am</p></header><div class="content"><p>On 12 Sep 2016, at 08:28, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br></p><p>&gt; It is not a bug. <br></p><p>I disagree.<br></p><p>&gt; You must explicitly specify the variable&#39;s type if you use `lazy` keyword.<br></p><p><br>No, that’s not the case in general.  For example, the following code compiles just fine.<br></p><p>  import Dispatch<br></p><p>  func queueMaker() -&gt; DispatchQueue {<br>    return DispatchQueue(label: &quot;Op&quot;, attributes: .concurrent)<br>  }<br></p><p>  class MyClass {<br>    lazy var myQ = queueMaker()<br>  }<br></p><p>Regardless, there’s two possibilities here:<br></p><p>A. this is a real restriction in the language, which makes the poor diagnostic bugworthy<br></p><p>B. this is a false restriction, which makes it bugworthy in and of itself<br></p><p>While I personally believe that B is the case here, that’s really besides the point; something, either A or B, should change, and hence my advice.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 12, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 00:02 , Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 12 Sep 2016, at 06:40, Jacob Bandes-Storch via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;d recommend filing a bug at bugs.swift.org.<br>&gt; <br>&gt; Agreed.<br></p><p>Done. https://bugs.swift.org/browse/SR-2616<br></p><p>&gt; Also, you can work around this by adding a type.<br>&gt; <br>&gt;  lazy var myQ: DispatchQueue = DispatchQueue(label: &quot;Op&quot;, attributes: .concurrent)<br></p><p>Sure, it just didn&#39;t seem to make sense.<br></p><p>&gt; Also, with regards this specific example, be aware that lazy properties aren’t guaranteed to be initialised only once.  To quote “The Swift Programming Language”:<br>&gt; <br>&gt;    If a property marked with the `lazy` modified is accessed by multiple <br>&gt;    threads simultaneously and the property has not yet been initialized, <br>&gt;    there is no guarantee that the property will be initialized only once.<br>&gt; <br>&gt; I’m struggling to think of a case where that limitation is acceptable in the context of a dispatch queue (-:<br></p><p>Thank you for that explanation. I had assumed lazy worked like static, which I understand uses dispatch_once under the hood. Would that be a reasonable thing for lazy to do?<br></p><p>In the end I didn&#39;t use a property for the queue, but rather just created it at point of use (I&#39;m testing to see whether or not the enqueued blocks retain the queue; that&#39;s all I need).<br></p><p>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 12, 2016 at 08:00:00am</p></header><div class="content"><p>On 12 Sep 2016, at 08:46, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br></p><p>&gt; I had assumed lazy worked like static, which I understand uses dispatch_once under the hood.<br></p><p>Correct.<br></p><p>[I’m not sure if it actually /uses/ `dispatch_once` specifically, but it has the same semantics.]<br></p><p>&gt; Would that be a reasonable thing for lazy to do?<br></p><p>It certainly would be nice.  I suspect that this would be hard to implement because the restrictions associated with `dispatch_once` are pretty tight.  OTOH, if you’d like to see it work this way it wouldn’t hurt to file an enhancement request.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 12, 2016 at 08:00:00am</p></header><div class="content"><p>On 12 Sep 2016, at 08:53, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; On 12 Sep 2016, at 08:46, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt;&gt; I had assumed lazy worked like static, which I understand uses dispatch_once under the hood.<br>&gt; <br>&gt; Correct.<br></p><p>Re-reading the above I realise that it was ambiguous.  Let’s try that again.<br></p><p>                   *                   *                   *<br></p><p>On 12 Sep 2016, at 08:46, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br></p><p>&gt; I had assumed lazy worked like static …<br></p><p>No, alas.<br></p><p>&gt; which I understand uses dispatch_once under the hood.<br></p><p>Your understanding of `static` is correct.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 12, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 00:53 , Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 12 Sep 2016, at 08:46, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt;&gt; I had assumed lazy worked like static, which I understand uses dispatch_once under the hood.<br>&gt; <br>&gt; Correct.<br>&gt; <br>&gt; [I’m not sure if it actually /uses/ `dispatch_once` specifically, but it has the same semantics.]<br>&gt; <br>&gt;&gt; Would that be a reasonable thing for lazy to do?<br>&gt; <br>&gt; It certainly would be nice.  I suspect that this would be hard to implement because the restrictions associated with `dispatch_once` are pretty tight.  OTOH, if you’d like to see it work this way it wouldn’t hurt to file an enhancement request.<br></p><p>Oh, right, because it seems to need a static or global variable for the flag. I&#39;ve always wondered why that was the case. Seems like any flag would do (like a member variable), and if that results in a second dispatch because it&#39;s a second flag, that&#39;s okay.<br></p><p>In any case, thanks for all the clarification.<br></p><p>&gt; <br>&gt; Share and Enjoy<br>&gt; --<br>&gt; Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>&gt; Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>September 12, 2016 at 11:00:00am</p></header><div class="content"><p>On 12 Sep 2016, at 09:20, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br></p><p>&gt; I&#39;ve always wondered why that was the case.<br></p><p>Implementing `dispatch_once` so that it’s fast on all CPU architectures, including those with a weak memory model, requires that ‘once token’:<br></p><p>* be initialised to 0 before `dispatch_once` sees it<br></p><p>* not modified by anything other than `dispatch_once`<br></p><p>That’s true for [switching to Obj-C terminology here] global variables, which are initialised by the linker to 0 before any instruction in the process runs, but it’s not true for ivars.<br></p><p>If you want to see how this really works, you can check out the source in Darwin.<br></p><p>&lt;http://opensource.apple.com/source/libdispatch/libdispatch-500.1.5/src/once.c&gt;<br></p><p>Frankly, it hurts my brain )-:<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 12, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; On Sep 12, 2016, at 03:02 , Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; On 12 Sep 2016, at 09:20, Rick Mann &lt;rmann at latencyzero.com&gt; wrote:<br>&gt; <br>&gt;&gt; I&#39;ve always wondered why that was the case.<br>&gt; <br>&gt; Implementing `dispatch_once` so that it’s fast on all CPU architectures, including those with a weak memory model, requires that ‘once token’:<br>&gt; <br>&gt; * be initialised to 0 before `dispatch_once` sees it<br>&gt; <br>&gt; * not modified by anything other than `dispatch_once`<br>&gt; <br>&gt; That’s true for [switching to Obj-C terminology here] global variables, which are initialised by the linker to 0 before any instruction in the process runs, but it’s not true for ivars.<br>&gt; <br>&gt; If you want to see how this really works, you can check out the source in Darwin.<br>&gt; <br>&gt; &lt;http://opensource.apple.com/source/libdispatch/libdispatch-500.1.5/src/once.c&gt;<br>&gt; <br>&gt; Frankly, it hurts my brain )-:<br></p><p>Wheeeee!<br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8809800aec2460f291384b794d7e6f8f?s=50"></div><header><strong>Lazy expression is ambiguous?</strong> from <string>Rick Mann</string> &lt;rmann at latencyzero.com&gt;<p>September 12, 2016 at 12:00:00am</p></header><div class="content"><p>Done. https://bugs.swift.org/browse/SR-2616<br></p><p>&gt; On Sep 11, 2016, at 22:40 , Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; This problem seems to occur when using an initializer with some default argument values. The following code also exhibits the issue:<br>&gt; <br>&gt; struct Bar {<br>&gt;   init(x: Int, y: Int? = 42) { }<br>&gt; }<br>&gt; <br>&gt; class Foo {<br>&gt;   lazy var myQ = Bar(x: 3)<br>&gt; }<br>&gt; <br>&gt; <br>&gt; I&#39;d recommend filing a bug at bugs.swift.org.<br>&gt; <br>&gt; On Sun, Sep 11, 2016 at 10:19 PM, Rick Mann via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; I get this error in the following code: &quot;Type of expression is ambiguous without more context&quot;, on the DispatchQueue. But only if I mark it as &quot;lazy&quot;, and not if I don&#39;t. I&#39;m not sure why.<br>&gt; <br>&gt; class<br>&gt; myClass<br>&gt; {<br>&gt;   lazy var myQ = DispatchQueue(label: &quot;Op&quot;, attributes: .concurrent)    // &lt;-- ERROR<br>&gt;                  ^Type of expression is ambiguous without more context<br>&gt; }<br>&gt; <br>&gt; Would someone please explain? Thank you.<br>&gt; <br>&gt; --<br>&gt; Rick Mann<br>&gt; rmann at latencyzero.com<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt; <br></p><p><br>-- <br>Rick Mann<br>rmann at latencyzero.com<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
