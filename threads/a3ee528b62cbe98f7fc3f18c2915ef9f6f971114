<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  7, 2015 at 01:00:00pm</p></header><div class="content"><p>Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br></p><p>Let’s take the example of class clusters:<br></p><p>private protocol _Cluster {<br>    func description() -&gt; String<br>}<br></p><p>class Cluster: _Cluster {<br>    <br>    private var _instance: _Cluster<br>    <br>    init(name: String) {<br>        _instance = _ClusterString(name: name)<br>    }<br>    <br>    init(value: Int) {<br>        _instance = _ClusterValue(value: value)<br>    }<br>    <br>    // this is pure boiler-plate<br>    func description() -&gt; String {<br>        return _instance.description()<br>    }<br>}<br></p><p>private class _ClusterString: _Cluster {<br>    private var name: String<br>    init(name: String) { self.name = name }<br>    func description() -&gt; String {<br>        return &quot;_ClusterString: \(name)&quot;<br>    }<br>}<br></p><p>private class _ClusterValue: _Cluster {<br>    private var value: Int<br>    init(value: Int) { self.value = value }<br>    func description() -&gt; String {<br>        return &quot;_ClusterValue: \(value)&quot;<br>    }<br>}<br></p><p>let s = Cluster(name: &quot;a string&quot;)<br>s.description()<br></p><p>let v = Cluster(value: 12)<br>v.description()<br></p><p><br>Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br></p><p>class Cluster: _Cluster {<br>    @forward(_Cluster, _instance)<br></p><p>    private var _instance: _Cluster<br>    <br>    init(name: String) {<br>        _instance = _ClusterString(name: name)<br>    }<br>    <br>    init(value: Int) {<br>        _instance = _ClusterValue(value: value)<br>    }<br>}<br></p><p>The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br></p><p>Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br></p><p>-David<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151207/a3ee1114/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 11:00:00am</p></header><div class="content"><p>I would also like to see language support for concise forwarding.  It gives composition a conciseness that approaches inheritance which makes it much more pragmatic than it currently is.  This is a huge win IMO.<br></p><p>Forwarding protocol implementations would provide the most value, but forwarding individual methods (whether part of a protocol implementation or not) may also be useful.  Maybe a single mechanism could accomplish both?<br></p><p>When forwarding protocols, it would be ideal to also allow the forwarding class to explicitly implement specific methods of the protocol while the rest are forwarded automatically.<br></p><p>One detail that definitely needs to be addressed is how a protocol with members using Self would be handled, especially when Self is used as a return value.  I’m not sure if these methods could be forwarded automatically or not.  David, do you have any ideas as to how this would be handled?<br></p><p>Another detail that needs to be addressed is how protocols with associated types are forwarded.  I think this would be more straightforward but the details need to be written up to be sure.<br></p><p>Syntactically, I think it would make most sense to specify forwarding along side the member declaration rather than in a separate declaration and should support multiple protocols to be forwarded to the same member in the same declaration.  Something like this:<br></p><p>class Cluster: _Cluster, Foo, Bar {<br>    // Ideally the member could have any type conforming to the protocol.<br>    // This would require Swift to recognize that members typed with the protocol itself<br>    // also conform to the protocol.<br>    @forward(_Cluster) private var _instance: _Cluster<br></p><p>    // FooBar is a type that conforms to both Foo and Bar protocols<br>    @forward(Foo, Bar) private let fooBar: FooBar<br>    ...<br>}<br></p><p>Matthew<br></p><p>&gt; On Dec 7, 2015, at 3:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt; <br>&gt; Let’s take the example of class clusters:<br>&gt; <br>&gt; private protocol _Cluster {<br>&gt;     func description() -&gt; String<br>&gt; }<br>&gt; <br>&gt; class Cluster: _Cluster {<br>&gt;     <br>&gt;     private var _instance: _Cluster<br>&gt;     <br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;     <br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt;     <br>&gt;     // this is pure boiler-plate<br>&gt;     func description() -&gt; String {<br>&gt;         return _instance.description()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; private class _ClusterString: _Cluster {<br>&gt;     private var name: String<br>&gt;     init(name: String) { self.name = name }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; private class _ClusterValue: _Cluster {<br>&gt;     private var value: Int<br>&gt;     init(value: Int) { self.value = value }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt; s.description()<br>&gt; <br>&gt; let v = Cluster(value: 12)<br>&gt; v.description()<br>&gt; <br>&gt; <br>&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt; <br>&gt; class Cluster: _Cluster {<br>&gt;     @forward(_Cluster, _instance)<br>&gt; <br>&gt;     private var _instance: _Cluster<br>&gt;     <br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;     <br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt; <br>&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/60eb00a2/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 09:00:00am</p></header><div class="content"><p>It&#39;d definitely be awesome to support forwarding protocol conformances. One thing a forwarding design needs to consider is how to handle `Self` requirements in the forwarded protocol. If the protocol requirements consume `Self` types, you need a conversion operation to go from the forwarder to the forwardee type, such as the getter for the forwardee property.<br>If there are any requirements that return `Self` you&#39;d need to additionally provide an initializer or factory function capable of building a new instance of the forwarder type from the forwardee.<br></p><p>-Joe<br></p><p>&gt; On Dec 7, 2015, at 1:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt; <br>&gt; Let’s take the example of class clusters:<br>&gt; <br>&gt; private protocol _Cluster {<br>&gt;     func description() -&gt; String<br>&gt; }<br>&gt; <br>&gt; class Cluster: _Cluster {<br>&gt;     <br>&gt;     private var _instance: _Cluster<br>&gt;     <br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;     <br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt;     <br>&gt;     // this is pure boiler-plate<br>&gt;     func description() -&gt; String {<br>&gt;         return _instance.description()<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; private class _ClusterString: _Cluster {<br>&gt;     private var name: String<br>&gt;     init(name: String) { self.name = name }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; private class _ClusterValue: _Cluster {<br>&gt;     private var value: Int<br>&gt;     init(value: Int) { self.value = value }<br>&gt;     func description() -&gt; String {<br>&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt; s.description()<br>&gt; <br>&gt; let v = Cluster(value: 12)<br>&gt; v.description()<br>&gt; <br>&gt; <br>&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt; <br>&gt; class Cluster: _Cluster {<br>&gt;     @forward(_Cluster, _instance)<br>&gt; <br>&gt;     private var _instance: _Cluster<br>&gt;     <br>&gt;     init(name: String) {<br>&gt;         _instance = _ClusterString(name: name)<br>&gt;     }<br>&gt;     <br>&gt;     init(value: Int) {<br>&gt;         _instance = _ClusterValue(value: value)<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt; <br>&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt; <br>&gt; -David<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/a23c3de0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>Would it be acceptable to make forwarding of member with Self return types optional for the forwarder (i.e. If the initializer / factory function is not provided the member is not forwarded and must be implemented manually)?<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 8, 2015, at 11:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; It&#39;d definitely be awesome to support forwarding protocol conformances. One thing a forwarding design needs to consider is how to handle `Self` requirements in the forwarded protocol. If the protocol requirements consume `Self` types, you need a conversion operation to go from the forwarder to the forwardee type, such as the getter for the forwardee property.<br>&gt; If there are any requirements that return `Self` you&#39;d need to additionally provide an initializer or factory function capable of building a new instance of the forwarder type from the forwardee.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 7, 2015, at 1:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt;&gt; <br>&gt;&gt; Let’s take the example of class clusters:<br>&gt;&gt; <br>&gt;&gt; private protocol _Cluster {<br>&gt;&gt;     func description() -&gt; String<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;     <br>&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;     <br>&gt;&gt;     init(name: String) {<br>&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init(value: Int) {<br>&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     // this is pure boiler-plate<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return _instance.description()<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;     private var name: String<br>&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;     private var value: Int<br>&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt; s.description()<br>&gt;&gt; <br>&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt; v.description()<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt;&gt; <br>&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;     @forward(_Cluster, _instance)<br>&gt;&gt; <br>&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;     <br>&gt;&gt;     init(name: String) {<br>&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;     }<br>&gt;&gt;     <br>&gt;&gt;     init(value: Int) {<br>&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt;&gt; <br>&gt;&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt;&gt; <br>&gt;&gt; -David<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/b69794df/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  8, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:09 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt; <br>&gt; Would it be acceptable to make forwarding of member with Self return types optional for the forwarder (i.e. If the initializer / factory function is not provided the member is not forwarded and must be implemented manually)?<br></p><p>That&#39;s definitely a reasonable answer.<br></p><p>In my mind, an ideal solution would make it easy to implement &#39;newtypes&#39; that wrap a type while exposing selected parts of the original type&#39;s interface. For example, if you wanted to make strongly-typed units valued as Doubles that still support arithmetic:<br></p><p>protocol Addable { func + (_: Self, _: Self) -&gt; Self }<br></p><p>struct Weight: Addable {<br>  var value: Double implements Addable<br>}<br>struct Distance: Addable {<br>  var value: Double implements Addable<br>}<br></p><p>it&#39;d be nice if the unwrapping and wrapping defaulted to something sensible.<br></p><p>-Joe<br></p><p>&gt; Sent from my iPad<br>&gt; <br>&gt; On Dec 8, 2015, at 11:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; It&#39;d definitely be awesome to support forwarding protocol conformances. One thing a forwarding design needs to consider is how to handle `Self` requirements in the forwarded protocol. If the protocol requirements consume `Self` types, you need a conversion operation to go from the forwarder to the forwardee type, such as the getter for the forwardee property.<br>&gt;&gt; If there are any requirements that return `Self` you&#39;d need to additionally provide an initializer or factory function capable of building a new instance of the forwarder type from the forwardee.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 7, 2015, at 1:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Let’s take the example of class clusters:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private protocol _Cluster {<br>&gt;&gt;&gt;     func description() -&gt; String<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     // this is pure boiler-plate<br>&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;         return _instance.description()<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;&gt;     private var name: String<br>&gt;&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;&gt;     private var value: Int<br>&gt;&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt;&gt; s.description()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt;&gt; v.description()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;     @forward(_Cluster, _instance)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;     <br>&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -David<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/7fa7ef79/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>December  8, 2015 at 04:00:00pm</p></header><div class="content"><p>Yes, it should be pretty straightforward to handle the wrapping and unwrapping for the single member / newtype case.  Thanks bringing that up.  I will keep that in mind if I get around to writing this proposal before someone else does.<br></p><p>Is a forwarding mechanism like this something that might be considered in the Swift 3 timeframe?<br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 8, 2015, at 2:52 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:09 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Would it be acceptable to make forwarding of member with Self return types optional for the forwarder (i.e. If the initializer / factory function is not provided the member is not forwarded and must be implemented manually)?<br>&gt; <br>&gt; That&#39;s definitely a reasonable answer.<br>&gt; <br>&gt; In my mind, an ideal solution would make it easy to implement &#39;newtypes&#39; that wrap a type while exposing selected parts of the original type&#39;s interface. For example, if you wanted to make strongly-typed units valued as Doubles that still support arithmetic:<br>&gt; <br>&gt; protocol Addable { func + (_: Self, _: Self) -&gt; Self }<br>&gt; <br>&gt; struct Weight: Addable {<br>&gt;   var value: Double implements Addable<br>&gt; }<br>&gt; struct Distance: Addable {<br>&gt;   var value: Double implements Addable<br>&gt; }<br>&gt; <br>&gt; it&#39;d be nice if the unwrapping and wrapping defaulted to something sensible.<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 11:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It&#39;d definitely be awesome to support forwarding protocol conformances. One thing a forwarding design needs to consider is how to handle `Self` requirements in the forwarded protocol. If the protocol requirements consume `Self` types, you need a conversion operation to go from the forwarder to the forwardee type, such as the getter for the forwardee property.<br>&gt;&gt;&gt; If there are any requirements that return `Self` you&#39;d need to additionally provide an initializer or factory function capable of building a new instance of the forwarder type from the forwardee.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Let’s take the example of class clusters:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private protocol _Cluster {<br>&gt;&gt;&gt;&gt;     func description() -&gt; String<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     // this is pure boiler-plate<br>&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;         return _instance.description()<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;&gt;&gt;     private var name: String<br>&gt;&gt;&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;&gt;&gt;     private var value: Int<br>&gt;&gt;&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt;&gt;&gt; s.description()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt;&gt;&gt; v.description()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;&gt;     @forward(_Cluster, _instance)<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/20a75dc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/33536e304f2318595dbd6104fdb0bd4a?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>Alejandro Martinez</string> &lt;alexito4 at gmail.com&gt;<p>December  9, 2015 at 07:00:00am</p></header><div class="content"><p>Hi,<br>Quick mail to check if I understood correctly ;)<br>Since swift introduction I&#39;ve been trying to explore creating more domain specific types in order to avoid passing numbers and strings around (that can mean anything) and leverage the type checker to write safer code. (For context http://alejandromp.com/blog/2015/12/5/solving-the-strings-problem-in-swift/ )<br>You can quickly realize that it increases the safety a lot but at cost of s bunch of boilerplate. At the end you just want that your type behaves as the other (string, int) but that the type checker treats it as different types.<br>Seems like this proposal and making easier creating &#39;newtype&#39; will be the solution for this right?<br>Thanks<br></p><p><br>Sent from my iPad<br></p><p>&gt; On 08 Dec 2015, at 22:41, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Yes, it should be pretty straightforward to handle the wrapping and unwrapping for the single member / newtype case.  Thanks bringing that up.  I will keep that in mind if I get around to writing this proposal before someone else does.<br>&gt; <br>&gt; Is a forwarding mechanism like this something that might be considered in the Swift 3 timeframe?<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 2:52 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 10:09 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Would it be acceptable to make forwarding of member with Self return types optional for the forwarder (i.e. If the initializer / factory function is not provided the member is not forwarded and must be implemented manually)?<br>&gt;&gt; <br>&gt;&gt; That&#39;s definitely a reasonable answer.<br>&gt;&gt; <br>&gt;&gt; In my mind, an ideal solution would make it easy to implement &#39;newtypes&#39; that wrap a type while exposing selected parts of the original type&#39;s interface. For example, if you wanted to make strongly-typed units valued as Doubles that still support arithmetic:<br>&gt;&gt; <br>&gt;&gt; protocol Addable { func + (_: Self, _: Self) -&gt; Self }<br>&gt;&gt; <br>&gt;&gt; struct Weight: Addable {<br>&gt;&gt;   var value: Double implements Addable<br>&gt;&gt; }<br>&gt;&gt; struct Distance: Addable {<br>&gt;&gt;   var value: Double implements Addable<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; it&#39;d be nice if the unwrapping and wrapping defaulted to something sensible.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 11:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; It&#39;d definitely be awesome to support forwarding protocol conformances. One thing a forwarding design needs to consider is how to handle `Self` requirements in the forwarded protocol. If the protocol requirements consume `Self` types, you need a conversion operation to go from the forwarder to the forwardee type, such as the getter for the forwardee property.<br>&gt;&gt;&gt;&gt; If there are any requirements that return `Self` you&#39;d need to additionally provide an initializer or factory function capable of building a new instance of the forwarder type from the forwardee.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Let’s take the example of class clusters:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private protocol _Cluster {<br>&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     // this is pure boiler-plate<br>&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;         return _instance.description()<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;     private var name: String<br>&gt;&gt;&gt;&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;     private var value: Int<br>&gt;&gt;&gt;&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt;&gt;&gt;&gt; s.description()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt;&gt;&gt;&gt; v.description()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;     @forward(_Cluster, _instance)<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/d51c4572/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>protocol based invocation forwarding</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>December  9, 2015 at 12:00:00am</p></header><div class="content"><p>Yes, this would help with that. <br></p><p>Sent from my iPad<br></p><p>&gt; On Dec 8, 2015, at 11:39 PM, Alejandro Martinez via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hi,<br>&gt; Quick mail to check if I understood correctly ;)<br>&gt; Since swift introduction I&#39;ve been trying to explore creating more domain specific types in order to avoid passing numbers and strings around (that can mean anything) and leverage the type checker to write safer code. (For context http://alejandromp.com/blog/2015/12/5/solving-the-strings-problem-in-swift/ )<br>&gt; You can quickly realize that it increases the safety a lot but at cost of s bunch of boilerplate. At the end you just want that your type behaves as the other (string, int) but that the type checker treats it as different types.<br>&gt; Seems like this proposal and making easier creating &#39;newtype&#39; will be the solution for this right?<br>&gt; Thanks<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On 08 Dec 2015, at 22:41, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Yes, it should be pretty straightforward to handle the wrapping and unwrapping for the single member / newtype case.  Thanks bringing that up.  I will keep that in mind if I get around to writing this proposal before someone else does.<br>&gt;&gt; <br>&gt;&gt; Is a forwarding mechanism like this something that might be considered in the Swift 3 timeframe?<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 2:52 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 10:09 AM, Matthew Johnson &lt;matthew at anandabits.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Would it be acceptable to make forwarding of member with Self return types optional for the forwarder (i.e. If the initializer / factory function is not provided the member is not forwarded and must be implemented manually)?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That&#39;s definitely a reasonable answer.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my mind, an ideal solution would make it easy to implement &#39;newtypes&#39; that wrap a type while exposing selected parts of the original type&#39;s interface. For example, if you wanted to make strongly-typed units valued as Doubles that still support arithmetic:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Addable { func + (_: Self, _: Self) -&gt; Self }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct Weight: Addable {<br>&gt;&gt;&gt;   var value: Double implements Addable<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; struct Distance: Addable {<br>&gt;&gt;&gt;   var value: Double implements Addable<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; it&#39;d be nice if the unwrapping and wrapping defaulted to something sensible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 11:53 AM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; It&#39;d definitely be awesome to support forwarding protocol conformances. One thing a forwarding design needs to consider is how to handle `Self` requirements in the forwarded protocol. If the protocol requirements consume `Self` types, you need a conversion operation to go from the forwarder to the forwardee type, such as the getter for the forwardee property.<br>&gt;&gt;&gt;&gt;&gt; If there are any requirements that return `Self` you&#39;d need to additionally provide an initializer or factory function capable of building a new instance of the forwarder type from the forwardee.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Joe<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 7, 2015, at 1:33 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Often it is the case where one might want to implement a type that provides an interface but has inner components that actually handle the implementation. In those cases, we end up with a lot of boiler-plate code that simply turns around and invokes the on the instance.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Let’s take the example of class clusters:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private protocol _Cluster {<br>&gt;&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     // this is pure boiler-plate<br>&gt;&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;         return _instance.description()<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private class _ClusterString: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;&gt;     private var name: String<br>&gt;&gt;&gt;&gt;&gt;&gt;     init(name: String) { self.name = name }<br>&gt;&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;_ClusterString: \(name)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; private class _ClusterValue: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;&gt;     private var value: Int<br>&gt;&gt;&gt;&gt;&gt;&gt;     init(value: Int) { self.value = value }<br>&gt;&gt;&gt;&gt;&gt;&gt;     func description() -&gt; String {<br>&gt;&gt;&gt;&gt;&gt;&gt;         return &quot;_ClusterValue: \(value)&quot;<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let s = Cluster(name: &quot;a string&quot;)<br>&gt;&gt;&gt;&gt;&gt;&gt; s.description()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; let v = Cluster(value: 12)<br>&gt;&gt;&gt;&gt;&gt;&gt; v.description()<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Now, it would be nice to not have to have to implement the boiler-plate (this example only has a single method, so the savings seem minimal).<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; class Cluster: _Cluster {<br>&gt;&gt;&gt;&gt;&gt;&gt;     @forward(_Cluster, _instance)<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;     private var _instance: _Cluster<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     init(name: String) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterString(name: name)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt;     <br>&gt;&gt;&gt;&gt;&gt;&gt;     init(value: Int) {<br>&gt;&gt;&gt;&gt;&gt;&gt;         _instance = _ClusterValue(value: value)<br>&gt;&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The @forward(protocol, instance) attribute lets the compiler know that the _Cluster protocol should be forwarded to the _instance value. The compiler would then generate all of the implementation stubs. Refactoring is also made simple as API changes to _Cluster do not need to be manually reflected on the type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Another way to solve this problem is with a sufficiently advanced macro system. But that is out-of-scope for v3. However, this seems like it could be a straight-forward enough implementation to support in the mean-time, with an easy path for removal/update if it were to be replaced by a macro system.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; -David<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/c61ce85f/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
