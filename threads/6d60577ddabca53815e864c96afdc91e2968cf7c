<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 10:00:00am</p></header><div class="content"><p>on Fri Jul 22 2016, Karl &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;&gt; On 22 Jul 2016, at 03:11, Robert Widmann via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift Community,<br>&gt;&gt; <br>&gt;<br>&gt;&gt; Harlan Haskins, Jaden Geller, and I have been working on a proposal<br>&gt;&gt; to clean up the semantics of ordering relations in the standard<br>&gt;&gt; library.  We have a draft that you can get as a<br>&gt;&gt; gist. &lt;https://gist.github.com/CodaFi/f0347bd37f1c407bf7ea0c429ead380e&gt;<br>&gt;&gt; Any feedback you might have about this proposal helps - though<br>&gt;&gt; please keeps your comments on Swift-Evolution and not on the gist.<br>&gt;&gt; <br>&gt;&gt; Cheers,<br>&gt;&gt; <br>&gt;&gt; ~Robert Widmann<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; I fear that this will become confusing (especially since Equatable may<br>&gt; now be implemented as a static function, too). We will have 3<br>&gt; different “equality” comparisons in Swift:<br>&gt;<br>&gt; === for reference-types<br>&gt; == for all types<br>&gt; areSame() which may be subtly different to ==<br>&gt;<br>&gt; In order to have an opinion on whether or not this is justified, I<br>&gt; need to know more about how areSame() may differ from == and how this<br>&gt; will affect generic code. What is required that could not fit inside<br>&gt; an override of Equatable? <br></p><p>Floating point types.  You should be able to ask for<br>arrayOfFloats.firstIndex(of: x) even if there are NaNs in the array (or<br>x).<br></p><p>It will not affect generic code, since in generic code == will always<br>dispatch to areSame() (unless the argument is constrained to<br>FloatingPoint, in which case == will have floating point semantics).<br></p><p>It would not be wholly unreasonable to merge === and areSame; they mean<br>almost exactly the same thing.<br></p><p>&gt; If this only applies to a few types, will it be its own protocol<br>&gt; (e.g. EquivalenceCheckable)?<br></p><p>It applies to every type where an == operator is appropriate, as far as<br>I know.  That&#39;s a lot.  <br></p><p>Whether we should rename it something having to<br>do with “Equivalence” or “Identity,” etc., is a good (and separate) question.<br></p><p>-- <br>Dave<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 22, 2016 at 10:00:00pm</p></header><div class="content"><p>I agree with Tony that we should still keep == and != as part of Equatable, and&lt;, &lt;=, &gt;, and &gt;= as part of Comparable, while offering default implementations through &lt;=&gt;.<br></p><p>The reason is, that otherwise generic code would dispatch differently depending on the generic constraint; &lt;T : Comparable&gt; would only see the operators using &lt;=&gt; while &lt;T : FloatingPoint&gt; would pick up the IEEE-754 versions, even if in both cases T were Double.<br></p><p>Below is a concrete example where things wouldn&#39;t work as expected, given the proposal omitting the other operators in the protocols:<br></p><p>Dave Abrahams wrote:<br></p><p>&gt;&gt; In order to have an opinion on whether or not this is justified, I<br>&gt;&gt; need to know more about how areSame() may differ from == and how this<br>&gt;&gt; will affect generic code. What is required that could not fit inside<br>&gt;&gt; an override of Equatable?<br>&gt; <br>&gt; Floating point types.  You should be able to ask for<br>&gt; arrayOfFloats.firstIndex(of: x) even if there are NaNs in the array (or<br>&gt; x).<br></p><p>Given that func firstIndex&lt;T : Equatable&gt;(of value: T) dispatches on Equatable, it would use Double.areSame(_:_:) instead of the IEEE-754 Double.==(_:_:). While that sounds innocuous, it would cause surprising results in the presense of negative zero:<br></p><p>    [-0.0, 1.0, .nan, 0.0].firstIndex(of: 0.0)<br>    //=&gt; 3, not 0<br></p><p>which almost definitely isn&#39;t what the caller would want. Instead, functions like these should clearly document (or it should be obvious from their semantics) whether they use == and &lt; (etc), or &lt;=&gt; in their implementation. I think that is a reasonable price to pay.<br></p><p>Or am I missing something obvious about round pegs and square holes?<br></p><p>— Pyry<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>July 22, 2016 at 02:00:00pm</p></header><div class="content"><p>On Fri, Jul 22, 2016 at 2:26 PM, Pyry Jahkola via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I agree with Tony that we should still keep == and != as part of<br>&gt; Equatable, and&lt;, &lt;=, &gt;, and &gt;= as part of Comparable, while offering<br>&gt; default implementations through &lt;=&gt;.<br>&gt;<br>&gt; The reason is, that otherwise generic code would dispatch differently<br>&gt; depending on the generic constraint; &lt;T : Comparable&gt; would only see the<br>&gt; operators using &lt;=&gt; while &lt;T : FloatingPoint&gt; would pick up the IEEE-754<br>&gt; versions, even if in both cases T were Double.<br>&gt;<br>&gt; Below is a concrete example where things wouldn&#39;t work as expected, given<br>&gt; the proposal omitting the other operators in the protocols:<br>&gt;<br>&gt; Dave Abrahams wrote:<br>&gt;<br>&gt; &gt;&gt; In order to have an opinion on whether or not this is justified, I<br>&gt; &gt;&gt; need to know more about how areSame() may differ from == and how this<br>&gt; &gt;&gt; will affect generic code. What is required that could not fit inside<br>&gt; &gt;&gt; an override of Equatable?<br>&gt; &gt;<br>&gt; &gt; Floating point types.  You should be able to ask for<br>&gt; &gt; arrayOfFloats.firstIndex(of: x) even if there are NaNs in the array (or<br>&gt; &gt; x).<br>&gt;<br>&gt; Given that func firstIndex&lt;T : Equatable&gt;(of value: T) dispatches on<br>&gt; Equatable, it would use Double.areSame(_:_:) instead of the IEEE-754<br>&gt; Double.==(_:_:). While that sounds innocuous, it would cause surprising<br>&gt; results in the presense of negative zero:<br>&gt;<br>&gt;     [-0.0, 1.0, .nan, 0.0].firstIndex(of: 0.0)<br>&gt;     //=&gt; 3, not 0<br>&gt;<br></p><p>I just assumed that the core team&#39;s vision was that this would be addressed<br>by a domain-specific floating point `areSame(a: Self, b: Self) -&gt; Bool {<br>return (a == 0 &amp;&amp; b == 0) || (a &lt;=&gt; b) == .same }`. This is a valid<br>equivalence relation afaik.<br></p><p><br>&gt; which almost definitely isn&#39;t what the caller would want. Instead,<br>&gt; functions like these should clearly document (or it should be obvious from<br>&gt; their semantics) whether they use == and &lt; (etc), or &lt;=&gt; in their<br>&gt; implementation. I think that is a reasonable price to pay.<br>&gt;<br>&gt; Or am I missing something obvious about round pegs and square holes?<br>&gt;<br>&gt; — Pyry<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/d569d71f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>July 22, 2016 at 11:00:00pm</p></header><div class="content"><p>Xiaodi Wu wrote:<br></p><p>&gt; I just assumed that the core team&#39;s vision was that this would be addressed by a domain-specific floating point `areSame(a: Self, b: Self) -&gt; Bool { return (a == 0 &amp;&amp; b == 0) || (a &lt;=&gt; b) == .same }`. This is a valid equivalence relation afaik.<br></p><p>I guess so, but it&#39;s a different from what Dmitri gave here:<br></p><p>&gt;&gt; 7. What, in fact, is the proposed total order for the stdlib&#39;s floating-point types?<br>&gt; <br>&gt; The IEEE 754 definition.<br>&gt; <br>&gt; https://github.com/apple/swift/blob/f318fe853d7898246db24d501f1ddc03c9eb8651/stdlib/public/core/FloatingPoint.swift.gyb#L855<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160722/8c2b880c/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d53b7c5f9b5f5557b9082face9b632a0?s=50"></div><header><strong>[Draft][Proposal] Formalized Ordering</strong> from <string>Dave Abrahams</string> &lt;dabrahams at apple.com&gt;<p>July 22, 2016 at 01:00:00pm</p></header><div class="content"><p>on Fri Jul 22 2016, Xiaodi Wu &lt;xiaodi.wu-AT-gmail.com&gt; wrote:<br></p><p>&gt; On Fri, Jul 22, 2016 at 2:26 PM, Pyry Jahkola via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I agree with Tony that we should still keep == and != as part of<br>&gt;&gt; Equatable, and&lt;, &lt;=, &gt;, and &gt;= as part of Comparable, while offering<br>&gt;&gt; default implementations through &lt;=&gt;.<br>&gt;&gt;<br>&gt;&gt; The reason is, that otherwise generic code would dispatch differently<br>&gt;&gt; depending on the generic constraint; &lt;T : Comparable&gt; would only see the<br>&gt;&gt; operators using &lt;=&gt; while &lt;T : FloatingPoint&gt; would pick up the IEEE-754<br>&gt;&gt; versions, even if in both cases T were Double.<br>&gt;&gt;<br>&gt;&gt; Below is a concrete example where things wouldn&#39;t work as expected, given<br>&gt;&gt; the proposal omitting the other operators in the protocols:<br>&gt;&gt;<br>&gt;&gt; Dave Abrahams wrote:<br>&gt;&gt;<br>&gt;&gt; &gt;&gt; In order to have an opinion on whether or not this is justified, I<br>&gt;&gt; &gt;&gt; need to know more about how areSame() may differ from == and how this<br>&gt;&gt; &gt;&gt; will affect generic code. What is required that could not fit inside<br>&gt;&gt; &gt;&gt; an override of Equatable?<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Floating point types.  You should be able to ask for<br>&gt;&gt; &gt; arrayOfFloats.firstIndex(of: x) even if there are NaNs in the array (or<br>&gt;&gt; &gt; x).<br>&gt;&gt;<br>&gt;&gt; Given that func firstIndex&lt;T : Equatable&gt;(of value: T) dispatches on<br>&gt;&gt; Equatable, it would use Double.areSame(_:_:) instead of the IEEE-754<br>&gt;&gt; Double.==(_:_:). While that sounds innocuous, it would cause surprising<br>&gt;&gt; results in the presense of negative zero:<br>&gt;&gt;<br>&gt;&gt;     [-0.0, 1.0, .nan, 0.0].firstIndex(of: 0.0)<br>&gt;&gt;     //=&gt; 3, not 0<br>&gt;&gt;<br>&gt;<br>&gt; I just assumed that the core team&#39;s vision was that this would be addressed<br>&gt; by a domain-specific floating point `areSame(a: Self, b: Self) -&gt; Bool {<br>&gt; return (a == 0 &amp;&amp; b == 0) || (a &lt;=&gt; b) == .same }`. This is a valid<br>&gt; equivalence relation afaik.<br></p><p>IEEE-754 specifies a standard equivalence relation that we&#39;d use for<br>this.<br></p><p>&gt;&gt; which almost definitely isn&#39;t what the caller would want. Instead,<br>&gt;&gt; functions like these should clearly document (or it should be obvious from<br>&gt;&gt; their semantics) whether they use == and &lt; (etc), or &lt;=&gt; in their<br>&gt;&gt; implementation. I think that is a reasonable price to pay.<br>&gt;&gt;<br>&gt;&gt; Or am I missing something obvious about round pegs and square holes?<br>&gt;&gt;<br>&gt;&gt; — Pyry<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br></p><p>-- <br>Dave<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
