<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/ad759d1806c218eb2f2b68034c9c28b0?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>John Myers</string> &lt;myersj at shawanoschools.com&gt;<p>May 18, 2016 at 05:00:00pm</p></header><div class="content"><p>I&#39;ve been having trouble figuring out how to read and write data to a<br>textfile, and not finding much out there for Swift on Linux.  I found code<br>for reading data from a file on StackOverflow that works for me, but<br>cludged together my own code for writing to a file.  I&#39;m not sure exactly<br>what I&#39;m doing, but am making some progress.  Can anyone point me toward a<br>good source of help for reading and writing data in Swift on Linux.  Thanks!<br></p><p>This is the code that I found that works for reading data:<br></p><p>//  Try to read from a file<br></p><p>//  5/16/2016<br></p><p>import Glibc  //import a Linux library<br></p><p>let path = &quot;Resources/sampleIn.txt&quot;<br></p><p>let BUFSIZE = 1024<br></p><p>print(&quot;attempting to open a file for input&quot;)<br></p><p>let fp = fopen(path, &quot;r&quot;)<br></p><p>if fp == nil {print(&quot;error reading file&quot;)}<br></p><p>if fp != nil {<br></p><p> print(&quot;reading...&quot;)<br></p><p> var buf = [CChar](count:BUFSIZE, repeatedValue:CChar(0))<br></p><p> while fgets(&amp;buf, Int32(BUFSIZE), fp) != nil {<br></p><p>   print(String.fromCString(buf)!, terminator:&quot;&quot;)<br></p><p> }<br></p><p>}<br></p><p><br>This is the code I pieced together for writing data:<br></p><p>import Glibc  //import a Linux library<br>let path = &quot;Resources/sampleOut.txt&quot;let BUFSIZE =<br>1024print(&quot;attempting to open a file for Output&quot;)let fp = fopen(path,<br>&quot;w+&quot;)if fp == nil {print(&quot;error writing file&quot;)}if fp != nil {<br>  print(&quot;Type a few words to be saved to a file&quot;)<br>  var fewWords=readLine()!<br>  fputs(fewWords,fp)<br>  print(&quot;writing...&quot;)<br>  }<br>fclose(fp)<br></p><p><br>Any help would be appreciated.<br>Thanks!<br>John<br></p><p>-- <br>John Myers<br>Mathematics and Computer Science Teacher<br></p><p>------------------------------------------------------------------<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160518/aeb4d1f6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>May 19, 2016 at 08:00:00am</p></header><div class="content"><p>On 18 May 2016, at 23:02, John Myers via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ve been having trouble figuring out how to read and write data to a textfile …<br></p><p>Your examples show you transferring the data line-by-line.  Is that the end goal?  Or just fallout from what you happened to get working?<br></p><p>The reason I ask is that most of the time when I mess around with files I transfer the entire file to and from memory, which is something that the Foundation APIs excel at.  OTOH, there are times when line-by-line is necessary.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 19, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On May 19, 2016, at 12:58 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; The reason I ask is that most of the time when I mess around with files I transfer the entire file to and from memory, which is something that the Foundation APIs excel at.<br></p><p>I believe Mac/iOS developers usually transfer the entire file because that’s the particular hammer that Foundation provides. For some reason Foundation has never had good stream APIs (and they used to be worse!), so it’s much more convenient to just use NSData or NSString methods to read and write the entire file, than it is to mess around with NSFileHandle or NSStream.<br></p><p>Conversely, most other platforms (certainly C/POSIX and Java) make it easier to stream the file (which I believe is more efficient; certainly more scalable) than to block-read/write it.<br></p><p>I’m hoping that the Swift translation of Foundation provides greatly-improved Stream classes.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160519/40f98c96/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>May 20, 2016 at 09:00:00am</p></header><div class="content"><p>On 19 May 2016, at 17:38, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt; I believe Mac/iOS developers usually transfer the entire file because that’s the particular hammer that Foundation provides.<br></p><p>I disagree.  One-shot file system APIs make sense for a lot of reasons:<br></p><p>* It’s generally easier to use.  Consider NSXMLDocument vs NSXMLParser (-:<br></p><p>* It composes well.  Consider the NSXMLDocument example again.  This high-level one-shot API is layered on top of a low-level one-shot API.  Which isn’t to say that you can’t build streaming APIs on top of other streaming APIs, but it’s not exactly easy, and you end up having to build the one-shot ‘convenience’ API anyway.<br></p><p>* It’s atomic on write; other folks looking at the file system never see ‘half’ the file.<br></p><p>* It radically reduces the state space of the API.  When you read a file with a one-shot API, you only have to deal with one possible error.  When you stream through a file, you can get an error at any point.<br></p><p>One of the nice things about the file system is that it has reasonable performance and error characteristics such that you /can/ deal with it synchronously.  Revel in that fact!<br></p><p>I generally find myself streaming through a file only when I’m dealing with some sort of I/O pipeline, which is the exception rather than the rule.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/72853d2b57e37aab89afe61af4f74c62?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Maury Markowitz</string> &lt;maury.markowitz at gmail.com&gt;<p>May 20, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 4:16 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; I disagree.  One-shot file system APIs make sense for a lot of reasons:<br></p><p>I do most of my programming in .Net, where streams are the primary IO system. Even simple tasks often require multiple objects and loops copying data between them. Limitations in the API and in the implementations layer on complexity.<br></p><p>I relish whenever I have to do IO on the Mac using the one-shot API. A single line of code almost always accomplishes what I want, and the API is perfectly clear on what it&#39;s doing.<br></p><p>&gt; I generally find myself streaming through a file only when I’m dealing with some sort of I/O pipeline, which is the exception rather than the rule.<br></p><p>Indeed, and in these domain&#39;s it&#39;s an excellent conceptual platform to work in. But as the *primary* API it&#39;s a wonderful example of distributed cost.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f0c42759e3b302ee8b0665d8b59c1197?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Gerard Iglesias</string> &lt;gerard_iglesias at me.com&gt;<p>May 20, 2016 at 02:00:00pm</p></header><div class="content"><p>Hello<br></p><p>Interesting question<br></p><p>From my point of view, I want to parse a huge file without loading it in memory...<br></p><p>Maybe something worth the reading <br></p><p> https://developer.apple.com/library/ios/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/TechniquesforReadingandWritingCustomFiles/TechniquesforReadingandWritingCustomFiles.html<br></p><p>Gérard <br></p><p>Le 20 mai 2016 à 13:59, Maury Markowitz via swift-users &lt;swift-users at swift.org&gt; a écrit :<br></p><p>&gt;&gt; On May 20, 2016, at 4:16 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt;&gt; I disagree.  One-shot file system APIs make sense for a lot of reasons:<br>&gt; <br>&gt; I do most of my programming in .Net, where streams are the primary IO system. Even simple tasks often require multiple objects and loops copying data between them. Limitations in the API and in the implementations layer on complexity.<br>&gt; <br>&gt; I relish whenever I have to do IO on the Mac using the one-shot API. A single line of code almost always accomplishes what I want, and the API is perfectly clear on what it&#39;s doing.<br>&gt; <br>&gt;&gt; I generally find myself streaming through a file only when I’m dealing with some sort of I/O pipeline, which is the exception rather than the rule.<br>&gt; <br>&gt; Indeed, and in these domain&#39;s it&#39;s an excellent conceptual platform to work in. But as the *primary* API it&#39;s a wonderful example of distributed cost.<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 20, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 1:16 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; One of the nice things about the file system is that it has reasonable performance and error characteristics such that you /can/ deal with it synchronously.  Revel in that fact!<br></p><p>That’s only really true at small scales, for local filesystems, under light I/O loads. This happens to be true most of the time* for typical Mac/iOS app needs, but it’s not universal.<br></p><p>I believe most people in the Swift community today come from a Mac/iOS background, but as Linux support matures, and with IBM’s backing, that’s going to be less and less true in the future. Me, I’m one of the oddball “mobile guys” at a database company [Couchbase] whose customers [eBay, PayPal, Citi, etc.] very commonly have multi-terabyte data sets.<br></p><p>&gt; Consider the NSXMLDocument example again.  This high-level one-shot API is layered on top of a low-level one-shot API.<br></p><p>The trouble with this is that those one-shot APIs tend to suck when working with data coming from the network, because you have to buffer the entire data set in memory, and you can’t start parsing it until the entire response is finished. If it does finish — there are protocols like XMPP/Jabber that use indefinitely-long streams of structured data like XML and can’t be parsed at all with one-shot APIs. I’ve recently had to replace NSJSONSerialization with a 3rd-party streaming JSON parser library, because the latency of reading large JSON documents over HTTP was getting in the way of performance and memory requirements.<br></p><p>Sorry if this is off-topic! What’s relevant is that I’d hate to see Apple’s historical bias toward one-shot I/O get in the way of Swift’s Foundation framework having a kick-ass stream API.<br></p><p>—Jens<br></p><p>* But not always. I can attest that during OS startup, when dozens of processes are contending for the disk, reading a 10MB file can take an achingly long time by normal standards. This caused lots of “fun” during performance tuning of the PubSub framework. Also, remember the days when devs at Apple still had NFS-based home directories?<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160520/2d8422a4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 10:47 AM, Jens Alfke via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 20, 2016, at 1:16 AM, Quinn The Eskimo! via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; One of the nice things about the file system is that it has reasonable performance and error characteristics such that you /can/ deal with it synchronously.  Revel in that fact!<br>&gt; <br>&gt; That’s only really true at small scales, for local filesystems, under light I/O loads. This happens to be true most of the time* for typical Mac/iOS app needs, but it’s not universal.<br>&gt; <br>&gt; I believe most people in the Swift community today come from a Mac/iOS background, but as Linux support matures, and with IBM’s backing, that’s going to be less and less true in the future. Me, I’m one of the oddball “mobile guys” at a database company [Couchbase] whose customers [eBay, PayPal, Citi, etc.] very commonly have multi-terabyte data sets.<br></p><p>Couchbase looks like a great product.  Cool to see someone from Couchbase is participating in Swift evolution!<br></p><p>&gt; <br>&gt;&gt; Consider the NSXMLDocument example again.  This high-level one-shot API is layered on top of a low-level one-shot API.<br>&gt; <br>&gt; The trouble with this is that those one-shot APIs tend to suck when working with data coming from the network, because you have to buffer the entire data set in memory, and you can’t start parsing it until the entire response is finished. If it does finish — there are protocols like XMPP/Jabber that use indefinitely-long streams of structured data like XML and can’t be parsed at all with one-shot APIs. I’ve recently had to replace NSJSONSerialization with a 3rd-party streaming JSON parser library, because the latency of reading large JSON documents over HTTP was getting in the way of performance and memory requirements.<br>&gt; <br>&gt; Sorry if this is off-topic! What’s relevant is that I’d hate to see Apple’s historical bias toward one-shot I/O get in the way of Swift’s Foundation framework having a kick-ass stream API.<br></p><p>+1.  There are many reasons to prefer streaming implementations.  It is also possible to write high-level APIs with relatively simple interfaces that use streaming behind the scenes.  The fact that this is not always done is not a good argument against providing robust streaming APIs.  In fact, it should be considered a challenge to improve the state of the art.<br></p><p>For example, I shared an example of a Ruby DSL I wrote that generated streaming XML parsers (in an Objective-C API and some C in the implementation) from the DSL which defined the structure of the document and how it maps to model objects.  This was much easier to use than any DOM-based API (whether XML, JSON, or whatever) and was more efficient.  It did not require the entire document to be in memory at once and did not construct all kinds of intermediate objects not needed by the model (dictionaries and arrays, etc).  <br></p><p>If / when Swift gets macros we should be able to implement something very similar directly in Swift without needing an intermediate code generation step.  It may also be possible to do this a better way in Swift.  <br></p><p>The main point I am making here is that taking advantage of the benefits of streaming APIs does not need to be difficult at the application level. <br></p><p>&gt; <br>&gt; —Jens<br>&gt; <br>&gt; * But not always. I can attest that during OS startup, when dozens of processes are contending for the disk, reading a 10MB file can take an achingly long time by normal standards. This caused lots of “fun” during performance tuning of the PubSub framework. Also, remember the days when devs at Apple still had NFS-based home directories?<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160520/2379a2f1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/26b79a145193358c02392e186dccaaf2?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Jan Neumüller</string> &lt;nasan at slayers.de&gt;<p>May 20, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; +1.  There are many reasons to prefer streaming implementations.  It is also possible to write high-level APIs with relatively simple interfaces that use streaming behind the scenes.  The fact that this is not always done is not a good argument against providing robust streaming APIs.  In fact, it should be considered a challenge to improve the state of the art.<br>&gt; <br></p><p>What advantage? Streaming IO is a pain in the ****. I never got what people like at this stuff - Even in my windows days I always used the much better memory mapped file IO. Is streaming IO some kind of C/C++ sickness like macros and templates?<br></p><p>greets, Jan<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>May 20, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On May 20, 2016, at 9:44 AM, Jan Neumüller via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; What advantage? Streaming IO is a pain in the ****. I never got what people like at this stuff<br></p><p>Well for one, it abstracts away the source of the data. It could be a file, a TCP socket, an HTTP body, the output of another algorithm like a GZip codec, the output of another process. One of the big innovations of Unix was the ability to build small tools and chain them together using pipes.<br></p><p>&gt; Even in my windows days I always used the much better memory mapped file IO. <br></p><p>Memory mapping is great, but it has limitations and pitfalls.<br>* You can only use it on filesystems that can’t be unmounted, otherwise if the filesystem disconnects, accessing the memory will crash.<br>* It ties up a file descriptor for as long as you need to use the data. File descriptors are a limited resource.<br>* It requires having contiguous free address space equal to the size of the file. I have seen this cause real-world failures in 32-bit processes.<br>* I’m told that iOS limits the amount of memory-mapped address space an app can allocate, even if it’s a 64-bit process. (I have been meaning to test whether this is actually true.)<br></p><p>&gt; Is streaming IO some kind of C/C++ sickness like macros and templates?<br></p><p>This isn’t a Playstation-vs-Xbox debate. The mature developer understands that everything has pros and cons.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160520/32a30231/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>May 23, 2016 at 09:00:00am</p></header><div class="content"><p>On 18 May 2016, at 23:02, John Myers via swift-users &lt;swift-users at swift.org&gt; wrote:<br></p><p>&gt; I&#39;ve been having trouble figuring out how to read and write data to a textfile, and not finding much out there for Swift on Linux.<br></p><p>Sorry about being complicit in the one-shot vs streaming I/O diversion.  It’s true that Swift’s streaming I/O story is in flux and I’m sure that Jens and co. will have fun designing its replacement, but right now I’d kinda like to bring this back to the original question.<br></p><p>Below is a snippet that shows how to process a file line-by-line using Foundation APIs.  As you can see, if you’re just trying to runs simple tests on the lines in a text file, doing this with Foundation is much easier than doing it with the current lower-level APIs.<br></p><p>---------------------------------------------------------------------------<br>import Foundation<br></p><p>func quoteFile(atPath filePath: String) throws {<br>    let input = try NSString(contentsOfFile: filePath, encoding: NSUTF8StringEncoding)<br>    let inputLines = input.components(separatedBy: &quot;\n&quot;)<br>    var outputLines: [String] = []<br>    for line in inputLines {<br>        let newLine = &quot;&gt; &quot; + line<br>        outputLines.append(newLine)<br>    }<br>    let output = outputLines.joined(separator: &quot;\n&quot;)<br>    try output.write(toFile: filePath, atomically: true, encoding: NSUTF8StringEncoding)<br>}<br></p><p>try! quoteFile(atPath: &quot;/Users/quinn/victim.txt&quot;)<br>---------------------------------------------------------------------------<br></p><p>I tested this on OS X (don’t have Linux set up, sorry) with the “2016-05-09 (a)” Swift development snapshot.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/239470edb218dd1168e72a50b3ac0a00?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Matthias Zenger</string> &lt;matthias at objecthub.net&gt;<p>June  5, 2016 at 03:00:00am</p></header><div class="content"><p>Quinn, thanks for the example. I agree that Foundation makes it easier by<br>loading the data fully into memory. I still don&#39;t understand if it&#39;s<br>currently actually *possible* to use non C-based solutions in Swift which<br>use streaming. I wanted to use NSFileHandle (for a use case that requires<br>streaming) and realized that this is an API that cannot really be used in<br>Swift because it&#39;s based on Objective-C exceptions. Are there any<br>alternatives?<br></p><p>Thanks,<br>  Matthias<br></p><p><br></p><p>*Matthias Zenger* matthias at objecthub.net<br></p><p><br>On Mon, May 23, 2016 at 10:24 AM, Quinn &quot;The Eskimo!&quot; via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On 18 May 2016, at 23:02, John Myers via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt; I&#39;ve been having trouble figuring out how to read and write data to a<br>&gt; textfile, and not finding much out there for Swift on Linux.<br>&gt;<br>&gt; Sorry about being complicit in the one-shot vs streaming I/O diversion.<br>&gt; It’s true that Swift’s streaming I/O story is in flux and I’m sure that<br>&gt; Jens and co. will have fun designing its replacement, but right now I’d<br>&gt; kinda like to bring this back to the original question.<br>&gt;<br>&gt; Below is a snippet that shows how to process a file line-by-line using<br>&gt; Foundation APIs.  As you can see, if you’re just trying to runs simple<br>&gt; tests on the lines in a text file, doing this with Foundation is much<br>&gt; easier than doing it with the current lower-level APIs.<br>&gt;<br>&gt; ---------------------------------------------------------------------------<br>&gt; import Foundation<br>&gt;<br>&gt; func quoteFile(atPath filePath: String) throws {<br>&gt;     let input = try NSString(contentsOfFile: filePath, encoding:<br>&gt; NSUTF8StringEncoding)<br>&gt;     let inputLines = input.components(separatedBy: &quot;\n&quot;)<br>&gt;     var outputLines: [String] = []<br>&gt;     for line in inputLines {<br>&gt;         let newLine = &quot;&gt; &quot; + line<br>&gt;         outputLines.append(newLine)<br>&gt;     }<br>&gt;     let output = outputLines.joined(separator: &quot;\n&quot;)<br>&gt;     try output.write(toFile: filePath, atomically: true, encoding:<br>&gt; NSUTF8StringEncoding)<br>&gt; }<br>&gt;<br>&gt; try! quoteFile(atPath: &quot;/Users/quinn/victim.txt&quot;)<br>&gt; ---------------------------------------------------------------------------<br>&gt;<br>&gt; I tested this on OS X (don’t have Linux set up, sorry) with the<br>&gt; “2016-05-09 (a)” Swift development snapshot.<br>&gt;<br>&gt; Share and Enjoy<br>&gt; --<br>&gt; Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>&gt; Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160605/b0107926/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>June  5, 2016 at 10:00:00am</p></header><div class="content"><p>On 5 Jun 2016, at 02:25, Matthias Zenger &lt;matthias at objecthub.net&gt; wrote:<br></p><p>&gt; I still don&#39;t understand if it&#39;s currently actually *possible* to use non C-based solutions in Swift which use streaming. I wanted to use NSFileHandle (for a use case that requires streaming) and realized that this is an API that cannot really be used in Swift because it&#39;s based on Objective-C exceptions.<br></p><p>Ah, yes, that’s definitely something you should be wary of.  I don’t know what the plan is for getting NSFileHandle to play nicely with Swift.  Maybe someone else will chime in.<br></p><p>&gt; Are there any alternatives?<br></p><p>You could always use NSStream.<br></p><p>However, building Swift code on top of NSStream is about as difficult as building it on top of UNIX system calls (open/close/read/write) or stdio (fopen/fclose/fread/fwrite), so if you need streaming file I/O you might as well do that.<br></p><p>Give it a go and let us know if you get stuck.<br></p><p>Finally, as has been mentioned on this thread already, it’s easy to imagine a Swift streaming file I/O that’s /much/ better than these options, although AFAIK there are no concrete plans for that.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>June  5, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jun 4, 2016, at 6:25 PM, Matthias Zenger via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; I wanted to use NSFileHandle (for a use case that requires streaming) and realized that this is an API that cannot really be used in Swift because it&#39;s based on Objective-C exceptions.<br></p><p>You’re right, NSFileHandle is a very archaic class (kind of a coelacanth) and its I/O methods signal errors by throwing exceptions. It’s almost unique in that regard; in general Cocoa APIs are only supposed to throw exceptions for programmer errors like assertion failures.<br></p><p>&gt; Are there any alternatives?<br></p><p>NSStream.<br></p><p>—Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160605/0b7e7ed1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/239470edb218dd1168e72a50b3ac0a00?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Matthias Zenger</string> &lt;matthias at objecthub.net&gt;<p>June  5, 2016 at 11:00:00pm</p></header><div class="content"><p>Quinn, Jens, thanks for pointing me at the NSStream classes. For some<br>reason, I discarded NSStream quickly after seeing the first paragraph<br>of Apple&#39;s<br>documentation on output streams<br>&lt;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Streams/Articles/WritingOutputStreams.html&gt;<br>listing 5 relatively complex steps — without realizing that this API also<br>has a synchronous interface.<br></p><p>Obviously, the NSStream API is too low level and thus difficult to use.<br>Therefore, I would also like to see Apple build a great IO streaming API<br>for Swift. I&#39;ve implemented Quinn&#39;s example using NSInputStream and Swift&#39;s<br>Generator design pattern. Except for mapping NSInputStream to a generator —<br>which is really messy — everything else is straightforward and much more<br>extensible and scalable than the standard Foundation approach. The code is<br>below.<br></p><p>== Matthias<br></p><p>See https://gist.github.com/objecthub/ada1f852924b2c253653d6949fd3555d<br></p><p>class ByteGenerator: GeneratorType {<br></p><p>  typealias Element = UInt8<br></p><p>  let input: NSInputStream<br></p><p>  var buffer: [UInt8]<br></p><p>  var index: Int = 0<br></p><p>  var eof: Bool = true<br></p><p>  init?(path: String, capacity: Int = 1024) {<br></p><p>    guard let input = NSInputStream(fileAtPath: path) else {<br></p><p>      return nil<br></p><p>    }<br></p><p>    self.buffer = [UInt8](count: capacity, repeatedValue: 0)<br></p><p>    input.open()<br></p><p>    if input.hasBytesAvailable {<br></p><p>      self.eof = input.read(&amp;self.buffer, maxLength: self.buffer.count *<br>sizeof(UInt8)) &lt;= 0<br></p><p>    }<br></p><p>    self.input = input<br></p><p>  }<br></p><p>  deinit {<br></p><p>    input.close()<br></p><p>  }<br></p><p>  func next() -&gt; UInt8? {<br></p><p>    guard !self.eof else {<br></p><p>      return nil<br></p><p>    }<br></p><p>    if self.index &gt;= self.buffer.count {<br></p><p>      self.index = 0<br></p><p>      self.eof = !input.hasBytesAvailable ||<br></p><p>                 input.read(&amp;self.buffer, maxLength: self.buffer.count *<br>sizeof(UInt8)) &lt;= 0<br></p><p>      guard !self.eof else {<br></p><p>        return nil<br></p><p>      }<br></p><p>    }<br></p><p>    self.index += 1<br></p><p>    return self.buffer[self.index - 1]<br></p><p>  }<br></p><p>}<br></p><p><br>struct CharacterGenerator&lt;G: GeneratorType, U: UnicodeCodecType where<br>G.Element == U.CodeUnit&gt;: GeneratorType {<br></p><p>  typealias Element = Character<br></p><p>  var source: G<br></p><p>  var decoder: U<br></p><p>  mutating func next() -&gt; Character? {<br></p><p>    guard case .Result(let scalar) = self.decoder.decode(&amp;self.source) else<br>{<br></p><p>      return nil<br></p><p>    }<br></p><p>    return Character(scalar)<br></p><p>  }<br></p><p>}<br></p><p><br>struct LineGenerator&lt;G: GeneratorType where G.Element == Character&gt;:<br>GeneratorType {<br></p><p>  typealias Element = String<br></p><p>  var source: G<br></p><p>  mutating func next() -&gt; String? {<br></p><p>    guard let fst = source.next() else {<br></p><p>      return nil<br></p><p>    }<br></p><p>    guard fst != &quot;\n&quot; else {<br></p><p>      return &quot;&quot;<br></p><p>    }<br></p><p>    var line = String(fst)<br></p><p>    while let ch = source.next() {<br></p><p>      if (ch == &quot;\n&quot;) {<br></p><p>        return line<br></p><p>      }<br></p><p>      line.append(ch)<br></p><p>    }<br></p><p>    return line<br></p><p>  }<br></p><p>}<br></p><p><br>if let input = ByteGenerator(path: &quot;/Users/username/filename.txt&quot;) {<br></p><p>  var generator = LineGenerator(source: CharacterGenerator(source: input,<br>decoder: UTF8()))<br></p><p>  var i = 0<br></p><p>  while let line = generator.next() {<br></p><p>    print(&quot;\(i): \(line)&quot;)<br></p><p>    i += 1<br></p><p>  }<br></p><p>}<br></p><p><br></p><p><br></p><p><br></p><p>*Matthias Zenger* matthias at objecthub.net<br></p><p><br>On Sun, Jun 5, 2016 at 8:36 PM, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 4, 2016, at 6:25 PM, Matthias Zenger via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt; I wanted to use NSFileHandle (for a use case that requires streaming) and<br>&gt; realized that this is an API that cannot really be used in Swift because<br>&gt; it&#39;s based on Objective-C exceptions.<br>&gt;<br>&gt;<br>&gt; You’re right, NSFileHandle is a very archaic class (kind of a coelacanth)<br>&gt; and its I/O methods signal errors by throwing exceptions. It’s almost<br>&gt; unique in that regard; in general Cocoa APIs are only supposed to throw<br>&gt; exceptions for programmer errors like assertion failures.<br>&gt;<br>&gt; Are there any alternatives?<br>&gt;<br>&gt;<br>&gt; NSStream.<br>&gt;<br>&gt; —Jens<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160605/f4cc73fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>June  5, 2016 at 03:00:00pm</p></header><div class="content"><p>Looks good, but you&#39;ll want some error handling. There&#39;s no clean way to integrate it with Generator because the protocol doesn&#39;t allow the implementation to throw, unfortunately. (I&#39;ve run into the same problem building a Generator around a database query.) I think the best solution is to add a property that returns the NSStream.streamError, or a checkError() method that throws the current error if any, and have the caller use those at the end of the iteration.<br></p><p>--Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160605/94b67dfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  5, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Looks good, but you&#39;ll want some error handling. There&#39;s no clean way to integrate it with Generator because the protocol doesn&#39;t allow the implementation to throw, unfortunately. (I&#39;ve run into the same problem building a Generator around a database query.) I think the best solution is to add a property that returns the NSStream.streamError, or a checkError() method that throws the current error if any, and have the caller use those at the end of the iteration.<br></p><p>You can do better.<br></p><p>	extension NSInputStream {<br>		// I will assume you already have a byteGenerator method (which you can use with a for loop)<br>		// with a checkError() method (which throws if the generation terminated due to an error). However, <br>		// you&#39;ve made these private, and will use them to implement this safe public API.<br>		public func withByteGenerator&lt;R&gt;(blockSize: Int = 1024, iterate: @noescape (NSInputStream.ByteGenerator) throws -&gt; R) throws -&gt; R {<br>			let generator = byteGenerator(blockSize: blockSize)<br>			let result = iterate(generator)<br>			try generator.checkError()<br>			return result<br>		}<br>	}<br></p><p>Now you write:<br></p><p>	guard let stream = NSInputStream(fileAtPath: path) else {<br>		…<br>	}<br>	try stream.withByteGenerator {<br>		// XXX This would all be more complicated if CharacterGenerator can throw, too.<br>		for (i, line) in LineGenerator(source: CharacterGenerator(source: $0, decoder: UTF8())).enumerate() {<br>			print(&quot;\(i+1): \(line)&quot;)<br>		}<br>	}<br></p><p>(I&#39;m assuming that these generators take their almost-automatic Sequence conformance, of course.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/239470edb218dd1168e72a50b3ac0a00?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Matthias Zenger</string> &lt;matthias at objecthub.net&gt;<p>June  6, 2016 at 02:00:00am</p></header><div class="content"><p>Yes, error reporting is missing (errors are treated like EOF), but your<br>proposal breaks encapsulation. By not making `NSInputStream` a hidden<br>implementation detail, you make it possible for clients to interfere with<br>the caching logic (e.g. by directly invoking `read`, or prematurely closing<br>the steam).<br></p><p>== Matthias<br></p><p><br></p><p>*Matthias Zenger* matthias at objecthub.net<br></p><p><br>On Mon, Jun 6, 2016 at 1:49 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>wrote:<br></p><p>&gt; &gt; Looks good, but you&#39;ll want some error handling. There&#39;s no clean way to<br>&gt; integrate it with Generator because the protocol doesn&#39;t allow the<br>&gt; implementation to throw, unfortunately. (I&#39;ve run into the same problem<br>&gt; building a Generator around a database query.) I think the best solution is<br>&gt; to add a property that returns the NSStream.streamError, or a checkError()<br>&gt; method that throws the current error if any, and have the caller use those<br>&gt; at the end of the iteration.<br>&gt;<br>&gt; You can do better.<br>&gt;<br>&gt;         extension NSInputStream {<br>&gt;                 // I will assume you already have a byteGenerator method<br>&gt; (which you can use with a for loop)<br>&gt;                 // with a checkError() method (which throws if the<br>&gt; generation terminated due to an error). However,<br>&gt;                 // you&#39;ve made these private, and will use them to<br>&gt; implement this safe public API.<br>&gt;                 public func withByteGenerator&lt;R&gt;(blockSize: Int = 1024,<br>&gt; iterate: @noescape (NSInputStream.ByteGenerator) throws -&gt; R) throws -&gt; R {<br>&gt;                         let generator = byteGenerator(blockSize: blockSize)<br>&gt;                         let result = iterate(generator)<br>&gt;                         try generator.checkError()<br>&gt;                         return result<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; Now you write:<br>&gt;<br>&gt;         guard let stream = NSInputStream(fileAtPath: path) else {<br>&gt;                 …<br>&gt;         }<br>&gt;         try stream.withByteGenerator {<br>&gt;                 // XXX This would all be more complicated if<br>&gt; CharacterGenerator can throw, too.<br>&gt;                 for (i, line) in LineGenerator(source:<br>&gt; CharacterGenerator(source: $0, decoder: UTF8())).enumerate() {<br>&gt;                         print(&quot;\(i+1): \(line)&quot;)<br>&gt;                 }<br>&gt;         }<br>&gt;<br>&gt; (I&#39;m assuming that these generators take their almost-automatic Sequence<br>&gt; conformance, of course.)<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160606/9a1350f2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2bc666e29724cd3bdf46b6cbbe4a07bb?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Quinn &quot;The Eskimo!&quot;</string> &lt;eskimo1 at apple.com&gt;<p>June  6, 2016 at 08:00:00am</p></header><div class="content"><p>On 5 Jun 2016, at 11:36, Jens Alfke &lt;jens at mooseyard.com&gt; wrote:<br></p><p>&gt; It’s almost unique in that regard; in general Cocoa APIs are only supposed to throw exceptions for programmer errors like assertion failures.<br></p><p>Almost unique is right.  The only other offender I can think of is Distributed Objects, which is even less fun because any method call (including property accesses) on any proxied object can throw language exceptions.<br></p><p>Share and Enjoy<br>--<br>Quinn &quot;The Eskimo!&quot;                    &lt;http://www.apple.com/developer/&gt;<br>Apple Developer Relations, Developer Technical Support, Core OS/Hardware<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>file io in Swift 2.2 for Linux (would like to be pointed in the right direction)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>June  7, 2016 at 07:00:00am</p></header><div class="content"><p>&gt;&gt; It’s almost unique in that regard; in general Cocoa APIs are only supposed to throw exceptions for programmer errors like assertion failures.<br>&gt; <br>&gt; Almost unique is right.  The only other offender I can think of is Distributed Objects, which is even less fun because any method call (including property accesses) on any proxied object can throw language exceptions.<br></p><p>The docs only touch on it, but `-[NSTask launch]` throws an Objective-C exception &quot;if it fails to create a process&quot;, which is something which can be very difficult to prevent through ahead-of-time checks.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
