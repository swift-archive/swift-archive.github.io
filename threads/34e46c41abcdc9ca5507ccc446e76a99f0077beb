<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>I&#39;ve successfully(?) imported C enum that is defined as:<br></p><p>typedef enum fe_type {<br>  FE_QPSK,<br>  FE_QAM,<br>  FE_OFDM,<br>  FE_ATSC<br>} fe_type_t;<br></p><p>I wanted this enum to conform to `CustomStringConvertible` so I added<br>the following extension:<br></p><p>extension fe_type: CustomStringConvertible {<br>  var description: String {<br>    switch self {<br>    case .FE_QPSK: return &quot;QPSK&quot;<br>    case .FE_QAM: return &quot;QAM&quot;<br>    case .FE_OFDM: return &quot;OFDM&quot;<br>    case .FE_ATSC: return &quot;ATSC&quot;<br>    }<br>  }<br>}<br></p><p>Unfortunately this does not compile successfully. The compiler states<br>that &quot;enum case &#39;FE_QPSK&#39; not found in type &#39;fe_type&#39;&quot; (and repeats for<br>all the cases). Does that mean that fe_type is _NOT_ an enum in Swift?<br>If it is how can I determine what Swift imported the case names as?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in Swift). I think if you want it to be imported as an enum you need to use the NS_ENUM macro in the definition, which might not be possible in your case.<br></p><p>Austin<br></p><p>&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; typedef enum fe_type {<br>&gt;  FE_QPSK,<br>&gt;  FE_QAM,<br>&gt;  FE_OFDM,<br>&gt;  FE_ATSC<br>&gt; } fe_type_t;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160110/194f90ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Austin,<br></p><p>I guess I should say that the `typedef` is coming from a Linux kernel<br>header[1]. So I don&#39;t think I&#39;m going to be able to add any macros to<br>the definition.<br></p><p>What do you mean about alt-click? Alt click where?<br></p><p>On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in<br>&gt; Swift). I think if you want it to be imported as an enum you need to<br>&gt; use the NS_ENUM macro in the definition, which might not be possible<br>&gt; in your case.<br>&gt;<br>&gt; Austin<br>&gt;<br>&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-<br>&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; typedef enum fe_type { FE_QPSK, FE_QAM, FE_OFDM, FE_ATSC } fe_type_t;<br></p><p><br></p><p>Links:<br></p><p>  1. http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160110/6ecb24c1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>Hi Ryan,<br></p><p>Apologies, I should have been more clear. In Xcode you can alt(?)-click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in the IDE to pop up a little window that shows you the definition, including the type and some other information. If you&#39;re on a Linux box or not using an IDE you probably don&#39;t have that option.<br></p><p>The only methods I see exposed on the Swift imported type are initializers taking a integer raw value, and a &#39;rawValue&#39; property for getting back out the raw value. Hope that helps.<br></p><p>Austin<br></p><p>&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; Austin,<br>&gt;  <br>&gt; I guess I should say that the `typedef` is coming from a Linux kernel header &lt;http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2&gt;. So I don&#39;t think I&#39;m going to be able to add any macros to the definition.<br>&gt;  <br>&gt; What do you mean about alt-click? Alt click where?<br>&gt;  <br>&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in Swift). I think if you want it to be imported as an enum you need to use the NS_ENUM macro in the definition, which might not be possible in your case.<br>&gt;&gt;  <br>&gt;&gt; Austin<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; typedef enum fe_type {<br>&gt;&gt;&gt;  FE_QPSK,<br>&gt;&gt;&gt;  FE_QAM,<br>&gt;&gt;&gt;  FE_OFDM,<br>&gt;&gt;&gt;  FE_ATSC<br>&gt;&gt;&gt; } fe_type_t;<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160110/869f023b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>January 10, 2016 at 01:00:00pm</p></header><div class="content"><p>I spoke too soon, the cases are also defined as values of that type. So, a working version of your code:<br></p><p>extension fe_type : CustomStringConvertible {<br>  public var description: String {<br>    switch self {<br>    case FE_QPSK: return &quot;QPSK&quot;<br>    case FE_QAM: return &quot;QAM&quot;<br>    case FE_OFDM: return &quot;OFDM&quot;<br>    case FE_ATSC: return &quot;ATSC&quot;<br>    default: fatalError(&quot;can&#39;t be exhaustive&quot;)<br>    }<br>  }<br>}<br></p><p>Best,<br>Austin<br></p><p>&gt; On Jan 10, 2016, at 1:22 PM, Austin Zheng &lt;austinzheng at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hi Ryan,<br>&gt; <br>&gt; Apologies, I should have been more clear. In Xcode you can alt(?)-click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in the IDE to pop up a little window that shows you the definition, including the type and some other information. If you&#39;re on a Linux box or not using an IDE you probably don&#39;t have that option.<br>&gt; <br>&gt; The only methods I see exposed on the Swift imported type are initializers taking a integer raw value, and a &#39;rawValue&#39; property for getting back out the raw value. Hope that helps.<br>&gt; <br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Austin,<br>&gt;&gt;  <br>&gt;&gt; I guess I should say that the `typedef` is coming from a Linux kernel header &lt;http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2&gt;. So I don&#39;t think I&#39;m going to be able to add any macros to the definition.<br>&gt;&gt;  <br>&gt;&gt; What do you mean about alt-click? Alt click where?<br>&gt;&gt;  <br>&gt;&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in Swift). I think if you want it to be imported as an enum you need to use the NS_ENUM macro in the definition, which might not be possible in your case.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; typedef enum fe_type {<br>&gt;&gt;&gt;&gt;  FE_QPSK,<br>&gt;&gt;&gt;&gt;  FE_QAM,<br>&gt;&gt;&gt;&gt;  FE_OFDM,<br>&gt;&gt;&gt;&gt;  FE_ATSC<br>&gt;&gt;&gt;&gt; } fe_type_t;<br>&gt;&gt;  <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160110/d38194e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 11, 2016 at 10:00:00am</p></header><div class="content"><p>Right. This is because Swift can&#39;t tell if your enum is actually an option set, a true, non-overlapping enum, or just a set of related constants, so it picks the lowest common denominator. We currently don&#39;t have a great way to override that in headers you don&#39;t control.<br></p><p>(Heck, on non-Apple platforms we don&#39;t have a great way to do it in headers you do control; Swift is currently keying off the macro names.)<br></p><p>Jordan<br></p><p>&gt; On Jan 10, 2016, at 13:25 , Austin Zheng via swift-dev &lt;swift-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; I spoke too soon, the cases are also defined as values of that type. So, a working version of your code:<br>&gt; <br>&gt; extension fe_type : CustomStringConvertible {<br>&gt;   public var description: String {<br>&gt;     switch self {<br>&gt;     case FE_QPSK: return &quot;QPSK&quot;<br>&gt;     case FE_QAM: return &quot;QAM&quot;<br>&gt;     case FE_OFDM: return &quot;OFDM&quot;<br>&gt;     case FE_ATSC: return &quot;ATSC&quot;<br>&gt;     default: fatalError(&quot;can&#39;t be exhaustive&quot;)<br>&gt;     }<br>&gt;   }<br>&gt; }<br>&gt; <br>&gt; Best,<br>&gt; Austin<br>&gt; <br>&gt;&gt; On Jan 10, 2016, at 1:22 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Ryan,<br>&gt;&gt; <br>&gt;&gt; Apologies, I should have been more clear. In Xcode you can alt(?)-click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in the IDE to pop up a little window that shows you the definition, including the type and some other information. If you&#39;re on a Linux box or not using an IDE you probably don&#39;t have that option.<br>&gt;&gt; <br>&gt;&gt; The only methods I see exposed on the Swift imported type are initializers taking a integer raw value, and a &#39;rawValue&#39; property for getting back out the raw value. Hope that helps.<br>&gt;&gt; <br>&gt;&gt; Austin<br>&gt;&gt; <br>&gt;&gt;&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I guess I should say that the `typedef` is coming from a Linux kernel header &lt;http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2&gt;. So I don&#39;t think I&#39;m going to be able to add any macros to the definition.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; What do you mean about alt-click? Alt click where?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in Swift). I think if you want it to be imported as an enum you need to use the NS_ENUM macro in the definition, which might not be possible in your case.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; typedef enum fe_type {<br>&gt;&gt;&gt;&gt;&gt;  FE_QPSK,<br>&gt;&gt;&gt;&gt;&gt;  FE_QAM,<br>&gt;&gt;&gt;&gt;&gt;  FE_OFDM,<br>&gt;&gt;&gt;&gt;&gt;  FE_ATSC<br>&gt;&gt;&gt;&gt;&gt; } fe_type_t;<br>&gt;&gt;&gt;  <br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-dev mailing list<br>&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160111/376aabc4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Jordan,<br></p><p>Perhaps I&#39;m not following that parenthetical comment. Are you saying<br>that even if I could add NS_ENUM to the header it still wouldn&#39;t compile<br>into a true Swift enum (on a non-Apple platform)?<br></p><p>Swift&#39;s pattern matching capability is probably a top 3 reason why I am<br>trying to port my C application to use Swift rather than just straight<br>C. Not being able to get this nicety out-of-the-box is just part of<br>doing business on a bleeding edge programming language.<br></p><p>However this *seems* like something that should be able to be achieved.<br>Looking at the fe_type enum definition, because it had no bit pattern<br>associated with it, I would have assumed it was a true non-overlapping<br>enum. Its probable I&#39;m not seeing the whole landscape here so would you<br>be able to illuminate why isn&#39;t this the default?<br></p><p>On Mon, Jan 11, 2016, at 01:11 PM, Jordan Rose wrote:<br>&gt; Right. This is because Swift can&#39;t tell if your enum is actually an<br>&gt; option set, a true, non-overlapping enum, or just a set of related<br>&gt; constants, so it picks the lowest common denominator. We currently<br>&gt; don&#39;t have a great way to override that in headers you don&#39;t control.<br>&gt;<br>&gt; (Heck, on non-Apple platforms we don&#39;t have a great way to do it<br>&gt; in headers you do control; Swift is currently keying off the<br>&gt; macro names.)<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;&gt; On Jan 10, 2016, at 13:25 , Austin Zheng via swift-dev &lt;swift-<br>&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I spoke too soon, the cases are also defined as values of that type.<br>&gt;&gt; So, a working version of your code:<br>&gt;&gt;<br>&gt;&gt; extensionfe_type:CustomStringConvertible{<br>&gt;&gt; publicvardescription:String{ switchself{ caseFE_QPSK:return&quot;QPSK&quot;<br>&gt;&gt; caseFE_QAM:return&quot;QAM&quot; caseFE_OFDM:return&quot;OFDM&quot;<br>&gt;&gt; caseFE_ATSC:return&quot;ATSC&quot; default:fatalError(&quot;can&#39;t be<br>&gt;&gt; exhaustive&quot;)    }  } }<br>&gt;&gt;<br>&gt;&gt; Best, Austin<br>&gt;&gt;<br>&gt;&gt;&gt; On Jan 10, 2016, at 1:22 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Hi Ryan,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Apologies, I should have been more clear. In Xcode you can alt(?)-<br>&gt;&gt;&gt; click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in the<br>&gt;&gt;&gt; IDE to pop up a little window that shows you the definition,<br>&gt;&gt;&gt; including the type and some other information. If you&#39;re on a Linux<br>&gt;&gt;&gt; box or not using an IDE you probably don&#39;t have that option.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The only methods I see exposed on the Swift imported type are<br>&gt;&gt;&gt; initializers taking a integer raw value, and a &#39;rawValue&#39; property<br>&gt;&gt;&gt; for getting back out the raw value. Hope that helps.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-<br>&gt;&gt;&gt;&gt; dev at ryan.lovelett.me&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I guess I should say that the `typedef` is coming from aLinux<br>&gt;&gt;&gt;&gt; kernel header[1]. So I don&#39;t think I&#39;m going to be able to add any<br>&gt;&gt;&gt;&gt; macros to the definition.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; What do you mean about alt-click? Alt click where?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in<br>&gt;&gt;&gt;&gt;&gt; Swift). I think if you want it to be imported as an enum you need<br>&gt;&gt;&gt;&gt;&gt; to use the NS_ENUM macro in the definition, which might not be<br>&gt;&gt;&gt;&gt;&gt; possible in your case.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; typedef enum fe_type { FE_QPSK, FE_QAM, FE_OFDM, FE_ATSC }<br>&gt;&gt;&gt;&gt;&gt;&gt; fe_type_t;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-dev mailing list swift-dev at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br></p><p><br></p><p>Links:<br></p><p>  1. http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160111/659c796d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 11, 2016 at 11:00:00am</p></header><div class="content"><p>Oh, you can certainly define a macro named NS_ENUM yourself, but that doesn&#39;t really seem like the right thing to do on Linux.<br></p><p>As for why we can&#39;t &quot;guess&quot; that this is a true enum, consider the following:<br></p><p>enum Foo {<br>  A = 1,<br>  B = 2,<br>};<br></p><p>Is this a very small option set, or an enum that deliberately doesn&#39;t start at 0? Or just a way to define constants for some other type, rather than using &quot;static const&quot;? If the compiler guesses here, (a) it might guess wrong, making the type hard to use now, and (b) if the headers are updated in a newer version of the library, it might change its guess, which would break source compatibility. (This can happen anyway, e.g. the first time an annotation is added, but at least that&#39;s supposed to be changing in the right direction, and is unlikely to change again.)<br></p><p>Hope that clarifies the motivation here, even if it&#39;s less than satisfactory.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 11, 2016, at 11:22, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me&gt; wrote:<br>&gt; <br>&gt; Jordan,<br>&gt;  <br>&gt; Perhaps I&#39;m not following that parenthetical comment. Are you saying that even if I could add NS_ENUM to the header it still wouldn&#39;t compile into a true Swift enum (on a non-Apple platform)?<br>&gt;  <br>&gt; Swift&#39;s pattern matching capability is probably a top 3 reason why I am trying to port my C application to use Swift rather than just straight C. Not being able to get this nicety out-of-the-box is just part of doing business on a bleeding edge programming language.<br>&gt;  <br>&gt; However this seems like something that should be able to be achieved. Looking at the fe_type enum definition, because it had no bit pattern associated with it, I would have assumed it was a true non-overlapping enum. Its probable I&#39;m not seeing the whole landscape here so would you be able to illuminate why isn&#39;t this the default?<br>&gt;  <br>&gt; On Mon, Jan 11, 2016, at 01:11 PM, Jordan Rose wrote:<br>&gt;&gt; Right. This is because Swift can&#39;t tell if your enum is actually an option set, a true, non-overlapping enum, or just a set of related constants, so it picks the lowest common denominator. We currently don&#39;t have a great way to override that in headers you don&#39;t control.<br>&gt;&gt;  <br>&gt;&gt; (Heck, on non-Apple platforms we don&#39;t have a great way to do it in headers you do control; Swift is currently keying off the macro names.)<br>&gt;&gt;  <br>&gt;&gt; Jordan<br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 10, 2016, at 13:25 , Austin Zheng via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; I spoke too soon, the cases are also defined as values of that type. So, a working version of your code:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; extensionfe_type:CustomStringConvertible{<br>&gt;&gt;&gt; publicvardescription:String{<br>&gt;&gt;&gt; switchself{<br>&gt;&gt;&gt; caseFE_QPSK:return&quot;QPSK&quot;<br>&gt;&gt;&gt; caseFE_QAM:return&quot;QAM&quot;<br>&gt;&gt;&gt; caseFE_OFDM:return&quot;OFDM&quot;<br>&gt;&gt;&gt; caseFE_ATSC:return&quot;ATSC&quot;<br>&gt;&gt;&gt; default:fatalError(&quot;can&#39;t be exhaustive&quot;)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt;   }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Best,<br>&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:22 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Hi Ryan,<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Apologies, I should have been more clear. In Xcode you can alt(?)-click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in the IDE to pop up a little window that shows you the definition, including the type and some other information. If you&#39;re on a Linux box or not using an IDE you probably don&#39;t have that option.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; The only methods I see exposed on the Swift imported type are initializers taking a integer raw value, and a &#39;rawValue&#39; property for getting back out the raw value. Hope that helps.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I guess I should say that the `typedef` is coming from aLinux kernel header &lt;http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2&gt;. So I don&#39;t think I&#39;m going to be able to add any macros to the definition.<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; What do you mean about alt-click? Alt click where?<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in Swift). I think if you want it to be imported as an enum you need to use the NS_ENUM macro in the definition, which might not be possible in your case.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; typedef enum fe_type {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_QPSK,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_QAM,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_OFDM,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_ATSC<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; } fe_type_t;<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160111/5f58d947/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January 11, 2016 at 04:00:00pm</p></header><div class="content"><p>I think I get where you are going. But I&#39;m not going to drop it quite<br>that easily. Forgive my insolence but I still think there is room for a<br>sane default here.<br></p><p>To answer your question: it is an enum that deliberately does not start<br>at 0. If Swift made that the default import symantics then I think all<br>the cases you covered (selfishly even my case) would be adequately<br>addressable.<br></p><p>Lets say there are, at least, 3 types of enums:<br> 1. A non-overlapping, non-option set enum<br> 2. A non-overlapping option set<br> 3. An overlapping option set<br></p><p>In this case, I&#39;d say the enum was of type 2; a non-overlapping option<br>set. If it was something the developer needed to conform to the<br>`OptionSetType` then the developer who imported the type could provide a<br>simple extension to the enum that provides conformance with the<br>`OptionSetType`. Voila. Now it is an option set.<br></p><p>More concretely:<br></p><p>enum Foo: Int {      case A = 1      case B = 2    }<br></p><p>// Not automatic but available in this hypothetical world    extension<br>Foo: OptionSetType {      init(rawValue: Int) {        self =<br>Foo.init(rawValue: rawValue) ?? Foo.A      }    }<br></p><p>If it was really some sort of constant then now it can be accessed via<br>it&#39;s `rawValue` property (isn&#39;t that the way it would be accessed as it<br>currently stands?).<br></p><p>If it was just an enum, well then that&#39;s covered too.<br></p><p>I tried compiling a few contrived enums based on this one to illustrate<br>how I&#39;d expect them to be mapped. I&#39;ve put them into this gist[1].<br></p><p>I think if you took it in terms of pattern matching where the the first<br>case is the strictest pattern (and thus the hardest to conform to) by<br>the time you reach the 3rd case your back to the current behavior. Swift<br>would then be able to account for more generic enum imports than it<br>currently can.<br></p><p>On Mon, Jan 11, 2016, at 02:51 PM, Jordan Rose wrote:<br>&gt; Oh, you can certainly define a macro named NS_ENUM yourself, but that<br>&gt; doesn&#39;t really seem like the right thing to do on Linux.<br>&gt;<br>&gt; As for why we can&#39;t &quot;guess&quot; that this is a true enum, consider the<br>&gt; following:<br>&gt;<br>&gt;&gt; enum Foo {  A = 1,  B = 2, };<br>&gt;<br>&gt; Is this a very small option set, or an enum that deliberately doesn&#39;t<br>&gt; start at 0? Or just a way to define constants for some other type,<br>&gt; rather than using &quot;static const&quot;? If the compiler guesses here, (a) it<br>&gt; might guess wrong, making the type hard to use *now,* and (b) if the<br>&gt; headers are updated in a newer version of the library, it might<br>&gt; *change* its guess, which would break source compatibility. (This can<br>&gt; happen anyway, e.g. the first time an annotation is added, but at<br>&gt; least that&#39;s supposed to be changing in the right direction, and is<br>&gt; unlikely to change again.)<br>&gt;<br>&gt; Hope that clarifies the motivation here, even if it&#39;s less than<br>&gt; satisfactory.<br>&gt;<br>&gt; Jordan<br>&gt;<br>&gt;<br>&gt;&gt; On Jan 11, 2016, at 11:22, Ryan Lovelett &lt;swift-<br>&gt;&gt; dev at ryan.lovelett.me&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Jordan,<br>&gt;&gt;<br>&gt;&gt; Perhaps I&#39;m not following that parenthetical comment. Are you saying<br>&gt;&gt; that even if I could add NS_ENUM to the header it still wouldn&#39;t<br>&gt;&gt; compile into a true Swift enum (on a non-Apple platform)?<br>&gt;&gt;<br>&gt;&gt; Swift&#39;s pattern matching capability is probably a top 3 reason why I<br>&gt;&gt; am trying to port my C application to use Swift rather than just<br>&gt;&gt; straight C. Not being able to get this nicety out-of-the-box is just<br>&gt;&gt; part of doing business on a bleeding edge programming language.<br>&gt;&gt;<br>&gt;&gt; However this *seems* like something that should be able to be<br>&gt;&gt; achieved. Looking at the fe_type enum definition, because it had no<br>&gt;&gt; bit pattern associated with it, I would have assumed it was a true<br>&gt;&gt; non-overlapping enum. Its probable I&#39;m not seeing the whole landscape<br>&gt;&gt; here so would you be able to illuminate why isn&#39;t this the default?<br>&gt;&gt;<br>&gt;&gt; On Mon, Jan 11, 2016, at 01:11 PM, Jordan Rose wrote:<br>&gt;&gt;&gt; Right. This is because Swift can&#39;t tell if your enum is actually an<br>&gt;&gt;&gt; option set, a true, non-overlapping enum, or just a set of related<br>&gt;&gt;&gt; constants, so it picks the lowest common denominator. We currently<br>&gt;&gt;&gt; don&#39;t have a great way to override that in headers you don&#39;t<br>&gt;&gt;&gt; control.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (Heck, on non-Apple platforms we don&#39;t have a great way to do it in<br>&gt;&gt;&gt; headers you do control; Swift is currently keying off the macro<br>&gt;&gt;&gt; names.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Jan 10, 2016, at 13:25 , Austin Zheng via swift-dev &lt;swift-<br>&gt;&gt;&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I spoke too soon, the cases are also defined as values of that<br>&gt;&gt;&gt;&gt; type. So, a working version of your code:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; extensionfe_type:CustomStringConvertible{<br>&gt;&gt;&gt;&gt; publicvardescription:String{ switchself{ caseFE_QPSK:return&quot;QPSK&quot;<br>&gt;&gt;&gt;&gt; caseFE_QAM:return&quot;QAM&quot; caseFE_OFDM:return&quot;OFDM&quot;<br>&gt;&gt;&gt;&gt; caseFE_ATSC:return&quot;ATSC&quot; default:fatalError(&quot;can&#39;t be exhaustive&quot;)<br>&gt;&gt;&gt;&gt; }  } }<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Best, Austin<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:22 PM, Austin Zheng &lt;austinzheng at gmail.com&gt;<br>&gt;&gt;&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Hi Ryan,<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Apologies, I should have been more clear. In Xcode you can alt(?)-<br>&gt;&gt;&gt;&gt;&gt; click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in<br>&gt;&gt;&gt;&gt;&gt; the IDE to pop up a little window that shows you the definition,<br>&gt;&gt;&gt;&gt;&gt; including the type and some other information. If you&#39;re on a<br>&gt;&gt;&gt;&gt;&gt; Linux box or not using an IDE you probably don&#39;t have that option.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; The only methods I see exposed on the Swift imported type are<br>&gt;&gt;&gt;&gt;&gt; initializers taking a integer raw value, and a &#39;rawValue&#39; property<br>&gt;&gt;&gt;&gt;&gt; for getting back out the raw value. Hope that helps.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt; dev at ryan.lovelett.me&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; I guess I should say that the `typedef` is coming from aLinux<br>&gt;&gt;&gt;&gt;&gt;&gt; kernel header[2]. So I don&#39;t think I&#39;m going to be able to add<br>&gt;&gt;&gt;&gt;&gt;&gt; any macros to the definition.<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; What do you mean about alt-click? Alt click where?<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Swift). I think if you want it to be imported as an enum you<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; need to use the NS_ENUM macro in the definition, which might not<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; be possible in your case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; typedef enum fe_type { FE_QPSK, FE_QAM, FE_OFDM, FE_ATSC }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fe_type_t;<br>&gt;&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-dev mailing list swift-dev at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev<br>&gt;&gt;<br></p><p><br></p><p>Links:<br></p><p>  1. https://gist.github.com/anonymous/232d62d77999f5eb27cd<br>  2. http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160111/2fb26331/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>January 12, 2016 at 09:00:00am</p></header><div class="content"><p>Not insolence at all. :-) It&#39;s important to justify or come up with good logic here, and doubly so on Linux where NS_ENUM/NS_OPTIONS aren&#39;t standard.<br></p><p>The usefulness of an enum is that you can guarantee that all cases are enumerated. But even that&#39;s not always true; people do add new elements to C enums without breaking binary compatibility. Or they have &quot;private&quot; cases that are ABI-compatible but do not correspond to a public declaration. So we&#39;ll already probably be dropping the idea of exhaustive switch over an imported enum unless we have some prior knowledge. (That still needs design.)<br></p><p>So then what&#39;s the cost of using an enum over a struct for the option set? I guess it&#39;s mostly the implication that you could switch over it, something you should never do with an option set. There are also option sets with predefined combinations of options:<br></p><p>typedef NS_OPTIONS(NSUInteger, MyOptions) {<br>  MyOptionA = 1,<br>  MyOptionB = 2,<br>  MyOptionC = 4,<br>  MyOptionDefault = MyOptionA | MyOptionC,<br>};<br></p><p>…which would be weird for an enum. As you say, though, it&#39;s not a deal-breaker.<br></p><p>For your gist &lt;https://gist.github.com/anonymous/232d62d77999f5eb27cd&gt;  I&#39;m not really sure what separates type 1 from type 2. Is it the explicit values assigned to the cases? The fact that all of the &quot;type 2&quot; values are powers of 2? And what makes type 3 a set of constants rather than just an enum or option set with a compatibility alias for its first element?<br></p><p>I don&#39;t think we want to make these heuristics much more complicated—the more rules there are, the more likely people will be confused when they don&#39;t work. One advantage of the current heuristic is that it encourages people to make their headers better; a disadvantage is that not all headers are editable. Maybe we can fix that problem instead, for example by looking for annotations on redeclarations of the enum.<br></p><p>Jordan<br></p><p><br>&gt; On Jan 11, 2016, at 13:25 , Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt; <br>&gt; I think I get where you are going. But I&#39;m not going to drop it quite that easily. Forgive my insolence but I still think there is room for a sane default here.<br>&gt;  <br>&gt; To answer your question: it is an enum that deliberately does not start at 0. If Swift made that the default import symantics then I think all the cases you covered (selfishly even my case) would be adequately addressable.<br>&gt;  <br>&gt; Lets say there are, at least, 3 types of enums:<br>&gt; A non-overlapping, non-option set enum<br>&gt; A non-overlapping option set<br>&gt; An overlapping option set<br>&gt;  <br>&gt; In this case, I&#39;d say the enum was of type 2; a non-overlapping option set. If it was something the developer needed to conform to the `OptionSetType` then the developer who imported the type could provide a simple extension to the enum that provides conformance with the `OptionSetType`. Voila. Now it is an option set.<br>&gt;  <br>&gt; More concretely:<br>&gt;  <br>&gt;     enum Foo: Int {<br>&gt;       case A = 1<br>&gt;       case B = 2<br>&gt;     }<br>&gt;  <br>&gt;     // Not automatic but available in this hypothetical world<br>&gt;     extension Foo: OptionSetType {<br>&gt;       init(rawValue: Int) {<br>&gt;         self = Foo.init(rawValue: rawValue) ?? Foo.A<br>&gt;       }<br>&gt;     }<br>&gt;  <br>&gt; If it was really some sort of constant then now it can be accessed via it&#39;s `rawValue` property (isn&#39;t that the way it would be accessed as it currently stands?).<br>&gt;  <br>&gt; If it was just an enum, well then that&#39;s covered too.<br>&gt;  <br>&gt; I tried compiling a few contrived enums based on this one to illustrate how I&#39;d expect them to be mapped. I&#39;ve put them into this gist &lt;https://gist.github.com/anonymous/232d62d77999f5eb27cd&gt;.<br>&gt;  <br>&gt; I think if you took it in terms of pattern matching where the the first case is the strictest pattern (and thus the hardest to conform to) by the time you reach the 3rd case your back to the current behavior. Swift would then be able to account for more generic enum imports than it currently can.<br>&gt;  <br>&gt; On Mon, Jan 11, 2016, at 02:51 PM, Jordan Rose wrote:<br>&gt;&gt; Oh, you can certainly define a macro named NS_ENUM yourself, but that doesn&#39;t really seem like the right thing to do on Linux.<br>&gt;&gt;  <br>&gt;&gt; As for why we can&#39;t &quot;guess&quot; that this is a true enum, consider the following:<br>&gt;&gt;  <br>&gt;&gt; enum Foo {<br>&gt;&gt;   A = 1,<br>&gt;&gt;   B = 2,<br>&gt;&gt; };<br>&gt;&gt;  <br>&gt;&gt; Is this a very small option set, or an enum that deliberately doesn&#39;t start at 0? Or just a way to define constants for some other type, rather than using &quot;static const&quot;? If the compiler guesses here, (a) it might guess wrong, making the type hard to use now, and (b) if the headers are updated in a newer version of the library, it might change its guess, which would break source compatibility. (This can happen anyway, e.g. the first time an annotation is added, but at least that&#39;s supposed to be changing in the right direction, and is unlikely to change again.)<br>&gt;&gt;  <br>&gt;&gt; Hope that clarifies the motivation here, even if it&#39;s less than satisfactory.<br>&gt;&gt;  <br>&gt;&gt; Jordan<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt;&gt; On Jan 11, 2016, at 11:22, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Jordan,<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Perhaps I&#39;m not following that parenthetical comment. Are you saying that even if I could add NS_ENUM to the header it still wouldn&#39;t compile into a true Swift enum (on a non-Apple platform)?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; Swift&#39;s pattern matching capability is probably a top 3 reason why I am trying to port my C application to use Swift rather than just straight C. Not being able to get this nicety out-of-the-box is just part of doing business on a bleeding edge programming language.<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; However this seems like something that should be able to be achieved. Looking at the fe_type enum definition, because it had no bit pattern associated with it, I would have assumed it was a true non-overlapping enum. Its probable I&#39;m not seeing the whole landscape here so would you be able to illuminate why isn&#39;t this the default?<br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Mon, Jan 11, 2016, at 01:11 PM, Jordan Rose wrote:<br>&gt;&gt;&gt;&gt; Right. This is because Swift can&#39;t tell if your enum is actually an option set, a true, non-overlapping enum, or just a set of related constants, so it picks the lowest common denominator. We currently don&#39;t have a great way to override that in headers you don&#39;t control.<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; (Heck, on non-Apple platforms we don&#39;t have a great way to do it in headers you do control; Swift is currently keying off the macro names.)<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; Jordan<br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 13:25 , Austin Zheng via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I spoke too soon, the cases are also defined as values of that type. So, a working version of your code:<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; extensionfe_type:CustomStringConvertible{<br>&gt;&gt;&gt;&gt;&gt; publicvardescription:String{<br>&gt;&gt;&gt;&gt;&gt; switchself{<br>&gt;&gt;&gt;&gt;&gt; caseFE_QPSK:return&quot;QPSK&quot;<br>&gt;&gt;&gt;&gt;&gt; caseFE_QAM:return&quot;QAM&quot;<br>&gt;&gt;&gt;&gt;&gt; caseFE_OFDM:return&quot;OFDM&quot;<br>&gt;&gt;&gt;&gt;&gt; caseFE_ATSC:return&quot;ATSC&quot;<br>&gt;&gt;&gt;&gt;&gt; default:fatalError(&quot;can&#39;t be exhaustive&quot;)<br>&gt;&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt;&gt;   }<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; Best,<br>&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:22 PM, Austin Zheng &lt;austinzheng at gmail.com &lt;mailto:austinzheng at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Ryan,<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Apologies, I should have been more clear. In Xcode you can alt(?)-click on a type (e.g the &#39;MyType&#39; in &quot;let a : MyType = 123&quot;) in the IDE to pop up a little window that shows you the definition, including the type and some other information. If you&#39;re on a Linux box or not using an IDE you probably don&#39;t have that option.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; The only methods I see exposed on the Swift imported type are initializers taking a integer raw value, and a &#39;rawValue&#39; property for getting back out the raw value. Hope that helps.<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:18 PM, Ryan Lovelett &lt;swift-dev at ryan.lovelett.me &lt;mailto:swift-dev at ryan.lovelett.me&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I guess I should say that the `typedef` is coming from aLinux kernel header &lt;http://lxr.free-electrons.com/source/include/linux/dvb/frontend.h?v=3.2&gt;. So I don&#39;t think I&#39;m going to be able to add any macros to the definition.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What do you mean about alt-click? Alt click where?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Jan 10, 2016, at 04:12 PM, Austin Zheng wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; fe_type is being imported as a struct (alt-click &#39;fe_type&#39; in Swift). I think if you want it to be imported as an enum you need to use the NS_ENUM macro in the definition, which might not be possible in your case.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Austin<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Jan 10, 2016, at 1:06 PM, Ryan Lovelett via swift-dev &lt;swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; typedef enum fe_type {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_QPSK,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_QAM,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_OFDM,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  FE_ATSC<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; } fe_type_t;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-dev mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-dev at swift.org &lt;mailto:swift-dev at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-dev &lt;https://lists.swift.org/mailman/listinfo/swift-dev&gt;<br>&gt;&gt;&gt;  <br>&gt;  <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-dev/attachments/20160112/5a2d9e9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/14477c366d6ee4e41adf14837bc4f2f9?s=50"></div><header><strong>Swift C enum Case Mapping</strong> from <string>Ryan Lovelett</string> &lt;swift-dev at ryan.lovelett.me&gt;<p>January 12, 2016 at 10:00:00pm</p></header><div class="content"><p>I was hoping it would come through as light-hearted. That certainly was<br>my intent. Text is sometimes hard to convey intent through.<br></p><p>Responses inline.<br></p><p>On Tue, Jan 12, 2016, at 12:52 PM, Jordan Rose wrote:<br>&gt; Not insolence at all. :-) It&#39;s important to justify or come up with good logic here, and doubly so on Linux where NS_ENUM/NS_OPTIONS aren&#39;t standard.<br>&gt; <br>&gt; The usefulness of an enum is that you can guarantee that all cases are enumerated. But even that&#39;s not always true; people *do* add new elements to C enums without breaking binary compatibility. Or they have &quot;private&quot; cases that are ABI-compatible but do not correspond to a public declaration. So we&#39;ll *already* probably be dropping the idea of exhaustive switch over an imported enum unless we have some prior knowledge. (That still needs design.)<br></p><p>Is Swift effectively worried about the case where in v1 of some header<br>the enum is defined as<br></p><p>enum Foo {<br>  A, B<br>}<br></p><p>and in v2 they add `C` or remove `B`. Thus requiring all the Swift code<br>case statements to no longer compile because they are &quot;not exhaustive&quot;.<br>If so that sounds like a good thing and not a bad thing to me.<br></p><p>Also, if I understand the &quot;private&quot; cases concern. Then I would contend<br>it&#39;s going to happen with the current import behavior. I think that a<br>&quot;private&quot; case in Swift&#39;s switch developers will have to exhaustively<br>account for that case even though in practice we know it will never<br>happen; thus leading to coding &quot;dead&quot; cases.<br></p><p>Consider a C enum that was imported as:<br></p><p>enum Foo {<br>  case PublicA, Private1, PublicB, Private2<br>}<br></p><p>the `switch` for the &quot;private&quot; might look something like this:<br></p><p>switch temp {<br>case .PublicA: fallthrough<br>case .PublicB: print(&quot;Expected&quot;)<br>case .Private1: fallthrough<br>case .Private2: fatalError(&quot;These cases are private&quot;)<br>}<br></p><p>Compare this with the current import behavior of a enum which we, human<br>in the loop, know to have no &quot;private&quot; cases.<br></p><p>typedef enum fe_type {<br>  FE_QPSK,<br>  FE_QAM,<br>  FE_OFDM,<br>  FE_ATSC<br>} fe_type_t;<br></p><p>switch type {<br>case FE_QPSK: fallthrough<br>case FE_QAM: fallthrough<br>case FE_OFDM: fallthrough<br>case FE_ATSC: fallthrough<br>default: fatalError(&quot;This switch is actually exhaustive. Though the<br>compiler doesn&#39;t know that.&quot;)<br>}<br></p><p>Seems like you end up in the same place. Or perhaps I completely missed<br>your point?<br></p><p>&gt; <br>&gt; So then what&#39;s the cost of using an enum over a struct for the option set? I guess it&#39;s mostly the *implication* that you could switch over it, something you should never do with an option set. There are also option sets with predefined combinations of options:<br>&gt; <br>&gt;&gt; typedef NS_OPTIONS(NSUInteger, MyOptions) {<br>&gt;&gt;   MyOptionA = 1,<br>&gt;&gt;   MyOptionB = 2,<br>&gt;&gt;   MyOptionC = 4,<br>&gt;&gt;   MyOptionDefault = MyOptionA | MyOptionC,<br>&gt;&gt; };<br>&gt; <br>&gt; …which would be weird for an enum. As you say, though, it&#39;s not a deal-breaker.<br>&gt; <br>&gt; For your gist[https://gist.github.com/anonymous/232d62d77999f5eb27cd]  I&#39;m not really sure what separates type 1 from type 2. Is it the explicit values assigned to the cases? The fact that all of the &quot;type 2&quot; values are powers of 2? And what makes type 3 a set of constants rather than just an enum or option set with a compatibility alias for its first element?<br></p><p>I guess I could have been a bit less cryptic. 😯<br></p><p>In my mind the fact that it has no explicit values assigned to the case<br>indicates that it is an &quot;true&quot; enum. The type 2 case is distinct from<br>the type 1 in that it supplies a value at all. The type 3 case is<br>distinct from the type 2 case in that it has a repeated value. Or put<br>more broadly, type 3 is anything that is more complicated than type 1 or<br>2.<br></p><p>&gt; <br>&gt; I don&#39;t think we want to make these heuristics much more complicated—the more rules there are, the more likely people will be confused when they don&#39;t work. One advantage of the current heuristic is that it encourages people to make their headers better; a disadvantage is that not all headers are editable. Maybe we can fix *that* problem instead, for example by looking for annotations on redeclarations of the enum.<br>&gt; <br>&gt; Jordan<br></p><p>After writing and thinking about this for a few days I went looking for<br>C headers that I didn&#39;t write or haven&#39;t been religiously using for 5<br>years to get a survey of how these things are done. The take-away: I<br>give up and now somewhat understand why the defaults are what they are.<br>I still don&#39;t _enjoy_ them mind you but it seems like that might be<br>beyond Swift&#39;s control. The way that enums are (ab)used is so crazy.<br></p><p>I think after having played that game redeclaration upon import or a<br>Swift API to convert a type through a protocol (is this even possible? I<br>love me some protocols.) or some other human-in-the-loop mechanism to<br>promote the imported enum to an first class enum once imported into to<br>Swift probably would end up being the most sane. It allows the C people<br>to continue to be, well C people, and the Swift people to write<br>idiomatic Swift code. After having thought about it for awhile that<br>seems like the most sane to me.<br></p><p>Can we get this implemented and merged tomorrow? 😈<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
