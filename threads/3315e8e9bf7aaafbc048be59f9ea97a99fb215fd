<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  6, 2015 at 03:00:00pm</p></header><div class="content"><p>Hmm. Something about braces inside expressions just feels wrong to me.<br></p><p>I also read switch? and if? as being some optional-related versions of<br>switch and if. And I don&#39;t love putting the condition /<br>value-to-switch-on *before<br>*the keyword, if we&#39;re going to use a keyword.<br></p><p>(Also: exhaustiveness checking *could *theoretically allow resolution of<br>ambiguity in nested switch expressions. We would just have to require that<br>as soon as you&#39;ve exhausted all possibilities, you don&#39;t add more cases and<br>the expression is over.)<br></p><p>On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; Yep probably does need braces: So for switch? if? suggestion i just made.<br>&gt;<br>&gt; let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red:<br>&gt; .Green, default: .Yellow }<br>&gt;<br>&gt; let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;<br>&gt;  case .Red: .Green; default: .Yellow }<br>&gt;<br>&gt; let myColor = yourColor switch? {<br>&gt; case .Blue :  .Reds<br>&gt; case .Green: .Blue<br>&gt; case .Red: .Green<br>&gt; default: .Yellow<br>&gt; }<br>&gt;<br>&gt; let myColor = yourColor switch? {<br>&gt; .Blue :  .Reds<br>&gt; .Green: .Blue<br>&gt; .Red: .Green<br>&gt; default: .Yellow<br>&gt; }<br>&gt;<br>&gt; let myColor = condition if?  { .Blue; .Red }<br>&gt;<br>&gt; I don’t find that looks bad.<br>&gt;<br>&gt; - Paul<br>&gt;<br>&gt;<br>&gt; On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Thanks for the feedback, Matthew. It&#39;s sensible to me to consider dropping<br>&gt; the ternary operator. I like it because the analogy &quot;C&#39;s if is to Swift&#39;s<br>&gt; if as C&#39;s ternary operator is to Swift&#39;s ternary operator&quot; is (sort of)<br>&gt; satisfied. But it is also confusing, both for the reasons you mention, and<br>&gt; because ? has other meanings in Swift:<br>&gt;<br>&gt;  // compiler error without space betw thatColor and ?<br>&gt; let thisColor = thatColor?<br>&gt;      case .Red: .Green<br>&gt;      default: .Blue<br>&gt;<br>&gt; On the other hand, is it really worth it to have control flow expressions<br>&gt; if they don&#39;t let your code look nicer?<br>&gt;<br>&gt; let thisColor = switch thatColor {<br>&gt;      case .Red:<br>&gt;           return .Green;<br>&gt;      default:<br>&gt;           return .Yellow;<br>&gt; }<br>&gt;<br>&gt; really isn&#39;t much nicer than<br>&gt;<br>&gt; let thisColor: Color<br>&gt; switch thatColor {<br>&gt;      case .Red:<br>&gt;           thisColor = .Green<br>&gt;      default:<br>&gt;           thisColor = .Yellow<br>&gt; }<br>&gt;<br>&gt; Maybe we could do a compromise, something like<br>&gt;<br>&gt; let thisColor = switch thatColor<br>&gt;      case .Red: .Green // must be an expression<br>&gt;      default: .Yellow      // must be an expression<br>&gt;<br>&gt; Or we could introduce a new keyword? Like *match*:<br>&gt;<br>&gt; let thisColor = match thatColor<br>&gt;       case .Red: .Green    // must be an expression<br>&gt;       default: .Yellow         // must be an expression<br>&gt;<br>&gt;<br>&gt; I sort of like the new-keyword approach, because even though this is<br>&gt; similar to a switch, it&#39;s not a switch: there&#39;s no fallthrough, you can&#39;t<br>&gt; put statements inside, etc.<br>&gt;<br>&gt; The problem with all these proposals:<br>&gt;<br>&gt; let thisColor = match thatColor<br>&gt;      case .Red: match thatOtherColor<br>&gt;                            case .Blue: .Green<br>&gt;                            case .Pink: .Yellow<br>&gt;                            default: .Orange<br>&gt;      default: .Orange<br>&gt;<br>&gt; is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can<br>&gt; know because of exhaustiveness checking, but this won&#39;t always work.) You<br>&gt; could solve this problem either by using parentheses around the whole<br>&gt; expression when necessary<br>&gt;<br>&gt; let thisColor = match thatColor<br>&gt;      case .Red: (match thatOtherColor<br>&gt;                            case .Blue: .Green<br>&gt;                            case .Pink: .Yellow<br>&gt;                            default: .Orange)<br>&gt;      default: .Orange<br>&gt;<br>&gt; or by adding curly braces in again<br>&gt;<br>&gt; let thisColor = match thatColor {<br>&gt;      case .Red: match thatOtherColor {<br>&gt;                            case .Blue: .Green<br>&gt;                            case .Pink: .Yellow<br>&gt;                            default: .Orange<br>&gt;                         }<br>&gt;      default: .Orange<br>&gt; }<br>&gt;<br>&gt; But that starts to look like switch again. (Of course, the best way to<br>&gt; handle this is as a programmer is to just switch on the tuple (thatColor,<br>&gt; thatOtherColor), but the language should allow for nested control<br>&gt; expressions.)<br>&gt;<br>&gt;<br>&gt; On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I am not a fan of this approach based on the ternary operator.  The<br>&gt;&gt; ternary operator is already a bit of an anomaly in that all other operators<br>&gt;&gt; are unary or binary and do not perform any control flow (beyond possibly<br>&gt;&gt; short circuiting an autoclosure argument).<br>&gt;&gt;<br>&gt;&gt; I would much rather features that perform control flow continue to use<br>&gt;&gt; keywords, but allow them to be expressions.<br>&gt;&gt;<br>&gt;&gt; Once we have control flow expressions I would like to see the ternary<br>&gt;&gt; operator removed from the language as it would no longer server a purpose.<br>&gt;&gt; Removing the ternary operator seems to fit nicely with the direction to<br>&gt;&gt; remove some features that are carried over from C-based languages but don’t<br>&gt;&gt; necessarily fit with the direction Swift is heading.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Ostensibly, case may not be necessary if you could delimit each case on<br>&gt;&gt; one line with something (perhaps a comma, or something else if that would<br>&gt;&gt; not fit well within the grammar):<br>&gt;&gt;<br>&gt;&gt; let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,<br>&gt;&gt; default: .Yellow<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I like this too, seems more powerful.  Also, would single line<br>&gt;&gt; expressions be allowed?  If not would case be required for example:<br>&gt;&gt;<br>&gt;&gt; let myFavoriteColor = yourFavoriteColor ?<br>&gt;&gt;     case .Blue: .Red<br>&gt;&gt;     case .Green: .Blue<br>&gt;&gt;     case .Red: .Green<br>&gt;&gt;     default: .Yellow<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I really like this train of thought. +1<br>&gt;&gt;<br>&gt;&gt; l8r<br>&gt;&gt; Sean<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; What if we left the if { ...} else { ... } syntax alone (as a statement),<br>&gt;&gt; and updated the ternary expression to be a more general pattern matching<br>&gt;&gt; expression (closer to &quot;switch&quot;)? Something like<br>&gt;&gt;<br>&gt;&gt; let x = condition ?<br>&gt;&gt;    true: &quot;Hello&quot;<br>&gt;&gt;    false: &quot;Goodbye&quot;<br>&gt;&gt;<br>&gt;&gt; let x = optionalValue ?<br>&gt;&gt;    .Some(let unwrapped): &quot;Hello, \(unwrapped)&quot;<br>&gt;&gt;    .None: &quot;To Whom It May Concern&quot;<br>&gt;&gt;<br>&gt;&gt; let myFavoriteColor = yourFavoriteColor ?<br>&gt;&gt;     .Blue: .Red<br>&gt;&gt;     .Green: .Blue<br>&gt;&gt;     .Red: .Green<br>&gt;&gt;<br>&gt;&gt; let quadrant = (x, y) ?<br>&gt;&gt;     let (x, y) where x &lt; 50 &amp;&amp; y &lt; 50: &quot;top left&quot;<br>&gt;&gt;     let (x, y) where x &lt; 50 &amp;&amp; y &gt; 50: &quot;bottom left&quot;<br>&gt;&gt;     let (x, y) where x &gt; 50 &amp;&amp; y &lt; 50: &quot;top right&quot;<br>&gt;&gt;     default: &quot;bottom right&quot;<br>&gt;&gt;<br>&gt;&gt; The colon comes from the fact that this is sort of a light-weight<br>&gt;&gt; expression-based &quot;switch&quot; statement, where each branch can only contain an<br>&gt;&gt; expression, not a series of statements.<br>&gt;&gt;<br>&gt;&gt; This is very similar to pattern matching expressions in languages like<br>&gt;&gt; Haskell, ML, and Coq.<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz &lt;thorsten.seitz at web.de&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;<br>&gt;&gt; I don&#39;t think you can just get rid of the if statement in favor of an<br>&gt;&gt; expression. You still want to be able to do this:<br>&gt;&gt;<br>&gt;&gt; if (condition) {<br>&gt;&gt;     funcWithSideEffectsThatReturnsInt()<br>&gt;&gt; } else {<br>&gt;&gt;     funcWithSideEffectsThatReturnsString()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; but that&#39;s not a valid expression (what is its type?).<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; That would actually be no problem if Swift’s type system would have union<br>&gt;&gt; types (Ceylon has union and intersection types which are quite awesome and<br>&gt;&gt; enable lots of nice things quite naturally, see<br>&gt;&gt; http://ceylon-lang.org/documentation/1.2/tour/types/).<br>&gt;&gt;<br>&gt;&gt; In that case the type of such an expression would just be the union of<br>&gt;&gt; both types, which is written Int | String in Ceylon.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; -Thorsten<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; *_______________________________________________*<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/331515fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>I agree that ? may imply optional, this may be similar to what you suggested, just filling in the example: Not sure parenthesis are better than braces though:<br></p><p>et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow )<br></p><p>let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow )<br></p><p>let myColor = match yourColor (<br>	case .Blue :  .Reds<br>	case .Green: .Blue <br>	case .Red: .Green<br>	default: .Yellow<br>)<br></p><p>let myColor = match yourColor (<br>	.Blue :  .Reds<br>	.Green: .Blue <br>	.Red: .Green<br>	default: .Yellow<br>)<br></p><p>let myColor = match boollCondition ( .Blue, .Red ) <br></p><p><br></p><p>&gt; On Dec 6, 2015, at 12:54 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; Hmm. Something about braces inside expressions just feels wrong to me.<br>&gt; <br>&gt; I also read switch? and if? as being some optional-related versions of switch and if. And I don&#39;t love putting the condition / value-to-switch-on before the keyword, if we&#39;re going to use a keyword.<br>&gt; <br>&gt; (Also: exhaustiveness checking could theoretically allow resolution of ambiguity in nested switch expressions. We would just have to require that as soon as you&#39;ve exhausted all possibilities, you don&#39;t add more cases and the expression is over.)<br>&gt; <br>&gt; On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt; Yep probably does need braces: So for switch? if? suggestion i just made. <br>&gt; <br>&gt; let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }<br>&gt; <br>&gt; let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }<br>&gt; <br>&gt; let myColor = yourColor switch? {<br>&gt; 	case .Blue :  .Reds<br>&gt; 	case .Green: .Blue <br>&gt; 	case .Red: .Green<br>&gt; 	default: .Yellow<br>&gt; }<br>&gt; <br>&gt; let myColor = yourColor switch? {<br>&gt; 	.Blue :  .Reds<br>&gt; 	.Green: .Blue <br>&gt; 	.Red: .Green<br>&gt; 	default: .Yellow<br>&gt; }<br>&gt; <br>&gt; let myColor = condition if?  { .Blue; .Red }<br>&gt; <br>&gt; I don’t find that looks bad. <br>&gt; <br>&gt; - Paul <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Thanks for the feedback, Matthew. It&#39;s sensible to me to consider dropping the ternary operator. I like it because the analogy &quot;C&#39;s if is to Swift&#39;s if as C&#39;s ternary operator is to Swift&#39;s ternary operator&quot; is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:<br>&gt;&gt; <br>&gt;&gt;  // compiler error without space betw thatColor and ?<br>&gt;&gt; let thisColor = thatColor? <br>&gt;&gt;      case .Red: .Green<br>&gt;&gt;      default: .Blue<br>&gt;&gt; <br>&gt;&gt; On the other hand, is it really worth it to have control flow expressions if they don&#39;t let your code look nicer?<br>&gt;&gt; <br>&gt;&gt; let thisColor = switch thatColor {<br>&gt;&gt;      case .Red:<br>&gt;&gt;           return .Green;<br>&gt;&gt;      default:<br>&gt;&gt;           return .Yellow;<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; really isn&#39;t much nicer than<br>&gt;&gt; <br>&gt;&gt; let thisColor: Color<br>&gt;&gt; switch thatColor {<br>&gt;&gt;      case .Red:<br>&gt;&gt;           thisColor = .Green<br>&gt;&gt;      default:<br>&gt;&gt;           thisColor = .Yellow<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Maybe we could do a compromise, something like<br>&gt;&gt; <br>&gt;&gt; let thisColor = switch thatColor<br>&gt;&gt;      case .Red: .Green // must be an expression<br>&gt;&gt;      default: .Yellow      // must be an expression<br>&gt;&gt; <br>&gt;&gt; Or we could introduce a new keyword? Like match:<br>&gt;&gt; <br>&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;       case .Red: .Green    // must be an expression<br>&gt;&gt;       default: .Yellow         // must be an expression<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I sort of like the new-keyword approach, because even though this is similar to a switch, it&#39;s not a switch: there&#39;s no fallthrough, you can&#39;t put statements inside, etc.<br>&gt;&gt; <br>&gt;&gt; The problem with all these proposals:<br>&gt;&gt; <br>&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;      case .Red: match thatOtherColor<br>&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;                            default: .Orange<br>&gt;&gt;      default: .Orange<br>&gt;&gt; <br>&gt;&gt; is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won&#39;t always work.) You could solve this problem either by using parentheses around the whole expression when necessary<br>&gt;&gt; <br>&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;      case .Red: (match thatOtherColor<br>&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;                            default: .Orange)<br>&gt;&gt;      default: .Orange<br>&gt;&gt; <br>&gt;&gt; or by adding curly braces in again<br>&gt;&gt; <br>&gt;&gt; let thisColor = match thatColor {<br>&gt;&gt;      case .Red: match thatOtherColor {<br>&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;                            default: .Orange<br>&gt;&gt;                         }<br>&gt;&gt;      default: .Orange<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).<br>&gt;&gt; <br>&gt;&gt; I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  <br>&gt;&gt; <br>&gt;&gt; Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar): <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote: <br>&gt;&gt;&gt;&gt; I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example: <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; let myFavoriteColor = yourFavoriteColor ? <br>&gt;&gt;&gt;&gt;     case .Blue: .Red <br>&gt;&gt;&gt;&gt;     case .Green: .Blue <br>&gt;&gt;&gt;&gt;     case .Red: .Green <br>&gt;&gt;&gt;&gt;     default: .Yellow <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; I really like this train of thought. +1 <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; l8r <br>&gt;&gt;&gt;&gt;&gt; Sean <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt; What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to &quot;switch&quot;)? Something like <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; let x = condition ? <br>&gt;&gt;&gt;&gt;&gt;&gt;    true: &quot;Hello&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;    false: &quot;Goodbye&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; let x = optionalValue ? <br>&gt;&gt;&gt;&gt;&gt;&gt;    .Some(let unwrapped): &quot;Hello, \(unwrapped)&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;    .None: &quot;To Whom It May Concern&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; let myFavoriteColor = yourFavoriteColor ? <br>&gt;&gt;&gt;&gt;&gt;&gt;     .Blue: .Red <br>&gt;&gt;&gt;&gt;&gt;&gt;     .Green: .Blue <br>&gt;&gt;&gt;&gt;&gt;&gt;     .Red: .Green <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; let quadrant = (x, y) ? <br>&gt;&gt;&gt;&gt;&gt;&gt;     let (x, y) where x &lt; 50 &amp;&amp; y &lt; 50: &quot;top left&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;     let (x, y) where x &lt; 50 &amp;&amp; y &gt; 50: &quot;bottom left&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;     let (x, y) where x &gt; 50 &amp;&amp; y &lt; 50: &quot;top right&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;     default: &quot;bottom right&quot; <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; The colon comes from the fact that this is sort of a light-weight expression-based &quot;switch&quot; statement, where each branch can only contain an expression, not a series of statements. <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq. <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz &lt;thorsten.seitz at web.de &lt;mailto:thorsten.seitz at web.de&gt;&gt; wrote: <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think you can just get rid of the if statement in favor of an expression. You still want to be able to do this: <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; if (condition) { <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     funcWithSideEffectsThatReturnsInt() <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; } else { <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     funcWithSideEffectsThatReturnsString() <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that&#39;s not a valid expression (what is its type?). <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see http://ceylon-lang.org/documentation/1.2/tour/types/ &lt;http://ceylon-lang.org/documentation/1.2/tour/types/&gt;). <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; In that case the type of such an expression would just be the union of both types, which is written Int | String in Ceylon. <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt;  <br>&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt; <br>&gt;&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/6b2fadb6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/411a0fa16436bc975292f7044033a246?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Alex Lew</string> &lt;alexl.mail+swift at gmail.com&gt;<p>December  6, 2015 at 04:00:00pm</p></header><div class="content"><p>To clarify, I would want parens around the entire expression (only when<br>necessary). So<br></p><p>let myColor = match yourColor<br>case .Blue :  .Red<br>case .Green: .Blue<br>case .Red: .Green<br>default: .Yellow<br></p><p>or<br></p><p>let myColor = match boolCondition<br>  case true: .Blue<br>  case false: .Red<br></p><p>or<br></p><p>let myColor = match boolCondition<br>  case true: (match yourColor<br>                      case .Red: .Blue<br>                      default: .Yellow)<br>  case false: .Red<br></p><p>But I actually think that the parens are unnecessary, as long as we require<br>matches to be exhaustive and for there to be no unreachable cases.<br></p><p>On Sun, Dec 6, 2015 at 4:17 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt; wrote:<br></p><p>&gt; I agree that ? may imply optional, this may be similar to what you<br>&gt; suggested, just filling in the example: Not sure parenthesis are better<br>&gt; than braces though:<br>&gt;<br>&gt; et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green,<br>&gt; default: .Yellow )<br>&gt;<br>&gt; let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;<br>&gt;  case .Red: .Green; default: .Yellow )<br>&gt;<br>&gt; let myColor = match yourColor (<br>&gt; case .Blue :  .Reds<br>&gt; case .Green: .Blue<br>&gt; case .Red: .Green<br>&gt; default: .Yellow<br>&gt; )<br>&gt;<br>&gt; let myColor = match yourColor (<br>&gt; .Blue :  .Reds<br>&gt; .Green: .Blue<br>&gt; .Red: .Green<br>&gt; default: .Yellow<br>&gt; )<br>&gt;<br>&gt; let myColor = match boollCondition ( .Blue, .Red )<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 6, 2015, at 12:54 PM, Alex Lew &lt; alexl.mail+swift at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Hmm. Something about braces inside expressions just feels wrong to me.<br>&gt;<br>&gt; I also read switch? and if? as being some optional-related versions of<br>&gt; switch and if. And I don&#39;t love putting the condition / value-to-switch-on *before<br>&gt; *the keyword, if we&#39;re going to use a keyword.<br>&gt;<br>&gt; (Also: exhaustiveness checking *could *theoretically allow resolution of<br>&gt; ambiguity in nested switch expressions. We would just have to require that<br>&gt; as soon as you&#39;ve exhausted all possibilities, you don&#39;t add more cases and<br>&gt; the expression is over.)<br>&gt;<br>&gt; On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen &lt;possen at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt;&gt; Yep probably does need braces: So for switch? if? suggestion i just<br>&gt;&gt; made.<br>&gt;&gt;<br>&gt;&gt; let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red:<br>&gt;&gt; .Green, default: .Yellow }<br>&gt;&gt;<br>&gt;&gt; let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;<br>&gt;&gt;  case .Red: .Green; default: .Yellow }<br>&gt;&gt;<br>&gt;&gt; let myColor = yourColor switch? {<br>&gt;&gt; case .Blue :  .Reds<br>&gt;&gt; case .Green: .Blue<br>&gt;&gt; case .Red: .Green<br>&gt;&gt; default: .Yellow<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let myColor = yourColor switch? {<br>&gt;&gt; .Blue :  .Reds<br>&gt;&gt; .Green: .Blue<br>&gt;&gt; .Red: .Green<br>&gt;&gt; default: .Yellow<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let myColor = condition if?  { .Blue; .Red }<br>&gt;&gt;<br>&gt;&gt; I don’t find that looks bad.<br>&gt;&gt;<br>&gt;&gt; - Paul<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; Thanks for the feedback, Matthew. It&#39;s sensible to me to consider<br>&gt;&gt; dropping the ternary operator. I like it because the analogy &quot;C&#39;s if is to<br>&gt;&gt; Swift&#39;s if as C&#39;s ternary operator is to Swift&#39;s ternary operator&quot; is (sort<br>&gt;&gt; of) satisfied. But it is also confusing, both for the reasons you mention,<br>&gt;&gt; and because ? has other meanings in Swift:<br>&gt;&gt;<br>&gt;&gt;  // compiler error without space betw thatColor and ?<br>&gt;&gt; let thisColor = thatColor?<br>&gt;&gt;      case .Red: .Green<br>&gt;&gt;      default: .Blue<br>&gt;&gt;<br>&gt;&gt; On the other hand, is it really worth it to have control flow expressions<br>&gt;&gt; if they don&#39;t let your code look nicer?<br>&gt;&gt;<br>&gt;&gt; let thisColor = switch thatColor {<br>&gt;&gt;      case .Red:<br>&gt;&gt;           return .Green;<br>&gt;&gt;      default:<br>&gt;&gt;           return .Yellow;<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; really isn&#39;t much nicer than<br>&gt;&gt;<br>&gt;&gt; let thisColor: Color<br>&gt;&gt; switch thatColor {<br>&gt;&gt;      case .Red:<br>&gt;&gt;           thisColor = .Green<br>&gt;&gt;      default:<br>&gt;&gt;           thisColor = .Yellow<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; Maybe we could do a compromise, something like<br>&gt;&gt;<br>&gt;&gt; let thisColor = switch thatColor<br>&gt;&gt;      case .Red: .Green // must be an expression<br>&gt;&gt;      default: .Yellow      // must be an expression<br>&gt;&gt;<br>&gt;&gt; Or we could introduce a new keyword? Like   *match*:<br>&gt;&gt;<br>&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;       case .Red: .Green    // must be an expression<br>&gt;&gt;       default: .Yellow         // must be an expression<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I sort of like the new-keyword approach, because even though this is<br>&gt;&gt; similar to a switch, it&#39;s not a switch: there&#39;s no fallthrough, you can&#39;t<br>&gt;&gt; put statements inside, etc.<br>&gt;&gt;<br>&gt;&gt; The problem with all these proposals:<br>&gt;&gt;<br>&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;      case .Red: match thatOtherColor<br>&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;                            default: .Orange<br>&gt;&gt;      default: .Orange<br>&gt;&gt;<br>&gt;&gt; is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can<br>&gt;&gt; know because of exhaustiveness checking, but this won&#39;t always work.) You<br>&gt;&gt; could solve this problem either by using parentheses around the whole<br>&gt;&gt; expression when necessary<br>&gt;&gt;<br>&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;      case .Red: (match thatOtherColor<br>&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;                            default: .Orange)<br>&gt;&gt;      default: .Orange<br>&gt;&gt;<br>&gt;&gt; or by adding curly braces in again<br>&gt;&gt;<br>&gt;&gt; let thisColor = match thatColor {<br>&gt;&gt;      case .Red: match thatOtherColor {<br>&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;                            default: .Orange<br>&gt;&gt;                         }<br>&gt;&gt;      default: .Orange<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; But that starts to look like switch again. (Of course, the best way to<br>&gt;&gt; handle this is as a programmer is to just switch on the tuple (thatColor,<br>&gt;&gt; thatOtherColor), but the language should allow for nested control<br>&gt;&gt; expressions.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution   &lt;<br>&gt;&gt; swift-evolution at swift.org&gt;  wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I am not a fan of this approach based on the ternary operator.  The<br>&gt;&gt;&gt; ternary operator is already a bit of an anomaly in that all other operators<br>&gt;&gt;&gt; are unary or binary and do not perform any control flow (beyond possibly<br>&gt;&gt;&gt; short circuiting an autoclosure argument).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I would much rather features that perform control flow continue to use<br>&gt;&gt;&gt; keywords, but allow them to be expressions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Once we have control flow expressions I would like to see the ternary<br>&gt;&gt;&gt; operator removed from the language as it would no longer server a purpose.<br>&gt;&gt;&gt; Removing the ternary operator seems to fit nicely with the direction to<br>&gt;&gt;&gt; remove some features that are carried over from C-based languages but don’t<br>&gt;&gt;&gt; necessarily fit with the direction Swift is heading.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Ostensibly, case may not be necessary if you could delimit each case on<br>&gt;&gt;&gt; one line with something (perhaps a comma, or something else if that would<br>&gt;&gt;&gt; not fit well within the grammar):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green,<br>&gt;&gt;&gt; default: .Yellow<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution<br>&gt;&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I like this too, seems more powerful.  Also, would single line<br>&gt;&gt;&gt; expressions be allowed?  If not would case be required for example:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let myFavoriteColor = yourFavoriteColor ?<br>&gt;&gt;&gt;      case .Blue: .Red<br>&gt;&gt;&gt;      case .Green: .Blue<br>&gt;&gt;&gt;      case .Red: .Green<br>&gt;&gt;&gt;      default: .Yellow<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I really like this train of thought. +1<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; l8r<br>&gt;&gt;&gt; Sean<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; What if we left the if { ...} else { ... } syntax alone (as a<br>&gt;&gt;&gt; statement), and updated the ternary expression to be a more general pattern<br>&gt;&gt;&gt; matching expression (closer to &quot;switch&quot;)? Something like<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = condition ?<br>&gt;&gt;&gt;    true: &quot;Hello&quot;<br>&gt;&gt;&gt;    false: &quot;Goodbye&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let x = optionalValue ?<br>&gt;&gt;&gt;    .Some(let unwrapped): &quot;Hello, \(unwrapped)&quot;<br>&gt;&gt;&gt;    .None: &quot;To Whom It May Concern&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let myFavoriteColor = yourFavoriteColor ?<br>&gt;&gt;&gt;      .Blue: .Red<br>&gt;&gt;&gt;      .Green: .Blue<br>&gt;&gt;&gt;      .Red: .Green<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; let quadrant = (x, y) ?<br>&gt;&gt;&gt;      let (x, y) where x &lt; 50 &amp;&amp; y &lt; 50: &quot;top left&quot;<br>&gt;&gt;&gt;      let (x, y) where x &lt; 50 &amp;&amp; y &gt; 50: &quot;bottom left&quot;<br>&gt;&gt;&gt;      let (x, y) where x &gt; 50 &amp;&amp; y &lt; 50: &quot;top right&quot;<br>&gt;&gt;&gt;      default: &quot;bottom right&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The colon comes from the fact that this is sort of a light-weight<br>&gt;&gt;&gt; expression-based &quot;switch&quot; statement, where each branch can only contain an<br>&gt;&gt;&gt; expression, not a series of statements.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is very similar to pattern matching expressions in languages like<br>&gt;&gt;&gt; Haskell, ML, and Coq.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz   &lt;thorsten.seitz at web.de<br>&gt;&gt;&gt; &gt;   wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I don&#39;t think you can just get rid of the if statement in favor of an<br>&gt;&gt;&gt; expression. You still want to be able to do this:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; if (condition) {<br>&gt;&gt;&gt;     funcWithSideEffectsThatReturnsInt()<br>&gt;&gt;&gt; } else {<br>&gt;&gt;&gt;     funcWithSideEffectsThatReturnsString()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; but that&#39;s not a valid expression (what is its type?).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; That would actually be no problem if Swift’s type system would have<br>&gt;&gt;&gt; union types (Ceylon has union and intersection types which are quite<br>&gt;&gt;&gt; awesome and enable lots of nice things quite naturally, see<br>&gt;&gt;&gt; http://ceylon-lang.org/documentation/1.2/tour/types/).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In that case the type of such an expression would just be the union of<br>&gt;&gt;&gt; both types, which is written   Int | String   in Ceylon.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; *_______________________________________________*<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Untracked with   Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/7f05a68f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85c55778d88fe0cd357b60a7a3ad81b3?s=50"></div><header><strong>ternary operator ?: suggestion</strong> from <string>Paul Ossenbruggen</string> &lt;possen at gmail.com&gt;<p>December  6, 2015 at 01:00:00pm</p></header><div class="content"><p>Got ya, so for a more complex example:<br></p><p>let myColor = (match yourColor <br>	case .Blue :  .Reds<br>	case .Green: .Blue <br>	case .Red: match  shade .LightRed : LightGreen, .MediumRed :  .DarkGreen :  DarkRed <br>	default: .Yellow<br>)<br></p><p>for booleans I would not want to list the true false cases out though.<br></p><p>let myColor = match boolCondition  .Blue, .Red <br></p><p><br></p><p>&gt; On Dec 6, 2015, at 1:32 PM, Alex Lew &lt;alexl.mail+swift at gmail.com&gt; wrote:<br>&gt; <br>&gt; To clarify, I would want parens around the entire expression (only when necessary). So<br>&gt; <br>&gt; let myColor = match yourColor<br>&gt;  case .Blue :  .Red<br>&gt;  case .Green: .Blue <br>&gt;  case .Red: .Green<br>&gt;  default: .Yellow<br>&gt; <br>&gt; or<br>&gt; <br>&gt; let myColor = match boolCondition<br>&gt;   case true: .Blue<br>&gt;   case false: .Red<br>&gt; <br>&gt; or<br>&gt; <br>&gt; let myColor = match boolCondition<br>&gt;   case true: (match yourColor<br>&gt;                       case .Red: .Blue<br>&gt;                       default: .Yellow)<br>&gt;   case false: .Red<br>&gt; <br>&gt; But I actually think that the parens are unnecessary, as long as we require matches to be exhaustive and for there to be no unreachable cases.<br>&gt; <br>&gt; On Sun, Dec 6, 2015 at 4:17 PM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote:<br>&gt; I agree that ? may imply optional, this may be similar to what you suggested, just filling in the example: Not sure parenthesis are better than braces though:<br>&gt; <br>&gt; et myColor = match yourColor ( .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow )<br>&gt; <br>&gt; let myColor = match yourColor ( case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow )<br>&gt; <br>&gt; let myColor = match yourColor (<br>&gt;   case .Blue :  .Reds<br>&gt;  case .Green: .Blue <br>&gt;  case .Red: .Green<br>&gt;  default: .Yellow<br>&gt; )<br>&gt; <br>&gt; let myColor = match yourColor (<br>&gt;   .Blue :  .Reds<br>&gt;  .Green: .Blue <br>&gt;  .Red: .Green<br>&gt;  default: .Yellow<br>&gt; )<br>&gt; <br>&gt; let myColor = match boollCondition ( .Blue, .Red ) <br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Dec 6, 2015, at 12:54 PM, Alex Lew &lt; alexl.mail+swift at gmail.com &lt;mailto:alexl.mail+swift at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hmm. Something about braces inside expressions just feels wrong to me.<br>&gt;&gt; <br>&gt;&gt; I also read switch? and if? as being some optional-related versions of switch and if. And I don&#39;t love putting the condition / value-to-switch-on before the keyword, if we&#39;re going to use a keyword.<br>&gt;&gt; <br>&gt;&gt; (Also: exhaustiveness checking could theoretically allow resolution of ambiguity in nested switch expressions. We would just have to require that as soon as you&#39;ve exhausted all possibilities, you don&#39;t add more cases and the expression is over.)<br>&gt;&gt; <br>&gt;&gt; On Sun, Dec 6, 2015 at 3:46 PM, Paul Ossenbruggen &lt;possen at gmail.com &lt;mailto:possen at gmail.com&gt;&gt; wrote: <br>&gt;&gt; Yep probably does need braces: So for switch? if? suggestion i just made. <br>&gt;&gt; <br>&gt;&gt; let myColor = yourColor switch? { .Blue :  .Red, .Green: .Blue, .Red: .Green, default: .Yellow }<br>&gt;&gt; <br>&gt;&gt; let myColor = yourColor switch? { case .Blue : .Red; case .Green: .Blue;  case .Red: .Green; default: .Yellow }<br>&gt;&gt; <br>&gt;&gt; let myColor = yourColor switch? {<br>&gt;&gt;  case .Blue :  .Reds<br>&gt;&gt;   case .Green: .Blue <br>&gt;&gt;  case .Red: .Green<br>&gt;&gt;  default: .Yellow<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let myColor = yourColor switch? {<br>&gt;&gt;  .Blue :  .Reds<br>&gt;&gt;  .Green: .Blue <br>&gt;&gt;  .Red: .Green<br>&gt;&gt;  default: .Yellow<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; let myColor = condition if?  { .Blue; .Red }<br>&gt;&gt; <br>&gt;&gt; I don’t find that looks bad. <br>&gt;&gt; <br>&gt;&gt; - Paul <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 6, 2015, at 12:24 PM, Alex Lew via swift-evolution &lt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks for the feedback, Matthew. It&#39;s sensible to me to consider dropping the ternary operator. I like it because the analogy &quot;C&#39;s if is to Swift&#39;s if as C&#39;s ternary operator is to Swift&#39;s ternary operator&quot; is (sort of) satisfied. But it is also confusing, both for the reasons you mention, and because ? has other meanings in Swift:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  // compiler error without space betw thatColor and ? <br>&gt;&gt;&gt; let thisColor = thatColor? <br>&gt;&gt;&gt;      case .Red: .Green<br>&gt;&gt;&gt;      default: .Blue<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, is it really worth it to have control flow expressions if they don&#39;t let your code look nicer?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor = switch thatColor {<br>&gt;&gt;&gt;      case .Red:<br>&gt;&gt;&gt;           return .Green;<br>&gt;&gt;&gt;      default:<br>&gt;&gt;&gt;           return .Yellow;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; really isn&#39;t much nicer than<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor: Color<br>&gt;&gt;&gt; switch thatColor {<br>&gt;&gt;&gt;      case .Red:<br>&gt;&gt;&gt;           thisColor = .Green<br>&gt;&gt;&gt;      default:<br>&gt;&gt;&gt;           thisColor = .Yellow<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Maybe we could do a compromise, something like<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor = switch thatColor<br>&gt;&gt;&gt;      case .Red: .Green // must be an expression<br>&gt;&gt;&gt;      default: .Yellow      // must be an expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Or we could introduce a new keyword? Like   match:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;&gt;       case .Red: .Green    // must be an expression<br>&gt;&gt;&gt;       default: .Yellow         // must be an expression<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I sort of like the new-keyword approach, because even though this is similar to a switch, it&#39;s not a switch: there&#39;s no fallthrough, you can&#39;t put statements inside, etc.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with all these proposals:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;&gt;      case .Red: match thatOtherColor<br>&gt;&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;&gt;                            default: .Orange<br>&gt;&gt;&gt;      default: .Orange<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; is ambiguous. (Does case .Pink match thatColor or thatOtherColor? We can know because of exhaustiveness checking, but this won&#39;t always work.) You could solve this problem either by using parentheses around the whole expression when necessary<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor = match thatColor<br>&gt;&gt;&gt;      case .Red: (match thatOtherColor<br>&gt;&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;&gt;                            default: .Orange)<br>&gt;&gt;&gt;      default: .Orange<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; or by adding curly braces in again<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let thisColor = match thatColor {<br>&gt;&gt;&gt;      case .Red: match thatOtherColor {<br>&gt;&gt;&gt;                            case .Blue: .Green<br>&gt;&gt;&gt;                            case .Pink: .Yellow<br>&gt;&gt;&gt;                            default: .Orange<br>&gt;&gt;&gt;                         }<br>&gt;&gt;&gt;      default: .Orange<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But that starts to look like switch again. (Of course, the best way to handle this is as a programmer is to just switch on the tuple (thatColor, thatOtherColor), but the language should allow for nested control expressions.)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sun, Dec 6, 2015 at 2:48 PM, Matthew Johnson via swift-evolution   &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;  wrote: <br>&gt;&gt;&gt; I am not a fan of this approach based on the ternary operator.  The ternary operator is already a bit of an anomaly in that all other operators are unary or binary and do not perform any control flow (beyond possibly short circuiting an autoclosure argument).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would much rather features that perform control flow continue to use keywords, but allow them to be expressions.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Once we have control flow expressions I would like to see the ternary operator removed from the language as it would no longer server a purpose.  Removing the ternary operator seems to fit nicely with the direction to remove some features that are carried over from C-based languages but don’t necessarily fit with the direction Swift is heading.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 6, 2015, at 1:19 PM, Kevin Lundberg via swift-evolution &lt;   swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Ostensibly, case may not be necessary if you could delimit each case on one line with something (perhaps a comma, or something else if that would not fit well within the grammar):   <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; let thisColor = thatColor ? .Blue: .Red, .Green: .Blue, .Red: .Green, default: .Yellow   <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; On Sun, Dec 6, 2015, at 01:57 PM, Paul Ossenbruggen via swift-evolution wrote:   <br>&gt;&gt;&gt;&gt;&gt; I like this too, seems more powerful.  Also, would single line expressions be allowed?  If not would case be required for example:   <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt; let myFavoriteColor = yourFavoriteColor ?   <br>&gt;&gt;&gt;&gt;&gt;      case .Blue: .Red   <br>&gt;&gt;&gt;&gt;&gt;      case .Green: .Blue   <br>&gt;&gt;&gt;&gt;&gt;      case .Red: .Green   <br>&gt;&gt;&gt;&gt;&gt;      default: .Yellow   <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 9:11 AM, Sean Heber via swift-evolution &lt;   swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:   <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; I really like this train of thought. +1   <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; l8r   <br>&gt;&gt;&gt;&gt;&gt;&gt; Sean   <br>&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt; On Dec 6, 2015, at 11:02 AM, Alex Lew via swift-evolution &lt;   swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; What if we left the if { ...} else { ... } syntax alone (as a statement), and updated the ternary expression to be a more general pattern matching expression (closer to &quot;switch&quot;)? Something like   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x = condition ?   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    true: &quot;Hello&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    false: &quot;Goodbye&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let x = optionalValue ?   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    .Some(let unwrapped): &quot;Hello, \(unwrapped)&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;    .None: &quot;To Whom It May Concern&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let myFavoriteColor = yourFavoriteColor ?   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Blue: .Red   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Green: .Blue   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      .Red: .Green   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; let quadrant = (x, y) ?   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let (x, y) where x &lt; 50 &amp;&amp; y &lt; 50: &quot;top left&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let (x, y) where x &lt; 50 &amp;&amp; y &gt; 50: &quot;bottom left&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      let (x, y) where x &gt; 50 &amp;&amp; y &lt; 50: &quot;top right&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;      default: &quot;bottom right&quot;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The colon comes from the fact that this is sort of a light-weight expression-based &quot;switch&quot; statement, where each branch can only contain an expression, not a series of statements.   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is very similar to pattern matching expressions in languages like Haskell, ML, and Coq.   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Sun, Dec 6, 2015 at 11:25 AM, Thorsten Seitz   &lt;thorsten.seitz at web.de &lt;mailto:thorsten.seitz at web.de&gt;&gt;   wrote:   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Am 06.12.2015 um 01:28 schrieb Alex Lew via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I don&#39;t think you can just get rid of the if statement in favor of an expression. You still want to be able to do this:   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; if (condition) {   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     funcWithSideEffectsThatReturnsInt()   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; } else {   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     funcWithSideEffectsThatReturnsString()   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; but that&#39;s not a valid expression (what is its type?).   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; That would actually be no problem if Swift’s type system would have union types (Ceylon has union and intersection types which are quite awesome and enable lots of nice things quite naturally, see   http://ceylon-lang.org/documentation/1.2/tour/types/ &lt;http://ceylon-lang.org/documentation/1.2/tour/types/&gt;).   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; In that case the type of such an expression would just be the union of both types, which is written   Int | String   in Ceylon.   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; -Thorsten   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt; _______________________________________________   <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list   <br>&gt;&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;   <br>&gt;&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;   <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________   <br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list   <br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;   <br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;   <br>&gt;&gt;&gt;&gt;  <br>&gt;&gt;&gt;&gt; _______________________________________________   <br>&gt;&gt;&gt;&gt; swift-evolution mailing list   <br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;   <br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;   <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Untracked with   Trackbuster &lt;https://trackbuster.com/?sig&gt;<br>&gt;&gt;&gt; _______________________________________________ <br>&gt;&gt;&gt; swift-evolution mailing list <br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt; <br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________ <br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br>&gt; Untracked with Trackbuster &lt;https://trackbuster.com/?sig&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151206/4daf8bd3/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
