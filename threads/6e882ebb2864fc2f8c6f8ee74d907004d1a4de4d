<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/75f8396d91a35711f910866c8791c4df?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>Muhammad Tahir Vali</string> &lt;tahir.vali13 at gmail.com&gt;<p>November 11, 2016 at 02:00:00pm</p></header><div class="content"><p>Im curious to know the reasoning behind why implicit-wrapped optionals<br>aren&#39;t allowed when creating tuples. Below is an example with type aliases<br>and anonymous tuples.<br></p><p>ex.<br></p><p>typealias Name = (first: String!, middle: String?, last: String!)<br></p><p>typealias Name = (first: String!, middle: String?, last: String!)!<br></p><p>var name : (first: String!, middle: String?, last: String!)<br>var name : (first: String!, middle: String?, last: String!)!<br></p><p>error from all 4 examples above:<br>Implicitly unwrapped optionals are only allowed at top level and as<br>function results<br></p><p><br>I also noticed that I can modify tuples using functions ONLY if I use<br>*inout*.<br></p><p>func name(Person : inout (first: String?, middle: String?, last: String?)) {<br></p><p>    Person.first = &quot;John&quot;<br></p><p>    Person.last = &quot;Doe&quot;<br></p><p>}<br></p><p><br>OR<br></p><p><br>func name(Person : inout Name) {<br></p><p>    Person.first = &quot;John&quot;<br></p><p>    Person.last = &quot;Doe&quot;<br></p><p>}<br></p><p>This is because tuples are passed into functions as &#39;let&#39; constants. Why<br>not add the ability to modify a copy of the tuple inside the function ?<br></p><p><br>-- <br>Best Regards,<br></p><p>Muhammad T. Vali<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/6e88de4d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e7e554db1f80d7d6041d92edd5145698?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>Hooman Mehr</string> &lt;hooman at mac.com&gt;<p>November 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Since Swift 3.0, they are no longer a normal type like Optional&lt;T&gt;. See SR-0054 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md&gt;<br></p><p>&gt; On Nov 11, 2016, at 11:54 AM, Muhammad Tahir Vali via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Im curious to know the reasoning behind why implicit-wrapped optionals aren&#39;t allowed when creating tuples. Below is an example with type aliases and anonymous tuples.<br>&gt; <br>&gt; ex. <br>&gt; typealias Name = (first: String!, middle: String?, last: String!)<br>&gt; typealias Name = (first: String!, middle: String?, last: String!)!<br>&gt; var name : (first: String!, middle: String?, last: String!)<br>&gt; var name : (first: String!, middle: String?, last: String!)!<br>&gt; <br>&gt; error from all 4 examples above:<br>&gt; Implicitly unwrapped optionals are only allowed at top level and as function results<br>&gt; <br>&gt; <br>&gt; I also noticed that I can modify tuples using functions ONLY if I use inout. <br>&gt; <br>&gt; func name(Person : inout (first: String?, middle: String?, last: String?)) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt; <br>&gt; OR <br>&gt; <br>&gt; func name(Person : inout Name) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt; <br>&gt; This is because tuples are passed into functions as &#39;let&#39; constants. Why not add the ability to modify a copy of the tuple inside the function ?<br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Best Regards,<br>&gt; <br>&gt; Muhammad T. Vali<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/30fe4840/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Nov 11, 2016, at 11:54 AM, Muhammad Tahir Vali via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Im curious to know the reasoning behind why implicit-wrapped optionals aren&#39;t allowed when creating tuples. Below is an example with type aliases and anonymous tuples.<br>&gt; <br>&gt; ex. <br>&gt; typealias Name = (first: String!, middle: String?, last: String!)<br>&gt; typealias Name = (first: String!, middle: String?, last: String!)!<br>&gt; var name : (first: String!, middle: String?, last: String!)<br>&gt; var name : (first: String!, middle: String?, last: String!)!<br>&gt; <br>&gt; error from all 4 examples above:<br>&gt; Implicitly unwrapped optionals are only allowed at top level and as function results<br></p><p>This is intentionally-designed behavior.  Preventing IUO at arbitrary locations was SE-0054:<br>  https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0054-abolish-iuo.md&gt;<br></p><p>&gt; I also noticed that I can modify tuples using functions ONLY if I use inout. <br>&gt; <br>&gt; func name(Person : inout (first: String?, middle: String?, last: String?)) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt; <br>&gt; OR <br>&gt; <br>&gt; func name(Person : inout Name) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt; <br>&gt; This is because tuples are passed into functions as &#39;let&#39; constants. Why not add the ability to modify a copy of the tuple inside the function ?<br></p><p>We used to allow &quot;var&quot; parameters, but they were removed in SE-0003:<br>  https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md&gt;<br></p><p>Tuples are values like any other; I don&#39;t know why they would warrant a special exception to that rule.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/d9e51ee5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/75f8396d91a35711f910866c8791c4df?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>Muhammad Tahir Vali</string> &lt;tahir.vali13 at gmail.com&gt;<p>November 11, 2016 at 03:00:00pm</p></header><div class="content"><p>Thank you. Overlooked that in the Swift 3 release notes.<br></p><p>On Fri, Nov 11, 2016 at 3:43 PM, John McCall &lt;rjmccall at apple.com&gt; wrote:<br></p><p>&gt; On Nov 11, 2016, at 11:54 AM, Muhammad Tahir Vali via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Im curious to know the reasoning behind why implicit-wrapped optionals<br>&gt; aren&#39;t allowed when creating tuples. Below is an example with type aliases<br>&gt; and anonymous tuples.<br>&gt;<br>&gt; ex.<br>&gt; typealias Name = (first: String!, middle: String?, last: String!)<br>&gt; typealias Name = (first: String!, middle: String?, last: String!)!<br>&gt; var name : (first: String!, middle: String?, last: String!)<br>&gt; var name : (first: String!, middle: String?, last: String!)!<br>&gt;<br>&gt; error from all 4 examples above:<br>&gt; Implicitly unwrapped optionals are only allowed at top level and as<br>&gt; function results<br>&gt;<br>&gt;<br>&gt; This is intentionally-designed behavior.  Preventing IUO at arbitrary<br>&gt; locations was SE-0054:<br>&gt;   https://github.com/apple/swift-evolution/blob/master/<br>&gt; proposals/0054-abolish-iuo.md<br>&gt;<br>&gt; I also noticed that I can modify tuples using functions ONLY if I use<br>&gt; *inout*.<br>&gt;<br>&gt; func name(Person : inout (first: String?, middle: String?, last: String?))<br>&gt; {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt;<br>&gt; OR<br>&gt;<br>&gt; func name(Person : inout Name) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt;<br>&gt; }<br>&gt;<br>&gt; This is because tuples are passed into functions as &#39;let&#39; constants. Why<br>&gt; not add the ability to modify a copy of the tuple inside the function ?<br>&gt;<br>&gt;<br>&gt; We used to allow &quot;var&quot; parameters, but they were removed in SE-0003:<br>&gt;   https://github.com/apple/swift-evolution/blob/master/<br>&gt; proposals/0003-remove-var-parameters.md<br>&gt;<br>&gt; Tuples are values like any other; I don&#39;t know why they would warrant a<br>&gt; special exception to that rule.<br>&gt;<br>&gt; John.<br>&gt;<br></p><p><br></p><p>-- <br>Best Regards,<br></p><p>Muhammad T. Vali<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/b2733b6c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8149b5bd66abbc94babfda2995153481?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>Nevin Brackett-Rozinsky</string> &lt;nevin.brackettrozinsky at gmail.com&gt;<p>November 11, 2016 at 04:00:00pm</p></header><div class="content"><p>I’ll mention this here since it’s related to tuples and optionals. Starting<br>with this setup:<br></p><p>var x, y: Int?<br>func f() -&gt; (Int, Int) { return (0, 1) }<br></p><p>This fails to compile:<br></p><p>(x, y) = f()  // Error: Cannot express tuple conversion &#39;(Int, Int)&#39; to<br>&#39;(Int?, Int?)&#39;<br></p><p>But this works fine:<br></p><p>func g() -&gt; Int { return 2 }<br>(x, y) = (g(), g())<br></p><p>What is going on, why does the first one fail, and is this a bug or does it<br>need a proposal to fix?<br></p><p>Nevin<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/9f63a7e0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c69b8eb4df5af15923fd1647a8276890?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>John McCall</string> &lt;rjmccall at apple.com&gt;<p>November 11, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Nov 11, 2016, at 1:37 PM, Nevin Brackett-Rozinsky via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I’ll mention this here since it’s related to tuples and optionals. Starting with this setup:<br>&gt; <br>&gt; var x, y: Int?<br>&gt; func f() -&gt; (Int, Int) { return (0, 1) }<br>&gt; <br>&gt; This fails to compile:<br>&gt; <br>&gt; (x, y) = f()  // Error: Cannot express tuple conversion &#39;(Int, Int)&#39; to &#39;(Int?, Int?)&#39;<br>&gt; <br>&gt; But this works fine:<br>&gt; <br>&gt; func g() -&gt; Int { return 2 }<br>&gt; (x, y) = (g(), g())<br>&gt; <br>&gt; What is going on, why does the first one fail, and is this a bug or does it need a proposal to fix?<br></p><p>It&#39;s a bug.  The error message is actually subtly telling you the problem: the type-checker literally can&#39;t express the opaque tuple conversion in the AST; when it&#39;s a raw tuple expression, it can push the element conversions into the element expressions, but it can&#39;t do that with an opaque tuple.  It&#39;s a silly restriction because of an unfortunate representational decision.<br></p><p>John.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/0cf4d159/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Implicit Optionals for Tuples &amp; Tuples as Function Parameter</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>November 11, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On 11 Nov 2016, at 19:54, Muhammad Tahir Vali via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Im curious to know the reasoning behind why implicit-wrapped optionals aren&#39;t allowed when creating tuples. Below is an example with type aliases and anonymous tuples.<br>&gt; <br>&gt; ex. <br>&gt; typealias Name = (first: String!, middle: String?, last: String!)<br>&gt; typealias Name = (first: String!, middle: String?, last: String!)!<br>&gt; var name : (first: String!, middle: String?, last: String!)<br>&gt; var name : (first: String!, middle: String?, last: String!)!<br>&gt; <br>&gt; error from all 4 examples above:<br>&gt; Implicitly unwrapped optionals are only allowed at top level and as function results<br></p><p>I think in general the direction is leaning towards getting rid of IUO&#39;s entirely if possible, as a lot of things that people use them for could be handled better in other ways; the only times I&#39;ve ever used them is to get around issues with constructors (namely the requirement to initialise everything before other methods can be called), but that could be solved by detecting or marking methods that would be safe for that.<br></p><p>&gt; I also noticed that I can modify tuples using functions ONLY if I use inout. <br>&gt; <br>&gt; func name(Person : inout (first: String?, middle: String?, last: String?)) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt; <br>&gt; OR <br>&gt; <br>&gt; func name(Person : inout Name) {<br>&gt;     Person.first = &quot;John&quot;<br>&gt;     Person.last = &quot;Doe&quot;<br>&gt; }<br>&gt; <br>&gt; This is because tuples are passed into functions as &#39;let&#39; constants. Why not add the ability to modify a copy of the tuple inside the function ?<br></p><p>The ability to specify function arguments as mutable was removed to avoid confusion with inout as it wasn&#39;t completely obvious that with a var what you&#39;re modifying is a copy. However you can make a mutable copy with shadowing, like-so:<br></p><p>	func name(Person:(first:String?, middle:String?, last:String?) { var Person = Person // Person is now a mutable copy<br>		Person.first = &quot;John&quot;<br>		Person.last = &quot;Doe&quot;<br>	}<br></p><p>Obviously with the caveat that these changes don&#39;t exist outside of that scope, so unless you make use of them there that code will likely just get optimised away.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20161111/2ac53f31/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
