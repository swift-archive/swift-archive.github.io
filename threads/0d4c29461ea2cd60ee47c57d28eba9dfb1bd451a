<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 28, 2016 at 01:00:00am</p></header><div class="content"><p>Howard Lovatt via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I like the proposal but would suggest you rename it Trait and not Mixin,<br>&gt; since you proposal has Trait and not Mixin behaviour. The difference is<br>&gt; that the order of inheritance is not important with Traits but is with<br>&gt; Mixins, EG:<br>&gt; <br>&gt;     protocol A { let msg = &quot;A&quot; }<br>&gt;     protocol B { let msg = &quot;B&quot; }<br>&gt;     struct MixinAB: A, B {}<br>&gt;     MixinAB().msg // B<br>&gt; <br>&gt;   Whereas<br>&gt; <br>&gt;     struct MixinBA: B, A {}<br>&gt;     MixinBA().msg // A<br>&gt; <br>&gt; With traits the order is not important, and has to be resolved by the<br>&gt; programmer when a conflict arises:<br>&gt; <br>&gt;     struct ErrorAB: A, B {} // An error because there are two `msg`s.<br>&gt; <br>&gt; You have to do:<br>&gt; <br>&gt;     struct TraitAB: A, B { // Could be B, A - makes no difference<br>&gt;         let msg = A.msg // Select A&#39;s definition, could be `= B.msg`, could<br>&gt; be `= 3` (i.e. any valid Swift)<br>&gt;     }<br>&gt; <br>&gt; As an aside I don&#39;t get what you mean by your example:<br>&gt; <br>&gt; protocol&lt;A, B&gt;  // error<br></p><p>This is the spelling for the protocol composition of A and B. <br></p><p>&gt; <br>&gt; Protocols cannot be generic!<br>&gt; <br>&gt; On Sunday, 28 February 2016, Anton Zhilin via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; 0. Please read the whole proposal and this whole message before replying.<br>&gt;&gt; <br>&gt;&gt; 1.<br>&gt;&gt;&gt; In short words, protocol will became a sort of class and no longer a<br>&gt;&gt; true kind of contract to conform to.<br>&gt;&gt; <br>&gt;&gt; There is an option to introduce &quot;mixin&quot; keyword:<br>&gt;&gt; mixin M {<br>&gt;&gt; var storage: Int = 0<br>&gt;&gt; }<br>&gt;&gt; It won&#39;t cause confusion with today&#39;s protocols.<br>&gt;&gt; For difference from classes, see under 3.<br>&gt;&gt; <br>&gt;&gt; 2.<br>&gt;&gt;&gt; What about compatibility with Objective C ?<br>&gt;&gt; <br>&gt;&gt; Protocols cannot inherit from classes, including NSObject.<br>&gt;&gt; [Warning: IMO ahead]<br>&gt;&gt; But I personally think that we should move from abstract classes in Obj-C,<br>&gt;&gt; where possible. Actually, all classes in Obj-C can be instantiated, so I<br>&gt;&gt; consider this a bad abstraction.<br>&gt;&gt; <br>&gt;&gt; 3.<br>&gt;&gt;&gt; (see David&#39;s message)<br>&gt;&gt; Firstly, what you&#39;ve shown is not a diamond problem. No dequate<br>&gt;&gt; programming language would allow you to do what you&#39;ve shown. Secondly,<br>&gt;&gt; please read the whole proposal, as I specifically addressed the issue there.<br>&gt;&gt; <br>&gt;&gt; Now, to difference from classes.<br>&gt;&gt; The largest difference between classes and mixins comes in inheritance. We<br>&gt;&gt; can allow multiple inheritance, because we can solve diamond problem with<br>&gt;&gt; mixins.<br>&gt;&gt; Let&#39;s take the example from my proposal:<br>&gt;&gt; <br>&gt;&gt; protocol A { var x: Int = 1 }<br>&gt;&gt; protocol B: A { }<br>&gt;&gt; protocol C: A { }<br>&gt;&gt; struct D : B, C { }<br>&gt;&gt; <br>&gt;&gt; What really happens here is the following:<br>&gt;&gt; <br>&gt;&gt; protocol ASelf { var x: Int = 1 }<br>&gt;&gt; protocol BSelf { }<br>&gt;&gt; protocol CSelf { }<br>&gt;&gt; struct D : ASelf, BSelf, CSelf { }<br>&gt;&gt; <br>&gt;&gt; We can do this, because mixins are statically dispatched. The compiler<br>&gt;&gt; will enumerate all included mixins and mix in only one version of each.<br>&gt;&gt; I said statically dispatched, but in Swift, compiler can automatically<br>&gt;&gt; create wrappers with necessary closures inside if we need dynamic dispatch<br>&gt;&gt; for protocols, so that is not a real concern.<br>&gt;&gt; Diamond problem is solved the same way in Python and Ruby, so I&#39;m not<br>&gt;&gt; inventing something new here.<br>&gt;&gt; Mixins tend to &quot;mix in behaviours&quot;. Let&#39;s take an example usage of diamond<br>&gt;&gt; pattern:<br>&gt;&gt; <br>&gt;&gt; protocol SignalSender {<br>&gt;&gt; private var slots: [String: [() -&gt; ()]] = []<br>&gt;&gt; func connect(signal: String, to slot: () -&gt; ()) { ... }<br>&gt;&gt; func fire(signal: String) { ... }<br>&gt;&gt; }<br>&gt;&gt; protocol A : SignalSender {<br>&gt;&gt; // Use signal functionality<br>&gt;&gt; }<br>&gt;&gt; protocol B : SignalSender {<br>&gt;&gt; // Use signal functionality<br>&gt;&gt; }<br>&gt;&gt; struct C : A, B { }<br>&gt;&gt; <br>&gt;&gt; A and B both use a single SignalSender, incorporated within final object.<br>&gt;&gt; If SignalSender supports its invariants through incapsulation, nothing will<br>&gt;&gt; ever break them. If it doesn&#39;t, then, well, this mixin is not perfectly<br>&gt;&gt; suited for multiple inheritance.<br>&gt;&gt; <br>&gt;&gt; If you have reached this far, thank you!<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/10d0339242a000b0b683ed1d5e25a110?s=50"></div><header><strong>[Draft] Mixins</strong> from <string>Howard Lovatt</string> &lt;howard.lovatt at gmail.com&gt;<p>February 28, 2016 at 01:00:00pm</p></header><div class="content"><p>Thanks for clarifying `protocol&lt;A, B&gt;`. In that case  `protocol&lt;A, B&gt;` is<br>not necessarily an error for traits, but the ambiguity needs resolving.<br></p><p>On Sunday, 28 February 2016, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Howard Lovatt via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt; I like the proposal but would suggest you rename it Trait and not Mixin,<br>&gt; &gt; since you proposal has Trait and not Mixin behaviour. The difference is<br>&gt; &gt; that the order of inheritance is not important with Traits but is with<br>&gt; &gt; Mixins, EG:<br>&gt; &gt;<br>&gt; &gt;     protocol A { let msg = &quot;A&quot; }<br>&gt; &gt;     protocol B { let msg = &quot;B&quot; }<br>&gt; &gt;     struct MixinAB: A, B {}<br>&gt; &gt;     MixinAB().msg // B<br>&gt; &gt;<br>&gt; &gt;   Whereas<br>&gt; &gt;<br>&gt; &gt;     struct MixinBA: B, A {}<br>&gt; &gt;     MixinBA().msg // A<br>&gt; &gt;<br>&gt; &gt; With traits the order is not important, and has to be resolved by the<br>&gt; &gt; programmer when a conflict arises:<br>&gt; &gt;<br>&gt; &gt;     struct ErrorAB: A, B {} // An error because there are two `msg`s.<br>&gt; &gt;<br>&gt; &gt; You have to do:<br>&gt; &gt;<br>&gt; &gt;     struct TraitAB: A, B { // Could be B, A - makes no difference<br>&gt; &gt;         let msg = A.msg // Select A&#39;s definition, could be `= B.msg`,<br>&gt; could<br>&gt; &gt; be `= 3` (i.e. any valid Swift)<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt; As an aside I don&#39;t get what you mean by your example:<br>&gt; &gt;<br>&gt; &gt; protocol&lt;A, B&gt;  // error<br>&gt;<br>&gt; This is the spelling for the protocol composition of A and B.<br>&gt;<br>&gt; &gt;<br>&gt; &gt; Protocols cannot be generic!<br>&gt; &gt;<br>&gt; &gt; On Sunday, 28 February 2016, Anton Zhilin via swift-evolution &lt;<br>&gt; &gt; swift-evolution at swift.org &lt;javascript:;&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; 0. Please read the whole proposal and this whole message before<br>&gt; replying.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 1.<br>&gt; &gt;&gt;&gt; In short words, protocol will became a sort of class and no longer a<br>&gt; &gt;&gt; true kind of contract to conform to.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; There is an option to introduce &quot;mixin&quot; keyword:<br>&gt; &gt;&gt; mixin M {<br>&gt; &gt;&gt; var storage: Int = 0<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; It won&#39;t cause confusion with today&#39;s protocols.<br>&gt; &gt;&gt; For difference from classes, see under 3.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 2.<br>&gt; &gt;&gt;&gt; What about compatibility with Objective C ?<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Protocols cannot inherit from classes, including NSObject.<br>&gt; &gt;&gt; [Warning: IMO ahead]<br>&gt; &gt;&gt; But I personally think that we should move from abstract classes in<br>&gt; Obj-C,<br>&gt; &gt;&gt; where possible. Actually, all classes in Obj-C can be instantiated, so I<br>&gt; &gt;&gt; consider this a bad abstraction.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; 3.<br>&gt; &gt;&gt;&gt; (see David&#39;s message)<br>&gt; &gt;&gt; Firstly, what you&#39;ve shown is not a diamond problem. No dequate<br>&gt; &gt;&gt; programming language would allow you to do what you&#39;ve shown. Secondly,<br>&gt; &gt;&gt; please read the whole proposal, as I specifically addressed the issue<br>&gt; there.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Now, to difference from classes.<br>&gt; &gt;&gt; The largest difference between classes and mixins comes in inheritance.<br>&gt; We<br>&gt; &gt;&gt; can allow multiple inheritance, because we can solve diamond problem<br>&gt; with<br>&gt; &gt;&gt; mixins.<br>&gt; &gt;&gt; Let&#39;s take the example from my proposal:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol A { var x: Int = 1 }<br>&gt; &gt;&gt; protocol B: A { }<br>&gt; &gt;&gt; protocol C: A { }<br>&gt; &gt;&gt; struct D : B, C { }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; What really happens here is the following:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol ASelf { var x: Int = 1 }<br>&gt; &gt;&gt; protocol BSelf { }<br>&gt; &gt;&gt; protocol CSelf { }<br>&gt; &gt;&gt; struct D : ASelf, BSelf, CSelf { }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; We can do this, because mixins are statically dispatched. The compiler<br>&gt; &gt;&gt; will enumerate all included mixins and mix in only one version of each.<br>&gt; &gt;&gt; I said statically dispatched, but in Swift, compiler can automatically<br>&gt; &gt;&gt; create wrappers with necessary closures inside if we need dynamic<br>&gt; dispatch<br>&gt; &gt;&gt; for protocols, so that is not a real concern.<br>&gt; &gt;&gt; Diamond problem is solved the same way in Python and Ruby, so I&#39;m not<br>&gt; &gt;&gt; inventing something new here.<br>&gt; &gt;&gt; Mixins tend to &quot;mix in behaviours&quot;. Let&#39;s take an example usage of<br>&gt; diamond<br>&gt; &gt;&gt; pattern:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; protocol SignalSender {<br>&gt; &gt;&gt; private var slots: [String: [() -&gt; ()]] = []<br>&gt; &gt;&gt; func connect(signal: String, to slot: () -&gt; ()) { ... }<br>&gt; &gt;&gt; func fire(signal: String) { ... }<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; protocol A : SignalSender {<br>&gt; &gt;&gt; // Use signal functionality<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; protocol B : SignalSender {<br>&gt; &gt;&gt; // Use signal functionality<br>&gt; &gt;&gt; }<br>&gt; &gt;&gt; struct C : A, B { }<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; A and B both use a single SignalSender, incorporated within final<br>&gt; object.<br>&gt; &gt;&gt; If SignalSender supports its invariants through incapsulation, nothing<br>&gt; will<br>&gt; &gt;&gt; ever break them. If it doesn&#39;t, then, well, this mixin is not perfectly<br>&gt; &gt;&gt; suited for multiple inheritance.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; If you have reached this far, thank you!<br>&gt; &gt;&gt; _______________________________________________<br>&gt; &gt;&gt; swift-evolution mailing list<br>&gt; &gt;&gt; swift-evolution at swift.org &lt;javascript:;&gt; &lt;javascript:;&gt;<br>&gt; &gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; &gt;&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;javascript:;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br>-- <br>-- Howard.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160228/14e576b5/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
