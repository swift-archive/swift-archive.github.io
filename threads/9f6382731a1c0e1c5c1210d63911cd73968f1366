<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 26, 2016 at 10:00:00am</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/9f631366/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8b9f0c10986385f3c7f50615d6176be3?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Pierre Monod-Broca</string> &lt;pierre at monod-broca.fr&gt;<p>February 26, 2016 at 02:00:00pm</p></header><div class="content"><p>For me it&#39;s<br> * -1 to have infix symmetrical operators (==, !=) be instance methods<br> * -0.5 for the operator keyword<br> * +1 to move the operators implementation inside class/struct/extension scope<br></p><p>In my experience == is a good example of operators better implemented as static funcs.<br></p><p><br></p><p>&gt; Le 26 févr. 2016 à 11:48, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Looks good to me, although I&#39;m torn on the &quot;operator&quot; keyword. While I like it because it distinguishes operators from methods, so that there is no confusion about a missing implicit &quot;self&quot; within an operator definition, I am not happy about losing &quot;operator&quot; as a method or variable name.<br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt; Am 25. Februar 2016 um 20:59 schrieb Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt;&gt; Hello.<br>&gt;&gt; <br>&gt;&gt; The proposal can be also read at https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5 &lt;https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5&gt;<br>&gt;&gt; <br>&gt;&gt; Original thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt;&gt; <br>&gt;&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt;&gt; <br>&gt;&gt; -Van<br>&gt;&gt; <br>&gt;&gt; ---------<br>&gt;&gt; <br>&gt;&gt; Instance Operators<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-NNNN &lt;https://github.com/apple/swift-evolution/blob/master/proposals/NNNN-instance-operators.md&gt;<br>&gt;&gt; Author: Vanderlei Martinelli &lt;https://github.com/vmartinelli&gt;<br>&gt;&gt; Status: Awaiting review<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt;&gt; <br>&gt;&gt; Swift-evolution thread: link to the discussion thread for that proposal &lt;https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html&gt;<br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; // MARK: - protocol<br>&gt;&gt; <br>&gt;&gt; public protocol MyDoubleType {<br>&gt;&gt;     public func someUsefulFunction()<br>&gt;&gt; <br>&gt;&gt;     public func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;     public postfix func ++(inout x: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // MARK: - implementation<br>&gt;&gt; <br>&gt;&gt; extension Double: MyDoubleType {<br>&gt;&gt; <br>&gt;&gt;     public func someUsefulFunction() {<br>&gt;&gt;         // ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // we cannot implement the operators here...<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // ... but have to implement them here<br>&gt;&gt; <br>&gt;&gt; public func *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;&gt;     return lhs.multipliedBy(rhs)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; public postfix func ++(inout x: Double) -&gt; Double {<br>&gt;&gt;     x += 1.0<br>&gt;&gt;     return x<br>&gt;&gt; }<br>&gt;&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt;&gt; <br>&gt;&gt; Proposed solution<br>&gt;&gt; <br>&gt;&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using the operator keyword.<br>&gt;&gt; <br>&gt;&gt; Detailed design<br>&gt;&gt; <br>&gt;&gt; Protocol conformance<br>&gt;&gt; <br>&gt;&gt; After the change the above code can be written like the example bellow.<br>&gt;&gt; <br>&gt;&gt; // MARK: - protocol<br>&gt;&gt; <br>&gt;&gt; public protocol MyDoubleType {<br>&gt;&gt;     public func someUsefulFunction()<br>&gt;&gt; <br>&gt;&gt;     public operator *(rhs: Self) -&gt; Self<br>&gt;&gt;     public mutating postfix operator ++() -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // MARK: - implementation<br>&gt;&gt; <br>&gt;&gt; extension Double: MyDoubleType {<br>&gt;&gt; <br>&gt;&gt;     public func someUsefulFunction() {<br>&gt;&gt;         // ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public operator *(rhs: Double) -&gt; Double {<br>&gt;&gt;         return self.multipliedBy(rhs)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public mutating postfix operator ++() -&gt; Double {<br>&gt;&gt;        self += 1.0<br>&gt;&gt;        return self<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; Operator funcs everywhere<br>&gt;&gt; <br>&gt;&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt;&gt; <br>&gt;&gt; Operator internal names<br>&gt;&gt; <br>&gt;&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt __operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator introduction would be:<br>&gt;&gt; <br>&gt;&gt; infix operator &gt;= {<br>&gt;&gt;     associativity none<br>&gt;&gt;     precedence 130<br>&gt;&gt;     name &quot;GreaterThanOrEqual&quot;<br>&gt;&gt; }<br>&gt;&gt; So the code will be written like this...<br>&gt;&gt; <br>&gt;&gt; struct MyStruct {<br>&gt;&gt;     operator &gt;=(other: MyStruct) -&gt; Bool {<br>&gt;&gt;         return ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; ... but translated internally to this:<br>&gt;&gt; <br>&gt;&gt; struct MyStruct {<br>&gt;&gt;     func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool {<br>&gt;&gt;         return ...<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; Impact on existing code<br>&gt;&gt; <br>&gt;&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt;&gt; <br>&gt;&gt; Also the func keyword would be deprecated for operators as well, using the operator to declare/implement an operator func.<br>&gt;&gt; <br>&gt;&gt; Alternatives considered<br>&gt;&gt; <br>&gt;&gt; Status quo<br>&gt;&gt; <br>&gt;&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt;&gt; <br>&gt;&gt; Static implementation inside extension/struct/class scope<br>&gt;&gt; <br>&gt;&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt;&gt; <br>&gt;&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt;&gt; <br>&gt;&gt; Example:<br>&gt;&gt; <br>&gt;&gt; // MARK: - protocol<br>&gt;&gt; <br>&gt;&gt; public protocol MyDoubleType {<br>&gt;&gt;     public func someUsefulFunction()<br>&gt;&gt; <br>&gt;&gt;     public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>&gt;&gt;     public static postfix operator ++(inout x: Self) -&gt; Self<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; // MARK: - implementation<br>&gt;&gt; <br>&gt;&gt; extension Double: MyDoubleType {<br>&gt;&gt; <br>&gt;&gt;     public func someUsefulFunction() {<br>&gt;&gt;         // ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public static operator *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;&gt;         return lhs.multipliedBy(rhs)<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     // this should be implemented inside a Int64 type, not here...<br>&gt;&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 {<br>&gt;&gt;         // ...<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt;     public static postfix operator ++(inout x: Double) -&gt; Double {<br>&gt;&gt;         x += 1.0<br>&gt;&gt;         return x<br>&gt;&gt;     }<br>&gt;&gt; <br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/8707ecfd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Instance Operators</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>February 26, 2016 at 04:00:00pm</p></header><div class="content"><p>Oops, seems I read the proposal too fast.<br></p><p>I&#39;m totally against symmetric implementing infix operators as instance methods!<br></p><p>I misread the proposal to just being able to group the definitions within a class or struct body. That&#39;s why I commented on the operator keyword as I did...<br></p><p>So, -1 for the proposal.<br></p><p>-Thorsten <br></p><p>&gt; Am 26.02.2016 um 14:40 schrieb Pierre Monod-Broca &lt;pierre at monod-broca.fr&gt;:<br>&gt; <br>&gt; For me it&#39;s<br>&gt;  * -1 to have infix symmetrical operators (==, !=) be instance methods<br>&gt;  * -0.5 for the operator keyword<br>&gt;  * +1 to move the operators implementation inside class/struct/extension scope<br>&gt; <br>&gt; In my experience == is a good example of operators better implemented as static funcs.<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; Le 26 févr. 2016 à 11:48, Thorsten Seitz via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; Looks good to me, although I&#39;m torn on the &quot;operator&quot; keyword. While I like it because it distinguishes operators from methods, so that there is no confusion about a missing implicit &quot;self&quot; within an operator definition, I am not happy about losing &quot;operator&quot; as a method or variable name.<br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 25. Februar 2016 um 20:59 schrieb Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hello.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal can be also read at https://gist.github.com/vmartinelli/67d6ad234c7a4e14f8d5<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Original thread: https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008508.html<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Opinions, comments and corrections (including on English grammar) are all welcome. :-)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Van<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; ---------<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Instance Operators<br>&gt;&gt;&gt; Proposal: SE-NNNN<br>&gt;&gt;&gt; Author: Vanderlei Martinelli<br>&gt;&gt;&gt; Status: Awaiting review<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The proposal aims to move operator implementation from the global and static scope into extension/struct/class instance scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Swift-evolution thread: link to the discussion thread for that proposal<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; When writing the protocol interface the operator is declarated inside the scope of that protocol, but its implementation has to be static and global. This, besides being inconsistent, might not the behaviour expected by programmers coming from other languages that have some kind of support for interface/protocol and operator implementation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // MARK: - protocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol MyDoubleType {<br>&gt;&gt;&gt;     public func someUsefulFunction()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     public postfix func ++(inout x: Self) -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // MARK: - implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Double: MyDoubleType {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func someUsefulFunction() {<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // we cannot implement the operators here...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // ... but have to implement them here<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;&gt;&gt;     return lhs.multipliedBy(rhs)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public postfix func ++(inout x: Double) -&gt; Double {<br>&gt;&gt;&gt;     x += 1.0<br>&gt;&gt;&gt;     return x<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Also the current implementation does not leave much room for future expansion in the use of operators (such as conversion between values, for example).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Move the operator implementation into the extension/struct/class scope and turn operator funcs into instance funcs, using the operator keyword.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Detailed design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocol conformance<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; After the change the above code can be written like the example bellow.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // MARK: - protocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol MyDoubleType {<br>&gt;&gt;&gt;     public func someUsefulFunction()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public operator *(rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     public mutating postfix operator ++() -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // MARK: - implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Double: MyDoubleType {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func someUsefulFunction() {<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public operator *(rhs: Double) -&gt; Double {<br>&gt;&gt;&gt;         return self.multipliedBy(rhs)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public mutating postfix operator ++() -&gt; Double {<br>&gt;&gt;&gt;        self += 1.0<br>&gt;&gt;&gt;        return self<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Operator funcs everywhere<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; An operator does not have to be implemented only to conform to a protocol, however. It can be also be implemented in any other place where a common func is. This means that even the current form can be supported.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Operator internal names<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Perhaps because of the internal implementation of Swift, operators have to have names to be handled. The suggestion is to adopt __operator__GreaterThanOrEqual for a &gt;= operator, as example. The operator introduction would be:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; infix operator &gt;= {<br>&gt;&gt;&gt;     associativity none<br>&gt;&gt;&gt;     precedence 130<br>&gt;&gt;&gt;     name &quot;GreaterThanOrEqual&quot;<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; So the code will be written like this...<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MyStruct {<br>&gt;&gt;&gt;     operator &gt;=(other: MyStruct) -&gt; Bool {<br>&gt;&gt;&gt;         return ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; ... but translated internally to this:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; struct MyStruct {<br>&gt;&gt;&gt;     func __operator__GreaterThanOrEqual(other: MyStruct) -&gt; Bool {<br>&gt;&gt;&gt;         return ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Impact on existing code<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Since after this change an operator can be implemented in any other place where a common func can be, the current implementation may continue to exist, but marked as deprecated with a compiler/analyser warning.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Also the func keyword would be deprecated for operators as well, using the operator to declare/implement an operator func.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives considered<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Status quo<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Leave things as they are. Even being inconsistent or not allowing new possibilities that instance operators will bring.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Static implementation inside extension/struct/class scope<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is the way operators are implemented in C#, for example. The change would be only aesthetic. The functionality would remain the same as today.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As the types may differ from protocol/structure/class, this would allow state within the scope of operators that have nothing to do with that type. Not a good thing. In this case it might be better to keep things as they are.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // MARK: - protocol<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public protocol MyDoubleType {<br>&gt;&gt;&gt;     public func someUsefulFunction()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public static operator *(lhs: Self, rhs: Self) -&gt; Self<br>&gt;&gt;&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 // what?<br>&gt;&gt;&gt;     public static postfix operator ++(inout x: Self) -&gt; Self<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // MARK: - implementation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; extension Double: MyDoubleType {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public func someUsefulFunction() {<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public static operator *(lhs: Double, rhs: Double) -&gt; Double {<br>&gt;&gt;&gt;         return lhs.multipliedBy(rhs)<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     // this should be implemented inside a Int64 type, not here...<br>&gt;&gt;&gt;     public static operator /(lhs: Int64, rhs: Int64) -&gt; Int64 {<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;     public static postfix operator ++(inout x: Double) -&gt; Double {<br>&gt;&gt;&gt;         x += 1.0<br>&gt;&gt;&gt;         return x<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160226/2945d41d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
