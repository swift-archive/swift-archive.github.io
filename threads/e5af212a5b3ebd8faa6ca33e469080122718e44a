<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  8, 2015 at 09:00:00pm</p></header><div class="content"><p>Enums are often used without associated values:<br></p><p>    enum Attribute { case Title, Date }<br>    enum Style { case Dark, Light }<br></p><p>In such cases, it&#39;s very useful to be able to iterate over all possible<br>values. But you have to do it manually:<br></p><p>    extension Attribute {<br>        static var allValues: [Attribute] {<br>            return [.Title, .Date]  // imagine this x100, and not<br>autogenerated :(<br>        }<br>    }<br></p><p>It would be nice if the compiler generated this for us. It doesn&#39;t have to<br>be an Array, but any kind of SequenceType. Maybe something like<br>&quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I<br>think simple enums are common enough that it might be worth doing.<br></p><p>Thoughts?<br></p><p>Jacob Bandes-Storch<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/e5afe44a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Enums are often used without associated values:<br>&gt; <br>&gt;     enum Attribute { case Title, Date }<br>&gt;     enum Style { case Dark, Light }<br>&gt; <br>&gt; In such cases, it&#39;s very useful to be able to iterate over all possible values. But you have to do it manually:<br>&gt; <br>&gt;     extension Attribute {<br>&gt;         static var allValues: [Attribute] {<br>&gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; It would be nice if the compiler generated this for us. It doesn&#39;t have to be an Array, but any kind of SequenceType. Maybe something like &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I think simple enums are common enough that it might be worth doing.<br></p><p>This is a commonly requested feature, and tons of people would support the ability to do this somehow.  Similarly, for integer-backed enums, many people want to be able to know the “max” enum rawValue so they can index into them.<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 06:00:00am</p></header><div class="content"><p>Do you have any recommendations for where in the compiler this would<br>happen, for those of us without thorough knowledge of all parts? What would<br>the team need to see in a proposal for it to be sufficiently complete?<br>On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Enums are often used without associated values:<br>&gt; &gt;<br>&gt; &gt;     enum Attribute { case Title, Date }<br>&gt; &gt;     enum Style { case Dark, Light }<br>&gt; &gt;<br>&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible<br>&gt; values. But you have to do it manually:<br>&gt; &gt;<br>&gt; &gt;     extension Attribute {<br>&gt; &gt;         static var allValues: [Attribute] {<br>&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not<br>&gt; autogenerated :(<br>&gt; &gt;         }<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have<br>&gt; to be an Array, but any kind of SequenceType. Maybe something like<br>&gt; &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I<br>&gt; think simple enums are common enough that it might be worth doing.<br>&gt;<br>&gt; This is a commonly requested feature, and tons of people would support the<br>&gt; ability to do this somehow.  Similarly, for integer-backed enums, many<br>&gt; people want to be able to know the “max” enum rawValue so they can index<br>&gt; into them.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/5149f667/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  8, 2015 at 10:00:00pm</p></header><div class="content"><p>&gt; On Dec 8, 2015, at 10:09 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; Do you have any recommendations for where in the compiler this would happen, for those of us without thorough knowledge of all parts? What would the team need to see in a proposal for it to be sufficiently complete?<br></p><p>This would slot into the same logic that synthesizes memberwise initializers on structs.  That said, I think that hashing out the right user model and set of capabilities is the first place to start.<br></p><p>-Chris<br></p><p><br>&gt; On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; Enums are often used without associated values:<br>&gt; &gt;<br>&gt; &gt;     enum Attribute { case Title, Date }<br>&gt; &gt;     enum Style { case Dark, Light }<br>&gt; &gt;<br>&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible values. But you have to do it manually:<br>&gt; &gt;<br>&gt; &gt;     extension Attribute {<br>&gt; &gt;         static var allValues: [Attribute] {<br>&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt; &gt;         }<br>&gt; &gt;     }<br>&gt; &gt;<br>&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have to be an Array, but any kind of SequenceType. Maybe something like &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I think simple enums are common enough that it might be worth doing.<br>&gt; <br>&gt; This is a commonly requested feature, and tons of people would support the ability to do this somehow.  Similarly, for integer-backed enums, many people want to be able to know the “max” enum rawValue so they can index into them.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151208/d5d0ee6b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>There are a number of possible proposals for enhancements I see off the bat for “basic&quot; enums (without associated data):<br></p><p>1. A generated implementation of SequenceType based on declaration order<br>2. A second interface or extension to the enum type could supply static max and min properties when the RawValue is Comparable<br>3. For enums with a String raw value, CustomStringConvertible and Streamable might make sense as well. You would likely want CustomDebugStringConvertible to also be defined to supply the original type-based value.<br></p><p>-DW<br></p><p>&gt; On Dec 8, 2015, at 11:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 8, 2015, at 10:09 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Do you have any recommendations for where in the compiler this would happen, for those of us without thorough knowledge of all parts? What would the team need to see in a proposal for it to be sufficiently complete?<br>&gt; <br>&gt; This would slot into the same logic that synthesizes memberwise initializers on structs.  That said, I think that hashing out the right user model and set of capabilities is the first place to start.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; <br>&gt;&gt; On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Enums are often used without associated values:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     enum Attribute { case Title, Date }<br>&gt;&gt; &gt;     enum Style { case Dark, Light }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible values. But you have to do it manually:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     extension Attribute {<br>&gt;&gt; &gt;         static var allValues: [Attribute] {<br>&gt;&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;&gt; &gt;         }<br>&gt;&gt; &gt;     }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have to be an Array, but any kind of SequenceType. Maybe something like &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I think simple enums are common enough that it might be worth doing.<br>&gt;&gt; <br>&gt;&gt; This is a commonly requested feature, and tons of people would support the ability to do this somehow.  Similarly, for integer-backed enums, many people want to be able to know the “max” enum rawValue so they can index into them.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/9b58c150/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 10:00:00am</p></header><div class="content"><p>Would this work with enums imported from C/Obj-C code as well? Personally,<br>I&#39;ve worked with code that would benefit greatly from it. But I could<br>imagine confusion if a C enum already defines &quot;max&quot; or &quot;number of elements&quot;<br>as a member of the enum, and Swift imports .max as being one greater.<br></p><p>Jacob<br></p><p>On Wed, Dec 9, 2015 at 10:19 AM, David Waite &lt;david at alkaline-solutions.com&gt;<br>wrote:<br></p><p>&gt; There are a number of possible proposals for enhancements I see off the<br>&gt; bat for “basic&quot; enums (without associated data):<br>&gt;<br>&gt; 1. A generated implementation of SequenceType based on declaration order<br>&gt; 2. A second interface or extension to the enum type could supply static<br>&gt; max and min properties when the RawValue is Comparable<br>&gt; 3. For enums with a String raw value, CustomStringConvertible and<br>&gt; Streamable might make sense as well. You would likely want<br>&gt; CustomDebugStringConvertible to also be defined to supply the original<br>&gt; type-based value.<br>&gt;<br>&gt; -DW<br>&gt;<br>&gt; On Dec 8, 2015, at 11:13 PM, Chris Lattner via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Dec 8, 2015, at 10:09 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; Do you have any recommendations for where in the compiler this would<br>&gt; happen, for those of us without thorough knowledge of all parts? What would<br>&gt; the team need to see in a proposal for it to be sufficiently complete?<br>&gt;<br>&gt;<br>&gt; This would slot into the same logic that synthesizes memberwise<br>&gt; initializers on structs.  That said, I think that hashing out the right<br>&gt; user model and set of capabilities is the first place to start.<br>&gt;<br>&gt; -Chris<br>&gt;<br>&gt;<br>&gt; On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Enums are often used without associated values:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     enum Attribute { case Title, Date }<br>&gt;&gt; &gt;     enum Style { case Dark, Light }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible<br>&gt;&gt; values. But you have to do it manually:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt;     extension Attribute {<br>&gt;&gt; &gt;         static var allValues: [Attribute] {<br>&gt;&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not<br>&gt;&gt; autogenerated :(<br>&gt;&gt; &gt;         }<br>&gt;&gt; &gt;     }<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have<br>&gt;&gt; to be an Array, but any kind of SequenceType. Maybe something like<br>&gt;&gt; &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I<br>&gt;&gt; think simple enums are common enough that it might be worth doing.<br>&gt;&gt;<br>&gt;&gt; This is a commonly requested feature, and tons of people would support<br>&gt;&gt; the ability to do this somehow.  Similarly, for integer-backed enums, many<br>&gt;&gt; people want to be able to know the “max” enum rawValue so they can index<br>&gt;&gt; into them.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/ba966c40/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 10:19 AM, David Waite &lt;david at alkaline-solutions.com&gt; wrote:<br>&gt; <br>&gt; There are a number of possible proposals for enhancements I see off the bat for “basic&quot; enums (without associated data):<br>&gt; <br>&gt; 1. A generated implementation of SequenceType based on declaration order<br>&gt; 2. A second interface or extension to the enum type could supply static max and min properties when the RawValue is Comparable<br>&gt; 3. For enums with a String raw value, CustomStringConvertible and Streamable might make sense as well. You would likely want CustomDebugStringConvertible to also be defined to supply the original type-based value.<br></p><p>Another design point to consider: instead of making *every* enum generate the “allValues” capability, it might make sense to restrict this synthesization to enums that opt into it by conforming to a protocol.  Intentionally not the right protocol name, but perhaps:<br></p><p>enum X { A, B }  // not enumerable.<br>enum X : Enumerable { A, B } // has allValues and other stuff automatically generated.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; -DW<br>&gt; <br>&gt;&gt; On Dec 8, 2015, at 11:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 10:09 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Do you have any recommendations for where in the compiler this would happen, for those of us without thorough knowledge of all parts? What would the team need to see in a proposal for it to be sufficiently complete?<br>&gt;&gt; <br>&gt;&gt; This would slot into the same logic that synthesizes memberwise initializers on structs.  That said, I think that hashing out the right user model and set of capabilities is the first place to start.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; Enums are often used without associated values:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;     enum Attribute { case Title, Date }<br>&gt;&gt;&gt; &gt;     enum Style { case Dark, Light }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible values. But you have to do it manually:<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt;     extension Attribute {<br>&gt;&gt;&gt; &gt;         static var allValues: [Attribute] {<br>&gt;&gt;&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;&gt;&gt; &gt;         }<br>&gt;&gt;&gt; &gt;     }<br>&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have to be an Array, but any kind of SequenceType. Maybe something like &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I think simple enums are common enough that it might be worth doing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is a commonly requested feature, and tons of people would support the ability to do this somehow.  Similarly, for integer-backed enums, many people want to be able to know the “max” enum rawValue so they can index into them.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/6e33ef55/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 5:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 9, 2015, at 10:19 AM, David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; There are a number of possible proposals for enhancements I see off the<br>&gt; bat for “basic&quot; enums (without associated data):<br>&gt;<br>&gt; 1. A generated implementation of SequenceType based on declaration order<br>&gt; 2. A second interface or extension to the enum type could supply static<br>&gt; max and min properties when the RawValue is Comparable<br>&gt; 3. For enums with a String raw value, CustomStringConvertible and<br>&gt; Streamable might make sense as well. You would likely want<br>&gt; CustomDebugStringConvertible to also be defined to supply the original<br>&gt; type-based value.<br>&gt;<br>&gt;<br>&gt; Another design point to consider: instead of making *every* enum generate<br>&gt; the “allValues” capability, it might make sense to restrict this<br>&gt; synthesization to enums that opt into it by conforming to a protocol.<br>&gt; Intentionally not the right protocol name, but perhaps:<br>&gt;<br>&gt; enum X { A, B }  // not enumerable.<br>&gt; enum X : Enumerable { A, B } // has allValues and other stuff<br>&gt; automatically generated.<br>&gt;<br>&gt; -Chris<br>&gt;<br></p><p>And I suppose it would have to be possible to add this conformance to a<br>pre-existing type?  You&#39;d want to be able to do &quot;extension NSTextAlignment<br>: Enumerable {}&quot;.  But I&#39;m not sure if it would work well to generate this<br>on-demand; might work better to do it at interface-generation time, along<br>with OptionSetType conformances, etc.<br></p><p>Jacob<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/fe980fea/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 5:24 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Wed, Dec 9, 2015 at 5:05 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 10:19 AM, David Waite &lt;david at alkaline-solutions.com &lt;mailto:david at alkaline-solutions.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; There are a number of possible proposals for enhancements I see off the bat for “basic&quot; enums (without associated data):<br>&gt;&gt; <br>&gt;&gt; 1. A generated implementation of SequenceType based on declaration order<br>&gt;&gt; 2. A second interface or extension to the enum type could supply static max and min properties when the RawValue is Comparable<br>&gt;&gt; 3. For enums with a String raw value, CustomStringConvertible and Streamable might make sense as well. You would likely want CustomDebugStringConvertible to also be defined to supply the original type-based value.<br>&gt; <br>&gt; Another design point to consider: instead of making *every* enum generate the “allValues” capability, it might make sense to restrict this synthesization to enums that opt into it by conforming to a protocol.  Intentionally not the right protocol name, but perhaps:<br>&gt; <br>&gt; enum X { A, B }  // not enumerable.<br>&gt; enum X : Enumerable { A, B } // has allValues and other stuff automatically generated.<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; And I suppose it would have to be possible to add this conformance to a pre-existing type?  You&#39;d want to be able to do &quot;extension NSTextAlignment : Enumerable {}”. <br></p><p>Yes, exactly.  This would allow it to work with C types as you suggest, as well as providing the ability to retroactively provide it for Swift enums that didn’t anticipate the need.<br></p><p>&gt; But I&#39;m not sure if it would work well to generate this on-demand; might work better to do it at interface-generation time, along with OptionSetType conformances, etc.<br></p><p>I’m not sure what you mean here,<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/3618ae7f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>On Wed, Dec 9, 2015 at 5:26 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>&gt;<br>&gt; On Dec 9, 2015, at 5:24 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; On Wed, Dec 9, 2015 at 5:05 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Dec 9, 2015, at 10:19 AM, David Waite &lt;david at alkaline-solutions.com&gt;<br>&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; There are a number of possible proposals for enhancements I see off the<br>&gt;&gt; bat for “basic&quot; enums (without associated data):<br>&gt;&gt;<br>&gt;&gt; 1. A generated implementation of SequenceType based on declaration order<br>&gt;&gt; 2. A second interface or extension to the enum type could supply static<br>&gt;&gt; max and min properties when the RawValue is Comparable<br>&gt;&gt; 3. For enums with a String raw value, CustomStringConvertible and<br>&gt;&gt; Streamable might make sense as well. You would likely want<br>&gt;&gt; CustomDebugStringConvertible to also be defined to supply the original<br>&gt;&gt; type-based value.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Another design point to consider: instead of making *every* enum generate<br>&gt;&gt; the “allValues” capability, it might make sense to restrict this<br>&gt;&gt; synthesization to enums that opt into it by conforming to a protocol.<br>&gt;&gt; Intentionally not the right protocol name, but perhaps:<br>&gt;&gt;<br>&gt;&gt; enum X { A, B }  // not enumerable.<br>&gt;&gt; enum X : Enumerable { A, B } // has allValues and other stuff<br>&gt;&gt; automatically generated.<br>&gt;&gt;<br>&gt;&gt; -Chris<br>&gt;&gt;<br>&gt;<br>&gt; And I suppose it would have to be possible to add this conformance to a<br>&gt; pre-existing type?  You&#39;d want to be able to do &quot;extension NSTextAlignment<br>&gt; : Enumerable {}”.<br>&gt;<br>&gt;<br>&gt; Yes, exactly.  This would allow it to work with C types as you suggest, as<br>&gt; well as providing the ability to retroactively provide it for Swift enums<br>&gt; that didn’t anticipate the need.<br>&gt;<br>&gt; But I&#39;m not sure if it would work well to generate this on-demand; might<br>&gt; work better to do it at interface-generation time, along with OptionSetType<br>&gt; conformances, etc.<br>&gt;<br>&gt;<br>&gt; I’m not sure what you mean here,<br>&gt;<br>&gt; -Chris<br>&gt;<br></p><p>I&#39;d have to look at the code before I&#39;ll be able to ask a fully coherent<br>question (you mentioned the same place memberwise initializers are<br>synthesized).<br></p><p>I was guessing that having multiple &quot;extension NSSortOptions : Enumerable<br>{}&quot; in different modules (or different files in the same module) might<br>cause problems, so you&#39;d have to do it only one place — i.e. NSSortOptions<br>would either be imported as protocol&lt;OptionSetType, Enumerable&gt; or it<br>wouldn&#39;t, with no way to change it post-hoc from user code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/2f7ec301/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December  9, 2015 at 05:00:00pm</p></header><div class="content"><p>On Dec 9, 2015, at 5:30 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com&gt; wrote:<br>&gt; <br>&gt;&gt; But I&#39;m not sure if it would work well to generate this on-demand; might work better to do it at interface-generation time, along with OptionSetType conformances, etc.<br>&gt; <br>&gt; I’m not sure what you mean here,<br>&gt; <br>&gt; -Chris<br>&gt; <br>&gt; I&#39;d have to look at the code before I&#39;ll be able to ask a fully coherent question (you mentioned the same place memberwise initializers are synthesized).<br>&gt; <br>&gt; I was guessing that having multiple &quot;extension NSSortOptions : Enumerable {}&quot; in different modules (or different files in the same module) might cause problems, so you&#39;d have to do it only one place — i.e. NSSortOptions would either be imported as protocol&lt;OptionSetType, Enumerable&gt; or it wouldn&#39;t, with no way to change it post-hoc from user code.<br></p><p>Ah, I see what you mean.  Yes, I don’t think that the memberwise initializer logic is the place to look, it is probably better to look at at the logic that synthesizes the ErrorType members, since this is currently allowed:<br></p><p>	enum X { case A, B }<br>	extension X : ErrorType {}<br></p><p>in principle there should be no problem with multiply defined members, since they will have different module qualifications and name lookup paths.<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151209/21c9984c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/569ed436467cf145f3bbdd0d53fbe115?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Slava Pestov</string> &lt;spestov at apple.com&gt;<p>December 10, 2015 at 08:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 5:05 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Another design point to consider: instead of making *every* enum generate the “allValues” capability, it might make sense to restrict this synthesization to enums that opt into it by conforming to a protocol.  Intentionally not the right protocol name, but perhaps:<br>&gt; <br>&gt; enum X { A, B }  // not enumerable.<br>&gt; enum X : Enumerable { A, B } // has allValues and other stuff automatically generated.<br>&gt; <br>&gt; -Chris<br>&gt; <br></p><p>The necessary information for getting enum case names (with and without payloads) is already emitted by IRGen as part of type metadata, but the runtime reflection interface for accessing it does not support this use-case (introspecting a type without a value) and in general is a bit heavy weight.<br></p><p>In the past we’ve talked about switching to an “opt-in” reflection model, where protocol conformance signals that metadata generation should occur. If we combine this with a nice type reflection interface, the original poster’s use-case should be taken care of well, I think.<br></p><p>Slava<br></p><p>&gt;&gt; <br>&gt;&gt; -DW<br>&gt;&gt; <br>&gt;&gt;&gt; On Dec 8, 2015, at 11:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 10:09 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Do you have any recommendations for where in the compiler this would happen, for those of us without thorough knowledge of all parts? What would the team need to see in a proposal for it to be sufficiently complete?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would slot into the same logic that synthesizes memberwise initializers on structs.  That said, I think that hashing out the right user model and set of capabilities is the first place to start.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; Enums are often used without associated values:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;     enum Attribute { case Title, Date }<br>&gt;&gt;&gt;&gt; &gt;     enum Style { case Dark, Light }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible values. But you have to do it manually:<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt;     extension Attribute {<br>&gt;&gt;&gt;&gt; &gt;         static var allValues: [Attribute] {<br>&gt;&gt;&gt;&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;&gt;&gt;&gt; &gt;         }<br>&gt;&gt;&gt;&gt; &gt;     }<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have to be an Array, but any kind of SequenceType. Maybe something like &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I think simple enums are common enough that it might be worth doing.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is a commonly requested feature, and tons of people would support the ability to do this somehow.  Similarly, for integer-backed enums, many people want to be able to know the “max” enum rawValue so they can index into them.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151210/048d3547/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>Yes I agree this would be great! I think an opt-in design where you can extend existing enums to conform is awesome.<br></p><p>As a suggestion for the names of the methods, I think the following would be great:<br></p><p>enum Thing: String, Enumerable {<br>    case One, Two, Three<br>}<br></p><p>// available for any conforming enum:<br>Thing.cases // returns [Thing] = [.One, .Two, .Three]<br></p><p>// only available for enums with raw values:<br>Thing.rawValues // returns [String] = [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;]<br>Regarding a name for the protocol, perhaps “Introspectable” or “Listable”?<br></p><p>Lastly, for enums that have cases with Associated Values, that definitely seems more complex and may be best suited for a separate discussion. I’d much rather see the “simple” version above implemented first, followed by something that deals with enums that have associated values in a later release. However, I do have a suggestion that’s different from what Brent suggested, which is that instead of returning actual enum values, I could see returning the functions associated with them as being potentially useful. I can show an example of what this might look like if anyone is interested.<br></p><p><br></p><p>&gt; On Dec 10, 2015, at 9:37 PM, Slava Pestov via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Dec 9, 2015, at 5:05 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Another design point to consider: instead of making *every* enum generate the “allValues” capability, it might make sense to restrict this synthesization to enums that opt into it by conforming to a protocol.  Intentionally not the right protocol name, but perhaps:<br>&gt;&gt; <br>&gt;&gt; enum X { A, B }  // not enumerable.<br>&gt;&gt; enum X : Enumerable { A, B } // has allValues and other stuff automatically generated.<br>&gt;&gt; <br>&gt;&gt; -Chris<br>&gt;&gt; <br>&gt; <br>&gt; The necessary information for getting enum case names (with and without payloads) is already emitted by IRGen as part of type metadata, but the runtime reflection interface for accessing it does not support this use-case (introspecting a type without a value) and in general is a bit heavy weight.<br>&gt; <br>&gt; In the past we’ve talked about switching to an “opt-in” reflection model, where protocol conformance signals that metadata generation should occur. If we combine this with a nice type reflection interface, the original poster’s use-case should be taken care of well, I think.<br>&gt; <br>&gt; Slava<br>&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -DW<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Dec 8, 2015, at 11:13 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Dec 8, 2015, at 10:09 PM, Jacob Bandes-Storch &lt;jtbandes at gmail.com &lt;mailto:jtbandes at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Do you have any recommendations for where in the compiler this would happen, for those of us without thorough knowledge of all parts? What would the team need to see in a proposal for it to be sufficiently complete?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would slot into the same logic that synthesizes memberwise initializers on structs.  That said, I think that hashing out the right user model and set of capabilities is the first place to start.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Tue, Dec 8, 2015 at 10:05 PM Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; &gt; On Dec 8, 2015, at 9:53 PM, Jacob Bandes-Storch via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; Enums are often used without associated values:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;     enum Attribute { case Title, Date }<br>&gt;&gt;&gt;&gt;&gt; &gt;     enum Style { case Dark, Light }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; In such cases, it&#39;s very useful to be able to iterate over all possible values. But you have to do it manually:<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt;     extension Attribute {<br>&gt;&gt;&gt;&gt;&gt; &gt;         static var allValues: [Attribute] {<br>&gt;&gt;&gt;&gt;&gt; &gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;&gt;&gt;&gt;&gt; &gt;         }<br>&gt;&gt;&gt;&gt;&gt; &gt;     }<br>&gt;&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;&gt; &gt; It would be nice if the compiler generated this for us. It doesn&#39;t have to be an Array, but any kind of SequenceType. Maybe something like &quot;StaticCollection&quot;. Of course, this doesn&#39;t work in the general case, but I think simple enums are common enough that it might be worth doing.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This is a commonly requested feature, and tons of people would support the ability to do this somehow.  Similarly, for integer-backed enums, many people want to be able to know the “max” enum rawValue so they can index into them.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; -Chris<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt;  _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/09ed3d38/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December 11, 2015 at 04:00:00pm</p></header><div class="content"><p>&gt; However, I do have a suggestion that’s different from what Brent suggested, which is that instead of returning actual enum values, I could see returning the functions associated with them as being potentially useful. I can show an example of what this might look like if anyone is interested.<br></p><p>Interesting. The problem I see with this is that, if by “the functions associated with them” you mean their constructors, each constructor would have a different set of parameters. To distinguish between them, you would probably need…an enum.<br></p><p>On the other hand, if you mean “functions testing an instance of the enum against that case, and returning true if it matches”, that’s a more interesting possibility.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/289e63405066acfc02feee3b7abf39bb?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Zef Houssney</string> &lt;zefmail at gmail.com&gt;<p>December 11, 2015 at 06:00:00pm</p></header><div class="content"><p>Yeah thank you —I did mean the constructor, didn’t think of that terminology :)<br></p><p>I recognize that it’s not totally ideal but I do still see that as being useful. Here’s an example of how you could use that. For cases that have the same signature, it’s less ideal but still totally workable as far as I can see.<br></p><p>Also with this approach you could fairly easily create the data structure you suggested yourself.<br></p><p><br>enum Foo {<br>    case Plain<br>    case AssociatedSimple(String)<br>    case AssociatedComplex(String, Int)<br>    case AssociatedSimpleCopy(String)<br></p><p>    static var cases: [Any] {<br>        return [<br>            Plain,<br>            AssociatedSimple,<br>            AssociatedComplex,<br>            AssociatedSimpleCopy,<br>        ]<br>    }<br>}<br></p><p>let cases = Foo.cases<br></p><p>cases[0] is Foo // true<br>cases[1] is Foo // false<br>cases[2] is Foo // false<br></p><p>cases[0] is (String) -&gt; Foo // false<br>cases[1] is (String) -&gt; Foo // true<br>cases[2] is (String) -&gt; Foo // false<br></p><p>cases[0] is (String, Int) -&gt; Foo // false<br>cases[1] is (String, Int) -&gt; Foo // false<br>cases[2] is (String, Int) -&gt; Foo // true<br></p><p>if let simple = cases[1] as? (String) -&gt; Foo {<br>    let created = simple(&quot;some value&quot;)<br></p><p>    switch created {<br>    case .AssociatedSimple:<br>        // we&#39;d hit this:<br>        print(&quot;Simple&quot;)<br>    case .AssociatedSimpleCopy:<br>        // here if you didn&#39;t want the original &quot;some value&quot;<br>        // you could create the enum with a different value<br>        print(&quot;Simple Copy&quot;)<br>    default:<br>        print(&quot;Something else&quot;)<br>    }<br>}<br></p><p>I don’t love that it’s using [Any] here, but I don’t know if it’s possible to represent that `() -&gt; Foo` where the methods passed can be dynamic… didn’t seem to be with what I was trying. Related to that, it might make more sense to have the “Plain” value above represented as `() -&gt; Foo` instead of simply `Foo`.<br></p><p><br></p><p><br>&gt; On Dec 11, 2015, at 5:43 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; However, I do have a suggestion that’s different from what Brent suggested, which is that instead of returning actual enum values, I could see returning the functions associated with them as being potentially useful. I can show an example of what this might look like if anyone is interested.<br>&gt; <br>&gt; Interesting. The problem I see with this is that, if by “the functions associated with them” you mean their constructors, each constructor would have a different set of parameters. To distinguish between them, you would probably need…an enum.<br>&gt; <br>&gt; On the other hand, if you mean “functions testing an instance of the enum against that case, and returning true if it matches”, that’s a more interesting possibility.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/17f06b71/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7e9f543f0ffdb7c9a899e628fe76e7f3?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Jacob Bandes-Storch</string> &lt;jtbandes at gmail.com&gt;<p>December 21, 2015 at 12:00:00pm</p></header><div class="content"><p>Bumping this thread because it&#39;s relevant to recent discussions in<br>&quot;Proposal: Enum &#39;count&#39; functionality&quot;. To summarize points so far:<br></p><p>Minimum and particularly maximum rawValues would be useful for<br>integer-typed enums.<br></p><p>For NS_ENUM/NS_OPTIONS and Swift enums without associated values, something<br>like &quot;allValues&quot; would be useful.<br></p><p>This functionality could be added at the request of the user, by deriving a<br>protocol such as &quot;enum Foo: ValueEnumerable&quot;.<br></p><p>Brent (in this thread) and Joe (in the other thread) have proposed<br>Cartesian products for nested &quot;enumerable&quot; enums:<br></p><p>        enum Foo {<br>&gt;                 case Alice, Bob<br>&gt;         }<br>&gt;         enum Bar {<br>&gt;                 case Charlie (Foo), Eve (Foo, Foo)<br>&gt;         }<br>&gt;         Bar.allValues   // =&gt; [ .Charlie(.Alice), .Charlie(.Bob),<br>&gt; .Eve(.Alice, .Alice), .Eve(.Alice, .Bob), .Eve(.Bob, .Alice), .Eve(.Bob,<br>&gt; .Bob) ]<br>&gt;<br></p><p><br>Barring full Cartesian product support, would it be useful to have some<br>form of &quot;allValues&quot; for enums with associated values, or is the ability to<br>do &quot;if case let&quot; sufficient to discriminate them?<br></p><p>Jacob Bandes-Storch<br></p><p>On Fri, Dec 11, 2015 at 5:49 PM, Zef Houssney via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Yeah thank you —I did mean the constructor, didn’t think of that<br>&gt; terminology :)<br>&gt;<br>&gt; I recognize that it’s not totally ideal but I do still see that as being<br>&gt; useful. Here’s an example of how you could use that. For cases that have<br>&gt; the same signature, it’s less ideal but still totally workable as far as I<br>&gt; can see.<br>&gt;<br>&gt; Also with this approach you could fairly easily create the data structure<br>&gt; you suggested yourself.<br>&gt;<br>&gt;<br>&gt; enum Foo {<br>&gt;     case Plain<br>&gt;     case AssociatedSimple(String)<br>&gt;     case AssociatedComplex(String, Int)<br>&gt;     case AssociatedSimpleCopy(String)<br>&gt;<br>&gt;     static var cases: [Any] {<br>&gt;         return [<br>&gt;             Plain,<br>&gt;             AssociatedSimple,<br>&gt;             AssociatedComplex,<br>&gt;             AssociatedSimpleCopy,<br>&gt;         ]<br>&gt;     }<br>&gt; }<br>&gt; let cases = Foo.cases<br>&gt;<br>&gt; cases[0] is Foo // true<br>&gt; cases[1] is Foo // false<br>&gt; cases[2] is Foo // false<br>&gt;<br>&gt; cases[0] is (String) -&gt; Foo // false<br>&gt; cases[1] is (String) -&gt; Foo // true<br>&gt; cases[2] is (String) -&gt; Foo // false<br>&gt;<br>&gt; cases[0] is (String, Int) -&gt; Foo // false<br>&gt; cases[1] is (String, Int) -&gt; Foo // false<br>&gt; cases[2] is (String, Int) -&gt; Foo // true<br>&gt; if let simple = cases[1] as? (String) -&gt; Foo {<br>&gt;     let created = simple(&quot;some value&quot;)<br>&gt;<br>&gt;     switch created {<br>&gt;     case .AssociatedSimple:<br>&gt;         // we&#39;d hit this:<br>&gt;         print(&quot;Simple&quot;)<br>&gt;     case .AssociatedSimpleCopy:<br>&gt;         // here if you didn&#39;t want the original &quot;some value&quot;<br>&gt;         // you could create the enum with a different value<br>&gt;         print(&quot;Simple Copy&quot;)<br>&gt;     default:<br>&gt;         print(&quot;Something else&quot;)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt;<br>&gt; I don’t love that it’s using [Any] here, but I don’t know if it’s possible<br>&gt; to represent that `() -&gt; Foo` where the methods passed can be dynamic…<br>&gt; didn’t seem to be with what I was trying. Related to that, it might make<br>&gt; more sense to have the “Plain” value above represented as `() -&gt; Foo`<br>&gt; instead of simply `Foo`.<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Dec 11, 2015, at 5:43 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt;<br>&gt; However, I do have a suggestion that’s different from what Brent<br>&gt; suggested, which is that instead of returning actual enum values, I could<br>&gt; see returning the functions associated with them as being potentially<br>&gt; useful. I can show an example of what this might look like if anyone is<br>&gt; interested.<br>&gt;<br>&gt;<br>&gt; Interesting. The problem I see with this is that, if by “the functions<br>&gt; associated with them” you mean their constructors, each constructor would<br>&gt; have a different set of parameters. To distinguish between them, you would<br>&gt; probably need…an enum.<br>&gt;<br>&gt; On the other hand, if you mean “functions testing an instance of the enum<br>&gt; against that case, and returning true if it matches”, that’s a more<br>&gt; interesting possibility.<br>&gt;<br>&gt; --<br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151221/5eca706b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  9, 2015 at 04:00:00am</p></header><div class="content"><p>&gt;     extension Attribute {<br>&gt;         static var allValues: [Attribute] {<br>&gt;             return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;         }<br>&gt;     }<br>&gt; <br>&gt; It would be nice if the compiler generated this for us.<br></p><p>You know, I was thinking about this the other day when the topic of numeric minimum/maximums came up.<br></p><p>In some sense these are related ideas. These types have in common that they have a particular finite, easily-calculated set of possible values, and it’s convenient to be able to look at that set in various ways. This has the feel of a protocol:<br></p><p>	protocol Enumerable {<br>		typealias Enumeration: SequenceType where Generator.Element == Self<br>		var allValues: Enumeration<br>	}<br></p><p>For a simple enum, `Enumeration` would be something like an `Array` or `Set`, and `allValues` would primarily be iterated over; for an integer type, `Enumeration` would be a range and `allValues` would primarily have its `first` and `last` elements examined. (Well, there’s a problem with using a range. A `Range&lt;T: IntegerType&gt;` can never include `T.max`, because then its `endIndex` would have to be `T.max + 1`, which is by definition not representable in `T`. But you could imagine a range-like type without this limitation.) However, in each case there are some fairly useless operations exposed by `allValues`, and I’m not sure if I like that.<br></p><p>One interesting thing I noticed: enums with associated values could also be made `Enumerable`, as long as all associated values are `Enumerable` and the enum is not recursive. For instance:<br></p><p>	enum Foo {<br>		case Alice, Bob<br>	}<br>	enum Bar {<br>		case Charlie (Foo), Eve (Foo, Foo)<br>	}<br>	Bar.allValues   // =&gt; [ .Charlie(.Alice), .Charlie(.Bob), .Eve(.Alice, .Alice), .Eve(.Alice, .Bob), .Eve(.Bob, .Alice), .Eve(.Bob, .Bob) ]<br></p><p>This is even in principle true of associated values of type `Int`, although obviously the set of possible values for `Int` would be so large that it would have to be generated lazily (not to mention that I can’t see much practical use for it). This would also imply that `Optional&lt;T: Enumerable&gt;` would be `Enumerable`, with an `allValues` consisting basically of `[.None] + Wrapped.all.map(.Some)`.<br></p><p>Anyway, I’m not sure if what I’m describing here is a good idea. It might be overcomplicating things, and some parts of it would probably be difficult to implement. But I thought it was an interesting observation.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>December  9, 2015 at 04:00:00am</p></header><div class="content"><p>&gt; 	protocol Enumerable {<br>&gt; 		typealias Enumeration: SequenceType where Generator.Element == Self<br>&gt; 		var allValues: Enumeration<br>&gt; 	}<br></p><p>Er, that should have been `static var`, of course. That was bright of me.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December  9, 2015 at 05:00:00am</p></header><div class="content"><p>I don’t think this is overcomplicating things at all.  I see many useful cases for this.<br></p><p>I would suggest a simple change to Enumerable…<br></p><p>protocol Enumerable : CustomStringConvertible, CustomDebugStringConvertible {<br>    …<br>}<br></p><p>The number of times the enumeration value name is needed at runtime is just too great.<br></p><p>&gt; On Dec 9, 2015, at 5:05 AM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt;    extension Attribute {<br>&gt;&gt;        static var allValues: [Attribute] {<br>&gt;&gt;            return [.Title, .Date]  // imagine this x100, and not autogenerated :(<br>&gt;&gt;        }<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; It would be nice if the compiler generated this for us.<br>&gt; <br>&gt; You know, I was thinking about this the other day when the topic of numeric minimum/maximums came up.<br>&gt; <br>&gt; In some sense these are related ideas. These types have in common that they have a particular finite, easily-calculated set of possible values, and it’s convenient to be able to look at that set in various ways. This has the feel of a protocol:<br>&gt; <br>&gt; 	protocol Enumerable {<br>&gt; 		typealias Enumeration: SequenceType where Generator.Element == Self<br>&gt; 		var allValues: Enumeration<br>&gt; 	}<br>&gt; <br>&gt; For a simple enum, `Enumeration` would be something like an `Array` or `Set`, and `allValues` would primarily be iterated over; for an integer type, `Enumeration` would be a range and `allValues` would primarily have its `first` and `last` elements examined. (Well, there’s a problem with using a range. A `Range&lt;T: IntegerType&gt;` can never include `T.max`, because then its `endIndex` would have to be `T.max + 1`, which is by definition not representable in `T`. But you could imagine a range-like type without this limitation.) However, in each case there are some fairly useless operations exposed by `allValues`, and I’m not sure if I like that.<br>&gt; <br>&gt; One interesting thing I noticed: enums with associated values could also be made `Enumerable`, as long as all associated values are `Enumerable` and the enum is not recursive. For instance:<br>&gt; <br>&gt; 	enum Foo {<br>&gt; 		case Alice, Bob<br>&gt; 	}<br>&gt; 	enum Bar {<br>&gt; 		case Charlie (Foo), Eve (Foo, Foo)<br>&gt; 	}<br>&gt; 	Bar.allValues   // =&gt; [ .Charlie(.Alice), .Charlie(.Bob), .Eve(.Alice, .Alice), .Eve(.Alice, .Bob), .Eve(.Bob, .Alice), .Eve(.Bob, .Bob) ]<br>&gt; <br>&gt; This is even in principle true of associated values of type `Int`, although obviously the set of possible values for `Int` would be so large that it would have to be generated lazily (not to mention that I can’t see much practical use for it). This would also imply that `Optional&lt;T: Enumerable&gt;` would be `Enumerable`, with an `allValues` consisting basically of `[.None] + Wrapped.all.map(.Some)`.<br>&gt; <br>&gt; Anyway, I’m not sure if what I’m describing here is a good idea. It might be overcomplicating things, and some parts of it would probably be difficult to implement. But I thought it was an interesting observation.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December  9, 2015 at 11:00:00am</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 4:37 AM, Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I don’t think this is overcomplicating things at all.  I see many useful cases for this.<br>&gt; <br>&gt; I would suggest a simple change to Enumerable…<br>&gt; <br>&gt; protocol Enumerable : CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;    …<br>&gt; }<br>&gt; <br>&gt; The number of times the enumeration value name is needed at runtime is just too great.<br></p><p>Everything is string-convertible; no need to force Enumerable implementations to provide custom printing implementations.<br></p><p>-Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/9bfba345bd373f7b8874d58fed6372ff?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>David Waite</string> &lt;david at alkaline-solutions.com&gt;<p>December  9, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 12:06 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The number of times the enumeration value name is needed at runtime is just too great.<br>&gt; <br>&gt; Everything is string-convertible; no need to force Enumerable implementations to provide custom printing implementations.<br></p><p>Per my email on this thread, the one case which might be worth handling is enums with String raw values. However, a String-backed enum is not necessarily the same as in other languages where annotations/attributes are used to indicate a representation name for the enumerated value, so this would likely need to be a behavior one could either opt into or out of.<br></p><p>-DW<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a59b0df1d55761e4d340da93232790ea?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Kevin Wooten</string> &lt;kdubb at me.com&gt;<p>December  9, 2015 at 09:00:00pm</p></header><div class="content"><p>I know that this currently works...<br></p><p>enum MyEnum { case MyA }<br>let val = String(MyEnum.MyA) // yields “MyA&quot;<br></p><p>Which I assume is what you are referring to.  Although, even after sifting through Swift.String, I am not sure how this support is provided. I assume some magic method is produced by the compiler for enums.<br></p><p>In the generics of today, auto generated functions like these do not seem to be available to generic implementations.  So what I was trying to achieve by adding the string convertible protocol was to ensure the availability of code like this…<br></p><p>parseFromSource&lt;E: Enumerable&gt;(source: Source) -&gt; E? {<br>	let str = source.readString()<br>	for e in E.allValues {<br>		if (e.description == str) {<br>			return e;<br>		}<br>	}<br>	return nil;<br>}<br></p><p>From what I know of the generics implementation if we tried to replace the “e.description == str” with “String(e) == str” it would fail; since that initializer is not formalized anywhere in the Enumerable protocol.<br></p><p>Another option entirely would be to just always produce an initializer similar to the raw value string enum initializer that will match raw values. Essentially a magic method similar to the one I wrote above but for all enums.  Although the code above is much more flexible even beyond my simple parsing example.<br></p><p>&gt; On Dec 9, 2015, at 12:06 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Dec 9, 2015, at 4:37 AM, Kevin Wooten via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I don’t think this is overcomplicating things at all.  I see many useful cases for this.<br>&gt;&gt; <br>&gt;&gt; I would suggest a simple change to Enumerable…<br>&gt;&gt; <br>&gt;&gt; protocol Enumerable : CustomStringConvertible, CustomDebugStringConvertible {<br>&gt;&gt;   …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; The number of times the enumeration value name is needed at runtime is just too great.<br>&gt; <br>&gt; Everything is string-convertible; no need to force Enumerable implementations to provide custom printing implementations.<br>&gt; <br>&gt; -Joe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>List of all Enum values (for simple enums)</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 10, 2015 at 01:00:00pm</p></header><div class="content"><p>&gt; On Dec 9, 2015, at 8:21 PM, Kevin Wooten &lt;kdubb at me.com&gt; wrote:<br>&gt; <br>&gt; I know that this currently works...<br>&gt; <br>&gt; enum MyEnum { case MyA }<br>&gt; let val = String(MyEnum.MyA) // yields “MyA&quot;<br>&gt; <br>&gt; Which I assume is what you are referring to.  Although, even after sifting through Swift.String, I am not sure how this support is provided. I assume some magic method is produced by the compiler for enums.<br>&gt; <br>&gt; In the generics of today, auto generated functions like these do not seem to be available to generic implementations.  So what I was trying to achieve by adding the string convertible protocol was to ensure the availability of code like this…<br>&gt; <br>&gt; parseFromSource&lt;E: Enumerable&gt;(source: Source) -&gt; E? {<br>&gt; 	let str = source.readString()<br>&gt; 	for e in E.allValues {<br>&gt; 		if (e.description == str) {<br>&gt; 			return e;<br>&gt; 		}<br>&gt; 	}<br>&gt; 	return nil;<br>&gt; }<br>&gt; <br>&gt; From what I know of the generics implementation if we tried to replace the “e.description == str” with “String(e) == str” it would fail; since that initializer is not formalized anywhere in the Enumerable protocol.<br></p><p>String(e) is defined for all types; there&#39;s an unconstrained String.init&lt;T&gt;(_: T) method. It&#39;s implemented using runtime reflection. You should use the String(x) initializer, or the equivalent interpolation &quot;\(x)&quot;, instead of using .description directly.<br></p><p>-Joe<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
