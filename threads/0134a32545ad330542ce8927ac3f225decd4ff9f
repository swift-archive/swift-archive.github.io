<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>July  6, 2016 at 02:00:00am</p></header><div class="content"><p>Please feel free to ignore this naive attempt to engage in this discussion.<br></p><p>My understanding of the history of Swift&#39;s tuples, argument lists, pattern<br>matching, associated values, etc. in two steps:<br></p><p>1. Initial Idealism *:<br>Simple powerful heavily reused general concept.<br></p><p>2. Iterative pragmatism / reality *:<br>Complicated (exceptions to) rules.<br></p><p>(* Inevitably not taking everything in to account.)<br></p><p>Has there been any recent attempts to outline a more or less complete<br>redesign for these things, returning to step 1 so to speak, but taking into<br>account what has now been learned?<br></p><p><br>As a side note (and supposedly trivial to most but me):<br></p><p>Parentheses (parenthesized expressions in the grammar?) are used for all of<br>these parts of the language, and they probably should be, but perhaps the<br>similarities and differences between the language constructs can be made<br>clearer to see by pretending that argument and parameter lists are written<br>with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br></p><p>For example, I think most people agree that we should be able to use<br>&quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>((1 + (2 * 3)) * (x + (-5))) - y<br>This is fine and can be used to express meaning for the person<br>reading/writing, even though it means that some of the parens can become<br>superfluous to a machine interpretation.<br></p><p>AFAICS this need not have anything to do with tuples and/or parameter<br>lists, but the fact that Swift is treating eg:<br>func foo(x: ((((Int))))) { print(x) }<br>as<br>func foo(x: Int) { print(x) }<br>and<br>((Int, Int))<br>as<br>(Int, Int)<br>seems to suggest that it somehow does.<br></p><p>Or maybe I have just forgotten the reasons for why there can be no such<br>thing as (a nested) single element tuple (type).<br></p><p>I also can&#39;t remember what the pros &amp; cons of disallowing labeled single<br>element tuples were.<br></p><p>Happy to be corrected and pointed to relevant reading : )<br></p><p>/Jens<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/0134ff9f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  6, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; Or maybe I have just forgotten the reasons for why there can be no such<br>thing as (a nested) single element tuple (type).<br></p><p>In Swift, types have their own (built-in) operators: infix &#39;-&gt;&#39;, postfix<br>&#39;?&#39;, postfix &#39;!&#39;.<br>Parentheses are required for grouping (setting priorities). If we allow<br>single element tuples, ambiguities arise:<br></p><p>(Int -&gt; Int)?  // is that an optional tuple or just optional function?<br></p><p>By the way, in Haskell, which allows user-defined operators on types, there<br>is no single element tuple for pretty much the same reason.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/8d98a1d1/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>July  6, 2016 at 04:00:00pm</p></header><div class="content"><p>Ah, thanks Anton!<br>But wouldn&#39;t/couldn&#39;t things be different if tuples was written with eg ⊂⊃<br>instead of parentheses?<br>(let&#39;s ignore the practical implications (difficult to write etc) for the<br>moment)<br></p><p>For example, here&#39;s an optional tuple whose single element is a function:<br>⊂Int -&gt; Int⊃?<br></p><p>and here is an optional function:<br>(Int -&gt; Int)?<br></p><p>In this thought-experiment, parentheses are _only_ used for grouping<br>(setting priorities), and they are the only grouping which is<br>sloppy/forgiving, so this would also be an optional tuple whose single<br>element is a function:<br></p><p>((((((((⊂Int -&gt; Int⊃))))))?))<br></p><p>But this would be an optional tuple whose single element is a single<br>element tuple whose single element is a function:<br>⊂⊂Int -&gt; Int⊃⊃?<br></p><p>/Jens<br></p><p><br>On Wed, Jul 6, 2016 at 12:23 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>wrote:<br></p><p>&gt; &gt; Or maybe I have just forgotten the reasons for why there can be no such<br>&gt; thing as (a nested) single element tuple (type).<br>&gt;<br>&gt; In Swift, types have their own (built-in) operators: infix &#39;-&gt;&#39;, postfix<br>&gt; &#39;?&#39;, postfix &#39;!&#39;.<br>&gt; Parentheses are required for grouping (setting priorities). If we allow<br>&gt; single element tuples, ambiguities arise:<br>&gt;<br>&gt; (Int -&gt; Int)?  // is that an optional tuple or just optional function?<br>&gt;<br>&gt; By the way, in Haskell, which allows user-defined operators on types,<br>&gt; there is no single element tuple for pretty much the same reason.<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/477bbb3b/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  6, 2016 at 05:00:00pm</p></header><div class="content"><p>On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt; Please feel free to ignore this naive attempt to engage in this discussion.<br>&gt;<br>&gt; My understanding of the history of Swift&#39;s tuples, argument lists, pattern<br>&gt; matching, associated values, etc. in two steps:<br>&gt;<br>&gt; 1. Initial Idealism *:<br>&gt; Simple powerful heavily reused general concept.<br>&gt;<br>&gt; 2. Iterative pragmatism / reality *:<br>&gt; Complicated (exceptions to) rules.<br>&gt;<br>&gt; (* Inevitably not taking everything in to account.)<br>&gt;<br>&gt; Has there been any recent attempts to outline a more or less complete<br>&gt; redesign for these things, returning to step 1 so to speak, but taking into<br>&gt; account what has now been learned?<br>&gt;<br>&gt;<br>&gt; As a side note (and supposedly trivial to most but me):<br>&gt;<br>&gt; Parentheses (parenthesized expressions in the grammar?) are used for all of<br>&gt; these parts of the language, and they probably should be, but perhaps the<br>&gt; similarities and differences between the language constructs can be made<br>&gt; clearer to see by pretending that argument and parameter lists are written<br>&gt; with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;<br>&gt; For example, I think most people agree that we should be able to use<br>&gt; &quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>&gt; ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt; This is fine and can be used to express meaning for the person<br>&gt; reading/writing, even though it means that some of the parens can become<br>&gt; superfluous to a machine interpretation.<br>&gt;<br>&gt; AFAICS this need not have anything to do with tuples and/or parameter<br>&gt; lists, but the fact that Swift is treating eg:<br>&gt; func foo(x: ((((Int))))) { print(x) }<br>&gt; as<br>&gt; func foo(x: Int) { print(x) }<br>&gt; and<br>&gt; ((Int, Int))<br>&gt; as<br>&gt; (Int, Int)<br></p><p>If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple with Int,Int <br>fields&quot; and (Int, Int) will mean only &quot;list of two Ints in parameters&quot;<br></p><p>&gt; seems to suggest that it somehow does.<br>&gt;<br>&gt; Or maybe I have just forgotten the reasons for why there can be no such<br>&gt; thing as (a nested) single element tuple (type).<br>&gt;<br>&gt; I also can&#39;t remember what the pros &amp; cons of disallowing labeled single<br>&gt; element tuples were.<br>&gt;<br>&gt; Happy to be corrected and pointed to relevant reading : )<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>July  6, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt; Please feel free to ignore this naive attempt to engage in this discussion.<br>&gt;&gt; <br>&gt;&gt; My understanding of the history of Swift&#39;s tuples, argument lists, pattern<br>&gt;&gt; matching, associated values, etc. in two steps:<br>&gt;&gt; <br>&gt;&gt; 1. Initial Idealism *:<br>&gt;&gt; Simple powerful heavily reused general concept.<br>&gt;&gt; <br>&gt;&gt; 2. Iterative pragmatism / reality *:<br>&gt;&gt; Complicated (exceptions to) rules.<br>&gt;&gt; <br>&gt;&gt; (* Inevitably not taking everything in to account.)<br>&gt;&gt; <br>&gt;&gt; Has there been any recent attempts to outline a more or less complete<br>&gt;&gt; redesign for these things, returning to step 1 so to speak, but taking into<br>&gt;&gt; account what has now been learned?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; As a side note (and supposedly trivial to most but me):<br>&gt;&gt; <br>&gt;&gt; Parentheses (parenthesized expressions in the grammar?) are used for all of<br>&gt;&gt; these parts of the language, and they probably should be, but perhaps the<br>&gt;&gt; similarities and differences between the language constructs can be made<br>&gt;&gt; clearer to see by pretending that argument and parameter lists are written<br>&gt;&gt; with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt; <br>&gt;&gt; For example, I think most people agree that we should be able to use<br>&gt;&gt; &quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>&gt;&gt; ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt; This is fine and can be used to express meaning for the person<br>&gt;&gt; reading/writing, even though it means that some of the parens can become<br>&gt;&gt; superfluous to a machine interpretation.<br>&gt;&gt; <br>&gt;&gt; AFAICS this need not have anything to do with tuples and/or parameter<br>&gt;&gt; lists, but the fact that Swift is treating eg:<br>&gt;&gt; func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt; as<br>&gt;&gt; func foo(x: Int) { print(x) }<br>&gt;&gt; and<br>&gt;&gt; ((Int, Int))<br>&gt;&gt; as<br>&gt;&gt; (Int, Int)<br>&gt; <br>&gt; If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple with Int,Int fields&quot; and (Int, Int) will mean only &quot;list of two Ints in parameters&quot;<br></p><p>((Int, Int)) would still be equivalent to (Int, Int). SE-0110 only concerns parameter lists in function types.<br></p><p>-Joe<br></p><p>&gt; <br>&gt;&gt; seems to suggest that it somehow does.<br>&gt;&gt; <br>&gt;&gt; Or maybe I have just forgotten the reasons for why there can be no such<br>&gt;&gt; thing as (a nested) single element tuple (type).<br>&gt;&gt; <br>&gt;&gt; I also can&#39;t remember what the pros &amp; cons of disallowing labeled single<br>&gt;&gt; element tuples were.<br>&gt;&gt; <br>&gt;&gt; Happy to be corrected and pointed to relevant reading : )<br>&gt;&gt; <br>&gt;&gt; /Jens<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;<br>&gt;&gt; On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt;&gt; Please feel free to ignore this naive attempt to engage in this discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; My understanding of the history of Swift&#39;s tuples, argument lists, pattern<br>&gt;&gt;&gt; matching, associated values, etc. in two steps:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 1. Initial Idealism *:<br>&gt;&gt;&gt; Simple powerful heavily reused general concept.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; 2. Iterative pragmatism / reality *:<br>&gt;&gt;&gt; Complicated (exceptions to) rules.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (* Inevitably not taking everything in to account.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Has there been any recent attempts to outline a more or less complete<br>&gt;&gt;&gt; redesign for these things, returning to step 1 so to speak, but taking into<br>&gt;&gt;&gt; account what has now been learned?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; As a side note (and supposedly trivial to most but me):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Parentheses (parenthesized expressions in the grammar?) are used for all of<br>&gt;&gt;&gt; these parts of the language, and they probably should be, but perhaps the<br>&gt;&gt;&gt; similarities and differences between the language constructs can be made<br>&gt;&gt;&gt; clearer to see by pretending that argument and parameter lists are written<br>&gt;&gt;&gt; with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; For example, I think most people agree that we should be able to use<br>&gt;&gt;&gt; &quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>&gt;&gt;&gt; ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt;&gt; This is fine and can be used to express meaning for the person<br>&gt;&gt;&gt; reading/writing, even though it means that some of the parens can become<br>&gt;&gt;&gt; superfluous to a machine interpretation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; AFAICS this need not have anything to do with tuples and/or parameter<br>&gt;&gt;&gt; lists, but the fact that Swift is treating eg:<br>&gt;&gt;&gt; func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt;&gt; as<br>&gt;&gt;&gt; func foo(x: Int) { print(x) }<br>&gt;&gt;&gt; and<br>&gt;&gt;&gt; ((Int, Int))<br>&gt;&gt;&gt; as<br>&gt;&gt;&gt; (Int, Int)<br>&gt;&gt;<br>&gt;&gt; If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple with Int,Int fields&quot; and (Int, Int) will mean only &quot;list of two Ints in parameters&quot;<br>&gt;<br>&gt; ((Int, Int)) would still be equivalent to (Int, Int). SE-0110 only concerns parameter lists in function types.<br></p><p>Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m missing <br>something... Quotation from proposal:<br></p><p> &gt;----------------&lt;<br>To declare a function type with one tuple parameter containing n elements <br>(where n &gt; 1), the function type&#39;s argument list must be enclosed by double <br>parentheses:<br></p><p>let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br> &gt;----------------&lt;<br></p><p>Oh... Or do you(and Jens) mean that this:<br>let x : (Int, Int) = (1,2)<br>will be the same as this:<br>let x : ((Int, Int)) = (1,2)<br>? and about<br>func foo(_ x: ((Int, Int))) { print(x) }<br>vs<br>func foo(_ x: (Int, Int)) { print(x) }<br>?<br>In this case yes, sorry for misunderstanding, SE-0110 will not change this. <br>I don&#39;t see any ambiguity here: foo will be called as<br>foo((1,2)) - clearly that tuple is sent as argument.<br></p><p>&gt;<br>&gt; -Joe<br>&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; seems to suggest that it somehow does.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Or maybe I have just forgotten the reasons for why there can be no such<br>&gt;&gt;&gt; thing as (a nested) single element tuple (type).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I also can&#39;t remember what the pros &amp; cons of disallowing labeled single<br>&gt;&gt;&gt; element tuples were.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Happy to be corrected and pointed to relevant reading : )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;ll try to rephrase my initial post a bit, perhaps it will make my point<br>clearer:<br></p><p>Might it be that some of the confusion regarding the evolution<br>(design/redesign) of tuples, parameter lists, etc. stems from the fact that<br>they all use parentheses? Or put differently: Parentheses, being used for<br>so many different (and similar) things, is perhaps blurring the &quot;real&quot;<br>(possibly simpler) similarities and differences.<br></p><p>I&#39;m not saying they should not all use parentheses in the final design, I&#39;m<br>only saying that perhaps it is making it harder to think clearly about<br>these things (while designing  the language).<br></p><p>Let&#39;s say we carry out a thought-experiment in which we assume that argument<br>and parameter lists use eg ≪≫ and tuples use eg ⊂⊃, and normal parentheses<br>are _only_ used for grouping and controlling priority in eg mathematical<br>expressions, but not when creating tuples, parameter lists, pattern<br>matching and closure types.<br></p><p>Using this notation (which is just a thinking-tool, not meant as a final<br>syntax), and reimagining these things from scratch, we could for example<br>try and see what happens if we assume that these are three _different_<br>types:<br>Int<br>⊂Int ⊃<br>⊂⊂ Int ⊃⊃<br>and also, for example, that it is ok to have single element tuples with an<br>element label.<br>And:<br></p><p>((-1) * ((x + y) + (3 * y))) // Still OK. Redundant parens are treated as<br>usual / as before.<br></p><p>⊂ String, Int ⊃ // Two element tuple type whose elements are a String and<br>an Int.<br></p><p>⊂ Int ⊃ // Single element Tuple type.<br></p><p>⊂⊂ Int ⊃⊃ // Single element Tuple type whose only element is another single<br>element tuple type whose only element is an Int.<br></p><p>≪ Int ≫ -&gt; Int // Function type from Int to Int.<br></p><p>Perhaps the ≪≫ would prove to be unnecessary, so:<br></p><p>Int -&gt; Int // Function type from Int to Int.<br>(Int -&gt; Int)? // Optional function type from Int to Int.<br>((((Int -&gt; Int))))? // Optional function type from Int to Int. (remember<br>parens are _only_ used for grouping this way)<br></p><p>⊂ Int, Int, Int ⊃ -&gt; Int // Function type from a 3-Int-tuple to an Int.<br>⊂⊂ Int, Int, Int ⊃⊃ -&gt; Int // Function type from a single element tuple<br>whose element is a 3-Int-tuple to an Int. (Yes, nobody would probably write<br>a function of such a type, but allowing it could perhaps make the rules a<br>lot simpler.)<br></p><p>... Well, I think you get the idea.<br></p><p>I&#39;m wondering if there has been any attempts at such from-the-scratch<br>redesigns of all these parentheses-related-things in the language<br>(including eg pattern matching, associated values and more).<br></p><p>/Jens<br></p><p><br>On Wed, Jul 6, 2016 at 8:10 PM, Vladimir.S via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;<br>&gt;&gt;<br>&gt;&gt; On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution &lt;<br>&gt;&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Please feel free to ignore this naive attempt to engage in this<br>&gt;&gt;&gt;&gt; discussion.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; My understanding of the history of Swift&#39;s tuples, argument lists,<br>&gt;&gt;&gt;&gt; pattern<br>&gt;&gt;&gt;&gt; matching, associated values, etc. in two steps:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 1. Initial Idealism *:<br>&gt;&gt;&gt;&gt; Simple powerful heavily reused general concept.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; 2. Iterative pragmatism / reality *:<br>&gt;&gt;&gt;&gt; Complicated (exceptions to) rules.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (* Inevitably not taking everything in to account.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Has there been any recent attempts to outline a more or less complete<br>&gt;&gt;&gt;&gt; redesign for these things, returning to step 1 so to speak, but taking<br>&gt;&gt;&gt;&gt; into<br>&gt;&gt;&gt;&gt; account what has now been learned?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; As a side note (and supposedly trivial to most but me):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Parentheses (parenthesized expressions in the grammar?) are used for<br>&gt;&gt;&gt;&gt; all of<br>&gt;&gt;&gt;&gt; these parts of the language, and they probably should be, but perhaps<br>&gt;&gt;&gt;&gt; the<br>&gt;&gt;&gt;&gt; similarities and differences between the language constructs can be made<br>&gt;&gt;&gt;&gt; clearer to see by pretending that argument and parameter lists are<br>&gt;&gt;&gt;&gt; written<br>&gt;&gt;&gt;&gt; with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; For example, I think most people agree that we should be able to use<br>&gt;&gt;&gt;&gt; &quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>&gt;&gt;&gt;&gt; ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt;&gt;&gt; This is fine and can be used to express meaning for the person<br>&gt;&gt;&gt;&gt; reading/writing, even though it means that some of the parens can become<br>&gt;&gt;&gt;&gt; superfluous to a machine interpretation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; AFAICS this need not have anything to do with tuples and/or parameter<br>&gt;&gt;&gt;&gt; lists, but the fact that Swift is treating eg:<br>&gt;&gt;&gt;&gt; func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt; func foo(x: Int) { print(x) }<br>&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt; ((Int, Int))<br>&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt; (Int, Int)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple with<br>&gt;&gt;&gt; Int,Int fields&quot; and (Int, Int) will mean only &quot;list of two Ints in<br>&gt;&gt;&gt; parameters&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ((Int, Int)) would still be equivalent to (Int, Int). SE-0110 only<br>&gt;&gt; concerns parameter lists in function types.<br>&gt;&gt;<br>&gt;<br>&gt; Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m missing<br>&gt; something... Quotation from proposal:<br>&gt;<br>&gt; &gt;----------------&lt;<br>&gt; To declare a function type with one tuple parameter containing n elements<br>&gt; (where n &gt; 1), the function type&#39;s argument list must be enclosed by double<br>&gt; parentheses:<br>&gt;<br>&gt; let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br>&gt; &gt;----------------&lt;<br>&gt;<br>&gt; Oh... Or do you(and Jens) mean that this:<br>&gt; let x : (Int, Int) = (1,2)<br>&gt; will be the same as this:<br>&gt; let x : ((Int, Int)) = (1,2)<br>&gt; ? and about<br>&gt; func foo(_ x: ((Int, Int))) { print(x) }<br>&gt; vs<br>&gt; func foo(_ x: (Int, Int)) { print(x) }<br>&gt; ?<br>&gt; In this case yes, sorry for misunderstanding, SE-0110 will not change<br>&gt; this. I don&#39;t see any ambiguity here: foo will be called as<br>&gt; foo((1,2)) - clearly that tuple is sent as argument.<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; seems to suggest that it somehow does.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Or maybe I have just forgotten the reasons for why there can be no such<br>&gt;&gt;&gt;&gt; thing as (a nested) single element tuple (type).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I also can&#39;t remember what the pros &amp; cons of disallowing labeled single<br>&gt;&gt;&gt;&gt; element tuples were.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Happy to be corrected and pointed to relevant reading : )<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br></p><p><br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160706/3c4390ad/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a0b362cd96d9f85beab1079ff37e3d19?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Vladimir.S</string> &lt;svabox at gmail.com&gt;<p>July  7, 2016 at 03:00:00pm</p></header><div class="content"><p>On 06.07.2016 22:37, Jens Persson wrote:<br>&gt; I&#39;ll try to rephrase my initial post a bit, perhaps it will make my point<br>&gt; clearer:<br></p><p>I got your idea. Although I don&#39;t know if it is easy to implement in <br>compiler/parser, I know that it is hard to find such symbols (as <br>replacement of parentheses) that will be easy to type on keyboard. Don&#39;t <br>you really propose to type unicode chars like ⊂ ? I believe no.<br></p><p>&lt;&gt; - used for generics<br>{} - for code blocks<br>[] - for subscripts/arrays/dicts<br></p><p>what I can think of is vertical bar | symbol as parentheses for tuples:<br></p><p>var x = |5,5|<br></p><p>func foo(tuple: |Int,Int,String|) {..}<br></p><p>(|Int,Int|)-&gt;Int<br>(|Int,Int|)-&gt;|String, String|<br></p><p>((Int) -&gt; Int)?  -- optional function<br>|(Int) -&gt; Int|?  -- optional tuple<br></p><p>I feel like such syntax for tuples more clearly separates tuple declaration <br>from other parts of code.<br>Don&#39;t know if that makes sense :-)<br>And not sure if we really needs one-element tuple even if we can clearly <br>parse it in source.<br></p><p>Btw, parentheses are required for argument list in function type now, so we <br>can&#39;t write `Int -&gt; Int`, but only as `(Int) -&gt; Int`, and not `(Int -&gt; <br>Int)?` but as `((Int) -&gt; Int)?`<br></p><p>&gt;<br>&gt; Might it be that some of the confusion regarding the evolution<br>&gt; (design/redesign) of tuples, parameter lists, etc. stems from the fact that<br>&gt; they all use parentheses? Or put differently: Parentheses, being used for<br>&gt; so many different (and similar) things, is perhaps blurring the &quot;real&quot;<br>&gt; (possibly simpler) similarities and differences.<br>&gt;<br>&gt; I&#39;m not saying they should not all use parentheses in the final design, I&#39;m<br>&gt; only saying that perhaps it is making it harder to think clearly about<br>&gt; these things (while designing  the language).<br>&gt;<br>&gt; Let&#39;s say we carry out a thought-experiment in which we assume<br>&gt; that argument and parameter lists use eg ≪≫ and tuples use eg ⊂⊃, and<br>&gt; normal parentheses are _only_ used for grouping and controlling priority in<br>&gt; eg mathematical expressions, but not when creating tuples, parameter lists,<br>&gt; pattern matching and closure types.<br>&gt;<br>&gt; Using this notation (which is just a thinking-tool, not meant as a final<br>&gt; syntax), and reimagining these things from scratch, we could for example<br>&gt; try and see what happens if we assume that these are three _different_ types:<br>&gt; Int<br>&gt; ⊂Int ⊃<br>&gt; ⊂⊂ Int ⊃⊃<br>&gt; and also, for example, that it is ok to have single element tuples with an<br>&gt; element label.<br>&gt; And:<br>&gt;<br>&gt; ((-1) * ((x + y) + (3 * y))) // Still OK. Redundant parens are treated as<br>&gt; usual / as before.<br>&gt;<br>&gt; ⊂ String, Int ⊃ // Two element tuple type whose elements are a String and<br>&gt; an Int.<br>&gt;<br>&gt; ⊂ Int ⊃ // Single element Tuple type.<br>&gt;<br>&gt; ⊂⊂ Int ⊃⊃ // Single element Tuple type whose only element is another single<br>&gt; element tuple type whose only element is an Int.<br>&gt;<br>&gt; ≪ Int ≫ -&gt; Int // Function type from Int to Int.<br>&gt;<br>&gt; Perhaps the ≪≫ would prove to be unnecessary, so:<br>&gt;<br>&gt; Int -&gt; Int // Function type from Int to Int.<br>&gt; (Int -&gt; Int)? // Optional function type from Int to Int.<br>&gt; ((((Int -&gt; Int))))? // Optional function type from Int to Int. (remember<br>&gt; parens are _only_ used for grouping this way)<br>&gt;<br>&gt; ⊂ Int, Int, Int ⊃ -&gt; Int // Function type from a 3-Int-tuple to an Int.<br>&gt; ⊂⊂ Int, Int, Int ⊃⊃ -&gt; Int // Function type from a single element tuple<br>&gt; whose element is a 3-Int-tuple to an Int. (Yes, nobody would probably write<br>&gt; a function of such a type, but allowing it could perhaps make the rules a<br>&gt; lot simpler.)<br>&gt;<br>&gt; ... Well, I think you get the idea.<br>&gt;<br>&gt; I&#39;m wondering if there has been any attempts at such from-the-scratch<br>&gt; redesigns of all these parentheses-related-things in the language<br>&gt; (including eg pattern matching, associated values and more).<br>&gt;<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Wed, Jul 6, 2016 at 8:10 PM, Vladimir.S via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;<br>&gt;     On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;<br>&gt;<br>&gt;             On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution<br>&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;<br>&gt;             wrote:<br>&gt;<br>&gt;             On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;<br>&gt;                 Please feel free to ignore this naive attempt to engage in<br>&gt;                 this discussion.<br>&gt;<br>&gt;                 My understanding of the history of Swift&#39;s tuples, argument<br>&gt;                 lists, pattern<br>&gt;                 matching, associated values, etc. in two steps:<br>&gt;<br>&gt;                 1. Initial Idealism *:<br>&gt;                 Simple powerful heavily reused general concept.<br>&gt;<br>&gt;                 2. Iterative pragmatism / reality *:<br>&gt;                 Complicated (exceptions to) rules.<br>&gt;<br>&gt;                 (* Inevitably not taking everything in to account.)<br>&gt;<br>&gt;                 Has there been any recent attempts to outline a more or<br>&gt;                 less complete<br>&gt;                 redesign for these things, returning to step 1 so to speak,<br>&gt;                 but taking into<br>&gt;                 account what has now been learned?<br>&gt;<br>&gt;<br>&gt;                 As a side note (and supposedly trivial to most but me):<br>&gt;<br>&gt;                 Parentheses (parenthesized expressions in the grammar?) are<br>&gt;                 used for all of<br>&gt;                 these parts of the language, and they probably should be,<br>&gt;                 but perhaps the<br>&gt;                 similarities and differences between the language<br>&gt;                 constructs can be made<br>&gt;                 clearer to see by pretending that argument and parameter<br>&gt;                 lists are written<br>&gt;                 with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;<br>&gt;                 For example, I think most people agree that we should be<br>&gt;                 able to use<br>&gt;                 &quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>&gt;                 ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;                 This is fine and can be used to express meaning for the person<br>&gt;                 reading/writing, even though it means that some of the<br>&gt;                 parens can become<br>&gt;                 superfluous to a machine interpretation.<br>&gt;<br>&gt;                 AFAICS this need not have anything to do with tuples and/or<br>&gt;                 parameter<br>&gt;                 lists, but the fact that Swift is treating eg:<br>&gt;                 func foo(x: ((((Int))))) { print(x) }<br>&gt;                 as<br>&gt;                 func foo(x: Int) { print(x) }<br>&gt;                 and<br>&gt;                 ((Int, Int))<br>&gt;                 as<br>&gt;                 (Int, Int)<br>&gt;<br>&gt;<br>&gt;             If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple<br>&gt;             with Int,Int fields&quot; and (Int, Int) will mean only &quot;list of two<br>&gt;             Ints in parameters&quot;<br>&gt;<br>&gt;<br>&gt;         ((Int, Int)) would still be equivalent to (Int, Int). SE-0110 only<br>&gt;         concerns parameter lists in function types.<br>&gt;<br>&gt;<br>&gt;     Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m missing<br>&gt;     something... Quotation from proposal:<br>&gt;<br>&gt;     &gt;----------------&lt;<br>&gt;     To declare a function type with one tuple parameter containing n<br>&gt;     elements (where n &gt; 1), the function type&#39;s argument list must be<br>&gt;     enclosed by double parentheses:<br>&gt;<br>&gt;     let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br>&gt;     &gt;----------------&lt;<br>&gt;<br>&gt;     Oh... Or do you(and Jens) mean that this:<br>&gt;     let x : (Int, Int) = (1,2)<br>&gt;     will be the same as this:<br>&gt;     let x : ((Int, Int)) = (1,2)<br>&gt;     ? and about<br>&gt;     func foo(_ x: ((Int, Int))) { print(x) }<br>&gt;     vs<br>&gt;     func foo(_ x: (Int, Int)) { print(x) }<br>&gt;     ?<br>&gt;     In this case yes, sorry for misunderstanding, SE-0110 will not change<br>&gt;     this. I don&#39;t see any ambiguity here: foo will be called as<br>&gt;     foo((1,2)) - clearly that tuple is sent as argument.<br>&gt;<br>&gt;<br>&gt;<br>&gt;         -Joe<br>&gt;<br>&gt;<br>&gt;                 seems to suggest that it somehow does.<br>&gt;<br>&gt;                 Or maybe I have just forgotten the reasons for why there<br>&gt;                 can be no such<br>&gt;                 thing as (a nested) single element tuple (type).<br>&gt;<br>&gt;                 I also can&#39;t remember what the pros &amp; cons of disallowing<br>&gt;                 labeled single<br>&gt;                 element tuples were.<br>&gt;<br>&gt;                 Happy to be corrected and pointed to relevant reading : )<br>&gt;<br>&gt;                 /Jens<br>&gt;<br>&gt;<br>&gt;<br>&gt;                 _______________________________________________<br>&gt;                 swift-evolution mailing list<br>&gt;                 swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;             _______________________________________________<br>&gt;             swift-evolution mailing list<br>&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;     _______________________________________________<br>&gt;     swift-evolution mailing list<br>&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>July  7, 2016 at 05:00:00pm</p></header><div class="content"><p>As previously mentioned, I was talking about using those symbols only as a<br>thinking-tool to possibly simplify language design, making the &quot;real&quot;<br>differences and similarities easier to see while thinking about the design.<br>The final syntax could perhaps still use normal parentheses for all<br>these parts of the language. Please reread my previous two posts for more<br>details.<br>/Jens<br></p><p><br>On Thursday, July 7, 2016, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br></p><p>&gt; On 06.07.2016 22:37, Jens Persson wrote:<br>&gt;<br>&gt;&gt; I&#39;ll try to rephrase my initial post a bit, perhaps it will make my point<br>&gt;&gt; clearer:<br>&gt;&gt;<br>&gt;<br>&gt; I got your idea. Although I don&#39;t know if it is easy to implement in<br>&gt; compiler/parser, I know that it is hard to find such symbols (as<br>&gt; replacement of parentheses) that will be easy to type on keyboard. Don&#39;t<br>&gt; you really propose to type unicode chars like ⊂ ? I believe no.<br>&gt;<br>&gt; &lt;&gt; - used for generics<br>&gt; {} - for code blocks<br>&gt; [] - for subscripts/arrays/dicts<br>&gt;<br>&gt; what I can think of is vertical bar | symbol as parentheses for tuples:<br>&gt;<br>&gt; var x = |5,5|<br>&gt;<br>&gt; func foo(tuple: |Int,Int,String|) {..}<br>&gt;<br>&gt; (|Int,Int|)-&gt;Int<br>&gt; (|Int,Int|)-&gt;|String, String|<br>&gt;<br>&gt; ((Int) -&gt; Int)?  -- optional function<br>&gt; |(Int) -&gt; Int|?  -- optional tuple<br>&gt;<br>&gt; I feel like such syntax for tuples more clearly separates tuple<br>&gt; declaration from other parts of code.<br>&gt; Don&#39;t know if that makes sense :-)<br>&gt; And not sure if we really needs one-element tuple even if we can clearly<br>&gt; parse it in source.<br>&gt;<br>&gt; Btw, parentheses are required for argument list in function type now, so<br>&gt; we can&#39;t write `Int -&gt; Int`, but only as `(Int) -&gt; Int`, and not `(Int -&gt;<br>&gt; Int)?` but as `((Int) -&gt; Int)?`<br>&gt;<br>&gt;<br>&gt;&gt; Might it be that some of the confusion regarding the evolution<br>&gt;&gt; (design/redesign) of tuples, parameter lists, etc. stems from the fact<br>&gt;&gt; that<br>&gt;&gt; they all use parentheses? Or put differently: Parentheses, being used for<br>&gt;&gt; so many different (and similar) things, is perhaps blurring the &quot;real&quot;<br>&gt;&gt; (possibly simpler) similarities and differences.<br>&gt;&gt;<br>&gt;&gt; I&#39;m not saying they should not all use parentheses in the final design,<br>&gt;&gt; I&#39;m<br>&gt;&gt; only saying that perhaps it is making it harder to think clearly about<br>&gt;&gt; these things (while designing  the language).<br>&gt;&gt;<br>&gt;&gt; Let&#39;s say we carry out a thought-experiment in which we assume<br>&gt;&gt; that argument and parameter lists use eg ≪≫ and tuples use eg ⊂⊃, and<br>&gt;&gt; normal parentheses are _only_ used for grouping and controlling priority<br>&gt;&gt; in<br>&gt;&gt; eg mathematical expressions, but not when creating tuples, parameter<br>&gt;&gt; lists,<br>&gt;&gt; pattern matching and closure types.<br>&gt;&gt;<br>&gt;&gt; Using this notation (which is just a thinking-tool, not meant as a final<br>&gt;&gt; syntax), and reimagining these things from scratch, we could for example<br>&gt;&gt; try and see what happens if we assume that these are three _different_<br>&gt;&gt; types:<br>&gt;&gt; Int<br>&gt;&gt; ⊂Int ⊃<br>&gt;&gt; ⊂⊂ Int ⊃⊃<br>&gt;&gt; and also, for example, that it is ok to have single element tuples with an<br>&gt;&gt; element label.<br>&gt;&gt; And:<br>&gt;&gt;<br>&gt;&gt; ((-1) * ((x + y) + (3 * y))) // Still OK. Redundant parens are treated as<br>&gt;&gt; usual / as before.<br>&gt;&gt;<br>&gt;&gt; ⊂ String, Int ⊃ // Two element tuple type whose elements are a String and<br>&gt;&gt; an Int.<br>&gt;&gt;<br>&gt;&gt; ⊂ Int ⊃ // Single element Tuple type.<br>&gt;&gt;<br>&gt;&gt; ⊂⊂ Int ⊃⊃ // Single element Tuple type whose only element is another<br>&gt;&gt; single<br>&gt;&gt; element tuple type whose only element is an Int.<br>&gt;&gt;<br>&gt;&gt; ≪ Int ≫ -&gt; Int // Function type from Int to Int.<br>&gt;&gt;<br>&gt;&gt; Perhaps the ≪≫ would prove to be unnecessary, so:<br>&gt;&gt;<br>&gt;&gt; Int -&gt; Int // Function type from Int to Int.<br>&gt;&gt; (Int -&gt; Int)? // Optional function type from Int to Int.<br>&gt;&gt; ((((Int -&gt; Int))))? // Optional function type from Int to Int. (remember<br>&gt;&gt; parens are _only_ used for grouping this way)<br>&gt;&gt;<br>&gt;&gt; ⊂ Int, Int, Int ⊃ -&gt; Int // Function type from a 3-Int-tuple to an Int.<br>&gt;&gt; ⊂⊂ Int, Int, Int ⊃⊃ -&gt; Int // Function type from a single element tuple<br>&gt;&gt; whose element is a 3-Int-tuple to an Int. (Yes, nobody would probably<br>&gt;&gt; write<br>&gt;&gt; a function of such a type, but allowing it could perhaps make the rules a<br>&gt;&gt; lot simpler.)<br>&gt;&gt;<br>&gt;&gt; ... Well, I think you get the idea.<br>&gt;&gt;<br>&gt;&gt; I&#39;m wondering if there has been any attempts at such from-the-scratch<br>&gt;&gt; redesigns of all these parentheses-related-things in the language<br>&gt;&gt; (including eg pattern matching, associated values and more).<br>&gt;&gt;<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Jul 6, 2016 at 8:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;     On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution<br>&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt; &gt;&gt;<br>&gt;&gt;             wrote:<br>&gt;&gt;<br>&gt;&gt;             On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt;<br>&gt;&gt;                 Please feel free to ignore this naive attempt to engage in<br>&gt;&gt;                 this discussion.<br>&gt;&gt;<br>&gt;&gt;                 My understanding of the history of Swift&#39;s tuples,<br>&gt;&gt; argument<br>&gt;&gt;                 lists, pattern<br>&gt;&gt;                 matching, associated values, etc. in two steps:<br>&gt;&gt;<br>&gt;&gt;                 1. Initial Idealism *:<br>&gt;&gt;                 Simple powerful heavily reused general concept.<br>&gt;&gt;<br>&gt;&gt;                 2. Iterative pragmatism / reality *:<br>&gt;&gt;                 Complicated (exceptions to) rules.<br>&gt;&gt;<br>&gt;&gt;                 (* Inevitably not taking everything in to account.)<br>&gt;&gt;<br>&gt;&gt;                 Has there been any recent attempts to outline a more or<br>&gt;&gt;                 less complete<br>&gt;&gt;                 redesign for these things, returning to step 1 so to<br>&gt;&gt; speak,<br>&gt;&gt;                 but taking into<br>&gt;&gt;                 account what has now been learned?<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 As a side note (and supposedly trivial to most but me):<br>&gt;&gt;<br>&gt;&gt;                 Parentheses (parenthesized expressions in the grammar?)<br>&gt;&gt; are<br>&gt;&gt;                 used for all of<br>&gt;&gt;                 these parts of the language, and they probably should be,<br>&gt;&gt;                 but perhaps the<br>&gt;&gt;                 similarities and differences between the language<br>&gt;&gt;                 constructs can be made<br>&gt;&gt;                 clearer to see by pretending that argument and parameter<br>&gt;&gt;                 lists are written<br>&gt;&gt;                 with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt;<br>&gt;&gt;                 For example, I think most people agree that we should be<br>&gt;&gt;                 able to use<br>&gt;&gt;                 &quot;sloppy/forgiving&quot; parenthetical grouping in code such as:<br>&gt;&gt;                 ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt;                 This is fine and can be used to express meaning for the<br>&gt;&gt; person<br>&gt;&gt;                 reading/writing, even though it means that some of the<br>&gt;&gt;                 parens can become<br>&gt;&gt;                 superfluous to a machine interpretation.<br>&gt;&gt;<br>&gt;&gt;                 AFAICS this need not have anything to do with tuples<br>&gt;&gt; and/or<br>&gt;&gt;                 parameter<br>&gt;&gt;                 lists, but the fact that Swift is treating eg:<br>&gt;&gt;                 func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt;                 as<br>&gt;&gt;                 func foo(x: Int) { print(x) }<br>&gt;&gt;                 and<br>&gt;&gt;                 ((Int, Int))<br>&gt;&gt;                 as<br>&gt;&gt;                 (Int, Int)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;             If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple<br>&gt;&gt;             with Int,Int fields&quot; and (Int, Int) will mean only &quot;list of<br>&gt;&gt; two<br>&gt;&gt;             Ints in parameters&quot;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         ((Int, Int)) would still be equivalent to (Int, Int). SE-0110 only<br>&gt;&gt;         concerns parameter lists in function types.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m missing<br>&gt;&gt;     something... Quotation from proposal:<br>&gt;&gt;<br>&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;     To declare a function type with one tuple parameter containing n<br>&gt;&gt;     elements (where n &gt; 1), the function type&#39;s argument list must be<br>&gt;&gt;     enclosed by double parentheses:<br>&gt;&gt;<br>&gt;&gt;     let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br>&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;<br>&gt;&gt;     Oh... Or do you(and Jens) mean that this:<br>&gt;&gt;     let x : (Int, Int) = (1,2)<br>&gt;&gt;     will be the same as this:<br>&gt;&gt;     let x : ((Int, Int)) = (1,2)<br>&gt;&gt;     ? and about<br>&gt;&gt;     func foo(_ x: ((Int, Int))) { print(x) }<br>&gt;&gt;     vs<br>&gt;&gt;     func foo(_ x: (Int, Int)) { print(x) }<br>&gt;&gt;     ?<br>&gt;&gt;     In this case yes, sorry for misunderstanding, SE-0110 will not change<br>&gt;&gt;     this. I don&#39;t see any ambiguity here: foo will be called as<br>&gt;&gt;     foo((1,2)) - clearly that tuple is sent as argument.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;         -Joe<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 seems to suggest that it somehow does.<br>&gt;&gt;<br>&gt;&gt;                 Or maybe I have just forgotten the reasons for why there<br>&gt;&gt;                 can be no such<br>&gt;&gt;                 thing as (a nested) single element tuple (type).<br>&gt;&gt;<br>&gt;&gt;                 I also can&#39;t remember what the pros &amp; cons of disallowing<br>&gt;&gt;                 labeled single<br>&gt;&gt;                 element tuples were.<br>&gt;&gt;<br>&gt;&gt;                 Happy to be corrected and pointed to relevant reading : )<br>&gt;&gt;<br>&gt;&gt;                 /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;                 _______________________________________________<br>&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;             _______________________________________________<br>&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;     _______________________________________________<br>&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;<br>&gt;&gt;<br>&gt;&gt;<br></p><p>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/a0afd454/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>July  7, 2016 at 09:00:00pm</p></header><div class="content"><p>Also, regarding the special case of single element tuples, ie Int being the<br>same type as (Int) and ((((Int))):<br>I&#39;m wondering if that can be viewed as an irregularity baked in at the<br>foundation of the system (parenthesized expressions), sending ripples of<br>perhaps needless complexity through the rest of the (parentheses-using<br>parts) of the language. I&#39;m not knowledgable enough to analyze this myself<br>though.<br>/Jens<br></p><p><br>On Thu, Jul 7, 2016 at 5:01 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br></p><p>&gt; As previously mentioned, I was talking about using those symbols only as a<br>&gt; thinking-tool to possibly simplify language design, making the &quot;real&quot;<br>&gt; differences and similarities easier to see while thinking about the design.<br>&gt; The final syntax could perhaps still use normal parentheses for all<br>&gt; these parts of the language. Please reread my previous two posts for more<br>&gt; details.<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Thursday, July 7, 2016, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;<br>&gt;&gt; On 06.07.2016 22:37, Jens Persson wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; I&#39;ll try to rephrase my initial post a bit, perhaps it will make my point<br>&gt;&gt;&gt; clearer:<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; I got your idea. Although I don&#39;t know if it is easy to implement in<br>&gt;&gt; compiler/parser, I know that it is hard to find such symbols (as<br>&gt;&gt; replacement of parentheses) that will be easy to type on keyboard. Don&#39;t<br>&gt;&gt; you really propose to type unicode chars like ⊂ ? I believe no.<br>&gt;&gt;<br>&gt;&gt; &lt;&gt; - used for generics<br>&gt;&gt; {} - for code blocks<br>&gt;&gt; [] - for subscripts/arrays/dicts<br>&gt;&gt;<br>&gt;&gt; what I can think of is vertical bar | symbol as parentheses for tuples:<br>&gt;&gt;<br>&gt;&gt; var x = |5,5|<br>&gt;&gt;<br>&gt;&gt; func foo(tuple: |Int,Int,String|) {..}<br>&gt;&gt;<br>&gt;&gt; (|Int,Int|)-&gt;Int<br>&gt;&gt; (|Int,Int|)-&gt;|String, String|<br>&gt;&gt;<br>&gt;&gt; ((Int) -&gt; Int)?  -- optional function<br>&gt;&gt; |(Int) -&gt; Int|?  -- optional tuple<br>&gt;&gt;<br>&gt;&gt; I feel like such syntax for tuples more clearly separates tuple<br>&gt;&gt; declaration from other parts of code.<br>&gt;&gt; Don&#39;t know if that makes sense :-)<br>&gt;&gt; And not sure if we really needs one-element tuple even if we can clearly<br>&gt;&gt; parse it in source.<br>&gt;&gt;<br>&gt;&gt; Btw, parentheses are required for argument list in function type now, so<br>&gt;&gt; we can&#39;t write `Int -&gt; Int`, but only as `(Int) -&gt; Int`, and not `(Int -&gt;<br>&gt;&gt; Int)?` but as `((Int) -&gt; Int)?`<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt; Might it be that some of the confusion regarding the evolution<br>&gt;&gt;&gt; (design/redesign) of tuples, parameter lists, etc. stems from the fact<br>&gt;&gt;&gt; that<br>&gt;&gt;&gt; they all use parentheses? Or put differently: Parentheses, being used for<br>&gt;&gt;&gt; so many different (and similar) things, is perhaps blurring the &quot;real&quot;<br>&gt;&gt;&gt; (possibly simpler) similarities and differences.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m not saying they should not all use parentheses in the final design,<br>&gt;&gt;&gt; I&#39;m<br>&gt;&gt;&gt; only saying that perhaps it is making it harder to think clearly about<br>&gt;&gt;&gt; these things (while designing  the language).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Let&#39;s say we carry out a thought-experiment in which we assume<br>&gt;&gt;&gt; that argument and parameter lists use eg ≪≫ and tuples use eg ⊂⊃, and<br>&gt;&gt;&gt; normal parentheses are _only_ used for grouping and controlling priority<br>&gt;&gt;&gt; in<br>&gt;&gt;&gt; eg mathematical expressions, but not when creating tuples, parameter<br>&gt;&gt;&gt; lists,<br>&gt;&gt;&gt; pattern matching and closure types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Using this notation (which is just a thinking-tool, not meant as a final<br>&gt;&gt;&gt; syntax), and reimagining these things from scratch, we could for example<br>&gt;&gt;&gt; try and see what happens if we assume that these are three _different_<br>&gt;&gt;&gt; types:<br>&gt;&gt;&gt; Int<br>&gt;&gt;&gt; ⊂Int ⊃<br>&gt;&gt;&gt; ⊂⊂ Int ⊃⊃<br>&gt;&gt;&gt; and also, for example, that it is ok to have single element tuples with<br>&gt;&gt;&gt; an<br>&gt;&gt;&gt; element label.<br>&gt;&gt;&gt; And:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ((-1) * ((x + y) + (3 * y))) // Still OK. Redundant parens are treated as<br>&gt;&gt;&gt; usual / as before.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ⊂ String, Int ⊃ // Two element tuple type whose elements are a String and<br>&gt;&gt;&gt; an Int.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ⊂ Int ⊃ // Single element Tuple type.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ⊂⊂ Int ⊃⊃ // Single element Tuple type whose only element is another<br>&gt;&gt;&gt; single<br>&gt;&gt;&gt; element tuple type whose only element is an Int.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ≪ Int ≫ -&gt; Int // Function type from Int to Int.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Perhaps the ≪≫ would prove to be unnecessary, so:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Int -&gt; Int // Function type from Int to Int.<br>&gt;&gt;&gt; (Int -&gt; Int)? // Optional function type from Int to Int.<br>&gt;&gt;&gt; ((((Int -&gt; Int))))? // Optional function type from Int to Int. (remember<br>&gt;&gt;&gt; parens are _only_ used for grouping this way)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ⊂ Int, Int, Int ⊃ -&gt; Int // Function type from a 3-Int-tuple to an Int.<br>&gt;&gt;&gt; ⊂⊂ Int, Int, Int ⊃⊃ -&gt; Int // Function type from a single element tuple<br>&gt;&gt;&gt; whose element is a 3-Int-tuple to an Int. (Yes, nobody would probably<br>&gt;&gt;&gt; write<br>&gt;&gt;&gt; a function of such a type, but allowing it could perhaps make the rules a<br>&gt;&gt;&gt; lot simpler.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ... Well, I think you get the idea.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I&#39;m wondering if there has been any attempts at such from-the-scratch<br>&gt;&gt;&gt; redesigns of all these parentheses-related-things in the language<br>&gt;&gt;&gt; (including eg pattern matching, associated values and more).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Wed, Jul 6, 2016 at 8:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt; &gt;&gt;<br>&gt;&gt;&gt;             wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 Please feel free to ignore this naive attempt to engage<br>&gt;&gt;&gt; in<br>&gt;&gt;&gt;                 this discussion.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 My understanding of the history of Swift&#39;s tuples,<br>&gt;&gt;&gt; argument<br>&gt;&gt;&gt;                 lists, pattern<br>&gt;&gt;&gt;                 matching, associated values, etc. in two steps:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 1. Initial Idealism *:<br>&gt;&gt;&gt;                 Simple powerful heavily reused general concept.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 2. Iterative pragmatism / reality *:<br>&gt;&gt;&gt;                 Complicated (exceptions to) rules.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 (* Inevitably not taking everything in to account.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 Has there been any recent attempts to outline a more or<br>&gt;&gt;&gt;                 less complete<br>&gt;&gt;&gt;                 redesign for these things, returning to step 1 so to<br>&gt;&gt;&gt; speak,<br>&gt;&gt;&gt;                 but taking into<br>&gt;&gt;&gt;                 account what has now been learned?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 As a side note (and supposedly trivial to most but me):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 Parentheses (parenthesized expressions in the grammar?)<br>&gt;&gt;&gt; are<br>&gt;&gt;&gt;                 used for all of<br>&gt;&gt;&gt;                 these parts of the language, and they probably should be,<br>&gt;&gt;&gt;                 but perhaps the<br>&gt;&gt;&gt;                 similarities and differences between the language<br>&gt;&gt;&gt;                 constructs can be made<br>&gt;&gt;&gt;                 clearer to see by pretending that argument and parameter<br>&gt;&gt;&gt;                 lists are written<br>&gt;&gt;&gt;                 with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 For example, I think most people agree that we should be<br>&gt;&gt;&gt;                 able to use<br>&gt;&gt;&gt;                 &quot;sloppy/forgiving&quot; parenthetical grouping in code such<br>&gt;&gt;&gt; as:<br>&gt;&gt;&gt;                 ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt;&gt;                 This is fine and can be used to express meaning for the<br>&gt;&gt;&gt; person<br>&gt;&gt;&gt;                 reading/writing, even though it means that some of the<br>&gt;&gt;&gt;                 parens can become<br>&gt;&gt;&gt;                 superfluous to a machine interpretation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 AFAICS this need not have anything to do with tuples<br>&gt;&gt;&gt; and/or<br>&gt;&gt;&gt;                 parameter<br>&gt;&gt;&gt;                 lists, but the fact that Swift is treating eg:<br>&gt;&gt;&gt;                 func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt;&gt;                 as<br>&gt;&gt;&gt;                 func foo(x: Int) { print(x) }<br>&gt;&gt;&gt;                 and<br>&gt;&gt;&gt;                 ((Int, Int))<br>&gt;&gt;&gt;                 as<br>&gt;&gt;&gt;                 (Int, Int)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple<br>&gt;&gt;&gt;             with Int,Int fields&quot; and (Int, Int) will mean only &quot;list of<br>&gt;&gt;&gt; two<br>&gt;&gt;&gt;             Ints in parameters&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         ((Int, Int)) would still be equivalent to (Int, Int). SE-0110<br>&gt;&gt;&gt; only<br>&gt;&gt;&gt;         concerns parameter lists in function types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m<br>&gt;&gt;&gt; missing<br>&gt;&gt;&gt;     something... Quotation from proposal:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;&gt;     To declare a function type with one tuple parameter containing n<br>&gt;&gt;&gt;     elements (where n &gt; 1), the function type&#39;s argument list must be<br>&gt;&gt;&gt;     enclosed by double parentheses:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br>&gt;&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     Oh... Or do you(and Jens) mean that this:<br>&gt;&gt;&gt;     let x : (Int, Int) = (1,2)<br>&gt;&gt;&gt;     will be the same as this:<br>&gt;&gt;&gt;     let x : ((Int, Int)) = (1,2)<br>&gt;&gt;&gt;     ? and about<br>&gt;&gt;&gt;     func foo(_ x: ((Int, Int))) { print(x) }<br>&gt;&gt;&gt;     vs<br>&gt;&gt;&gt;     func foo(_ x: (Int, Int)) { print(x) }<br>&gt;&gt;&gt;     ?<br>&gt;&gt;&gt;     In this case yes, sorry for misunderstanding, SE-0110 will not change<br>&gt;&gt;&gt;     this. I don&#39;t see any ambiguity here: foo will be called as<br>&gt;&gt;&gt;     foo((1,2)) - clearly that tuple is sent as argument.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;         -Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 seems to suggest that it somehow does.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 Or maybe I have just forgotten the reasons for why there<br>&gt;&gt;&gt;                 can be no such<br>&gt;&gt;&gt;                 thing as (a nested) single element tuple (type).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 I also can&#39;t remember what the pros &amp; cons of disallowing<br>&gt;&gt;&gt;                 labeled single<br>&gt;&gt;&gt;                 element tuples were.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 Happy to be corrected and pointed to relevant reading : )<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;                 https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/a26f00b2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>July  7, 2016 at 11:00:00pm</p></header><div class="content"><p>I guess you are suggesting to:<br>1. Add single-element tuples to the language (not convertible to &quot;plain&quot;<br>types)<br>2. Make all otherwise unnecessary parentheses signify single-element tuples<br></p><p>In my first answer, I mentioned Haskell, because it treats types and<br>variables in pretty much the same way.<br>In that context, it is consistent to allow &quot;extra&quot; parentheses in types.<br>Compare:<br></p><p>a + (b!)     vs     A -&gt; (B?)<br></p><p>Both are not the best code style, but both are allowed. I see how<br>separating single-element tuples solves one inconsistency, but notice how<br>it creates another one.<br>Of course, we are discussing Swift, not Haskell, and here we may want to go<br>the other way and disallow extra parentheses on types. I don&#39;t really like<br>that way, though.<br></p><p>P.S. Since we now allow converting types to variables without &#39;self&#39;, the<br>following would be ambiguous:<br></p><p>Optional(0).map { _ in return (((Int))) }<br></p><p>Do parentheses belong to type or to value? Currently it does not really<br>matter, but with the change it would.<br></p><p>2016-07-07 22:16 GMT+03:00 Jens Persson via swift-evolution &lt;<br>swift-evolution at swift.org&gt;:<br></p><p>&gt; Also, regarding the special case of single element tuples, ie Int being<br>&gt; the same type as (Int) and ((((Int))):<br>&gt; I&#39;m wondering if that can be viewed as an irregularity baked in at the<br>&gt; foundation of the system (parenthesized expressions), sending ripples of<br>&gt; perhaps needless complexity through the rest of the (parentheses-using<br>&gt; parts) of the language. I&#39;m not knowledgable enough to analyze this myself<br>&gt; though.<br>&gt; /Jens<br>&gt;<br>&gt;<br>&gt; On Thu, Jul 7, 2016 at 5:01 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;<br>&gt;&gt; As previously mentioned, I was talking about using those symbols only as<br>&gt;&gt; a thinking-tool to possibly simplify language design, making the &quot;real&quot;<br>&gt;&gt; differences and similarities easier to see while thinking about the design.<br>&gt;&gt; The final syntax could perhaps still use normal parentheses for all<br>&gt;&gt; these parts of the language. Please reread my previous two posts for more<br>&gt;&gt; details.<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thursday, July 7, 2016, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; On 06.07.2016 22:37, Jens Persson wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;ll try to rephrase my initial post a bit, perhaps it will make my<br>&gt;&gt;&gt;&gt; point<br>&gt;&gt;&gt;&gt; clearer:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I got your idea. Although I don&#39;t know if it is easy to implement in<br>&gt;&gt;&gt; compiler/parser, I know that it is hard to find such symbols (as<br>&gt;&gt;&gt; replacement of parentheses) that will be easy to type on keyboard. Don&#39;t<br>&gt;&gt;&gt; you really propose to type unicode chars like ⊂ ? I believe no.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; &lt;&gt; - used for generics<br>&gt;&gt;&gt; {} - for code blocks<br>&gt;&gt;&gt; [] - for subscripts/arrays/dicts<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; what I can think of is vertical bar | symbol as parentheses for tuples:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; var x = |5,5|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; func foo(tuple: |Int,Int,String|) {..}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (|Int,Int|)-&gt;Int<br>&gt;&gt;&gt; (|Int,Int|)-&gt;|String, String|<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ((Int) -&gt; Int)?  -- optional function<br>&gt;&gt;&gt; |(Int) -&gt; Int|?  -- optional tuple<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; I feel like such syntax for tuples more clearly separates tuple<br>&gt;&gt;&gt; declaration from other parts of code.<br>&gt;&gt;&gt; Don&#39;t know if that makes sense :-)<br>&gt;&gt;&gt; And not sure if we really needs one-element tuple even if we can clearly<br>&gt;&gt;&gt; parse it in source.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Btw, parentheses are required for argument list in function type now, so<br>&gt;&gt;&gt; we can&#39;t write `Int -&gt; Int`, but only as `(Int) -&gt; Int`, and not `(Int -&gt;<br>&gt;&gt;&gt; Int)?` but as `((Int) -&gt; Int)?`<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Might it be that some of the confusion regarding the evolution<br>&gt;&gt;&gt;&gt; (design/redesign) of tuples, parameter lists, etc. stems from the fact<br>&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt; they all use parentheses? Or put differently: Parentheses, being used<br>&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt; so many different (and similar) things, is perhaps blurring the &quot;real&quot;<br>&gt;&gt;&gt;&gt; (possibly simpler) similarities and differences.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m not saying they should not all use parentheses in the final design,<br>&gt;&gt;&gt;&gt; I&#39;m<br>&gt;&gt;&gt;&gt; only saying that perhaps it is making it harder to think clearly about<br>&gt;&gt;&gt;&gt; these things (while designing  the language).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Let&#39;s say we carry out a thought-experiment in which we assume<br>&gt;&gt;&gt;&gt; that argument and parameter lists use eg ≪≫ and tuples use eg ⊂⊃, and<br>&gt;&gt;&gt;&gt; normal parentheses are _only_ used for grouping and controlling<br>&gt;&gt;&gt;&gt; priority in<br>&gt;&gt;&gt;&gt; eg mathematical expressions, but not when creating tuples, parameter<br>&gt;&gt;&gt;&gt; lists,<br>&gt;&gt;&gt;&gt; pattern matching and closure types.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Using this notation (which is just a thinking-tool, not meant as a final<br>&gt;&gt;&gt;&gt; syntax), and reimagining these things from scratch, we could for example<br>&gt;&gt;&gt;&gt; try and see what happens if we assume that these are three _different_<br>&gt;&gt;&gt;&gt; types:<br>&gt;&gt;&gt;&gt; Int<br>&gt;&gt;&gt;&gt; ⊂Int ⊃<br>&gt;&gt;&gt;&gt; ⊂⊂ Int ⊃⊃<br>&gt;&gt;&gt;&gt; and also, for example, that it is ok to have single element tuples with<br>&gt;&gt;&gt;&gt; an<br>&gt;&gt;&gt;&gt; element label.<br>&gt;&gt;&gt;&gt; And:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ((-1) * ((x + y) + (3 * y))) // Still OK. Redundant parens are treated<br>&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt; usual / as before.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ⊂ String, Int ⊃ // Two element tuple type whose elements are a String<br>&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt; an Int.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ⊂ Int ⊃ // Single element Tuple type.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ⊂⊂ Int ⊃⊃ // Single element Tuple type whose only element is another<br>&gt;&gt;&gt;&gt; single<br>&gt;&gt;&gt;&gt; element tuple type whose only element is an Int.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ≪ Int ≫ -&gt; Int // Function type from Int to Int.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Perhaps the ≪≫ would prove to be unnecessary, so:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Int -&gt; Int // Function type from Int to Int.<br>&gt;&gt;&gt;&gt; (Int -&gt; Int)? // Optional function type from Int to Int.<br>&gt;&gt;&gt;&gt; ((((Int -&gt; Int))))? // Optional function type from Int to Int. (remember<br>&gt;&gt;&gt;&gt; parens are _only_ used for grouping this way)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ⊂ Int, Int, Int ⊃ -&gt; Int // Function type from a 3-Int-tuple to an Int.<br>&gt;&gt;&gt;&gt; ⊂⊂ Int, Int, Int ⊃⊃ -&gt; Int // Function type from a single element tuple<br>&gt;&gt;&gt;&gt; whose element is a 3-Int-tuple to an Int. (Yes, nobody would probably<br>&gt;&gt;&gt;&gt; write<br>&gt;&gt;&gt;&gt; a function of such a type, but allowing it could perhaps make the rules<br>&gt;&gt;&gt;&gt; a<br>&gt;&gt;&gt;&gt; lot simpler.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ... Well, I think you get the idea.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I&#39;m wondering if there has been any attempts at such from-the-scratch<br>&gt;&gt;&gt;&gt; redesigns of all these parentheses-related-things in the language<br>&gt;&gt;&gt;&gt; (including eg pattern matching, associated values and more).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On Wed, Jul 6, 2016 at 8:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;             wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 Please feel free to ignore this naive attempt to engage<br>&gt;&gt;&gt;&gt; in<br>&gt;&gt;&gt;&gt;                 this discussion.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 My understanding of the history of Swift&#39;s tuples,<br>&gt;&gt;&gt;&gt; argument<br>&gt;&gt;&gt;&gt;                 lists, pattern<br>&gt;&gt;&gt;&gt;                 matching, associated values, etc. in two steps:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 1. Initial Idealism *:<br>&gt;&gt;&gt;&gt;                 Simple powerful heavily reused general concept.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 2. Iterative pragmatism / reality *:<br>&gt;&gt;&gt;&gt;                 Complicated (exceptions to) rules.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 (* Inevitably not taking everything in to account.)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 Has there been any recent attempts to outline a more or<br>&gt;&gt;&gt;&gt;                 less complete<br>&gt;&gt;&gt;&gt;                 redesign for these things, returning to step 1 so to<br>&gt;&gt;&gt;&gt; speak,<br>&gt;&gt;&gt;&gt;                 but taking into<br>&gt;&gt;&gt;&gt;                 account what has now been learned?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 As a side note (and supposedly trivial to most but me):<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 Parentheses (parenthesized expressions in the grammar?)<br>&gt;&gt;&gt;&gt; are<br>&gt;&gt;&gt;&gt;                 used for all of<br>&gt;&gt;&gt;&gt;                 these parts of the language, and they probably should<br>&gt;&gt;&gt;&gt; be,<br>&gt;&gt;&gt;&gt;                 but perhaps the<br>&gt;&gt;&gt;&gt;                 similarities and differences between the language<br>&gt;&gt;&gt;&gt;                 constructs can be made<br>&gt;&gt;&gt;&gt;                 clearer to see by pretending that argument and parameter<br>&gt;&gt;&gt;&gt;                 lists are written<br>&gt;&gt;&gt;&gt;                 with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 For example, I think most people agree that we should be<br>&gt;&gt;&gt;&gt;                 able to use<br>&gt;&gt;&gt;&gt;                 &quot;sloppy/forgiving&quot; parenthetical grouping in code such<br>&gt;&gt;&gt;&gt; as:<br>&gt;&gt;&gt;&gt;                 ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt;&gt;&gt;                 This is fine and can be used to express meaning for the<br>&gt;&gt;&gt;&gt; person<br>&gt;&gt;&gt;&gt;                 reading/writing, even though it means that some of the<br>&gt;&gt;&gt;&gt;                 parens can become<br>&gt;&gt;&gt;&gt;                 superfluous to a machine interpretation.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 AFAICS this need not have anything to do with tuples<br>&gt;&gt;&gt;&gt; and/or<br>&gt;&gt;&gt;&gt;                 parameter<br>&gt;&gt;&gt;&gt;                 lists, but the fact that Swift is treating eg:<br>&gt;&gt;&gt;&gt;                 func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt;&gt;&gt;                 as<br>&gt;&gt;&gt;&gt;                 func foo(x: Int) { print(x) }<br>&gt;&gt;&gt;&gt;                 and<br>&gt;&gt;&gt;&gt;                 ((Int, Int))<br>&gt;&gt;&gt;&gt;                 as<br>&gt;&gt;&gt;&gt;                 (Int, Int)<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1 tuple<br>&gt;&gt;&gt;&gt;             with Int,Int fields&quot; and (Int, Int) will mean only &quot;list of<br>&gt;&gt;&gt;&gt; two<br>&gt;&gt;&gt;&gt;             Ints in parameters&quot;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         ((Int, Int)) would still be equivalent to (Int, Int). SE-0110<br>&gt;&gt;&gt;&gt; only<br>&gt;&gt;&gt;&gt;         concerns parameter lists in function types.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m<br>&gt;&gt;&gt;&gt; missing<br>&gt;&gt;&gt;&gt;     something... Quotation from proposal:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;&gt;&gt;     To declare a function type with one tuple parameter containing n<br>&gt;&gt;&gt;&gt;     elements (where n &gt; 1), the function type&#39;s argument list must be<br>&gt;&gt;&gt;&gt;     enclosed by double parentheses:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br>&gt;&gt;&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     Oh... Or do you(and Jens) mean that this:<br>&gt;&gt;&gt;&gt;     let x : (Int, Int) = (1,2)<br>&gt;&gt;&gt;&gt;     will be the same as this:<br>&gt;&gt;&gt;&gt;     let x : ((Int, Int)) = (1,2)<br>&gt;&gt;&gt;&gt;     ? and about<br>&gt;&gt;&gt;&gt;     func foo(_ x: ((Int, Int))) { print(x) }<br>&gt;&gt;&gt;&gt;     vs<br>&gt;&gt;&gt;&gt;     func foo(_ x: (Int, Int)) { print(x) }<br>&gt;&gt;&gt;&gt;     ?<br>&gt;&gt;&gt;&gt;     In this case yes, sorry for misunderstanding, SE-0110 will not<br>&gt;&gt;&gt;&gt; change<br>&gt;&gt;&gt;&gt;     this. I don&#39;t see any ambiguity here: foo will be called as<br>&gt;&gt;&gt;&gt;     foo((1,2)) - clearly that tuple is sent as argument.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;         -Joe<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 seems to suggest that it somehow does.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 Or maybe I have just forgotten the reasons for why there<br>&gt;&gt;&gt;&gt;                 can be no such<br>&gt;&gt;&gt;&gt;                 thing as (a nested) single element tuple (type).<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 I also can&#39;t remember what the pros &amp; cons of<br>&gt;&gt;&gt;&gt; disallowing<br>&gt;&gt;&gt;&gt;                 labeled single<br>&gt;&gt;&gt;&gt;                 element tuples were.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 Happy to be corrected and pointed to relevant reading :<br>&gt;&gt;&gt;&gt; )<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 /Jens<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; &gt;<br>&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt; E-mail: jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; --<br>&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt; http://www.bitcycle.com/<br>&gt; Phone: +46-73-753 24 62<br>&gt; E-mail: jens at bitcycle.com<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160707/fd202db7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d042be5dcfe90e649f760303af3e429?s=50"></div><header><strong>[Discussion] Parentheses</strong> from <string>Jens Persson</string> &lt;jens at bitcycle.com&gt;<p>July  8, 2016 at 08:00:00pm</p></header><div class="content"><p>Thank you all, I guess it&#39;s impossible / very hard to come up with a design<br>without such inconsistencies and ambiguities, especially when parentheses<br>are used for so many different things in the language.<br>/Jens<br></p><p>On Thu, Jul 7, 2016 at 10:33 PM, Anton Zhilin &lt;antonyzhilin at gmail.com&gt;<br>wrote:<br></p><p>&gt; I guess you are suggesting to:<br>&gt; 1. Add single-element tuples to the language (not convertible to &quot;plain&quot;<br>&gt; types)<br>&gt; 2. Make all otherwise unnecessary parentheses signify single-element tuples<br>&gt;<br>&gt; In my first answer, I mentioned Haskell, because it treats types and<br>&gt; variables in pretty much the same way.<br>&gt; In that context, it is consistent to allow &quot;extra&quot; parentheses in types.<br>&gt; Compare:<br>&gt;<br>&gt; a + (b!)     vs     A -&gt; (B?)<br>&gt;<br>&gt; Both are not the best code style, but both are allowed. I see how<br>&gt; separating single-element tuples solves one inconsistency, but notice how<br>&gt; it creates another one.<br>&gt; Of course, we are discussing Swift, not Haskell, and here we may want to<br>&gt; go the other way and disallow extra parentheses on types. I don&#39;t really<br>&gt; like that way, though.<br>&gt;<br>&gt; P.S. Since we now allow converting types to variables without &#39;self&#39;, the<br>&gt; following would be ambiguous:<br>&gt;<br>&gt; Optional(0).map { _ in return (((Int))) }<br>&gt;<br>&gt; Do parentheses belong to type or to value? Currently it does not really<br>&gt; matter, but with the change it would.<br>&gt;<br>&gt; 2016-07-07 22:16 GMT+03:00 Jens Persson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt;&gt; Also, regarding the special case of single element tuples, ie Int being<br>&gt;&gt; the same type as (Int) and ((((Int))):<br>&gt;&gt; I&#39;m wondering if that can be viewed as an irregularity baked in at the<br>&gt;&gt; foundation of the system (parenthesized expressions), sending ripples of<br>&gt;&gt; perhaps needless complexity through the rest of the (parentheses-using<br>&gt;&gt; parts) of the language. I&#39;m not knowledgable enough to analyze this myself<br>&gt;&gt; though.<br>&gt;&gt; /Jens<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Thu, Jul 7, 2016 at 5:01 PM, Jens Persson &lt;jens at bitcycle.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; As previously mentioned, I was talking about using those symbols only as<br>&gt;&gt;&gt; a thinking-tool to possibly simplify language design, making the &quot;real&quot;<br>&gt;&gt;&gt; differences and similarities easier to see while thinking about the design.<br>&gt;&gt;&gt; The final syntax could perhaps still use normal parentheses for all<br>&gt;&gt;&gt; these parts of the language. Please reread my previous two posts for more<br>&gt;&gt;&gt; details.<br>&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; On Thursday, July 7, 2016, Vladimir.S &lt;svabox at gmail.com&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; On 06.07.2016 22:37, Jens Persson wrote:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;ll try to rephrase my initial post a bit, perhaps it will make my<br>&gt;&gt;&gt;&gt;&gt; point<br>&gt;&gt;&gt;&gt;&gt; clearer:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I got your idea. Although I don&#39;t know if it is easy to implement in<br>&gt;&gt;&gt;&gt; compiler/parser, I know that it is hard to find such symbols (as<br>&gt;&gt;&gt;&gt; replacement of parentheses) that will be easy to type on keyboard. Don&#39;t<br>&gt;&gt;&gt;&gt; you really propose to type unicode chars like ⊂ ? I believe no.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; &lt;&gt; - used for generics<br>&gt;&gt;&gt;&gt; {} - for code blocks<br>&gt;&gt;&gt;&gt; [] - for subscripts/arrays/dicts<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; what I can think of is vertical bar | symbol as parentheses for tuples:<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; var x = |5,5|<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; func foo(tuple: |Int,Int,String|) {..}<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; (|Int,Int|)-&gt;Int<br>&gt;&gt;&gt;&gt; (|Int,Int|)-&gt;|String, String|<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; ((Int) -&gt; Int)?  -- optional function<br>&gt;&gt;&gt;&gt; |(Int) -&gt; Int|?  -- optional tuple<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; I feel like such syntax for tuples more clearly separates tuple<br>&gt;&gt;&gt;&gt; declaration from other parts of code.<br>&gt;&gt;&gt;&gt; Don&#39;t know if that makes sense :-)<br>&gt;&gt;&gt;&gt; And not sure if we really needs one-element tuple even if we can<br>&gt;&gt;&gt;&gt; clearly parse it in source.<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt; Btw, parentheses are required for argument list in function type now,<br>&gt;&gt;&gt;&gt; so we can&#39;t write `Int -&gt; Int`, but only as `(Int) -&gt; Int`, and not `(Int<br>&gt;&gt;&gt;&gt; -&gt; Int)?` but as `((Int) -&gt; Int)?`<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Might it be that some of the confusion regarding the evolution<br>&gt;&gt;&gt;&gt;&gt; (design/redesign) of tuples, parameter lists, etc. stems from the fact<br>&gt;&gt;&gt;&gt;&gt; that<br>&gt;&gt;&gt;&gt;&gt; they all use parentheses? Or put differently: Parentheses, being used<br>&gt;&gt;&gt;&gt;&gt; for<br>&gt;&gt;&gt;&gt;&gt; so many different (and similar) things, is perhaps blurring the &quot;real&quot;<br>&gt;&gt;&gt;&gt;&gt; (possibly simpler) similarities and differences.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;m not saying they should not all use parentheses in the final<br>&gt;&gt;&gt;&gt;&gt; design, I&#39;m<br>&gt;&gt;&gt;&gt;&gt; only saying that perhaps it is making it harder to think clearly about<br>&gt;&gt;&gt;&gt;&gt; these things (while designing  the language).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Let&#39;s say we carry out a thought-experiment in which we assume<br>&gt;&gt;&gt;&gt;&gt; that argument and parameter lists use eg ≪≫ and tuples use eg ⊂⊃, and<br>&gt;&gt;&gt;&gt;&gt; normal parentheses are _only_ used for grouping and controlling<br>&gt;&gt;&gt;&gt;&gt; priority in<br>&gt;&gt;&gt;&gt;&gt; eg mathematical expressions, but not when creating tuples, parameter<br>&gt;&gt;&gt;&gt;&gt; lists,<br>&gt;&gt;&gt;&gt;&gt; pattern matching and closure types.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Using this notation (which is just a thinking-tool, not meant as a<br>&gt;&gt;&gt;&gt;&gt; final<br>&gt;&gt;&gt;&gt;&gt; syntax), and reimagining these things from scratch, we could for<br>&gt;&gt;&gt;&gt;&gt; example<br>&gt;&gt;&gt;&gt;&gt; try and see what happens if we assume that these are three _different_<br>&gt;&gt;&gt;&gt;&gt; types:<br>&gt;&gt;&gt;&gt;&gt; Int<br>&gt;&gt;&gt;&gt;&gt; ⊂Int ⊃<br>&gt;&gt;&gt;&gt;&gt; ⊂⊂ Int ⊃⊃<br>&gt;&gt;&gt;&gt;&gt; and also, for example, that it is ok to have single element tuples<br>&gt;&gt;&gt;&gt;&gt; with an<br>&gt;&gt;&gt;&gt;&gt; element label.<br>&gt;&gt;&gt;&gt;&gt; And:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ((-1) * ((x + y) + (3 * y))) // Still OK. Redundant parens are treated<br>&gt;&gt;&gt;&gt;&gt; as<br>&gt;&gt;&gt;&gt;&gt; usual / as before.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ⊂ String, Int ⊃ // Two element tuple type whose elements are a String<br>&gt;&gt;&gt;&gt;&gt; and<br>&gt;&gt;&gt;&gt;&gt; an Int.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ⊂ Int ⊃ // Single element Tuple type.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ⊂⊂ Int ⊃⊃ // Single element Tuple type whose only element is another<br>&gt;&gt;&gt;&gt;&gt; single<br>&gt;&gt;&gt;&gt;&gt; element tuple type whose only element is an Int.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ≪ Int ≫ -&gt; Int // Function type from Int to Int.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Perhaps the ≪≫ would prove to be unnecessary, so:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; Int -&gt; Int // Function type from Int to Int.<br>&gt;&gt;&gt;&gt;&gt; (Int -&gt; Int)? // Optional function type from Int to Int.<br>&gt;&gt;&gt;&gt;&gt; ((((Int -&gt; Int))))? // Optional function type from Int to Int.<br>&gt;&gt;&gt;&gt;&gt; (remember<br>&gt;&gt;&gt;&gt;&gt; parens are _only_ used for grouping this way)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ⊂ Int, Int, Int ⊃ -&gt; Int // Function type from a 3-Int-tuple to an Int.<br>&gt;&gt;&gt;&gt;&gt; ⊂⊂ Int, Int, Int ⊃⊃ -&gt; Int // Function type from a single element tuple<br>&gt;&gt;&gt;&gt;&gt; whose element is a 3-Int-tuple to an Int. (Yes, nobody would probably<br>&gt;&gt;&gt;&gt;&gt; write<br>&gt;&gt;&gt;&gt;&gt; a function of such a type, but allowing it could perhaps make the<br>&gt;&gt;&gt;&gt;&gt; rules a<br>&gt;&gt;&gt;&gt;&gt; lot simpler.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; ... Well, I think you get the idea.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; I&#39;m wondering if there has been any attempts at such from-the-scratch<br>&gt;&gt;&gt;&gt;&gt; redesigns of all these parentheses-related-things in the language<br>&gt;&gt;&gt;&gt;&gt; (including eg pattern matching, associated values and more).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; On Wed, Jul 6, 2016 at 8:10 PM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     On 06.07.2016 20:51, Joe Groff wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             On Jul 6, 2016, at 7:47 AM, Vladimir.S via swift-evolution<br>&gt;&gt;&gt;&gt;&gt;             &lt;swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             On 06.07.2016 3:57, Jens Persson via swift-evolution wrote:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 Please feel free to ignore this naive attempt to<br>&gt;&gt;&gt;&gt;&gt; engage in<br>&gt;&gt;&gt;&gt;&gt;                 this discussion.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 My understanding of the history of Swift&#39;s tuples,<br>&gt;&gt;&gt;&gt;&gt; argument<br>&gt;&gt;&gt;&gt;&gt;                 lists, pattern<br>&gt;&gt;&gt;&gt;&gt;                 matching, associated values, etc. in two steps:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 1. Initial Idealism *:<br>&gt;&gt;&gt;&gt;&gt;                 Simple powerful heavily reused general concept.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 2. Iterative pragmatism / reality *:<br>&gt;&gt;&gt;&gt;&gt;                 Complicated (exceptions to) rules.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 (* Inevitably not taking everything in to account.)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 Has there been any recent attempts to outline a more or<br>&gt;&gt;&gt;&gt;&gt;                 less complete<br>&gt;&gt;&gt;&gt;&gt;                 redesign for these things, returning to step 1 so to<br>&gt;&gt;&gt;&gt;&gt; speak,<br>&gt;&gt;&gt;&gt;&gt;                 but taking into<br>&gt;&gt;&gt;&gt;&gt;                 account what has now been learned?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 As a side note (and supposedly trivial to most but me):<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 Parentheses (parenthesized expressions in the<br>&gt;&gt;&gt;&gt;&gt; grammar?) are<br>&gt;&gt;&gt;&gt;&gt;                 used for all of<br>&gt;&gt;&gt;&gt;&gt;                 these parts of the language, and they probably should<br>&gt;&gt;&gt;&gt;&gt; be,<br>&gt;&gt;&gt;&gt;&gt;                 but perhaps the<br>&gt;&gt;&gt;&gt;&gt;                 similarities and differences between the language<br>&gt;&gt;&gt;&gt;&gt;                 constructs can be made<br>&gt;&gt;&gt;&gt;&gt;                 clearer to see by pretending that argument and<br>&gt;&gt;&gt;&gt;&gt; parameter<br>&gt;&gt;&gt;&gt;&gt;                 lists are written<br>&gt;&gt;&gt;&gt;&gt;                 with eg ≪≫ and tuples with eg ⊂⊃, etc.?<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 For example, I think most people agree that we should<br>&gt;&gt;&gt;&gt;&gt; be<br>&gt;&gt;&gt;&gt;&gt;                 able to use<br>&gt;&gt;&gt;&gt;&gt;                 &quot;sloppy/forgiving&quot; parenthetical grouping in code such<br>&gt;&gt;&gt;&gt;&gt; as:<br>&gt;&gt;&gt;&gt;&gt;                 ((1 + (2 * 3)) * (x + (-5))) - y<br>&gt;&gt;&gt;&gt;&gt;                 This is fine and can be used to express meaning for<br>&gt;&gt;&gt;&gt;&gt; the person<br>&gt;&gt;&gt;&gt;&gt;                 reading/writing, even though it means that some of the<br>&gt;&gt;&gt;&gt;&gt;                 parens can become<br>&gt;&gt;&gt;&gt;&gt;                 superfluous to a machine interpretation.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 AFAICS this need not have anything to do with tuples<br>&gt;&gt;&gt;&gt;&gt; and/or<br>&gt;&gt;&gt;&gt;&gt;                 parameter<br>&gt;&gt;&gt;&gt;&gt;                 lists, but the fact that Swift is treating eg:<br>&gt;&gt;&gt;&gt;&gt;                 func foo(x: ((((Int))))) { print(x) }<br>&gt;&gt;&gt;&gt;&gt;                 as<br>&gt;&gt;&gt;&gt;&gt;                 func foo(x: Int) { print(x) }<br>&gt;&gt;&gt;&gt;&gt;                 and<br>&gt;&gt;&gt;&gt;&gt;                 ((Int, Int))<br>&gt;&gt;&gt;&gt;&gt;                 as<br>&gt;&gt;&gt;&gt;&gt;                 (Int, Int)<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             If SE-0110 will be accepted, ((Int, Int)) will mean &quot;1<br>&gt;&gt;&gt;&gt;&gt; tuple<br>&gt;&gt;&gt;&gt;&gt;             with Int,Int fields&quot; and (Int, Int) will mean only &quot;list<br>&gt;&gt;&gt;&gt;&gt; of two<br>&gt;&gt;&gt;&gt;&gt;             Ints in parameters&quot;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         ((Int, Int)) would still be equivalent to (Int, Int). SE-0110<br>&gt;&gt;&gt;&gt;&gt; only<br>&gt;&gt;&gt;&gt;&gt;         concerns parameter lists in function types.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Yes, I&#39;m talking about parameter list in function. Perhaps I&#39;m<br>&gt;&gt;&gt;&gt;&gt; missing<br>&gt;&gt;&gt;&gt;&gt;     something... Quotation from proposal:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;&gt;&gt;&gt;     To declare a function type with one tuple parameter containing n<br>&gt;&gt;&gt;&gt;&gt;     elements (where n &gt; 1), the function type&#39;s argument list must be<br>&gt;&gt;&gt;&gt;&gt;     enclosed by double parentheses:<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     let a : ((Int, Int, Int)) -&gt; Int = { x in return x.0 + x.1 + x.2 }<br>&gt;&gt;&gt;&gt;&gt;     &gt;----------------&lt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     Oh... Or do you(and Jens) mean that this:<br>&gt;&gt;&gt;&gt;&gt;     let x : (Int, Int) = (1,2)<br>&gt;&gt;&gt;&gt;&gt;     will be the same as this:<br>&gt;&gt;&gt;&gt;&gt;     let x : ((Int, Int)) = (1,2)<br>&gt;&gt;&gt;&gt;&gt;     ? and about<br>&gt;&gt;&gt;&gt;&gt;     func foo(_ x: ((Int, Int))) { print(x) }<br>&gt;&gt;&gt;&gt;&gt;     vs<br>&gt;&gt;&gt;&gt;&gt;     func foo(_ x: (Int, Int)) { print(x) }<br>&gt;&gt;&gt;&gt;&gt;     ?<br>&gt;&gt;&gt;&gt;&gt;     In this case yes, sorry for misunderstanding, SE-0110 will not<br>&gt;&gt;&gt;&gt;&gt; change<br>&gt;&gt;&gt;&gt;&gt;     this. I don&#39;t see any ambiguity here: foo will be called as<br>&gt;&gt;&gt;&gt;&gt;     foo((1,2)) - clearly that tuple is sent as argument.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;         -Joe<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 seems to suggest that it somehow does.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 Or maybe I have just forgotten the reasons for why<br>&gt;&gt;&gt;&gt;&gt; there<br>&gt;&gt;&gt;&gt;&gt;                 can be no such<br>&gt;&gt;&gt;&gt;&gt;                 thing as (a nested) single element tuple (type).<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 I also can&#39;t remember what the pros &amp; cons of<br>&gt;&gt;&gt;&gt;&gt; disallowing<br>&gt;&gt;&gt;&gt;&gt;                 labeled single<br>&gt;&gt;&gt;&gt;&gt;                 element tuples were.<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 Happy to be corrected and pointed to relevant reading<br>&gt;&gt;&gt;&gt;&gt; : )<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 /Jens<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;                 _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;                 swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;                 swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;             _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;             swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;             swift-evolution at swift.org &lt;mailto:<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;             https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;     _______________________________________________<br>&gt;&gt;&gt;&gt;&gt;     swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt;     swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt;&gt;     https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt; --<br>&gt;&gt;&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt;&gt;&gt; E-mail: jens at bitcycle.com &lt;mailto:jens at bitcycle.com&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; --<br>&gt;&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; --<br>&gt;&gt; bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>&gt;&gt; http://www.bitcycle.com/<br>&gt;&gt; Phone: +46-73-753 24 62<br>&gt;&gt; E-mail: jens at bitcycle.com<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br></p><p><br>-- <br>bitCycle AB | Smedjegatan 12 | 742 32 Östhammar | Sweden<br>http://www.bitcycle.com/<br>Phone: +46-73-753 24 62<br>E-mail: jens at bitcycle.com<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160708/391aedfa/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
