<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>May  3, 2016 at 08:00:00pm</p></header><div class="content"><p>Hello Swift community,<br></p><p>The review of &quot;SE-0073: Marking closures as executing exactly once&quot; begins now and runs through May 9. The proposal is available here:<br></p><p>	https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br></p><p>Reviews are an important part of the Swift evolution process. All reviews should be sent to the swift-evolution mailing list at<br></p><p>	https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>or, if you would like to keep your feedback private, directly to the review manager.<br></p><p>What goes into a review?<br></p><p>The goal of the review process is to improve the proposal under review through constructive criticism and contribute to the direction of Swift. When writing your review, here are some questions you might want to answer in your review:<br></p><p>	* What is your evaluation of the proposal?<br>	* Is the problem being addressed significant enough to warrant a change to Swift?<br>	* Does this proposal fit well with the feel and direction of Swift?<br>	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>More information about the Swift evolution process is available at<br></p><p>	https://github.com/apple/swift-evolution/blob/master/process.md<br></p><p>Thank you,<br></p><p>-Chris Lattner<br>Review Manager<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May  4, 2016 at 09:00:00am</p></header><div class="content"><p>Here&#39;s my review of &quot;SE-0073 &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md&gt;: Marking closures as executing exactly once&quot;.<br></p><p>&gt; What is your evaluation of the proposal?<br></p><p>+1. I think this is a good idea and should be accepted (without extending the proposed scope).<br></p><p>However, I think the proposal should be more explicit about the case when (and whether) the block itself throws. Specifically, I think we should highlight that the criterion that<br></p><p>&gt; it must not be executed on any path that throws<br></p><p><br>implies that a @noescape(once) parameter itself cannot throw (until another language change allows otherwise). Consider this use case:<br></p><p>    final class Database {<br>      final class Transaction { ... }<br>      // Not allowed by SE-0073:<br>      func transact(_ apply: @noescape(once) (Transaction) throws -&gt; ()) rethrows<br>    }<br></p><p>    func incrementScore(db: Database, game: String) throws -&gt; Int {<br>      let oldScore: Int<br>      // This use of &quot;@noescape(once) ... throws&quot; *could* be ok if the error was<br>      // unconditionally propagated out of the scope of uninitialised variables:<br>      try db.transact { tx in<br>        oldScore = try tx.read(key: &quot;\(game).score&quot;)<br>        try tx.update(key: &quot;\(game).score&quot;, value: oldScore + 1)<br>        try tx.update(key: &quot;\(game).updatedAt&quot;, value: NSDate())<br>      }<br>      return oldScore<br>    }<br></p><p>Being able to throw out of a @noescape(once) block would be useful in cases like this, as it would naturally allow rolling back a transaction. But it would complicate the language by requiring that no one catches the error in the scope where uninitialised variables are defined. I suggest adding this remark to the Future directions.<br></p><p>&gt; Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes. I&#39;m looking forward to being able to initialise immutable variables in dispatch_sync blocks and such without needing to resort to defining them as `var`.<br></p><p>&gt; Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes it does, it aligns nicely with the trailing closure syntax that allows for the emulation of control flow constructs with library code. And as we know, the control flow constructs already allow the delayed initialisation of local variables.<br></p><p>&gt; If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>With a similar feature, I have only used languages (in the sense of &quot;used in anger&quot;) where the delayed initialisation is allowed by allowing an undefined state (e.g. C++). For a not-really-applicable-to-Swift alternative approach, Haskell&#39;s laziness allows the recursive definition of variables for a similar effect.<br></p><p>Finally, I think it&#39;s interesting that the requirement for @noescape(once) arguments to be unconditionally executed has a similarity to linear type systems (Wikipedia &lt;https://en.wikipedia.org/wiki/Substructural_type_system&gt;) and uniqueness or references. Except in this case, the reference is not to an object but a function. Such a function reference bears a certain similarity to the deinit of a uniquely held object. I think the proposed feature may later merge with a bigger language update that brings reference uniqueness to the type system.<br></p><p>&gt; How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p><br>Between quick reading and in-depth study.<br></p><p>— Pyry<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/9ba04e7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 4 mai 2016 à 08:28, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; Here&#39;s my review of &quot;SE-0073: Marking closures as executing exactly once&quot;.<br>&gt; <br>&gt;&gt; What is your evaluation of the proposal?<br>&gt; <br>&gt; +1. I think this is a good idea and should be accepted (without extending the proposed scope).<br>&gt; <br>&gt; However, I think the proposal should be more explicit about the case when (and whether) the block itself throws. Specifically, I think we should highlight that the criterion that<br>&gt; <br>&gt;&gt; it must not be executed on any path that throws<br>&gt; <br>&gt; implies that a @noescape(once) parameter itself cannot throw (until another language change allows otherwise).<br>&gt; <br>&gt; […]<br>&gt; <br>&gt; Being able to throw out of a @noescape(once) block […] would complicate the language by requiring that no one catches the error in the scope where uninitialised variables are defined. I suggest adding this remark to the Future directions.<br></p><p>Hello Pyry,<br></p><p>I quite expect being able to throw out of a @noescape(once) block. Maybe the sentence &quot;it must not be executed on any path that throws&quot; should be removed from the proposal, should it have the implications you describe.<br></p><p>Here is below what I expect this proposal to allow. So you see one problematic case?<br></p><p>	// Function which rethrows closure errors:<br>	func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>		try closure()<br>	}<br></p><p>	// Function which may throw before, inside, or after the closure:<br>	func f2(closure: @noescape(once) () throws -&gt; ()) throws {<br>		try mayFailBefore()<br>		try closure()<br>		try mayFailAfter()<br>	}<br>	<br>	// Support function<br>	func getX() throws -&gt; Int { return 1 }<br>	<br>Case 1:<br></p><p>	let x: Int<br>	f1 {<br>		x = 1<br>		// use x<br>	}<br>	// use x<br>	<br>Case 2:<br></p><p>	let x: Int<br>	do {<br>		try f1 {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		// can&#39;t use x<br>	}<br>	// can&#39;t use x<br>	<br>Case 3:<br></p><p>	let x: Int<br>	do {<br>		try f1 {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		x = 1<br>	}<br>	// use x<br>	<br>Case 4:<br></p><p>	let x: Int<br>	do {<br>		try f2 {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		// can&#39;t use x<br>	}<br>	// can&#39;t use x<br></p><p>Case 5:<br></p><p>	let x: Int<br>	do {<br>		try f2 {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		x = 1<br>	}<br>	// use x<br></p><p>Gwendal Roué<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May  4, 2016 at 12:00:00pm</p></header><div class="content"><p>Hi Gwendal,<br></p><p>Nice writeup. So I see that you recognise how this extra specification will complicate (while also facilitate) things. And I also see that you&#39;re a co-author of the proposal. So I&#39;m more than happy if you can squeeze this extra into it.<br></p><p>However reading your example code, I had to squint to see—without the compiler&#39;s squiggly red aid—what all the problematic cases are.<br></p><p>1) Is it obvious to everybody why you can&#39;t always use `x` in the end of Cases 2 and 4? For example, with `if—else` you MUST initialise the variable or escape its scope in all branches; you can&#39;t just write the following to complete the initialisation later:<br></p><p>    let x: Int<br>    if cond { x = 1 }<br>    // ...<br>    if !cond { x = 2 } // too late!<br></p><p>2) Should Cases 2 and 4 be made illegal? The requirement could then be that all `catch` blocks either:<br>2.a) initialise another value for `x`, or<br>2.b) escape the scope using `throw`, `return`, `fatalError`, whatnot…<br></p><p>3) If you consider including this addition to the proposal, it might also help other reviewers if you explained how the compiler will be able to help the programmer write a valid program. E.g. what would the error messages about partially initialised variables look like? And where and when would they appear? Could the compiler suggest certain fixits? Etc.<br></p><p>So, I&#39;m all +1 and very glad if you can make it! (But also somewhat sceptical whether it could get accepted.)<br></p><p>— Pyry<br></p><p>&gt; On 04 May 2016, at 12:24, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt; <br>&gt; I quite expect being able to throw out of a @noescape(once) block. Maybe the sentence &quot;it must not be executed on any path that throws&quot; should be removed from the proposal, should it have the implications you describe.<br>&gt; <br>&gt; Here is below what I expect this proposal to allow. So you see one problematic case?<br>&gt; <br>&gt; 	// Function which rethrows closure errors:<br>&gt; 	func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>&gt; 		try closure()<br>&gt; 	}<br>&gt; <br>&gt; 	// Function which may throw before, inside, or after the closure:<br>&gt; 	func f2(closure: @noescape(once) () throws -&gt; ()) throws {<br>&gt; 		try mayFailBefore()<br>&gt; 		try closure()<br>&gt; 		try mayFailAfter()<br>&gt; 	}<br>&gt; 	<br>&gt; 	// Support function<br>&gt; 	func getX() throws -&gt; Int { return 1 }<br>&gt; 	<br>&gt; Case 1:<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	f1 {<br>&gt; 		x = 1<br>&gt; 		// use x<br>&gt; 	}<br>&gt; 	// use x<br>&gt; 	<br>&gt; Case 2:<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	do {<br>&gt; 		try f1 {<br>&gt; 			x = try getX()<br>&gt; 			// use x<br>&gt; 		}<br>&gt; 		// use x<br>&gt; 	} catch {<br>&gt; 		// can&#39;t use x<br>&gt; 	}<br>&gt; 	// can&#39;t use x<br>&gt; 	<br>&gt; Case 3:<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	do {<br>&gt; 		try f1 {<br>&gt; 			x = try getX()<br>&gt; 			// use x<br>&gt; 		}<br>&gt; 		// use x<br>&gt; 	} catch {<br>&gt; 		x = 1<br>&gt; 	}<br>&gt; 	// use x<br>&gt; 	<br>&gt; Case 4:<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	do {<br>&gt; 		try f2 {<br>&gt; 			x = try getX()<br>&gt; 			// use x<br>&gt; 		}<br>&gt; 		// use x<br>&gt; 	} catch {<br>&gt; 		// can&#39;t use x<br>&gt; 	}<br>&gt; 	// can&#39;t use x<br>&gt; <br>&gt; Case 5:<br>&gt; <br>&gt; 	let x: Int<br>&gt; 	do {<br>&gt; 		try f2 {<br>&gt; 			x = try getX()<br>&gt; 			// use x<br>&gt; 		}<br>&gt; 		// use x<br>&gt; 	} catch {<br>&gt; 		x = 1<br>&gt; 	}<br>&gt; 	// use x<br>&gt; <br>&gt; Gwendal Roué<br>&gt; <br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160504/f7fdacf5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; Le 4 mai 2016 à 11:55, Pyry Jahkola &lt;pyry.jahkola at iki.fi&gt; a écrit :<br>&gt; <br>&gt; Hi Gwendal,<br>&gt; <br>&gt; Nice writeup. So I see that you recognise how this extra specification will complicate (while also facilitate) things. And I also see that you&#39;re a co-author of the proposal. So I&#39;m more than happy if you can squeeze this extra into it.<br>&gt; <br>&gt; However reading your example code, I had to squint to see—without the compiler&#39;s squiggly red aid—what all the problematic cases are.<br>&gt; <br>&gt; 1) Is it obvious to everybody why you can&#39;t always use `x` in the end of Cases 2 and 4? For example, with `if—else` you MUST initialise the variable or escape its scope in all branches; you can&#39;t just write the following to complete the initialisation later:<br>&gt; <br>&gt;     let x: Int<br>&gt;     if cond { x = 1 }<br>&gt;     // ...<br>&gt;     if !cond { x = 2 } // too late!<br>&gt; 2) Should Cases 2 and 4 be made illegal? The requirement could then be that all `catch` blocks either:<br></p><p>Hello Pyry,<br></p><p>In case 2 and 4, you can&#39;t always use `x` at the end because there are code paths that do not initialize x.<br></p><p>Let&#39;s repeat the case 2 and 4, as a reminder:<br></p><p>Case 2:<br></p><p>	// Function which rethrows closure errors:<br>	func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>		try closure()<br>	}<br>	let x: Int<br>	do {<br>		try f1 {			<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		// can&#39;t use x<br>	}<br>	// can&#39;t use x<br></p><p>Case 4:<br></p><p>	// Function which may throw before, inside, or after the closure:<br>	func f2(closure: @noescape(once) () throws -&gt; ()) throws {<br>		try mayFailBefore()<br>		try closure()<br>		try mayFailAfter()<br>	}<br>	let x: Int<br>	do {<br>		try f2 {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		// can&#39;t use x<br>	}<br>	// can&#39;t use x<br></p><p>To better explain them, let&#39;s replace `f1` with `do`, and `f2` with a throwing function followed with do:<br></p><p>Rewritten case 2:<br></p><p>	let x: Int<br>	do {<br>		do {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		// can&#39;t use x<br>	}<br>	// can&#39;t use x<br></p><p>Rewritten case 4:<br></p><p>	let x: Int<br>	do {<br>		try mayFail()<br>		do {<br>			x = try getX()<br>			// use x<br>		}<br>		// use x<br>	} catch {<br>		// can&#39;t use x<br>	}<br>	// can&#39;t use x<br></p><p>The examples above are already the behavior of the Swift compiler. I expect @noescape(once) closures to behave the same (the cases 2 and 4 above)<br></p><p>&gt; 3) If you consider including this addition to the proposal, it might also help other reviewers if you explained how the compiler will be able to help the programmer write a valid program. E.g. what would the error messages about partially initialised variables look like? And where and when would they appear? Could the compiler suggest certain fixits? Etc.<br></p><p>For error messages about partially initialized variables, we just use the regular messages that we already have: `Constant &#39;x&#39; used before being initialized` error.<br></p><p>Gwendal Roué<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/c1fe79fd/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  4, 2016 at 10:00:00am</p></header><div class="content"><p>On Wed, May 4, 2016 at 2:24 AM, Gwendal Roué &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Le 4 mai 2016 à 08:28, Pyry Jahkola via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt; Here&#39;s my review of &quot;SE-0073: Marking closures as executing exactly once&quot;.<br>&gt;&gt;<br>&gt;&gt;&gt; What is your evaluation of the proposal?<br>&gt;&gt;<br>&gt;&gt; +1. I think this is a good idea and should be accepted (without extending the proposed scope).<br>&gt;&gt;<br>&gt;&gt; However, I think the proposal should be more explicit about the case when (and whether) the block itself throws. Specifically, I think we should highlight that the criterion that<br>&gt;&gt;<br>&gt;&gt;&gt; it must not be executed on any path that throws<br>&gt;&gt;<br>&gt;&gt; implies that a @noescape(once) parameter itself cannot throw (until another language change allows otherwise).<br>&gt;&gt;<br>&gt;&gt; […]<br>&gt;&gt;<br>&gt;&gt; Being able to throw out of a @noescape(once) block […] would complicate the language by requiring that no one catches the error in the scope where uninitialised variables are defined. I suggest adding this remark to the Future directions.<br>&gt;<br>&gt; Hello Pyry,<br>&gt;<br>&gt; I quite expect being able to throw out of a @noescape(once) block. Maybe the sentence &quot;it must not be executed on any path that throws&quot; should be removed from the proposal, should it have the implications you describe.<br>&gt;<br>&gt; Here is below what I expect this proposal to allow. So you see one problematic case?<br></p><p>Hi Gwendal,<br></p><p>What about the following case?<br></p><p>// Function which rethrows closure errors:<br>func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>  try closure()<br>}<br></p><p>let x: AnyObject<br>f1 {<br>  if someCondition() { x = MyClass() }<br>  if someOtherCondition() { throw MyError.Error() }<br>  x = MyOtherClass()<br>}<br></p><p>How do you handle memory management for &#39;x&#39; on the path that throws?<br>If the rule is that upon returning from f1 via a throw the variable<br>&#39;x&#39; should not be initialized, then the closure passed to f1 has to<br>guarantee the deinitialization.  But f1 accepts an arbitrary closure.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May  5, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt;&gt; I quite expect being able to throw out of a @noescape(once) block. Maybe the sentence &quot;it must not be executed on any path that throws&quot; should be removed from the proposal, should it have the implications you describe.<br>&gt;&gt; <br>&gt;&gt; Here is below what I expect this proposal to allow. So you see one problematic case?<br>&gt; <br>&gt; Hi Gwendal,<br>&gt; <br>&gt; What about the following case?<br>&gt; <br>&gt; // Function which rethrows closure errors:<br>&gt; func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>&gt;  try closure()<br>&gt; }<br>&gt; <br>&gt; let x: AnyObject<br>&gt; f1 {<br>&gt;  if someCondition() { x = MyClass() }<br>&gt;  if someOtherCondition() { throw MyError.Error() }<br>&gt;  x = MyOtherClass()<br>&gt; }<br>&gt; <br>&gt; How do you handle memory management for &#39;x&#39; on the path that throws?<br>&gt; If the rule is that upon returning from f1 via a throw the variable<br>&gt; &#39;x&#39; should not be initialized, then the closure passed to f1 has to<br>&gt; guarantee the deinitialization.  But f1 accepts an arbitrary closure.<br></p><p>Hello Dmitri,<br></p><p>To reason about @noescape(once) functions, the easiest way is to replace them with `do`:<br></p><p>    let x: AnyObject<br>    do {<br>        if someCondition() { x = MyClass() }<br>        if someOtherCondition() { throw MyError.error }<br>        x = MyOtherClass()<br>    }<br></p><p>This code does not compile because x can&#39;t be initialized to MyOtherClass().<br></p><p>But I don&#39;t think this is your point. Your point was &quot;how can the compiler handle memory management ?&quot;.<br></p><p>I can&#39;t answer this question, because I&#39;m not competent enough. But if it can handle the do { … } case, can&#39;t it also handle the f { … } case?<br></p><p>Gwendal Roué<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>May  5, 2016 at 09:00:00am</p></header><div class="content"><p>On Thu, May 5, 2016 at 3:27 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;&gt;&gt; I quite expect being able to throw out of a @noescape(once) block. Maybe the sentence &quot;it must not be executed on any path that throws&quot; should be removed from the proposal, should it have the implications you describe.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Here is below what I expect this proposal to allow. So you see one problematic case?<br>&gt;&gt;<br>&gt;&gt; Hi Gwendal,<br>&gt;&gt;<br>&gt;&gt; What about the following case?<br>&gt;&gt;<br>&gt;&gt; // Function which rethrows closure errors:<br>&gt;&gt; func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>&gt;&gt;  try closure()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; let x: AnyObject<br>&gt;&gt; f1 {<br>&gt;&gt;  if someCondition() { x = MyClass() }<br>&gt;&gt;  if someOtherCondition() { throw MyError.Error() }<br>&gt;&gt;  x = MyOtherClass()<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; How do you handle memory management for &#39;x&#39; on the path that throws?<br>&gt;&gt; If the rule is that upon returning from f1 via a throw the variable<br>&gt;&gt; &#39;x&#39; should not be initialized, then the closure passed to f1 has to<br>&gt;&gt; guarantee the deinitialization.  But f1 accepts an arbitrary closure.<br>&gt;<br>&gt; Hello Dmitri,<br>&gt;<br>&gt; To reason about @noescape(once) functions, the easiest way is to replace them with `do`:<br>&gt;<br>&gt;     let x: AnyObject<br>&gt;     do {<br>&gt;         if someCondition() { x = MyClass() }<br>&gt;         if someOtherCondition() { throw MyError.error }<br>&gt;         x = MyOtherClass()<br>&gt;     }<br>&gt;<br>&gt; This code does not compile because x can&#39;t be initialized to MyOtherClass().<br>&gt;<br>&gt; But I don&#39;t think this is your point. Your point was &quot;how can the compiler handle memory management ?&quot;.<br>&gt;<br>&gt; I can&#39;t answer this question, because I&#39;m not competent enough. But if it can handle the do { … } case, can&#39;t it also handle the f { … } case?<br></p><p>The difference is that the do{} case is type checked and codegen&#39;ed<br>together with the rest of the function.  The f{} case has two<br>functions that are type checked and codegen&#39;ed more or less<br>separately (the function that contains the call to f, and the closure<br>itself).  Moreover, with do{} the placement of the code block is<br>fixed.  With f{}, you can save a closure in a variable and then call<br>f(myClosure).  How would that affect the rules?  How would you<br>implement the desired analysis?<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a06dd7924588141b9c907543798c2524?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Gwendal Roué</string> &lt;gwendal.roue at gmail.com&gt;<p>May  5, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Le 5 mai 2016 à 18:16, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; a écrit :<br>&gt; <br>&gt; On Thu, May 5, 2016 at 3:27 AM, Gwendal Roué &lt;gwendal.roue at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; I quite expect being able to throw out of a @noescape(once) block. Maybe the sentence &quot;it must not be executed on any path that throws&quot; should be removed from the proposal, should it have the implications you describe.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Here is below what I expect this proposal to allow. So you see one problematic case?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Hi Gwendal,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about the following case?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // Function which rethrows closure errors:<br>&gt;&gt;&gt; func f1(closure: @noescape(once) () throws -&gt; ()) rethrows {<br>&gt;&gt;&gt; try closure()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; let x: AnyObject<br>&gt;&gt;&gt; f1 {<br>&gt;&gt;&gt; if someCondition() { x = MyClass() }<br>&gt;&gt;&gt; if someOtherCondition() { throw MyError.Error() }<br>&gt;&gt;&gt; x = MyOtherClass()<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How do you handle memory management for &#39;x&#39; on the path that throws?<br>&gt;&gt;&gt; If the rule is that upon returning from f1 via a throw the variable<br>&gt;&gt;&gt; &#39;x&#39; should not be initialized, then the closure passed to f1 has to<br>&gt;&gt;&gt; guarantee the deinitialization.  But f1 accepts an arbitrary closure.<br>&gt;&gt; <br>&gt;&gt; Hello Dmitri,<br>&gt;&gt; <br>&gt;&gt; To reason about @noescape(once) functions, the easiest way is to replace them with `do`:<br>&gt;&gt; <br>&gt;&gt;    let x: AnyObject<br>&gt;&gt;    do {<br>&gt;&gt;        if someCondition() { x = MyClass() }<br>&gt;&gt;        if someOtherCondition() { throw MyError.error }<br>&gt;&gt;        x = MyOtherClass()<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt; This code does not compile because x can&#39;t be initialized to MyOtherClass().<br>&gt;&gt; <br>&gt;&gt; But I don&#39;t think this is your point. Your point was &quot;how can the compiler handle memory management ?&quot;.<br>&gt;&gt; <br>&gt;&gt; I can&#39;t answer this question, because I&#39;m not competent enough. But if it can handle the do { … } case, can&#39;t it also handle the f { … } case?<br>&gt; <br>&gt; The difference is that the do{} case is type checked and codegen&#39;ed<br>&gt; together with the rest of the function.  The f{} case has two<br>&gt; functions that are type checked and codegen&#39;ed more or less<br>&gt; separately (the function that contains the call to f, and the closure<br>&gt; itself).  Moreover, with do{} the placement of the code block is<br>&gt; fixed.  With f{}, you can save a closure in a variable and then call<br>&gt; f(myClosure).  How would that affect the rules?  How would you<br>&gt; implement the desired analysis?<br>&gt; <br>&gt; Dmitri<br></p><p>I just have two messages by Chris Lattner who did not seem to foresee any big trouble. Of course this does not mean there aren&#39;t any, even maybe some pretty difficult one. The second message addresses more precisely your memory handling concerns:<br></p><p>- https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008231.html<br>- https://lists.swift.org/pipermail/swift-evolution/Week-of-Mon-20160125/008598.html<br></p><p>Gwendal Roué<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  4, 2016 at 08:00:00am</p></header><div class="content"><p>&gt;    * What is your evaluation of the proposal?<br></p><p>I like the proposal and I think it&#39;s a good idea, but I&#39;m really not sure it is important enough to fix. Looking at the proposals already accepted, half of them are still waiting for an implementation. Several will probably never make it in time for Swift 3. And I don&#39;t feel like the current issue is less important, and will require more implementation effort, than many other issues still waiting for an implementation.<br></p><p>&gt;    * Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>See above, but I think not.<br></p><p>&gt;    * Does this proposal fit well with the feel and direction of Swift?<br></p><p>I does fit well.<br></p><p>&gt;    * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>No.<br></p><p>&gt;    * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>A detailed read of the proposal.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; * What is your evaluation of the proposal?<br></p><p>+1.  I like semantic guarantees provided by the compiler.<br></p><p>&gt; 	* Is the problem being addressed significant enough to warrant a change to Swift?<br></p><p>Yes.<br></p><p>&gt; 	* Does this proposal fit well with the feel and direction of Swift?<br></p><p>Yes.<br></p><p>&gt; 	* If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br></p><p>Not that I can think of.<br></p><p>&gt; 	* How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br></p><p>I participated in the earlier threads, read the proposal thoroughly, and have followed the review closely.<br></p><p>&gt; <br>&gt; More information about the Swift evolution process is available at<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/process.md<br>&gt; <br>&gt; Thank you,<br>&gt; <br>&gt; -Chris Lattner<br>&gt; Review Manager<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f38cb038c3d9ae705c4db3b5b5272906?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Greg Parker</string> &lt;gparker at apple.com&gt;<p>May  6, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; On May 3, 2016, at 8:53 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Hello Swift community,<br>&gt; <br>&gt; The review of &quot;SE-0073: Marking closures as executing exactly once&quot; begins now and runs through May 9. The proposal is available here:<br>&gt; <br>&gt; 	https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br></p><p>&gt; <br>&gt; &quot;A @once parameter<br>&gt; <br>&gt; It was mentioned in the discussion that the &quot;once&quot; behavior and @noescape look orthogonal, and the &quot;once&quot; behavior could be useful on closures that escape. However, it is only possible to verify that a closure has been executed exactly once if it does not escape. Because of this, &quot;once&quot; and @noescape are better left together.&quot;<br></p><p>I dislike the proposed syntax.<br></p><p>noescape-ness and once-ness are semantically orthogonal. The compiler&#39;s ability to verify once-ness depends on noescape and some other semantics all being present, as noted in the above quote from the proposal. The fact that the compiler is limited should not forgive the semantic transgression. Note that semantically the once-ness is the more important part for the designed usage; noescape-ness is only dragged in because of the desire to enforce once-ness at compile time. The @noescape(once) syntax is therefore backwards: the feature is not some small modification to or variation of plain @noescape.<br></p><p>The proposed behavior includes restrictions that are required for its designed usage but are unrelated to noescape-ness and once-ness. (&quot;A @noescape(once) closure may only read from variables that were initialized before it was formed.&quot;) That suggests the proposed functionality should use a new higher-level name rather than being bolted on to @noescape. <br></p><p><br>-- <br>Greg Parker     gparker at apple.com     Runtime Wrangler<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0073: Marking closures as executing exactly once</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May  7, 2016 at 11:00:00am</p></header><div class="content"><p>Agreed.<br></p><p>I think you bring up points that articulate well my issues with this proposal.<br></p><p>&gt; On 7 May 2016, at 10:31 AM, Greg Parker via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On May 3, 2016, at 8:53 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hello Swift community,<br>&gt;&gt; <br>&gt;&gt; The review of &quot;SE-0073: Marking closures as executing exactly once&quot; begins now and runs through May 9. The proposal is available here:<br>&gt;&gt; <br>&gt;&gt;    https://github.com/apple/swift-evolution/blob/master/proposals/0073-noescape-once.md<br>&gt; <br>&gt;&gt; <br>&gt;&gt; &quot;A @once parameter<br>&gt;&gt; <br>&gt;&gt; It was mentioned in the discussion that the &quot;once&quot; behavior and @noescape look orthogonal, and the &quot;once&quot; behavior could be useful on closures that escape. However, it is only possible to verify that a closure has been executed exactly once if it does not escape. Because of this, &quot;once&quot; and @noescape are better left together.&quot;<br>&gt; <br>&gt; I dislike the proposed syntax.<br>&gt; <br>&gt; noescape-ness and once-ness are semantically orthogonal. The compiler&#39;s ability to verify once-ness depends on noescape and some other semantics all being present, as noted in the above quote from the proposal. The fact that the compiler is limited should not forgive the semantic transgression. Note that semantically the once-ness is the more important part for the designed usage; noescape-ness is only dragged in because of the desire to enforce once-ness at compile time. The @noescape(once) syntax is therefore backwards: the feature is not some small modification to or variation of plain @noescape.<br>&gt; <br>&gt; The proposed behavior includes restrictions that are required for its designed usage but are unrelated to noescape-ness and once-ness. (&quot;A @noescape(once) closure may only read from variables that were initialized before it was formed.&quot;) That suggests the proposed functionality should use a new higher-level name rather than being bolted on to @noescape. <br>&gt; <br>&gt; <br>&gt; -- <br>&gt; Greg Parker     gparker at apple.com     Runtime Wrangler<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
