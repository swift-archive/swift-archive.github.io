<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 24, 2016 at 10:00:00pm</p></header><div class="content"><p>I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br></p><p>More Powerful Constraints for Associated Types<br></p><p>Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br></p><p>This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br></p><p>This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br></p><p>Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br></p><p>protocol Sequence {<br>    associatedtype Iterator : IteratorProtocol<br>    associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>    ...<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br></p><p>With this proposal, the grammar for protocols associated types would be modified to:<br></p><p>protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br></p><p>The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#issues&gt;Issues<br></p><p>Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br></p><p>protocol Collection : Sequence {<br>    where SubSequence : Collection<br>} <br>But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058&gt;. For those reasons, it might be wiser not to introduce the shorthand syntax.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#acknowledgements&gt;Acknowledgements<br></p><p>Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/39bb7ee8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>April 25, 2016 at 12:00:00pm</p></header><div class="content"><p>I&#39;m definitely a supporter of this change. It addresses things I&#39;ve hit multiple times.<br></p><p>&gt; On 25 Apr 2016, at 6:34 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt; <br>&gt; More Powerful Constraints for Associated Types<br>&gt; Proposal: SE-XXXX<br>&gt; Author(s): David Hart<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     ...<br>&gt; }<br>&gt; Detail Design<br>&gt; <br>&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt; <br>&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt; <br>&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt; <br>&gt; Issues<br>&gt; <br>&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt; <br>&gt; protocol Collection : Sequence {<br>&gt;     where SubSequence : Collection<br>&gt; } <br>&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/7e10f1fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 25, 2016 at 07:00:00am</p></header><div class="content"><p>+1<br>I&#39;ve been missing this myself<br></p><p>-Thorsten <br></p><p>&gt; Am 25.04.2016 um 04:15 schrieb Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;m definitely a supporter of this change. It addresses things I&#39;ve hit multiple times.<br>&gt; <br>&gt;&gt; On 25 Apr 2016, at 6:34 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt; <br>&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author(s): David Hart<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt; <br>&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt; <br>&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt; <br>&gt;&gt; Issues<br>&gt;&gt; <br>&gt;&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt;&gt; <br>&gt;&gt; protocol Collection : Sequence {<br>&gt;&gt;     where SubSequence : Collection<br>&gt;&gt; } <br>&gt;&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/a157a9e4/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 25, 2016 at 08:00:00am</p></header><div class="content"><p>I’m a strong +1 for this, although I’m suspicious of the timing as in my current project I could do with this right now ;)<br></p><p>&gt; On 24 Apr 2016, at 21:34, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt; <br>&gt; More Powerful Constraints for Associated Types<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt; Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br>&gt; <br>&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     ...<br>&gt; }<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br>&gt; <br>&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt; <br>&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt; <br>&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#issues&gt;Issues<br>&gt; <br>&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt; <br>&gt; protocol Collection : Sequence {<br>&gt;     where SubSequence : Collection<br>&gt; } <br>&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058&gt;. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt; <br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#acknowledgements&gt;Acknowledgements<br>&gt; <br>&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/5f380248/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 25, 2016 at 01:00:00am</p></header><div class="content"><p>On Sun, Apr 24, 2016 at 1:34 PM, David Hart via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Currently, associated type declarations can only express simple inheritance<br>&gt; constraints and not the more sophisticated constraints available to generic<br>&gt; types with the where expression. Some designs, including many in the<br>&gt; Standard Library, require more powerful constraints for associated types to<br>&gt; be truly elegant. For example, the SequenceType protocol can be declared as<br>&gt; follows:<br></p><p>I completely support this.  This feature will unblock many<br>improvements in the standard library.  Currently users of some<br>protocols have to carry extra constraints in their own type<br>signatures, but we should be able to hoist these constraints into the<br>protocol definiton.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 25, 2016 at 08:00:00am</p></header><div class="content"><p>I really like this proposal.  It is a nice step forward from current state.  <br></p><p>However, it looks like it doesn&#39;t allow us to express constraints that elate two or more associated types together, such as requiring both to have the same Element type.  I think it would be a good idea to solve the general problem of constraining associated types if possible.  The general case is an important part of completing generics IMO so it should be within the scope of Swift 3 to consider it.<br></p><p>Matthew<br></p><p>Sent from my iPad<br></p><p>&gt; On Apr 24, 2016, at 3:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt; <br>&gt; More Powerful Constraints for Associated Types<br>&gt; Proposal: SE-XXXX<br>&gt; Author(s): David Hart<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt; Introduction<br>&gt; <br>&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt; <br>&gt; Motivation<br>&gt; <br>&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     ...<br>&gt; }<br>&gt; Detail Design<br>&gt; <br>&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt; <br>&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt; <br>&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt; <br>&gt; Issues<br>&gt; <br>&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt; <br>&gt; protocol Collection : Sequence {<br>&gt;     where SubSequence : Collection<br>&gt; } <br>&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt; <br>&gt; Acknowledgements<br>&gt; <br>&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/50385883/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Am 25.04.2016 um 15:40 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I really like this proposal.  It is a nice step forward from current state.  <br>&gt; <br>&gt; However, it looks like it doesn&#39;t allow us to express constraints that elate two or more associated types together, such as requiring both to have the same Element type.<br></p><p>Did I miss something? I thought that was the exact example given in the motivation section?<br></p><p>-Thorsten <br></p><p>&gt;  I think it would be a good idea to solve the general problem of constraining associated types if possible.  The general case is an important part of completing generics IMO so it should be within the scope of Swift 3 to consider it.<br>&gt; <br>&gt; Matthew<br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt;&gt; On Apr 24, 2016, at 3:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt; <br>&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt; Author(s): David Hart<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt; Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt; <br>&gt;&gt; Motivation<br>&gt;&gt; <br>&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt; Detail Design<br>&gt;&gt; <br>&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt; <br>&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt; <br>&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt; <br>&gt;&gt; Issues<br>&gt;&gt; <br>&gt;&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt;&gt; <br>&gt;&gt; protocol Collection : Sequence {<br>&gt;&gt;     where SubSequence : Collection<br>&gt;&gt; } <br>&gt;&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt;&gt; <br>&gt;&gt; Acknowledgements<br>&gt;&gt; <br>&gt;&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/21e9c138/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>April 25, 2016 at 10:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On Apr 25, 2016, at 9:58 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; Am 25.04.2016 um 15:40 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; I really like this proposal.  It is a nice step forward from current state.  <br>&gt;&gt; <br>&gt;&gt; However, it looks like it doesn&#39;t allow us to express constraints that elate two or more associated types together, such as requiring both to have the same Element type.<br>&gt; <br>&gt; Did I miss something? I thought that was the exact example given in the motivation section?<br></p><p>You are right.  I&#39;m not sure how I missed that.  I think it is because the constraints are attached to a single associatedtype declaration rather than being at the top level of the protocol declaration. <br></p><p>It feels slightly awkward to have to attach such constraints to one of the associatedtype declarations as they are effectively peers in the same type constraint.  Allowing such constraints to stand alone would look similar to Doug&#39;s example in the issues section.  I would prefer to look for a syntax for generic constraints on declarations that allows for freestanding and refined constraints in protocols.<br></p><p>&gt; <br>&gt; -Thorsten <br>&gt; <br>&gt;&gt;  I think it would be a good idea to solve the general problem of constraining associated types if possible.  The general case is an important part of completing generics IMO so it should be within the scope of Swift 3 to consider it.<br>&gt;&gt; <br>&gt;&gt; Matthew<br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On Apr 24, 2016, at 3:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt; Author(s): David Hart<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Detail Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Issues<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Collection : Sequence {<br>&gt;&gt;&gt;     where SubSequence : Collection<br>&gt;&gt;&gt; } <br>&gt;&gt;&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Acknowledgements<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/ad28c188/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e910871dda004717de19e83626308b5a?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Tony Allevato</string> &lt;allevato at google.com&gt;<p>April 25, 2016 at 04:00:00pm</p></header><div class="content"><p>I really like where this proposal is headed.<br></p><p>Would this syntax also support constraining associated types based on<br>&quot;inheritability&quot; (for lack of a better word)? For example, a couple times<br>I&#39;ve hit a situation where I want to express a supertype/subtype<br>relationship. A contrived example:<br></p><p>protocol Foo {<br>  associatedtype Bar<br></p><p>  func f&lt;Baz: Bar&gt;(b: Baz.Type) -&gt; Baz<br>}<br></p><p>This currently gives me the error &quot;inheritance from non-protocol, non-class<br>type &#39;Self.Bar&#39;.&quot; This makes sense in a way, because a type conforming to<br>Foo could define Bar to be anything, including a struct.<br></p><p>I see a few ways to address this:<br></p><p>(1) Allow users to write &quot;associatedtype Bar: class&quot; to indicate that the<br>conforming class must set Bar to be a class type, which would let the type<br>checker know that the Baz: Bar constraint is valid. This gets us partially<br>there, but is still somewhat limiting because other supertype/subtype<br>relationships could not be expressed, such as Bar being an arbitrary<br>protocol and Baz being any type that conforms to that protocol.<br></p><p>(2) Allow users to write &quot;associatedtype Bar: _____&quot;, where _____ is some<br>way of expressing any arbitrary type that is inheritable: this would<br>include classes but also protocols. The difference here is instead of<br>specifying a specific protocol, conforming types could put any protocol<br>here, binding Bar in function f() to that protocol and then Baz would be<br>any type conforming to Bar.<br></p><p>(3) Allow the syntax above unchanged. If a conforming type defines Bar to<br>be a struct, loosen the check and still allow it such that the only<br>possible type that can satisfy Baz is Bar itself. This would be consistent<br>with other generic constraints that are class-based, where a constraint of<br>the form f&lt;SomeClass: BaseClass&gt; can still satisfy SomeClass by using<br>BaseClass itself.<br></p><p>While writing this, I noticed some other constructs that seem like they<br>should work, but don&#39;t:<br></p><p>protocol SomeProtocol {}<br>protocol Foo {<br>  associatedtype Bar: SomeProtocol<br>  func f&lt;Baz: Bar&gt;(b: Baz.Type) -&gt; Baz<br>  // ^ inheritance from non-protocol, non-class type &#39;Self.Bar&#39;<br>  // Shouldn&#39;t the compiler know that Bar is constrained by a protocol here?<br>}<br></p><p>class SomeClass {}<br>protocol Foo {<br>  associatedtype Bar: SomeClass<br>  func f&lt;Baz: Bar&gt;(b: Baz.Type) -&gt; Baz<br>  // ^ inheritance from non-protocol, non-class type &#39;Self.Bar&#39;<br>  // Same problem as above, essentially.<br>}<br></p><p>protocol A {}<br>protocol B {}<br>protocol Foo {<br>  associatedtype Bar: protocol&lt;A, B&gt;<br>  // ^ This one doesn&#39;t appear to even get past the parser, which is<br>unfortunate.<br>  // To express the notion of an associatedtype conforming to two<br>protocols, you<br>  // have to create a third protocol and extend the type you wish to use to<br>conform<br>  // to that protocol.<br>}<br></p><p>Some of these issues may have been addressed in &quot;Completing generics&quot;, but<br>they seem like they would fit into this proposal as well.<br></p><p>On Mon, Apr 25, 2016 at 8:30 AM Matthew Johnson via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Apr 25, 2016, at 9:58 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; Am 25.04.2016 um 15:40 schrieb Matthew Johnson via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt;:<br>&gt;<br>&gt; I really like this proposal.  It is a nice step forward from current<br>&gt; state.<br>&gt;<br>&gt; However, it looks like it doesn&#39;t allow us to express constraints that<br>&gt; elate two or more associated types together, such as requiring both to have<br>&gt; the same Element type.<br>&gt;<br>&gt;<br>&gt; Did I miss something? I thought that was the exact example given in the<br>&gt; motivation section?<br>&gt;<br>&gt;<br>&gt; You are right.  I&#39;m not sure how I missed that.  I think it is because the<br>&gt; constraints are attached to a single associatedtype declaration rather than<br>&gt; being at the top level of the protocol declaration.<br>&gt;<br>&gt; It feels slightly awkward to have to attach such constraints to one of the<br>&gt; associatedtype declarations as they are effectively peers in the same type<br>&gt; constraint.  Allowing such constraints to stand alone would look similar to<br>&gt; Doug&#39;s example in the issues section.  I would prefer to look for a syntax<br>&gt; for generic constraints on declarations that allows for freestanding and<br>&gt; refined constraints in protocols.<br>&gt;<br>&gt;<br>&gt; -Thorsten<br>&gt;<br>&gt;  I think it would be a good idea to solve the general problem of<br>&gt; constraining associated types if possible.  The general case is an<br>&gt; important part of completing generics IMO so it should be within the scope<br>&gt; of Swift 3 to consider it.<br>&gt;<br>&gt; Matthew<br>&gt;<br>&gt; Sent from my iPad<br>&gt;<br>&gt; On Apr 24, 2016, at 3:34 PM, David Hart via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I wrote the proposal which was discussed to introduce generic constraints<br>&gt; for associated types. I’d like to get some feedback on it and get it ready<br>&gt; before submitting it:<br>&gt;<br>&gt; More Powerful Constraints for Associated Types<br>&gt;<br>&gt;    - Proposal: SE-XXXX<br>&gt;    &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt;    - Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt;    - Status: *TBD*<br>&gt;    - Review manager: TBD<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;<br>&gt; Introduction<br>&gt;<br>&gt; This proposal seeks to introduce a where expression to associated types<br>&gt; declarations to bring the same expressive power as generic type constraints.<br>&gt;<br>&gt; *This proposal was discussed on the Swift Evolution list in<br>&gt; the [swift-evolution] [Completing Generics] Arbitrary requirements in<br>&gt; protocols<br>&gt; &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.*<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;<br>&gt; Motivation<br>&gt;<br>&gt; Currently, associated type declarations can only express simple<br>&gt; inheritance constraints and not the more sophisticated constraints<br>&gt; available to generic types with the where expression. Some designs,<br>&gt; including many in the Standard Library, require more powerful constraints<br>&gt; for associated types to be truly elegant. For example, the SequenceType protocol<br>&gt; can be declared as follows:<br>&gt;<br>&gt; protocol Sequence {<br>&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     ...<br>&gt; }<br>&gt;<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail<br>&gt; Design<br>&gt;<br>&gt; With this proposal, the grammar for protocols associated types would be<br>&gt; modified to:<br>&gt;<br>&gt; *protocol-associated-type-declaration* → *attributesopt*<br>&gt; *access-level-modifieropt* *associatedtype* *typealias-name*<br>&gt; *­type-inheritance-clause­opt­* *typealias-assignment­opt*<br>&gt; *requirement-clauseopt*<br>&gt;<br>&gt; The new requirement-clause is then used by the compiler to validate the<br>&gt; associated types of conforming types.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#issues&gt;<br>&gt; Issues<br>&gt;<br>&gt; Douglas Gregor argues that the proposed syntax is redundant when adding<br>&gt; new constraints to an associated type declared in a parent protocol and<br>&gt; proposes another syntax:<br>&gt;<br>&gt; protocol Collection : Sequence {<br>&gt;     where SubSequence : Collection<br>&gt; }<br>&gt;<br>&gt; But as Douglas notes himself, that syntax will become ambiguous if we<br>&gt; adopt the generic where expression at the end of declarations like<br>&gt; discussed in the following thread:<br>&gt; http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058.<br>&gt; For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt;<br>&gt; &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#acknowledgements&gt;<br>&gt; Acknowledgements<br>&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me<br>&gt; through this proposal.<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/0b398ec4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  3, 2016 at 12:00:00am</p></header><div class="content"><p>Hello Tony,<br></p><p>Sorry, I never took the time to comment. I see the issues you are pointing, but they seem to be more generic than only concerning associated type constraints. For example, the &quot;inheritance from non-protocol, non-class type” error also concerns generic types. Perhaps it should be best to start new discussions and new proposal for those issues? This proposal already seems like a mouthful to me.<br></p><p>David.<br></p><p><br>&gt; On 25 Apr 2016, at 18:01, Tony Allevato via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I really like where this proposal is headed.<br>&gt; <br>&gt; Would this syntax also support constraining associated types based on &quot;inheritability&quot; (for lack of a better word)? For example, a couple times I&#39;ve hit a situation where I want to express a supertype/subtype relationship. A contrived example:<br>&gt; <br>&gt; protocol Foo {<br>&gt;   associatedtype Bar<br>&gt; <br>&gt;   func f&lt;Baz: Bar&gt;(b: Baz.Type) -&gt; Baz<br>&gt; }<br>&gt; <br>&gt; This currently gives me the error &quot;inheritance from non-protocol, non-class type &#39;Self.Bar&#39;.&quot; This makes sense in a way, because a type conforming to Foo could define Bar to be anything, including a struct.<br>&gt; <br>&gt; I see a few ways to address this:<br>&gt; <br>&gt; (1) Allow users to write &quot;associatedtype Bar: class&quot; to indicate that the conforming class must set Bar to be a class type, which would let the type checker know that the Baz: Bar constraint is valid. This gets us partially there, but is still somewhat limiting because other supertype/subtype relationships could not be expressed, such as Bar being an arbitrary protocol and Baz being any type that conforms to that protocol.<br>&gt; <br>&gt; (2) Allow users to write &quot;associatedtype Bar: _____&quot;, where _____ is some way of expressing any arbitrary type that is inheritable: this would include classes but also protocols. The difference here is instead of specifying a specific protocol, conforming types could put any protocol here, binding Bar in function f() to that protocol and then Baz would be any type conforming to Bar.<br>&gt; <br>&gt; (3) Allow the syntax above unchanged. If a conforming type defines Bar to be a struct, loosen the check and still allow it such that the only possible type that can satisfy Baz is Bar itself. This would be consistent with other generic constraints that are class-based, where a constraint of the form f&lt;SomeClass: BaseClass&gt; can still satisfy SomeClass by using BaseClass itself.<br>&gt; <br>&gt; While writing this, I noticed some other constructs that seem like they should work, but don&#39;t:<br>&gt; <br>&gt; protocol SomeProtocol {}<br>&gt; protocol Foo {<br>&gt;   associatedtype Bar: SomeProtocol<br>&gt;   func f&lt;Baz: Bar&gt;(b: Baz.Type) -&gt; Baz<br>&gt;   // ^ inheritance from non-protocol, non-class type &#39;Self.Bar&#39;<br>&gt;   // Shouldn&#39;t the compiler know that Bar is constrained by a protocol here?<br>&gt; }<br>&gt; <br>&gt; class SomeClass {}<br>&gt; protocol Foo {<br>&gt;   associatedtype Bar: SomeClass<br>&gt;   func f&lt;Baz: Bar&gt;(b: Baz.Type) -&gt; Baz<br>&gt;   // ^ inheritance from non-protocol, non-class type &#39;Self.Bar&#39;<br>&gt;   // Same problem as above, essentially.<br>&gt; }<br>&gt; <br>&gt; protocol A {}<br>&gt; protocol B {}<br>&gt; protocol Foo {<br>&gt;   associatedtype Bar: protocol&lt;A, B&gt;<br>&gt;   // ^ This one doesn&#39;t appear to even get past the parser, which is unfortunate.<br>&gt;   // To express the notion of an associatedtype conforming to two protocols, you<br>&gt;   // have to create a third protocol and extend the type you wish to use to conform<br>&gt;   // to that protocol.<br>&gt; }<br>&gt; <br>&gt; Some of these issues may have been addressed in &quot;Completing generics&quot;, but they seem like they would fit into this proposal as well.<br>&gt; <br>&gt; On Mon, Apr 25, 2016 at 8:30 AM Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On Apr 25, 2016, at 9:58 AM, Thorsten Seitz &lt;tseitz42 at icloud.com &lt;mailto:tseitz42 at icloud.com&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; Am 25.04.2016 um 15:40 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt; <br>&gt;&gt;&gt; I really like this proposal.  It is a nice step forward from current state.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, it looks like it doesn&#39;t allow us to express constraints that elate two or more associated types together, such as requiring both to have the same Element type.<br>&gt;&gt; <br>&gt;&gt; Did I miss something? I thought that was the exact example given in the motivation section?<br>&gt; <br>&gt; You are right.  I&#39;m not sure how I missed that.  I think it is because the constraints are attached to a single associatedtype declaration rather than being at the top level of the protocol declaration. <br>&gt; <br>&gt; It feels slightly awkward to have to attach such constraints to one of the associatedtype declarations as they are effectively peers in the same type constraint.  Allowing such constraints to stand alone would look similar to Doug&#39;s example in the issues section.  I would prefer to look for a syntax for generic constraints on declarations that allows for freestanding and refined constraints in protocols.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten <br>&gt;&gt; <br>&gt;&gt;&gt;  I think it would be a good idea to solve the general problem of constraining associated types if possible.  The general case is an important part of completing generics IMO so it should be within the scope of Swift 3 to consider it.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Matthew<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 24, 2016, at 3:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt;&gt;&gt;&gt; Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#issues&gt;Issues<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Collection : Sequence {<br>&gt;&gt;&gt;&gt;     where SubSequence : Collection<br>&gt;&gt;&gt;&gt; } <br>&gt;&gt;&gt;&gt; But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where expression at the end of declarations like discussed in the following thread: http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058 &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/13886/focus=14058&gt;. For those reasons, it might be wiser not to introduce the shorthand syntax.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#acknowledgements&gt;Acknowledgements<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/7667a370/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt; <br>&gt; More Powerful Constraints for Associated Types<br>&gt; <br>&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt; Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt; Status: TBD<br>&gt; Review manager: TBD<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br>&gt; <br>&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt; <br>&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br>&gt; <br>Believe it or not, I support this direction…<br></p><p>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br>&gt; <br>&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt; <br>&gt; protocol Sequence {<br>&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;     ...<br>&gt; }<br>&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br>&gt; <br>&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt; <br>&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt; <br>&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt; <br>The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br></p><p>protocol P { }<br></p><p>protocol Q {<br>  typealias AssocType<br>}<br></p><p>protocol R : Q {<br>  // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>  typealias AssocType where AssocType : P<br>}<br></p><p>Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br></p><p>protocol R : Q where AssocType : P {<br>  // …<br>}<br></p><p>There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br></p><p>Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br></p><p>	- Doug<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160425/d59c7728/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>On Mon, Apr 25, 2016 at 8:28 PM, Douglas Gregor via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; Did you consider an alternate syntax that puts the where clause outside the<br>&gt; braces, e.g.,<br>&gt;<br>&gt; protocol R : Q where AssocType : P {<br>&gt;   // …<br>&gt; }<br></p><p>To me this reads like declaring a conditional conformance.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 25, 2016 at 08:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On Apr 25, 2016, at 8:41 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Mon, Apr 25, 2016 at 8:28 PM, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the<br>&gt;&gt; braces, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;  // …<br>&gt;&gt; }<br>&gt; <br>&gt; To me this reads like declaring a conditional conformance.<br></p><p>I&#39;m reading it as &quot;R is-a Q where AssocType is-a P&quot;. <br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 25, 2016 at 11:00:00pm</p></header><div class="content"><p>Is that bad? We already have conditional inheritance in classes:<br>	class Foo&lt;T where _constraint_&gt; : Bar&lt;T&gt; {}<br>If you move the where clause to the right:<br>	class Foo&lt;T&gt;  : Bar&lt;T where _constraint_&gt; {}<br>And drop the generic arguments:<br>	class Foo : Bar where _constraint_ {}<br>The only difference is “protocol” vs “class”.<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 25, 2016, at 10:41 PM, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Mon, Apr 25, 2016 at 8:28 PM, Douglas Gregor via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the<br>&gt;&gt; braces, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;  // …<br>&gt;&gt; }<br>&gt; <br>&gt; To me this reads like declaring a conditional conformance.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>April 25, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br></p><p>You also do it to specify or change a default associated type. This is from an older copy of the stdlib source code, but I believe there&#39;s still something equivalent:<br></p><p>	public protocol CollectionType : Indexable, SequenceType {<br>	  associatedtype Generator: GeneratorType = IndexingGenerator&lt;Self&gt;<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>April 26, 2016 at 06:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>On Apr 25, 2016, at 10:03 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br></p><p>&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt; <br>&gt; You also do it to specify or change a default associated type. This is from an older copy of the stdlib source code, but I believe there&#39;s still something equivalent:<br>&gt; <br>&gt;    public protocol CollectionType : Indexable, SequenceType {<br>&gt;      associatedtype Generator: GeneratorType = IndexingGenerator&lt;Self&gt;<br></p><p>Ah yes, of course! Thank you. <br></p><p>  - Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 29, 2016 at 09:00:00am</p></header><div class="content"><p>I’ve taken some time to digest the current feedback and I’ve changed my mind. The syntax for adding constraints to a sub-protocol in the protocol’s definition where clause is starting to grow on me. Before I modify the proposal, I&#39;d still like to understand something:<br></p><p>What is the use of declaring a default associated types with the `=` syntax in protocols? I’ve never used them and I don’t understand what they provide.<br></p><p>&gt; On 26 Apr 2016, at 15:53, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt; On Apr 25, 2016, at 10:03 PM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt; <br>&gt;&gt; You also do it to specify or change a default associated type. This is from an older copy of the stdlib source code, but I believe there&#39;s still something equivalent:<br>&gt;&gt; <br>&gt;&gt;   public protocol CollectionType : Indexable, SequenceType {<br>&gt;&gt;     associatedtype Generator: GeneratorType = IndexingGenerator&lt;Self&gt;<br>&gt; <br>&gt; Ah yes, of course! Thank you. <br>&gt; <br>&gt;  - Doug<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 29, 2016 at 12:00:00am</p></header><div class="content"><p>On Fri, Apr 29, 2016 at 12:25 AM, David Hart via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I’ve taken some time to digest the current feedback and I’ve changed my mind. The syntax for adding constraints to a sub-protocol in the protocol’s definition where clause is starting to grow on me. Before I modify the proposal, I&#39;d still like to understand something:<br>&gt;<br>&gt; What is the use of declaring a default associated types with the `=` syntax in protocols? I’ve never used them and I don’t understand what they provide.<br></p><p>Please take a look at the Collection protocol<br>(https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift).<br></p><p>associatedtype Iterator : IteratorProtocol = IndexingIterator&lt;Self&gt;<br>associatedtype SubSequence : IndexableBase, Sequence = Slice&lt;Self&gt;<br>associatedtype Indices : IndexableBase, Sequence = DefaultIndices&lt;Self&gt;<br></p><p>Some collections want to customize these, but for simple ones the<br>defaults are usually fine.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 29, 2016 at 10:00:00am</p></header><div class="content"><p>Hi Dimitri,<br></p><p>Excuse me if I’m being dumb. I saw those example but I don’t understand their use.<br></p><p>If I define a custom Collection, I still have the be explicit in the types I use where associated types are expected. Because I need to be explicit, I don’t understand how default associated types are used.<br></p><p>Default parameters seem clear to me:<br></p><p>func foobar(a: Int = 0) {}<br>foo() // implicit uses default value<br>foo(a: 1) // Explicit bypasses default value<br></p><p>But default associated types are not:<br></p><p>protocol Foobar {<br>    associatedtype Foo = Int<br>    func foobar(a: Foo)<br>}<br></p><p>class FoobarImpl : FooBar {<br>    func foobar(a: Foo) {} // error: Use of undeclared type ‘Foo’ - there is no such thing as an implicit use<br>    func foobar(a: Double) {} // This works but is explicit<br>}<br></p><p>I just don’t see the implicit use of the default associated type.<br></p><p>David.<br></p><p>&gt; On 29 Apr 2016, at 09:36, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Apr 29, 2016 at 12:25 AM, David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I’ve taken some time to digest the current feedback and I’ve changed my mind. The syntax for adding constraints to a sub-protocol in the protocol’s definition where clause is starting to grow on me. Before I modify the proposal, I&#39;d still like to understand something:<br>&gt;&gt; <br>&gt;&gt; What is the use of declaring a default associated types with the `=` syntax in protocols? I’ve never used them and I don’t understand what they provide.<br>&gt; <br>&gt; Please take a look at the Collection protocol<br>&gt; (https://github.com/apple/swift/blob/master/stdlib/public/core/Collection.swift).<br>&gt; <br>&gt; associatedtype Iterator : IteratorProtocol = IndexingIterator&lt;Self&gt;<br>&gt; associatedtype SubSequence : IndexableBase, Sequence = Slice&lt;Self&gt;<br>&gt; associatedtype Indices : IndexableBase, Sequence = DefaultIndices&lt;Self&gt;<br>&gt; <br>&gt; Some collections want to customize these, but for simple ones the<br>&gt; defaults are usually fine.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/abbaf614/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 29, 2016 at 01:00:00am</p></header><div class="content"><p>On Fri, Apr 29, 2016 at 1:50 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; Hi Dimitri,<br>&gt;<br>&gt; Excuse me if I’m being dumb. I saw those example but I don’t understand<br>&gt; their use.<br>&gt;<br>&gt; If I define a custom Collection, I still have the be explicit in the types I<br>&gt; use where associated types are expected. Because I need to be explicit, I<br>&gt; don’t understand how default associated types are used.<br>&gt;<br>&gt; Default parameters seem clear to me:<br>&gt;<br>&gt; func foobar(a: Int = 0) {}<br>&gt; foo() // implicit uses default value<br>&gt; foo(a: 1) // Explicit bypasses default value<br>&gt;<br>&gt; But default associated types are not:<br>&gt;<br>&gt; protocol Foobar {<br>&gt;     associatedtype Foo = Int<br>&gt;     func foobar(a: Foo)<br>&gt; }<br>&gt;<br>&gt; class FoobarImpl : FooBar {<br>&gt;     func foobar(a: Foo) {} // error: Use of undeclared type ‘Foo’ - there is<br>&gt; no such thing as an implicit use<br>&gt;     func foobar(a: Double) {} // This works but is explicit<br>&gt; }<br></p><p>In a typical use, &#39;func foobar&#39; would also be defaulted.  The<br>Collection.Iterator associated type and the makeIterator() method are<br>an example of this.<br></p><p>The fact that the compiler does not allow to use the inferred &#39;Foo&#39;<br>type actually looks like a bug to me.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>April 29, 2016 at 01:00:00pm</p></header><div class="content"><p>But Collection has to have an extension which explicitly mentions IndexingIterator:<br></p><p>extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>    /// Returns an iterator over the elements of the collection.<br>    public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; {<br>        return IndexingIterator(_elements: self)<br>    }<br>}<br></p><p>And Array, for example, has to be explicit:<br></p><p>public typealias Iterator = IndexingIterator&lt;${Self}&gt;<br></p><p>So I still don’t see how defining:<br></p><p>associatedtype Iterator : IteratorProtocol = IndexingIterator&lt;Self&gt;<br></p><p>has created any default behaviour.<br></p><p>When you say &quot;The fact that the compiler does not allow to use the inferred ‘Foo&#39; type actually looks like a bug to me.”, could you give me an example of how you would have imagined this default behaviour to work in the case of Array? Would have expected Array not to have to define its typealias?<br></p><p>David.<br></p><p>&gt; On 29 Apr 2016, at 10:59, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; <br>&gt; On Fri, Apr 29, 2016 at 1:50 AM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; Hi Dimitri,<br>&gt;&gt; <br>&gt;&gt; Excuse me if I’m being dumb. I saw those example but I don’t understand<br>&gt;&gt; their use.<br>&gt;&gt; <br>&gt;&gt; If I define a custom Collection, I still have the be explicit in the types I<br>&gt;&gt; use where associated types are expected. Because I need to be explicit, I<br>&gt;&gt; don’t understand how default associated types are used.<br>&gt;&gt; <br>&gt;&gt; Default parameters seem clear to me:<br>&gt;&gt; <br>&gt;&gt; func foobar(a: Int = 0) {}<br>&gt;&gt; foo() // implicit uses default value<br>&gt;&gt; foo(a: 1) // Explicit bypasses default value<br>&gt;&gt; <br>&gt;&gt; But default associated types are not:<br>&gt;&gt; <br>&gt;&gt; protocol Foobar {<br>&gt;&gt;    associatedtype Foo = Int<br>&gt;&gt;    func foobar(a: Foo)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; class FoobarImpl : FooBar {<br>&gt;&gt;    func foobar(a: Foo) {} // error: Use of undeclared type ‘Foo’ - there is<br>&gt;&gt; no such thing as an implicit use<br>&gt;&gt;    func foobar(a: Double) {} // This works but is explicit<br>&gt;&gt; }<br>&gt; <br>&gt; In a typical use, &#39;func foobar&#39; would also be defaulted.  The<br>&gt; Collection.Iterator associated type and the makeIterator() method are<br>&gt; an example of this.<br>&gt; <br>&gt; The fact that the compiler does not allow to use the inferred &#39;Foo&#39;<br>&gt; type actually looks like a bug to me.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160429/1a2d5528/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>April 29, 2016 at 08:00:00am</p></header><div class="content"><p>On Fri, Apr 29, 2016 at 4:02 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; But Collection has to have an extension which explicitly mentions<br>&gt; IndexingIterator:<br>&gt;<br>&gt; extension Collection where Iterator == IndexingIterator&lt;Self&gt; {<br>&gt;     /// Returns an iterator over the elements of the collection.<br>&gt;     public func makeIterator() -&gt; IndexingIterator&lt;Self&gt; {<br>&gt;         return IndexingIterator(_elements: self)<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; And Array, for example, has to be explicit:<br>&gt;<br>&gt; public typealias Iterator = IndexingIterator&lt;${Self}&gt;<br></p><p>This might be a workaround for a compiler bug (that it couldn&#39;t infer the type).<br></p><p>&gt; So I still don’t see how defining:<br>&gt;<br>&gt; associatedtype Iterator : IteratorProtocol = IndexingIterator&lt;Self&gt;<br>&gt;<br>&gt; has created any default behaviour.<br>&gt;<br>&gt; When you say &quot;The fact that the compiler does not allow to use the inferred<br>&gt; ‘Foo&#39; type actually looks like a bug to me.”, could you give me an example<br>&gt; of how you would have imagined this default behaviour to work in the case of<br>&gt; Array? Would have expected Array not to have to define its typealias?<br></p><p>Right, I would expect Array to not need to mention Iterator at all in<br>its definition.<br></p><p>Take a look at stdlib/public/core/CollectionOfOne.swift.  It does not<br>define SubSequence or Indices.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  3, 2016 at 12:00:00am</p></header><div class="content"><p>Hi Doug,<br></p><p>In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br></p><p>protocol R : Q where AssocType : P {<br>  // …<br>}<br></p><p>Can you read through that part of the proposal and let me know if it is descriptive enough?<br></p><p>David.<br></p><p>&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt; <br>&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt; <br>&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt;&gt; Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt;&gt; Status: TBD<br>&gt;&gt; Review manager: TBD<br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br>&gt;&gt; <br>&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt; <br>&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br>&gt;&gt; <br>&gt; Believe it or not, I support this direction…<br>&gt; <br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br>&gt;&gt; <br>&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt; <br>&gt;&gt; protocol Sequence {<br>&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;     ...<br>&gt;&gt; }<br>&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br>&gt;&gt; <br>&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt; <br>&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt; <br>&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt; <br>&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt; <br>&gt; protocol P { }<br>&gt; <br>&gt; protocol Q {<br>&gt;   typealias AssocType<br>&gt; }<br>&gt; <br>&gt; protocol R : Q {<br>&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;   typealias AssocType where AssocType : P<br>&gt; }<br>&gt; <br>&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt; <br>&gt; protocol R : Q where AssocType : P {<br>&gt;   // …<br>&gt; }<br>&gt; <br>&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt; <br>&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt; <br>&gt; 	- Doug<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/506ee4d2/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3c450c87df0788b8e1f7a6ca17ea34c7?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Douglas Gregor</string> &lt;dgregor at apple.com&gt;<p>May  3, 2016 at 01:00:00am</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Hi Doug,<br>&gt; <br>&gt; In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br>&gt; <br>&gt; protocol R : Q where AssocType : P {<br>&gt;   // …<br>&gt; }<br>&gt; <br>&gt; Can you read through that part of the proposal and let me know if it is descriptive enough?<br></p><p>I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br></p><p>  - Doug<br></p><p><br>&gt; <br>&gt; David.<br>&gt; <br>&gt;&gt;&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt; Author(s): David Hart<br>&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt;&gt; <br>&gt;&gt; Believe it or not, I support this direction…<br>&gt;&gt; <br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;     ...<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; Detail Design<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt; <br>&gt;&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt;&gt; <br>&gt;&gt; protocol P { }<br>&gt;&gt; <br>&gt;&gt; protocol Q {<br>&gt;&gt;   typealias AssocType<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; protocol R : Q {<br>&gt;&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;&gt;   typealias AssocType where AssocType : P<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt;&gt; <br>&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;   // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt;&gt; <br>&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt; <br>&gt;&gt; 	- Doug<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/881d9c02/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  3, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 3, 2016, at 3:37 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Hi Doug,<br>&gt;&gt; <br>&gt;&gt; In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br>&gt;&gt; <br>&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;   // …<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; Can you read through that part of the proposal and let me know if it is descriptive enough?<br>&gt; <br>&gt; I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br></p><p>To me this syntax reads as a constraint on Q only.  If we need a constraint on associated types defined in R the constraint should be attached to the definition.<br></p><p>&gt; <br>&gt;   - Doug<br>&gt; <br>&gt; <br>&gt;&gt; <br>&gt;&gt; David.<br>&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt; Author(s): David Hart<br>&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; Believe it or not, I support this direction…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; Detail Design<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;   typealias AssocType<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol R : Q {<br>&gt;&gt;&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;&gt;&gt;   typealias AssocType where AssocType : P<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;   // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/0fd7d265/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May  5, 2016 at 02:00:00pm</p></header><div class="content"><p>To me it reads as a constraint on R. Otherwise we would have to write `protocol R where … : Q where …, S where … { … }` which would not only be confusing but would not make much sense IMHO because I want to be able to write constraints which combine associated types from R, Q and S, i.e. from all sources contributing to R.<br></p><p>Answering Doug’s question: I’d like the name lookup to start in R and to be able to refer to an associated type newly defined in R.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 03.05.2016 um 14:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; <br>&gt; <br>&gt; Sent from my iPad<br>&gt; <br>&gt; On May 3, 2016, at 3:37 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPhone<br>&gt;&gt; <br>&gt;&gt; On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Hi Doug,<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;   // …<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Can you read through that part of the proposal and let me know if it is descriptive enough?<br>&gt;&gt; <br>&gt;&gt; I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br>&gt; <br>&gt; To me this syntax reads as a constraint on Q only.  If we need a constraint on associated types defined in R the constraint should be attached to the definition.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;   - Doug<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; David.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt;&gt;&gt;&gt;&gt; Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Believe it or not, I support this direction…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;   typealias AssocType<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol R : Q {<br>&gt;&gt;&gt;&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;&gt;&gt;&gt;   typealias AssocType where AssocType : P<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/39c63d5d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 07:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 5, 2016, at 7:30 AM, Thorsten Seitz &lt;tseitz42 at icloud.com&gt; wrote:<br>&gt; <br>&gt; To me it reads as a constraint on R. Otherwise we would have to write `protocol R where … : Q where …, S where … { … }` which would not only be confusing but would not make much sense IMHO because I want to be able to write constraints which combine associated types from R, Q and S, i.e. from all sources contributing to R.<br></p><p>My early post was poorly worded.  It reads as a constraint on the associated types R inherits (from Q in this example).  You would be able to relate any inherited associated types to each other here if desired.  Any new associated types introduced by R should be constrained where they are introduced.<br></p><p>&gt; <br>&gt; Answering Doug’s question: I’d like the name lookup to start in R and to be able to refer to an associated type newly defined in R.<br></p><p>This seems confusing to me.  The associated type has not been introduced until inside the body of R.  It doesn&#39;t make sense to allow them to be constrained prior to introduction and it offers no additional functionality.  Separating the constraints on inherited associated types from the constraints on newly introduced associated types adds clarity and readability IMO.  Lookup should only consider inherited protocols.<br></p><p><br>&gt; <br>&gt; -Thorsten<br>&gt; <br>&gt; <br>&gt;&gt; Am 03.05.2016 um 14:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; Sent from my iPad<br>&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 3:37 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Hi Doug,<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Can you read through that part of the proposal and let me know if it is descriptive enough?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br>&gt;&gt; <br>&gt;&gt; To me this syntax reads as a constraint on Q only.  If we need a constraint on associated types defined in R the constraint should be attached to the definition.<br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt;&gt; Author(s): David Hart<br>&gt;&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Believe it or not, I support this direction…<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; Detail Design<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;&gt;   typealias AssocType<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol R : Q {<br>&gt;&gt;&gt;&gt;&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;&gt;&gt;&gt;&gt;   typealias AssocType where AssocType : P<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/79d69a7f/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  5, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt;&gt; Answering Doug’s question: I’d like the name lookup to start in R and to be able to refer to an associated type newly defined in R.<br>&gt; <br>&gt; This seems confusing to me.  The associated type has not been introduced until inside the body of R.  It doesn&#39;t make sense to allow them to be constrained prior to introduction and it offers no additional functionality.  Separating the constraints on inherited associated types from the constraints on newly introduced associated types adds clarity and readability IMO.  Lookup should only consider inherited protocols.<br></p><p>I agree with you Matthew (as my proposal makes clear). If it started in R, readers would have to scan both the declaration where clause and the associated type where clause to get a full picture.<br></p><p>protocol R : Q where AssocType.Generator.Element == Int {<br>    associatedtype AssocType: Sequence<br>}<br></p><p>vs<br></p><p>protocol R : Q {<br>    associatedtype AssocType: Sequence where AssocType.Generator.Element == Int<br>}<br></p><p>David.<br></p><p>&gt; <br>&gt;&gt; <br>&gt;&gt; -Thorsten<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; Am 03.05.2016 um 14:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt;:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On May 3, 2016, at 3:37 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Hi Doug,<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Can you read through that part of the proposal and let me know if it is descriptive enough?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To me this syntax reads as a constraint on Q only.  If we need a constraint on associated types defined in R the constraint should be attached to the definition.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com &lt;mailto:dgregor at apple.com&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Author(s): David Hart &lt;http://github.com/hartbit&gt;<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#introduction&gt;Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt; thread.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Believe it or not, I support this direction…<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#motivation&gt;Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;  &lt;https://github.com/hartbit/swift-evolution/blob/master/proposals/XXXX-powerful-constraints-associated-types.md#detail-design&gt;Detail Design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;&gt;&gt;   typealias AssocType<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol R : Q {<br>&gt;&gt;&gt;&gt;&gt;&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;&gt;&gt;&gt;&gt;&gt;   typealias AssocType where AssocType : P<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/c861c5c5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc3a9ea0c6c870343d9acb4ac3059cdc?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>Matthew Johnson</string> &lt;matthew at anandabits.com&gt;<p>May  5, 2016 at 08:00:00am</p></header><div class="content"><p>Sent from my iPad<br></p><p>&gt; On May 5, 2016, at 8:25 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; Answering Doug’s question: I’d like the name lookup to start in R and to be able to refer to an associated type newly defined in R.<br>&gt;&gt; <br>&gt;&gt; This seems confusing to me.  The associated type has not been introduced until inside the body of R.  It doesn&#39;t make sense to allow them to be constrained prior to introduction and it offers no additional functionality.  Separating the constraints on inherited associated types from the constraints on newly introduced associated types adds clarity and readability IMO.  Lookup should only consider inherited protocols.<br>&gt; <br>&gt; I agree with you Matthew (as my proposal makes clear). If it started in R, readers would have to scan both the declaration where clause and the associated type where clause to get a full picture.<br>&gt; <br>&gt; protocol R : Q where AssocType.Generator.Element == Int {<br>&gt;     associatedtype AssocType: Sequence<br>&gt; }<br>&gt; <br>&gt; vs<br>&gt; <br>&gt; protocol R : Q {<br>&gt;     associatedtype AssocType: Sequence where AssocType.Generator.Element == Int<br>&gt; }<br>&gt; <br></p><p>Yep, I know you agree and am happy with the proposal.  Just clarifying the rationale (as I see it) for Thorsten.<br></p><p>&gt; David.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Thorsten<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Am 03.05.2016 um 14:03 schrieb Matthew Johnson via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Sent from my iPad<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On May 3, 2016, at 3:37 AM, Douglas Gregor via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Sent from my iPhone<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On May 2, 2016, at 3:50 PM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Hi Doug,<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; In the latest version of the proposal, which is now linked to a pull request, I mentioned in the Detail Design section that the following syntax be valid:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Can you read through that part of the proposal and let me know if it is descriptive enough?<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I think you need to clarify the intended name lookup semantics. Does name lookup for &quot;AssocType&quot; start its lookup in R or in Q? If the former, can one refer to an associated type newly defined in R?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To me this syntax reads as a constraint on Q only.  If we need a constraint on associated types defined in R the constraint should be attached to the definition.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;   - Doug<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; David.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 26 Apr 2016, at 05:28, Douglas Gregor &lt;dgregor at apple.com&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On Apr 24, 2016, at 1:34 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; I wrote the proposal which was discussed to introduce generic constraints for associated types. I’d like to get some feedback on it and get it ready before submitting it:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; More Powerful Constraints for Associated Types<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Proposal: SE-XXXX<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Author(s): David Hart<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Status: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Review manager: TBD<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal seeks to introduce a where expression to associated types declarations to bring the same expressive power as generic type constraints.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; This proposal was discussed on the Swift Evolution list in the [swift-evolution] [Completing Generics] Arbitrary requirements in protocols thread.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Believe it or not, I support this direction…<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where expression. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Sequence {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype Iterator : IteratorProtocol<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;     ...<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Detail Design<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; With this proposal, the grammar for protocols associated types would be modified to:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt­ typealias-assignment­opt requirement-clauseopt<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; The only thing that bothers me about this syntax is that I have to introduce an associated type to add requirements. For example, what if I want my inheriting protocol to add a requirement to an existing associated type?<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol P { }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol Q {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   typealias AssocType<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol R : Q {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   // I want to just add “AssocType : P”, but I have to redeclare AssocType to do so<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   typealias AssocType where AssocType : P<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Did you consider an alternate syntax that puts the where clause outside the braces, e.g.,<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; protocol R : Q where AssocType : P {<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;   // …<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; There are two things I like about this. First, it breaks the unnecessary link between an associated type and a (possibly unrelated) where clause, eliminating the need to redeclare associated types in inheriting protocols. Second, it’s effectively the same syntax as constrained extensions, which have a similar feel.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Note that, if we do the above, I’d love to make it an error to define a new associated type with the same name as an associated type in an inherited protocol. It’s odd that we do so, and IIRC the only use case for it is to add requirement to an “existing” associated type.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	- Doug<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160505/7b213563/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b2fa5f52f699e07a98fefcf30fb95354?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>James Richard</string> &lt;ketzu at me.com&gt;<p>April 27, 2016 at 07:00:00am</p></header><div class="content"><p>+1 to this! I’ve been missing this as well.<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] More Powerful Constraints for Associated Types</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>May  3, 2016 at 12:00:00am</p></header><div class="content"><p>I’ve updated the proposal with comments from the discussions and opened a pull request. Please let me know if you have any feedback before it’s merged:<br></p><p>More Powerful Constraints for Associated Types<br></p><p>Proposal: SE-XXXX &lt;https://github.com/apple/swift-evolution/blob/master/proposals/XXXX-associated-types-constraints.md&gt;<br>Author(s): David Hart &lt;http://github.com/hartbit&gt;, Jacob Bandes-Storch &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/jtbandes at gmail.com&gt;, Douglas Gregor &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/dgregor at apple.com&gt;<br>Status: TBD<br>Review manager: TBD<br> &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/XXXX-associated-types-constraints.md#introduction&gt;Introduction<br></p><p>This proposal seeks to introduce a where clause to associated types declarations to bring the same expressive power as generic type constraints.<br></p><p>This proposal was discussed twice on the Swift Evolution list in the following threads:<br></p><p>[Completing Generics] Arbitrary requirements in protocols &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/14243&gt;<br>More Powerful Constraints for Associated Types &lt;http://thread.gmane.org/gmane.comp.lang.swift.evolution/15201&gt;<br> &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/XXXX-associated-types-constraints.md#motivation&gt;Motivation<br></p><p>Currently, associated type declarations can only express simple inheritance constraints and not the more sophisticated constraints available to generic types with the where clause. Some designs, including many in the Standard Library, require more powerful constraints for associated types to be truly elegant. For example, the SequenceType protocol can be declared as follows:<br></p><p>protocol Sequence {<br>    associatedtype Iterator : IteratorProtocol<br>    associatedtype SubSequence : Sequence where SubSequence.Iterator.Element == Iterator.Element<br>    ...<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/XXXX-associated-types-constraints.md#detail-design&gt;Detail Design<br></p><p>With this proposal, the grammar for protocols associated types would be modified to:<br></p><p>protocol-associated-type-declaration → attributesopt access-level-modifieropt associatedtype typealias-name ­type-inheritance-clause­opt typealias-assignment­opt requirement-clauseopt<br></p><p>The new requirement-clause is then used by the compiler to validate the associated types of conforming types.<br></p><p>The proposal also allows protocols to use the associated types of their conforming protocols in their declaration where clause as below:<br></p><p>protocol IntSequence : Sequence where Iterator.Element == Int {<br>    ...<br>}<br> &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/XXXX-associated-types-constraints.md#alternatives&gt;Alternatives<br></p><p>Douglas Gregor argues that the proposed syntax is redundant when adding new constraints to an associated type declared in a parent protocol and proposes another syntax: <br></p><p>protocol Collection : Sequence {<br>    where SubSequence : Collection<br>}<br>But as Douglas notes himself, that syntax will become ambiguous if we adopt the generic where clause at the end of declarations like discussed in proposal SE-0081: Move where clause to end of declaration &lt;https://github.com/apple/swift-evolution/blob/master/proposals/0081-move-where-expression.md&gt;. For those reasons, it might be wiser not to introduce the shorthand syntax.<br></p><p> &lt;https://github.com/hartbit/swift-evolution/blob/associated-types-constraints/proposals/XXXX-associated-types-constraints.md#acknowledgements&gt;Acknowledgements<br></p><p>Thanks to Dave Abrahams and Douglas Gregor for taking the time to help me through this proposal.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160503/24b85a19/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
