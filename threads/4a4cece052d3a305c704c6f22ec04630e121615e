<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 12, 2016 at 10:00:00pm</p></header><div class="content"><p>I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br></p><p>I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br></p><p>http://stackoverflow.com/a/31349339<br></p><p>Is this imaginable?<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt; I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br>&gt;<br>&gt; I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br>&gt;<br>&gt; http://stackoverflow.com/a/31349339<br>&gt;<br>&gt; Is this imaginable?<br></p><p>What would precondition() if the condition evaluates to false, and the<br>special handler is installed?  precondition() can&#39;t return, since it<br>can&#39;t allow the original code to continue.  The original code<br>certainly does not expect to continue (it can even do something<br>memory-unsafe, or force-unwrap an nil optional, or advance an index<br>past endIndex, etc.)<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Mar 12, 2016 at 4:26 PM, Dmitri Gribenko &lt;gribozavr at gmail.com&gt; wrote:<br>&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br>&gt;&gt;<br>&gt;&gt; I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br>&gt;&gt;<br>&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;<br>&gt;&gt; Is this imaginable?<br>&gt;<br>&gt; What would precondition() if the condition evaluates to false, and the<br>&gt; special handler is installed?  precondition() can&#39;t return, since it<br>&gt; can&#39;t allow the original code to continue.  The original code<br>&gt; certainly does not expect to continue (it can even do something<br>&gt; memory-unsafe, or force-unwrap an nil optional, or advance an index<br>&gt; past endIndex, etc.)<br></p><p>And, for the case of fatalError(), the compiler wouldn&#39;t even allow<br>you to return from a custom handler (since fatalError() is @noreturn).<br></p><p>I don&#39;t see a way around this.  If the code needs to stop, it will<br>make all sorts of assumptions about it (that it won&#39;t continue), and<br>so will the optimizer.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>March 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I am deeply interested in finding solutions for allowing unit-tests of<br>&gt; preconditions. Without them, I believe we are leaving many holes in our<br>&gt; tests and coverage. The solution found in the Swift project of forking the<br>&gt; process seems fairly complicated to implement in XCTest.<br>&gt;<br>&gt; I found a solution online that works by overriding the precondition<br>&gt; function with a function that calls a configurable closure which defaults<br>&gt; to the original precondition function. It would be great if the Standard<br>&gt; Library allowed this by default so that XCTest could use it to offer full<br>&gt; support for precondition unit tests.<br>&gt;<br>&gt; http://stackoverflow.com/a/31349339<br>&gt;<br>&gt; Is this imaginable?<br>&gt;<br></p><p>+1 to this being an important problem to solve, but I&#39;m not sure about the<br>specific solution.  Are there performance or security impacts to production<br>code by having this?  Could the forked-process solution be implemented once<br>in a framework and then everybody just uses it transparently?  The<br>forked-process approach also has the advantage of catching crashes for any<br>other unexpected reason (eg. division by zero), and of ensuring that test<br>executions are hermetically sealed without data leaking between test<br>instances.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160312/f6d033f0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March 12, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sat, Mar 12, 2016 at 4:28 PM, Jonathan Tang via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of<br>&gt;&gt; preconditions. Without them, I believe we are leaving many holes in our<br>&gt;&gt; tests and coverage. The solution found in the Swift project of forking the<br>&gt;&gt; process seems fairly complicated to implement in XCTest.<br>&gt;&gt;<br>&gt;&gt; I found a solution online that works by overriding the precondition<br>&gt;&gt; function with a function that calls a configurable closure which defaults to<br>&gt;&gt; the original precondition function. It would be great if the Standard<br>&gt;&gt; Library allowed this by default so that XCTest could use it to offer full<br>&gt;&gt; support for precondition unit tests.<br>&gt;&gt;<br>&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;<br>&gt;&gt; Is this imaginable?<br>&gt;<br>&gt;<br>&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the<br>&gt; specific solution.  Are there performance or security impacts to production<br>&gt; code by having this?  Could the forked-process solution be implemented once<br>&gt; in a framework and then everybody just uses it transparently?  The<br>&gt; forked-process approach also has the advantage of catching crashes for any<br>&gt; other unexpected reason (eg. division by zero), and of ensuring that test<br>&gt; executions are hermetically sealed without data leaking between test<br>&gt; instances.<br></p><p>I completely agree that the approach that uses process isolation is<br>the right way to go, not just for testing preconditions, but for all<br>other reasons you mention.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>March 13, 2016 at 08:00:00am</p></header><div class="content"><p>I’m unsure about this; a precondition should validate that a method has been called correctly, so if it fails then it may indicate a flaw with your test, so it makes sense for it to stop. You can use assert() to also test for edge-cases within your method that could have unexpected results (due to implementation details). The unit test meanwhile should just pass in valid input, and test for expected output. At least that’s how I try to do it, i.e- with a unit test doing black-box testing only, and assert() handling white-box testing (implementation details and edge cases that could affect them). This leaves the precondition to check input; if one fails then it indicates a very basic error that may invalidate your remaining tests anyway.<br></p><p><br>If you do want to handle them however, then it seems like a compiler option to replace them with thrown errors might make most sense; this would mean duplicating code with preconditions (or that calls such methods) so that there’s one path with thrown preconditions and one without, the compiler can then select which path to use based upon the call-site in your unit test (e.g- if you have a catch block for PreconditionError, or an attribute like @preconditionError or something), and discard any paths that aren’t used. It’s a complex option, but it would definitely work, and would only be enabled when testing by default.<br></p><p>&gt; On 13 Mar 2016, at 00:32, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; On Sat, Mar 12, 2016 at 4:28 PM, Jonathan Tang via swift-evolution<br>&gt; &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of<br>&gt;&gt;&gt; preconditions. Without them, I believe we are leaving many holes in our<br>&gt;&gt;&gt; tests and coverage. The solution found in the Swift project of forking the<br>&gt;&gt;&gt; process seems fairly complicated to implement in XCTest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I found a solution online that works by overriding the precondition<br>&gt;&gt;&gt; function with a function that calls a configurable closure which defaults to<br>&gt;&gt;&gt; the original precondition function. It would be great if the Standard<br>&gt;&gt;&gt; Library allowed this by default so that XCTest could use it to offer full<br>&gt;&gt;&gt; support for precondition unit tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this imaginable?<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the<br>&gt;&gt; specific solution.  Are there performance or security impacts to production<br>&gt;&gt; code by having this?  Could the forked-process solution be implemented once<br>&gt;&gt; in a framework and then everybody just uses it transparently?  The<br>&gt;&gt; forked-process approach also has the advantage of catching crashes for any<br>&gt;&gt; other unexpected reason (eg. division by zero), and of ensuring that test<br>&gt;&gt; executions are hermetically sealed without data leaking between test<br>&gt;&gt; instances.<br>&gt; <br>&gt; I completely agree that the approach that uses process isolation is<br>&gt; the right way to go, not just for testing preconditions, but for all<br>&gt; other reasons you mention.<br>&gt; <br>&gt; Dmitri<br>&gt; <br>&gt; -- <br>&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com &lt;mailto:gribozavr at gmail.com&gt;&gt;*/<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/b415b86b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 13, 2016 at 10:00:00am</p></header><div class="content"><p>I don&#39;t agree because as soon as you have complicated preconditions, you will have bugs in them which need unit testing. As recently as Friday, the approach on Stack Overflow allowed me to test and uncover several bugs/holes in my preconditions.<br></p><p>&gt; On 13 Mar 2016, at 09:40, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I’m unsure about this; a precondition should validate that a method has been called correctly, so if it fails then it may indicate a flaw with your test, so it makes sense for it to stop. You can use assert() to also test for edge-cases within your method that could have unexpected results (due to implementation details). The unit test meanwhile should just pass in valid input, and test for expected output. At least that’s how I try to do it, i.e- with a unit test doing black-box testing only, and assert() handling white-box testing (implementation details and edge cases that could affect them). This leaves the precondition to check input; if one fails then it indicates a very basic error that may invalidate your remaining tests anyway.<br>&gt; <br>&gt; <br>&gt; If you do want to handle them however, then it seems like a compiler option to replace them with thrown errors might make most sense; this would mean duplicating code with preconditions (or that calls such methods) so that there’s one path with thrown preconditions and one without, the compiler can then select which path to use based upon the call-site in your unit test (e.g- if you have a catch block for PreconditionError, or an attribute like @preconditionError or something), and discard any paths that aren’t used. It’s a complex option, but it would definitely work, and would only be enabled when testing by default.<br>&gt; <br>&gt;&gt; On 13 Mar 2016, at 00:32, Dmitri Gribenko via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Sat, Mar 12, 2016 at 4:28 PM, Jonathan Tang via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution<br>&gt;&gt;&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of<br>&gt;&gt;&gt;&gt; preconditions. Without them, I believe we are leaving many holes in our<br>&gt;&gt;&gt;&gt; tests and coverage. The solution found in the Swift project of forking the<br>&gt;&gt;&gt;&gt; process seems fairly complicated to implement in XCTest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I found a solution online that works by overriding the precondition<br>&gt;&gt;&gt;&gt; function with a function that calls a configurable closure which defaults to<br>&gt;&gt;&gt;&gt; the original precondition function. It would be great if the Standard<br>&gt;&gt;&gt;&gt; Library allowed this by default so that XCTest could use it to offer full<br>&gt;&gt;&gt;&gt; support for precondition unit tests.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is this imaginable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the<br>&gt;&gt;&gt; specific solution.  Are there performance or security impacts to production<br>&gt;&gt;&gt; code by having this?  Could the forked-process solution be implemented once<br>&gt;&gt;&gt; in a framework and then everybody just uses it transparently?  The<br>&gt;&gt;&gt; forked-process approach also has the advantage of catching crashes for any<br>&gt;&gt;&gt; other unexpected reason (eg. division by zero), and of ensuring that test<br>&gt;&gt;&gt; executions are hermetically sealed without data leaking between test<br>&gt;&gt;&gt; instances.<br>&gt;&gt; <br>&gt;&gt; I completely agree that the approach that uses process isolation is<br>&gt;&gt; the right way to go, not just for testing preconditions, but for all<br>&gt;&gt; other reasons you mention.<br>&gt;&gt; <br>&gt;&gt; Dmitri<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>&gt;&gt; (j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/699ea135/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 13, 2016 at 10:00:00am</p></header><div class="content"><p>Okay, perhaps this is not the optimal solution. But I tried to rally enthusiasm for finding a solution using forks a few months back and the complexity of the problem seemed to stall the progress. The issue is important enough for me that I tried to come at it from a different angle. If be more than happy if it was implemented using forks.<br></p><p>&gt; On 13 Mar 2016, at 01:28, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br>&gt;&gt; <br>&gt;&gt; I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br>&gt;&gt; <br>&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt; <br>&gt;&gt; Is this imaginable?<br>&gt; <br>&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the specific solution.  Are there performance or security impacts to production code by having this?  Could the forked-process solution be implemented once in a framework and then everybody just uses it transparently?  The forked-process approach also has the advantage of catching crashes for any other unexpected reason (eg. division by zero), and of ensuring that test executions are hermetically sealed without data leaking between test instances.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/76779d2a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5c9df42e3c293e3cdb5f3e1b34d44ef9?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Step C</string> &lt;schristopher at bignerdranch.com&gt;<p>March 13, 2016 at 10:00:00am</p></header><div class="content"><p>I think the forking approach is correct and would like to see more tooling support for that path in test runners. <br></p><p>&gt; On Mar 13, 2016, at 5:20 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Okay, perhaps this is not the optimal solution. But I tried to rally enthusiasm for finding a solution using forks a few months back and the complexity of the problem seemed to stall the progress. The issue is important enough for me that I tried to come at it from a different angle. If be more than happy if it was implemented using forks.<br>&gt; <br>&gt;&gt; On 13 Mar 2016, at 01:28, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is this imaginable?<br>&gt;&gt; <br>&gt;&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the specific solution.  Are there performance or security impacts to production code by having this?  Could the forked-process solution be implemented once in a framework and then everybody just uses it transparently?  The forked-process approach also has the advantage of catching crashes for any other unexpected reason (eg. division by zero), and of ensuring that test executions are hermetically sealed without data leaking between test instances.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/cea6b5fd/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>March 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I think keeping the code running in a separate process with probes may be something really useful in the unit testing toolbox for sure. How far did your experiment/proposal with that went?<br></p><p>Sent from my iPhone<br></p><p>&gt; On 13 Mar 2016, at 14:27, Step C via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think the forking approach is correct and would like to see more tooling support for that path in test runners. <br>&gt; <br>&gt;&gt; On Mar 13, 2016, at 5:20 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Okay, perhaps this is not the optimal solution. But I tried to rally enthusiasm for finding a solution using forks a few months back and the complexity of the problem seemed to stall the progress. The issue is important enough for me that I tried to come at it from a different angle. If be more than happy if it was implemented using forks.<br>&gt;&gt; <br>&gt;&gt;&gt; On 13 Mar 2016, at 01:28, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is this imaginable?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the specific solution.  Are there performance or security impacts to production code by having this?  Could the forked-process solution be implemented once in a framework and then everybody just uses it transparently?  The forked-process approach also has the advantage of catching crashes for any other unexpected reason (eg. division by zero), and of ensuring that test executions are hermetically sealed without data leaking between test instances.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/4e084bcb/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March 13, 2016 at 10:00:00pm</p></header><div class="content"><p>As I&#39;m not technically knowledgable enough in low-level process handling and about the intricacies of xctest, I can&#39;t write a proposal that stands on it&#39;s own feet. All I can do is talk about it until someone that is can work on it.<br></p><p>&gt; On 13 Mar 2016, at 20:36, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; I think keeping the code running in a separate process with probes may be something really useful in the unit testing toolbox for sure. How far did your experiment/proposal with that went?<br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 13 Mar 2016, at 14:27, Step C via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I think the forking approach is correct and would like to see more tooling support for that path in test runners. <br>&gt;&gt; <br>&gt;&gt;&gt; On Mar 13, 2016, at 5:20 AM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Okay, perhaps this is not the optimal solution. But I tried to rally enthusiasm for finding a solution using forks a few months back and the complexity of the problem seemed to stall the progress. The issue is important enough for me that I tried to come at it from a different angle. If be more than happy if it was implemented using forks.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 13 Mar 2016, at 01:28, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Sat, Mar 12, 2016 at 1:41 PM, David Hart via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; I am deeply interested in finding solutions for allowing unit-tests of preconditions. Without them, I believe we are leaving many holes in our tests and coverage. The solution found in the Swift project of forking the process seems fairly complicated to implement in XCTest.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; I found a solution online that works by overriding the precondition function with a function that calls a configurable closure which defaults to the original precondition function. It would be great if the Standard Library allowed this by default so that XCTest could use it to offer full support for precondition unit tests.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; http://stackoverflow.com/a/31349339<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Is this imaginable?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; +1 to this being an important problem to solve, but I&#39;m not sure about the specific solution.  Are there performance or security impacts to production code by having this?  Could the forked-process solution be implemented once in a framework and then everybody just uses it transparently?  The forked-process approach also has the advantage of catching crashes for any other unexpected reason (eg. division by zero), and of ensuring that test executions are hermetically sealed without data leaking between test instances.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160313/9f56ed5b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>March 13, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; The forked-process approach also has the advantage of catching crashes for any other unexpected reason (eg. division by zero), and of ensuring that test executions are hermetically sealed without data leaking between test instances.<br></p><p>If by &quot;forked-process approach&quot; you mean putting code like this in XCTest:<br></p><p>	func XCTAssertPreconditionsPass(_ expression: Void -&gt; Void, _ message: String) {<br>		let childPid = fork()<br>		switch childPid {<br>		case -1:<br>			XCTFail(&quot;Forking during test \(message) failed&quot;)<br>		case 0:<br>			expression()<br>			exit(0)<br>		default:<br>			var status: Int32 = 0<br>			guard waitpid(childPid, &amp;status, 0) &gt; 0 else {<br>				fatalError(&quot;XCTAssertPreconditionsPass waitpid() failed!&quot;)<br>			}<br>			if status != 0 {<br>				XCTFail(message)<br>			}<br>		}<br>	}<br></p><p>I don&#39;t think that&#39;s going to work in practice. Apple Foundation (and I believe CF as well) don&#39;t support forking unless you immediately exec() &lt;http://lists.apple.com/archives/cocoa-dev/2007/Oct/msg01237.html&gt;. Even if XCTest could communicate with the subprocesses without using Foundation, many of the tests themselves would use Foundation; having tests fail because of the test harness&#39;s implementation is probably not acceptable.<br></p><p>It might be possible to run whole tests, rather than individual assertions, by fork/exec-ing our harness with a command-line flag indicating the test to run, but we would need a way to mark the tests which ought to be treated this way. (Or we could run every test in a sub-process, but that seems like it would introduce significant overhead.)<br></p><p>With the assistance of the compiler, we might be able to have precondition() and friends throw C++ exceptions in builds with testability enabled, and then have XCTest call into some C++ glue to wrap a try/catch block around the expression. This would leave a trail of leaked objects and broken invariants in its wake, but the damage might not matter for many simple tests.<br></p><p>Ultimately, I think what this proposal is about is catching universal errors &lt;https://github.com/apple/swift/blob/master/docs/ErrorHandlingRationale.rst#universal-errors&gt;. There&#39;s no mechanism to do that in Swift right now, but there *is* a general understanding that we&#39;ll probably need something eventually. We may not have a better option than to defer precondition testing until we have those.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Solving the issue of unit-testing precondition with the Standard Library?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>March 13, 2016 at 04:00:00pm</p></header><div class="content"><p>On Sun, Mar 13, 2016 at 3:32 PM, Brent Royal-Gordon via<br>swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; It might be possible to run whole tests, rather than individual assertions, by fork/exec-ing our harness<br></p><p>This is exactly what is being proposed.<br></p><p>&gt; with a command-line flag indicating the test to run, but we would need a way to mark the tests which ought to be treated this way. (Or we could run every test in a sub-process, but that seems like it would introduce significant overhead.)<br></p><p>I think we should measure first and then make conclusions.  By the<br>way, I highly recommend everyone to take a look at StdlibUnittest,<br>where this approach is already implemented and works well for testing<br>preconditions in the standard library.  StdlibUnittest just keeps a<br>worker process running, asking it to run tests one by one until it<br>crashes, and then starts a new one.<br></p><p>&gt; With the assistance of the compiler, we might be able to have precondition() and friends throw C++ exceptions in builds with testability enabled,<br></p><p>That would immediately lead to undefined behavior, not just leaks.  If<br>the code does not expect to continue, then the optimizer will make all<br>sorts of assumptions about that, and we don&#39;t want to inflict<br>debugging that mess onto our users.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
