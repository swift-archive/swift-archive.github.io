<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 10, 2016 at 02:00:00am</p></header><div class="content"><p>Here is a contrived reduction of my problem<br></p><p>func mainFunction(closure:(Int) -&gt; Int) -&gt; Int {<br></p><p><br>    func closureDoubled(_ n: Int) -&gt; Int {<br></p><p>        let result = closure(n)<br></p><p>        return 2*result<br></p><p>    }<br></p><p><br>    let temp1 = closure(1)<br></p><p>    let temp2 = closureDoubled(1)<br></p><p>    return temp1+temp2<br></p><p>}<br></p><p>The line &quot;let result = closure(n)&quot; is refused by the compiler with the<br>error message &quot;declaration over non closing parameter may allow it to<br>escape&quot;.<br></p><p>First off, while I know what an escaping or a non-escaping closure is, I<br>find this error message utterly impossible to understand. To begin with,<br>the sentence &quot;non closing parameter&quot; is meaningless to me.<br></p><p>In any case, my main function is passed a non-escaping closure. I want to<br>call it from inside it, the compiler is ok with. I want also to call it<br>from a nested function, but the compiler disagrees.<br></p><p>I believe the compiler should not complain here. Did I miss anything?<br></p><p>Jean-Denis<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/54f05504/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>October 10, 2016 at 08:00:00am</p></header><div class="content"><p>I changed you code `let result = closure(n)` to `let result = closure(1)`.<br>I thought that should eliminate the error. It didn&#39;t. The compiler asked me<br>to change the whole code as below:<br></p><p>func mainFunction(closure: @escaping (Int) -&gt; Int) -&gt; Int {<br></p><p><br></p><p>    func closureDoubled(_ n: Int) -&gt; Int {<br></p><p>        let result = closure(1)<br></p><p>        return 2*result<br></p><p>    }<br></p><p><br></p><p>    let temp1 = closure(1)<br></p><p>    let temp2 = closureDoubled(1)<br></p><p>    return temp1+temp2<br></p><p>}<br></p><p><br>So I think in `func closureDoubled(_ n: Int) -&gt; Int`, the `closure` is<br>escaping other than non-escaping. The result is not calculated inside the<br>function `closureDoubled`, it was calculated at `return temp1+temp2`, that<br>is what I think can explain the behavior.<br></p><p><br>I don&#39;t know why at first. It just like there were two ways to do the job,<br>you thought it worked in this way, but it chose the other way. Both ways<br>lead to the same result.<br></p><p><br>Then I changed your code to<br></p><p><br>func mainFunction2(closure:  (Int) -&gt; Int) -&gt; Int {<br></p><p><br></p><p>    func closureDoubled(_ n: Int, closure2:(Int) -&gt; Int) -&gt; Int {<br></p><p>        let result = closure2(1)<br></p><p>        return 2*result<br></p><p>    }<br></p><p><br></p><p>    let temp1 = closure(1)<br></p><p>    let temp2 = closureDoubled(1, closure2: closure)<br></p><p>    return temp1+temp2<br></p><p>}<br></p><p><br>Everything works as expected now. So I think the reason is just because of<br>`closure` was not define in `func closureDoubled` in the first<br>code snippet. It was defined outside, so it was escaping. What do you think?<br></p><p><br>Zhaoxin<br></p><p>On Mon, Oct 10, 2016 at 8:07 AM, Jean-Denis Muys via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; Here is a contrived reduction of my problem<br>&gt;<br>&gt; func mainFunction(closure:(Int) -&gt; Int) -&gt; Int {<br>&gt;<br>&gt;<br>&gt;     func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;<br>&gt;         let result = closure(n)<br>&gt;<br>&gt;         return 2*result<br>&gt;<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     let temp1 = closure(1)<br>&gt;<br>&gt;     let temp2 = closureDoubled(1)<br>&gt;<br>&gt;     return temp1+temp2<br>&gt;<br>&gt; }<br>&gt;<br>&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the<br>&gt; error message &quot;declaration over non closing parameter may allow it to<br>&gt; escape&quot;.<br>&gt;<br>&gt; First off, while I know what an escaping or a non-escaping closure is, I<br>&gt; find this error message utterly impossible to understand. To begin with,<br>&gt; the sentence &quot;non closing parameter&quot; is meaningless to me.<br>&gt;<br>&gt; In any case, my main function is passed a non-escaping closure. I want to<br>&gt; call it from inside it, the compiler is ok with. I want also to call it<br>&gt; from a nested function, but the compiler disagrees.<br>&gt;<br>&gt; I believe the compiler should not complain here. Did I miss anything?<br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/ad76f9b8/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function: Bug?</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>It seems to me you are shooting while blindfolded.<br></p><p>&gt; I changed you code `let result = closure(n)` to `let result = closure(1)`. I thought that should eliminate the error. It didn&#39;t. The compiler asked me to change the whole code as below:<br></p><p><br>Why did you expect changing which argument to send the closure to make any difference?<br></p><p>&gt; func mainFunction(closure: @escaping (Int) -&gt; Int) -&gt; Int {<br></p><p><br>Sure declaring the closure as escaping shuts up the compiler. At the cost of having an escaping closure in a context where the closure is guaranteed no to escape. My understanding of the distinction between escaping and non escaping is it enables compiler optimisations (in the non escaping case) that would not be possible in the general case. Therefore this compiler-mandated change kills performance for nothing<br></p><p><br>&gt; So I think in `func closureDoubled(_ n: Int) -&gt; Int`, the `closure` is escaping other than non-escaping.<br></p><p>No. The closure is not escaping. At least as far as I can see. Can you point out where it is escaping? Declaring a closure as escaping does not make it so. It only *allows* it to escape.<br></p><p>Note that here, “escaping” means escaping the scope where it is declared, i.e. the `mainFunction` function. Clearly, it does not.<br></p><p><br>&gt;  The result is not calculated inside the function `closureDoubled`, it was calculated at `return temp1+temp2`, that is what I think can explain the behavior. <br></p><p><br>Where does this speculation comes from? It totally contradicts the story that the source code tells. temp1 and temp2 and Int variables that are local to `mainFunction `, while `result` is local to the nested function `closureDoubled`. Unless you use of the word “result” does not refer to the `result` variable. I apologise for the poor choice of variable names that made possible this confusion.<br></p><p>&gt; I don&#39;t know why at first. It just like there were two ways to do the job, you thought it worked in this way, but it chose the other way. Both ways lead to the same result.<br></p><p>You lost me in that sentence. What do the pronouns refer to?<br></p><p>&gt; Then I changed your code to <br></p><p>yes you totally changed my code by adding a closure parameter to the nested function, in which you passed the closure that was passed to the outer function.<br></p><p>By doing so, however, you altered significantly my use case. This is because the point of having a nested function, as opposed to a separate function defined outside the outer function, is for the nested function to capture the environment of its containing function.<br></p><p>Of course, this begs the question: this is semantically equivalent, so why objecting to that? There are two answers to that question:<br></p><p>1- preventing a nested function from capturing a local closure is a significant limitation which essentially demotes closure from the status of first-class citizen. The artificial limitation of expressiveness in the language is unwarranted and a serious flaw (if intended. I still believe this is a bug)<br>2- A very common pattern for nested functions is to make recursive algorithms more memory-efficient by forwarding the recursion to a nested function whose parameters are only those values that change during the recursion. Other values, such as the parameter you just added in your change, if passed as parameters, will only waste stack space since they will never change in the recursion. This will also degrade performance slightly because the code will have to push this unchanging value to the stack every time a recursive call is made.<br></p><p>Note that this was the context where I was bitten by the problem. Of course, you could expect a smart compiler to recognise that is doesn’t have to push unchanging parameter values onto the stack in recursive calls. Similarly, there are smart compiler which recognise terminal recursion and transform recursion into iteration. I even encountered in the past (Lisp) compilers which automatically transformed simple cases of non-terminal recursion into terminal-recursive versions (by adding an accumulator parameter), followed by transformation into iterative code. I do not expect typical compilers to do that (where “typical” is left undefined, but would include GCC, Clang, Swift). This is why I tend to implement my recursive calls in the way just described.<br></p><p>&gt; Everything works as expected now.<br></p><p>Expected, perhaps. As intended, certainly not.<br></p><p>&gt; So I think the reason is just because of `closure` was not define in `func closureDoubled` in the first code snippet. It was defined outside, so it was escaping. What do you think?<br></p><p>I think this explanation does not make sense to me. Maybe I am missing something. Could you possibly detail what you mean?<br></p><p>Thank you very much for your attempts. It’s possible something is escaping me (pun intended). But I still believe this is a bug in the compiler, if not in the language.<br></p><p>Best regards.<br></p><p>Jean-Denis<br></p><p><br></p><p><br>&gt; On 10 Oct 2016, at 02:45, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt; <br>&gt; I changed you code `let result = closure(n)` to `let result = closure(1)`. I thought that should eliminate the error. It didn&#39;t. The compiler asked me to change the whole code as below:<br>&gt; <br>&gt; func mainFunction(closure: @escaping (Int) -&gt; Int) -&gt; Int {<br>&gt;     <br>&gt;     func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;         let result = closure(1)<br>&gt;         return 2*result<br>&gt;     }<br>&gt;     <br>&gt;     let temp1 = closure(1)<br>&gt;     let temp2 = closureDoubled(1)<br>&gt;     return temp1+temp2<br>&gt; }<br>&gt; <br>&gt; So I think in `func closureDoubled(_ n: Int) -&gt; Int`, the `closure` is escaping other than non-escaping. The result is not calculated inside the function `closureDoubled`, it was calculated at `return temp1+temp2`, that is what I think can explain the behavior. <br>&gt; <br>&gt; I don&#39;t know why at first. It just like there were two ways to do the job, you thought it worked in this way, but it chose the other way. Both ways lead to the same result.<br>&gt; <br>&gt; Then I changed your code to <br>&gt; <br>&gt; func mainFunction2(closure:  (Int) -&gt; Int) -&gt; Int {<br>&gt;     <br>&gt;     func closureDoubled(_ n: Int, closure2:(Int) -&gt; Int) -&gt; Int {<br>&gt;         let result = closure2(1)<br>&gt;         return 2*result<br>&gt;     }<br>&gt;     <br>&gt;     let temp1 = closure(1)<br>&gt;     let temp2 = closureDoubled(1, closure2: closure)<br>&gt;     return temp1+temp2<br>&gt; }<br>&gt; <br>&gt; Everything works as expected now. So I think the reason is just because of `closure` was not define in `func closureDoubled` in the first code snippet. It was defined outside, so it was escaping. What do you think?<br>&gt; <br>&gt; Zhaoxin<br>&gt; <br>&gt; On Mon, Oct 10, 2016 at 8:07 AM, Jean-Denis Muys via swift-users &lt;swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;&gt; wrote:<br>&gt; Here is a contrived reduction of my problem<br>&gt; <br>&gt; func mainFunction(closure:(Int) -&gt; Int) -&gt; Int {<br>&gt; <br>&gt;     func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;         let result = closure(n)<br>&gt;         return 2*result<br>&gt;     }<br>&gt; <br>&gt;     let temp1 = closure(1)<br>&gt;     let temp2 = closureDoubled(1)<br>&gt;     return temp1+temp2<br>&gt; }<br>&gt; <br>&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the error message &quot;declaration over non closing parameter may allow it to escape&quot;.<br>&gt; <br>&gt; First off, while I know what an escaping or a non-escaping closure is, I find this error message utterly impossible to understand. To begin with, the sentence &quot;non closing parameter&quot; is meaningless to me.<br>&gt; <br>&gt; In any case, my main function is passed a non-escaping closure. I want to call it from inside it, the compiler is ok with. I want also to call it from a nested function, but the compiler disagrees.<br>&gt; <br>&gt; I believe the compiler should not complain here. Did I miss anything?<br>&gt; <br>&gt; Jean-Denis<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org &lt;mailto:swift-users at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users &lt;https://lists.swift.org/mailman/listinfo/swift-users&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/88de683b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function: Bug?</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>October 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; It is just like there were two ways to do the job, you thought it worked<br>in this way, but it chose the other way. Both ways lead to the same result.<br></p><p>I think it is because the compiler **flatten** your inner function instead<br>of calculated the result.<br></p><p>The variable scope of `closure` is outside the `func closureDoubled`, so it<br>is `escaping` from that function. However, since `closure` is defined<br>outside, there is no place in `func closureDoubled` mark as `@escaping`, so<br>the compiler asked me to add `@escaping` in the place where it is firstly<br>defined.<br></p><p>Zhaoxin<br></p><p><br></p><p>On Mon, Oct 10, 2016 at 4:06 PM, Jean-Denis Muys &lt;jdmuys at gmail.com&gt; wrote:<br></p><p>&gt; It seems to me you are shooting while blindfolded.<br>&gt;<br>&gt; I changed you code `let result = closure(n)` to `let result = closure(1)`.<br>&gt; I thought that should eliminate the error. It didn&#39;t. The compiler asked me<br>&gt; to change the whole code as below:<br>&gt;<br>&gt;<br>&gt; Why did you expect changing which argument to send the closure to make any<br>&gt; difference?<br>&gt;<br>&gt; func mainFunction(closure: @escaping (Int) -&gt; Int) -&gt; Int {<br>&gt;<br>&gt;<br>&gt; Sure declaring the closure as escaping shuts up the compiler. At the cost<br>&gt; of having an escaping closure in a context where the closure is guaranteed<br>&gt; no to escape. My understanding of the distinction between escaping and non<br>&gt; escaping is it enables compiler optimisations (in the non escaping case)<br>&gt; that would not be possible in the general case. Therefore this<br>&gt; compiler-mandated change kills performance for nothing<br>&gt;<br>&gt;<br>&gt; So I think in `func closureDoubled(_ n: Int) -&gt; Int`, the `closure` is<br>&gt; escaping other than non-escaping.<br>&gt;<br>&gt;<br>&gt; No. The closure is not escaping. At least as far as I can see. Can you<br>&gt; point out where it is escaping? Declaring a closure as escaping does not<br>&gt; make it so. It only *allows* it to escape.<br>&gt;<br>&gt; Note that here, “escaping” means escaping the scope where it is declared,<br>&gt; i.e. the `mainFunction` function. Clearly, it does not.<br>&gt;<br>&gt;<br>&gt;  The result is not calculated inside the function `closureDoubled`, it<br>&gt; was calculated at `return temp1+temp2`, that is what I think can explain<br>&gt; the behavior.<br>&gt;<br>&gt;<br>&gt; Where does this speculation comes from? It totally contradicts the story<br>&gt; that the source code tells. temp1 and temp2 and Int variables that are<br>&gt; local to `mainFunction `, while `result` is local to the nested function<br>&gt; `closureDoubled`. Unless you use of the word “result” does not refer to the<br>&gt; `result` variable. I apologise for the poor choice of variable names that<br>&gt; made possible this confusion.<br>&gt;<br>&gt; I don&#39;t know why at first. It just like there were two ways to do the job,<br>&gt; you thought it worked in this way, but it chose the other way. Both ways<br>&gt; lead to the same result.<br>&gt;<br>&gt;<br>&gt; You lost me in that sentence. What do the pronouns refer to?<br>&gt;<br>&gt; Then I changed your code to<br>&gt;<br>&gt;<br>&gt; yes you totally changed my code by adding a closure parameter to the<br>&gt; nested function, in which you passed the closure that was passed to the<br>&gt; outer function.<br>&gt;<br>&gt; By doing so, however, you altered significantly my use case. This is<br>&gt; because the point of having a nested function, as opposed to a separate<br>&gt; function defined outside the outer function, is for the nested function to<br>&gt; capture the environment of its containing function.<br>&gt;<br>&gt; Of course, this begs the question: this is semantically equivalent, so why<br>&gt; objecting to that? There are two answers to that question:<br>&gt;<br>&gt; 1- preventing a nested function from capturing a local closure is a<br>&gt; significant limitation which essentially demotes closure from the status of<br>&gt; first-class citizen. The artificial limitation of expressiveness in the<br>&gt; language is unwarranted and a serious flaw (if intended. I still believe<br>&gt; this is a bug)<br>&gt; 2- A very common pattern for nested functions is to make recursive<br>&gt; algorithms more memory-efficient by forwarding the recursion to a nested<br>&gt; function whose parameters are only those values that change during the<br>&gt; recursion. Other values, such as the parameter you just added in your<br>&gt; change, if passed as parameters, will only waste stack space since they<br>&gt; will never change in the recursion. This will also degrade performance<br>&gt; slightly because the code will have to push this unchanging value to the<br>&gt; stack every time a recursive call is made.<br>&gt;<br>&gt; Note that this was the context where I was bitten by the problem. Of<br>&gt; course, you could expect a smart compiler to recognise that is doesn’t have<br>&gt; to push unchanging parameter values onto the stack in recursive calls.<br>&gt; Similarly, there are smart compiler which recognise terminal recursion and<br>&gt; transform recursion into iteration. I even encountered in the past (Lisp)<br>&gt; compilers which automatically transformed simple cases of non-terminal<br>&gt; recursion into terminal-recursive versions (by adding an accumulator<br>&gt; parameter), followed by transformation into iterative code. I do not expect<br>&gt; typical compilers to do that (where “typical” is left undefined, but would<br>&gt; include GCC, Clang, Swift). This is why I tend to implement my recursive<br>&gt; calls in the way just described.<br>&gt;<br>&gt; Everything works as expected now.<br>&gt;<br>&gt;<br>&gt; Expected, perhaps. As intended, certainly not.<br>&gt;<br>&gt; So I think the reason is just because of `closure` was not define in `func<br>&gt; closureDoubled` in the first code snippet. It was defined outside, so it<br>&gt; was escaping. What do you think?<br>&gt;<br>&gt;<br>&gt; I think this explanation does not make sense to me. Maybe I am missing<br>&gt; something. Could you possibly detail what you mean?<br>&gt;<br>&gt; Thank you very much for your attempts. It’s possible something is escaping<br>&gt; me (pun intended). But I still believe this is a bug in the compiler, if<br>&gt; not in the language.<br>&gt;<br>&gt; Best regards.<br>&gt;<br>&gt; Jean-Denis<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On 10 Oct 2016, at 02:45, Zhao Xin &lt;owenzx at gmail.com&gt; wrote:<br>&gt;<br>&gt; I changed you code `let result = closure(n)` to `let result = closure(1)`.<br>&gt; I thought that should eliminate the error. It didn&#39;t. The compiler asked me<br>&gt; to change the whole code as below:<br>&gt;<br>&gt; func mainFunction(closure: @escaping (Int) -&gt; Int) -&gt; Int {<br>&gt;<br>&gt;<br>&gt;     func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;         let result = closure(1)<br>&gt;         return 2*result<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     let temp1 = closure(1)<br>&gt;     let temp2 = closureDoubled(1)<br>&gt;     return temp1+temp2<br>&gt; }<br>&gt;<br>&gt; So I think in `func closureDoubled(_ n: Int) -&gt; Int`, the `closure` is<br>&gt; escaping other than non-escaping. The result is not calculated inside the<br>&gt; function `closureDoubled`, it was calculated at `return temp1+temp2`,<br>&gt; that is what I think can explain the behavior.<br>&gt;<br>&gt; I don&#39;t know why at first. It just like there were two ways to do the job,<br>&gt; you thought it worked in this way, but it chose the other way. Both ways<br>&gt; lead to the same result.<br>&gt;<br>&gt; Then I changed your code to<br>&gt;<br>&gt; func mainFunction2(closure:  (Int) -&gt; Int) -&gt; Int {<br>&gt;<br>&gt;<br>&gt;     func closureDoubled(_ n: Int, closure2:(Int) -&gt; Int) -&gt; Int {<br>&gt;         let result = closure2(1)<br>&gt;         return 2*result<br>&gt;     }<br>&gt;<br>&gt;<br>&gt;     let temp1 = closure(1)<br>&gt;     let temp2 = closureDoubled(1, closure2: closure)<br>&gt;     return temp1+temp2<br>&gt;<br>&gt; }<br>&gt;<br>&gt; Everything works as expected now. So I think the reason is just because of<br>&gt; `closure` was not define in `func closureDoubled` in the first<br>&gt; code snippet. It was defined outside, so it was escaping. What do you think?<br>&gt;<br>&gt; Zhaoxin<br>&gt;<br>&gt; On Mon, Oct 10, 2016 at 8:07 AM, Jean-Denis Muys via swift-users &lt;<br>&gt; swift-users at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Here is a contrived reduction of my problem<br>&gt;&gt;<br>&gt;&gt; func mainFunction(closure:(Int) -&gt; Int) -&gt; Int {<br>&gt;&gt;<br>&gt;&gt;     func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;&gt;         let result = closure(n)<br>&gt;&gt;         return 2*result<br>&gt;&gt;     }<br>&gt;&gt;<br>&gt;&gt;     let temp1 = closure(1)<br>&gt;&gt;     let temp2 = closureDoubled(1)<br>&gt;&gt;     return temp1+temp2<br>&gt;&gt; }<br>&gt;&gt;<br>&gt;&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the<br>&gt;&gt; error message &quot;declaration over non closing parameter may allow it to<br>&gt;&gt; escape&quot;.<br>&gt;&gt;<br>&gt;&gt; First off, while I know what an escaping or a non-escaping closure is, I<br>&gt;&gt; find this error message utterly impossible to understand. To begin with,<br>&gt;&gt; the sentence &quot;non closing parameter&quot; is meaningless to me.<br>&gt;&gt;<br>&gt;&gt; In any case, my main function is passed a non-escaping closure. I want to<br>&gt;&gt; call it from inside it, the compiler is ok with. I want also to call it<br>&gt;&gt; from a nested function, but the compiler disagrees.<br>&gt;&gt;<br>&gt;&gt; I believe the compiler should not complain here. Did I miss anything?<br>&gt;&gt;<br>&gt;&gt; Jean-Denis<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-users mailing list<br>&gt;&gt; swift-users at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/fdf06025/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>October 10, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the<br>&gt; error message &quot;declaration over non closing parameter may allow it to<br>&gt; escape&quot;.<br>&gt;<br>&gt; First off, while I know what an escaping or a non-escaping closure is, I<br>&gt; find this error message utterly impossible to understand. To begin with,<br>&gt; the sentence &quot;non closing parameter&quot; is meaningless to me.<br></p><p>The error message I&#39;m seeing in Xcode 8.0 is &quot;Declaration closing over <br>*non-escaping* parameter &#39;closure&#39; may allow it to escape&quot;, so I don&#39;t <br>know where you&#39;re seeing the &quot;non closing parameter&quot;. And &quot;non-escaping <br>parameter&quot; does make a lot more sense, I think.<br></p><p>&gt; In any case, my main function is passed a non-escaping closure. I want<br>&gt; to call it from inside it, the compiler is ok with. I want also to call<br>&gt; it from a nested function, but the compiler disagrees.<br>&gt;<br>&gt; I believe the compiler should not complain here. Did I miss anything?<br></p><p>I think the error message is actually quite good, given that the <br>compiler apparently is taking some shortcuts to prove that a parameter <br>doesn&#39;t escape.<br></p><p>By declaring a function that closes over the non-escaping parameter, <br>you&#39;re creating a situation that *may* allow the non-escaping closure to <br>escape, i.e. the compiler can&#39;t guarantee anymore that it won&#39;t escape. <br>For example, you could do assign the `closureDoubled` function to a <br>variable that&#39;s outside the scope of `mainFunction`:<br></p><p>     // Variable outside the scope of mainFunction<br>     var f: (Int) -&gt; (Int) = { $0 }<br></p><p>     func mainFunction(closure: (Int) -&gt; Int) -&gt; Int {<br></p><p>         func closureDoubled(_ n: Int) -&gt; Int {<br>             let result = closure(n)<br>             return 2*result<br>         }<br></p><p>         // closure would escape here<br>         f = closureDoubled<br>	...<br>     }<br></p><p>     mainFunction { $0 }<br>     f(5)<br></p><p>If this were allowed, `closure` would be able to escape. I think this <br>possibility explains the error message.<br></p><p>Now the compiler *could* of course check for this and I think you&#39;re <br>right in arguing that it *should* ideally perform more sophisticated <br>checks, but since it currently seems to be taking some shortcuts in <br>guaranteeing that a parameter doesn&#39;t escape, it has to disallow <br>anything it can&#39;t verify as correct.<br></p><p>Ole<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/957b675456a66c394945a7361aedd51d?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Zhao Xin</string> &lt;owenzx at gmail.com&gt;<p>October 10, 2016 at 07:00:00pm</p></header><div class="content"><p>Thank you, Ole. Your reply teaches me a lot.<br></p><p>Zhaoxin<br></p><p>On Mon, Oct 10, 2016 at 6:52 PM, Ole Begemann via swift-users &lt;<br>swift-users at swift.org&gt; wrote:<br></p><p>&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the<br>&gt;&gt; error message &quot;declaration over non closing parameter may allow it to<br>&gt;&gt; escape&quot;.<br>&gt;&gt;<br>&gt;&gt; First off, while I know what an escaping or a non-escaping closure is, I<br>&gt;&gt; find this error message utterly impossible to understand. To begin with,<br>&gt;&gt; the sentence &quot;non closing parameter&quot; is meaningless to me.<br>&gt;&gt;<br>&gt;<br>&gt; The error message I&#39;m seeing in Xcode 8.0 is &quot;Declaration closing over<br>&gt; *non-escaping* parameter &#39;closure&#39; may allow it to escape&quot;, so I don&#39;t know<br>&gt; where you&#39;re seeing the &quot;non closing parameter&quot;. And &quot;non-escaping<br>&gt; parameter&quot; does make a lot more sense, I think.<br>&gt;<br>&gt; In any case, my main function is passed a non-escaping closure. I want<br>&gt;&gt; to call it from inside it, the compiler is ok with. I want also to call<br>&gt;&gt; it from a nested function, but the compiler disagrees.<br>&gt;&gt;<br>&gt;&gt; I believe the compiler should not complain here. Did I miss anything?<br>&gt;&gt;<br>&gt;<br>&gt; I think the error message is actually quite good, given that the compiler<br>&gt; apparently is taking some shortcuts to prove that a parameter doesn&#39;t<br>&gt; escape.<br>&gt;<br>&gt; By declaring a function that closes over the non-escaping parameter,<br>&gt; you&#39;re creating a situation that *may* allow the non-escaping closure to<br>&gt; escape, i.e. the compiler can&#39;t guarantee anymore that it won&#39;t escape. For<br>&gt; example, you could do assign the `closureDoubled` function to a variable<br>&gt; that&#39;s outside the scope of `mainFunction`:<br>&gt;<br>&gt;     // Variable outside the scope of mainFunction<br>&gt;     var f: (Int) -&gt; (Int) = { $0 }<br>&gt;<br>&gt;     func mainFunction(closure: (Int) -&gt; Int) -&gt; Int {<br>&gt;<br>&gt;         func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;             let result = closure(n)<br>&gt;             return 2*result<br>&gt;         }<br>&gt;<br>&gt;         // closure would escape here<br>&gt;         f = closureDoubled<br>&gt;         ...<br>&gt;     }<br>&gt;<br>&gt;     mainFunction { $0 }<br>&gt;     f(5)<br>&gt;<br>&gt; If this were allowed, `closure` would be able to escape. I think this<br>&gt; possibility explains the error message.<br>&gt;<br>&gt; Now the compiler *could* of course check for this and I think you&#39;re right<br>&gt; in arguing that it *should* ideally perform more sophisticated checks, but<br>&gt; since it currently seems to be taking some shortcuts in guaranteeing that a<br>&gt; parameter doesn&#39;t escape, it has to disallow anything it can&#39;t verify as<br>&gt; correct.<br>&gt;<br>&gt; Ole<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-users mailing list<br>&gt; swift-users at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-users<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/3c5a2bcd/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 10, 2016 at 04:00:00pm</p></header><div class="content"><p>Thanks Ole,<br></p><p>You are perfectly right regarding the error message. For some reason, I misread it. I am sorry about that.<br></p><p>The actual error message, as you point out, makes much more sense!<br></p><p>The rest of your explanation makes sense too, except:<br></p><p>When I declare my closure as @noescape, (the default), I explicitly tell the compiler that, despite the fact closing over it *may* allow it to escape, I, the programmer, guarantee that it will not.<br></p><p>I would understand a warning, but I don’t understand that the compiler insists on putting out an error.<br></p><p>So, while the compiler could perhaps, as you say, perform more sophisticated checks, I don’t even request that. I request however, to be able to tell the compiler that I know better.<br></p><p>If I am wrong, and if I still let the closure escape despite my promise, then I made a programming error, and my code can legitimately crash.<br></p><p>This is no different than using the “!” to promise the compiler that an optional is not nil: if I don’t keep my promise, the program crashes.<br></p><p>Last, in presence of a similar warning (instead of an error), a simple way to squelch the warning would be to make the @noescape declaration explicit.<br>This would require un-deprecating it.<br></p><p>I now feel that I should propose that as an evolution.<br></p><p>What do you think?<br></p><p>Jean-Denis<br></p><p><br></p><p><br>&gt; On 10 Oct 2016, at 12:52, Ole Begemann &lt;ole at oleb.net&gt; wrote:<br>&gt; <br>&gt;&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the<br>&gt;&gt; error message &quot;declaration over non closing parameter may allow it to<br>&gt;&gt; escape&quot;.<br>&gt;&gt; <br>&gt;&gt; First off, while I know what an escaping or a non-escaping closure is, I<br>&gt;&gt; find this error message utterly impossible to understand. To begin with,<br>&gt;&gt; the sentence &quot;non closing parameter&quot; is meaningless to me.<br>&gt; <br>&gt; The error message I&#39;m seeing in Xcode 8.0 is &quot;Declaration closing over *non-escaping* parameter &#39;closure&#39; may allow it to escape&quot;, so I don&#39;t know where you&#39;re seeing the &quot;non closing parameter&quot;. And &quot;non-escaping parameter&quot; does make a lot more sense, I think.<br>&gt; <br>&gt;&gt; In any case, my main function is passed a non-escaping closure. I want<br>&gt;&gt; to call it from inside it, the compiler is ok with. I want also to call<br>&gt;&gt; it from a nested function, but the compiler disagrees.<br>&gt;&gt; <br>&gt;&gt; I believe the compiler should not complain here. Did I miss anything?<br>&gt; <br>&gt; I think the error message is actually quite good, given that the compiler apparently is taking some shortcuts to prove that a parameter doesn&#39;t escape.<br>&gt; <br>&gt; By declaring a function that closes over the non-escaping parameter, you&#39;re creating a situation that *may* allow the non-escaping closure to escape, i.e. the compiler can&#39;t guarantee anymore that it won&#39;t escape. For example, you could do assign the `closureDoubled` function to a variable that&#39;s outside the scope of `mainFunction`:<br>&gt; <br>&gt;    // Variable outside the scope of mainFunction<br>&gt;    var f: (Int) -&gt; (Int) = { $0 }<br>&gt; <br>&gt;    func mainFunction(closure: (Int) -&gt; Int) -&gt; Int {<br>&gt; <br>&gt;        func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;            let result = closure(n)<br>&gt;            return 2*result<br>&gt;        }<br>&gt; <br>&gt;        // closure would escape here<br>&gt;        f = closureDoubled<br>&gt; 	...<br>&gt;    }<br>&gt; <br>&gt;    mainFunction { $0 }<br>&gt;    f(5)<br>&gt; <br>&gt; If this were allowed, `closure` would be able to escape. I think this possibility explains the error message.<br>&gt; <br>&gt; Now the compiler *could* of course check for this and I think you&#39;re right in arguing that it *should* ideally perform more sophisticated checks, but since it currently seems to be taking some shortcuts in guaranteeing that a parameter doesn&#39;t escape, it has to disallow anything it can&#39;t verify as correct.<br>&gt; <br>&gt; Ole<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/72fec6ab/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>October 10, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; When I declare my closure as @noescape, (the default), I explicitly tell<br>&gt; the compiler that, despite the fact closing over it *may* allow it to<br>&gt; escape, I, the programmer, guarantee that it will not.<br>&gt;<br>&gt; I would understand a warning, but I don’t understand that the compiler<br>&gt; insists on putting out an error.<br>&gt;<br>&gt; So, while the compiler could perhaps, as you say, perform more<br>&gt; sophisticated checks, I don’t even request that. I request however, to<br>&gt; be able to tell the compiler that I know better.<br>&gt;<br>&gt; If I am wrong, and if I still let the closure escape despite my promise,<br>&gt; then I made a programming error, and my code can legitimately crash.<br></p><p>I wouldn&#39;t like this. I much prefer the current state where this is an <br>error. That said, it would indeed be great if the compiler were smarter <br>when it does the analysis whether a closure actually escapes.<br></p><p>There is already a bug report for this, by the way: SR-2274 [1]<br></p><p>[1]: https://bugs.swift.org/browse/SR-2274<br></p><p>&gt; This is no different than using the “!” to promise the compiler that an<br>&gt; optional is not nil: if I don’t keep my promise, the program crashes.<br>&gt;<br>&gt; Last, in presence of a similar warning (instead of an error), a simple<br>&gt; way to squelch the warning would be to make the @noescape declaration<br>&gt; explicit.<br>&gt; This would require un-deprecating it.<br>&gt;<br>&gt; I now feel that I should propose that as an evolution.<br>&gt;<br>&gt; What do you think?<br></p><p>Again, I don&#39;t think we should go that route. I prefer the status quo.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>October 10, 2016 at 05:00:00pm</p></header><div class="content"><p>So I suppose you feel this case is different from the (unsafe)  implicitly unwrapping of optionals with the “!” operator.<br></p><p>Why do you feel the situation is different?<br></p><p><br>&gt; On 10 Oct 2016, at 17:34, Ole Begemann &lt;ole at oleb.net&gt; wrote:<br>&gt; <br>&gt;&gt; When I declare my closure as @noescape, (the default), I explicitly tell<br>&gt;&gt; the compiler that, despite the fact closing over it *may* allow it to<br>&gt;&gt; escape, I, the programmer, guarantee that it will not.<br>&gt;&gt; <br>&gt;&gt; I would understand a warning, but I don’t understand that the compiler<br>&gt;&gt; insists on putting out an error.<br>&gt;&gt; <br>&gt;&gt; So, while the compiler could perhaps, as you say, perform more<br>&gt;&gt; sophisticated checks, I don’t even request that. I request however, to<br>&gt;&gt; be able to tell the compiler that I know better.<br>&gt;&gt; <br>&gt;&gt; If I am wrong, and if I still let the closure escape despite my promise,<br>&gt;&gt; then I made a programming error, and my code can legitimately crash.<br>&gt; <br>&gt; I wouldn&#39;t like this. I much prefer the current state where this is an error. That said, it would indeed be great if the compiler were smarter when it does the analysis whether a closure actually escapes.<br>&gt; <br>&gt; There is already a bug report for this, by the way: SR-2274 [1]<br>&gt; <br>&gt; [1]: https://bugs.swift.org/browse/SR-2274<br>&gt; <br>&gt;&gt; This is no different than using the “!” to promise the compiler that an<br>&gt;&gt; optional is not nil: if I don’t keep my promise, the program crashes.<br>&gt;&gt; <br>&gt;&gt; Last, in presence of a similar warning (instead of an error), a simple<br>&gt;&gt; way to squelch the warning would be to make the @noescape declaration<br>&gt;&gt; explicit.<br>&gt;&gt; This would require un-deprecating it.<br>&gt;&gt; <br>&gt;&gt; I now feel that I should propose that as an evolution.<br>&gt;&gt; <br>&gt;&gt; What do you think?<br>&gt; <br>&gt; Again, I don&#39;t think we should go that route. I prefer the status quo.<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0efc09d023fa0569a2479c9dcfd4620?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Ole Begemann</string> &lt;ole at oleb.net&gt;<p>October 11, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; So I suppose you feel this case is different from the (unsafe) implicitly unwrapping of optionals with the “!” operator.<br>&gt;<br>&gt; Why do you feel the situation is different?<br></p><p>I agree that it&#39;s a somewhat similar situation, at least if the function <br>declaration were made explicit with a `@nonescaping` keyword as you <br>suggested.<br></p><p>I just think features like force-unwrapping of optionals should remain <br>the exception, not the rule. Just because most people will agree (I <br>assume) that force-unwrapping is useful, doesn&#39;t automatically mean we <br>should extend this logic to other use cases.<br></p><p>On a side note, part of SE-0103 [1] was the <br>`withoutActuallyEscapingFunction` function, which would actually allow <br>you to explicitly override the compiler, though I&#39;m not sure it would <br>cover the nested function situation we&#39;re discussing here. Sadly, <br>`withoutActuallyEscapingFunction` is implemented yet [2].<br></p><p>[1]: <br>https://github.com/apple/swift-evolution/blob/master/proposals/0103-make-noescape-default.md<br>[2]: https://bugs.swift.org/browse/SR-2313<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Compiler refuses non-escaping closure calls in nested function</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>October 10, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Oct 9, 2016, at 5:07 PM, Jean-Denis Muys via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is a contrived reduction of my problem<br>&gt; <br>&gt; func mainFunction(closure:(Int) -&gt; Int) -&gt; Int {<br>&gt; <br>&gt;     func closureDoubled(_ n: Int) -&gt; Int {<br>&gt;         let result = closure(n)<br>&gt;         return 2*result<br>&gt;     }<br>&gt; <br>&gt;     let temp1 = closure(1)<br>&gt;     let temp2 = closureDoubled(1)<br>&gt;     return temp1+temp2<br>&gt; }<br>&gt; <br>&gt; The line &quot;let result = closure(n)&quot; is refused by the compiler with the error message &quot;declaration over non closing parameter may allow it to escape&quot;.<br>&gt; <br>&gt; First off, while I know what an escaping or a non-escaping closure is, I find this error message utterly impossible to understand. To begin with, the sentence &quot;non closing parameter&quot; is meaningless to me.<br>&gt; <br>&gt; In any case, my main function is passed a non-escaping closure. I want to call it from inside it, the compiler is ok with. I want also to call it from a nested function, but the compiler disagrees.<br>&gt; <br>&gt; I believe the compiler should not complain here. Did I miss anything?<br></p><p>I agrre that the compiler should be able to determine that the closure is nonescaping in this case, and that that diagnostic is in dire need of revision. Would you be able to file a couple of bug reports, one to allow this example, and one to improve the error message?<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20161010/56caa9b6/attachment.html&gt;<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
