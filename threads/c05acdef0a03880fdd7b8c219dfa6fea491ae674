<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 25, 2016 at 12:00:00pm</p></header><div class="content"><p>Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31 &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31&gt;<br></p><p>Introduction, Motivation<br></p><p>The standard library lacks equivalents to the floor() and ceil() functions found in the standard libraries of most other languages. Currently, we need to import Darwin or Glibc in order to access the C standard library versions.<br></p><p>They are essential for many algorithms, and adding them would allow more basic algorithms to be written platform-independently (or at least without #if (os) flags at the top).<br></p><p> &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31#proposed-solution&gt;Proposed Solution<br></p><p>Add floor and ceiling functions (and mutating variants) to FloatingPoint<br></p><p>protocol FloatingPoint {<br></p><p>    ...<br></p><p>    /// Returns the largest integral value not greater than `self`<br>    func floor() -&gt; Self<br>    /// Mutating form of `floor`<br>    mutating func formFloor()<br></p><p>    /// Returns the smallest integral value not less than `self`<br>    func ceiling() -&gt; Self<br>    /// Mutating form of `ceiling`<br>    mutating func formCeiling()<br>}<br> &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31#impact-on-existing-code&gt;Impact on existing code<br></p><p>This change is additive, although we may consider suppressing the imported, global-level C functions and automatically migrating them to instance method calls.<br></p><p> &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31#alternatives-considered&gt;Alternatives considered<br></p><p>floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/c05ae674/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 25, 2016 at 11:00:00am</p></header><div class="content"><p>Sent from my iPhone<br>&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31<br></p><p>+1<br></p><p>The only thing I&#39;m worried about is the situation where we have &quot;x = N.M&quot;, and `x.ceiling` equals maybe &quot;(N+2).0&quot; instead of &quot;(N+1).0&quot; because we ran out of precision and can&#39;t represent (N+1).0. I&#39;m not sure what the exact values are where floats (or doubles) stop having enough precision to represent inter-integer values... It might be a moot point.<br></p><p>I&#39;d suggest the functions&#39; descriptions to be changed from &quot;[largest|smallest] integral value&quot; to &quot;[largest|smallest] representable integral value&quot;.<br></p><p>- Dave Sweeris <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/40814d27/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/52ed55990045acc9742b6c982cd55e98?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Austin Rathe</string> &lt;austinr at gmail.com&gt;<p>June 25, 2016 at 05:00:00pm</p></header><div class="content"><p>+1 to the proposal<br></p><p>On Sat, 25 Jun 2016 at 17:48 David Sweeris via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31<br>&gt;<br>&gt;<br>&gt; +1<br>&gt;<br>&gt; The only thing I&#39;m worried about is the situation where we have &quot;x = N.M&quot;,<br>&gt; and `x.ceiling` equals maybe &quot;(N+2).0&quot; instead of &quot;(N+1).0&quot; because we ran<br>&gt; out of precision and can&#39;t represent (N+1).0. I&#39;m not sure what the exact<br>&gt; values are where floats (or doubles) stop having enough precision to<br>&gt; represent inter-integer values... It might be a moot point.<br>&gt;<br>&gt; I&#39;d suggest the functions&#39; descriptions to be changed from<br>&gt; &quot;[largest|smallest] integral value&quot; to &quot;[largest|smallest] representable<br>&gt; integral value&quot;.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/996a6eeb/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31 &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31&gt;<br>Karl, thanks for writing this up.  It should be extended to include not only floor( ) and ceiling( ), but also:<br></p><p>	/// Returns the integral value closest to `self` whose magnitude is not greater than that of `self`.<br>	func truncate( ) -&gt; Self<br></p><p>	/// Returns the integral value closest to `self`.  If two integrers are equally close, the even one<br>	/// is returned.<br>	//  NOTE: The name of this function requires bike-shedding.  I’ve chosen a deliberately poor<br>	//  name as a straw-man.<br>	func roundToNearestTiesToEven( ) -&gt; Self<br></p><p>	/// Returns the integral value closest to `self`.  If two integrers are equally close, the one with<br>	/// greater magnitude is returned.<br>	//  NOTE: The name of this function requires bike-shedding.  I’ve chosen a deliberately poor<br>	//  name as a straw-man.<br>	func roundToNearestTiesAway( ) -&gt; Self<br></p><p>and mutating versions of those.<br></p><p>Some collected responses to other comments on this thread:<br></p><p>&gt; David Sweeris wrote:<br>&gt; <br>&gt; The only thing I&#39;m worried about is the situation where we have &quot;x = N.M&quot;, and `x.ceiling` equals maybe &quot;(N+2).0&quot; instead of &quot;(N+1).0&quot; because we ran out of precision and can&#39;t represent (N+1).0. I&#39;m not sure what the exact values are where floats (or doubles) stop having enough precision to represent inter-integer values... It might be a moot point.<br></p><p>This never happens.  Floor and ceiling are always exact operations.<br></p><p>&gt; Austin Rathe wrote:<br>&gt; <br></p><p>&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br></p><p>While I understand where you’re going with this, you can’t round non-decimal floating-point numbers to a non-zero number of decimal digits (the result won’t be representable, in general).  This should be available for decimal floating-point types if/when they are added, but should be handled as part of conversions to String for binary floating-point types.<br></p><p>– Steve<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/7e48843e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/552a3e0dcef60ac896560e0c8f4baf5b?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Karl</string> &lt;razielim at gmail.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 16:23, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31 &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31&gt;<br>&gt; Karl, thanks for writing this up.  It should be extended to include not only floor( ) and ceiling( ), but also:<br>&gt; <br>&gt; 	/// Returns the integral value closest to `self` whose magnitude is not greater than that of `self`.<br>&gt; 	func truncate( ) -&gt; Self<br>&gt; <br>&gt; 	/// Returns the integral value closest to `self`.  If two integrers are equally close, the even one<br>&gt; 	/// is returned.<br>&gt; 	//  NOTE: The name of this function requires bike-shedding.  I’ve chosen a deliberately poor<br>&gt; 	//  name as a straw-man.<br>&gt; 	func roundToNearestTiesToEven( ) -&gt; Self<br>&gt; <br>&gt; 	/// Returns the integral value closest to `self`.  If two integrers are equally close, the one with<br>&gt; 	/// greater magnitude is returned.<br>&gt; 	//  NOTE: The name of this function requires bike-shedding.  I’ve chosen a deliberately poor<br>&gt; 	//  name as a straw-man.<br>&gt; 	func roundToNearestTiesAway( ) -&gt; Self<br>&gt; <br>&gt; and mutating versions of those.<br>&gt; <br></p><p>I was trying to add these, but working out the names of the mutating functions is difficult. How is truncate different to floor if it returns an integral value and can never round up?<br></p><p>Perhaps for the other functions, we could have a general `round` function with a tiebreak-enum parameter (it would be great if we could embed enums in protocols, but I’m not sure if that’s even on the roadmap):<br></p><p>enum FloatingPointRoundingStrategy {   // or something to that effect<br>    case preferEven<br>    case preferGreatest<br>}<br></p><p>func rounded(inTiebreak: FloatingPointRoundingStrategy) -&gt; Self<br></p><p>I think `(4.5).rounded(inTiebreak: .preferGreatest) == 5.0` looks quite nice.<br></p><p>Karl<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/96ec1eae/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 06:00:00pm</p></header><div class="content"><p>On Mon, Jun 27, 2016 at 9:34 AM Karl via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 27 Jun 2016, at 16:23, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31<br>&gt;<br>&gt;<br>&gt; Karl, thanks for writing this up.  It should be extended to include not<br>&gt; only floor( ) and ceiling( ), but also:<br>&gt;<br>&gt; /// Returns the integral value closest to `self` whose magnitude is not<br>&gt; greater than that of `self`.<br>&gt; func truncate( ) -&gt; Self<br>&gt;<br>&gt; /// Returns the integral value closest to `self`.  If two integrers are<br>&gt; equally close, the even one<br>&gt; /// is returned.<br>&gt; //  NOTE: The name of this function requires bike-shedding.  I’ve chosen a<br>&gt; deliberately poor<br>&gt; //  name as a straw-man.<br>&gt; func roundToNearestTiesToEven( ) -&gt; Self<br>&gt;<br>&gt; /// Returns the integral value closest to `self`.  If two integrers are<br>&gt; equally close, the one with<br>&gt; /// greater magnitude is returned.<br>&gt; //  NOTE: The name of this function requires bike-shedding.  I’ve chosen a<br>&gt; deliberately poor<br>&gt; //  name as a straw-man.<br>&gt; func roundToNearestTiesAway( ) -&gt; Self<br>&gt;<br>&gt; and mutating versions of those.<br>&gt;<br>&gt;<br>&gt; I was trying to add these, but working out the names of the mutating<br>&gt; functions is difficult. How is truncate different to floor if it returns an<br>&gt; integral value and can never round up?<br>&gt;<br>&gt;<br>(-4.5).truncate == -4<br>(-4.5).roundedDown == -5<br></p><p><br>&gt; Perhaps for the other functions, we could have a general `round` function<br>&gt; with a tiebreak-enum parameter (it would be great if we could embed enums<br>&gt; in protocols, but I’m not sure if that’s even on the roadmap):<br>&gt;<br>&gt; enum FloatingPointRoundingStrategy {   // or something to that effect<br>&gt;     case preferEven<br>&gt;     case preferGreatest<br>&gt; }<br>&gt;<br>&gt; func rounded(inTiebreak: FloatingPointRoundingStrategy) -&gt; Self<br>&gt;<br>&gt; I think `(4.5).rounded(inTiebreak: .preferGreatest) == 5.0` looks quite<br>&gt; nice.<br>&gt;<br>&gt; Karl<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/415c6e27/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 12:34 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 27 Jun 2016, at 16:23, Stephen Canon &lt;scanon at apple.com &lt;mailto:scanon at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31 &lt;https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31&gt;<br>&gt;&gt; Karl, thanks for writing this up.  It should be extended to include not only floor( ) and ceiling( ), but also:<br>&gt;&gt; <br>&gt;&gt; 	/// Returns the integral value closest to `self` whose magnitude is not greater than that of `self`.<br>&gt;&gt; 	func truncate( ) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; 	/// Returns the integral value closest to `self`.  If two integrers are equally close, the even one<br>&gt;&gt; 	/// is returned.<br>&gt;&gt; 	//  NOTE: The name of this function requires bike-shedding.  I’ve chosen a deliberately poor<br>&gt;&gt; 	//  name as a straw-man.<br>&gt;&gt; 	func roundToNearestTiesToEven( ) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; 	/// Returns the integral value closest to `self`.  If two integrers are equally close, the one with<br>&gt;&gt; 	/// greater magnitude is returned.<br>&gt;&gt; 	//  NOTE: The name of this function requires bike-shedding.  I’ve chosen a deliberately poor<br>&gt;&gt; 	//  name as a straw-man.<br>&gt;&gt; 	func roundToNearestTiesAway( ) -&gt; Self<br>&gt;&gt; <br>&gt;&gt; and mutating versions of those.<br>&gt;&gt; <br>&gt; <br>&gt; I was trying to add these, but working out the names of the mutating functions is difficult. How is truncate different to floor if it returns an integral value and can never round up?<br>&gt; <br>&gt; Perhaps for the other functions, we could have a general `round` function with a tiebreak-enum parameter (it would be great if we could embed enums in protocols, but I’m not sure if that’s even on the roadmap):<br>&gt; <br>&gt; enum FloatingPointRoundingStrategy {   // or something to that effect<br>&gt;     case preferEven<br>&gt;     case preferGreatest<br>&gt; }<br>&gt; <br>&gt; func rounded(inTiebreak: FloatingPointRoundingStrategy) -&gt; Self<br>&gt; <br>&gt; I think `(4.5).rounded(inTiebreak: .preferGreatest) == 5.0` looks quite nice.<br></p><p>Yes, something along these lines might work, though `FloatingPointRoundingStrategy` isn’t quite right; after all, round-towards-infinity (aka ceiling) is also a rounding strategy.<br></p><p>One option (which I don’t totally love, but which simplifies the API surface quite a bit, and avoids adding more formXXXX constructions) would be to fold all the rounding rules into a single member function (very strawman):<br></p><p>	/// Describes a rule for rounding to an integral value.<br>	enum RoundingRule {<br>		/// The result is the closest representable value greater than or equal to the source.<br>		case upwards<br>		/// The result is the closest representable value less than or equal to the source.<br>		case downwards<br>		/// The result is the closest representable value whose magnitude is less than or equal to that of the source.<br>		case towardZero<br>		/// The result is the closest representable value; if two values are equally close, the even one is chosen.<br>		case toNearestTiesToEven<br>		/// The result is the closest representable value; if two values are equally close, the one with greater magnitude is chosen.<br>		case toNearestTiesAway<br>	}<br></p><p>	/// Rounds to an integral value according to the specified rounding rule.<br>	mutating func round(_ rule: RoundingRule = toNearestTiesAway)<br></p><p>	func rounded(_ rule: RoundingRule = toNearestTiesAway) -&gt; Self<br></p><p>That gives us e.g.:<br></p><p>	let x = -2.5<br>	x.round(.upwards)	// -2<br>	x.round(.downwards)	// -3<br>	x.round(.towardZero)	// -2<br>	x.round(.toNearestTiesToEven)	// -2<br>	x.round()	// -3<br></p><p>We might also provide free functions that implement the most common operations under the familiar libc names (I realize that free-functions are not broadly considered “swifty”, but they may be appropriate here; we would effectively simply be moving these free functions from Darwin/Glibc into the stdlib, and making them available for all FloatingPoint types).<br></p><p>	func ceil&lt;T: FloatingPoint&gt;(_ x: T) -&gt; T {<br>		return x.rounded(.upwards)<br>	}<br></p><p>	func floor&lt;T: FloatingPoint&gt;(_ x: T) -&gt; T {<br>		return x.rounded(.downwards)<br>	}<br></p><p>	func trunc&lt;T: FloatingPoint&gt;(_ x: T) -&gt; T {<br>		return x.rounded(.towardZero)<br>	}<br></p><p><br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/c0bdab18/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2024f9524b1e51a54c4251abf0c34f50?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Saagar Jha</string> &lt;saagarjha28 at gmail.com&gt;<p>June 27, 2016 at 07:00:00pm</p></header><div class="content"><p>Seems fine to me. One addition though: some sort of round(withPrecision:<br>Int)<br>On Mon, Jun 27, 2016 at 12:23 Stephen Canon via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; On Jun 27, 2016, at 12:34 PM, Karl &lt;razielim at gmail.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On 27 Jun 2016, at 16:23, Stephen Canon &lt;scanon at apple.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 25, 2016, at 05:06, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Proposal: https://gist.github.com/karwa/273db66cd8a5fe2c388ccc7de9c4cf31<br>&gt;<br>&gt;<br>&gt; Karl, thanks for writing this up.  It should be extended to include not<br>&gt; only floor( ) and ceiling( ), but also:<br>&gt;<br>&gt; /// Returns the integral value closest to `self` whose magnitude is not<br>&gt; greater than that of `self`.<br>&gt; func truncate( ) -&gt; Self<br>&gt;<br>&gt; /// Returns the integral value closest to `self`.  If two integrers are<br>&gt; equally close, the even one<br>&gt; /// is returned.<br>&gt; //  NOTE: The name of this function requires bike-shedding.  I’ve chosen a<br>&gt; deliberately poor<br>&gt; //  name as a straw-man.<br>&gt; func roundToNearestTiesToEven( ) -&gt; Self<br>&gt;<br>&gt; /// Returns the integral value closest to `self`.  If two integrers are<br>&gt; equally close, the one with<br>&gt; /// greater magnitude is returned.<br>&gt; //  NOTE: The name of this function requires bike-shedding.  I’ve chosen a<br>&gt; deliberately poor<br>&gt; //  name as a straw-man.<br>&gt; func roundToNearestTiesAway( ) -&gt; Self<br>&gt;<br>&gt; and mutating versions of those.<br>&gt;<br>&gt;<br>&gt; I was trying to add these, but working out the names of the mutating<br>&gt; functions is difficult. How is truncate different to floor if it returns an<br>&gt; integral value and can never round up?<br>&gt;<br>&gt;<br>&gt; Perhaps for the other functions, we could have a general `round` function<br>&gt; with a tiebreak-enum parameter (it would be great if we could embed enums<br>&gt; in protocols, but I’m not sure if that’s even on the roadmap):<br>&gt;<br>&gt; enum FloatingPointRoundingStrategy {   // or something to that effect<br>&gt;     case preferEven<br>&gt;     case preferGreatest<br>&gt; }<br>&gt;<br>&gt; func rounded(inTiebreak: FloatingPointRoundingStrategy) -&gt; Self<br>&gt;<br>&gt; I think `(4.5).rounded(inTiebreak: .preferGreatest) == 5.0` looks quite<br>&gt; nice.<br>&gt;<br>&gt;<br>&gt; Yes, something along these lines might work, though<br>&gt; `FloatingPointRoundingStrategy` isn’t quite right; after all,<br>&gt; round-towards-infinity (aka ceiling) is also a rounding strategy.<br>&gt;<br>&gt; One option (which I don’t totally love, but which simplifies the API<br>&gt; surface quite a bit, and avoids adding more formXXXX constructions) would<br>&gt; be to fold all the rounding rules into a single member function (very<br>&gt; strawman):<br>&gt;<br>&gt; /// Describes a rule for rounding to an integral value.<br>&gt; enum RoundingRule {<br>&gt; /// The result is the closest representable value greater than or equal to<br>&gt; the source.<br>&gt; case upwards<br>&gt; /// The result is the closest representable value less than or equal to<br>&gt; the source.<br>&gt; case downwards<br>&gt; /// The result is the closest representable value whose magnitude is less<br>&gt; than or equal to that of the source.<br>&gt; case towardZero<br>&gt; /// The result is the closest representable value; if two values are<br>&gt; equally close, the even one is chosen.<br>&gt; case toNearestTiesToEven<br>&gt; /// The result is the closest representable value; if two values are<br>&gt; equally close, the one with greater magnitude is chosen.<br>&gt; case toNearestTiesAway<br>&gt; }<br>&gt;<br>&gt; /// Rounds to an integral value according to the specified rounding rule.<br>&gt; mutating func round(_ rule: RoundingRule = toNearestTiesAway)<br>&gt;<br>&gt; func rounded(_ rule: RoundingRule = toNearestTiesAway) -&gt; Self<br>&gt;<br>&gt; That gives us e.g.:<br>&gt;<br>&gt; let x = -2.5<br>&gt; x.round(.upwards) // -2<br>&gt; x.round(.downwards) // -3<br>&gt; x.round(.towardZero) // -2<br>&gt; x.round(.toNearestTiesToEven) // -2<br>&gt; x.round() // -3<br>&gt;<br>&gt; We might also provide free functions that implement the most common<br>&gt; operations under the familiar libc names (I realize that free-functions are<br>&gt; not broadly considered “swifty”, but they may be appropriate here; we would<br>&gt; effectively simply be moving these free functions from Darwin/Glibc into<br>&gt; the stdlib, and making them available for all FloatingPoint types).<br>&gt;<br>&gt; func ceil&lt;T: FloatingPoint&gt;(_ x: T) -&gt; T {<br>&gt; return x.rounded(.upwards)<br>&gt; }<br>&gt;<br>&gt; func floor&lt;T: FloatingPoint&gt;(_ x: T) -&gt; T {<br>&gt; return x.rounded(.downwards)<br>&gt; }<br>&gt;<br>&gt; func trunc&lt;T: FloatingPoint&gt;(_ x: T) -&gt; T {<br>&gt; return x.rounded(.towardZero)<br>&gt; }<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-- <br>-Saagar Jha<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/e21cf8e9/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d9b7c9b023237138ccb67df539f11b50?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Stephen Canon</string> &lt;scanon at apple.com&gt;<p>June 27, 2016 at 03:00:00pm</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 3:34 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt; <br>&gt; Seems fine to me. One addition though: some sort of round(withPrecision: Int)<br></p><p>I noted in another post on this thread that this doesn’t actually make any sense for FloatingPoint.  I’ll flesh that out here for everyone’s benefit.<br></p><p>When people talk about rounding to some precision, they almost universally mean “some number of decimal digits”.  But for binary floating-point types, rounding to any number of decimal digits other than zero doesn’t actually work.  E.g.:<br></p><p>	(1.15).round(withPrecision: 1) // returns 1.1<br></p><p>Why do we get 1.1 here instead of the expected 1.2?  Because 1.15 is actually 1.149999999999999911182158029987476766109466552734375.  For that matter, we haven’t actually succeeded in rounding to one decimal digit; the resulting value isn’t actually 1.1, but rather 1.100000000000000088817841970012523233890533447265625.<br></p><p>For binary floating-point types, the correct way to make rounding to a fixed number of digits behave as expected is to do it *at the point that the value is converted to a String for display, as part of the formatting*, never as a separate operation.<br></p><p>For a hypothetical DecimalFloatingPoint protocol, on the other hand, it would be perfectly reasonable to have the proposed operation:<br></p><p>	func rounded(digits: Int = 0, rule: RoundingRule) -&gt; Self<br></p><p>– Steve<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 27, 2016 at 05:00:00pm</p></header><div class="content"><p>That’s a very good point, IMHO.<br>- Dave Sweeris<br>&gt; On Jun 27, 2016, at 2:43 PM, Stephen Canon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 3:34 PM, Saagar Jha &lt;saagarjha28 at gmail.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Seems fine to me. One addition though: some sort of round(withPrecision: Int)<br>&gt; <br>&gt; I noted in another post on this thread that this doesn’t actually make any sense for FloatingPoint.  I’ll flesh that out here for everyone’s benefit.<br>&gt; <br>&gt; When people talk about rounding to some precision, they almost universally mean “some number of decimal digits”.  But for binary floating-point types, rounding to any number of decimal digits other than zero doesn’t actually work.  E.g.:<br>&gt; <br>&gt; 	(1.15).round(withPrecision: 1) // returns 1.1<br>&gt; <br>&gt; Why do we get 1.1 here instead of the expected 1.2?  Because 1.15 is actually 1.149999999999999911182158029987476766109466552734375.  For that matter, we haven’t actually succeeded in rounding to one decimal digit; the resulting value isn’t actually 1.1, but rather 1.100000000000000088817841970012523233890533447265625.<br>&gt; <br>&gt; For binary floating-point types, the correct way to make rounding to a fixed number of digits behave as expected is to do it *at the point that the value is converted to a String for display, as part of the formatting*, never as a separate operation.<br>&gt; <br>&gt; For a hypothetical DecimalFloatingPoint protocol, on the other hand, it would be perfectly reasonable to have the proposed operation:<br>&gt; <br>&gt; 	func rounded(digits: Int = 0, rule: RoundingRule) -&gt; Self<br>&gt; <br>&gt; – Steve<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>June 27, 2016 at 02:00:00pm</p></header><div class="content"><p>I&#39;m starting to come down from me earlier +1... Floor and ceiling are more functions than properties of a number, aren&#39;t they? <br></p><p>- Dave Sweeris<br></p><p>&gt; On Jun 25, 2016, at 11:48, David Sweeris via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; +1<br>&gt; <br>&gt; The only thing I&#39;m worried about is the situation where we have &quot;x = N.M&quot;, and `x.ceiling` equals maybe &quot;(N+2).0&quot; instead of &quot;(N+1).0&quot; because we ran out of precision and can&#39;t represent (N+1).0. I&#39;m not sure what the exact values are where floats (or doubles) stop having enough precision to represent inter-integer values... It might be a moot point.<br>&gt; <br>&gt; I&#39;d suggest the functions&#39; descriptions to be changed from &quot;[largest|smallest] integral value&quot; to &quot;[largest|smallest] representable integral value&quot;.<br>&gt; <br>&gt; - Dave Sweeris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; David Sweeris wrote:<br>&gt; <br>&gt; I&#39;m starting to come down from me earlier +1... Floor and ceiling are more functions than properties of a number, aren&#39;t they?<br></p><p>I agree with that. Having used various math libraries for decades now, I&#39;d find it odd to find these as members of a floating-point type, especially so for the suggested in-place mutating variants. These tend to be function-like constructs (or various kinds of brackets) in mathematics too, just like trigonometric functions.<br></p><p>But since do we need these in the FloatingPoint protocol for generic algorithms, I&#39;d suggest defining them as static members, and keeping state-of-art names (or close) where possible:<br></p><p>    protocol FloatingPoint {<br>      static func floor(_ value: Self) -&gt; Self<br>      static func ceiling(_ value: Self) -&gt; Self<br>      static func truncate(_ value: Self) -&gt; Self<br>      static func round(_ value: Self) -&gt; Self<br>    }<br></p><p>The top-level functions can them simply delegate to these counterparts:<br></p><p>    func floor&lt;T : FloatingPoint&gt;(_ value: T) -&gt; T {<br>      return .floor(value)<br>    }<br></p><p>— Pyry<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b8fbb69a582e03b56bd4c125aef9e3f?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Haravikk</string> &lt;e-mail at haravikk.me&gt;<p>June 25, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br></p><p>	func roundedUp() -&gt; Self { … }<br>	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>	func roundedDown() -&gt; Self { … }<br>	func roundedDown(withPrecision:Int) -&gt; Self { … }<br></p><p>Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/fac10d38/attachment.html&gt;<br>-------------- next part --------------<br>A non-text attachment was scrubbed...<br>Name: smime.p7s<br>Type: application/pkcs7-signature<br>Size: 4634 bytes<br>Desc: not available<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/fac10d38/attachment.p7s&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b85275a7eb50a13a925d4ce05bb5daf7?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Remy Demarest</string> &lt;psycho.hedgehog at me.com&gt;<p>June 25, 2016 at 12:00:00pm</p></header><div class="content"><p>We don&#39;t seem to have a rounded() function either as part of FloatingPoint, we should probably have these methods in the end:<br></p><p>func rounded() -&gt; Self<br>func rounded(withPrecision: Int) -&gt; Self<br></p><p>Along with the 4 other methods proposed below.<br></p><p>&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt; <br>&gt; 	func roundedUp() -&gt; Self { … }<br>&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt; 	func roundedDown() -&gt; Self { … }<br>&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt; <br>&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160625/822d4f19/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>Given the API guidelines, it should be<br></p><p>rounded, ceiled, floored <br></p><p>for returning the rounded/ceiled/floored value and<br></p><p>round(), ceil(), floor()<br></p><p>would be the mutating variants. Question is where it&#39;s not too confusing for anyone knowing these from another language.<br></p><p>&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; We don&#39;t seem to have a rounded() function either as part of FloatingPoint, we should probably have these methods in the end:<br>&gt; <br>&gt; func rounded() -&gt; Self<br>&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt; <br>&gt; Along with the 4 other methods proposed below.<br>&gt; <br>&gt;&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt;&gt; <br>&gt;&gt; 	func roundedUp() -&gt; Self { … }<br>&gt;&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt; 	func roundedDown() -&gt; Self { … }<br>&gt;&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt; <br>&gt;&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/da7fb54b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 01:00:00am</p></header><div class="content"><p>On Mon, Jun 27, 2016 at 12:45 AM, Charlie Monroe via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Given the API guidelines, it should be<br>&gt;<br>&gt; rounded, ceiled, floored<br>&gt;<br>&gt; for returning the rounded/ceiled/floored value and<br>&gt;<br>&gt; round(), ceil(), floor()<br>&gt;<br>&gt; would be the mutating variants. Question is where it&#39;s not too confusing<br>&gt; for anyone knowing these from another language.<br>&gt;<br></p><p>Although colloquially they can be &quot;verbed,&quot; ceil[ing] and floor are<br>formally nouns, just like sine, union, etc. So the API guidelines would<br>recommend: `rounded`, `ceiling`, `floor` for the non-mutating version and<br>`round`, `formCeiling`, and `formFloor` for the mutating version.<br></p><p><br>&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; We don&#39;t seem to have a rounded() function either as part of<br>&gt; FloatingPoint, we should probably have these methods in the end:<br>&gt;<br>&gt; func rounded() -&gt; Self<br>&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt;<br>&gt; Along with the 4 other methods proposed below.<br>&gt;<br>&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;<br>&gt;<br>&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;<br>&gt;    - floor() and ceil(), exactly like C. ceiling() is more descriptive<br>&gt;    and is a mathematical term of art<br>&gt;    &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;    - nextIntegralUp() and nextIntegralDown() are more descriptive still,<br>&gt;    but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;<br>&gt; I&#39;m in favour of these capabilities being there, but in terms of naming<br>&gt; I&#39;ve often wondered why it can&#39;t just be part of a rounding group of<br>&gt; methods like so:<br>&gt;<br>&gt; func roundedUp() -&gt; Self { … }<br>&gt; func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt; func roundedDown() -&gt; Self { … }<br>&gt; func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;<br>&gt; Since the methods with implied precision of zero are equivalent to floor<br>&gt; and ceiling surely? I know floor and ceiling are pretty common terms, but<br>&gt; they&#39;re just a form rounding when it comes down to it.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/1b02a429/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 27, 2016 at 08:00:00am</p></header><div class="content"><p>Whatever the naming scheme, I would be hesitant to have the non-mutating versions of floor and ceil have different endings, seeing how connected they are. So:<br></p><p>floor, ceil <br>floored, ceiled <br>flooring, ceiling<br></p><p>But not a mix.<br></p><p>&gt; On 27 Jun 2016, at 07:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 12:45 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; Given the API guidelines, it should be<br>&gt;&gt; <br>&gt;&gt; rounded, ceiled, floored <br>&gt;&gt; <br>&gt;&gt; for returning the rounded/ceiled/floored value and<br>&gt;&gt; <br>&gt;&gt; round(), ceil(), floor()<br>&gt;&gt; <br>&gt;&gt; would be the mutating variants. Question is where it&#39;s not too confusing for anyone knowing these from another language.<br>&gt; <br>&gt; Although colloquially they can be &quot;verbed,&quot; ceil[ing] and floor are formally nouns, just like sine, union, etc. So the API guidelines would recommend: `rounded`, `ceiling`, `floor` for the non-mutating version and `round`, `formCeiling`, and `formFloor` for the mutating version.<br>&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t seem to have a rounded() function either as part of FloatingPoint, we should probably have these methods in the end:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func rounded() -&gt; Self<br>&gt;&gt;&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Along with the 4 other methods proposed below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art.<br>&gt;&gt;&gt;&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;&gt;&gt;&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func roundedUp() -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedDown() -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/88a97fe6/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 06:00:00am</p></header><div class="content"><p>I disagree: in English, the nouns are floor and ceiling. That&#39;s what they<br>should be called.<br>On Mon, Jun 27, 2016 at 02:41 David Hart &lt;david at hartbit.com&gt; wrote:<br></p><p>&gt; Whatever the naming scheme, I would be hesitant to have the non-mutating<br>&gt; versions of floor and ceil have different endings, seeing how connected<br>&gt; they are. So:<br>&gt;<br>&gt; floor, ceil<br>&gt; floored, ceiled<br>&gt; flooring, ceiling<br>&gt;<br>&gt; But not a mix.<br>&gt;<br>&gt; On 27 Jun 2016, at 07:13, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; On Mon, Jun 27, 2016 at 12:45 AM, Charlie Monroe via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; Given the API guidelines, it should be<br>&gt;&gt;<br>&gt;&gt; rounded, ceiled, floored<br>&gt;&gt;<br>&gt;&gt; for returning the rounded/ceiled/floored value and<br>&gt;&gt;<br>&gt;&gt; round(), ceil(), floor()<br>&gt;&gt;<br>&gt;&gt; would be the mutating variants. Question is where it&#39;s not too confusing<br>&gt;&gt; for anyone knowing these from another language.<br>&gt;&gt;<br>&gt;<br>&gt; Although colloquially they can be &quot;verbed,&quot; ceil[ing] and floor are<br>&gt; formally nouns, just like sine, union, etc. So the API guidelines would<br>&gt; recommend: `rounded`, `ceiling`, `floor` for the non-mutating version and<br>&gt; `round`, `formCeiling`, and `formFloor` for the mutating version.<br>&gt;<br>&gt;<br>&gt;&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; We don&#39;t seem to have a rounded() function either as part of<br>&gt;&gt; FloatingPoint, we should probably have these methods in the end:<br>&gt;&gt;<br>&gt;&gt; func rounded() -&gt; Self<br>&gt;&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt;&gt;<br>&gt;&gt; Along with the 4 other methods proposed below.<br>&gt;&gt;<br>&gt;&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;    - floor() and ceil(), exactly like C. ceiling() is more descriptive<br>&gt;&gt;    and is a mathematical term of art<br>&gt;&gt;    &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;&gt;    - nextIntegralUp() and nextIntegralDown() are more descriptive still,<br>&gt;&gt;    but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;&gt;<br>&gt;&gt; I&#39;m in favour of these capabilities being there, but in terms of naming<br>&gt;&gt; I&#39;ve often wondered why it can&#39;t just be part of a rounding group of<br>&gt;&gt; methods like so:<br>&gt;&gt;<br>&gt;&gt; func roundedUp() -&gt; Self { … }<br>&gt;&gt; func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt; func roundedDown() -&gt; Self { … }<br>&gt;&gt; func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;<br>&gt;&gt; Since the methods with implied precision of zero are equivalent to floor<br>&gt;&gt; and ceiling surely? I know floor and ceiling are pretty common terms, but<br>&gt;&gt; they&#39;re just a form rounding when it comes down to it.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/fe9d4386/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/063adc064d3d040fcbfba0265019aecd?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>James Hillhouse</string> &lt;jdhillhouse4 at icloud.com&gt;<p>June 27, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On Jun 27, 2016, at 1:53 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I disagree: in English, the nouns are floor and ceiling. That&#39;s what they should be called.<br></p><p>Completely agree.<br></p><p>&gt; On Mon, Jun 27, 2016 at 02:41 David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; Whatever the naming scheme, I would be hesitant to have the non-mutating versions of floor and ceil have different endings, seeing how connected they are. So:<br>&gt; <br>&gt; floor, ceil <br>&gt; floored, ceiled <br>&gt; flooring, ceiling<br>&gt; <br>&gt; But not a mix.<br>&gt; <br>&gt; On 27 Jun 2016, at 07:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 12:45 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Given the API guidelines, it should be<br>&gt;&gt; <br>&gt;&gt; rounded, ceiled, floored <br>&gt;&gt; <br>&gt;&gt; for returning the rounded/ceiled/floored value and<br>&gt;&gt; <br>&gt;&gt; round(), ceil(), floor()<br>&gt;&gt; <br>&gt;&gt; would be the mutating variants. Question is where it&#39;s not too confusing for anyone knowing these from another language.<br>&gt;&gt; <br>&gt;&gt; Although colloquially they can be &quot;verbed,&quot; ceil[ing] and floor are formally nouns, just like sine, union, etc. So the API guidelines would recommend: `rounded`, `ceiling`, `floor` for the non-mutating version and `round`, `formCeiling`, and `formFloor` for the mutating version.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t seem to have a rounded() function either as part of FloatingPoint, we should probably have these methods in the end:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func rounded() -&gt; Self<br>&gt;&gt;&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Along with the 4 other methods proposed below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;&gt;&gt;&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;&gt;&gt;&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func roundedUp() -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedDown() -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/d2f9241a/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; On 27 Jun 2016, at 07:55, James Hillhouse &lt;jdhillhouse4 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jun 27, 2016, at 1:53 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I disagree: in English, the nouns are floor and ceiling. That&#39;s what they should be called.<br>&gt; <br>&gt; Completely agree.<br></p><p>This is why I suggested roundedDown() and roundedUp() in place of floor() and ceiling(), as the latter are kind of strange terms to fit into Swift, they&#39;re not that explanatory to people that don&#39;t know them, and rounding up and down with precision greater than zero could also be useful operations. Plus it would group all rounding methods together.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/45c41904/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>June 27, 2016 at 01:00:00pm</p></header><div class="content"><p>Hmm, I think they&#39;d qualify as terms of art; I don&#39;t know that rounding to<br>an arbitrary decimal place would be (although useful) primitive enough that<br>they should be added in stdlib [also, to genericize over floats and<br>doubles, how many decimal places could you usefully get?]; and grouping<br>families of methods by name has been rejected as a criterion for naming,<br>though obviously it&#39;s elegant where possible.<br>On Mon, Jun 27, 2016 at 05:59 Haravikk &lt;swift-evolution at haravikk.me&gt; wrote:<br></p><p>&gt; On 27 Jun 2016, at 07:55, James Hillhouse &lt;jdhillhouse4 at icloud.com&gt; wrote:<br>&gt;<br>&gt;<br>&gt; On Jun 27, 2016, at 1:53 AM, Xiaodi Wu via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I disagree: in English, the nouns are floor and ceiling. That&#39;s what they<br>&gt; should be called.<br>&gt;<br>&gt;<br>&gt; Completely agree.<br>&gt;<br>&gt;<br>&gt; This is why I suggested roundedDown() and roundedUp() in place of floor()<br>&gt; and ceiling(), as the latter are kind of strange terms to fit into Swift,<br>&gt; they&#39;re not that explanatory to people that don&#39;t know them, and rounding<br>&gt; up and down with precision greater than zero could also be useful<br>&gt; operations. Plus it would group all rounding methods together.<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/a4561232/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>June 27, 2016 at 10:00:00am</p></header><div class="content"><p>I&#39;m with those recommending round, rounded, roundUp, roundedUp, roundDown, <br>roundedDown, with Remy&#39;s precision factored in as needed.<br></p><p>This is usually the point where Dave A wanders in and explains how this can all be <br>implemented by a single FloatingPoint protocol, with built-in properties<br>and methods across all FP types in order to limit the API surface area that would be<br>otherwise affected by creating a whole bunch of native stdlib freestanding functions,<br>even generic ones.<br></p><p>-- E, starting the &quot;Tailor Swift Simply&quot; party<br></p><p><br>&gt; On Jun 27, 2016, at 12:53 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I disagree: in English, the nouns are floor and ceiling. That&#39;s what they should be called.<br>&gt; On Mon, Jun 27, 2016 at 02:41 David Hart &lt;david at hartbit.com &lt;mailto:david at hartbit.com&gt;&gt; wrote:<br>&gt; Whatever the naming scheme, I would be hesitant to have the non-mutating versions of floor and ceil have different endings, seeing how connected they are. So:<br>&gt; <br>&gt; floor, ceil <br>&gt; floored, ceiled <br>&gt; flooring, ceiling<br>&gt; <br>&gt; But not a mix.<br>&gt; <br>&gt; On 27 Jun 2016, at 07:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; On Mon, Jun 27, 2016 at 12:45 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Given the API guidelines, it should be<br>&gt;&gt; <br>&gt;&gt; rounded, ceiled, floored <br>&gt;&gt; <br>&gt;&gt; for returning the rounded/ceiled/floored value and<br>&gt;&gt; <br>&gt;&gt; round(), ceil(), floor()<br>&gt;&gt; <br>&gt;&gt; would be the mutating variants. Question is where it&#39;s not too confusing for anyone knowing these from another language.<br>&gt;&gt; <br>&gt;&gt; Although colloquially they can be &quot;verbed,&quot; ceil[ing] and floor are formally nouns, just like sine, union, etc. So the API guidelines would recommend: `rounded`, `ceiling`, `floor` for the non-mutating version and `round`, `formCeiling`, and `formFloor` for the mutating version.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; We don&#39;t seem to have a rounded() function either as part of FloatingPoint, we should probably have these methods in the end:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func rounded() -&gt; Self<br>&gt;&gt;&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Along with the 4 other methods proposed below.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; a écrit :<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;&gt;&gt;&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;&gt;&gt;&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; 	func roundedUp() -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedDown() -&gt; Self { … }<br>&gt;&gt;&gt;&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/e9a7be1e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>June 27, 2016 at 10:00:00pm</p></header><div class="content"><p>Hadn&#39;t thought of roundUp/Down. Makes it so obvious. +10<br></p><p>&gt; On 27 Jun 2016, at 18:32, Erica Sadun &lt;erica at ericasadun.com&gt; wrote:<br>&gt; <br>&gt; I&#39;m with those recommending round, rounded, roundUp, roundedUp, roundDown, <br>&gt; roundedDown, with Remy&#39;s precision factored in as needed.<br>&gt; <br>&gt; This is usually the point where Dave A wanders in and explains how this can all be <br>&gt; implemented by a single FloatingPoint protocol, with built-in properties<br>&gt; and methods across all FP types in order to limit the API surface area that would be<br>&gt; otherwise affected by creating a whole bunch of native stdlib freestanding functions,<br>&gt; even generic ones.<br>&gt; <br>&gt; -- E, starting the &quot;Tailor Swift Simply&quot; party<br>&gt; <br>&gt; <br>&gt;&gt; On Jun 27, 2016, at 12:53 AM, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I disagree: in English, the nouns are floor and ceiling. That&#39;s what they should be called.<br>&gt;&gt; On Mon, Jun 27, 2016 at 02:41 David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt;&gt;&gt; Whatever the naming scheme, I would be hesitant to have the non-mutating versions of floor and ceil have different endings, seeing how connected they are. So:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; floor, ceil <br>&gt;&gt;&gt; floored, ceiled <br>&gt;&gt;&gt; flooring, ceiling<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But not a mix.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On 27 Jun 2016, at 07:13, Xiaodi Wu via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Mon, Jun 27, 2016 at 12:45 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; Given the API guidelines, it should be<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; rounded, ceiled, floored <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; for returning the rounded/ceiled/floored value and<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; round(), ceil(), floor()<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; would be the mutating variants. Question is where it&#39;s not too confusing for anyone knowing these from another language.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Although colloquially they can be &quot;verbed,&quot; ceil[ing] and floor are formally nouns, just like sine, union, etc. So the API guidelines would recommend: `rounded`, `ceiling`, `floor` for the non-mutating version and `round`, `formCeiling`, and `formFloor` for the mutating version.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; On Jun 25, 2016, at 9:02 PM, Remy Demarest via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; We don&#39;t seem to have a rounded() function either as part of FloatingPoint, we should probably have these methods in the end:<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; func rounded() -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; func rounded(withPrecision: Int) -&gt; Self<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt; Along with the 4 other methods proposed below.<br>&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Le 25 juin 2016 à 11:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art.<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	func roundedUp() -&gt; Self { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	func roundedDown() -&gt; Self { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt;&gt;&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160627/54502d7c/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>[Proposal] Add floor() and ceiling() functions to FloatingPoint</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>June 30, 2016 at 11:00:00pm</p></header><div class="content"><p>IMO, this is the most mathematically meaningful and semantically transparent solution. Floor and ceiling might be the popular terms but roundedUp/Down is much cleaner. <br></p><p><br>&gt; On 25 Jun 2016, at 20:55, Haravikk via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On 25 Jun 2016, at 11:06, Karl via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; floor() and ceil(), exactly like C. ceiling() is more descriptive and is a mathematical term of art &lt;http://mathworld.wolfram.com/CeilingFunction.html&gt;.<br>&gt;&gt; nextIntegralUp() and nextIntegralDown() are more descriptive still, but possibly misleading as (4.0).nextIntegralUp() == 4.0<br>&gt; I&#39;m in favour of these capabilities being there, but in terms of naming I&#39;ve often wondered why it can&#39;t just be part of a rounding group of methods like so:<br>&gt; <br>&gt; 	func roundedUp() -&gt; Self { … }<br>&gt; 	func roundedUp(withPrecision:Int) -&gt; Self { … }<br>&gt; 	func roundedDown() -&gt; Self { … }<br>&gt; 	func roundedDown(withPrecision:Int) -&gt; Self { … }<br>&gt; <br>&gt; Since the methods with implied precision of zero are equivalent to floor and ceiling surely? I know floor and ceiling are pretty common terms, but they&#39;re just a form rounding when it comes down to it.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160630/badd2fde/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
