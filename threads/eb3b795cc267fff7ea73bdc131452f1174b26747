<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July  9, 2016 at 12:00:00pm</p></header><div class="content"><p>Please stop saying that this proposal will bring more consideration to the design of libraries.  It isn’t true.  I haven’t even seen an argument for why it would be true, it is just taken for granted that it is true.<br></p><p>As I mentioned in another post, this is structurally very different from things like ‘if-let’ and optionals.  Optionals force the user to consider their decision in the context it is being used (i.e. as you use the optional/value).  This proposal, however, does the opposite.  The effect of your actions appear in the context of a completely different user.  It is like sitting in a room, flipping a light switch wondering “I wonder what this does?”… meanwhile the people downstairs are wondering why their lights keep turning off and on”.  <br></p><p>You can try to test for this, but by definition library authors can only test for scenarios that they have thought of.  I have often found people surprise me with their use-cases.  Relying on the diligence of other programmers is what leads to things like: &quot;You always need to remember to test for zero before using a pointer&quot;.  Literally the opposite of optionals!  It sounds good, but at the end of the day, people are human and they WILL make mistakes.  Best to either catch those mistakes in the context where they happen or to mitigate the effect of it.  This proposal basically forces you to feel the full effect of other people&#39;s mistakes (thinking that it will discourage them from making them in the first place).<br></p><p>Your only real mechanism for feedback is when users of your library complain to you that something that they need isn’t subclass-able.  This is the point where most framework authors will actually learn that this feature/default exists.  Users of a framework will learn of it slightly earlier, when they find they need to subclass something, and it just isn’t possible.<br></p><p><br>I would much prefer adding a ‘sealed’ keyword which library authors could use to annotate things which they do not want subclassed outside of the module.  Or preferably, as others have suggested, allow augmentation of ‘final’ with ‘public(final)&#39; or ‘internal(final)’.<br></p><p>The only case where I would support ‘sealed’ by default is if there are 3 levels: open, sealed, final.  Final would allow &#39;public(final)&#39; and &#39;internal(final)’ to allow private subclassing inside the file/module.  Sealed would be the same, except it would allow the user to subclass by explicitly acknowledging the risk using ‘unsafe’:  “unsafe class MySubclass:SealedSuper“ and  “unsafe override func”.  Final would not allow the override.<br></p><p>That is the case where ‘sealed’ makes sense as a default…<br></p><p>Thanks,<br>Jon<br></p><p>P.S. The current proposal will only cause massive problems down the line, IMHO.  We will find an escape hatch is needed, but we will have made optimizations based on assumptions of finality which prevent us from easily adding one.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160709/eb3b6747/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 11, 2016 at 07:00:00am</p></header><div class="content"><p>I personally agree with most of your assessments. It&#39;s why I pushed so hard for &quot;allow subclassing my default&quot; in the first discussion of this point.<br></p><p>The problem with this is simple: you cannot retroactively &quot;close up&quot; an API. I cannot add final to a class I have previously declared as non-final. I also can seal a class which has previously been open to subclassing.<br></p><p>Consider: someone builds against my framework and I do nothing, and they subclass my classes. Then later I come through and mark the classes as &quot;Sealed&quot;. What should we do with those classes that are subclassing my classes? Nothing. I can&#39;t. I permitted access and now I&#39;m beholden to that access level.<br></p><p>On the other hand, opening up access levels gradually has no such issues. Users of my class can&#39;t subclass, and then they can. They just have another tool in the bag now.<br></p><p>If you want a default, it should be one you can reverse later. Your default should not be the most restrictive.<br></p><p>Whilst I agree with most of your points, this core concept seems to trump them to my mind.<br></p><p>- Rod<br></p><p>&gt; On 10 Jul. 2016, at 5:51 am, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Please stop saying that this proposal will bring more consideration to the design of libraries.  It isn’t true.  I haven’t even seen an argument for why it would be true, it is just taken for granted that it is true.<br>&gt; <br>&gt; As I mentioned in another post, this is structurally very different from things like ‘if-let’ and optionals.  Optionals force the user to consider their decision in the context it is being used (i.e. as you use the optional/value).  This proposal, however, does the opposite.  The effect of your actions appear in the context of a completely different user.  It is like sitting in a room, flipping a light switch wondering “I wonder what this does?”… meanwhile the people downstairs are wondering why their lights keep turning off and on”.  <br>&gt; <br>&gt; You can try to test for this, but by definition library authors can only test for scenarios that they have thought of.  I have often found people surprise me with their use-cases.  Relying on the diligence of other programmers is what leads to things like: &quot;You always need to remember to test for zero before using a pointer&quot;.  Literally the opposite of optionals!  It sounds good, but at the end of the day, people are human and they WILL make mistakes.  Best to either catch those mistakes in the context where they happen or to mitigate the effect of it.  This proposal basically forces you to feel the full effect of other people&#39;s mistakes (thinking that it will discourage them from making them in the first place).<br>&gt; <br>&gt; Your only real mechanism for feedback is when users of your library complain to you that something that they need isn’t subclass-able.  This is the point where most framework authors will actually learn that this feature/default exists.  Users of a framework will learn of it slightly earlier, when they find they need to subclass something, and it just isn’t possible.<br>&gt; <br>&gt; <br>&gt; I would much prefer adding a ‘sealed’ keyword which library authors could use to annotate things which they do not want subclassed outside of the module.  Or preferably, as others have suggested, allow augmentation of ‘final’ with ‘public(final)&#39; or ‘internal(final)’.<br>&gt; <br>&gt; The only case where I would support ‘sealed’ by default is if there are 3 levels: open, sealed, final.  Final would allow &#39;public(final)&#39; and &#39;internal(final)’ to allow private subclassing inside the file/module.  Sealed would be the same, except it would allow the user to subclass by explicitly acknowledging the risk using ‘unsafe’:  “unsafe class MySubclass:SealedSuper“ and  “unsafe override func”.  Final would not allow the override.<br>&gt; <br>&gt; That is the case where ‘sealed’ makes sense as a default…<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; P.S. The current proposal will only cause massive problems down the line, IMHO.  We will find an escape hatch is needed, but we will have made optimizations based on assumptions of finality which prevent us from easily adding one.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/103bd5c3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; The problem with this is simple: you cannot retroactively &quot;close up&quot; an API. I cannot add final to a class I have previously declared as non-final. I also can seal a class which has previously been open to subclassing.<br>Of course you can do both — it may make users angry, but so what?<br>The essence of this way of thinking is &quot;I fear the reaction of my users when I take something away from them… so I have to deny them those options right from start&quot;.<br></p><p>I&#39;ve no statistics (there&#39;s a general lack of facts all over the place…), but I don&#39;t thing the majority of todays and future libraries are build with a strictly planned top-down approach and guarantees about API-stability. Nowadays things are much more spontaneous, and the strict rules and limits some people here want to force upon others would most likely decrease the joy in playing with the language and start experiments in it.<br></p><p>There is only a very small number of Swift-developers writing frameworks that are used on a large scale basis, and even if many people in this group vote for limiting defaults, the focus should be on the majority:<br>When I come to the conclusion that a set of classes in a project could be useful somewhere else, my problem is not fear of future API changes — it is the daunting task of having to sprinkle &quot;public&quot; all over the place.<br>Sealing classes makes proper code reuse a more tedious job, and I want Swift to stay fun rather than become a playground for sticklers for order.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/73ac6b56/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 11, 2016 at 11:00:00am</p></header><div class="content"><p>This is the case with a library.<br></p><p>It is *not* the case with a framework. Dynamically linked frameworks can be changed without the app even being changed. Imagine if Apple changed UIKit and make UINavigationController final retroactively. UIKit internally would therefore call directly to the UINavigationController methods statically, and bypass any subclass’s methods, thereby breaking applications. Should app apps have to be rebuilt to work with iOS 12 simply because Apple shipped a new version of UIKit? This is illogical. You will *break* things by finalising after the fact. Swift, being about safety, needs to deal with this safely.<br></p><p><br>&gt; On 11 Jul 2016, at 9:13 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; The problem with this is simple: you cannot retroactively &quot;close up&quot; an API. I cannot add final to a class I have previously declared as non-final. I also can seal a class which has previously been open to subclassing.<br>&gt; Of course you can do both — it may make users angry, but so what?<br>&gt; The essence of this way of thinking is &quot;I fear the reaction of my users when I take something away from them… so I have to deny them those options right from start&quot;.<br>&gt; <br>&gt; I&#39;ve no statistics (there&#39;s a general lack of facts all over the place…), but I don&#39;t thing the majority of todays and future libraries are build with a strictly planned top-down approach and guarantees about API-stability. Nowadays things are much more spontaneous, and the strict rules and limits some people here want to force upon others would most likely decrease the joy in playing with the language and start experiments in it.<br>&gt; <br>&gt; There is only a very small number of Swift-developers writing frameworks that are used on a large scale basis, and even if many people in this group vote for limiting defaults, the focus should be on the majority:<br>&gt; When I come to the conclusion that a set of classes in a project could be useful somewhere else, my problem is not fear of future API changes — it is the daunting task of having to sprinkle &quot;public&quot; all over the place.<br>&gt; Sealing classes makes proper code reuse a more tedious job, and I want Swift to stay fun rather than become a playground for sticklers for order.<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/665813a3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 07:00:00am</p></header><div class="content"><p>&gt; It is *not* the case with a framework. Dynamically linked frameworks can be changed without the app even being changed. Imagine if Apple changed UIKit and make UINavigationController final retroactively. <br>Your argument is true, and you choose a good example — but it&#39;s actually the only one that exists at all:<br>There are no other parties that ship frameworks that way, and I don&#39;t think this should change.<br></p><p>So the benefits of this proposal would exist for Apple alone, and I can understand why sealed is convenient for an UIKit-engineer.<br>It is tempting to aim for the easiest solution, but it is smarter to take the route that&#39;s better for the customer (and we happen to be the customers).<br>And, as others pointed out before, Cupertino is free to diverge from the defaults in either direction, so it is only a little effort to have &quot;sealed by default&quot; without the bad side effects.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>Resent for Swift Evolution:<br></p><p>With the existence of Swift on the server, dynamically linked, independently distributed frameworks will not be an Apple-only issue - this extends beyond Apple&#39;s OS X-based platforms towards how dynamic frameworks link against each other as if they are to be distributed separately.<br></p><p>It is short sighted to suggest that all Swift deployments will be under Apple&#39;s control.<br></p><p>On 11 Jul. 2016, at 3:43 pm, Tino Heth &lt;2th at gmx.de&gt; wrote:<br></p><p>&gt;&gt; It is *not* the case with a framework. Dynamically linked frameworks can be changed without the app even being changed. Imagine if Apple changed UIKit and make UINavigationController final retroactively. <br>&gt; Your argument is true, and you choose a good example — but it&#39;s actually the only one that exists at all:<br>&gt; There are no other parties that ship frameworks that way, and I don&#39;t think this should change.<br>&gt; <br>&gt; So the benefits of this proposal would exist for Apple alone, and I can understand why sealed is convenient for an UIKit-engineer.<br>&gt; It is tempting to aim for the easiest solution, but it is smarter to take the route that&#39;s better for the customer (and we happen to be the customers).<br>&gt; And, as others pointed out before, Cupertino is free to diverge from the defaults in either direction, so it is only a little effort to have &quot;sealed by default&quot; without the bad side effects.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 11, 2016 at 07:00:00am</p></header><div class="content"><p>Is it more unreasonable to ask developers to seal their modules or users to unseal them? I would say Apple or third parties shipping frameworks could be asked to think about subclass ability before shipping their commercial library.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 11 Jul 2016, at 07:36, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Resent for Swift Evolution:<br>&gt; <br>&gt; With the existence of Swift on the server, dynamically linked, independently distributed frameworks will not be an Apple-only issue - this extends beyond Apple&#39;s OS X-based platforms towards how dynamic frameworks link against each other as if they are to be distributed separately.<br>&gt; <br>&gt; It is short sighted to suggest that all Swift deployments will be under Apple&#39;s control.<br>&gt; <br>&gt; On 11 Jul. 2016, at 3:43 pm, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt;&gt; It is *not* the case with a framework. Dynamically linked frameworks can be changed without the app even being changed. Imagine if Apple changed UIKit and make UINavigationController final retroactively. <br>&gt;&gt; Your argument is true, and you choose a good example — but it&#39;s actually the only one that exists at all:<br>&gt;&gt; There are no other parties that ship frameworks that way, and I don&#39;t think this should change.<br>&gt;&gt; <br>&gt;&gt; So the benefits of this proposal would exist for Apple alone, and I can understand why sealed is convenient for an UIKit-engineer.<br>&gt;&gt; It is tempting to aim for the easiest solution, but it is smarter to take the route that&#39;s better for the customer (and we happen to be the customers).<br>&gt;&gt; And, as others pointed out before, Cupertino is free to diverge from the defaults in either direction, so it is only a little effort to have &quot;sealed by default&quot; without the bad side effects.<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; With the existence of Swift on the server, dynamically linked, independently distributed frameworks will not be an Apple-only issue - this extends beyond Apple&#39;s OS X-based platforms towards how dynamic frameworks link against each other as if they are to be distributed separately.<br>&gt; <br>&gt; It is short sighted to suggest that all Swift deployments will be under Apple&#39;s control.<br>I&#39;m really looking forward for server-side Swift — I&#39;m planning for years to extend my portfolio in that direction, and Swift could really push that diversification.<br></p><p>But I had a concrete reason for interest in writing my own backend-code:<br>Server-side was imho broken on large scale, and it still isn&#39;t fixed yet… I can run circles around those poor Java-developers who have to fight crusted structures and deal with sluggish tools like Maven and Tomcat (and Java ;-).*<br>It seems to me I&#39;m not alone with my opinion, because there are already alternatives on the rise:<br>Look at Docker — it&#39;s a huge success, because it not only takes application and libraries to build a robust unit; it even includes a whole OS!<br></p><p>On iOS, it already hurts when you have a bunch of Swift-Apps which all have the stdlib bundled — but on the server, this doesn&#39;t matter, and I&#39;m convinced it would be a bad move to propagate shared frameworks.<br></p><p>- Tino<br></p><p>* of course, there are agile alternatives — but in my environment, most of the big players wouldn&#39;t even consider something like Rails<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 11, 2016 at 12:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 11, 2016, at 9:39 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; With the existence of Swift on the server, dynamically linked, independently distributed frameworks will not be an Apple-only issue - this extends beyond Apple&#39;s OS X-based platforms towards how dynamic frameworks link against each other as if they are to be distributed separately.<br>&gt;&gt; <br>&gt;&gt; It is short sighted to suggest that all Swift deployments will be under Apple&#39;s control.<br>&gt; I&#39;m really looking forward for server-side Swift — I&#39;m planning for years to extend my portfolio in that direction, and Swift could really push that diversification.<br>&gt; <br>&gt; But I had a concrete reason for interest in writing my own backend-code:<br>&gt; Server-side was imho broken on large scale, and it still isn&#39;t fixed yet… I can run circles around those poor Java-developers who have to fight crusted structures and deal with sluggish tools like Maven and Tomcat (and Java ;-).*<br></p><p>You do realize that then itunes store used to (i don&#39;t know hese days) for many years run on java, despite objc being such a more advanced environment. ;-)<br></p><p><br>&gt; It seems to me I&#39;m not alone with my opinion, because there are already alternatives on the rise:<br>&gt; Look at Docker — it&#39;s a huge success, because it not only takes application and libraries to build a robust unit; it even includes a whole OS!<br>&gt; <br>&gt; On iOS, it already hurts when you have a bunch of Swift-Apps which all have the stdlib bundled — but on the server, this doesn&#39;t matter, and I&#39;m convinced it would be a bad move to propagate shared frameworks.<br>&gt; <br>&gt; - Tino<br>&gt; <br>&gt; * of course, there are agile alternatives — but in my environment, most of the big players wouldn&#39;t even consider something like Rails<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; You do realize that then itunes store used to (i don&#39;t know hese days) for many years run on java, despite objc being such a more advanced environment. ;-)<br>well, from my experience, app developers are running circles around the itunes store all the time ;-)<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>July 11, 2016 at 06:00:00pm</p></header><div class="content"><p>Regards<br>(From mobile)<br></p><p>&gt; On Jul 11, 2016, at 12:53 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; You do realize that then itunes store used to (i don&#39;t know hese days) for many years run on java, despite objc being such a more advanced environment. ;-)<br>&gt; well, from my experience, app developers are running circles around the itunes store all the time ;-)<br></p><p>Better yet... I once had lunch with the now defunct java team and the guy who did the java rewrite of webobjects... can you guess from what language? or why they had to do it? <br>Still running circles?<br>;-)<br>Cheers &amp; thank u for the smiles...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b1fc4ed1ed8e138ef0a87fd3e91c83a4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Ricardo Parada</string> &lt;rparada at mac.com&gt;<p>July 11, 2016 at 03:00:00pm</p></header><div class="content"><p>WebObjects is one of the frameworks I was referring to without actually naming it. <br></p><p>After Apple stopped supporting WebObjects we have been able to fix, extend and enhance it all these years and has served us really well. It is an awesome framework. I really wish that Swift had a framework like it. But Swift&#39;s limited reflection is lacking and is crucial for implementing a framework like WebObjects. <br></p><p>Had WebObjects been designed with sealed classes, our hands would have been tied for all the many apps and systems that use it. <br></p><p>I am hoping that if this proposal gets approved that libraries such as these get designed as subclassable. That to me is much more valuable, at least for these types of libraries. <br></p><p>I think that in the long term libraries will sort themselves out. A well designed subclassable library will have more value. <br></p><p><br></p><p><br>&gt; On Jul 11, 2016, at 12:49 PM, L. Mihalkovic via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt; Regards<br>&gt; (From mobile)<br>&gt; <br>&gt;&gt; On Jul 11, 2016, at 12:53 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; You do realize that then itunes store used to (i don&#39;t know hese days) for many years run on java, despite objc being such a more advanced environment. ;-)<br>&gt;&gt; well, from my experience, app developers are running circles around the itunes store all the time ;-)<br>&gt; <br>&gt; Better yet... I once had lunch with the now defunct java team and the guy who did the java rewrite of webobjects... can you guess from what language? or why they had to do it? <br>&gt; Still running circles?<br>&gt; ;-)<br>&gt; Cheers &amp; thank u for the smiles...<br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; Le 11 juil. 2016 à 09:39, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt; <br>&gt;&gt; With the existence of Swift on the server, dynamically linked, independently distributed frameworks will not be an Apple-only issue - this extends beyond Apple&#39;s OS X-based platforms towards how dynamic frameworks link against each other as if they are to be distributed separately.<br>&gt;&gt; <br>&gt;&gt; It is short sighted to suggest that all Swift deployments will be under Apple&#39;s control.<br>&gt; I&#39;m really looking forward for server-side Swift — I&#39;m planning for years to extend my portfolio in that direction, and Swift could really push that diversification.<br></p><p>Server side swift is already alive:  https://developer.ibm.com/swift/<br></p><p>&gt; But I had a concrete reason for interest in writing my own backend-code:<br>&gt; Server-side was imho broken on large scale, and it still isn&#39;t fixed yet… I can run circles around those poor Java-developers who have to fight crusted structures and deal with sluggish tools like Maven and Tomcat (and Java ;-).*<br>&gt; It seems to me I&#39;m not alone with my opinion, because there are already alternatives on the rise:<br>&gt; Look at Docker — it&#39;s a huge success, because it not only takes application and libraries to build a robust unit; it even includes a whole OS!<br>&gt; <br>&gt; On iOS, it already hurts when you have a bunch of Swift-Apps which all have the stdlib bundled — but on the server, this doesn&#39;t matter, and I&#39;m convinced it would be a bad move to propagate shared frameworks.<br>&gt; <br>&gt; - Tino<br>&gt; <br>&gt; * of course, there are agile alternatives — but in my environment, most of the big players wouldn&#39;t even consider something like Rails<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 10, 2016 at 06:00:00pm</p></header><div class="content"><p>@Rod:  Thank you for actually replying to the content of my post.  Much appreciated.<br></p><p>It is a trolly problem.  You are arguing that pre-breaking everyone&#39;s code is better (even if causes way more trouble overall) than taking an action that breaks a few people’s code later (and thus feeling responsible).  There are other options. I grew up watching enough Star Trek that I don’t believe in no win scenarios.<br></p><p>I still think my compromise is the best solution.  3 levels: Open, Sealed, Final.  The difference is that sealed can be overridden with a compiler warning and use of “unsafe” keyword, but final can’t be overridden.  That way the user is acknowledging that they are doing something which isn’t supported in the context which they are doing it… but it doesn’t completely prevent it by default.  Opt-out safety.  (Yes you lose some compiler optimizations in the default case, but that was premature optimization anyway).<br></p><p>As for the interaction with public/internal/etc… that should be explicit.  This proposal confuses and intermingles them.  You should just be able to say ‘public final internal(open)’ or some other syntax which lets you express the same sentiment.  (The above says the class/method is public and final, but internally it is open.)<br></p><p>I am not saying that we shouldn’t solve these issues.  I am saying this proposal:<br>1) Isn’t easily discoverable.<br>2) Requires communication between different parties (author and user) which slows iteration cycles to weeks or months (vs the usual minutes)<br>3) Conflates/mixes the ideas of access level and subclass-ability<br>4) Makes way too many separate changes in a single proposal: New idea of “sealed”, new default, replaces ‘public’ in some cases but not others, new keywords (which everyone wants to change), etc…<br>5) Has structural problems which mean that it won’t actually increase thoughtfulness<br>6) Makes app developers extremely dependent on framework authors (and those author’s schedules)<br>7) Will require us to patch/fix it later, but that will be difficult due to optimizations/assumptions of finality.<br>8) Will cause unnecessary pain for both framework authors and users of frameworks<br></p><p>We would be foolish to accept this proposal without planning for the inevitable escape hatch.  We will need it, and if we don’t plan for it, it will break everything when we are forced to fix it in Swift 4/5.  Anything else is idealistic to the point of ignoring real-world use/behavior.<br></p><p>As I said before, this type of thinking: “If we just make things more difficult, it will encourage awareness” is what leads to the DMV, TSA, and Java.  The problem is, the brain doesn’t work that way, and it ultimately just adds pain without being effective.  You can add forcing functions (like optional unwrapping), which are annoying, but effective… but as I also mentioned before this proposal doesn’t do that.  It is structurally different.  It will not do what you think it does.<br></p><p>Thanks,<br>Jon<br></p><p>P.S.  There is also a dangerous difference between helping the programmer catch mistakes (e.g. don’t accidentally subclass the wrong method) and trying to prevent them from coding in a style you disagree with.  I have been seeing far to many proposals of the second variety of late.<br></p><p><br>&gt; On Jul 10, 2016, at 2:58 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; I personally agree with most of your assessments. It&#39;s why I pushed so hard for &quot;allow subclassing my default&quot; in the first discussion of this point.<br>&gt; <br>&gt; The problem with this is simple: you cannot retroactively &quot;close up&quot; an API. I cannot add final to a class I have previously declared as non-final. I also can seal a class which has previously been open to subclassing.<br>&gt; <br>&gt; Consider: someone builds against my framework and I do nothing, and they subclass my classes. Then later I come through and mark the classes as &quot;Sealed&quot;. What should we do with those classes that are subclassing my classes? Nothing. I can&#39;t. I permitted access and now I&#39;m beholden to that access level.<br>&gt; <br>&gt; On the other hand, opening up access levels gradually has no such issues. Users of my class can&#39;t subclass, and then they can. They just have another tool in the bag now.<br>&gt; <br>&gt; If you want a default, it should be one you can reverse later. Your default should not be the most restrictive.<br>&gt; <br>&gt; Whilst I agree with most of your points, this core concept seems to trump them to my mind.<br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; On 10 Jul. 2016, at 5:51 am, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; Please stop saying that this proposal will bring more consideration to the design of libraries.  It isn’t true.  I haven’t even seen an argument for why it would be true, it is just taken for granted that it is true.<br>&gt;&gt; <br>&gt;&gt; As I mentioned in another post, this is structurally very different from things like ‘if-let’ and optionals.  Optionals force the user to consider their decision in the context it is being used (i.e. as you use the optional/value).  This proposal, however, does the opposite.  The effect of your actions appear in the context of a completely different user.  It is like sitting in a room, flipping a light switch wondering “I wonder what this does?”… meanwhile the people downstairs are wondering why their lights keep turning off and on”.  <br>&gt;&gt; <br>&gt;&gt; You can try to test for this, but by definition library authors can only test for scenarios that they have thought of.  I have often found people surprise me with their use-cases.  Relying on the diligence of other programmers is what leads to things like: &quot;You always need to remember to test for zero before using a pointer&quot;.  Literally the opposite of optionals!  It sounds good, but at the end of the day, people are human and they WILL make mistakes.  Best to either catch those mistakes in the context where they happen or to mitigate the effect of it.  This proposal basically forces you to feel the full effect of other people&#39;s mistakes (thinking that it will discourage them from making them in the first place).<br>&gt;&gt; <br>&gt;&gt; Your only real mechanism for feedback is when users of your library complain to you that something that they need isn’t subclass-able.  This is the point where most framework authors will actually learn that this feature/default exists.  Users of a framework will learn of it slightly earlier, when they find they need to subclass something, and it just isn’t possible.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; I would much prefer adding a ‘sealed’ keyword which library authors could use to annotate things which they do not want subclassed outside of the module.  Or preferably, as others have suggested, allow augmentation of ‘final’ with ‘public(final)&#39; or ‘internal(final)’.<br>&gt;&gt; <br>&gt;&gt; The only case where I would support ‘sealed’ by default is if there are 3 levels: open, sealed, final.  Final would allow &#39;public(final)&#39; and &#39;internal(final)’ to allow private subclassing inside the file/module.  Sealed would be the same, except it would allow the user to subclass by explicitly acknowledging the risk using ‘unsafe’:  “unsafe class MySubclass:SealedSuper“ and  “unsafe override func”.  Final would not allow the override.<br>&gt;&gt; <br>&gt;&gt; That is the case where ‘sealed’ makes sense as a default…<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; P.S. The current proposal will only cause massive problems down the line, IMHO.  We will find an escape hatch is needed, but we will have made optimizations based on assumptions of finality which prevent us from easily adding one.<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/830447f0/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 11, 2016 at 11:00:00am</p></header><div class="content"><p>@Jonathan<br></p><p>I don’t think that &quot;pre-breaking code&quot; is a good description. You are not breaking anything - you’re just not allowing something that *could* become unsafe. It’s safety first, at the cost of the library user’s flexibility.<br></p><p>That said, I actually think you have a good point however that “sealed” should be able to be overridden, either in a patch capacity or an “unsafe” capacity. Should this become final at a later point, you have acknowledged you know this will be unsafe and are willing to take this risk to get the job done. This is opt-in risk.<br></p><p>Perhaps however this shouldn’t be “sealed” declaratively. Perhaps we just have a keyword for “Open” as an access level, and if you subclass or override things that are not “open” from other modules, you must mark unsafe.<br></p><p>I think this is a decent compromise: We allow potential to patch, but discourage without acknowledgement of the risk. Allow Final and Open to be declarative.<br></p><p>- Rod<br></p><p><br></p><p>&gt; On 11 Jul 2016, at 11:05 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; @Rod:  Thank you for actually replying to the content of my post.  Much appreciated.<br>&gt; <br>&gt; It is a trolly problem.  You are arguing that pre-breaking everyone&#39;s code is better (even if causes way more trouble overall) than taking an action that breaks a few people’s code later (and thus feeling responsible).  There are other options. I grew up watching enough Star Trek that I don’t believe in no win scenarios.<br>&gt; <br>&gt; I still think my compromise is the best solution.  3 levels: Open, Sealed, Final.  The difference is that sealed can be overridden with a compiler warning and use of “unsafe” keyword, but final can’t be overridden.  That way the user is acknowledging that they are doing something which isn’t supported in the context which they are doing it… but it doesn’t completely prevent it by default.  Opt-out safety.  (Yes you lose some compiler optimizations in the default case, but that was premature optimization anyway).<br>&gt; <br>&gt; As for the interaction with public/internal/etc… that should be explicit.  This proposal confuses and intermingles them.  You should just be able to say ‘public final internal(open)’ or some other syntax which lets you express the same sentiment.  (The above says the class/method is public and final, but internally it is open.)<br>&gt; <br>&gt; I am not saying that we shouldn’t solve these issues.  I am saying this proposal:<br>&gt; 1) Isn’t easily discoverable.<br>&gt; 2) Requires communication between different parties (author and user) which slows iteration cycles to weeks or months (vs the usual minutes)<br>&gt; 3) Conflates/mixes the ideas of access level and subclass-ability<br>&gt; 4) Makes way too many separate changes in a single proposal: New idea of “sealed”, new default, replaces ‘public’ in some cases but not others, new keywords (which everyone wants to change), etc…<br>&gt; 5) Has structural problems which mean that it won’t actually increase thoughtfulness<br>&gt; 6) Makes app developers extremely dependent on framework authors (and those author’s schedules)<br>&gt; 7) Will require us to patch/fix it later, but that will be difficult due to optimizations/assumptions of finality.<br>&gt; 8) Will cause unnecessary pain for both framework authors and users of frameworks<br>&gt; <br>&gt; We would be foolish to accept this proposal without planning for the inevitable escape hatch.  We will need it, and if we don’t plan for it, it will break everything when we are forced to fix it in Swift 4/5.  Anything else is idealistic to the point of ignoring real-world use/behavior.<br>&gt; <br>&gt; As I said before, this type of thinking: “If we just make things more difficult, it will encourage awareness” is what leads to the DMV, TSA, and Java.  The problem is, the brain doesn’t work that way, and it ultimately just adds pain without being effective.  You can add forcing functions (like optional unwrapping), which are annoying, but effective… but as I also mentioned before this proposal doesn’t do that.  It is structurally different.  It will not do what you think it does.<br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; P.S.  There is also a dangerous difference between helping the programmer catch mistakes (e.g. don’t accidentally subclass the wrong method) and trying to prevent them from coding in a style you disagree with.  I have been seeing far to many proposals of the second variety of late.<br>&gt; <br>&gt; <br>&gt;&gt; On Jul 10, 2016, at 2:58 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I personally agree with most of your assessments. It&#39;s why I pushed so hard for &quot;allow subclassing my default&quot; in the first discussion of this point.<br>&gt;&gt; <br>&gt;&gt; The problem with this is simple: you cannot retroactively &quot;close up&quot; an API. I cannot add final to a class I have previously declared as non-final. I also can seal a class which has previously been open to subclassing.<br>&gt;&gt; <br>&gt;&gt; Consider: someone builds against my framework and I do nothing, and they subclass my classes. Then later I come through and mark the classes as &quot;Sealed&quot;. What should we do with those classes that are subclassing my classes? Nothing. I can&#39;t. I permitted access and now I&#39;m beholden to that access level.<br>&gt;&gt; <br>&gt;&gt; On the other hand, opening up access levels gradually has no such issues. Users of my class can&#39;t subclass, and then they can. They just have another tool in the bag now.<br>&gt;&gt; <br>&gt;&gt; If you want a default, it should be one you can reverse later. Your default should not be the most restrictive.<br>&gt;&gt; <br>&gt;&gt; Whilst I agree with most of your points, this core concept seems to trump them to my mind.<br>&gt;&gt; <br>&gt;&gt; - Rod<br>&gt;&gt; <br>&gt;&gt; On 10 Jul. 2016, at 5:51 am, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; Please stop saying that this proposal will bring more consideration to the design of libraries.  It isn’t true.  I haven’t even seen an argument for why it would be true, it is just taken for granted that it is true.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; As I mentioned in another post, this is structurally very different from things like ‘if-let’ and optionals.  Optionals force the user to consider their decision in the context it is being used (i.e. as you use the optional/value).  This proposal, however, does the opposite.  The effect of your actions appear in the context of a completely different user.  It is like sitting in a room, flipping a light switch wondering “I wonder what this does?”… meanwhile the people downstairs are wondering why their lights keep turning off and on”.  <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; You can try to test for this, but by definition library authors can only test for scenarios that they have thought of.  I have often found people surprise me with their use-cases.  Relying on the diligence of other programmers is what leads to things like: &quot;You always need to remember to test for zero before using a pointer&quot;.  Literally the opposite of optionals!  It sounds good, but at the end of the day, people are human and they WILL make mistakes.  Best to either catch those mistakes in the context where they happen or to mitigate the effect of it.  This proposal basically forces you to feel the full effect of other people&#39;s mistakes (thinking that it will discourage them from making them in the first place).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Your only real mechanism for feedback is when users of your library complain to you that something that they need isn’t subclass-able.  This is the point where most framework authors will actually learn that this feature/default exists.  Users of a framework will learn of it slightly earlier, when they find they need to subclass something, and it just isn’t possible.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I would much prefer adding a ‘sealed’ keyword which library authors could use to annotate things which they do not want subclassed outside of the module.  Or preferably, as others have suggested, allow augmentation of ‘final’ with ‘public(final)&#39; or ‘internal(final)’.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The only case where I would support ‘sealed’ by default is if there are 3 levels: open, sealed, final.  Final would allow &#39;public(final)&#39; and &#39;internal(final)’ to allow private subclassing inside the file/module.  Sealed would be the same, except it would allow the user to subclass by explicitly acknowledging the risk using ‘unsafe’:  “unsafe class MySubclass:SealedSuper“ and  “unsafe override func”.  Final would not allow the override.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That is the case where ‘sealed’ makes sense as a default…<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt; Jon<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; P.S. The current proposal will only cause massive problems down the line, IMHO.  We will find an escape hatch is needed, but we will have made optimizations based on assumptions of finality which prevent us from easily adding one.<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/c4db7ee4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 10, 2016 at 07:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 6:45 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt; @Jonathan<br>&gt; <br>&gt; I don’t think that &quot;pre-breaking code&quot; is a good description. You are not breaking anything - you’re just not allowing something that *could* become unsafe. It’s safety first, at the cost of the library user’s flexibility.<br></p><p>It is pre-breaking in that it is the exact same code that doesn’t work in both cases (only in the pre-breaking case, a bunch of other code also doesn’t work).  I know it feels different because it “was never possible” vs our change being the cause, but it is one of those things like me giving you $5 or giving you $10 and later taking back $5.  As humans we are loss averse so we devise strategies to hide the loss from ourselves.<br></p><p><br>&gt; That said, I actually think you have a good point however that “sealed” should be able to be overridden, either in a patch capacity or an “unsafe” capacity. Should this become final at a later point, you have acknowledged you know this will be unsafe and are willing to take this risk to get the job done. This is opt-in risk.<br>&gt; <br>&gt; Perhaps however this shouldn’t be “sealed” declaratively. Perhaps we just have a keyword for “Open” as an access level, and if you subclass or override things that are not “open” from other modules, you must mark unsafe.<br>&gt; <br>&gt; I think this is a decent compromise: We allow potential to patch, but discourage without acknowledgement of the risk. Allow Final and Open to be declarative.<br></p><p>Pretty much, but it is important IMHO to separate this from access levels.  They need to be orthogonal concepts or it will be confusing (e.g. why are structs “public” but classes “open”?).  <br></p><p>The default in that case would actually be ‘sealed internal(open)’ which would suck to type repeatedly, but you won’t have to because it is the default.  The thing you would type often would be ‘public open’, which is shorter than the new keywords in the proposal (and consistent for both classes and methods instead of learning different words)<br></p><p>I think we basically agree overall.<br></p><p>Thanks,<br>Jon<br></p><p><br>&gt; <br>&gt; - Rod<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On 11 Jul 2016, at 11:05 AM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; @Rod:  Thank you for actually replying to the content of my post.  Much appreciated.<br>&gt;&gt; <br>&gt;&gt; It is a trolly problem.  You are arguing that pre-breaking everyone&#39;s code is better (even if causes way more trouble overall) than taking an action that breaks a few people’s code later (and thus feeling responsible).  There are other options. I grew up watching enough Star Trek that I don’t believe in no win scenarios.<br>&gt;&gt; <br>&gt;&gt; I still think my compromise is the best solution.  3 levels: Open, Sealed, Final.  The difference is that sealed can be overridden with a compiler warning and use of “unsafe” keyword, but final can’t be overridden.  That way the user is acknowledging that they are doing something which isn’t supported in the context which they are doing it… but it doesn’t completely prevent it by default.  Opt-out safety.  (Yes you lose some compiler optimizations in the default case, but that was premature optimization anyway).<br>&gt;&gt; <br>&gt;&gt; As for the interaction with public/internal/etc… that should be explicit.  This proposal confuses and intermingles them.  You should just be able to say ‘public final internal(open)’ or some other syntax which lets you express the same sentiment.  (The above says the class/method is public and final, but internally it is open.)<br>&gt;&gt; <br>&gt;&gt; I am not saying that we shouldn’t solve these issues.  I am saying this proposal:<br>&gt;&gt; 1) Isn’t easily discoverable.<br>&gt;&gt; 2) Requires communication between different parties (author and user) which slows iteration cycles to weeks or months (vs the usual minutes)<br>&gt;&gt; 3) Conflates/mixes the ideas of access level and subclass-ability<br>&gt;&gt; 4) Makes way too many separate changes in a single proposal: New idea of “sealed”, new default, replaces ‘public’ in some cases but not others, new keywords (which everyone wants to change), etc…<br>&gt;&gt; 5) Has structural problems which mean that it won’t actually increase thoughtfulness<br>&gt;&gt; 6) Makes app developers extremely dependent on framework authors (and those author’s schedules)<br>&gt;&gt; 7) Will require us to patch/fix it later, but that will be difficult due to optimizations/assumptions of finality.<br>&gt;&gt; 8) Will cause unnecessary pain for both framework authors and users of frameworks<br>&gt;&gt; <br>&gt;&gt; We would be foolish to accept this proposal without planning for the inevitable escape hatch.  We will need it, and if we don’t plan for it, it will break everything when we are forced to fix it in Swift 4/5.  Anything else is idealistic to the point of ignoring real-world use/behavior.<br>&gt;&gt; <br>&gt;&gt; As I said before, this type of thinking: “If we just make things more difficult, it will encourage awareness” is what leads to the DMV, TSA, and Java.  The problem is, the brain doesn’t work that way, and it ultimately just adds pain without being effective.  You can add forcing functions (like optional unwrapping), which are annoying, but effective… but as I also mentioned before this proposal doesn’t do that.  It is structurally different.  It will not do what you think it does.<br>&gt;&gt; <br>&gt;&gt; Thanks,<br>&gt;&gt; Jon<br>&gt;&gt; <br>&gt;&gt; P.S.  There is also a dangerous difference between helping the programmer catch mistakes (e.g. don’t accidentally subclass the wrong method) and trying to prevent them from coding in a style you disagree with.  I have been seeing far to many proposals of the second variety of late.<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Jul 10, 2016, at 2:58 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I personally agree with most of your assessments. It&#39;s why I pushed so hard for &quot;allow subclassing my default&quot; in the first discussion of this point.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The problem with this is simple: you cannot retroactively &quot;close up&quot; an API. I cannot add final to a class I have previously declared as non-final. I also can seal a class which has previously been open to subclassing.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Consider: someone builds against my framework and I do nothing, and they subclass my classes. Then later I come through and mark the classes as &quot;Sealed&quot;. What should we do with those classes that are subclassing my classes? Nothing. I can&#39;t. I permitted access and now I&#39;m beholden to that access level.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On the other hand, opening up access levels gradually has no such issues. Users of my class can&#39;t subclass, and then they can. They just have another tool in the bag now.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If you want a default, it should be one you can reverse later. Your default should not be the most restrictive.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Whilst I agree with most of your points, this core concept seems to trump them to my mind.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Rod<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On 10 Jul. 2016, at 5:51 am, Jonathan Hull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Please stop saying that this proposal will bring more consideration to the design of libraries.  It isn’t true.  I haven’t even seen an argument for why it would be true, it is just taken for granted that it is true.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; As I mentioned in another post, this is structurally very different from things like ‘if-let’ and optionals.  Optionals force the user to consider their decision in the context it is being used (i.e. as you use the optional/value).  This proposal, however, does the opposite.  The effect of your actions appear in the context of a completely different user.  It is like sitting in a room, flipping a light switch wondering “I wonder what this does?”… meanwhile the people downstairs are wondering why their lights keep turning off and on”.  <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; You can try to test for this, but by definition library authors can only test for scenarios that they have thought of.  I have often found people surprise me with their use-cases.  Relying on the diligence of other programmers is what leads to things like: &quot;You always need to remember to test for zero before using a pointer&quot;.  Literally the opposite of optionals!  It sounds good, but at the end of the day, people are human and they WILL make mistakes.  Best to either catch those mistakes in the context where they happen or to mitigate the effect of it.  This proposal basically forces you to feel the full effect of other people&#39;s mistakes (thinking that it will discourage them from making them in the first place).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Your only real mechanism for feedback is when users of your library complain to you that something that they need isn’t subclass-able.  This is the point where most framework authors will actually learn that this feature/default exists.  Users of a framework will learn of it slightly earlier, when they find they need to subclass something, and it just isn’t possible.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I would much prefer adding a ‘sealed’ keyword which library authors could use to annotate things which they do not want subclassed outside of the module.  Or preferably, as others have suggested, allow augmentation of ‘final’ with ‘public(final)&#39; or ‘internal(final)’.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The only case where I would support ‘sealed’ by default is if there are 3 levels: open, sealed, final.  Final would allow &#39;public(final)&#39; and &#39;internal(final)’ to allow private subclassing inside the file/module.  Sealed would be the same, except it would allow the user to subclass by explicitly acknowledging the risk using ‘unsafe’:  “unsafe class MySubclass:SealedSuper“ and  “unsafe override func”.  Final would not allow the override.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That is the case where ‘sealed’ makes sense as a default…<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Thanks,<br>&gt;&gt;&gt;&gt; Jon<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; P.S. The current proposal will only cause massive problems down the line, IMHO.  We will find an escape hatch is needed, but we will have made optimizations based on assumptions of finality which prevent us from easily adding one.<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160710/7920605e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 11, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt; It is pre-breaking in that it is the exact same code that doesn’t work in both cases (only in the pre-breaking case, a bunch of other code also doesn’t work).  I know it feels different because it “was never possible” vs our change being the cause, but it is one of those things like me giving you $5 or giving you $10 and later taking back $5.  As humans we are loss averse so we devise strategies to hide the loss from ourselves.<br></p><p>I completely disagree with this.<br></p><p> Not providing someone something due to risk of breakage is not the same thing as “giving it and taking it away”. We don’t build bridges out of spare parts and tell people “We build it but we expect it to break at some stage, so use with caution.” You either build it correctly, or you don’t let people cross the bridge. At All.<br></p><p>This isn’t about “loss averse”. This is about risk management.<br></p><p>Where does the line lie on risk? That’s ultimately something the core team will have to decide.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c354b21edb9ba56fe6b42950e08195fa?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jonathan Hull</string> &lt;jhull at gbis.com&gt;<p>July 11, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; On Jul 10, 2016, at 7:48 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; <br>&gt;&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; It is pre-breaking in that it is the exact same code that doesn’t work in both cases (only in the pre-breaking case, a bunch of other code also doesn’t work).  I know it feels different because it “was never possible” vs our change being the cause, but it is one of those things like me giving you $5 or giving you $10 and later taking back $5.  As humans we are loss averse so we devise strategies to hide the loss from ourselves.<br>&gt; <br>&gt; I completely disagree with this.<br>&gt; <br>&gt; Not providing someone something due to risk of breakage is not the same thing as “giving it and taking it away”. We don’t build bridges out of spare parts and tell people “We build it but we expect it to break at some stage, so use with caution.” You either build it correctly, or you don’t let people cross the bridge. At All.<br>&gt; <br>&gt; This isn’t about “loss averse”. This is about risk management.<br>&gt; <br>&gt; Where does the line lie on risk? That’s ultimately something the core team will have to decide.<br></p><p>My point is that you are completely ignoring an entire class of risk that has a real-world $$$ cost.  Every time I have to use a framework under this proposal, I am now completely at the mercy of the author.  In the case of open source frameworks I can at least make a fork, but for closed source frameworks (often from large companies where us using their framework has been negotiated by the bosses) you have now just added weeks to my development cycle while I wait for big-company-who-doesn’t-really-care-that-much to update their stuff. (sure I can work on other things during that time, but delaying a launch isn’t free)<br></p><p>Are you offering to explain to my boss/client why I can’t add the feature in a reasonable timeframe like I can with Objective C frameworks?  That it may not even be possible now in Swift even though the Android guy just did it in a few hours?  <br></p><p>Do you know what I am going to tell my boss/client?  &quot;Don’t use Swift for frameworks” and “Try to avoid partnering with companies that have Swift frameworks”.  &quot;It is too much of a risk&quot;.  &quot;We are giving them too much control over the future of our product…&quot;  I mean, it even affects the prices that companies can charge for crappy frameworks. If I am asking for a bunch of features that I NEED them to add to provide a basic feature, that affects negotiations/price (vs a world where I can add it myself if needed).  Sealed-by-default gives them leverage.<br></p><p>To use your bridge analogy, which is better in the case that you haven’t provided a bridge for me:<br>1) I build my own bridge knowing that I will need to maintain it periodically (usually on a predictable schedule)<br>2) Have everyone wait for 6 months (loosing $ the whole time) while I plead with you to build the bridge for me.<br></p><p>By definition, the least thought through frameworks are the ones most likely to need workarounds, but under this proposal, they are also the ones we will be unable to fix.  I think some people think that this proposal will make them fix those frameworks or make them disappear… but they are often from big brand name companies, who don’t care that much because tech isn’t their main business.  In my experience, we can get the changes we need, but it takes anywhere from 2 months to a year.  Being able to patch in a stop-gap while we are waiting is very important for the health of the business.<br></p><p>For example, I had a recent client that called me in a panic (unfortunately I have somehow gotten a reputation as someone to call for impossible tasks) because they had a demo they needed to show for a potential multimillion dollar deal and it just wasn’t working.  The tech they had used as a base wasn’t doing what it was supposed to… and the fixes were 3-6 months away (the demo was a week and a half away).  I would call the support guy for the tech, and they would tell me “that isn’t possible yet. Just wait for the update”.  I would call them back a couple of hours later saying “If someone else asks, here is how I did it…”  Was that code beautiful? No.  Did I get all the features in that demo working?  Yes, with something like 1 hour to spare.  The demo went very very well.<br></p><p>Should I have let that deal fall through because it wasn’t the “proper” ideological way to write code?  Sometimes things just need to get done and there isn’t another way….  A few people have suggested that these types of concerns aren’t relevant, but I find them very relevant to my everyday life.  This is the first proposal with the ability to actually cost me (and my clients) money.<br></p><p>I am completely ok with needing to type “unsafe” (or similar) to acknowledge and take responsibility for my actions in those situations.  I understand those modifications might break when the framework is finally updated in 3-6 months (hopefully we can even remove them at that point).  Just don’t “safety&quot; my clients out of business by making working around bad frameworks impossible.<br></p><p>One last analogy.  At a restaurant, they might be afraid I would cut myself with a sharp knife.  They don’t force me to wear mittens or otherwise make using knifes impossible.  They give everyone butterknives, but I can always get a real knife if I ask for one.  If I order steak, I don’t even have to ask… they just bring me a real knife.  This is how Swift has been and should continue to be IMHO.  Prevent me from subclassing accidentally, but if I acknowledge the risk, let me do it.  “Safe-by-default” != “Impossible-by-default” <br></p><p>Thanks,<br>Jon<br></p><p>P.S. This discussion is reminding me of one of my favorite blogs.  He often talks about the tension between doing things right, and actually getting out there and doing things.  Here is a good/relevant article:<br>http://prog21.dadgum.com/87.html<br></p><p><br>-<br>-<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>July 12, 2016 at 12:00:00am</p></header><div class="content"><p>Thank you for putting your real world scenario out there too. I think you<br>made some pragmatic points about life of application developers depending<br>on other companies libraries and I am curious to see more debate on that<br>point of view.<br></p><p>On Tue, Jul 12, 2016 at 12:00 AM, Jonathan Hull via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt; &gt; On Jul 10, 2016, at 7:48 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; It is pre-breaking in that it is the exact same code that doesn’t work<br>&gt; in both cases (only in the pre-breaking case, a bunch of other code also<br>&gt; doesn’t work).  I know it feels different because it “was never possible”<br>&gt; vs our change being the cause, but it is one of those things like me giving<br>&gt; you $5 or giving you $10 and later taking back $5.  As humans we are loss<br>&gt; averse so we devise strategies to hide the loss from ourselves.<br>&gt; &gt;<br>&gt; &gt; I completely disagree with this.<br>&gt; &gt;<br>&gt; &gt; Not providing someone something due to risk of breakage is not the same<br>&gt; thing as “giving it and taking it away”. We don’t build bridges out of<br>&gt; spare parts and tell people “We build it but we expect it to break at some<br>&gt; stage, so use with caution.” You either build it correctly, or you don’t<br>&gt; let people cross the bridge. At All.<br>&gt; &gt;<br>&gt; &gt; This isn’t about “loss averse”. This is about risk management.<br>&gt; &gt;<br>&gt; &gt; Where does the line lie on risk? That’s ultimately something the core<br>&gt; team will have to decide.<br>&gt;<br>&gt; My point is that you are completely ignoring an entire class of risk that<br>&gt; has a real-world $$$ cost.  Every time I have to use a framework under this<br>&gt; proposal, I am now completely at the mercy of the author.  In the case of<br>&gt; open source frameworks I can at least make a fork, but for closed source<br>&gt; frameworks (often from large companies where us using their framework has<br>&gt; been negotiated by the bosses) you have now just added weeks to my<br>&gt; development cycle while I wait for<br>&gt; big-company-who-doesn’t-really-care-that-much to update their stuff. (sure<br>&gt; I can work on other things during that time, but delaying a launch isn’t<br>&gt; free)<br>&gt;<br>&gt; Are you offering to explain to my boss/client why I can’t add the feature<br>&gt; in a reasonable timeframe like I can with Objective C frameworks?  That it<br>&gt; may not even be possible now in Swift even though the Android guy just did<br>&gt; it in a few hours?<br>&gt;<br>&gt; Do you know what I am going to tell my boss/client?  &quot;Don’t use Swift for<br>&gt; frameworks” and “Try to avoid partnering with companies that have Swift<br>&gt; frameworks”.  &quot;It is too much of a risk&quot;.  &quot;We are giving them too much<br>&gt; control over the future of our product…&quot;  I mean, it even affects the<br>&gt; prices that companies can charge for crappy frameworks. If I am asking for<br>&gt; a bunch of features that I NEED them to add to provide a basic feature,<br>&gt; that affects negotiations/price (vs a world where I can add it myself if<br>&gt; needed).  Sealed-by-default gives them leverage.<br>&gt;<br>&gt; To use your bridge analogy, which is better in the case that you haven’t<br>&gt; provided a bridge for me:<br>&gt; 1) I build my own bridge knowing that I will need to maintain it<br>&gt; periodically (usually on a predictable schedule)<br>&gt; 2) Have everyone wait for 6 months (loosing $ the whole time) while I<br>&gt; plead with you to build the bridge for me.<br>&gt;<br>&gt; By definition, the least thought through frameworks are the ones most<br>&gt; likely to need workarounds, but under this proposal, they are also the ones<br>&gt; we will be unable to fix.  I think some people think that this proposal<br>&gt; will make them fix those frameworks or make them disappear… but they are<br>&gt; often from big brand name companies, who don’t care that much because tech<br>&gt; isn’t their main business.  In my experience, we can get the changes we<br>&gt; need, but it takes anywhere from 2 months to a year.  Being able to patch<br>&gt; in a stop-gap while we are waiting is very important for the health of the<br>&gt; business.<br>&gt;<br>&gt; For example, I had a recent client that called me in a panic<br>&gt; (unfortunately I have somehow gotten a reputation as someone to call for<br>&gt; impossible tasks) because they had a demo they needed to show for a<br>&gt; potential multimillion dollar deal and it just wasn’t working.  The tech<br>&gt; they had used as a base wasn’t doing what it was supposed to… and the fixes<br>&gt; were 3-6 months away (the demo was a week and a half away).  I would call<br>&gt; the support guy for the tech, and they would tell me “that isn’t possible<br>&gt; yet. Just wait for the update”.  I would call them back a couple of hours<br>&gt; later saying “If someone else asks, here is how I did it…”  Was that code<br>&gt; beautiful? No.  Did I get all the features in that demo working?  Yes, with<br>&gt; something like 1 hour to spare.  The demo went very very well.<br>&gt;<br>&gt; Should I have let that deal fall through because it wasn’t the “proper”<br>&gt; ideological way to write code?  Sometimes things just need to get done and<br>&gt; there isn’t another way….  A few people have suggested that these types of<br>&gt; concerns aren’t relevant, but I find them very relevant to my everyday<br>&gt; life.  This is the first proposal with the ability to actually cost me (and<br>&gt; my clients) money.<br>&gt;<br>&gt; I am completely ok with needing to type “unsafe” (or similar) to<br>&gt; acknowledge and take responsibility for my actions in those situations.  I<br>&gt; understand those modifications might break when the framework is finally<br>&gt; updated in 3-6 months (hopefully we can even remove them at that point).<br>&gt; Just don’t “safety&quot; my clients out of business by making working around bad<br>&gt; frameworks impossible.<br>&gt;<br>&gt; One last analogy.  At a restaurant, they might be afraid I would cut<br>&gt; myself with a sharp knife.  They don’t force me to wear mittens or<br>&gt; otherwise make using knifes impossible.  They give everyone butterknives,<br>&gt; but I can always get a real knife if I ask for one.  If I order steak, I<br>&gt; don’t even have to ask… they just bring me a real knife.  This is how Swift<br>&gt; has been and should continue to be IMHO.  Prevent me from subclassing<br>&gt; accidentally, but if I acknowledge the risk, let me do it.<br>&gt; “Safe-by-default” != “Impossible-by-default”<br>&gt;<br>&gt; Thanks,<br>&gt; Jon<br>&gt;<br>&gt; P.S. This discussion is reminding me of one of my favorite blogs.  He<br>&gt; often talks about the tension between doing things right, and actually<br>&gt; getting out there and doing things.  Here is a good/relevant article:<br>&gt; http://prog21.dadgum.com/87.html<br>&gt;<br>&gt;<br>&gt; -<br>&gt; -<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/3c7090ae/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/f526807a5a76bc96427760ca78707cfb?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jon Akhtar</string> &lt;jona at herbalife.com&gt;<p>July 12, 2016 at 03:00:00pm</p></header><div class="content"><p>I completely agree, the programmer should have as much power as we can<br>give them, even if it means allowing them to shoot themselves in the foot,<br>because at the end of the day Swift isn¹t an academic exercise, it is a<br>real world programming language, so it should be optimized for solving<br>real world problems not having some kind of technical, philosophical, and<br>stylistic perfection when those come at the cost of the former.<br></p><p>So -1<br></p><p>-Jon<br></p><p>On 7/11/16, 16:00, &quot;swift-evolution-bounces at swift.org on behalf of<br>Jonathan Hull via swift-evolution&quot; &lt;swift-evolution-bounces at swift.org on<br>behalf of swift-evolution at swift.org&gt; wrote:<br></p><p>&gt;<br>&gt;&gt; On Jul 10, 2016, at 7:48 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is pre-breaking in that it is the exact same code that doesn¹t work<br>&gt;&gt;&gt;in both cases (only in the pre-breaking case, a bunch of other code<br>&gt;&gt;&gt;also doesn¹t work).  I know it feels different because it ³was never<br>&gt;&gt;&gt;possible² vs our change being the cause, but it is one of those things<br>&gt;&gt;&gt;like me giving you $5 or giving you $10 and later taking back $5.  As<br>&gt;&gt;&gt;humans we are loss averse so we devise strategies to hide the loss from<br>&gt;&gt;&gt;ourselves.<br>&gt;&gt; <br>&gt;&gt; I completely disagree with this.<br>&gt;&gt; <br>&gt;&gt; Not providing someone something due to risk of breakage is not the same<br>&gt;&gt;thing as ³giving it and taking it away². We don¹t build bridges out of<br>&gt;&gt;spare parts and tell people ³We build it but we expect it to break at<br>&gt;&gt;some stage, so use with caution.² You either build it correctly, or you<br>&gt;&gt;don¹t let people cross the bridge. At All.<br>&gt;&gt; <br>&gt;&gt; This isn¹t about ³loss averse². This is about risk management.<br>&gt;&gt; <br>&gt;&gt; Where does the line lie on risk? That¹s ultimately something the core<br>&gt;&gt;team will have to decide.<br>&gt;<br>&gt;My point is that you are completely ignoring an entire class of risk that<br>&gt;has a real-world $$$ cost.  Every time I have to use a framework under<br>&gt;this proposal, I am now completely at the mercy of the author.  In the<br>&gt;case of open source frameworks I can at least make a fork, but for closed<br>&gt;source frameworks (often from large companies where us using their<br>&gt;framework has been negotiated by the bosses) you have now just added<br>&gt;weeks to my development cycle while I wait for<br>&gt;big-company-who-doesn¹t-really-care-that-much to update their stuff.<br>&gt;(sure I can work on other things during that time, but delaying a launch<br>&gt;isn¹t free)<br>&gt;<br>&gt;Are you offering to explain to my boss/client why I can¹t add the feature<br>&gt;in a reasonable timeframe like I can with Objective C frameworks?  That<br>&gt;it may not even be possible now in Swift even though the Android guy just<br>&gt;did it in a few hours?<br>&gt;<br>&gt;Do you know what I am going to tell my boss/client?  &quot;Don¹t use Swift for<br>&gt;frameworks² and ³Try to avoid partnering with companies that have Swift<br>&gt;frameworks².  &quot;It is too much of a risk&quot;.  &quot;We are giving them too much<br>&gt;control over the future of our productŠ&quot;  I mean, it even affects the<br>&gt;prices that companies can charge for crappy frameworks. If I am asking<br>&gt;for a bunch of features that I NEED them to add to provide a basic<br>&gt;feature, that affects negotiations/price (vs a world where I can add it<br>&gt;myself if needed).  Sealed-by-default gives them leverage.<br>&gt;<br>&gt;To use your bridge analogy, which is better in the case that you haven¹t<br>&gt;provided a bridge for me:<br>&gt;1) I build my own bridge knowing that I will need to maintain it<br>&gt;periodically (usually on a predictable schedule)<br>&gt;2) Have everyone wait for 6 months (loosing $ the whole time) while I<br>&gt;plead with you to build the bridge for me.<br>&gt;<br>&gt;By definition, the least thought through frameworks are the ones most<br>&gt;likely to need workarounds, but under this proposal, they are also the<br>&gt;ones we will be unable to fix.  I think some people think that this<br>&gt;proposal will make them fix those frameworks or make them disappearŠ but<br>&gt;they are often from big brand name companies, who don¹t care that much<br>&gt;because tech isn¹t their main business.  In my experience, we can get the<br>&gt;changes we need, but it takes anywhere from 2 months to a year.  Being<br>&gt;able to patch in a stop-gap while we are waiting is very important for<br>&gt;the health of the business.<br>&gt;<br>&gt;For example, I had a recent client that called me in a panic<br>&gt;(unfortunately I have somehow gotten a reputation as someone to call for<br>&gt;impossible tasks) because they had a demo they needed to show for a<br>&gt;potential multimillion dollar deal and it just wasn¹t working.  The tech<br>&gt;they had used as a base wasn¹t doing what it was supposed toŠ and the<br>&gt;fixes were 3-6 months away (the demo was a week and a half away).  I<br>&gt;would call the support guy for the tech, and they would tell me ³that<br>&gt;isn¹t possible yet. Just wait for the update².  I would call them back a<br>&gt;couple of hours later saying ³If someone else asks, here is how I did<br>&gt;itŠ²  Was that code beautiful? No.  Did I get all the features in that<br>&gt;demo working?  Yes, with something like 1 hour to spare.  The demo went<br>&gt;very very well.<br>&gt;<br>&gt;Should I have let that deal fall through because it wasn¹t the ³proper²<br>&gt;ideological way to write code?  Sometimes things just need to get done<br>&gt;and there isn¹t another wayŠ.  A few people have suggested that these<br>&gt;types of concerns aren¹t relevant, but I find them very relevant to my<br>&gt;everyday life.  This is the first proposal with the ability to actually<br>&gt;cost me (and my clients) money.<br>&gt;<br>&gt;I am completely ok with needing to type ³unsafe² (or similar) to<br>&gt;acknowledge and take responsibility for my actions in those situations.<br>&gt;I understand those modifications might break when the framework is<br>&gt;finally updated in 3-6 months (hopefully we can even remove them at that<br>&gt;point).  Just don¹t ³safety&quot; my clients out of business by making working<br>&gt;around bad frameworks impossible.<br>&gt;<br>&gt;One last analogy.  At a restaurant, they might be afraid I would cut<br>&gt;myself with a sharp knife.  They don¹t force me to wear mittens or<br>&gt;otherwise make using knifes impossible.  They give everyone butterknives,<br>&gt;but I can always get a real knife if I ask for one.  If I order steak, I<br>&gt;don¹t even have to askŠ they just bring me a real knife.  This is how<br>&gt;Swift has been and should continue to be IMHO.  Prevent me from<br>&gt;subclassing accidentally, but if I acknowledge the risk, let me do it.<br>&gt;³Safe-by-default² != ³Impossible-by-default²<br>&gt;<br>&gt;Thanks,<br>&gt;Jon<br>&gt;<br>&gt;P.S. This discussion is reminding me of one of my favorite blogs.  He<br>&gt;often talks about the tension between doing things right, and actually<br>&gt;getting out there and doing things.  Here is a good/relevant article:<br>&gt;http://prog21.dadgum.com/87.html<br>&gt;<br>&gt;<br>&gt;-<br>&gt;-<br>&gt;_______________________________________________<br>&gt;swift-evolution mailing list<br>&gt;swift-evolution at swift.org<br>&gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/46439321e8b5b5ba0944eef50e18c3a3?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Denis Muys</string> &lt;jdmuys at gmail.com&gt;<p>July 12, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt;<br>&gt;         * What is your evaluation of the proposal?<br>&gt;<br></p><p>I am strongly opposed to that proposal. I am mostly a lurker on this list,<br>the volume of which I cannot cope with. However, I feel this proposal is<br>important enough that I decided to invest more time than usual.<br>So I have read carefully the arguments presented here.<br>And I am still opposed to the proposal.<br>I believe no programmer, least of which myself, can be trusted with the<br>decision to reliably decide ahead of time that this or that class cannot or<br>will not be subclassed.<br>So strong -1 for me.<br></p><p><br>&gt;         * Is the problem being addressed significant enough to warrant a<br>&gt; change to Swift?<br>&gt;<br></p><p>I don&#39;t think the problem is a problem at all.<br></p><p><br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt;<br></p><p>Not in my mind. Swift aims for safety, but not at the price of inflexibility<br></p><p><br>        * If you have used other languages or libraries with a similar<br>feature, how do you feel that this proposal compares to those?<br></p><p>I would compare it for example to the decision for the C++ developer to<br>mark methods virtual or not, with the usual recommendation to mark<br>everything virtual, especially the destructor<br></p><p>        * How much effort did you put into your review? A glance, a quick<br>reading, or an in-depth study?<br></p><p>I read it and ready carefully the debate on this list.<br></p><p><br>On Tue, Jul 12, 2016 at 5:36 PM, Jon Akhtar via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I completely agree, the programmer should have as much power as we can<br>&gt; give them, even if it means allowing them to shoot themselves in the foot,<br>&gt; because at the end of the day Swift isn¹t an academic exercise, it is a<br>&gt; real world programming language, so it should be optimized for solving<br>&gt; real world problems not having some kind of technical, philosophical, and<br>&gt; stylistic perfection when those come at the cost of the former.<br>&gt;<br>&gt; So -1<br>&gt;<br>&gt; -Jon<br>&gt;<br>&gt; On 7/11/16, 16:00, &quot;swift-evolution-bounces at swift.org on behalf of<br>&gt; Jonathan Hull via swift-evolution&quot; &lt;swift-evolution-bounces at swift.org on<br>&gt; behalf of swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 10, 2016, at 7:48 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt;<br>&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It is pre-breaking in that it is the exact same code that doesn¹t work<br>&gt; &gt;&gt;&gt;in both cases (only in the pre-breaking case, a bunch of other code<br>&gt; &gt;&gt;&gt;also doesn¹t work).  I know it feels different because it ³was never<br>&gt; &gt;&gt;&gt;possible² vs our change being the cause, but it is one of those things<br>&gt; &gt;&gt;&gt;like me giving you $5 or giving you $10 and later taking back $5.  As<br>&gt; &gt;&gt;&gt;humans we are loss averse so we devise strategies to hide the loss from<br>&gt; &gt;&gt;&gt;ourselves.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I completely disagree with this.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Not providing someone something due to risk of breakage is not the same<br>&gt; &gt;&gt;thing as ³giving it and taking it away². We don¹t build bridges out of<br>&gt; &gt;&gt;spare parts and tell people ³We build it but we expect it to break at<br>&gt; &gt;&gt;some stage, so use with caution.² You either build it correctly, or you<br>&gt; &gt;&gt;don¹t let people cross the bridge. At All.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This isn¹t about ³loss averse². This is about risk management.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Where does the line lie on risk? That¹s ultimately something the core<br>&gt; &gt;&gt;team will have to decide.<br>&gt; &gt;<br>&gt; &gt;My point is that you are completely ignoring an entire class of risk that<br>&gt; &gt;has a real-world $$$ cost.  Every time I have to use a framework under<br>&gt; &gt;this proposal, I am now completely at the mercy of the author.  In the<br>&gt; &gt;case of open source frameworks I can at least make a fork, but for closed<br>&gt; &gt;source frameworks (often from large companies where us using their<br>&gt; &gt;framework has been negotiated by the bosses) you have now just added<br>&gt; &gt;weeks to my development cycle while I wait for<br>&gt; &gt;big-company-who-doesn¹t-really-care-that-much to update their stuff.<br>&gt; &gt;(sure I can work on other things during that time, but delaying a launch<br>&gt; &gt;isn¹t free)<br>&gt; &gt;<br>&gt; &gt;Are you offering to explain to my boss/client why I can¹t add the feature<br>&gt; &gt;in a reasonable timeframe like I can with Objective C frameworks?  That<br>&gt; &gt;it may not even be possible now in Swift even though the Android guy just<br>&gt; &gt;did it in a few hours?<br>&gt; &gt;<br>&gt; &gt;Do you know what I am going to tell my boss/client?  &quot;Don¹t use Swift for<br>&gt; &gt;frameworks² and ³Try to avoid partnering with companies that have Swift<br>&gt; &gt;frameworks².  &quot;It is too much of a risk&quot;.  &quot;We are giving them too much<br>&gt; &gt;control over the future of our productŠ&quot;  I mean, it even affects the<br>&gt; &gt;prices that companies can charge for crappy frameworks. If I am asking<br>&gt; &gt;for a bunch of features that I NEED them to add to provide a basic<br>&gt; &gt;feature, that affects negotiations/price (vs a world where I can add it<br>&gt; &gt;myself if needed).  Sealed-by-default gives them leverage.<br>&gt; &gt;<br>&gt; &gt;To use your bridge analogy, which is better in the case that you haven¹t<br>&gt; &gt;provided a bridge for me:<br>&gt; &gt;1) I build my own bridge knowing that I will need to maintain it<br>&gt; &gt;periodically (usually on a predictable schedule)<br>&gt; &gt;2) Have everyone wait for 6 months (loosing $ the whole time) while I<br>&gt; &gt;plead with you to build the bridge for me.<br>&gt; &gt;<br>&gt; &gt;By definition, the least thought through frameworks are the ones most<br>&gt; &gt;likely to need workarounds, but under this proposal, they are also the<br>&gt; &gt;ones we will be unable to fix.  I think some people think that this<br>&gt; &gt;proposal will make them fix those frameworks or make them disappearŠ but<br>&gt; &gt;they are often from big brand name companies, who don¹t care that much<br>&gt; &gt;because tech isn¹t their main business.  In my experience, we can get the<br>&gt; &gt;changes we need, but it takes anywhere from 2 months to a year.  Being<br>&gt; &gt;able to patch in a stop-gap while we are waiting is very important for<br>&gt; &gt;the health of the business.<br>&gt; &gt;<br>&gt; &gt;For example, I had a recent client that called me in a panic<br>&gt; &gt;(unfortunately I have somehow gotten a reputation as someone to call for<br>&gt; &gt;impossible tasks) because they had a demo they needed to show for a<br>&gt; &gt;potential multimillion dollar deal and it just wasn¹t working.  The tech<br>&gt; &gt;they had used as a base wasn¹t doing what it was supposed toŠ and the<br>&gt; &gt;fixes were 3-6 months away (the demo was a week and a half away).  I<br>&gt; &gt;would call the support guy for the tech, and they would tell me ³that<br>&gt; &gt;isn¹t possible yet. Just wait for the update².  I would call them back a<br>&gt; &gt;couple of hours later saying ³If someone else asks, here is how I did<br>&gt; &gt;itŠ²  Was that code beautiful? No.  Did I get all the features in that<br>&gt; &gt;demo working?  Yes, with something like 1 hour to spare.  The demo went<br>&gt; &gt;very very well.<br>&gt; &gt;<br>&gt; &gt;Should I have let that deal fall through because it wasn¹t the ³proper²<br>&gt; &gt;ideological way to write code?  Sometimes things just need to get done<br>&gt; &gt;and there isn¹t another wayŠ.  A few people have suggested that these<br>&gt; &gt;types of concerns aren¹t relevant, but I find them very relevant to my<br>&gt; &gt;everyday life.  This is the first proposal with the ability to actually<br>&gt; &gt;cost me (and my clients) money.<br>&gt; &gt;<br>&gt; &gt;I am completely ok with needing to type ³unsafe² (or similar) to<br>&gt; &gt;acknowledge and take responsibility for my actions in those situations.<br>&gt; &gt;I understand those modifications might break when the framework is<br>&gt; &gt;finally updated in 3-6 months (hopefully we can even remove them at that<br>&gt; &gt;point).  Just don¹t ³safety&quot; my clients out of business by making working<br>&gt; &gt;around bad frameworks impossible.<br>&gt; &gt;<br>&gt; &gt;One last analogy.  At a restaurant, they might be afraid I would cut<br>&gt; &gt;myself with a sharp knife.  They don¹t force me to wear mittens or<br>&gt; &gt;otherwise make using knifes impossible.  They give everyone butterknives,<br>&gt; &gt;but I can always get a real knife if I ask for one.  If I order steak, I<br>&gt; &gt;don¹t even have to askŠ they just bring me a real knife.  This is how<br>&gt; &gt;Swift has been and should continue to be IMHO.  Prevent me from<br>&gt; &gt;subclassing accidentally, but if I acknowledge the risk, let me do it.<br>&gt; &gt;³Safe-by-default² != ³Impossible-by-default²<br>&gt; &gt;<br>&gt; &gt;Thanks,<br>&gt; &gt;Jon<br>&gt; &gt;<br>&gt; &gt;P.S. This discussion is reminding me of one of my favorite blogs.  He<br>&gt; &gt;often talks about the tension between doing things right, and actually<br>&gt; &gt;getting out there and doing things.  Here is a good/relevant article:<br>&gt; &gt;http://prog21.dadgum.com/87.html<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;-<br>&gt; &gt;-<br>&gt; &gt;_______________________________________________<br>&gt; &gt;swift-evolution mailing list<br>&gt; &gt;swift-evolution at swift.org<br>&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/8891b567/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>July 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; I believe no programmer, least of which myself, can be trusted with the decision to reliably decide ahead of time that this or that class cannot or will not be subclassed.<br>&gt; So strong -1 for me.<br></p><p>I just don’t get this line of reasoning. Can a programmer be trusted with determining if a type should be declared as a struct vs. a class? If I choose to implement an API construct with a struct, you’ll be the exact same position that this proposal puts you in with classes as well.<br></p><p>I’m a big +1 for this proposal. The default annotations on types should set up code to be as future-proof as possible without putting someone in a bad spot resilience-wise simply because they forgot to add the restriction before shipping.<br></p><p>This proposal also does *not* disallow language features that allow unsafe constructs to be added later. Even with this proposal, it’s still possible to add the __unsafe_really_subclass_even_though_its_bad construct. It requires additional metadata to be kept around by the compiler so that any optimizations that may have removed the dynamic dispatching of functions calls through the inheritance chain to be kept, but it’s still possible.<br></p><p>-David<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/73a38bb7bc9528e31098defe30e68ea4?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Jean-Daniel Dupas</string> &lt;mailing at xenonium.com&gt;<p>July 12, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; Le 12 juil. 2016 à 21:29, Jean-Denis Muys via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br>&gt; <br>&gt;         * What is your evaluation of the proposal?<br>&gt; <br>&gt; I am strongly opposed to that proposal. I am mostly a lurker on this list, the volume of which I cannot cope with. However, I feel this proposal is important enough that I decided to invest more time than usual.<br>&gt; So I have read carefully the arguments presented here.<br>&gt; And I am still opposed to the proposal.<br>&gt; I believe no programmer, least of which myself, can be trusted with the decision to reliably decide ahead of time that this or that class cannot or will not be subclassed.<br></p><p>If you can’t trust a developer, how could you use its library ? Using third-party code involve some kind of trusting, as you would have to trust the developer to write reliable and efficient code, which is IMHO, far more important than knowing if the developer carefully choose what can be subclasses or not.<br></p><p>And when you encounter a library where the dev choose to allow subclassing, you will have far more trust than the code was design to be subclassed.<br></p><p>Some design patterns work better with subclassing than with protocol or delegation. So I’m confident than library developers will ‘open’ there classes if needed.<br></p><p>&gt; So strong -1 for me.<br>&gt;  <br>&gt;         * Is the problem being addressed significant enough to warrant a change to Swift?<br>&gt; <br>&gt; I don&#39;t think the problem is a problem at all.<br>&gt;  <br>&gt;         * Does this proposal fit well with the feel and direction of Swift?<br>&gt; <br>&gt; Not in my mind. Swift aims for safety, but not at the price of inflexibility<br>&gt; <br>&gt; <br>&gt;         * If you have used other languages or libraries with a similar feature, how do you feel that this proposal compares to those?<br>&gt; <br>&gt; I would compare it for example to the decision for the C++ developer to mark methods virtual or not, with the usual recommendation to mark everything virtual, especially the destructor<br>&gt; <br>&gt;         * How much effort did you put into your review? A glance, a quick reading, or an in-depth study?<br>&gt; <br>&gt; I read it and ready carefully the debate on this list.<br>&gt;  <br>&gt; <br>&gt; On Tue, Jul 12, 2016 at 5:36 PM, Jon Akhtar via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I completely agree, the programmer should have as much power as we can<br>&gt; give them, even if it means allowing them to shoot themselves in the foot,<br>&gt; because at the end of the day Swift isn¹t an academic exercise, it is a<br>&gt; real world programming language, so it should be optimized for solving<br>&gt; real world problems not having some kind of technical, philosophical, and<br>&gt; stylistic perfection when those come at the cost of the former.<br>&gt; <br>&gt; So -1<br>&gt; <br>&gt; -Jon<br>&gt; <br>&gt; On 7/11/16, 16:00, &quot;swift-evolution-bounces at swift.org &lt;mailto:swift-evolution-bounces at swift.org&gt; on behalf of<br>&gt; Jonathan Hull via swift-evolution&quot; &lt;swift-evolution-bounces at swift.org &lt;mailto:swift-evolution-bounces at swift.org&gt; on<br>&gt; behalf of swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt; &gt;<br>&gt; &gt;&gt; On Jul 10, 2016, at 7:48 PM, Rod Brown &lt;rodney.brown6 at icloud.com &lt;mailto:rodney.brown6 at icloud.com&gt;&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt;&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com &lt;mailto:jhull at gbis.com&gt;&gt; wrote:<br>&gt; &gt;&gt;&gt;<br>&gt; &gt;&gt;&gt; It is pre-breaking in that it is the exact same code that doesn¹t work<br>&gt; &gt;&gt;&gt;in both cases (only in the pre-breaking case, a bunch of other code<br>&gt; &gt;&gt;&gt;also doesn¹t work).  I know it feels different because it ³was never<br>&gt; &gt;&gt;&gt;possible² vs our change being the cause, but it is one of those things<br>&gt; &gt;&gt;&gt;like me giving you $5 or giving you $10 and later taking back $5.  As<br>&gt; &gt;&gt;&gt;humans we are loss averse so we devise strategies to hide the loss from<br>&gt; &gt;&gt;&gt;ourselves.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; I completely disagree with this.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Not providing someone something due to risk of breakage is not the same<br>&gt; &gt;&gt;thing as ³giving it and taking it away². We don¹t build bridges out of<br>&gt; &gt;&gt;spare parts and tell people ³We build it but we expect it to break at<br>&gt; &gt;&gt;some stage, so use with caution.² You either build it correctly, or you<br>&gt; &gt;&gt;don¹t let people cross the bridge. At All.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This isn¹t about ³loss averse². This is about risk management.<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Where does the line lie on risk? That¹s ultimately something the core<br>&gt; &gt;&gt;team will have to decide.<br>&gt; &gt;<br>&gt; &gt;My point is that you are completely ignoring an entire class of risk that<br>&gt; &gt;has a real-world $$$ cost.  Every time I have to use a framework under<br>&gt; &gt;this proposal, I am now completely at the mercy of the author.  In the<br>&gt; &gt;case of open source frameworks I can at least make a fork, but for closed<br>&gt; &gt;source frameworks (often from large companies where us using their<br>&gt; &gt;framework has been negotiated by the bosses) you have now just added<br>&gt; &gt;weeks to my development cycle while I wait for<br>&gt; &gt;big-company-who-doesn¹t-really-care-that-much to update their stuff.<br>&gt; &gt;(sure I can work on other things during that time, but delaying a launch<br>&gt; &gt;isn¹t free)<br>&gt; &gt;<br>&gt; &gt;Are you offering to explain to my boss/client why I can¹t add the feature<br>&gt; &gt;in a reasonable timeframe like I can with Objective C frameworks?  That<br>&gt; &gt;it may not even be possible now in Swift even though the Android guy just<br>&gt; &gt;did it in a few hours?<br>&gt; &gt;<br>&gt; &gt;Do you know what I am going to tell my boss/client?  &quot;Don¹t use Swift for<br>&gt; &gt;frameworks² and ³Try to avoid partnering with companies that have Swift<br>&gt; &gt;frameworks².  &quot;It is too much of a risk&quot;.  &quot;We are giving them too much<br>&gt; &gt;control over the future of our productŠ&quot;  I mean, it even affects the<br>&gt; &gt;prices that companies can charge for crappy frameworks. If I am asking<br>&gt; &gt;for a bunch of features that I NEED them to add to provide a basic<br>&gt; &gt;feature, that affects negotiations/price (vs a world where I can add it<br>&gt; &gt;myself if needed).  Sealed-by-default gives them leverage.<br>&gt; &gt;<br>&gt; &gt;To use your bridge analogy, which is better in the case that you haven¹t<br>&gt; &gt;provided a bridge for me:<br>&gt; &gt;1) I build my own bridge knowing that I will need to maintain it<br>&gt; &gt;periodically (usually on a predictable schedule)<br>&gt; &gt;2) Have everyone wait for 6 months (loosing $ the whole time) while I<br>&gt; &gt;plead with you to build the bridge for me.<br>&gt; &gt;<br>&gt; &gt;By definition, the least thought through frameworks are the ones most<br>&gt; &gt;likely to need workarounds, but under this proposal, they are also the<br>&gt; &gt;ones we will be unable to fix.  I think some people think that this<br>&gt; &gt;proposal will make them fix those frameworks or make them disappearŠ but<br>&gt; &gt;they are often from big brand name companies, who don¹t care that much<br>&gt; &gt;because tech isn¹t their main business.  In my experience, we can get the<br>&gt; &gt;changes we need, but it takes anywhere from 2 months to a year.  Being<br>&gt; &gt;able to patch in a stop-gap while we are waiting is very important for<br>&gt; &gt;the health of the business.<br>&gt; &gt;<br>&gt; &gt;For example, I had a recent client that called me in a panic<br>&gt; &gt;(unfortunately I have somehow gotten a reputation as someone to call for<br>&gt; &gt;impossible tasks) because they had a demo they needed to show for a<br>&gt; &gt;potential multimillion dollar deal and it just wasn¹t working.  The tech<br>&gt; &gt;they had used as a base wasn¹t doing what it was supposed toŠ and the<br>&gt; &gt;fixes were 3-6 months away (the demo was a week and a half away).  I<br>&gt; &gt;would call the support guy for the tech, and they would tell me ³that<br>&gt; &gt;isn¹t possible yet. Just wait for the update².  I would call them back a<br>&gt; &gt;couple of hours later saying ³If someone else asks, here is how I did<br>&gt; &gt;itŠ²  Was that code beautiful? No.  Did I get all the features in that<br>&gt; &gt;demo working?  Yes, with something like 1 hour to spare.  The demo went<br>&gt; &gt;very very well.<br>&gt; &gt;<br>&gt; &gt;Should I have let that deal fall through because it wasn¹t the ³proper²<br>&gt; &gt;ideological way to write code?  Sometimes things just need to get done<br>&gt; &gt;and there isn¹t another wayŠ.  A few people have suggested that these<br>&gt; &gt;types of concerns aren¹t relevant, but I find them very relevant to my<br>&gt; &gt;everyday life.  This is the first proposal with the ability to actually<br>&gt; &gt;cost me (and my clients) money.<br>&gt; &gt;<br>&gt; &gt;I am completely ok with needing to type ³unsafe² (or similar) to<br>&gt; &gt;acknowledge and take responsibility for my actions in those situations.<br>&gt; &gt;I understand those modifications might break when the framework is<br>&gt; &gt;finally updated in 3-6 months (hopefully we can even remove them at that<br>&gt; &gt;point).  Just don¹t ³safety&quot; my clients out of business by making working<br>&gt; &gt;around bad frameworks impossible.<br>&gt; &gt;<br>&gt; &gt;One last analogy.  At a restaurant, they might be afraid I would cut<br>&gt; &gt;myself with a sharp knife.  They don¹t force me to wear mittens or<br>&gt; &gt;otherwise make using knifes impossible.  They give everyone butterknives,<br>&gt; &gt;but I can always get a real knife if I ask for one.  If I order steak, I<br>&gt; &gt;don¹t even have to askŠ they just bring me a real knife.  This is how<br>&gt; &gt;Swift has been and should continue to be IMHO.  Prevent me from<br>&gt; &gt;subclassing accidentally, but if I acknowledge the risk, let me do it.<br>&gt; &gt;³Safe-by-default² != ³Impossible-by-default²<br>&gt; &gt;<br>&gt; &gt;Thanks,<br>&gt; &gt;Jon<br>&gt; &gt;<br>&gt; &gt;P.S. This discussion is reminding me of one of my favorite blogs.  He<br>&gt; &gt;often talks about the tension between doing things right, and actually<br>&gt; &gt;getting out there and doing things.  Here is a good/relevant article:<br>&gt; &gt;http://prog21.dadgum.com/87.html &lt;http://prog21.dadgum.com/87.html&gt;<br>&gt; &gt;<br>&gt; &gt;<br>&gt; &gt;-<br>&gt; &gt;-<br>&gt; &gt;_______________________________________________<br>&gt; &gt;swift-evolution mailing list<br>&gt; &gt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; &gt;https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160712/3394a256/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 13, 2016 at 08:00:00am</p></header><div class="content"><p>&gt; Am 12.07.2016 um 22:54 schrieb Jean-Daniel Dupas via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; If you can’t trust a developer, how could you use its library ?<br>I guess you&#39;re getting this wrong, and maybe on purpose:<br>Thrusting a developer is competent and tries to do a good job is on a completely different scale than the faith that someone foresees the future and writes code without any errors.<br></p><p>&gt; Using third-party code involve some kind of trusting, as you would have to trust the developer to write reliable and efficient code, which is IMHO, far more important than knowing if the developer carefully choose what can be subclasses or not.<br>Very true — so wouldn&#39;t it better to concentrate on topics that help developers write this code, instead of building a bureaucracy that makes coding harder?<br></p><p>&gt; And when you encounter a library where the dev choose to allow subclassing, you will have far more trust than the code was design to be subclassed.<br>I have the impression that many supporters of the proposal would love to have the power to not only change a tiny part of the language, but all the people using it... luckily, this isn&#39;t true, and this would be a false feeling of security:<br>Even if you punish them, some developers will value the freedom of choice more than the tiny slight risk of harming someone who uses this liberty — and even the biggest bureaucrats won&#39;t get their inheritance-model right all the time...<br></p><p>&gt; Some design patterns work better with subclassing than with protocol or delegation. So I’m confident than library developers will ‘open’ there classes if needed.<br></p><p>Would you allow others to put you in a cage, as long as they will open it if needed?<br>I wouldn&#39;t want that, even if that cage offered some protection.<br></p><p>Tino<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/322f4a41/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>July 13, 2016 at 07:00:00pm</p></header><div class="content"><p>I think you missed that I actually agree with all your points.<br></p><p>My point was merely regarding “pre-breaking” which I thought wasn’t a relevant term. I think a far more appropriate term is “overly limiting”. We are discussing semantics, nonetheless.<br></p><p>I actually support the idea that you should be able to subclass classes by default, with some form of acknowledgement that “I know this wasn’t meant to be subclassed, but I’m going to anyway.” This frees framework developers from the idea that it was “promised” to be able to work, and also frees a developer from the chains of an overly constrained development environment.<br></p><p>- Rod<br></p><p><br>&gt; On 12 Jul 2016, at 9:00 AM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Jul 10, 2016, at 7:48 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; On 11 Jul 2016, at 12:33 PM, Jonathan Hull &lt;jhull at gbis.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It is pre-breaking in that it is the exact same code that doesn’t work in both cases (only in the pre-breaking case, a bunch of other code also doesn’t work).  I know it feels different because it “was never possible” vs our change being the cause, but it is one of those things like me giving you $5 or giving you $10 and later taking back $5.  As humans we are loss averse so we devise strategies to hide the loss from ourselves.<br>&gt;&gt; <br>&gt;&gt; I completely disagree with this.<br>&gt;&gt; <br>&gt;&gt; Not providing someone something due to risk of breakage is not the same thing as “giving it and taking it away”. We don’t build bridges out of spare parts and tell people “We build it but we expect it to break at some stage, so use with caution.” You either build it correctly, or you don’t let people cross the bridge. At All.<br>&gt;&gt; <br>&gt;&gt; This isn’t about “loss averse”. This is about risk management.<br>&gt;&gt; <br>&gt;&gt; Where does the line lie on risk? That’s ultimately something the core team will have to decide.<br>&gt; <br>&gt; My point is that you are completely ignoring an entire class of risk that has a real-world $$$ cost.  Every time I have to use a framework under this proposal, I am now completely at the mercy of the author.  In the case of open source frameworks I can at least make a fork, but for closed source frameworks (often from large companies where us using their framework has been negotiated by the bosses) you have now just added weeks to my development cycle while I wait for big-company-who-doesn’t-really-care-that-much to update their stuff. (sure I can work on other things during that time, but delaying a launch isn’t free)<br>&gt; <br>&gt; Are you offering to explain to my boss/client why I can’t add the feature in a reasonable timeframe like I can with Objective C frameworks?  That it may not even be possible now in Swift even though the Android guy just did it in a few hours?  <br>&gt; <br>&gt; Do you know what I am going to tell my boss/client?  &quot;Don’t use Swift for frameworks” and “Try to avoid partnering with companies that have Swift frameworks”.  &quot;It is too much of a risk&quot;.  &quot;We are giving them too much control over the future of our product…&quot;  I mean, it even affects the prices that companies can charge for crappy frameworks. If I am asking for a bunch of features that I NEED them to add to provide a basic feature, that affects negotiations/price (vs a world where I can add it myself if needed).  Sealed-by-default gives them leverage.<br>&gt; <br>&gt; To use your bridge analogy, which is better in the case that you haven’t provided a bridge for me:<br>&gt; 1) I build my own bridge knowing that I will need to maintain it periodically (usually on a predictable schedule)<br>&gt; 2) Have everyone wait for 6 months (loosing $ the whole time) while I plead with you to build the bridge for me.<br>&gt; <br>&gt; By definition, the least thought through frameworks are the ones most likely to need workarounds, but under this proposal, they are also the ones we will be unable to fix.  I think some people think that this proposal will make them fix those frameworks or make them disappear… but they are often from big brand name companies, who don’t care that much because tech isn’t their main business.  In my experience, we can get the changes we need, but it takes anywhere from 2 months to a year.  Being able to patch in a stop-gap while we are waiting is very important for the health of the business.<br>&gt; <br>&gt; For example, I had a recent client that called me in a panic (unfortunately I have somehow gotten a reputation as someone to call for impossible tasks) because they had a demo they needed to show for a potential multimillion dollar deal and it just wasn’t working.  The tech they had used as a base wasn’t doing what it was supposed to… and the fixes were 3-6 months away (the demo was a week and a half away).  I would call the support guy for the tech, and they would tell me “that isn’t possible yet. Just wait for the update”.  I would call them back a couple of hours later saying “If someone else asks, here is how I did it…”  Was that code beautiful? No.  Did I get all the features in that demo working?  Yes, with something like 1 hour to spare.  The demo went very very well.<br>&gt; <br>&gt; Should I have let that deal fall through because it wasn’t the “proper” ideological way to write code?  Sometimes things just need to get done and there isn’t another way….  A few people have suggested that these types of concerns aren’t relevant, but I find them very relevant to my everyday life.  This is the first proposal with the ability to actually cost me (and my clients) money.<br>&gt; <br>&gt; I am completely ok with needing to type “unsafe” (or similar) to acknowledge and take responsibility for my actions in those situations.  I understand those modifications might break when the framework is finally updated in 3-6 months (hopefully we can even remove them at that point).  Just don’t “safety&quot; my clients out of business by making working around bad frameworks impossible.<br>&gt; <br>&gt; One last analogy.  At a restaurant, they might be afraid I would cut myself with a sharp knife.  They don’t force me to wear mittens or otherwise make using knifes impossible.  They give everyone butterknives, but I can always get a real knife if I ask for one.  If I order steak, I don’t even have to ask… they just bring me a real knife.  This is how Swift has been and should continue to be IMHO.  Prevent me from subclassing accidentally, but if I acknowledge the risk, let me do it.  “Safe-by-default” != “Impossible-by-default” <br>&gt; <br>&gt; Thanks,<br>&gt; Jon<br>&gt; <br>&gt; P.S. This discussion is reminding me of one of my favorite blogs.  He often talks about the tension between doing things right, and actually getting out there and doing things.  Here is a good/relevant article:<br>&gt; http://prog21.dadgum.com/87.html &lt;http://prog21.dadgum.com/87.html&gt;<br>&gt; <br>&gt; <br>&gt; -<br>&gt; -<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160713/521643b5/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Review] SE-0117: Default classes to be non-subclassable publicly</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>July 11, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; Am 11.07.2016 um 03:45 schrieb Rod Brown &lt;rodney.brown6 at icloud.com&gt;:<br>&gt; <br>&gt; That said, I actually think you have a good point however that “sealed” should be able to be overridden, either in a patch capacity or an “unsafe” capacity. Should this become final at a later point, you have acknowledged you know this will be unsafe and are willing to take this risk to get the job done. This is opt-in risk.<br>&gt; <br>&gt; Perhaps however this shouldn’t be “sealed” declaratively. Perhaps we just have a keyword for “Open” as an access level, and if you subclass or override things that are not “open” from other modules, you must mark unsafe.<br>&gt; <br>&gt; I think this is a decent compromise: We allow potential to patch, but discourage without acknowledgement of the risk. Allow Final and Open to be declarative.<br>Finally: Someone from the other party who not only speaks about compromise, but also shares a compatible way of thinking :-)<br>All those strict rules are a pointless attempt to trade freedom for security, and are purely cosmetic in most cases: In the context of open source, they are a blunt sword, whose only power is to annoy users.<br>Instead of trying to avoid all possible problems users of your library may run into, it&#39;s better to treat them as adults who know what they are doing — and make sure that the actually know what they are doing.<br></p><p>The defaults should match reality, and that is neither &quot;overriding is trouble&quot; nor &quot;it&#39;s safe to subclass&quot;; it is &quot;I haven&#39;t thought about overriding yet&quot;.<br>There is even a natural choice for the syntax to acknowledge that you are aware of doing something that might be dangerous: Simply add an exclamation mark to override.<br></p><p>Tino<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160711/f7395f6f/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
