<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 12, 2016 at 11:00:00pm</p></header><div class="content"><p>First of all, I insist that a deadline of less than 1 week is extremely<br>tough for this specific proposal. There are just too many details that we<br>need to work out, too many approaches to the problem that we want to<br>consider. As many people as possible should be able to express ideas on<br>this. A special request to core team is to extend the review to 2 week at<br>least, or even more if it will be needed.<br></p><p>I dislike the proposal as it is, especially the syntax. I think that<br>rolling out a language feature and &quot;bikeshedding&quot; it is only right if we<br>are ready to settle with most (although not all) of it. It&#39;s not the state<br>of things currently.<br></p><p>I have prepaired a draft (not real proposal) of my vision on the problem. I<br>tried to look at it from the other side, using existing Swift terms where<br>possible. Some wording or details might be off. Link to the gist:<br></p><p>https://gist.github.com/Anton3/f71a3e2ee29dffe1b9b2<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/8a430af5/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 12, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:08 PM, Антон Жилин &lt;antonyzhilin at gmail.com&gt; wrote:<br>&gt; <br>&gt; First of all, I insist that a deadline of less than 1 week is extremely tough for this specific proposal. There are just too many details that we need to work out, too many approaches to the problem that we want to consider. As many people as possible should be able to express ideas on this. A special request to core team is to extend the review to 2 week at least, or even more if it will be needed.<br></p><p>I&#39;m inclined to agree. I&#39;d be happy to extend the review period.<br></p><p>&gt; <br>&gt; I dislike the proposal as it is, especially the syntax. I think that rolling out a language feature and &quot;bikeshedding&quot; it is only right if we are ready to settle with most (although not all) of it. It&#39;s not the state of things currently.<br>&gt; <br>&gt; I have prepaired a draft (not real proposal) of my vision on the problem. I tried to look at it from the other side, using existing Swift terms where possible. Some wording or details might be off. Link to the gist:<br>&gt; <br>&gt; https://gist.github.com/Anton3/f71a3e2ee29dffe1b9b2 &lt;https://gist.github.com/Anton3/f71a3e2ee29dffe1b9b2&gt;<br>public behaviour lazy&lt;ValueType&gt; {<br>    private var storage: ValueType? = nil<br>    private var closure: (() -&gt; ValueType)?<br></p><p>IMO it&#39;s unacceptable to have to store a closure for every individual lazy property. That significantly increases the storage cost of the abstraction.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/d7edcb36/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 12:44 PM, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:08 PM, Антон Жилин &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First of all, I insist that a deadline of less than 1 week is extremely tough for this specific proposal. There are just too many details that we need to work out, too many approaches to the problem that we want to consider. As many people as possible should be able to express ideas on this. A special request to core team is to extend the review to 2 week at least, or even more if it will be needed.<br>&gt; <br>&gt; I&#39;m inclined to agree. I&#39;d be happy to extend the review period.<br></p><p>Joe, are you planning to send out another draft of the proposal?  Maybe you should do that and extend the period at the same time,<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/231324e3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 1:28 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:44 PM, Joe Groff &lt;jgroff at apple.com &lt;mailto:jgroff at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 12, 2016, at 12:08 PM, Антон Жилин &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; First of all, I insist that a deadline of less than 1 week is extremely tough for this specific proposal. There are just too many details that we need to work out, too many approaches to the problem that we want to consider. As many people as possible should be able to express ideas on this. A special request to core team is to extend the review to 2 week at least, or even more if it will be needed.<br>&gt;&gt; <br>&gt;&gt; I&#39;m inclined to agree. I&#39;d be happy to extend the review period.<br>&gt; <br>&gt; Joe, are you planning to send out another draft of the proposal?  Maybe you should do that and extend the period at the same time<br></p><p>Yeah, I&#39;ll do that.<br></p><p>-Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/02b3b4bb/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 12, 2016 at 10:00:00pm</p></header><div class="content"><p>I like Anton’s proposal much better! Clean, obvious and down to the point. <br></p><p>&gt; On 12 Feb 2016, at 21:44, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; IMO it&#39;s unacceptable to have to store a closure for every individual lazy property. That significantly increases the storage cost of the abstraction.<br>&gt; <br>&gt; -Joe<br></p><p>Maybe I am missing something obvious here but what would be a practical example of a lazy variable that does not rely on a closure to provide the initial value? Besides, storing an additional pointer per property is what, 8 bytes overhead? Barely worth mentioning. And of course, if you want to be very efficient about it you can always use a global hash map to store the closures. <br></p><p>BTW, the lazy implementation you propose also has additional overhead, but its hidden (initialValue needs to be stored somewhere before the first call to get). In fact, your solution might be even worse in terms of storage overhead, because it implies that individual closure with unique environment needs to be created for getters of every instance of the property with different initialiser. <br></p><p>— Taras<br></p><p>&gt; On 12 Feb 2016, at 21:44, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 12:08 PM, Антон Жилин &lt;antonyzhilin at gmail.com &lt;mailto:antonyzhilin at gmail.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; First of all, I insist that a deadline of less than 1 week is extremely tough for this specific proposal. There are just too many details that we need to work out, too many approaches to the problem that we want to consider. As many people as possible should be able to express ideas on this. A special request to core team is to extend the review to 2 week at least, or even more if it will be needed.<br>&gt; <br>&gt; I&#39;m inclined to agree. I&#39;d be happy to extend the review period.<br>&gt; <br>&gt;&gt; <br>&gt;&gt; I dislike the proposal as it is, especially the syntax. I think that rolling out a language feature and &quot;bikeshedding&quot; it is only right if we are ready to settle with most (although not all) of it. It&#39;s not the state of things currently.<br>&gt;&gt; <br>&gt;&gt; I have prepaired a draft (not real proposal) of my vision on the problem. I tried to look at it from the other side, using existing Swift terms where possible. Some wording or details might be off. Link to the gist:<br>&gt;&gt; <br>&gt;&gt; https://gist.github.com/Anton3/f71a3e2ee29dffe1b9b2 &lt;https://gist.github.com/Anton3/f71a3e2ee29dffe1b9b2&gt;<br>&gt; public behaviour lazy&lt;ValueType&gt; {<br>&gt;     private var storage: ValueType? = nil<br>&gt;     private var closure: (() -&gt; ValueType)?<br>&gt; <br>&gt; IMO it&#39;s unacceptable to have to store a closure for every individual lazy property. That significantly increases the storage cost of the abstraction.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/71d299c0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>February 12, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; On Feb 12, 2016, at 1:45 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch&gt; wrote:<br>&gt; <br>&gt; I like Anton’s proposal much better! Clean, obvious and down to the point. <br>&gt; <br>&gt;&gt; On 12 Feb 2016, at 21:44, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; <br>&gt;&gt; IMO it&#39;s unacceptable to have to store a closure for every individual lazy property. That significantly increases the storage cost of the abstraction.<br>&gt;&gt; <br>&gt;&gt; -Joe<br>&gt; <br>&gt; Maybe I am missing something obvious here but what would be a practical example of a lazy variable that does not rely on a closure to provide the initial value? Besides, storing an additional pointer per property is what, 8 bytes overhead? Barely worth mentioning. And of course, if you want to be very efficient about it you can always use a global hash map to store the closures. <br></p><p>A Swift closure is two pointers wide—a function pointer, and a context pointer. The per-instance overhead for Optional&lt;T&gt; will already cost a word for many types without an extra bit or representation for &#39;None&#39;.<br></p><p>&gt; BTW, the lazy implementation you propose also has additional overhead, but its hidden (initialValue needs to be stored somewhere before the first call to get). In fact, your solution might be even worse in terms of storage overhead, because it implies that individual closure with unique environment needs to be created for getters of every instance of the property with different initialiser. <br></p><p>As currently implemented, &#39;lazy&#39; inlines the initializer expression into the property&#39;s getter implementation, so the only overhead is some code size in the getter function. A behavior implementation of [lazy] needs to afford the same opportunity to the optimizer. One way we could model this is as &#39;static&#39; members in the behavior, perhaps.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160212/27f5ddc7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 14, 2016 at 08:00:00am</p></header><div class="content"><p>Ok, fair enough. Then here a few ideas how to fix it and still stay in-line with Anton’s proposal (that i still consider much more attractive):<br></p><p>1. Allow behaviours to specify abstract members that need to be implemented (akin to protocols) and get the initial value of lazy from there, e.g.:<br></p><p>    var lazy x : T {<br>	func load() {<br>		return 33<br>	}<br>    }<br></p><p>  Pros: clean and clear. Cons: verbosity.<br></p><p>2. Allow behaviours to have members stored per property declaration and not per property instance. These members are tied to the type-level storage of the host item (e.g. class and not instance). A closure that initialises the lazy storage can be stored at that level, thus solving the storage overhead issue. One can use the static declarations for this (although a new storage class might be appropriate). Note that Python uses this kind of approach per default: instances of property descriptors are created per class that hosts a property and not per instance. The property getter/setter then receives the specific object instance to manipulate the value specific to that instance. <br></p><p> Pros: clean and clear. Cons: potentially need new storage declaration.<br></p><p>— Taras <br></p><p><br>&gt; On 12 Feb 2016, at 22:59, Joe Groff &lt;jgroff at apple.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 12, 2016, at 1:45 PM, Taras Zakharko &lt;taras.zakharko at uzh.ch &lt;mailto:taras.zakharko at uzh.ch&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I like Anton’s proposal much better! Clean, obvious and down to the point. <br>&gt;&gt; <br>&gt;&gt;&gt; On 12 Feb 2016, at 21:44, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; IMO it&#39;s unacceptable to have to store a closure for every individual lazy property. That significantly increases the storage cost of the abstraction.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; Maybe I am missing something obvious here but what would be a practical example of a lazy variable that does not rely on a closure to provide the initial value? Besides, storing an additional pointer per property is what, 8 bytes overhead? Barely worth mentioning. And of course, if you want to be very efficient about it you can always use a global hash map to store the closures. <br>&gt; <br>&gt; A Swift closure is two pointers wide—a function pointer, and a context pointer. The per-instance overhead for Optional&lt;T&gt; will already cost a word for many types without an extra bit or representation for &#39;None&#39;.<br>&gt; <br>&gt;&gt; BTW, the lazy implementation you propose also has additional overhead, but its hidden (initialValue needs to be stored somewhere before the first call to get). In fact, your solution might be even worse in terms of storage overhead, because it implies that individual closure with unique environment needs to be created for getters of every instance of the property with different initialiser. <br>&gt; <br>&gt; As currently implemented, &#39;lazy&#39; inlines the initializer expression into the property&#39;s getter implementation, so the only overhead is some code size in the getter function. A behavior implementation of [lazy] needs to afford the same opportunity to the optimizer. One way we could model this is as &#39;static&#39; members in the behavior, perhaps.<br>&gt; <br>&gt; -Joe<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160214/1b987b65/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 14, 2016 at 12:00:00am</p></header><div class="content"><p>&gt; 1. Allow behaviours to specify abstract members that need to be implemented (akin to protocols) and get the initial value of lazy from there, e.g.:<br>&gt; <br>&gt;     var lazy x : T {<br>&gt; 	func load() {<br>&gt; 		return 33<br>&gt; 	}<br>&gt;     }<br>&gt; <br>&gt;   Pros: clean and clear. Cons: verbosity.<br></p><p>The existing proposal&#39;s accessor feature does this. (The syntax would just be `load {}`, not `func load() {}`, though.)<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 14, 2016 at 09:00:00am</p></header><div class="content"><p>Ah, yes, sorry, should have double checked with the initial text before sending the message. For some reason I though that the accessor requirement declarations were limited to get/set. But I think that my basic point still holds. E.g. in Joe’s proposal, I don’t really see how lazy behaviour is achieved: the sample implementation for lazy he proposes seems to force evaluation of the initial value at the declaration time. Unless we have some sort of magic that wraps the initial value into a closure (but that is then the same as what Anton suggests, albeit explicitly). <br></p><p><br>&gt; On 14 Feb 2016, at 09:19, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; 1. Allow behaviours to specify abstract members that need to be implemented (akin to protocols) and get the initial value of lazy from there, e.g.:<br>&gt;&gt; <br>&gt;&gt;    var lazy x : T {<br>&gt;&gt; 	func load() {<br>&gt;&gt; 		return 33<br>&gt;&gt; 	}<br>&gt;&gt;    }<br>&gt;&gt; <br>&gt;&gt;  Pros: clean and clear. Cons: verbosity.<br>&gt; <br>&gt; The existing proposal&#39;s accessor feature does this. (The syntax would just be `load {}`, not `func load() {}`, though.)<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 14, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; Ah, yes, sorry, should have double checked with the initial text before sending the message. For some reason I though that the accessor requirement declarations were limited to get/set. But I think that my basic point still holds. E.g. in Joe’s proposal, I don’t really see how lazy behaviour is achieved: the sample implementation for lazy he proposes seems to force evaluation of the initial value at the declaration time. Unless we have some sort of magic that wraps the initial value into a closure (but that is then the same as what Anton suggests, albeit explicitly). <br></p><p>In Joe&#39;s proposal, the initializer expression is wrapped up in a computed property. Because it&#39;s a *computed* property, rather than a *stored* property containing a closure, it doesn&#39;t take up any extra storage in the instances.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 14, 2016 at 12:00:00pm</p></header><div class="content"><p>Ok, thanks for explaining, now I finally understand how this is supposed to work (thats what happens when one just skims through he proposal and missed important paragraphs). So in the end, it is magic that wraps the initialiser expression in a per-declaration closure. I’d rather such things be under full programmer control. Even more, what would happen in the following case?<br></p><p>public behavior var [custom] _: Value = initialValue {<br>  var value: Value = initialValue // alternatively init() { value = initialValue} <br>  get<br>  {<br>   return value<br>  }<br>  set<br>  {<br>    value = newValue<br>  }<br>}<br></p><p>var global_x = 1<br></p><p>class Test {<br> var [custom] x : Int = global_x + 1<br>}<br></p><p>let t1 = Test()<br>print(t1.x)<br>global_x = 2<br>let t2 = Test()<br>print(t2.x) // 2 or 3???<br></p><p><br>What gets printed in the last line? If I read the proposal correctly (but by now I expect to have missed something AGAIN in all honestly), the initialValue expression is gets wrapped in a computed property. This property is first accessed when the storage is initialised, i.e. when the host object instance is constructed. This means that t1 and t2 should get two different initial values which is probably not what one would have intended. Implicit wrapping of the initialiser is a good idea if we are interested in the lazy behaviour but it could be a source of bugs if we are *not*. <br></p><p>— Taras<br></p><p><br>&gt; On 14 Feb 2016, at 11:58, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Ah, yes, sorry, should have double checked with the initial text before sending the message. For some reason I though that the accessor requirement declarations were limited to get/set. But I think that my basic point still holds. E.g. in Joe’s proposal, I don’t really see how lazy behaviour is achieved: the sample implementation for lazy he proposes seems to force evaluation of the initial value at the declaration time. Unless we have some sort of magic that wraps the initial value into a closure (but that is then the same as what Anton suggests, albeit explicitly). <br>&gt; <br>&gt; In Joe&#39;s proposal, the initializer expression is wrapped up in a computed property. Because it&#39;s a *computed* property, rather than a *stored* property containing a closure, it doesn&#39;t take up any extra storage in the instances.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>February 14, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; This means that t1 and t2 should get two different initial values which is probably not what one would have intended.<br></p><p>On the contrary, that&#39;s how initial values always work in Swift. Try it yourself: if you copy that code sample, delete the `[custom]`, and paste it into a Swift REPL (any version, as far as I know), it will print &quot;2&quot; and &quot;3&quot;.<br></p><p>This semantic is important in several cases, like assigning unique IDs, but it&#39;s perhaps most crucial when you&#39;re initializing with a reference type. When you write something like this:<br></p><p>	struct Foo {<br>		let bar = NSMutableArray()<br>	}<br></p><p>Each `Foo` needs to get its own, separate instance of NSMutableArray, rather than all of them sharing a single array. Reevaluating the initial value for every initialization achieves that goal.<br></p><p>Given that it&#39;s the way the rest of the language works, I really don&#39;t think it&#39;ll be particularly surprising if this semantic carries over to property behaviors, too.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/566528c7f7c28c35c0c646d415943612?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Taras Zakharko</string> &lt;taras.zakharko at uzh.ch&gt;<p>February 14, 2016 at 01:00:00pm</p></header><div class="content"><p>You are right! Ok, I’m convinced now as far as that goes :) Smart design. I didn’t think that far, I’m afraid. <br></p><p>Thanks for explaining again, <br></p><p> T. <br></p><p>&gt; On 14 Feb 2016, at 13:33, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; This means that t1 and t2 should get two different initial values which is probably not what one would have intended.<br>&gt; <br>&gt; On the contrary, that&#39;s how initial values always work in Swift. Try it yourself: if you copy that code sample, delete the `[custom]`, and paste it into a Swift REPL (any version, as far as I know), it will print &quot;2&quot; and &quot;3&quot;.<br>&gt; <br>&gt; This semantic is important in several cases, like assigning unique IDs, but it&#39;s perhaps most crucial when you&#39;re initializing with a reference type. When you write something like this:<br>&gt; <br>&gt; 	struct Foo {<br>&gt; 		let bar = NSMutableArray()<br>&gt; 	}<br>&gt; <br>&gt; Each `Foo` needs to get its own, separate instance of NSMutableArray, rather than all of them sharing a single array. Reevaluating the initial value for every initialization achieves that goal.<br>&gt; <br>&gt; Given that it&#39;s the way the rest of the language works, I really don&#39;t think it&#39;ll be particularly surprising if this semantic carries over to property behaviors, too.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8aa3a9da9a32d3e98805b4a5409e4cee?s=50"></div><header><strong>SE-0030 Property Behaviors</strong> from <string>Anton Zhilin</string> &lt;antonyzhilin at gmail.com&gt;<p>February 18, 2016 at 12:00:00am</p></header><div class="content"><p>A second try at improving syntax for properties, aiming for unification and<br>consistency. This time I suggest to declare initialValue as an accessor, as<br>it is really an accessor with shorthand syntax. For this and a couple of<br>other ideas, please see the gist<br>&lt;https://gist.github.com/Anton3/f71a3e2ee29dffe1b9b2&gt;.<br></p><p>2016-02-14 15:41 GMT+03:00 Taras Zakharko &lt;taras.zakharko at uzh.ch&gt;:<br></p><p>&gt; You are right! Ok, I’m convinced now as far as that goes :) Smart design.<br>&gt; I didn’t think that far, I’m afraid.<br>&gt;<br>&gt; Thanks for explaining again,<br>&gt;<br>&gt;  T.<br>&gt;<br>&gt; &gt; On 14 Feb 2016, at 13:33, Brent Royal-Gordon &lt;brent at architechies.com&gt;<br>&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; This means that t1 and t2 should get two different initial values which<br>&gt; is probably not what one would have intended.<br>&gt; &gt;<br>&gt; &gt; On the contrary, that&#39;s how initial values always work in Swift. Try it<br>&gt; yourself: if you copy that code sample, delete the `[custom]`, and paste it<br>&gt; into a Swift REPL (any version, as far as I know), it will print &quot;2&quot; and<br>&gt; &quot;3&quot;.<br>&gt; &gt;<br>&gt; &gt; This semantic is important in several cases, like assigning unique IDs,<br>&gt; but it&#39;s perhaps most crucial when you&#39;re initializing with a reference<br>&gt; type. When you write something like this:<br>&gt; &gt;<br>&gt; &gt;       struct Foo {<br>&gt; &gt;               let bar = NSMutableArray()<br>&gt; &gt;       }<br>&gt; &gt;<br>&gt; &gt; Each `Foo` needs to get its own, separate instance of NSMutableArray,<br>&gt; rather than all of them sharing a single array. Reevaluating the initial<br>&gt; value for every initialization achieves that goal.<br>&gt; &gt;<br>&gt; &gt; Given that it&#39;s the way the rest of the language works, I really don&#39;t<br>&gt; think it&#39;ll be particularly surprising if this semantic carries over to<br>&gt; property behaviors, too.<br>&gt; &gt;<br>&gt; &gt; --<br>&gt; &gt; Brent Royal-Gordon<br>&gt; &gt; Architechies<br>&gt; &gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160218/5b3a439d/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
