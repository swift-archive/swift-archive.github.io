<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 05:00:00pm</p></header><div class="content"><p>In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br></p><p>By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br></p><p>If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br></p><p>The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br></p><p>UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br></p><p>This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br></p><p>Alternatives include:<br>• A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>• In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>• Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br></p><p>This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br></p><p>- James<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  3, 2016 at 11:00:00am</p></header><div class="content"><p>-1  CollectionType and it&#39;s ilk, contrary to what you believe, were<br>designed to handle negative indexes just fine. Or even indexes that aren&#39;t<br>numeric. And there&#39;s plenty of real use cases for this.<br></p><p>class GraphRow : MutableCollectionType {<br></p><p>    var values = [Int](count: 201, repeatedValue: 0)<br></p><p>    var startIndex: Int { return -100 }<br></p><p>    var endIndex: Int { return 100 }<br></p><p>    subscript(column: Int) -&gt; Int {<br></p><p>        get {<br></p><p>            return values[column+100]<br></p><p>        }<br></p><p>        set {<br></p><p>            values[column+100] = newValue<br></p><p>        }<br></p><p>    }<br></p><p>}<br></p><p>var r = GraphRow()<br></p><p>r[-3] = 12<br></p><p>r[9] = 2<br></p><p>print(r[-3])<br></p><p>print(r.reduce(0, combine: +))<br></p><p>-david<br></p><p><br>On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the standard library, there are methods (notably array subscripts,<br>&gt; CollectionType&#39;s .count and the dimensions of CGSize) which are designed to<br>&gt; deal only with natural (non-negative) numbers. Functions either throw an<br>&gt; error if a parameter is negative, or else ignore the possibility of a<br>&gt; negative value finding its way into these functions.<br>&gt;<br>&gt; By updating the standard library with a natural number type to represent<br>&gt; these values (and potentially the Swift interfaces for Foundation and other<br>&gt; frameworks), there is no way a negative number can be passed to these<br>&gt; functions. This eliminates the need for many preconditions, allowing them<br>&gt; to eliminate the possibility of a crash, and it would be clear that values<br>&gt; such as count will never be negative.<br>&gt;<br>&gt; If this change were accepted, the user would have to explicitly convert<br>&gt; between the types at some points in their code. This could be seen as a<br>&gt; burden, but requiring a cast encourages the programmer to check for<br>&gt; negative values, keeping negatives out of natural number functions, and<br>&gt; moving checks to the source of the data, similar to how Optionals eliminate<br>&gt; nil values early on.<br>&gt;<br>&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of<br>&gt; this idea. With Swift&#39;s focus on type safety, the lack of distinction<br>&gt; between natural numbers and potentially negative ones seems like an<br>&gt; omission, given how commonly both kinds of number are used. Enabling this<br>&gt; level of integral safety would add additional clarity and reduce potential<br>&gt; errors. Use cases include not just indexes, but in sizes such as<br>&gt; collections&#39; count and CG dimensions, for both clarity when getting values,<br>&gt; and enforcing valid values at initialisation.<br>&gt;<br>&gt; UInt is the obvious candidate to represent integer natural numbers, but is<br>&gt; hazardous in edge cases: UInt allows an extra bit for magnitude, so has the<br>&gt; possibility of overflow when converting back to Int. I assume this hazard<br>&gt; is the primary reason UInt currently isn&#39;t used. If this a concern, a<br>&gt; separate collection of types for natural integers (NInt?) could be created,<br>&gt; which could be a strict subset of the correspondingly sized Int values<br>&gt; (using n-1 bits).<br>&gt;<br>&gt; This would mean adding a new collection of integer types in the standard<br>&gt; library, which is undesirable. However, for high level applications which<br>&gt; Swift is primarily used for, this would arguably be a more useful type than<br>&gt; UInt, considering the near absence of UInt in current APIs, and its tiny<br>&gt; increase (1 bit?) in precision compared to using an Int of a larger size.<br>&gt; An unsigned Integer subset would allow safe conversion back to Int, and the<br>&gt; conversion from Int is relatively simple, from the design perspective -<br>&gt; ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;<br>&gt; Alternatives include:<br>&gt; • A generic wrapper for Int which constrains its possible values. This<br>&gt; would allow inherent support for use with existing operators, but would be<br>&gt; rather clunky in cases where only natural numbers are being dealt with.<br>&gt; • In a future version of Swift, the addition of type parameters<br>&gt; constraining possible values may enable this to be added, but even if this<br>&gt; does get added it may be too late to make such a major change.<br>&gt; • Leaving the APIs as they are and require every function dealing with<br>&gt; natural numbers to either throw a runtime error when a negative is passed.<br>&gt; If the user forgets to follow this rule (or wont put in the extra effort to<br>&gt; add the check), their functions will have unspecified behaviour.<br>&gt;<br>&gt; This ended up longer than I would like, sorry about that. I don&#39;t think<br>&gt; this issue has been covered here.<br>&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident<br>&gt; this change would be beneficial if done correctly, doing it correctly is<br>&gt; easier said that done.<br>&gt;<br>&gt; - James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/09de0a42/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>What about .count? Is it possible for that to be negative? If we change how count is represented, I think it should be switched to size_t, rather that UInt. I’m aware that they’re currently the same thing, but that might not always be the case, and, at least the way I understand things, the max value of a platform’s “pointer” type is more directly tied to the maximum possible element count than the max value of its native uint type. I know of at least one platform in development which uses 64 bits for pointers, but the address space is only 61 bits because the CPU &amp; memory system use 3 bits for flags.<br></p><p>- Dave Sweeris<br></p><p><br>&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were designed to handle negative indexes just fine. Or even indexes that aren&#39;t numeric. And there&#39;s plenty of real use cases for this.<br>&gt; <br>&gt; class GraphRow : MutableCollectionType {<br>&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;     var startIndex: Int { return -100 }<br>&gt;     var endIndex: Int { return 100 }<br>&gt;     subscript(column: Int) -&gt; Int {<br>&gt;         get {<br>&gt;             return values[column+100]<br>&gt;         }<br>&gt;         set {<br>&gt;             values[column+100] = newValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; var r = GraphRow()<br>&gt; r[-3] = 12<br>&gt; r[9] = 2<br>&gt; print(r[-3])<br>&gt; print(r.reduce(0, combine: +))<br>&gt; <br>&gt; -david<br>&gt; <br>&gt; <br>&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt; <br>&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt; <br>&gt; If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br>&gt; <br>&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br>&gt; <br>&gt; UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br>&gt; <br>&gt; This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt; <br>&gt; Alternatives include:<br>&gt; • A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>&gt; • In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>&gt; • Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br>&gt; <br>&gt; This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br>&gt; <br>&gt; - James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/41f1457e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  3, 2016 at 12:00:00pm</p></header><div class="content"><p>You can have a collection with a negative count. There&#39;s uses for this too.<br>For example, importing data. You can import whatever garbage in one pass,<br>and validate in a second. That way you don&#39;t have to mix concerns in your<br>code.<br></p><p>-david<br></p><p>On Wed, Feb 3, 2016 at 12:35 PM, &lt;davesweeris at mac.com&gt; wrote:<br></p><p>&gt; What about .count? Is it possible for that to be negative? *If* we change<br>&gt; how count is represented, I think it should be switched to size_t, rather<br>&gt; that UInt. I’m aware that they’re currently the same thing, but that might<br>&gt; not always be the case, and, at least the way I understand things, the max<br>&gt; value of a platform’s “pointer” type is more directly tied to the maximum<br>&gt; possible element count than the max value of its native uint type. I know<br>&gt; of at least one platform in development which uses 64 bits for pointers,<br>&gt; but the address space is only 61 bits because the CPU &amp; memory system use 3<br>&gt; bits for flags.<br>&gt;<br>&gt; - Dave Sweeris<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were<br>&gt; designed to handle negative indexes just fine. Or even indexes that aren&#39;t<br>&gt; numeric. And there&#39;s plenty of real use cases for this.<br>&gt;<br>&gt; class GraphRow : MutableCollectionType {<br>&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;     var startIndex: Int { return -100 }<br>&gt;     var endIndex: Int { return 100 }<br>&gt;     subscript(column: Int) -&gt; Int {<br>&gt;         get {<br>&gt;             return values[column+100]<br>&gt;         }<br>&gt;         set {<br>&gt;             values[column+100] = newValue<br>&gt;         }<br>&gt;     }<br>&gt; }<br>&gt; var r = GraphRow()<br>&gt; r[-3] = 12<br>&gt; r[9] = 2<br>&gt; print(r[-3])<br>&gt; print(r.reduce(0, combine: +))<br>&gt;<br>&gt; -david<br>&gt;<br>&gt;<br>&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; In the standard library, there are methods (notably array subscripts,<br>&gt;&gt; CollectionType&#39;s .count and the dimensions of CGSize) which are designed to<br>&gt;&gt; deal only with natural (non-negative) numbers. Functions either throw an<br>&gt;&gt; error if a parameter is negative, or else ignore the possibility of a<br>&gt;&gt; negative value finding its way into these functions.<br>&gt;&gt;<br>&gt;&gt; By updating the standard library with a natural number type to represent<br>&gt;&gt; these values (and potentially the Swift interfaces for Foundation and other<br>&gt;&gt; frameworks), there is no way a negative number can be passed to these<br>&gt;&gt; functions. This eliminates the need for many preconditions, allowing them<br>&gt;&gt; to eliminate the possibility of a crash, and it would be clear that values<br>&gt;&gt; such as count will never be negative.<br>&gt;&gt;<br>&gt;&gt; If this change were accepted, the user would have to explicitly convert<br>&gt;&gt; between the types at some points in their code. This could be seen as a<br>&gt;&gt; burden, but requiring a cast encourages the programmer to check for<br>&gt;&gt; negative values, keeping negatives out of natural number functions, and<br>&gt;&gt; moving checks to the source of the data, similar to how Optionals eliminate<br>&gt;&gt; nil values early on.<br>&gt;&gt;<br>&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of<br>&gt;&gt; this idea. With Swift&#39;s focus on type safety, the lack of distinction<br>&gt;&gt; between natural numbers and potentially negative ones seems like an<br>&gt;&gt; omission, given how commonly both kinds of number are used. Enabling this<br>&gt;&gt; level of integral safety would add additional clarity and reduce potential<br>&gt;&gt; errors. Use cases include not just indexes, but in sizes such as<br>&gt;&gt; collections&#39; count and CG dimensions, for both clarity when getting values,<br>&gt;&gt; and enforcing valid values at initialisation.<br>&gt;&gt;<br>&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but<br>&gt;&gt; is hazardous in edge cases: UInt allows an extra bit for magnitude, so has<br>&gt;&gt; the possibility of overflow when converting back to Int. I assume this<br>&gt;&gt; hazard is the primary reason UInt currently isn&#39;t used. If this a concern,<br>&gt;&gt; a separate collection of types for natural integers (NInt?) could be<br>&gt;&gt; created, which could be a strict subset of the correspondingly sized Int<br>&gt;&gt; values (using n-1 bits).<br>&gt;&gt;<br>&gt;&gt; This would mean adding a new collection of integer types in the standard<br>&gt;&gt; library, which is undesirable. However, for high level applications which<br>&gt;&gt; Swift is primarily used for, this would arguably be a more useful type than<br>&gt;&gt; UInt, considering the near absence of UInt in current APIs, and its tiny<br>&gt;&gt; increase (1 bit?) in precision compared to using an Int of a larger size.<br>&gt;&gt; An unsigned Integer subset would allow safe conversion back to Int, and the<br>&gt;&gt; conversion from Int is relatively simple, from the design perspective -<br>&gt;&gt; ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;<br>&gt;&gt; Alternatives include:<br>&gt;&gt; • A generic wrapper for Int which constrains its possible values. This<br>&gt;&gt; would allow inherent support for use with existing operators, but would be<br>&gt;&gt; rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt; • In a future version of Swift, the addition of type parameters<br>&gt;&gt; constraining possible values may enable this to be added, but even if this<br>&gt;&gt; does get added it may be too late to make such a major change.<br>&gt;&gt; • Leaving the APIs as they are and require every function dealing with<br>&gt;&gt; natural numbers to either throw a runtime error when a negative is passed.<br>&gt;&gt; If the user forgets to follow this rule (or wont put in the extra effort to<br>&gt;&gt; add the check), their functions will have unspecified behaviour.<br>&gt;&gt;<br>&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think<br>&gt;&gt; this issue has been covered here.<br>&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident<br>&gt;&gt; this change would be beneficial if done correctly, doing it correctly is<br>&gt;&gt; easier said that done.<br>&gt;&gt;<br>&gt;&gt; - James<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/3b5adfa3/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Oooh… clever…<br></p><p>I’m not sure it really invalidates my point, though… In your example, the public “count” might return a negative number, but internally at some level your collection would still need a “count” for the purpose of knowing how many elements are in its buffer, right? I mean it’s not like that invalid data takes up a negative amount of memory…<br></p><p>- Dave Sweeris<br></p><p>&gt; On Feb 3, 2016, at 12:50, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt; <br>&gt; You can have a collection with a negative count. There&#39;s uses for this too. For example, importing data. You can import whatever garbage in one pass, and validate in a second. That way you don&#39;t have to mix concerns in your code.<br>&gt; <br>&gt; -david<br>&gt; <br>&gt; On Wed, Feb 3, 2016 at 12:35 PM, &lt;davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt;&gt; wrote:<br>&gt; What about .count? Is it possible for that to be negative? If we change how count is represented, I think it should be switched to size_t, rather that UInt. I’m aware that they’re currently the same thing, but that might not always be the case, and, at least the way I understand things, the max value of a platform’s “pointer” type is more directly tied to the maximum possible element count than the max value of its native uint type. I know of at least one platform in development which uses 64 bits for pointers, but the address space is only 61 bits because the CPU &amp; memory system use 3 bits for flags.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were designed to handle negative indexes just fine. Or even indexes that aren&#39;t numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt; <br>&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;         get {<br>&gt;&gt;             return values[column+100]<br>&gt;&gt;         }<br>&gt;&gt;         set {<br>&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; var r = GraphRow()<br>&gt;&gt; r[-3] = 12<br>&gt;&gt; r[9] = 2<br>&gt;&gt; print(r[-3])<br>&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt; <br>&gt;&gt; -david<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt;&gt; <br>&gt;&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt;&gt; <br>&gt;&gt; If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br>&gt;&gt; <br>&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br>&gt;&gt; <br>&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br>&gt;&gt; <br>&gt;&gt; This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt; <br>&gt;&gt; Alternatives include:<br>&gt;&gt; • A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt; • In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>&gt;&gt; • Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br>&gt;&gt; <br>&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br>&gt;&gt; <br>&gt;&gt; - James<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/3dbe8746/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;m not sure I follow. Could you elaborate on this?<br></p><p>If such a type were made, I&#39;m fairly sure generic functions designed to accept a CollectionType would throw an error if the count were negative (if trying to iterate with 0 ..&lt; .count, for example), indicating such a type doesn&#39;t implement the protocol as it was intended to be used.<br></p><p>From James F<br></p><p>&gt; On 3 Feb 2016, at 20:50, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt; <br>&gt; You can have a collection with a negative count. There&#39;s uses for this too. For example, importing data. You can import whatever garbage in one pass, and validate in a second. That way you don&#39;t have to mix concerns in your code.<br>&gt; <br>&gt; -david<br>&gt; <br>&gt;&gt; On Wed, Feb 3, 2016 at 12:35 PM, &lt;davesweeris at mac.com&gt; wrote:<br>&gt;&gt; What about .count? Is it possible for that to be negative? If we change how count is represented, I think it should be switched to size_t, rather that UInt. I’m aware that they’re currently the same thing, but that might not always be the case, and, at least the way I understand things, the max value of a platform’s “pointer” type is more directly tied to the maximum possible element count than the max value of its native uint type. I know of at least one platform in development which uses 64 bits for pointers, but the address space is only 61 bits because the CPU &amp; memory system use 3 bits for flags.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were designed to handle negative indexes just fine. Or even indexes that aren&#39;t numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;&gt;         get {<br>&gt;&gt;&gt;             return values[column+100]<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         set {<br>&gt;&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; var r = GraphRow()<br>&gt;&gt;&gt; r[-3] = 12<br>&gt;&gt;&gt; r[9] = 2<br>&gt;&gt;&gt; print(r[-3])<br>&gt;&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -david<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Alternatives include:<br>&gt;&gt;&gt;&gt; • A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt;&gt;&gt; • In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>&gt;&gt;&gt;&gt; • Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>&gt;&gt;&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; - James<br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/1d3b663e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  3, 2016 at 05:00:00pm</p></header><div class="content"><p>Here&#39;s how you could use a collection as a predicate. The OnSwitchesIndex is<br>opaque to anything outside the file. There&#39;s no way to iterate OnSwitches with<br> 0 ..&lt;count. Thinking that arrays and sequences are counting up from 0 by 1<br>is missing the entire point of these protocols.<br></p><p>class Switches : CollectionType{<br></p><p>    private let data:[Bool]<br></p><p>    init(_ d:[Bool]) {<br></p><p>        data = d<br></p><p>    }<br></p><p>    var startIndex: Int {<br></p><p>        return data.startIndex<br></p><p>    }<br></p><p>    var endIndex: Int {<br></p><p>        return data.endIndex<br></p><p>    }<br></p><p>    subscript(i:Int) -&gt; Bool {<br></p><p>        return data[i]<br></p><p>    }<br></p><p>}<br></p><p><br>struct OnSwitchesIndex : ForwardIndexType {<br></p><p>    private let data:Switches<br></p><p>    private let index:Int<br></p><p>    init(_ d:Switches, _ i:Int) {<br></p><p>        data = d<br></p><p>        for i in i..&lt;data.endIndex {<br></p><p>            if data[i] {<br></p><p>                index = i<br></p><p>                return<br></p><p>            }<br></p><p>        }<br></p><p>        index = data.endIndex<br></p><p>    }<br></p><p>    func successor() -&gt; OnSwitchesIndex {<br></p><p>        return OnSwitchesIndex(data, index+1)<br></p><p>    }<br></p><p>}<br></p><p><br>func ==(lhs: OnSwitchesIndex, rhs: OnSwitchesIndex) -&gt; Bool {<br></p><p>    return lhs.index == rhs.index<br></p><p>}<br></p><p><br>class OnSwitches : CollectionType {<br></p><p>    let data:Switches<br></p><p>    init(_ d:Switches) {<br></p><p>        data = d<br></p><p>    }<br></p><p>    var startIndex: OnSwitchesIndex {<br></p><p>        return OnSwitchesIndex(data, data.startIndex)<br></p><p>    }<br></p><p>    var endIndex: OnSwitchesIndex {<br></p><p>        return OnSwitchesIndex(data, data.endIndex)<br></p><p>    }<br></p><p>    subscript(sw: OnSwitchesIndex) -&gt; Int {<br></p><p>        assert(sw.data.data == data.data)<br></p><p>        return sw.index<br></p><p>    }<br></p><p>}<br></p><p><br>let x:Switches = Switches([false, true, true, false, true])<br></p><p>x.count // == 5<br></p><p><br>let y = OnSwitches(x)<br></p><p>y.count // == 3<br></p><p>for z in y { print(z) } // == prints 1 2 4<br></p><p>-david<br></p><p><br></p><p>On Wed, Feb 3, 2016 at 1:09 PM, James Froggatt &lt;conductator at ntlworld.com&gt;<br>wrote:<br></p><p>&gt; I&#39;m not sure I follow. Could you elaborate on this?<br>&gt;<br>&gt; If such a type were made, I&#39;m fairly sure generic functions designed to<br>&gt; accept a CollectionType would throw an error if the count were negative (if<br>&gt; trying to iterate with 0 ..&lt; .count, for example), indicating such a type<br>&gt; doesn&#39;t implement the protocol as it was intended to be used.<br>&gt;<br>&gt; From James F<br>&gt;<br>&gt; On 3 Feb 2016, at 20:50, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt;<br>&gt; You can have a collection with a negative count. There&#39;s uses for this<br>&gt; too. For example, importing data. You can import whatever garbage in one<br>&gt; pass, and validate in a second. That way you don&#39;t have to mix concerns in<br>&gt; your code.<br>&gt;<br>&gt; -david<br>&gt;<br>&gt; On Wed, Feb 3, 2016 at 12:35 PM, &lt;davesweeris at mac.com&gt; wrote:<br>&gt;<br>&gt;&gt; What about .count? Is it possible for that to be negative? *If* we<br>&gt;&gt; change how count is represented, I think it should be switched to size_t,<br>&gt;&gt; rather that UInt. I’m aware that they’re currently the same thing, but that<br>&gt;&gt; might not always be the case, and, at least the way I understand things,<br>&gt;&gt; the max value of a platform’s “pointer” type is more directly tied to the<br>&gt;&gt; maximum possible element count than the max value of its native uint type.<br>&gt;&gt; I know of at least one platform in development which uses 64 bits for<br>&gt;&gt; pointers, but the address space is only 61 bits because the CPU &amp; memory<br>&gt;&gt; system use 3 bits for flags.<br>&gt;&gt;<br>&gt;&gt; - Dave Sweeris<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were<br>&gt;&gt; designed to handle negative indexes just fine. Or even indexes that aren&#39;t<br>&gt;&gt; numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt;<br>&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;         get {<br>&gt;&gt;             return values[column+100]<br>&gt;&gt;         }<br>&gt;&gt;         set {<br>&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; var r = GraphRow()<br>&gt;&gt; r[-3] = 12<br>&gt;&gt; r[9] = 2<br>&gt;&gt; print(r[-3])<br>&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt;<br>&gt;&gt; -david<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts,<br>&gt;&gt;&gt; CollectionType&#39;s .count and the dimensions of CGSize) which are designed to<br>&gt;&gt;&gt; deal only with natural (non-negative) numbers. Functions either throw an<br>&gt;&gt;&gt; error if a parameter is negative, or else ignore the possibility of a<br>&gt;&gt;&gt; negative value finding its way into these functions.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; By updating the standard library with a natural number type to represent<br>&gt;&gt;&gt; these values (and potentially the Swift interfaces for Foundation and other<br>&gt;&gt;&gt; frameworks), there is no way a negative number can be passed to these<br>&gt;&gt;&gt; functions. This eliminates the need for many preconditions, allowing them<br>&gt;&gt;&gt; to eliminate the possibility of a crash, and it would be clear that values<br>&gt;&gt;&gt; such as count will never be negative.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If this change were accepted, the user would have to explicitly convert<br>&gt;&gt;&gt; between the types at some points in their code. This could be seen as a<br>&gt;&gt;&gt; burden, but requiring a cast encourages the programmer to check for<br>&gt;&gt;&gt; negative values, keeping negatives out of natural number functions, and<br>&gt;&gt;&gt; moving checks to the source of the data, similar to how Optionals eliminate<br>&gt;&gt;&gt; nil values early on.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect<br>&gt;&gt;&gt; of this idea. With Swift&#39;s focus on type safety, the lack of distinction<br>&gt;&gt;&gt; between natural numbers and potentially negative ones seems like an<br>&gt;&gt;&gt; omission, given how commonly both kinds of number are used. Enabling this<br>&gt;&gt;&gt; level of integral safety would add additional clarity and reduce potential<br>&gt;&gt;&gt; errors. Use cases include not just indexes, but in sizes such as<br>&gt;&gt;&gt; collections&#39; count and CG dimensions, for both clarity when getting values,<br>&gt;&gt;&gt; and enforcing valid values at initialisation.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but<br>&gt;&gt;&gt; is hazardous in edge cases: UInt allows an extra bit for magnitude, so has<br>&gt;&gt;&gt; the possibility of overflow when converting back to Int. I assume this<br>&gt;&gt;&gt; hazard is the primary reason UInt currently isn&#39;t used. If this a concern,<br>&gt;&gt;&gt; a separate collection of types for natural integers (NInt?) could be<br>&gt;&gt;&gt; created, which could be a strict subset of the correspondingly sized Int<br>&gt;&gt;&gt; values (using n-1 bits).<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This would mean adding a new collection of integer types in the standard<br>&gt;&gt;&gt; library, which is undesirable. However, for high level applications which<br>&gt;&gt;&gt; Swift is primarily used for, this would arguably be a more useful type than<br>&gt;&gt;&gt; UInt, considering the near absence of UInt in current APIs, and its tiny<br>&gt;&gt;&gt; increase (1 bit?) in precision compared to using an Int of a larger size.<br>&gt;&gt;&gt; An unsigned Integer subset would allow safe conversion back to Int, and the<br>&gt;&gt;&gt; conversion from Int is relatively simple, from the design perspective -<br>&gt;&gt;&gt; ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Alternatives include:<br>&gt;&gt;&gt; • A generic wrapper for Int which constrains its possible values. This<br>&gt;&gt;&gt; would allow inherent support for use with existing operators, but would be<br>&gt;&gt;&gt; rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt;&gt; • In a future version of Swift, the addition of type parameters<br>&gt;&gt;&gt; constraining possible values may enable this to be added, but even if this<br>&gt;&gt;&gt; does get added it may be too late to make such a major change.<br>&gt;&gt;&gt; • Leaving the APIs as they are and require every function dealing with<br>&gt;&gt;&gt; natural numbers to either throw a runtime error when a negative is passed.<br>&gt;&gt;&gt; If the user forgets to follow this rule (or wont put in the extra effort to<br>&gt;&gt;&gt; add the check), their functions will have unspecified behaviour.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think<br>&gt;&gt;&gt; this issue has been covered here.<br>&gt;&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m<br>&gt;&gt;&gt; confident this change would be beneficial if done correctly, doing it<br>&gt;&gt;&gt; correctly is easier said that done.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; - James<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/47a423c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  4, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On 4 Feb 2016, at 01:08, David Turnbull &lt;dturnbull at gmail.com&gt; wrote:<br>&gt; <br>&gt; Here&#39;s how you could use a collection as a predicate. The OnSwitchesIndex is opaque to anything outside the file. There&#39;s no way to iterate OnSwitches with  0 ..&lt;count. Thinking that arrays and sequences are counting up from 0 by 1 is missing the entire point of these protocols.<br></p><p><br>No matter the index, since .count represents the number of elements in the collection, it should never be negative.<br></p><p>An EveryOtherElementOfReverseOfArray implementation could have a startIndex of 4 and endIndex of 0, and wouldn&#39;t be iterable with a simple range, yet I&#39;d still expect the count to be positive. Types without integer indexes are no exception.<br></p><p><br>For cases such as CGSize: from memory, I have no idea how CGSize would handle negatives. Would it ignore the sign, crash on creation, or simply allow them?<br></p><p><br>According to the CGGeometry reference:<br></p><p>A CGSize structure is sometimes used to represent a distance vector, rather than a physical size. As a vector, its values can be negative. To normalize a CGRect structure so that its size is represented by positive values, call the CGRectStandardize function.<br></p><p><br>CGSize represents vectors and sizes? And an explicit ‘normalisation’ (a non-negative safety check) must be performed to work with CGSize as a size? This sounds awfully like a lack of type safety.<br></p><p>So based on CGSize&#39;s use as a vector, it would have to remain unchanged. Using naturals elsewhere in the frameworks would serve to make it much more obvious negative checks should be performed working with this and similar types. This example just serves to emphasise how important making this distinction is.<br></p><p>From James F<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/fa343596/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/7321934b88ca8da079d7b89926501a9c?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Turnbull</string> &lt;dturnbull at gmail.com&gt;<p>February  4, 2016 at 09:00:00am</p></header><div class="content"><p>On Thu, Feb 4, 2016 at 3:48 AM, James Froggatt &lt;conductator at ntlworld.com&gt;<br>wrote:<br></p><p>&gt; CGSize represents vectors *and* sizes? And an explicit ‘normalisation’ (a<br>&gt; non-negative safety check) must be performed to work with CGSize as a size?<br>&gt; This sounds awfully like a lack of type safety.<br>&gt;<br></p><p>That&#39;s an invariant. Enforcing y&gt;=x with a type system is just as hard as<br>the halting problem.<br></p><p>-david<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160204/10596c6b/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>I specifically referred to the subscript of Array, not all CollectionTypes. The fact is Array&#39;s specific implementation of CollectionType implements a zero-based index, yet exposes its subscript as a signed integer.<br></p><p>As for .count, there is no way for it to be negative in CollectionType&#39;s default implementation, and don&#39;t see any realistic situation in which an implementing type would override it to allow negative values. If one did, I&#39;m not sure it should conform to CollectionType to begin with. I expect there are many occurrences of 0 ..&lt; collection.count being used in functions operating on collections without first checking count is not negative, because why would it be?<br></p><p>The problem is, currently any type implementing CollectionType could do this, so when creating generic functions, any cautious programmer would have to account for it. The only sensible thing to do in that situation, that I can see, is throw an error, which suggests count is in fact unsafe.<br></p><p>I am unfamiliar with size_t, but a type that could act as an equivalent of the CGFloat typealias for unsigned integers seems a good idea. However, given size_t goes against Swift type naming conventions (I assume it exists for C interop?), it seems like it would be preferable to create a separate typealias for this purpose.<br></p><p>From James F<br></p><p>&gt; On 3 Feb 2016, at 20:35, davesweeris at mac.com wrote:<br>&gt; <br>&gt; What about .count? Is it possible for that to be negative? If we change how count is represented, I think it should be switched to size_t, rather that UInt. I’m aware that they’re currently the same thing, but that might not always be the case, and, at least the way I understand things, the max value of a platform’s “pointer” type is more directly tied to the maximum possible element count than the max value of its native uint type. I know of at least one platform in development which uses 64 bits for pointers, but the address space is only 61 bits because the CPU &amp; memory system use 3 bits for flags.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt; <br>&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were designed to handle negative indexes just fine. Or even indexes that aren&#39;t numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt; <br>&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;         get {<br>&gt;&gt;             return values[column+100]<br>&gt;&gt;         }<br>&gt;&gt;         set {<br>&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;         }<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; var r = GraphRow()<br>&gt;&gt; r[-3] = 12<br>&gt;&gt; r[9] = 2<br>&gt;&gt; print(r[-3])<br>&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt; <br>&gt;&gt; -david<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives include:<br>&gt;&gt;&gt; • A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt;&gt; • In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>&gt;&gt;&gt; • Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>&gt;&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - James<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/545a0f7c/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>Dunno, but unless you’re still specifically talking about arrays, why assume that it starts at 0?<br>&gt; On Feb 3, 2016, at 13:03, James Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br>&gt; <br>&gt; I expect there are many occurrences of 0 ..&lt; collection.count being used in functions operating on collections without first checking count is not negative, because why would it be?<br></p><p><br></p><p>IIRC, size_t is C’s pointer type, and as such, it’s maximum value is also the maximum # of bytes the system can address. Since the smallest data type in C is a byte, it’s always big enough to hold the number of elements in an array (which is why I used it). I think on most platforms it’s just typedefed to uint_64t (or uint_32t on 32-bit platforms). I don’t know if Swift is using it for anything behind the scenes, but I believe you are correct in that you’d only come across it in production code for interoperating with C code. Last time I checked, in Swift it was typealiased to UInt.<br></p><p>- Dave Sweeris<br></p><p>&gt; I am unfamiliar with size_t, but a type that could act as an equivalent of the CGFloat typealias for unsigned integers seems a good idea. However, given size_t goes against Swift type naming conventions (I assume it exists for C interop?), it seems like it would be preferable to create a separate typealias for this purpose.<br>&gt; <br>&gt; From James F<br>&gt; <br>&gt; On 3 Feb 2016, at 20:35, davesweeris at mac.com &lt;mailto:davesweeris at mac.com&gt; wrote:<br>&gt; <br>&gt;&gt; What about .count? Is it possible for that to be negative? If we change how count is represented, I think it should be switched to size_t, rather that UInt. I’m aware that they’re currently the same thing, but that might not always be the case, and, at least the way I understand things, the max value of a platform’s “pointer” type is more directly tied to the maximum possible element count than the max value of its native uint type. I know of at least one platform in development which uses 64 bits for pointers, but the address space is only 61 bits because the CPU &amp; memory system use 3 bits for flags.<br>&gt;&gt; <br>&gt;&gt; - Dave Sweeris<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were designed to handle negative indexes just fine. Or even indexes that aren&#39;t numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;&gt;         get {<br>&gt;&gt;&gt;             return values[column+100]<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;         set {<br>&gt;&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;&gt;         }<br>&gt;&gt;&gt;     }<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; var r = GraphRow()<br>&gt;&gt;&gt; r[-3] = 12<br>&gt;&gt;&gt; r[9] = 2<br>&gt;&gt;&gt; print(r[-3])<br>&gt;&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -david<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Alternatives include:<br>&gt;&gt;&gt; • A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt;&gt; • In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>&gt;&gt;&gt; • Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>&gt;&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - James<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt; <br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/d7406619/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 09:00:00pm</p></header><div class="content"><p>I would assume count represents the number of elements in the collection, in which case the lowest possible value would be 0.<br></p><p>Admittedly, the loop would only be useful for CollectionTypes with zero indexed arrays, however that just leads back to the issue that while:<br>T: CollectionType where T.Index == Int<br>is valid, there is no guarantee that the collection is zero-indexed, which is useful information to have to constrain to Array-like collections.<br></p><p>From James F<br></p><p>&gt; On 3 Feb 2016, at 21:26, davesweeris at mac.com wrote:<br>&gt; <br>&gt; Dunno, but unless you’re still specifically talking about arrays, why assume that it starts at 0?<br>&gt;&gt; On Feb 3, 2016, at 13:03, James Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; I expect there are many occurrences of 0 ..&lt; collection.count being used in functions operating on collections without first checking count is not negative, because why would it be?<br>&gt; <br>&gt; <br>&gt; <br>&gt; IIRC, size_t is C’s pointer type, and as such, it’s maximum value is also the maximum # of bytes the system can address. Since the smallest data type in C is a byte, it’s always big enough to hold the number of elements in an array (which is why I used it). I think on most platforms it’s just typedefed to uint_64t (or uint_32t on 32-bit platforms). I don’t know if Swift is using it for anything behind the scenes, but I believe you are correct in that you’d only come across it in production code for interoperating with C code. Last time I checked, in Swift it was typealiased to UInt.<br>&gt; <br>&gt; - Dave Sweeris<br>&gt; <br>&gt;&gt; I am unfamiliar with size_t, but a type that could act as an equivalent of the CGFloat typealias for unsigned integers seems a good idea. However, given size_t goes against Swift type naming conventions (I assume it exists for C interop?), it seems like it would be preferable to create a separate typealias for this purpose.<br>&gt;&gt; <br>&gt;&gt; From James F<br>&gt;&gt; <br>&gt;&gt;&gt; On 3 Feb 2016, at 20:35, davesweeris at mac.com wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What about .count? Is it possible for that to be negative? If we change how count is represented, I think it should be switched to size_t, rather that UInt. I’m aware that they’re currently the same thing, but that might not always be the case, and, at least the way I understand things, the max value of a platform’s “pointer” type is more directly tied to the maximum possible element count than the max value of its native uint type. I know of at least one platform in development which uses 64 bits for pointers, but the address space is only 61 bits because the CPU &amp; memory system use 3 bits for flags.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; - Dave Sweeris<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Feb 3, 2016, at 11:58, David Turnbull via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -1  CollectionType and it&#39;s ilk, contrary to what you believe, were designed to handle negative indexes just fine. Or even indexes that aren&#39;t numeric. And there&#39;s plenty of real use cases for this.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; class GraphRow : MutableCollectionType {<br>&gt;&gt;&gt;&gt;     var values = [Int](count: 201, repeatedValue: 0)<br>&gt;&gt;&gt;&gt;     var startIndex: Int { return -100 }<br>&gt;&gt;&gt;&gt;     var endIndex: Int { return 100 }<br>&gt;&gt;&gt;&gt;     subscript(column: Int) -&gt; Int {<br>&gt;&gt;&gt;&gt;         get {<br>&gt;&gt;&gt;&gt;             return values[column+100]<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;         set {<br>&gt;&gt;&gt;&gt;             values[column+100] = newValue<br>&gt;&gt;&gt;&gt;         }<br>&gt;&gt;&gt;&gt;     }<br>&gt;&gt;&gt;&gt; }<br>&gt;&gt;&gt;&gt; var r = GraphRow()<br>&gt;&gt;&gt;&gt; r[-3] = 12<br>&gt;&gt;&gt;&gt; r[9] = 2<br>&gt;&gt;&gt;&gt; print(r[-3])<br>&gt;&gt;&gt;&gt; print(r.reduce(0, combine: +))<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -david<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If this change were accepted, the user would have to explicitly convert between the types at some points in their code. This could be seen as a burden, but requiring a cast encourages the programmer to check for negative values, keeping negatives out of natural number functions, and moving checks to the source of the data, similar to how Optionals eliminate nil values early on.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of this idea. With Swift&#39;s focus on type safety, the lack of distinction between natural numbers and potentially negative ones seems like an omission, given how commonly both kinds of number are used. Enabling this level of integral safety would add additional clarity and reduce potential errors. Use cases include not just indexes, but in sizes such as collections&#39; count and CG dimensions, for both clarity when getting values, and enforcing valid values at initialisation.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; UInt is the obvious candidate to represent integer natural numbers, but is hazardous in edge cases: UInt allows an extra bit for magnitude, so has the possibility of overflow when converting back to Int. I assume this hazard is the primary reason UInt currently isn&#39;t used. If this a concern, a separate collection of types for natural integers (NInt?) could be created, which could be a strict subset of the correspondingly sized Int values (using n-1 bits).<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This would mean adding a new collection of integer types in the standard library, which is undesirable. However, for high level applications which Swift is primarily used for, this would arguably be a more useful type than UInt, considering the near absence of UInt in current APIs, and its tiny increase (1 bit?) in precision compared to using an Int of a larger size. An unsigned Integer subset would allow safe conversion back to Int, and the conversion from Int is relatively simple, from the design perspective - ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Alternatives include:<br>&gt;&gt;&gt;&gt;&gt; • A generic wrapper for Int which constrains its possible values. This would allow inherent support for use with existing operators, but would be rather clunky in cases where only natural numbers are being dealt with.<br>&gt;&gt;&gt;&gt;&gt; • In a future version of Swift, the addition of type parameters constraining possible values may enable this to be added, but even if this does get added it may be too late to make such a major change.<br>&gt;&gt;&gt;&gt;&gt; • Leaving the APIs as they are and require every function dealing with natural numbers to either throw a runtime error when a negative is passed. If the user forgets to follow this rule (or wont put in the extra effort to add the check), their functions will have unspecified behaviour.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; This ended up longer than I would like, sorry about that. I don&#39;t think this issue has been covered here.<br>&gt;&gt;&gt;&gt;&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident this change would be beneficial if done correctly, doing it correctly is easier said that done.<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; - James<br>&gt;&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; <br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/d8b39a59/attachment-0001.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  3, 2016 at 01:00:00pm</p></header><div class="content"><p>On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; In the standard library, there are methods (notably array subscripts,<br>&gt; CollectionType&#39;s .count and the dimensions of CGSize) which are designed to<br>&gt; deal only with natural (non-negative) numbers. Functions either throw an<br>&gt; error if a parameter is negative, or else ignore the possibility of a<br>&gt; negative value finding its way into these functions.<br>&gt;<br>&gt; By updating the standard library with a natural number type to represent<br>&gt; these values (and potentially the Swift interfaces for Foundation and other<br>&gt; frameworks), there is no way a negative number can be passed to these<br>&gt; functions. This eliminates the need for many preconditions, allowing them<br>&gt; to eliminate the possibility of a crash, and it would be clear that values<br>&gt; such as count will never be negative.<br>&gt;<br>&gt;<br>How would you handle the types of arithmetic operations?  Natural numbers<br>are not closed under subtraction or division; a natural number minus<br>another natural number may be an integer.  There&#39;s no provision for<br>arithmetic operations to throw an error in Swift, so you might have to<br>silently eat the error in the subtraction operation, which defeats much of<br>the typesafety of having a separate type.<br></p><p><br>&gt; If this change were accepted, the user would have to explicitly convert<br>&gt; between the types at some points in their code. This could be seen as a<br>&gt; burden, but requiring a cast encourages the programmer to check for<br>&gt; negative values, keeping negatives out of natural number functions, and<br>&gt; moving checks to the source of the data, similar to how Optionals eliminate<br>&gt; nil values early on.<br>&gt;<br>&gt;<br>You could alleviate this somewhat by having natural numbers conform to<br>IntLiteralConvertible.<br></p><p><br>&gt; The parallel to Optionals is, in my opinion, the most appealing aspect of<br>&gt; this idea. With Swift&#39;s focus on type safety, the lack of distinction<br>&gt; between natural numbers and potentially negative ones seems like an<br>&gt; omission, given how commonly both kinds of number are used. Enabling this<br>&gt; level of integral safety would add additional clarity and reduce potential<br>&gt; errors. Use cases include not just indexes, but in sizes such as<br>&gt; collections&#39; count and CG dimensions, for both clarity when getting values,<br>&gt; and enforcing valid values at initialisation.<br>&gt;<br>&gt; UInt is the obvious candidate to represent integer natural numbers, but is<br>&gt; hazardous in edge cases: UInt allows an extra bit for magnitude, so has the<br>&gt; possibility of overflow when converting back to Int. I assume this hazard<br>&gt; is the primary reason UInt currently isn&#39;t used. If this a concern, a<br>&gt; separate collection of types for natural integers (NInt?) could be created,<br>&gt; which could be a strict subset of the correspondingly sized Int values<br>&gt; (using n-1 bits).<br>&gt;<br>&gt; This would mean adding a new collection of integer types in the standard<br>&gt; library, which is undesirable. However, for high level applications which<br>&gt; Swift is primarily used for, this would arguably be a more useful type than<br>&gt; UInt, considering the near absence of UInt in current APIs, and its tiny<br>&gt; increase (1 bit?) in precision compared to using an Int of a larger size.<br>&gt; An unsigned Integer subset would allow safe conversion back to Int, and the<br>&gt; conversion from Int is relatively simple, from the design perspective -<br>&gt; ignore the sign bit, throw an error, or round up to 0, as appropriate.<br>&gt;<br>&gt; Alternatives include:<br>&gt; • A generic wrapper for Int which constrains its possible values. This<br>&gt; would allow inherent support for use with existing operators, but would be<br>&gt; rather clunky in cases where only natural numbers are being dealt with.<br>&gt; • In a future version of Swift, the addition of type parameters<br>&gt; constraining possible values may enable this to be added, but even if this<br>&gt; does get added it may be too late to make such a major change.<br>&gt; • Leaving the APIs as they are and require every function dealing with<br>&gt; natural numbers to either throw a runtime error when a negative is passed.<br>&gt; If the user forgets to follow this rule (or wont put in the extra effort to<br>&gt; add the check), their functions will have unspecified behaviour.<br>&gt;<br>&gt; This ended up longer than I would like, sorry about that. I don&#39;t think<br>&gt; this issue has been covered here.<br>&gt; I&#39;d be interested to hear responses and opinions, and while I&#39;m confident<br>&gt; this change would be beneficial if done correctly, doing it correctly is<br>&gt; easier said that done.<br>&gt;<br>&gt; - James<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/1596be01/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/6a94b04f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/bc045f9bdc3bd1885767f2a2ba8af458?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>Jonathan Tang</string> &lt;jonathan.d.tang at gmail.com&gt;<p>February  3, 2016 at 02:00:00pm</p></header><div class="content"><p>On Wed, Feb 3, 2016 at 2:17 PM, James Samuel Froggatt &lt;<br>conductator at ntlworld.com&gt; wrote:<br></p><p>&gt; That is an interesting point. Based on how the operators are defined for<br>&gt; Int:<br>&gt;<br>&gt; ‘Unlike the arithmetic operators in C and Objective-C, the Swift<br>&gt; arithmetic operators do not allow values to overflow by default. You can<br>&gt; opt in to value overflow behavior by using Swift’s overflow operators (such<br>&gt; as a &amp;+ b)’<br>&gt;<br>&gt; https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html<br>&gt;<br>&gt;<br>&gt; The former statement, I believe, refers to the behaviour of throwing a<br>&gt; runtime error. The solution would be the same as for checking before using<br>&gt; an Array subscript (as currently implemented): explicit comparisons before<br>&gt; performing the potentially crashing operation.<br>&gt;<br>&gt; A regular signed integer already has the hazard of a ÷0 error. I think it<br>&gt; would make sense to throw errors readily for subtraction - if the user<br>&gt; would have to perform a check beforehand or face the consequences, just as<br>&gt; they do for index out of bounds errors with Arrays. This is is currently<br>&gt; how UInt&#39;s subtract implementation works, and I think the best option is to<br>&gt; match this behaviour.<br>&gt;<br>&gt;<br>&gt;<br>We&#39;d be largely in the same position we are in now w.r.t. array accesses.<br>You still need a runtime check and you can still cause a crash, but the<br>check has been moved from the array subscript to any subtraction on array<br>indices.  As with divide-by-zero, it&#39;s the responsibility of the calling<br>algorithm to make sure this never happens.<br></p><p>I think I&#39;m -1 on this.  Swift has for-each loops already that eliminate<br>the vast majority of explicit array accesses.  For ones with a computed<br>index, you&#39;d still need a check for &lt;0 on the computation.  Literal indices<br>aren&#39;t much of a risk anyway - it&#39;s pretty obvious when you&#39;re subscripting<br>with a literal negative number - but as others have pointed out, there are<br>sometimes legit reasons why you might want a negative subscript or count<br>property.<br></p><p><br>&gt; On 3 Feb 2016, at 21:51, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt;<br>&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; In the standard library, there are methods (notably array subscripts,<br>&gt;&gt; CollectionType&#39;s .count and the dimensions of CGSize) which are designed to<br>&gt;&gt; deal only with natural (non-negative) numbers. Functions either throw an<br>&gt;&gt; error if a parameter is negative, or else ignore the possibility of a<br>&gt;&gt; negative value finding its way into these functions.<br>&gt;&gt;<br>&gt;&gt; By updating the standard library with a natural number type to represent<br>&gt;&gt; these values (and potentially the Swift interfaces for Foundation and other<br>&gt;&gt; frameworks), there is no way a negative number can be passed to these<br>&gt;&gt; functions. This eliminates the need for many preconditions, allowing them<br>&gt;&gt; to eliminate the possibility of a crash, and it would be clear that values<br>&gt;&gt; such as count will never be negative.<br>&gt;&gt;<br>&gt;&gt;<br>&gt; How would you handle the types of arithmetic operations?  Natural numbers<br>&gt; are not closed under subtraction or division; a natural number minus<br>&gt; another natural number may be an integer.  There&#39;s no provision for<br>&gt; arithmetic operations to throw an error in Swift, so you might have to<br>&gt; silently eat the error in the subtraction operation, which defeats much of<br>&gt; the typesafety of having a separate type.<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/a45d5fc7/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Representation of natural numbers with a distinct type</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 10:00:00pm</p></header><div class="content"><p>Fair point, though I&#39;ll point out that if the subtraction of Array indices ever did result in a negative, using the result as an index will result in a runtime error already.<br></p><p>If the negative result is useful, an explicit cast would be necessary for both operands. The main issue with this idea does seem to be the explicit casting, and this would have to be either accepted, or else overcome to make working with naturals more friendly, for this proposal to be accepted.<br></p><p>One solution would be an operator like subtract which returns an Int, to allow for easy conversion in this case, however this smells of a workaround.<br></p><p>Even if the idea isn&#39;t accepted, any solution we find for the problem of working with naturals would be equally applicable to UInt, so the discussion seems worth having either way.<br></p><p>From James F<br></p><p>&gt; On 3 Feb 2016, at 22:26, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; On Wed, Feb 3, 2016 at 2:17 PM, James Samuel Froggatt &lt;conductator at ntlworld.com&gt; wrote:<br>&gt;&gt; That is an interesting point. Based on how the operators are defined for Int:<br>&gt;&gt; <br>&gt;&gt; ‘Unlike the arithmetic operators in C and Objective-C, the Swift arithmetic operators do not allow values to overflow by default. You can opt in to value overflow behavior by using Swift’s overflow operators (such as a &amp;+ b)’<br>&gt;&gt; https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/BasicOperators.html<br>&gt;&gt; <br>&gt;&gt; The former statement, I believe, refers to the behaviour of throwing a runtime error. The solution would be the same as for checking before using an Array subscript (as currently implemented): explicit comparisons before performing the potentially crashing operation.<br>&gt;&gt; <br>&gt;&gt; A regular signed integer already has the hazard of a ÷0 error. I think it would make sense to throw errors readily for subtraction - if the user would have to perform a check beforehand or face the consequences, just as they do for index out of bounds errors with Arrays. This is is currently how UInt&#39;s subtract implementation works, and I think the best option is to match this behaviour.<br>&gt; <br>&gt; We&#39;d be largely in the same position we are in now w.r.t. array accesses.  You still need a runtime check and you can still cause a crash, but the check has been moved from the array subscript to any subtraction on array indices.  As with divide-by-zero, it&#39;s the responsibility of the calling algorithm to make sure this never happens.<br>&gt; <br>&gt; I think I&#39;m -1 on this.  Swift has for-each loops already that eliminate the vast majority of explicit array accesses.  For ones with a computed index, you&#39;d still need a check for &lt;0 on the computation.  Literal indices aren&#39;t much of a risk anyway - it&#39;s pretty obvious when you&#39;re subscripting with a literal negative number - but as others have pointed out, there are sometimes legit reasons why you might want a negative subscript or count property.<br>&gt;  <br>&gt;&gt;&gt; On 3 Feb 2016, at 21:51, Jonathan Tang &lt;jonathan.d.tang at gmail.com&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On Wed, Feb 3, 2016 at 9:31 AM, James Froggatt via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; In the standard library, there are methods (notably array subscripts, CollectionType&#39;s .count and the dimensions of CGSize) which are designed to deal only with natural (non-negative) numbers. Functions either throw an error if a parameter is negative, or else ignore the possibility of a negative value finding its way into these functions.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; By updating the standard library with a natural number type to represent these values (and potentially the Swift interfaces for Foundation and other frameworks), there is no way a negative number can be passed to these functions. This eliminates the need for many preconditions, allowing them to eliminate the possibility of a crash, and it would be clear that values such as count will never be negative.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; How would you handle the types of arithmetic operations?  Natural numbers are not closed under subtraction or division; a natural number minus another natural number may be an integer.  There&#39;s no provision for arithmetic operations to throw an error in Swift, so you might have to silently eat the error in the subtraction operation, which defeats much of the typesafety of having a separate type.<br>&gt; <br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160203/57f1b9f7/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2679e7a28cb46e207a562ad4e7fc45fc?s=50"></div><header><strong>Compile time constraints on properties</strong> from <string>James F</string> &lt;conductator at ntlworld.com&gt;<p>February  3, 2016 at 11:00:00pm</p></header><div class="content"><p>As a side note to the natural numbers discussion, the idea of constraining properties at compile time seems like it would allow compile-time safety for all existing types.<br></p><p>Based on the previous ‘Partially Constrained Protocols’ discussion, a natural extension would be:<br>protocol&lt;Self == TypeName where Self.instance.property == [literal]&gt;<br></p><p>This would require a new keyword, ‘instance’ is an obvious candidate, though isn&#39;t great, but would allow function parameters and return types to make compile-time requirements on the value being passed, and make promises about values being returned, eliminating the need for failure conditions hidden inside the function itself.<br></p><p>Thus allowing:<br>protocol&lt;Self == Int where Self.instance &gt;= 0&gt;<br></p><p>I&#39;m not sure how feasible this would be, as it&#39;s presumably asking a lot in terms of compile-time code checking, but it would certainly cover constraining to natural numbers and eliminate many runtime failure conditions.<br></p><p>Honestly, I&#39;m not happy with verbosity of the ‘where’ syntax in general; any other suggestions for syntax are welcome.<br></p><p>Usage:<br>typealias NaturalInt = protocol&lt;Self == Int where Self.instance &gt;= 0&gt;<br>struct SafeSize {<br>    var width: NaturalInt<br>    var height: NaturalInt<br>}<br>extension Array {<br>    subscript(safer index: NaturalInt) -&gt; _Element {<br>        return self[index]<br>    }<br>}<br></p><p>I also feel I&#39;ve seen this issue raised here before, so I may be reviving an old discussion.<br></p><p>From James F<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
