<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 20, 2016 at 03:00:00pm</p></header><div class="content"><p>I would like to discuss about the following topic.<br></p><p>Wouldn&#39;t it be better to enforce argument labels on tuples types, if the tuple type defines them?<br></p><p>```swift<br></p><p>func foo(tuple: (a: Int, b: Int)) { /* do something */ }<br></p><p>let test1 = (10, 100)<br>let test2: (a: Int, c: Int) = test<br>let test3: (Int, Int) = test2<br></p><p>foo(test1)<br>foo(test3)<br></p><p>/*<br>cannot convert value of type &#39;(a: Int, c: Int)&#39; <br>to expected argument type &#39;(a: Int, b: Int)&#39;<br>*/<br>foo(test2) <br></p><p>```<br></p><p>Function `foo` awaits a tuple of type `(a: Int, b: Int)` but `test1` and `test3` are both just of type `(Int, Int)`.<br>As expected `test2` will raise an error because it has indeed a wrong type `(a: Int, c: Int)`.<br></p><p>I&#39;d suggest to enforce argument labeling on tuple types for better readability, because wasn&#39;t it the idea behind labels inside tuples?<br></p><p>`foo(test1)` should raise an error `cannot convert value of type &#39;(Int, Int)&#39; to expected argument type &#39;(a: Int, b: Int)&#39;` as long as `test1` is not written like `let test1 = (a: 10, b: 100)` or `let test1: (a: Int, b: Int) = (a: 10, b: 100)`<br></p><p>This will impact current codebase if you used labels but provided tuples without labels like the example above. The migrator could solve this by providing labels automatically to tuples where this error occurs.<br></p><p>I&#39;m not good at writing proposals for the GitHub repository at all, so if the community likes this idea, I&#39;d be glad to see some help for this little proposal.<br></p><p>-- <br>Adrian Zubarev<br>Sent with Airmail<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/4d369c52/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>April 20, 2016 at 07:00:00pm</p></header><div class="content"><p>I think it&#39;s good that the labels aren&#39;t enforced:<br>This would sacrifice flexibility, and force us to write unnecessary boilerplate to &quot;translate&quot; labels (one library might use (height, width), and another (h, w) to express the same concept…)<br></p><p>But: Objective-C had no tuples, so a final decision shouldn&#39;t happen until there is an agreement on best-practices for them...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>April 20, 2016 at 10:00:00am</p></header><div class="content"><p>+1 to Tino&#39;s concern. This seems like something better suited for a formal newtype style feature.<br></p><p>Austin<br></p><p><br>&gt; On Apr 20, 2016, at 10:47 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think it&#39;s good that the labels aren&#39;t enforced:<br>&gt; This would sacrifice flexibility, and force us to write unnecessary boilerplate to &quot;translate&quot; labels (one library might use (height, width), and another (h, w) to express the same concept…)<br>&gt; <br>&gt; But: Objective-C had no tuples, so a final decision shouldn&#39;t happen until there is an agreement on best-practices for them...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 20, 2016 at 07:00:00pm</p></header><div class="content"><p>That’s why I’d like to discuss this topic and hear all your feedback.<br></p><p>Do you think it might be possible to add some optional extra flag to the language to enforce argument labeling. Not only for tuples as I started the discussion with but also for argument labels on blocks/closures?<br></p><p>```swift<br></p><p>@require_argument_label<br>func foo(tuple: (a: Int, b: Int)) { /* do some work */ }<br></p><p>// this will only work with<br></p><p>let test1 = (a: 1, b: 2)<br>foo(test1)<br></p><p>func foo(block: (boo: Int) -&gt; Void) { /* pass boo to block */ }<br></p><p><br>foo() { boo in // do is enforced here<br>	/* do some work*/<br>}<br></p><p>// or<br></p><p>foo() { (boo: Int) -&gt; Void in<br>	/* do some work*/<br>}<br>```<br></p><p>An extra flag won’t break any codebase and as an addition will allow some good looking syntax at some places.<br></p><p>-- <br>Adrian Zubarev<br></p><p>Am 20. April 2016 bei 19:47:03, Tino Heth (2th at gmx.de) schrieb:<br></p><p>I think it&#39;s good that the labels aren&#39;t enforced:  <br>This would sacrifice flexibility, and force us to write unnecessary boilerplate to &quot;translate&quot; labels (one library might use (height, width), and another (h, w) to express the same concept…)  <br></p><p>But: Objective-C had no tuples, so a final decision shouldn&#39;t happen until there is an agreement on best-practices for them...<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/2bec431f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 20, 2016 at 08:00:00pm</p></header><div class="content"><p>I forgot something in my previous post:<br></p><p>```swift<br></p><p>@require_argument_label<br>func foo(block: (boo: Int) -&gt; Void) { /* pass boo to block */ }<br></p><p><br>foo() { boo in // do is enforced here<br>	/* do some work*/<br>}<br></p><p>```<br></p><p>-- <br>Adrian Zubarev<br></p><p>Am 20. April 2016 bei 19:59:23, Adrian Zubarev (adrian.zubarev at devandartist.com) schrieb:<br></p><p>@require_argument_label<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/43d479d1/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/b9904260218b6d7942782c2b2355f2aa?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>William Dillon</string> &lt;william at housedillon.com&gt;<p>April 20, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; <br>&gt; Do you think it might be possible to add some optional extra flag to the language to enforce argument labeling. Not only for tuples as I started the discussion with but also for argument labels on blocks/closures?<br>&gt; <br></p><p>That seems fairly heavy-handed, also.<br></p><p>This feels like the kind of thing that should be enforced by an organization&#39;s policy not by the language, IMHO.<br></p><p>- Will<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/e00bfd50/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/279fa63eae4ac804b4dbdb83686797bf?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Austin Zheng</string> &lt;austinzheng at gmail.com&gt;<p>April 20, 2016 at 11:00:00am</p></header><div class="content"><p>The tuple splat feature you mention below (&quot;foo(test1)&quot;, where test1 is a tuple ) is going away in Swift 3, as is the entire idea of modeling a function&#39;s list of formal parameters as a named tuple.<br></p><p>Aside from that, my personal opinion is that forcing a closure to take certain argument names is way too onerous a requirement for very little benefit. It would, for example, disqualify the use of the $x wildcards or the use of local argument names which more precisely represent the semantics of the closure. Function signatures are already very complicated, so I think any new attributes or flags should really have a strong argument to justify their inclusion.<br></p><p>Austin<br></p><p><br>&gt; On Apr 20, 2016, at 10:59 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; That’s why I’d like to discuss this topic and hear all your feedback.<br>&gt; <br>&gt; Do you think it might be possible to add some optional extra flag to the language to enforce argument labeling. Not only for tuples as I started the discussion with but also for argument labels on blocks/closures?<br>&gt; <br>&gt; ```swift<br>&gt; <br>&gt; @require_argument_label<br>&gt; func foo(tuple: (a: Int, b: Int)) { /* do some work */ }<br>&gt; <br>&gt; // this will only work with<br>&gt; <br>&gt; let test1 = (a: 1, b: 2)<br>&gt; foo(test1)<br>&gt; <br>&gt; func foo(block: (boo: Int) -&gt; Void) { /* pass boo to block */ }<br>&gt; <br>&gt; <br>&gt; foo() { boo in // do is enforced here<br>&gt; 	/* do some work*/<br>&gt; }<br>&gt; <br>&gt; // or<br>&gt; <br>&gt; foo() { (boo: Int) -&gt; Void in<br>&gt; 	/* do some work*/<br>&gt; }<br>&gt; ```<br>&gt; <br>&gt; An extra flag won’t break any codebase and as an addition will allow some good looking syntax at some places.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; <br>&gt; Am 20. April 2016 bei 19:47:03, Tino Heth (2th at gmx.de &lt;mailto:2th at gmx.de&gt;) schrieb:<br>&gt; <br>&gt;&gt; I think it&#39;s good that the labels aren&#39;t enforced: <br>&gt;&gt; This would sacrifice flexibility, and force us to write unnecessary boilerplate to &quot;translate&quot; labels (one library might use (height, width), and another (h, w) to express the same concept…) <br>&gt;&gt; <br>&gt;&gt; But: Objective-C had no tuples, so a final decision shouldn&#39;t happen until there is an agreement on best-practices for them...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/3a63f6b0/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>April 20, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; Do you think it might be possible to add some optional extra flag to the language to enforce argument labeling. Not only for tuples as I started the discussion with but also for argument labels on blocks/closures?<br>I&#39;m quite skeptical when it comes to enforce behavior (unless it&#39;s the way I prefer it anyways ;-) — and in this case, I think the carrot is better than the stick:<br>Leave the language as it is, but let the tools add the &quot;right&quot; labels by default (sadly, there is no thing like Xcode-evolution… ;-)<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/c2a5c4f3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/1f823d615b521ed15f1006b105c77900?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>David Sweeris</string> &lt;davesweeris at mac.com&gt;<p>April 20, 2016 at 04:00:00pm</p></header><div class="content"><p>What about enforcing the argument labels, but then adding a “@autolabel” or something in code where the current behavior is desired?<br></p><p>- Dave Sweeris<br></p><p>&gt; On Apr 20, 2016, at 12:47 PM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I think it&#39;s good that the labels aren&#39;t enforced:<br>&gt; This would sacrifice flexibility, and force us to write unnecessary boilerplate to &quot;translate&quot; labels (one library might use (height, width), and another (h, w) to express the same concept…)<br>&gt; <br>&gt; But: Objective-C had no tuples, so a final decision shouldn&#39;t happen until there is an agreement on best-practices for them...<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 20, 2016 at 07:00:00pm</p></header><div class="content"><p>I’m not sure about a general rule, but I think that labels should be required for associated types and type aliases. I can’t check right now if this changed in Swift 3, but in earlier version Dictionary for example has the associated type Element which is a tuple of (Key, Value). While using this via .0 and .1 is fine generally, I’d much rather the parameters were named key and value for absolute clarity, and think that this the way to go with these. For ad-hoc tuples it doesn’t matter so much, but yeah, the rest of the time I’d prefer to be clear.<br></p><p>While it may be annoying in cases where names don’t match, I think that’s fine too, as it forces us to be explicit about what’s happening, as it may not always be clear to someone new to maintaining the code. There could perhaps be a simpler syntax for mapping tuples, or an attribute/compiler directive to ignore the mismatch anywhere it occurs?<br></p><p>&gt; On 20 Apr 2016, at 14:23, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like to discuss about the following topic.<br>&gt; <br>&gt; Wouldn&#39;t it be better to enforce argument labels on tuples types, if the tuple type defines them?<br>&gt; <br>&gt; ```swift<br>&gt; <br>&gt; func foo(tuple: (a: Int, b: Int)) { /* do something */ }<br>&gt; <br>&gt; let test1 = (10, 100)<br>&gt; let test2: (a: Int, c: Int) = test<br>&gt; let test3: (Int, Int) = test2<br>&gt; <br>&gt; foo(test1)<br>&gt; foo(test3)<br>&gt; <br>&gt; /*<br>&gt; cannot convert value of type &#39;(a: Int, c: Int)&#39; <br>&gt; to expected argument type &#39;(a: Int, b: Int)&#39;<br>&gt; */<br>&gt; foo(test2) <br>&gt; <br>&gt; ```<br>&gt; <br>&gt; Function `foo` awaits a tuple of type `(a: Int, b: Int)` but `test1` and `test3` are both just of type `(Int, Int)`.<br>&gt; As expected `test2` will raise an error because it has indeed a wrong type `(a: Int, c: Int)`.<br>&gt; <br>&gt; I&#39;d suggest to enforce argument labeling on tuple types for better readability, because wasn&#39;t it the idea behind labels inside tuples?<br>&gt; <br>&gt; `foo(test1)` should raise an error `cannot convert value of type &#39;(Int, Int)&#39; to expected argument type &#39;(a: Int, b: Int)&#39;` as long as `test1` is not written like `let test1 = (a: 10, b: 100)` or `let test1: (a: Int, b: Int) = (a: 10, b: 100)`<br>&gt; <br>&gt; This will impact current codebase if you used labels but provided tuples without labels like the example above. The migrator could solve this by providing labels automatically to tuples where this error occurs.<br>&gt; <br>&gt; I&#39;m not good at writing proposals for the GitHub repository at all, so if the community likes this idea, I&#39;d be glad to see some help for this little proposal.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/c6ff8506/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 20, 2016 at 08:00:00pm</p></header><div class="content"><p>@Austin I wasn’t talking about the tuple splat feature here.<br></p><p>In my case I was trying to simplify the example of a function that awaits an actual tuple of a specific type, which in my case also (should) have argument labels.<br></p><p>```swift<br></p><p>func foo(tuple: (a: Int, b: Int)) {}<br></p><p>let tuple = (10, 42)<br>foo(tuple)<br></p><p>// this is not the same as <br></p><p>func boo(a: Int, b: Int) {}<br>boo(42, b: 17)<br></p><p>let x = (1, b: 2)<br>boo(x) // which will be removed in Swift 3<br>```<br></p><p>-- <br>Adrian Zubarev<br></p><p>Am 20. April 2016 bei 20:11:01, Haravikk (swift-evolution at haravikk.me) schrieb:<br></p><p>organization&#39;s policy<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/a44b5a22/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 20, 2016 at 12:00:00pm</p></header><div class="content"><p>This is similar to another concern I raised with functions and being able to essentially erase the function argument names and apply two different named parameters just because their types match.<br></p><p>It seems reasonable to me that you can go from (x: Int, y: Int) =&gt; (Int, Int). However, going from (x: Int, y: Int) =&gt; (a: Int, b: Int) feels somewhat odd. Yes, the types can obviously slot in there fine, but how much importance do the labels for the types bring to the table?<br></p><p>Similarly, should this (Int, Int) =&gt; (x: Int, y: Int) be allowed through an implicit means? If so, then it&#39;s really just an intermediate step for (x: Int, y: Int) =&gt; (a: Int, b: Int) working.<br></p><p>So what matters more, type signatures or label names?<br></p><p>Here&#39;s an example:<br></p><p>typealias Functor = (left: Int, right: Int) -&gt; Int<br></p><p>func hi(x: Int, y: Int, fn: Functor) -&gt; Int {<br>    return fn(left: x, right: y)<br>}<br></p><p>hi(1, y: 2, fn: +)<br>hi(1, y: 2, fn: *)<br></p><p>If we say that the parameter names are indeed vital, then the above code cannot work as the operators that match the type signature are defined as: <br></p><p>public func +(lhs: Int, rhs: Int) -&gt; Int<br></p><p>Obviously, given a name to the parameter brings clarity and can be self documenting, but if we want the above to work while making names just as vital as the type signature, then we need to declare `Functor` as such:<br></p><p>typealias Functor = (_ left: Int, _ right: Int) -&gt; Int<br></p><p>However, that&#39;s not even legal code today, and even if it were, is that really better?<br></p><p>So I&#39;m mixed on the idea. I think the idea that type coercions happening for matching type signatures is very powerful, and this just happens to be one of the example manifestations of that.<br></p><p>-David<br></p><p>&gt; On Apr 20, 2016, at 6:23 AM, Adrian Zubarev via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I would like to discuss about the following topic.<br>&gt; <br>&gt; Wouldn&#39;t it be better to enforce argument labels on tuples types, if the tuple type defines them?<br>&gt; <br>&gt; ```swift<br>&gt; <br>&gt; func foo(tuple: (a: Int, b: Int)) { /* do something */ }<br>&gt; <br>&gt; let test1 = (10, 100)<br>&gt; let test2: (a: Int, c: Int) = test<br>&gt; let test3: (Int, Int) = test2<br>&gt; <br>&gt; foo(test1)<br>&gt; foo(test3)<br>&gt; <br>&gt; /*<br>&gt; cannot convert value of type &#39;(a: Int, c: Int)&#39; <br>&gt; to expected argument type &#39;(a: Int, b: Int)&#39;<br>&gt; */<br>&gt; foo(test2) <br>&gt; <br>&gt; ```<br>&gt; <br>&gt; Function `foo` awaits a tuple of type `(a: Int, b: Int)` but `test1` and `test3` are both just of type `(Int, Int)`.<br>&gt; As expected `test2` will raise an error because it has indeed a wrong type `(a: Int, c: Int)`.<br>&gt; <br>&gt; I&#39;d suggest to enforce argument labeling on tuple types for better readability, because wasn&#39;t it the idea behind labels inside tuples?<br>&gt; <br>&gt; `foo(test1)` should raise an error `cannot convert value of type &#39;(Int, Int)&#39; to expected argument type &#39;(a: Int, b: Int)&#39;` as long as `test1` is not written like `let test1 = (a: 10, b: 100)` or `let test1: (a: Int, b: Int) = (a: 10, b: 100)`<br>&gt; <br>&gt; This will impact current codebase if you used labels but provided tuples without labels like the example above. The migrator could solve this by providing labels automatically to tuples where this error occurs.<br>&gt; <br>&gt; I&#39;m not good at writing proposals for the GitHub repository at all, so if the community likes this idea, I&#39;d be glad to see some help for this little proposal.<br>&gt; <br>&gt; -- <br>&gt; Adrian Zubarev<br>&gt; Sent with Airmail<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/2677ab5f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 20, 2016 at 04:00:00pm</p></header><div class="content"><p>On Apr 20, 2016, at 12:31 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; This is similar to another concern I raised with functions and being able to essentially erase the function argument names and apply two different named parameters just because their types match.<br>&gt; <br>&gt; It seems reasonable to me that you can go from (x: Int, y: Int) =&gt; (Int, Int). However, going from (x: Int, y: Int) =&gt; (a: Int, b: Int) feels somewhat odd. Yes, the types can obviously slot in there fine, but how much importance do the labels for the types bring to the table?<br>&gt; <br>&gt; Similarly, should this (Int, Int) =&gt; (x: Int, y: Int) be allowed through an implicit means? If so, then it&#39;s really just an intermediate step for (x: Int, y: Int) =&gt; (a: Int, b: Int) working.<br></p><p>I completely agree, I think it makes sense to convert from unlabeled to labeled (or back) but not from “labeled&quot; to &quot;differently labeled”.<br></p><p>&gt; So what matters more, type signatures or label names?<br>&gt; <br>&gt; Here&#39;s an example:<br>&gt; <br>&gt; typealias Functor = (left: Int, right: Int) -&gt; Int<br>&gt; <br>&gt; func hi(x: Int, y: Int, fn: Functor) -&gt; Int {<br>&gt;     return fn(left: x, right: y)<br>&gt; }<br>&gt; <br>&gt; hi(1, y: 2, fn: +)<br>&gt; hi(1, y: 2, fn: *)<br>&gt; <br>&gt; If we say that the parameter names are indeed vital, then the above code cannot work as the operators that match the type signature are defined as: <br>&gt; <br>&gt; public func +(lhs: Int, rhs: Int) -&gt; Int<br>&gt; <br>&gt; Obviously, given a name to the parameter brings clarity and can be self documenting, but if we want the above to work while making names just as vital as the type signature, then we need to declare `Functor` as such:<br>&gt; <br>&gt; typealias Functor = (_ left: Int, _ right: Int) -&gt; Int<br>&gt; <br>&gt; However, that&#39;s not even legal code today, and even if it were, is that really better?<br></p><p>I don’t think this follows, since operator parameters are always unlabeled.  I suspect we don’t reject it, but I’d be in favor of rejecting:<br></p><p>func +(lhs xyz: Int, rhs abc: Int) -&gt; Int { }<br></p><p>-Chris<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/abd66f6f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/012bc4c5e7b0c2829fff88611143c108?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>David Owens II</string> &lt;david at owensd.io&gt;<p>April 20, 2016 at 10:00:00pm</p></header><div class="content"><p>&gt; On Apr 20, 2016, at 4:47 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br>&gt; <br>&gt; On Apr 20, 2016, at 12:31 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; This is similar to another concern I raised with functions and being able to essentially erase the function argument names and apply two different named parameters just because their types match.<br>&gt;&gt; <br>&gt;&gt; It seems reasonable to me that you can go from (x: Int, y: Int) =&gt; (Int, Int). However, going from (x: Int, y: Int) =&gt; (a: Int, b: Int) feels somewhat odd. Yes, the types can obviously slot in there fine, but how much importance do the labels for the types bring to the table?<br>&gt;&gt; <br>&gt;&gt; Similarly, should this (Int, Int) =&gt; (x: Int, y: Int) be allowed through an implicit means? If so, then it&#39;s really just an intermediate step for (x: Int, y: Int) =&gt; (a: Int, b: Int) working.<br>&gt; <br>&gt; I completely agree, I think it makes sense to convert from unlabeled to labeled (or back) but not from “labeled&quot; to &quot;differently labeled”.<br>&gt; <br>&gt;&gt; So what matters more, type signatures or label names?<br>&gt;&gt; <br>&gt;&gt; Here&#39;s an example:<br>&gt;&gt; <br>&gt;&gt; typealias Functor = (left: Int, right: Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; func hi(x: Int, y: Int, fn: Functor) -&gt; Int {<br>&gt;&gt;     return fn(left: x, right: y)<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; hi(1, y: 2, fn: +)<br>&gt;&gt; hi(1, y: 2, fn: *)<br>&gt;&gt; <br>&gt;&gt; If we say that the parameter names are indeed vital, then the above code cannot work as the operators that match the type signature are defined as: <br>&gt;&gt; <br>&gt;&gt; public func +(lhs: Int, rhs: Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; Obviously, given a name to the parameter brings clarity and can be self documenting, but if we want the above to work while making names just as vital as the type signature, then we need to declare `Functor` as such:<br>&gt;&gt; <br>&gt;&gt; typealias Functor = (_ left: Int, _ right: Int) -&gt; Int<br>&gt;&gt; <br>&gt;&gt; However, that&#39;s not even legal code today, and even if it were, is that really better?<br>&gt; <br>&gt; I don’t think this follows, since operator parameters are always unlabeled.  I suspect we don’t reject it, but I’d be in favor of rejecting:<br>&gt; <br>&gt; func +(lhs xyz: Int, rhs abc: Int) -&gt; Int { }<br></p><p>So maybe I think about this incorrectly, but I always think of any parameter without an explicit label to have one that is equal to the parameter name. So these two functions signatures would be equivalent:<br></p><p>func sum1(lhs: Int, rhs: Int) -&gt; Int<br>func sum2(lhs lhs: Int, rhs rhs: Int) -&gt; Int<br></p><p>It’s only when you explicit “erase” the label where there is none:<br></p><p>func sum(_ lhs: Int, _ rhs: Int) -&gt; Int<br></p><p>So back to the example above, it’s still somewhat odd that all of these are valid:<br></p><p>hi(1, y: 2, fn: sum1)<br>hi(1, y: 2, fn: sum2)<br>hi(1, y: 2, fn: sum)   // makes the most sense, no label to labeled promotion<br></p><p>But if we did reject the differently labeled version, that would mean that we would need to declare the `Functor` above as:<br></p><p>typealias Functor = (Int, Int) -&gt; Int<br></p><p>Is that better? I’m not terribly convinced that it is.<br></p><p>If `Functor` keeps the labels, I suspect it would just lead to additional boiler-plate code that would look like:<br></p><p>typealias Functor = (left: Int, right: Int) -&gt; Int<br></p><p>hi(1, y: 2, fn: { left, right in sum1(lhs: left, rhs: right) })<br></p><p>While it does seem technically correct, is that really the kind of code we want in Swift? <br></p><p>-David<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160420/1d137a4e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0d4fb9162c777a5d6d0b1fb00893d709?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Haravikk</string> &lt;swift-evolution at haravikk.me&gt;<p>April 21, 2016 at 08:00:00am</p></header><div class="content"><p>I think the important thing to remember is that the label check is intended to prevent cases like this:<br></p><p>	let a:(left:Int, right:Int) = (1, 2)<br>	var b:(right:Int, left:Int) = a<br></p><p>While the two tuples are compatible by type, the meaning of the values may differ due to the different labels; in this case the values are represented in a different order that a developer should have to explicitly reverse to ensure they aren’t making a mistake, or they could represent radically different concepts altogether.<br></p><p>It’s certainly annoying when the labels are only different due to minor differences, but the compiler doesn’t know that. So yeah, I think that in any case where there are external labels that differ a warning should be raised; this comes down to being able to later ignore types of warnings, which could avoid the boiler-plate in future.<br></p><p>The alternative would be if we had some syntax for mapping parameters more cleanly, for example:<br></p><p>	hi(1, y: 2, fn: sum1 where left = lhs, right = rhs)<br></p><p>Or something along those lines anyway?<br></p><p>&gt; On 21 Apr 2016, at 06:18, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; <br>&gt;&gt; On Apr 20, 2016, at 4:47 PM, Chris Lattner &lt;clattner at apple.com &lt;mailto:clattner at apple.com&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; On Apr 20, 2016, at 12:31 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt;&gt; This is similar to another concern I raised with functions and being able to essentially erase the function argument names and apply two different named parameters just because their types match.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; It seems reasonable to me that you can go from (x: Int, y: Int) =&gt; (Int, Int). However, going from (x: Int, y: Int) =&gt; (a: Int, b: Int) feels somewhat odd. Yes, the types can obviously slot in there fine, but how much importance do the labels for the types bring to the table?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Similarly, should this (Int, Int) =&gt; (x: Int, y: Int) be allowed through an implicit means? If so, then it&#39;s really just an intermediate step for (x: Int, y: Int) =&gt; (a: Int, b: Int) working.<br>&gt;&gt; <br>&gt;&gt; I completely agree, I think it makes sense to convert from unlabeled to labeled (or back) but not from “labeled&quot; to &quot;differently labeled”.<br>&gt;&gt; <br>&gt;&gt;&gt; So what matters more, type signatures or label names?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Here&#39;s an example:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Functor = (left: Int, right: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; func hi(x: Int, y: Int, fn: Functor) -&gt; Int {<br>&gt;&gt;&gt;     return fn(left: x, right: y)<br>&gt;&gt;&gt; }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; hi(1, y: 2, fn: +)<br>&gt;&gt;&gt; hi(1, y: 2, fn: *)<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; If we say that the parameter names are indeed vital, then the above code cannot work as the operators that match the type signature are defined as: <br>&gt;&gt;&gt; <br>&gt;&gt;&gt; public func +(lhs: Int, rhs: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Obviously, given a name to the parameter brings clarity and can be self documenting, but if we want the above to work while making names just as vital as the type signature, then we need to declare `Functor` as such:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Functor = (_ left: Int, _ right: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, that&#39;s not even legal code today, and even if it were, is that really better?<br>&gt;&gt; <br>&gt;&gt; I don’t think this follows, since operator parameters are always unlabeled.  I suspect we don’t reject it, but I’d be in favor of rejecting:<br>&gt;&gt; <br>&gt;&gt; func +(lhs xyz: Int, rhs abc: Int) -&gt; Int { }<br>&gt; <br>&gt; So maybe I think about this incorrectly, but I always think of any parameter without an explicit label to have one that is equal to the parameter name. So these two functions signatures would be equivalent:<br>&gt; <br>&gt; func sum1(lhs: Int, rhs: Int) -&gt; Int<br>&gt; func sum2(lhs lhs: Int, rhs rhs: Int) -&gt; Int<br>&gt; <br>&gt; It’s only when you explicit “erase” the label where there is none:<br>&gt; <br>&gt; func sum(_ lhs: Int, _ rhs: Int) -&gt; Int<br>&gt; <br>&gt; So back to the example above, it’s still somewhat odd that all of these are valid:<br>&gt; <br>&gt; hi(1, y: 2, fn: sum1)<br>&gt; hi(1, y: 2, fn: sum2)<br>&gt; hi(1, y: 2, fn: sum)   // makes the most sense, no label to labeled promotion<br>&gt; <br>&gt; But if we did reject the differently labeled version, that would mean that we would need to declare the `Functor` above as:<br>&gt; <br>&gt; typealias Functor = (Int, Int) -&gt; Int<br>&gt; <br>&gt; Is that better? I’m not terribly convinced that it is.<br>&gt; <br>&gt; If `Functor` keeps the labels, I suspect it would just lead to additional boiler-plate code that would look like:<br>&gt; <br>&gt; typealias Functor = (left: Int, right: Int) -&gt; Int<br>&gt; <br>&gt; hi(1, y: 2, fn: { left, right in sum1(lhs: left, rhs: right) })<br>&gt; <br>&gt; While it does seem technically correct, is that really the kind of code we want in Swift? <br>&gt; <br>&gt; -David<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/145eef06/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cce5c4aaa87dd6df9c22ede21d5d1ed6?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Adrian Zubarev</string> &lt;adrian.zubarev at devandartist.com&gt;<p>April 21, 2016 at 11:00:00am</p></header><div class="content"><p>Personally I&#39;m fine with the way it is right now, but I do miss enforced labels at some point. At least it would be &#39;nice to have&#39; feature like we already have @autoclosure or @noescape to enforce some specific behaviour.<br></p><p>I started the discussion about enforcing argument labels on tuples but with your feedback I totally see the point why this shouldn’t be something backed inside the language by default.<br></p><p>Optional way to enforce the usage of correct/strict/explicit labels could provide better readability from my point of view.<br></p><p>Remember the idea of cascading methods/initializer? For class types it’s almost possible to build that feature by yourself, but there is one problem that was discussed back then. What do we use inside the trailing closure to access the instance. <br>Sure we could give it a custom name or just use `$0`.<br></p><p>```swift<br>let instance = ClassA() {<br></p><p>      // customName in<br>      // or $0<br>}<br></p><p>// imagine we had something optional like<br>class ClassB {<br></p><p>      @require_explicit_label_usage<br>      init(closure: (this: ClassB) -&gt; Void) {<br></p><p>            closure(this: self)<br>      }<br>      func foo() {}<br>}<br></p><p>// now we could use it like<br></p><p>let b = ClassB() { this in // can be omitted due the use of @require_explicit_label_usage<br></p><p>       this.foo()<br>}<br></p><p>// I&#39;ll use ++ operator just for the example here<br></p><p>@require_explicit_label_usage<br>prefix func ++ (tuple: (exp: Int, earned: Int)) -&gt; Int {<br></p><p>     return tuple.apples + tuple.amount<br>}<br></p><p>// this operator will only overload when the right labeling is applied to the tuple<br></p><p>++(exp: 10, earned: 5) // result would be 15<br></p><p>// the operator wont work with<br>++(100, 50)<br>// give another dev this snippet and ask him what 100 and 50 means<br></p><p>```<br>This example is very abstract but I&#39;m sure you should get the point of the possible need of an optional label enforcement.<br></p><p>By the way, why does Swift allow something like this anyway?<br></p><p>var a = (a: 10) // is of type Int<br></p><p>Where something like the next example is not allowed at all:<br></p><p>var a: (a: Int) = (a: 10)<br></p><p><br>-- <br>Adrian Zubarev<br></p><p>Am 21. April 2016 bei 09:14:16, Haravikk via swift-evolution (swift-evolution at swift.org) schrieb:<br></p><p>I think the important thing to remember is that the label check is intended to prevent cases like this:<br></p><p>let a:(left:Int, right:Int) = (1, 2)<br>var b:(right:Int, left:Int) = a<br></p><p>While the two tuples are compatible by type, the meaning of the values may differ due to the different labels; in this case the values are represented in a different order that a developer should have to explicitly reverse to ensure they aren’t making a mistake, or they could represent radically different concepts altogether.<br></p><p>It’s certainly annoying when the labels are only different due to minor differences, but the compiler doesn’t know that. So yeah, I think that in any case where there are external labels that differ a warning should be raised; this comes down to being able to later ignore types of warnings, which could avoid the boiler-plate in future.<br></p><p>The alternative would be if we had some syntax for mapping parameters more cleanly, for example:<br></p><p>hi(1, y: 2, fn: sum1 where left = lhs, right = rhs)<br></p><p>Or something along those lines anyway?<br></p><p>On 21 Apr 2016, at 06:18, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p><br>On Apr 20, 2016, at 4:47 PM, Chris Lattner &lt;clattner at apple.com&gt; wrote:<br></p><p>On Apr 20, 2016, at 12:31 PM, David Owens II via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>This is similar to another concern I raised with functions and being able to essentially erase the function argument names and apply two different named parameters just because their types match.<br></p><p>It seems reasonable to me that you can go from (x: Int, y: Int) =&gt; (Int, Int). However, going from (x: Int, y: Int) =&gt; (a: Int, b: Int) feels somewhat odd. Yes, the types can obviously slot in there fine, but how much importance do the labels for the types bring to the table?<br></p><p>Similarly, should this (Int, Int) =&gt; (x: Int, y: Int) be allowed through an implicit means? If so, then it&#39;s really just an intermediate step for (x: Int, y: Int) =&gt; (a: Int, b: Int) working.<br></p><p>I completely agree, I think it makes sense to convert from unlabeled to labeled (or back) but not from “labeled&quot; to &quot;differently labeled”.<br></p><p>So what matters more, type signatures or label names?<br></p><p>Here&#39;s an example:<br></p><p>typealias Functor = (left: Int, right: Int) -&gt; Int<br></p><p>func hi(x: Int, y: Int, fn: Functor) -&gt; Int {<br>    return fn(left: x, right: y)<br>}<br></p><p>hi(1, y: 2, fn: +)<br>hi(1, y: 2, fn: *)<br></p><p>If we say that the parameter names are indeed vital, then the above code cannot work as the operators that match the type signature are defined as: <br></p><p>public func +(lhs: Int, rhs: Int) -&gt; Int<br></p><p>Obviously, given a name to the parameter brings clarity and can be self documenting, but if we want the above to work while making names just as vital as the type signature, then we need to declare `Functor` as such:<br></p><p>typealias Functor = (_ left: Int, _ right: Int) -&gt; Int<br></p><p>However, that&#39;s not even legal code today, and even if it were, is that really better?<br></p><p>I don’t think this follows, since operator parameters are always unlabeled.  I suspect we don’t reject it, but I’d be in favor of rejecting:<br></p><p>func +(lhs xyz: Int, rhs abc: Int) -&gt; Int { }<br></p><p>So maybe I think about this incorrectly, but I always think of any parameter without an explicit label to have one that is equal to the parameter name. So these two functions signatures would be equivalent:<br></p><p>func sum1(lhs: Int, rhs: Int) -&gt; Int<br>func sum2(lhs lhs: Int, rhs rhs: Int) -&gt; Int<br></p><p>It’s only when you explicit “erase” the label where there is none:<br></p><p>func sum(_ lhs: Int, _ rhs: Int) -&gt; Int<br></p><p>So back to the example above, it’s still somewhat odd that all of these are valid:<br></p><p>hi(1, y: 2, fn: sum1)<br>hi(1, y: 2, fn: sum2)<br>hi(1, y: 2, fn: sum)   // makes the most sense, no label to labeled promotion<br></p><p>But if we did reject the differently labeled version, that would mean that we would need to declare the `Functor` above as:<br></p><p>typealias Functor = (Int, Int) -&gt; Int<br></p><p>Is that better? I’m not terribly convinced that it is.<br></p><p>If `Functor` keeps the labels, I suspect it would just lead to additional boiler-plate code that would look like:<br></p><p>typealias Functor = (left: Int, right: Int) -&gt; Int<br></p><p>hi(1, y: 2, fn: { left, right in sum1(lhs: left, rhs: right) })<br></p><p>While it does seem technically correct, is that really the kind of code we want in Swift? <br></p><p>-David<br>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160421/f925ebc3/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>[Discussion] Enforce argument labels on tuples</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>April 24, 2016 at 02:00:00pm</p></header><div class="content"><p>On Apr 20, 2016, at 10:18 PM, David Owens II &lt;david at owensd.io&gt; wrote:<br>&gt;&gt;&gt; Obviously, given a name to the parameter brings clarity and can be self documenting, but if we want the above to work while making names just as vital as the type signature, then we need to declare `Functor` as such:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; typealias Functor = (_ left: Int, _ right: Int) -&gt; Int<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; However, that&#39;s not even legal code today, and even if it were, is that really better?<br>&gt;&gt; <br>&gt;&gt; I don’t think this follows, since operator parameters are always unlabeled.  I suspect we don’t reject it, but I’d be in favor of rejecting:<br>&gt;&gt; <br>&gt;&gt; func +(lhs xyz: Int, rhs abc: Int) -&gt; Int { }<br>&gt; <br>&gt; So maybe I think about this incorrectly, but I always think of any parameter without an explicit label to have one that is equal to the parameter name.<br></p><p>We’re going in that direction, but that is not currently the case for operators and subscript indices.  As a community, we don’t have much real-world experience using Swift 3, but I don’t expect that either of those cases would get better by requiring labels by default and requiring _ to suppress them.<br></p><p>&gt; So these two functions signatures would be equivalent:<br>&gt; <br>&gt; func sum1(lhs: Int, rhs: Int) -&gt; Int<br>&gt; func sum2(lhs lhs: Int, rhs rhs: Int) -&gt; Int<br>&gt; <br>&gt; It’s only when you explicit “erase” the label where there is none:<br>&gt; <br>&gt; func sum(_ lhs: Int, _ rhs: Int) -&gt; Int<br>&gt; <br>&gt; So back to the example above, it’s still somewhat odd that all of these are valid:<br>&gt; <br>&gt; hi(1, y: 2, fn: sum1)<br>&gt; hi(1, y: 2, fn: sum2)<br>&gt; hi(1, y: 2, fn: sum)   // makes the most sense, no label to labeled promotion<br>&gt; <br>&gt; But if we did reject the differently labeled version, that would mean that we would need to declare the `Functor` above as:<br>&gt; <br>&gt; typealias Functor = (Int, Int) -&gt; Int<br></p><p>I agree that eliminating relabeling would force this. <br></p><p>&gt; Is that better? I’m not terribly convinced that it is.<br></p><p>Me neither.<br></p><p>Off in crazy space for a bit, but one could argue that this style of design would imply that you should be able to call this example like this:<br></p><p>&gt; hi(1, y: 2, fn: { sum1(lhs: $left, rhs: $right) })<br></p><p>since the only sensible names for the parameters come from context.<br></p><p>-Chris<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160424/076fbcb2/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
