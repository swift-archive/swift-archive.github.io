<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>May 28, 2016 at 07:00:00pm</p></header><div class="content"><p>Hello.<br></p><p><br>This is the first draft. I&#39;d like to know your opinion about it.<br></p><p>(I know that this subject could have been discussed before. If so, please<br>indicate me the correct thread to follow and interact.)<br></p><p><br>Regards,<br></p><p>Vanderlei Martinelli<br></p><p><br>---<br></p><p><br>Introduction<br></p><p>Protected access level will enable entities to be used within the container<br>type and by derived types only.<br>Motivation<br></p><p>Today Swift has three access levels (public, internal and private), but<br>lacks a way to describe a member that can be only visible to its type or<br>derived types.<br></p><p>A common case is the UIView from UIKit. Many developers are tempted to make<br>this call:<br></p><p>view.layoutSubviews()<br></p><p>The documentation says: &quot;You should not call this method directly. If you<br>want to force a layout update, call the setNeedsLayoutmethod instead to do<br>so prior to the next drawing update. If you want to update the layout of<br>your views immediately, call the layoutIfNeeded method.&quot;<br></p><p>But yes, you should call this method directly if you are subclassing the<br>view and needs to perform additional layout to its subviews (&quot;subclasses<br>can override this method as needed&quot;):<br></p><p>public override func layoutSubviews() {<br>    // We are calling the super method directly here.<br>    super.layoutSubviews()<br></p><p>    // Do more adjustments to this view&#39;s subviews...}<br></p><p>So, yes, we can call this method directly when subclassing, but the Swift<br>compiler will not prevent you from do this when not subclassing or from any<br>other foreign class. It will not even issue a warning.<br></p><p>In Objective-C problems like this are usually &quot;solved&quot; my adding a kind of<br>&quot;protected&quot; header (.h) that is intended to be included only when the<br>developer is subclassing. In Swift we do not have headers, but we have the<br>new access level model. So, if the declaration of this method was...<br></p><p>protected func layoutSubviews()<br></p><p>... no one outside the class or derived classes would be allowed to call<br>this method directly.<br></p><p>Of course, there are other cases in the Cocoa frameworks and there are many<br>other cases when we are developing software in Swift that the protected access<br>level would be very usefull.<br>Proposed solution<br></p><p>Create the protected access level.<br>Detailed designReference Types (classes)<br></p><p>When declarated by a class the protected member will be visible to the<br>class itself and all the derived classes.<br></p><p>// BaseClass.swiftpublic class BaseClass {<br>    public protected(set) var x = 20<br>    protected let y = 10<br></p><p>    protected func doSomething() {<br>        // ...<br>    }}<br>// DerivedClass.swiftpublic class DerivedClass: BaseClass {<br>    protected override doSomething() {<br>        self.x = 10 * self.y<br>    }}<br></p><p>If the member is declared as final then it will be visible but not can be<br>overrided by the derived classes. Just like it works with other access<br>levels.<br>Value Types (structs, enums, etc.)<br></p><p>Value types cannot have derived types. In this case the protected access<br>level does not make sense and will not be allowed in their members.<br>Protocols<br></p><p>Protocols do not declare access level for their members. So the<br>protected access<br>level is not applicable here.<br>Extensions<br></p><p>Extensions will not be able do be protected nor their members.<br>Special Note<br></p><p>The protected access level can only be applied to classes, structs and<br>other types when nested inside other type. So the following code will not<br>compile:<br></p><p>// ERROR: A first level class cannot be protected.<br>protected class MyProtectedClass {<br>    /// ...}<br></p><p>But nested declarations will be allowed, so this code will compile:<br></p><p>// We can declare a protected class (or struct, enum, etc.) if// and<br>only if they are nested inside other type.public class MyPublicClass {<br>    protected class MyProtectedClass {<br>        /// ...<br>    }}<br>// Since `MyProtectedClass` is nested and protected we// can have<br>access to it here.public class MyDerivedClass: MyPublicClass {<br>    public func doSomething() {<br>        let c = MyProtectedClass()<br></p><p>        /// ...<br>    }}<br></p><p>Impact on existing code<br></p><p>The imported Cocoa frameworks may have annotations on the &quot;Objective-C<br>side&quot; that will inform if one member is protected. If this will be case<br>(for the layoutSubviews method, as example), only code accessing these now<br>protected members outside the owner class and its derived classes will have<br>to change (currently this can be considered an error, anyway).<br></p><p>Any other code will be not impacted by this feature as it is new to the<br>language.<br>Alternatives considered<br></p><p>Do not add the protected access level to the current model.<br></p><p><br>---<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/10afdc4f/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/60dcb74d816e29b2aa6b9c0b5969670e?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Xiaodi Wu</string> &lt;xiaodi.wu at gmail.com&gt;<p>May 28, 2016 at 11:00:00pm</p></header><div class="content"><p>Seems entirely reasonable to me. POP aficionados may object, but I think<br>the pros and cons of this type of access are well trodden terrain and I<br>think it&#39;s a net win to have this available in Swift going forward.<br>On Sat, May 28, 2016 at 18:53 Vanderlei Martinelli via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Hello.<br>&gt;<br>&gt;<br>&gt; This is the first draft. I&#39;d like to know your opinion about it.<br>&gt;<br>&gt; (I know that this subject could have been discussed before. If so, please<br>&gt; indicate me the correct thread to follow and interact.)<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Vanderlei Martinelli<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Protected access level will enable entities to be used within the<br>&gt; container type and by derived types only.<br>&gt; Motivation<br>&gt;<br>&gt; Today Swift has three access levels (public, internal and private), but<br>&gt; lacks a way to describe a member that can be only visible to its type or<br>&gt; derived types.<br>&gt;<br>&gt; A common case is the UIView from UIKit. Many developers are tempted to<br>&gt; make this call:<br>&gt;<br>&gt; view.layoutSubviews()<br>&gt;<br>&gt; The documentation says: &quot;You should not call this method directly. If you<br>&gt; want to force a layout update, call the setNeedsLayoutmethod instead to<br>&gt; do so prior to the next drawing update. If you want to update the layout of<br>&gt; your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;<br>&gt; But yes, you should call this method directly if you are subclassing the<br>&gt; view and needs to perform additional layout to its subviews (&quot;subclasses<br>&gt; can override this method as needed&quot;):<br>&gt;<br>&gt; public override func layoutSubviews() {<br>&gt;     // We are calling the super method directly here.<br>&gt;     super.layoutSubviews()<br>&gt;<br>&gt;     // Do more adjustments to this view&#39;s subviews...}<br>&gt;<br>&gt; So, yes, we can call this method directly when subclassing, but the Swift<br>&gt; compiler will not prevent you from do this when not subclassing or from any<br>&gt; other foreign class. It will not even issue a warning.<br>&gt;<br>&gt; In Objective-C problems like this are usually &quot;solved&quot; my adding a kind of<br>&gt; &quot;protected&quot; header (.h) that is intended to be included only when the<br>&gt; developer is subclassing. In Swift we do not have headers, but we have the<br>&gt; new access level model. So, if the declaration of this method was...<br>&gt;<br>&gt; protected func layoutSubviews()<br>&gt;<br>&gt; ... no one outside the class or derived classes would be allowed to call<br>&gt; this method directly.<br>&gt;<br>&gt; Of course, there are other cases in the Cocoa frameworks and there are<br>&gt; many other cases when we are developing software in Swift that the<br>&gt; protected access level would be very usefull.<br>&gt; Proposed solution<br>&gt;<br>&gt; Create the protected access level.<br>&gt; Detailed designReference Types (classes)<br>&gt;<br>&gt; When declarated by a class the protected member will be visible to the<br>&gt; class itself and all the derived classes.<br>&gt;<br>&gt; // BaseClass.swiftpublic class BaseClass {<br>&gt;     public protected(set) var x = 20<br>&gt;     protected let y = 10<br>&gt;<br>&gt;     protected func doSomething() {<br>&gt;         // ...<br>&gt;     }}<br>&gt; // DerivedClass.swiftpublic class DerivedClass: BaseClass {<br>&gt;     protected override doSomething() {<br>&gt;         self.x = 10 * self.y<br>&gt;     }}<br>&gt;<br>&gt; If the member is declared as final then it will be visible but not can be<br>&gt; overrided by the derived classes. Just like it works with other access<br>&gt; levels.<br>&gt; Value Types (structs, enums, etc.)<br>&gt;<br>&gt; Value types cannot have derived types. In this case the protected access<br>&gt; level does not make sense and will not be allowed in their members.<br>&gt; Protocols<br>&gt;<br>&gt; Protocols do not declare access level for their members. So the protected access<br>&gt; level is not applicable here.<br>&gt; Extensions<br>&gt;<br>&gt; Extensions will not be able do be protected nor their members.<br>&gt; Special Note<br>&gt;<br>&gt; The protected access level can only be applied to classes, structs and<br>&gt; other types when nested inside other type. So the following code will not<br>&gt; compile:<br>&gt;<br>&gt; // ERROR: A first level class cannot be protected.<br>&gt; protected class MyProtectedClass {<br>&gt;     /// ...}<br>&gt;<br>&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;<br>&gt; // We can declare a protected class (or struct, enum, etc.) if// and only if they are nested inside other type.public class MyPublicClass {<br>&gt;     protected class MyProtectedClass {<br>&gt;         /// ...<br>&gt;     }}<br>&gt; // Since `MyProtectedClass` is nested and protected we// can have access to it here.public class MyDerivedClass: MyPublicClass {<br>&gt;     public func doSomething() {<br>&gt;         let c = MyProtectedClass()<br>&gt;<br>&gt;         /// ...<br>&gt;     }}<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; The imported Cocoa frameworks may have annotations on the &quot;Objective-C<br>&gt; side&quot; that will inform if one member is protected. If this will be case<br>&gt; (for the layoutSubviews method, as example), only code accessing these<br>&gt; now protected members outside the owner class and its derived classes will<br>&gt; have to change (currently this can be considered an error, anyway).<br>&gt;<br>&gt; Any other code will be not impacted by this feature as it is new to the<br>&gt; language.<br>&gt; Alternatives considered<br>&gt;<br>&gt; Do not add the protected access level to the current model.<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/80b408c4/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 28, 2016 at 08:00:00pm</p></header><div class="content"><p>If we&#39;re to introduce the protected visibility, I think we should as well make it automatically internal or introduce an explicit protected internal visibility. I&#39;ve been through many cases while programming in C# &#39;where&#39; this was handy (thou I cannot name one from memory right now; it&#39;s been so many years ago...)<br></p><p><br></p><p>-----Original Message-----<br>From: &quot;Xiaodi Wu via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎28/‎05/‎2016 08:10 PM<br>To: &quot;Vanderlei Martinelli&quot; &lt;vmartinelli at alecrim.com&gt;; &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br></p><p>Seems entirely reasonable to me. POP aficionados may object, but I think the pros and cons of this type of access are well trodden terrain and I think it&#39;s a net win to have this available in Swift going forward.<br></p><p>On Sat, May 28, 2016 at 18:53 Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>Hello.<br></p><p><br></p><p><br>This is the first draft. I&#39;d like to know your opinion about it.<br></p><p><br>(I know that this subject could have been discussed before. If so, please indicate me the correct thread to follow and interact.)<br></p><p><br></p><p><br>Regards,<br></p><p><br>Vanderlei Martinelli<br></p><p><br></p><p><br>---<br></p><p><br></p><p><br>Introduction<br>Protected access level will enable entities to be used within the container type and by derived types only.<br>Motivation<br>Today Swift has three access levels (public, internal and private), but lacks a way to describe a member that can be only visible to its type or derived types.<br>A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>view.layoutSubviews()The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>But yes, you should call this method directly if you are subclassing the view and needs to perform additional layout to its subviews (&quot;subclasses can override this method as needed&quot;):<br>public override func layoutSubviews() {<br>    // We are calling the super method directly here.<br>    super.layoutSubviews()<br>    <br>    // Do more adjustments to this view&#39;s subviews...<br>}So, yes, we can call this method directly when subclassing, but the Swift compiler will not prevent you from do this when not subclassing or from any other foreign class. It will not even issue a warning.<br>In Objective-C problems like this are usually &quot;solved&quot; my adding a kind of &quot;protected&quot; header (.h) that is intended to be included only when the developer is subclassing. In Swift we do not have headers, but we have the new access level model. So, if the declaration of this method was...<br>protected func layoutSubviews()... no one outside the class or derived classes would be allowed to call this method directly.<br>Of course, there are other cases in the Cocoa frameworks and there are many other cases when we are developing software in Swift that the protected access level would be very usefull.<br>Proposed solution<br>Create the protected access level.<br>Detailed design<br>Reference Types (classes)<br>When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>// BaseClass.swift<br>public class BaseClass {<br>    public protected(set) var x = 20<br>    protected let y = 10<br>    <br>    protected func doSomething() {<br>        // ...<br>    }<br>}<br></p><p>// DerivedClass.swift<br>public class DerivedClass: BaseClass {<br>    protected override doSomething() {<br>        self.x = 10 * self.y<br>    }<br>}If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>Value Types (structs, enums, etc.)<br>Value types cannot have derived types. In this case the protected access level does not make sense and will not be allowed in their members.<br>Protocols<br>Protocols do not declare access level for their members. So the protected access level is not applicable here.<br>Extensions<br>Extensions will not be able do be protected nor their members.<br>Special Note<br>The protected access level can only be applied to classes, structs and other types when nested inside other type. So the following code will not compile:<br>&lt;code style=&quot;margin:0px;padding:0px;border:none;border-top-left-radius:3px;border-top-right-radius:3px;border-bottom-right-radius:3px;border-bottom-left-radius:3px;background-image:none;font-family:Consolas,Monaco,&amp;#39;Andale Mono<br></p><p>[The entire original message is not included.]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160528/28a91b87/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 28, 2016 at 06:00:00pm</p></header><div class="content"><p>To begin with, I&#39;m not a fan of `protected` access. But even leaving that aside, I have a few questions and critiques.<br></p><p>&gt; A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>&gt; <br>&gt; view.layoutSubviews()<br>&gt; The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br></p><p>This example is illuminating in several ways.<br></p><p>* The rule is not simply that &quot;only the class should call `layoutSubviews()`&quot;; it is effectively &quot;*you* should never call `layoutSubviews()` except when `super`ing up from your override&quot;. Calling `layoutSubviews()` from `insertRows(at:)` is just as much a mistake if `insertRows(at:)` is part of the class as if it is not. So isn&#39;t `protected` insufficiently strict to properly serve this use case?<br></p><p>* At the same time, something outside `layoutSubviews()` has to be able to call `layoutSubviews()`. In the case of UIKit, though, that &quot;something&quot; is always within UIKit itself, never outside it. So should `protected` have a &quot;bottom&quot;, a level below which calls are unrestricted? For instance, in UIKit&#39;s case you might have `protected fileprivate`, meaning &quot;anything up to `fileprivate` has unrestricted use; anything above that can override and `super` up from its override, but not use it any other way&quot;.<br></p><p>	protected fileprivate func layoutSubviews()<br></p><p>* `layoutSubviews()` is also something you should probably always `super` up to. Have you considered addressing `super` requirements at all?<br></p><p>In short, is a traditional `protected` really the feature you want to handle this use case, or would a very different design actually suit it a lot better?<br></p><p>&gt; When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br></p><p>In what scope? The same as the class?<br></p><p>Is there not room for, for instance, &quot;usable without restriction in this file, override-only in the rest of this module, invisible outside it&quot;? For instance, `internal(protected) fileprivate`, or perhaps `internal(override) fileprivate`? `layoutSubviews()` might then be `public(override) fileprivate`—the ability to override is public, the ability to use it unrestricted is filewide.<br></p><p>	public(override) fileprivate func layoutSubviews()<br>	internal(override) fileprivate func privateSubclassingHook()<br></p><p>&gt; public protected(set) var x = 20<br></p><p>Of course, that might be difficult to combine with the `(set)` syntax. `public(set: override)`, maybe? With, for instance, `public internal(set: override) private(set)` if you want the property&#39;s getter public and its setter overridable internally and callable in private scope.<br></p><p>	public(override) fileprivate func layoutSubviews()<br>	internal(override) fileprivate func privateSubclassingHook()<br>	public(get, set: override) internal(set) var x = 20<br></p><p>But there&#39;s something about this that&#39;s starting to seem a little rotten. I think the problem is that we&#39;re not really trying to widen the ability to override, we&#39;re trying to restrict the ability to call. Let&#39;s try restructuring along those lines:<br></p><p>	public fileprivate(call) func layoutSubviews()<br>	internal fileprivate(call) func privateSubclassingHook()<br>	public internal(set: call) var x = 20<br></p><p>That seems much cleaner to me.<br></p><p>&gt; If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br></p><p>With the &quot;overridable but otherwise unusable&quot; conception I&#39;m suggesting, this would not be the case, of course.<br></p><p>&gt; Protocols<br>&gt; <br>&gt; Protocols do not declare access level for their members. So the protected access level is not applicable here.<br></p><p>But `protected` is quite different from other access levels; it does not limit the visibility of the symbols, but rather their use. And protocols face the same sort of problem as classes, where certain members are essentially override hooks and shouldn&#39;t be called directly outside a particular scope.<br></p><p>So I think we ought to allow `accesslevel(call)`, but not a plain `accesslevel`:<br></p><p>	public fileprivate(call) func layoutSubviews()<br>	internal fileprivate(call) func privateSubclassingHook()<br>	public internal(set: call) var x = 20<br>	internal(call) func protocolConformanceHook()<br>	fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br></p><p>&gt; Extensions<br>&gt; <br>&gt; Extensions will not be able do be protected nor their members.<br></p><p>This is very vague. There are several things extensions might try to do with protected members:<br></p><p>* Declare new ones<br>* Override existing ones<br>* Call existing ones<br></p><p>Which of these, if any, are permitted? Why?<br></p><p>In my conception, I would permit extensions to behave as the type they extended did. Extensions could declare new members with restricted calling and override existing ones. They would not be able to call, except when supering from an override, unless they were within scope of the `call` access control. In other words, they&#39;d behave just like any other code at that location. That&#39;s how we want extensions to work.<br></p><p>&gt; But nested declarations will be allowed, so this code will compile:<br>&gt; <br>&gt; // We can declare a protected class (or struct, enum, etc.) if<br>&gt; // and only if they are nested inside other type.<br>&gt; public class MyPublicClass {<br>&gt;    protected <br>&gt; class MyProtectedClass {<br></p><p>What does it mean to &quot;use&quot; a protected class, though? Clearly you can call its methods, if only through AnyObject or a non-protected superclass or a protocol it conforms to. Does it mean you can&#39;t instantiate it? Does it mean you can&#39;t subclass it? Does it mean you can&#39;t call methods that aren&#39;t on its supertypes? All of the above? None?<br></p><p>One more thing that didn&#39;t come up: Testability. I believe that importing a module with `@testable` should disable its call restrictions, even ones inherited from outside that module. Thus, even if *you* cannot call your `layoutSubviews()`, your test suite can.<br></p><p>So, in short, my counter-proposal is:<br></p><p>	public fileprivate(call) func layoutSubviews()<br>	internal fileprivate(call) func privateSubclassingHook()<br>	public internal(set: call) var x = 20<br>	internal(call) func protocolConformanceHook()<br>	fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br></p><p>In other words:<br></p><p>* There is a new aspect of the member, `call`, which controls the ability to actually call the member, as opposed to overriding it. No `call`, no calling (except when `super`ing up from an override).<br></p><p>* `call` is used in combination with one of the existing access modifiers: `public(call)` `internal(call)` `fileprivate(call)` `private(call)`. `call`&#39;s visibility is always less or equal to the member itself.<br></p><p>* To control the callability of a setter independently from both the getter and the overridability of the setter, use `set: call`.<br></p><p>* Extensions behave just like type definitions at the same location with regards to `call`.<br></p><p>* Protocols can use access modifiers with `call` to prevent unauthorized code from calling a member. The access control level to implement a member continues to be as wide as the access control level of the protocol itself.<br></p><p>* `@testable` disables `call` restrictions on the types it imports, so the test suite can call any visible member, even ones inherited from other modules.<br></p><p>* There should probably also be some sort of &quot;super required&quot; warning/error, but this is an orthogonal feature and can be left for a separate proposal.<br></p><p>I think that feature will be closer to the one you actually *want*, as opposed to the one that other languages have cargo-culted from SIMULA-67.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/009173d589176cfd9c8146cc49849ff6?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Riley Testut</string> &lt;rileytestut at gmail.com&gt;<p>May 29, 2016 at 12:00:00am</p></header><div class="content"><p>Unless I&#39;m missing something Brent, your suggestions still wouldn&#39;t allow the developer to provide a public class in a module designed to be subclassed by clients in another module and access these &quot;private&quot; details, which is a real problem I&#39;m having in my current project.<br></p><p>I have a framework which provides an abstract model object designed to be subclassed (and yes it has to be a class and not a struct for a multitude of reasons 😛) by clients of the framework. There are several convenience methods + properties I have exposed for subclasses to use, but they should really be implementation details; a client using these model objects should not have to know about them. Even worse, several of the properties are mutable so the subclasses can modify them, but they certainly should *not* be modified by anything else.<br></p><p>Right now, I&#39;m limited to simply commenting something akin to &quot;DO NOT CALL&quot; next to these methods/properties, which definitely goes against Swift&#39;s safety focus. For these reasons, I&#39;m 100% in support of a protected access control modifier.<br></p><p>&gt; On May 28, 2016, at 8:11 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; To begin with, I&#39;m not a fan of `protected` access. But even leaving that aside, I have a few questions and critiques.<br>&gt; <br>&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>&gt;&gt; <br>&gt;&gt; view.layoutSubviews()<br>&gt;&gt; The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>&gt; <br>&gt; This example is illuminating in several ways.<br>&gt; <br>&gt; * The rule is not simply that &quot;only the class should call `layoutSubviews()`&quot;; it is effectively &quot;*you* should never call `layoutSubviews()` except when `super`ing up from your override&quot;. Calling `layoutSubviews()` from `insertRows(at:)` is just as much a mistake if `insertRows(at:)` is part of the class as if it is not. So isn&#39;t `protected` insufficiently strict to properly serve this use case?<br>&gt; <br>&gt; * At the same time, something outside `layoutSubviews()` has to be able to call `layoutSubviews()`. In the case of UIKit, though, that &quot;something&quot; is always within UIKit itself, never outside it. So should `protected` have a &quot;bottom&quot;, a level below which calls are unrestricted? For instance, in UIKit&#39;s case you might have `protected fileprivate`, meaning &quot;anything up to `fileprivate` has unrestricted use; anything above that can override and `super` up from its override, but not use it any other way&quot;.<br>&gt; <br>&gt;    protected fileprivate func layoutSubviews()<br>&gt; <br>&gt; * `layoutSubviews()` is also something you should probably always `super` up to. Have you considered addressing `super` requirements at all?<br>&gt; <br>&gt; In short, is a traditional `protected` really the feature you want to handle this use case, or would a very different design actually suit it a lot better?<br>&gt; <br>&gt;&gt; When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>&gt; <br>&gt; In what scope? The same as the class?<br>&gt; <br>&gt; Is there not room for, for instance, &quot;usable without restriction in this file, override-only in the rest of this module, invisible outside it&quot;? For instance, `internal(protected) fileprivate`, or perhaps `internal(override) fileprivate`? `layoutSubviews()` might then be `public(override) fileprivate`—the ability to override is public, the ability to use it unrestricted is filewide.<br>&gt; <br>&gt;    public(override) fileprivate func layoutSubviews()<br>&gt;    internal(override) fileprivate func privateSubclassingHook()<br>&gt; <br>&gt;&gt; public protected(set) var x = 20<br>&gt; <br>&gt; Of course, that might be difficult to combine with the `(set)` syntax. `public(set: override)`, maybe? With, for instance, `public internal(set: override) private(set)` if you want the property&#39;s getter public and its setter overridable internally and callable in private scope.<br>&gt; <br>&gt;    public(override) fileprivate func layoutSubviews()<br>&gt;    internal(override) fileprivate func privateSubclassingHook()<br>&gt;    public(get, set: override) internal(set) var x = 20<br>&gt; <br>&gt; But there&#39;s something about this that&#39;s starting to seem a little rotten. I think the problem is that we&#39;re not really trying to widen the ability to override, we&#39;re trying to restrict the ability to call. Let&#39;s try restructuring along those lines:<br>&gt; <br>&gt;    public fileprivate(call) func layoutSubviews()<br>&gt;    internal fileprivate(call) func privateSubclassingHook()<br>&gt;    public internal(set: call) var x = 20<br>&gt; <br>&gt; That seems much cleaner to me.<br>&gt; <br>&gt;&gt; If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>&gt; <br>&gt; With the &quot;overridable but otherwise unusable&quot; conception I&#39;m suggesting, this would not be the case, of course.<br>&gt; <br>&gt;&gt; Protocols<br>&gt;&gt; <br>&gt;&gt; Protocols do not declare access level for their members. So the protected access level is not applicable here.<br>&gt; <br>&gt; But `protected` is quite different from other access levels; it does not limit the visibility of the symbols, but rather their use. And protocols face the same sort of problem as classes, where certain members are essentially override hooks and shouldn&#39;t be called directly outside a particular scope.<br>&gt; <br>&gt; So I think we ought to allow `accesslevel(call)`, but not a plain `accesslevel`:<br>&gt; <br>&gt;    public fileprivate(call) func layoutSubviews()<br>&gt;    internal fileprivate(call) func privateSubclassingHook()<br>&gt;    public internal(set: call) var x = 20<br>&gt;    internal(call) func protocolConformanceHook()<br>&gt;    fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt; <br>&gt;&gt; Extensions<br>&gt;&gt; <br>&gt;&gt; Extensions will not be able do be protected nor their members.<br>&gt; <br>&gt; This is very vague. There are several things extensions might try to do with protected members:<br>&gt; <br>&gt; * Declare new ones<br>&gt; * Override existing ones<br>&gt; * Call existing ones<br>&gt; <br>&gt; Which of these, if any, are permitted? Why?<br>&gt; <br>&gt; In my conception, I would permit extensions to behave as the type they extended did. Extensions could declare new members with restricted calling and override existing ones. They would not be able to call, except when supering from an override, unless they were within scope of the `call` access control. In other words, they&#39;d behave just like any other code at that location. That&#39;s how we want extensions to work.<br>&gt; <br>&gt;&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;&gt; <br>&gt;&gt; // We can declare a protected class (or struct, enum, etc.) if<br>&gt;&gt; // and only if they are nested inside other type.<br>&gt;&gt; public class MyPublicClass {<br>&gt;&gt;   protected <br>&gt;&gt; class MyProtectedClass {<br>&gt; <br>&gt; What does it mean to &quot;use&quot; a protected class, though? Clearly you can call its methods, if only through AnyObject or a non-protected superclass or a protocol it conforms to. Does it mean you can&#39;t instantiate it? Does it mean you can&#39;t subclass it? Does it mean you can&#39;t call methods that aren&#39;t on its supertypes? All of the above? None?<br>&gt; <br>&gt; One more thing that didn&#39;t come up: Testability. I believe that importing a module with `@testable` should disable its call restrictions, even ones inherited from outside that module. Thus, even if *you* cannot call your `layoutSubviews()`, your test suite can.<br>&gt; <br>&gt; So, in short, my counter-proposal is:<br>&gt; <br>&gt;    public fileprivate(call) func layoutSubviews()<br>&gt;    internal fileprivate(call) func privateSubclassingHook()<br>&gt;    public internal(set: call) var x = 20<br>&gt;    internal(call) func protocolConformanceHook()<br>&gt;    fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt; <br>&gt; In other words:<br>&gt; <br>&gt; * There is a new aspect of the member, `call`, which controls the ability to actually call the member, as opposed to overriding it. No `call`, no calling (except when `super`ing up from an override).<br>&gt; <br>&gt; * `call` is used in combination with one of the existing access modifiers: `public(call)` `internal(call)` `fileprivate(call)` `private(call)`. `call`&#39;s visibility is always less or equal to the member itself.<br>&gt; <br>&gt; * To control the callability of a setter independently from both the getter and the overridability of the setter, use `set: call`.<br>&gt; <br>&gt; * Extensions behave just like type definitions at the same location with regards to `call`.<br>&gt; <br>&gt; * Protocols can use access modifiers with `call` to prevent unauthorized code from calling a member. The access control level to implement a member continues to be as wide as the access control level of the protocol itself.<br>&gt; <br>&gt; * `@testable` disables `call` restrictions on the types it imports, so the test suite can call any visible member, even ones inherited from other modules.<br>&gt; <br>&gt; * There should probably also be some sort of &quot;super required&quot; warning/error, but this is an orthogonal feature and can be left for a separate proposal.<br>&gt; <br>&gt; I think that feature will be closer to the one you actually *want*, as opposed to the one that other languages have cargo-culted from SIMULA-67.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>Ditto - I would love to be able to disallow non-subclasses accessing/modifying some variables.<br></p><p>Though, I&#39;m not sure what would be the stand on this from the core team - according to Apple&#39;s blog they&#39;ve already considered protected access level:<br></p><p>https://developer.apple.com/swift/blog/?id=11<br></p><p>Charlie<br></p><p><br>&gt; On May 29, 2016, at 7:56 AM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Unless I&#39;m missing something Brent, your suggestions still wouldn&#39;t allow the developer to provide a public class in a module designed to be subclassed by clients in another module and access these &quot;private&quot; details, which is a real problem I&#39;m having in my current project.<br>&gt; <br>&gt; I have a framework which provides an abstract model object designed to be subclassed (and yes it has to be a class and not a struct for a multitude of reasons 😛) by clients of the framework. There are several convenience methods + properties I have exposed for subclasses to use, but they should really be implementation details; a client using these model objects should not have to know about them. Even worse, several of the properties are mutable so the subclasses can modify them, but they certainly should *not* be modified by anything else.<br>&gt; <br>&gt; Right now, I&#39;m limited to simply commenting something akin to &quot;DO NOT CALL&quot; next to these methods/properties, which definitely goes against Swift&#39;s safety focus. For these reasons, I&#39;m 100% in support of a protected access control modifier.<br>&gt; <br>&gt;&gt; On May 28, 2016, at 8:11 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; To begin with, I&#39;m not a fan of `protected` access. But even leaving that aside, I have a few questions and critiques.<br>&gt;&gt; <br>&gt;&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; view.layoutSubviews()<br>&gt;&gt;&gt; The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;&gt; <br>&gt;&gt; This example is illuminating in several ways.<br>&gt;&gt; <br>&gt;&gt; * The rule is not simply that &quot;only the class should call `layoutSubviews()`&quot;; it is effectively &quot;*you* should never call `layoutSubviews()` except when `super`ing up from your override&quot;. Calling `layoutSubviews()` from `insertRows(at:)` is just as much a mistake if `insertRows(at:)` is part of the class as if it is not. So isn&#39;t `protected` insufficiently strict to properly serve this use case?<br>&gt;&gt; <br>&gt;&gt; * At the same time, something outside `layoutSubviews()` has to be able to call `layoutSubviews()`. In the case of UIKit, though, that &quot;something&quot; is always within UIKit itself, never outside it. So should `protected` have a &quot;bottom&quot;, a level below which calls are unrestricted? For instance, in UIKit&#39;s case you might have `protected fileprivate`, meaning &quot;anything up to `fileprivate` has unrestricted use; anything above that can override and `super` up from its override, but not use it any other way&quot;.<br>&gt;&gt; <br>&gt;&gt;   protected fileprivate func layoutSubviews()<br>&gt;&gt; <br>&gt;&gt; * `layoutSubviews()` is also something you should probably always `super` up to. Have you considered addressing `super` requirements at all?<br>&gt;&gt; <br>&gt;&gt; In short, is a traditional `protected` really the feature you want to handle this use case, or would a very different design actually suit it a lot better?<br>&gt;&gt; <br>&gt;&gt;&gt; When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>&gt;&gt; <br>&gt;&gt; In what scope? The same as the class?<br>&gt;&gt; <br>&gt;&gt; Is there not room for, for instance, &quot;usable without restriction in this file, override-only in the rest of this module, invisible outside it&quot;? For instance, `internal(protected) fileprivate`, or perhaps `internal(override) fileprivate`? `layoutSubviews()` might then be `public(override) fileprivate`—the ability to override is public, the ability to use it unrestricted is filewide.<br>&gt;&gt; <br>&gt;&gt;   public(override) fileprivate func layoutSubviews()<br>&gt;&gt;   internal(override) fileprivate func privateSubclassingHook()<br>&gt;&gt; <br>&gt;&gt;&gt; public protected(set) var x = 20<br>&gt;&gt; <br>&gt;&gt; Of course, that might be difficult to combine with the `(set)` syntax. `public(set: override)`, maybe? With, for instance, `public internal(set: override) private(set)` if you want the property&#39;s getter public and its setter overridable internally and callable in private scope.<br>&gt;&gt; <br>&gt;&gt;   public(override) fileprivate func layoutSubviews()<br>&gt;&gt;   internal(override) fileprivate func privateSubclassingHook()<br>&gt;&gt;   public(get, set: override) internal(set) var x = 20<br>&gt;&gt; <br>&gt;&gt; But there&#39;s something about this that&#39;s starting to seem a little rotten. I think the problem is that we&#39;re not really trying to widen the ability to override, we&#39;re trying to restrict the ability to call. Let&#39;s try restructuring along those lines:<br>&gt;&gt; <br>&gt;&gt;   public fileprivate(call) func layoutSubviews()<br>&gt;&gt;   internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;   public internal(set: call) var x = 20<br>&gt;&gt; <br>&gt;&gt; That seems much cleaner to me.<br>&gt;&gt; <br>&gt;&gt;&gt; If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>&gt;&gt; <br>&gt;&gt; With the &quot;overridable but otherwise unusable&quot; conception I&#39;m suggesting, this would not be the case, of course.<br>&gt;&gt; <br>&gt;&gt;&gt; Protocols<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Protocols do not declare access level for their members. So the protected access level is not applicable here.<br>&gt;&gt; <br>&gt;&gt; But `protected` is quite different from other access levels; it does not limit the visibility of the symbols, but rather their use. And protocols face the same sort of problem as classes, where certain members are essentially override hooks and shouldn&#39;t be called directly outside a particular scope.<br>&gt;&gt; <br>&gt;&gt; So I think we ought to allow `accesslevel(call)`, but not a plain `accesslevel`:<br>&gt;&gt; <br>&gt;&gt;   public fileprivate(call) func layoutSubviews()<br>&gt;&gt;   internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;   public internal(set: call) var x = 20<br>&gt;&gt;   internal(call) func protocolConformanceHook()<br>&gt;&gt;   fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt;&gt; <br>&gt;&gt;&gt; Extensions<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Extensions will not be able do be protected nor their members.<br>&gt;&gt; <br>&gt;&gt; This is very vague. There are several things extensions might try to do with protected members:<br>&gt;&gt; <br>&gt;&gt; * Declare new ones<br>&gt;&gt; * Override existing ones<br>&gt;&gt; * Call existing ones<br>&gt;&gt; <br>&gt;&gt; Which of these, if any, are permitted? Why?<br>&gt;&gt; <br>&gt;&gt; In my conception, I would permit extensions to behave as the type they extended did. Extensions could declare new members with restricted calling and override existing ones. They would not be able to call, except when supering from an override, unless they were within scope of the `call` access control. In other words, they&#39;d behave just like any other code at that location. That&#39;s how we want extensions to work.<br>&gt;&gt; <br>&gt;&gt;&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; // We can declare a protected class (or struct, enum, etc.) if<br>&gt;&gt;&gt; // and only if they are nested inside other type.<br>&gt;&gt;&gt; public class MyPublicClass {<br>&gt;&gt;&gt;  protected <br>&gt;&gt;&gt; class MyProtectedClass {<br>&gt;&gt; <br>&gt;&gt; What does it mean to &quot;use&quot; a protected class, though? Clearly you can call its methods, if only through AnyObject or a non-protected superclass or a protocol it conforms to. Does it mean you can&#39;t instantiate it? Does it mean you can&#39;t subclass it? Does it mean you can&#39;t call methods that aren&#39;t on its supertypes? All of the above? None?<br>&gt;&gt; <br>&gt;&gt; One more thing that didn&#39;t come up: Testability. I believe that importing a module with `@testable` should disable its call restrictions, even ones inherited from outside that module. Thus, even if *you* cannot call your `layoutSubviews()`, your test suite can.<br>&gt;&gt; <br>&gt;&gt; So, in short, my counter-proposal is:<br>&gt;&gt; <br>&gt;&gt;   public fileprivate(call) func layoutSubviews()<br>&gt;&gt;   internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;   public internal(set: call) var x = 20<br>&gt;&gt;   internal(call) func protocolConformanceHook()<br>&gt;&gt;   fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt;&gt; <br>&gt;&gt; In other words:<br>&gt;&gt; <br>&gt;&gt; * There is a new aspect of the member, `call`, which controls the ability to actually call the member, as opposed to overriding it. No `call`, no calling (except when `super`ing up from an override).<br>&gt;&gt; <br>&gt;&gt; * `call` is used in combination with one of the existing access modifiers: `public(call)` `internal(call)` `fileprivate(call)` `private(call)`. `call`&#39;s visibility is always less or equal to the member itself.<br>&gt;&gt; <br>&gt;&gt; * To control the callability of a setter independently from both the getter and the overridability of the setter, use `set: call`.<br>&gt;&gt; <br>&gt;&gt; * Extensions behave just like type definitions at the same location with regards to `call`.<br>&gt;&gt; <br>&gt;&gt; * Protocols can use access modifiers with `call` to prevent unauthorized code from calling a member. The access control level to implement a member continues to be as wide as the access control level of the protocol itself.<br>&gt;&gt; <br>&gt;&gt; * `@testable` disables `call` restrictions on the types it imports, so the test suite can call any visible member, even ones inherited from other modules.<br>&gt;&gt; <br>&gt;&gt; * There should probably also be some sort of &quot;super required&quot; warning/error, but this is an orthogonal feature and can be left for a separate proposal.<br>&gt;&gt; <br>&gt;&gt; I think that feature will be closer to the one you actually *want*, as opposed to the one that other languages have cargo-culted from SIMULA-67.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 29, 2016 at 10:00:00am</p></header><div class="content"><p>Without wither abstract classes or a protected access modifier, the status quo, that kind of ExceptionThisMethodShouldBeOverridden are really ugly bad code there is no alternative to beyond a religious stop using classes and sub classing... did you not know about your pop saviour ;)? <br></p><p>Sent from my iPhone<br></p><p>&gt; On 29 May 2016, at 08:38, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ditto - I would love to be able to disallow non-subclasses accessing/modifying some variables.<br>&gt; <br>&gt; Though, I&#39;m not sure what would be the stand on this from the core team - according to Apple&#39;s blog they&#39;ve already considered protected access level:<br>&gt; <br>&gt; https://developer.apple.com/swift/blog/?id=11<br>&gt; <br>&gt; Charlie<br>&gt; <br>&gt; <br>&gt;&gt; On May 29, 2016, at 7:56 AM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Unless I&#39;m missing something Brent, your suggestions still wouldn&#39;t allow the developer to provide a public class in a module designed to be subclassed by clients in another module and access these &quot;private&quot; details, which is a real problem I&#39;m having in my current project.<br>&gt;&gt; <br>&gt;&gt; I have a framework which provides an abstract model object designed to be subclassed (and yes it has to be a class and not a struct for a multitude of reasons 😛) by clients of the framework. There are several convenience methods + properties I have exposed for subclasses to use, but they should really be implementation details; a client using these model objects should not have to know about them. Even worse, several of the properties are mutable so the subclasses can modify them, but they certainly should *not* be modified by anything else.<br>&gt;&gt; <br>&gt;&gt; Right now, I&#39;m limited to simply commenting something akin to &quot;DO NOT CALL&quot; next to these methods/properties, which definitely goes against Swift&#39;s safety focus. For these reasons, I&#39;m 100% in support of a protected access control modifier.<br>&gt;&gt; <br>&gt;&gt;&gt; On May 28, 2016, at 8:11 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; To begin with, I&#39;m not a fan of `protected` access. But even leaving that aside, I have a few questions and critiques.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; view.layoutSubviews()<br>&gt;&gt;&gt;&gt; The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This example is illuminating in several ways.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * The rule is not simply that &quot;only the class should call `layoutSubviews()`&quot;; it is effectively &quot;*you* should never call `layoutSubviews()` except when `super`ing up from your override&quot;. Calling `layoutSubviews()` from `insertRows(at:)` is just as much a mistake if `insertRows(at:)` is part of the class as if it is not. So isn&#39;t `protected` insufficiently strict to properly serve this use case?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * At the same time, something outside `layoutSubviews()` has to be able to call `layoutSubviews()`. In the case of UIKit, though, that &quot;something&quot; is always within UIKit itself, never outside it. So should `protected` have a &quot;bottom&quot;, a level below which calls are unrestricted? For instance, in UIKit&#39;s case you might have `protected fileprivate`, meaning &quot;anything up to `fileprivate` has unrestricted use; anything above that can override and `super` up from its override, but not use it any other way&quot;.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  protected fileprivate func layoutSubviews()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * `layoutSubviews()` is also something you should probably always `super` up to. Have you considered addressing `super` requirements at all?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In short, is a traditional `protected` really the feature you want to handle this use case, or would a very different design actually suit it a lot better?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In what scope? The same as the class?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Is there not room for, for instance, &quot;usable without restriction in this file, override-only in the rest of this module, invisible outside it&quot;? For instance, `internal(protected) fileprivate`, or perhaps `internal(override) fileprivate`? `layoutSubviews()` might then be `public(override) fileprivate`—the ability to override is public, the ability to use it unrestricted is filewide.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public(override) fileprivate func layoutSubviews()<br>&gt;&gt;&gt;  internal(override) fileprivate func privateSubclassingHook()<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public protected(set) var x = 20<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Of course, that might be difficult to combine with the `(set)` syntax. `public(set: override)`, maybe? With, for instance, `public internal(set: override) private(set)` if you want the property&#39;s getter public and its setter overridable internally and callable in private scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public(override) fileprivate func layoutSubviews()<br>&gt;&gt;&gt;  internal(override) fileprivate func privateSubclassingHook()<br>&gt;&gt;&gt;  public(get, set: override) internal(set) var x = 20<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But there&#39;s something about this that&#39;s starting to seem a little rotten. I think the problem is that we&#39;re not really trying to widen the ability to override, we&#39;re trying to restrict the ability to call. Let&#39;s try restructuring along those lines:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public fileprivate(call) func layoutSubviews()<br>&gt;&gt;&gt;  internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;&gt;  public internal(set: call) var x = 20<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; That seems much cleaner to me.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; With the &quot;overridable but otherwise unusable&quot; conception I&#39;m suggesting, this would not be the case, of course.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Protocols do not declare access level for their members. So the protected access level is not applicable here.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; But `protected` is quite different from other access levels; it does not limit the visibility of the symbols, but rather their use. And protocols face the same sort of problem as classes, where certain members are essentially override hooks and shouldn&#39;t be called directly outside a particular scope.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So I think we ought to allow `accesslevel(call)`, but not a plain `accesslevel`:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public fileprivate(call) func layoutSubviews()<br>&gt;&gt;&gt;  internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;&gt;  public internal(set: call) var x = 20<br>&gt;&gt;&gt;  internal(call) func protocolConformanceHook()<br>&gt;&gt;&gt;  fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Extensions will not be able do be protected nor their members.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; This is very vague. There are several things extensions might try to do with protected members:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Declare new ones<br>&gt;&gt;&gt; * Override existing ones<br>&gt;&gt;&gt; * Call existing ones<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Which of these, if any, are permitted? Why?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In my conception, I would permit extensions to behave as the type they extended did. Extensions could declare new members with restricted calling and override existing ones. They would not be able to call, except when supering from an override, unless they were within scope of the `call` access control. In other words, they&#39;d behave just like any other code at that location. That&#39;s how we want extensions to work.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; // We can declare a protected class (or struct, enum, etc.) if<br>&gt;&gt;&gt;&gt; // and only if they are nested inside other type.<br>&gt;&gt;&gt;&gt; public class MyPublicClass {<br>&gt;&gt;&gt;&gt; protected <br>&gt;&gt;&gt;&gt; class MyProtectedClass {<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; What does it mean to &quot;use&quot; a protected class, though? Clearly you can call its methods, if only through AnyObject or a non-protected superclass or a protocol it conforms to. Does it mean you can&#39;t instantiate it? Does it mean you can&#39;t subclass it? Does it mean you can&#39;t call methods that aren&#39;t on its supertypes? All of the above? None?<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; One more thing that didn&#39;t come up: Testability. I believe that importing a module with `@testable` should disable its call restrictions, even ones inherited from outside that module. Thus, even if *you* cannot call your `layoutSubviews()`, your test suite can.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; So, in short, my counter-proposal is:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;  public fileprivate(call) func layoutSubviews()<br>&gt;&gt;&gt;  internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;&gt;  public internal(set: call) var x = 20<br>&gt;&gt;&gt;  internal(call) func protocolConformanceHook()<br>&gt;&gt;&gt;  fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; In other words:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * There is a new aspect of the member, `call`, which controls the ability to actually call the member, as opposed to overriding it. No `call`, no calling (except when `super`ing up from an override).<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * `call` is used in combination with one of the existing access modifiers: `public(call)` `internal(call)` `fileprivate(call)` `private(call)`. `call`&#39;s visibility is always less or equal to the member itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * To control the callability of a setter independently from both the getter and the overridability of the setter, use `set: call`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Extensions behave just like type definitions at the same location with regards to `call`.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * Protocols can use access modifiers with `call` to prevent unauthorized code from calling a member. The access control level to implement a member continues to be as wide as the access control level of the protocol itself.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * `@testable` disables `call` restrictions on the types it imports, so the test suite can call any visible member, even ones inherited from other modules.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; * There should probably also be some sort of &quot;super required&quot; warning/error, but this is an orthogonal feature and can be left for a separate proposal.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I think that feature will be closer to the one you actually *want*, as opposed to the one that other languages have cargo-culted from SIMULA-67.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; -- <br>&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 29, 2016 at 11:00:00am</p></header><div class="content"><p>I agree - both will need to be addressed in the future to make the language complete. There are some valid points, however, in the blog post - would you allow extensions to access protected variables and potentially expose them to other classes? I.e:<br></p><p>/// Class in module A:<br>class View {<br>	protected func layoutSubviews()<br>}<br></p><p>/// In module B:<br>extension View {<br>	func doLayoutSubviews() {<br>		self.layoutSubviews()<br>	}<br>}<br></p><p>Or would you disallow access from extensions to prevent this kind of abuse?<br></p><p>&gt; On May 29, 2016, at 11:19 AM, Goffredo Marocchi &lt;panajev at gmail.com&gt; wrote:<br>&gt; <br>&gt; Without wither abstract classes or a protected access modifier, the status quo, that kind of ExceptionThisMethodShouldBeOverridden are really ugly bad code there is no alternative to beyond a religious stop using classes and sub classing... did you not know about your pop saviour ;)? <br>&gt; <br>&gt; Sent from my iPhone<br>&gt; <br>&gt;&gt; On 29 May 2016, at 08:38, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; Ditto - I would love to be able to disallow non-subclasses accessing/modifying some variables.<br>&gt;&gt; <br>&gt;&gt; Though, I&#39;m not sure what would be the stand on this from the core team - according to Apple&#39;s blog they&#39;ve already considered protected access level:<br>&gt;&gt; <br>&gt;&gt; https://developer.apple.com/swift/blog/?id=11<br>&gt;&gt; <br>&gt;&gt; Charlie<br>&gt;&gt; <br>&gt;&gt; <br>&gt;&gt;&gt; On May 29, 2016, at 7:56 AM, Riley Testut via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Unless I&#39;m missing something Brent, your suggestions still wouldn&#39;t allow the developer to provide a public class in a module designed to be subclassed by clients in another module and access these &quot;private&quot; details, which is a real problem I&#39;m having in my current project.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; I have a framework which provides an abstract model object designed to be subclassed (and yes it has to be a class and not a struct for a multitude of reasons 😛) by clients of the framework. There are several convenience methods + properties I have exposed for subclasses to use, but they should really be implementation details; a client using these model objects should not have to know about them. Even worse, several of the properties are mutable so the subclasses can modify them, but they certainly should *not* be modified by anything else.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt; Right now, I&#39;m limited to simply commenting something akin to &quot;DO NOT CALL&quot; next to these methods/properties, which definitely goes against Swift&#39;s safety focus. For these reasons, I&#39;m 100% in support of a protected access control modifier.<br>&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; On May 28, 2016, at 8:11 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; To begin with, I&#39;m not a fan of `protected` access. But even leaving that aside, I have a few questions and critiques.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; view.layoutSubviews()<br>&gt;&gt;&gt;&gt;&gt; The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This example is illuminating in several ways.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * The rule is not simply that &quot;only the class should call `layoutSubviews()`&quot;; it is effectively &quot;*you* should never call `layoutSubviews()` except when `super`ing up from your override&quot;. Calling `layoutSubviews()` from `insertRows(at:)` is just as much a mistake if `insertRows(at:)` is part of the class as if it is not. So isn&#39;t `protected` insufficiently strict to properly serve this use case?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * At the same time, something outside `layoutSubviews()` has to be able to call `layoutSubviews()`. In the case of UIKit, though, that &quot;something&quot; is always within UIKit itself, never outside it. So should `protected` have a &quot;bottom&quot;, a level below which calls are unrestricted? For instance, in UIKit&#39;s case you might have `protected fileprivate`, meaning &quot;anything up to `fileprivate` has unrestricted use; anything above that can override and `super` up from its override, but not use it any other way&quot;.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; protected fileprivate func layoutSubviews()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * `layoutSubviews()` is also something you should probably always `super` up to. Have you considered addressing `super` requirements at all?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In short, is a traditional `protected` really the feature you want to handle this use case, or would a very different design actually suit it a lot better?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In what scope? The same as the class?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Is there not room for, for instance, &quot;usable without restriction in this file, override-only in the rest of this module, invisible outside it&quot;? For instance, `internal(protected) fileprivate`, or perhaps `internal(override) fileprivate`? `layoutSubviews()` might then be `public(override) fileprivate`—the ability to override is public, the ability to use it unrestricted is filewide.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public(override) fileprivate func layoutSubviews()<br>&gt;&gt;&gt;&gt; internal(override) fileprivate func privateSubclassingHook()<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; public protected(set) var x = 20<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Of course, that might be difficult to combine with the `(set)` syntax. `public(set: override)`, maybe? With, for instance, `public internal(set: override) private(set)` if you want the property&#39;s getter public and its setter overridable internally and callable in private scope.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public(override) fileprivate func layoutSubviews()<br>&gt;&gt;&gt;&gt; internal(override) fileprivate func privateSubclassingHook()<br>&gt;&gt;&gt;&gt; public(get, set: override) internal(set) var x = 20<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But there&#39;s something about this that&#39;s starting to seem a little rotten. I think the problem is that we&#39;re not really trying to widen the ability to override, we&#39;re trying to restrict the ability to call. Let&#39;s try restructuring along those lines:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public fileprivate(call) func layoutSubviews()<br>&gt;&gt;&gt;&gt; internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;&gt;&gt; public internal(set: call) var x = 20<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; That seems much cleaner to me.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; With the &quot;overridable but otherwise unusable&quot; conception I&#39;m suggesting, this would not be the case, of course.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Protocols do not declare access level for their members. So the protected access level is not applicable here.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; But `protected` is quite different from other access levels; it does not limit the visibility of the symbols, but rather their use. And protocols face the same sort of problem as classes, where certain members are essentially override hooks and shouldn&#39;t be called directly outside a particular scope.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So I think we ought to allow `accesslevel(call)`, but not a plain `accesslevel`:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public fileprivate(call) func layoutSubviews()<br>&gt;&gt;&gt;&gt; internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;&gt;&gt; public internal(set: call) var x = 20<br>&gt;&gt;&gt;&gt; internal(call) func protocolConformanceHook()<br>&gt;&gt;&gt;&gt; fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Extensions<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; Extensions will not be able do be protected nor their members.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; This is very vague. There are several things extensions might try to do with protected members:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Declare new ones<br>&gt;&gt;&gt;&gt; * Override existing ones<br>&gt;&gt;&gt;&gt; * Call existing ones<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; Which of these, if any, are permitted? Why?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In my conception, I would permit extensions to behave as the type they extended did. Extensions could declare new members with restricted calling and override existing ones. They would not be able to call, except when supering from an override, unless they were within scope of the `call` access control. In other words, they&#39;d behave just like any other code at that location. That&#39;s how we want extensions to work.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt;&gt; // We can declare a protected class (or struct, enum, etc.) if<br>&gt;&gt;&gt;&gt;&gt; // and only if they are nested inside other type.<br>&gt;&gt;&gt;&gt;&gt; public class MyPublicClass {<br>&gt;&gt;&gt;&gt;&gt; protected <br>&gt;&gt;&gt;&gt;&gt; class MyProtectedClass {<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; What does it mean to &quot;use&quot; a protected class, though? Clearly you can call its methods, if only through AnyObject or a non-protected superclass or a protocol it conforms to. Does it mean you can&#39;t instantiate it? Does it mean you can&#39;t subclass it? Does it mean you can&#39;t call methods that aren&#39;t on its supertypes? All of the above? None?<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; One more thing that didn&#39;t come up: Testability. I believe that importing a module with `@testable` should disable its call restrictions, even ones inherited from outside that module. Thus, even if *you* cannot call your `layoutSubviews()`, your test suite can.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; So, in short, my counter-proposal is:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; public fileprivate(call) func layoutSubviews()<br>&gt;&gt;&gt;&gt; internal fileprivate(call) func privateSubclassingHook()<br>&gt;&gt;&gt;&gt; public internal(set: call) var x = 20<br>&gt;&gt;&gt;&gt; internal(call) func protocolConformanceHook()<br>&gt;&gt;&gt;&gt; fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; In other words:<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * There is a new aspect of the member, `call`, which controls the ability to actually call the member, as opposed to overriding it. No `call`, no calling (except when `super`ing up from an override).<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * `call` is used in combination with one of the existing access modifiers: `public(call)` `internal(call)` `fileprivate(call)` `private(call)`. `call`&#39;s visibility is always less or equal to the member itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * To control the callability of a setter independently from both the getter and the overridability of the setter, use `set: call`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Extensions behave just like type definitions at the same location with regards to `call`.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * Protocols can use access modifiers with `call` to prevent unauthorized code from calling a member. The access control level to implement a member continues to be as wide as the access control level of the protocol itself.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * `@testable` disables `call` restrictions on the types it imports, so the test suite can call any visible member, even ones inherited from other modules.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; * There should probably also be some sort of &quot;super required&quot; warning/error, but this is an orthogonal feature and can be left for a separate proposal.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; I think that feature will be closer to the one you actually *want*, as opposed to the one that other languages have cargo-culted from SIMULA-67.<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; -- <br>&gt;&gt;&gt;&gt; Brent Royal-Gordon<br>&gt;&gt;&gt;&gt; Architechies<br>&gt;&gt;&gt;&gt; <br>&gt;&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt; _______________________________________________<br>&gt;&gt;&gt; swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 29, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 29, 2016, at 9:38 AM, Charlie Monroe via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Ditto - I would love to be able to disallow non-subclasses accessing/modifying some variables.<br>&gt; <br>&gt; Though, I&#39;m not sure what would be the stand on this from the core team - according to Apple&#39;s blog they&#39;ve already considered protected access level:<br>&gt; <br>&gt; https://developer.apple.com/swift/blog/?id=11<br>&gt; <br>&gt; Charlie<br>&gt; <br></p><p>let’s perpetuate the helplessness because developers will not understand. That might be the rationale that also prevailed to make swift have no namespaces: Objective-c did not… funny thing is, the compiler source code would be miserable to read if its source code was organized in terms of classes and modules (lib). Which means that aside from accessibility to LLVM API, attempting to write a Swift compiler in Swift today would probably result in hard to read/reason about source code.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; attempting to write a Swift compiler in Swift today would probably result in hard to read/reason about source code. <br></p><p>Hmm, I still have to find some time to start working in this...<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>The rust compiler is written in rust… many compilers are bootstrapped and then written in their own language. Looking at the swift language vs C++ features used in the current compiler, I wager it would be a suicide mission to try with Swift 3.0.<br></p><p>&gt; On May 29, 2016, at 2:27 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt; <br>&gt; <br>&gt;&gt; attempting to write a Swift compiler in Swift today would probably result in hard to read/reason about source code. <br>&gt; <br>&gt; Hmm, I still have to find some time to start working in this...<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 29, 2016 at 03:00:00am</p></header><div class="content"><p>&gt; Unless I&#39;m missing something Brent, your suggestions still wouldn&#39;t allow the developer to provide a public class in a module designed to be subclassed by clients in another module and access these &quot;private&quot; details, which is a real problem I&#39;m having in my current project.<br>&gt; <br>&gt; I have a framework which provides an abstract model object designed to be subclassed (and yes it has to be a class and not a struct for a multitude of reasons 😛) by clients of the framework. There are several convenience methods + properties I have exposed for subclasses to use, but they should really be implementation details; a client using these model objects should not have to know about them. Even worse, several of the properties are mutable so the subclasses can modify them, but they certainly should *not* be modified by anything else.<br>&gt; <br>&gt; Right now, I&#39;m limited to simply commenting something akin to &quot;DO NOT CALL&quot; next to these methods/properties, which definitely goes against Swift&#39;s safety focus. For these reasons, I&#39;m 100% in support of a protected access control modifier.<br></p><p>That&#39;s a little bit of a different use case than the `layoutSubviews()` case discussed in the proposal.<br></p><p>My answer is this: There is nothing magical about being a subclass that ought to grant access to those methods. For instance, if your subclass grows very complicated and you extract a helper object, it&#39;s perfectly reasonable for that helper object to want to access the &quot;subclass-only&quot; API. Contrarily, simple subclasses might not need that API, and exposing it to them would be an unnecessary risk. And there are things which you don&#39;t subclass at all which could benefit from being hidden away—think of the Objective-C runtime, which has some parts which every app needs (like the definition of `BOOL`) and other parts which are extraordinarily dangerous and should only be available to code which needs it (like `method_exchangeImplementations`).<br></p><p>The Objective-C solution—using a separate header file—actually acknowledges this fact. Even though the header is called &quot;UIGestureRecognizerSubclass.h&quot;, it is not really limited to subclasses; any code can import and use that API. It&#39;s just sectioned off *by default*, like keeping all the kitchen knives in a sharps drawer. And the Objective-C runtime, which doesn&#39;t contain (many) classes, can use this approach too: &lt;objc/objc.h&gt; is implicitly available, while &lt;objc/runtime.h&gt; is something you have to ask for explicitly.<br></p><p>There are a few ways you could bring this same &quot;sharps drawer&quot; approach to Swift. For instance—without adding any language features—you could create an ancillary struct which merely serves to segregate all the dangerous APIs:<br></p><p>	public class UIGestureRecognizer {<br>		public private(set) var state: UIGestureRecognizerState {...}<br>		<br>		private func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {...}<br>		private func reset() {...}<br>		<br>		// etc. for the other APIs<br>		<br>		/// Contains methods and properties which directly affect the state of the gesture recognizer.<br>		///<br>		/// -Warning: Only use the state engine when implementing a custom gesture recognizer yourself.<br>		/// 		The state engine is delicate and modifying behind a gesture recognizer&#39;s back is likely to <br>		///		break it.<br>		public var stateEngine: StateEngine { return StateEngine(gestureRecognizer: self) }<br>		<br>		public struct StateEngine {<br>			private var gestureRecognizer: UIGestureRecognizer<br>			<br>			public var state: UIGestureRecognizerState {<br>				get { return gestureRecognizer.state }<br>				nonmutating set { gestureRecognizer.state = newValue }<br>			}<br>		<br>			public func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {<br>				gestureRecognizer.ignoreTouch(touch, forEvent: event)<br>			}<br>			<br>			public func reset() {<br>				gestureRecognizer.reset()<br>			}<br></p><p>			/// etc. for the other APIs<br>		}<br>	}<br></p><p>Now ordinary clients of UIGestureRecognizer won&#39;t see a bunch of random methods strewn around with doc comments warning not to use them; they&#39;ll see *one* property with an intimidating name and a scary comment. You could even give the property a name like `internals` to make it clearer that you shouldn&#39;t be touching this unless you know what you&#39;re doing. On the other hand, any code that needs to *can* access these features, whether or not that code happens to be located in a subclass of the class in question.<br></p><p>Obviously, this approach could benefit from formalization; there are a number of ways that might be done. For instance, you could create a sort of namespace within a class which functions the same way as the `StateEngine` struct and `stateEngine` property in the last example, but without the boilerplate:<br></p><p>	public class UIGestureRecognizer {<br>		/// Contains methods and properties which directly affect the state of the gesture recognizer.<br>		///<br>		/// -Warning: Only use the state engine when implementing a custom gesture recognizer yourself.<br>		/// 		The state engine is delicate and modifying behind a gesture recognizer&#39;s back is likely to <br>		///		break it.<br>		namespace stateEngine {<br>			// Note that `self` here is still UIGestureRecognizer.<br>			<br>			public var state: UIGestureRecognizerState {...}<br>			<br>			public func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {...}<br>			public func reset() {...}<br>		}<br>		<br>		public var state: UIGestureRecognizerState {<br>			get { return stateEngine.state }<br>		}<br>	}<br></p><p>You could tag particular methods and properties such that files have to ask for access to that subset:<br></p><p>	public class UIGestureRecognizer {<br>		public(@restricted(set: StateEngine)) var state: UIGestureRecognizerState {...}<br>		<br>		public(@restricted(StateEngine))  func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {...}<br>		public(@restricted(StateEngine)) func reset() {...}<br>	}<br></p><p>	// In some other file...<br>	import UIKit<br>	use UIGestureRecognizer.StateEngine<br></p><p>Or you could move the dangerous members into a submodule and thus require a separate import to see them. I will not speculate on a good submodule syntax, but usage would end up looking like this:<br></p><p>	import UIKit<br>	import UIKit.UIGestureRecognizerStateEngine<br></p><p>All of these approaches share the virtues of the Objective-C approach:<br></p><p>* Subclasses which don&#39;t need the dangerous stuff don&#39;t have access to it.<br>* Code which is not technically a subclass but still requires access *does* have access to it.<br>* They&#39;ll work with types which *don&#39;t* get subclassed but similarly have some rare-but-dangerous APIs.<br></p><p>So, just as with controlling override point callers, I think that `protected` is at best a rough approximation of the feature you actually want.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 29, 2016 at 01:00:00pm</p></header><div class="content"><p>&gt; My answer is this: There is nothing magical about being a subclass that ought to grant access to those methods.<br></p><p>There is - it&#39;s a family member that you let use your summer house. Without the metaphor, here is an example for this being useful: <br></p><p>URLConnection subclass may want to update the URL in case of a redirect, but you don&#39;t really want to expose the setter for the URL to public.<br></p><p>&gt; For instance, if your subclass grows very complicated and you extract a helper object, it&#39;s perfectly reasonable for that helper object to want to access the &quot;subclass-only&quot; API.<br></p><p>That&#39;s what &quot;friend&quot; classes are for in C++, similar concept would be applied here.<br></p><p>&gt; Contrarily, simple subclasses might not need that API, and exposing it to them would be an unnecessary risk. And there are things which you don&#39;t subclass at all which could benefit from being hidden away—think of the Objective-C runtime, which has some parts which every app needs (like the definition of `BOOL`) and othe<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 29, 2016 at 09:00:00am</p></header><div class="content"><p>You know the default access is was is used for this, right? And in this case I don&#39;t think they meant it for external subclasses to be able to access this change.<br></p><p>I think this is how Swift was meant to work allowing only classes in a certain module to access such &quot;private shared&quot; parts and using delegates for these extensions. I&#39;m not saying I&#39;m against protecteds but it&#39;s hard to get used to use another way of programming when most other languages we previously learned had a different philosophy.<br></p><p>Sure everyone has the right to discuss they like this new philosophy or not but we should also question ourselves if this is the right way to go because it will completely change the philosophy of the language. Should this pass, we may start facing the core library using the delegate philosophy (I don&#39;t believe Apple will change it) and third-party modern frameworks using old school subclassing with protected parts. That&#39;s two ways of doing the same thing and I don&#39;t think this will be much good to anyone.<br></p><p><br>-----Original Message-----<br>From: &quot;Charlie Monroe via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎29/‎05/‎2016 08:29 AM<br>To: &quot;Brent Royal-Gordon&quot; &lt;brent at architechies.com&gt;<br>Cc: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br></p><p><br>&gt; My answer is this: There is nothing magical about being a subclass that ought to grant access to those methods.<br></p><p>There is - it&#39;s a family member that you let use your summer house. Without the metaphor, here is an example for this being useful: <br></p><p>URLConnection subclass may want to update the URL in case of a redirect, but you don&#39;t really want to expose the setter for the URL to public.<br></p><p>&gt; For instance, if your subclass grows very complicated and you extract a helper object, it&#39;s perfectly reasonable for that helper object to want to access the &quot;subclass-only&quot; API.<br></p><p>That&#39;s what &quot;friend&quot; classes are for in C++, similar concept would be applied here.<br></p><p>&gt; Contrarily, simple subclasses might not need that API, and exposing it to them would be an unnecessary risk. And there are things which you don&#39;t subclass at all which could benefit from being hidden away—think of the Objective-C runtime, which has some parts which every app needs (like the definition of `BOOL`) and othe<br></p><p>_______________________________________________<br>swift-evolution mailing list<br>swift-evolution at swift.org<br>https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/0bede146/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 29, 2016 at 01:00:00pm</p></header><div class="content"><p>Multiple ways for multiple needs. The same way you can support both delegation as well as blocks based callbacks.<br></p><p>Sent from my iPhone<br></p><p>&gt; On 29 May 2016, at 13:23, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; You know the default access is was is used for this, right? And in this case I don&#39;t think they meant it for external subclasses to be able to access this change.<br>&gt; <br>&gt; I think this is how Swift was meant to work allowing only classes in a certain module to access such &quot;private shared&quot; parts and using delegates for these extensions. I&#39;m not saying I&#39;m against protecteds but it&#39;s hard to get used to use another way of programming when most other languages we previously learned had a different philosophy.<br>&gt; <br>&gt; Sure everyone has the right to discuss they like this new philosophy or not but we should also question ourselves if this is the right way to go because it will completely change the philosophy of the language. Should this pass, we may start facing the core library using the delegate philosophy (I don&#39;t believe Apple will change it) and third-party modern frameworks using old school subclassing with protected parts. That&#39;s two ways of doing the same thing and I don&#39;t think this will be much good to anyone.<br>&gt; From: Charlie Monroe via swift-evolution<br>&gt; Sent: ‎29/‎05/‎2016 08:29 AM<br>&gt; To: Brent Royal-Gordon<br>&gt; Cc: swift-evolution<br>&gt; Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br>&gt; <br>&gt; <br>&gt; &gt; My answer is this: There is nothing magical about being a subclass that ought to grant access to those methods.<br>&gt; <br>&gt; There is - it&#39;s a family member that you let use your summer house. Without the metaphor, here is an example for this being useful: <br>&gt; <br>&gt; URLConnection subclass may want to update the URL in case of a redirect, but you don&#39;t really want to expose the setter for the URL to public.<br>&gt; <br>&gt; &gt; For instance, if your subclass grows very complicated and you extract a helper object, it&#39;s perfectly reasonable for that helper object to want to access the &quot;subclass-only&quot; API.<br>&gt; <br>&gt; That&#39;s what &quot;friend&quot; classes are for in C++, similar concept would be applied here.<br>&gt; <br>&gt; &gt; Contrarily, simple subclasses might not need that API, and exposing it to them would be an unnecessary risk. And there are things which you don&#39;t subclass at all which could benefit from being hidden away—think of the Objective-C runtime, which has some parts which every app needs (like the definition of `BOOL`) and othe<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/f1b17c60/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 29, 2016 at 09:00:00pm</p></header><div class="content"><p>Brent,<br></p><p>I personally was also thinking of the UIGestureRecognizerSubclass example, and I think it’s the best example of ‘protected’ use case, but I think I came to a slightly different position you did.<br></p><p>You come to this from the perspective of “can we do something with the same limitations of UIGestureRecognizerSubclass”? I come at this from the exact opposite view, I think UIGestureRecognizer shows the problem with the Obj-C solution. It’s a workaround for a painful limitation of Obj-C. This is something we should be looking to provide a better solution for, not “as good as”. I also think your solution is quite convoluted simply to avoid a “protected” solution.<br></p><p>I really liked your idea for “private(call)” but I think that the UIGestureRecognizer example still could not be implemented without a “protected(call)”. Internal state needs to be updated by the gesture recognizer subclass, outside the initial module (UIKit), but these setters and accessors should never be called externally of a subclass. That, in my mind, is the definition of “protected”.<br></p><p>You seem to be producing a convoluted solution to create a “sharps drawer” but Swift is supposed to be safe. You shouldn’t access the sharps drawer there and there are better ways for us to stop you than to simply “trust” the developer - it’s to do the right thing, and provide a protection level that stops the access where it’s not needed: “protected”.<br></p><p>Protected would not fix some of the issues with calling methods like “layoutSubviews()” but we can address them otherwise as they’re not really in the scope “protected” addresses.<br></p><p>- Rod<br></p><p><br></p><p>&gt; On 29 May 2016, at 8:30 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; Unless I&#39;m missing something Brent, your suggestions still wouldn&#39;t allow the developer to provide a public class in a module designed to be subclassed by clients in another module and access these &quot;private&quot; details, which is a real problem I&#39;m having in my current project.<br>&gt;&gt; <br>&gt;&gt; I have a framework which provides an abstract model object designed to be subclassed (and yes it has to be a class and not a struct for a multitude of reasons 😛) by clients of the framework. There are several convenience methods + properties I have exposed for subclasses to use, but they should really be implementation details; a client using these model objects should not have to know about them. Even worse, several of the properties are mutable so the subclasses can modify them, but they certainly should *not* be modified by anything else.<br>&gt;&gt; <br>&gt;&gt; Right now, I&#39;m limited to simply commenting something akin to &quot;DO NOT CALL&quot; next to these methods/properties, which definitely goes against Swift&#39;s safety focus. For these reasons, I&#39;m 100% in support of a protected access control modifier.<br>&gt; <br>&gt; That&#39;s a little bit of a different use case than the `layoutSubviews()` case discussed in the proposal.<br>&gt; <br>&gt; My answer is this: There is nothing magical about being a subclass that ought to grant access to those methods. For instance, if your subclass grows very complicated and you extract a helper object, it&#39;s perfectly reasonable for that helper object to want to access the &quot;subclass-only&quot; API. Contrarily, simple subclasses might not need that API, and exposing it to them would be an unnecessary risk. And there are things which you don&#39;t subclass at all which could benefit from being hidden away—think of the Objective-C runtime, which has some parts which every app needs (like the definition of `BOOL`) and other parts which are extraordinarily dangerous and should only be available to code which needs it (like `method_exchangeImplementations`).<br>&gt; <br>&gt; The Objective-C solution—using a separate header file—actually acknowledges this fact. Even though the header is called &quot;UIGestureRecognizerSubclass.h&quot;, it is not really limited to subclasses; any code can import and use that API. It&#39;s just sectioned off *by default*, like keeping all the kitchen knives in a sharps drawer. And the Objective-C runtime, which doesn&#39;t contain (many) classes, can use this approach too: &lt;objc/objc.h&gt; is implicitly available, while &lt;objc/runtime.h&gt; is something you have to ask for explicitly.<br>&gt; <br>&gt; There are a few ways you could bring this same &quot;sharps drawer&quot; approach to Swift. For instance—without adding any language features—you could create an ancillary struct which merely serves to segregate all the dangerous APIs:<br>&gt; <br>&gt; 	public class UIGestureRecognizer {<br>&gt; 		public private(set) var state: UIGestureRecognizerState {...}<br>&gt; 		<br>&gt; 		private func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {...}<br>&gt; 		private func reset() {...}<br>&gt; 		<br>&gt; 		// etc. for the other APIs<br>&gt; 		<br>&gt; 		/// Contains methods and properties which directly affect the state of the gesture recognizer.<br>&gt; 		///<br>&gt; 		/// -Warning: Only use the state engine when implementing a custom gesture recognizer yourself.<br>&gt; 		/// 		The state engine is delicate and modifying behind a gesture recognizer&#39;s back is likely to <br>&gt; 		///		break it.<br>&gt; 		public var stateEngine: StateEngine { return StateEngine(gestureRecognizer: self) }<br>&gt; 		<br>&gt; 		public struct StateEngine {<br>&gt; 			private var gestureRecognizer: UIGestureRecognizer<br>&gt; 			<br>&gt; 			public var state: UIGestureRecognizerState {<br>&gt; 				get { return gestureRecognizer.state }<br>&gt; 				nonmutating set { gestureRecognizer.state = newValue }<br>&gt; 			}<br>&gt; 		<br>&gt; 			public func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {<br>&gt; 				gestureRecognizer.ignoreTouch(touch, forEvent: event)<br>&gt; 			}<br>&gt; 			<br>&gt; 			public func reset() {<br>&gt; 				gestureRecognizer.reset()<br>&gt; 			}<br>&gt; <br>&gt; 			/// etc. for the other APIs<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; Now ordinary clients of UIGestureRecognizer won&#39;t see a bunch of random methods strewn around with doc comments warning not to use them; they&#39;ll see *one* property with an intimidating name and a scary comment. You could even give the property a name like `internals` to make it clearer that you shouldn&#39;t be touching this unless you know what you&#39;re doing. On the other hand, any code that needs to *can* access these features, whether or not that code happens to be located in a subclass of the class in question.<br>&gt; <br>&gt; Obviously, this approach could benefit from formalization; there are a number of ways that might be done. For instance, you could create a sort of namespace within a class which functions the same way as the `StateEngine` struct and `stateEngine` property in the last example, but without the boilerplate:<br>&gt; <br>&gt; 	public class UIGestureRecognizer {<br>&gt; 		/// Contains methods and properties which directly affect the state of the gesture recognizer.<br>&gt; 		///<br>&gt; 		/// -Warning: Only use the state engine when implementing a custom gesture recognizer yourself.<br>&gt; 		/// 		The state engine is delicate and modifying behind a gesture recognizer&#39;s back is likely to <br>&gt; 		///		break it.<br>&gt; 		namespace stateEngine {<br>&gt; 			// Note that `self` here is still UIGestureRecognizer.<br>&gt; 			<br>&gt; 			public var state: UIGestureRecognizerState {...}<br>&gt; 			<br>&gt; 			public func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {...}<br>&gt; 			public func reset() {...}<br>&gt; 		}<br>&gt; 		<br>&gt; 		public var state: UIGestureRecognizerState {<br>&gt; 			get { return stateEngine.state }<br>&gt; 		}<br>&gt; 	}<br>&gt; <br>&gt; You could tag particular methods and properties such that files have to ask for access to that subset:<br>&gt; <br>&gt; 	public class UIGestureRecognizer {<br>&gt; 		public(@restricted(set: StateEngine)) var state: UIGestureRecognizerState {...}<br>&gt; 		<br>&gt; 		public(@restricted(StateEngine))  func ignoreTouch(touch: UITouch, forEvent event: UIEvent) {...}<br>&gt; 		public(@restricted(StateEngine)) func reset() {...}<br>&gt; 	}<br>&gt; <br>&gt; 	// In some other file...<br>&gt; 	import UIKit<br>&gt; 	use UIGestureRecognizer.StateEngine<br>&gt; <br>&gt; Or you could move the dangerous members into a submodule and thus require a separate import to see them. I will not speculate on a good submodule syntax, but usage would end up looking like this:<br>&gt; <br>&gt; 	import UIKit<br>&gt; 	import UIKit.UIGestureRecognizerStateEngine<br>&gt; <br>&gt; All of these approaches share the virtues of the Objective-C approach:<br>&gt; <br>&gt; * Subclasses which don&#39;t need the dangerous stuff don&#39;t have access to it.<br>&gt; * Code which is not technically a subclass but still requires access *does* have access to it.<br>&gt; * They&#39;ll work with types which *don&#39;t* get subclassed but similarly have some rare-but-dangerous APIs.<br>&gt; <br>&gt; So, just as with controlling override point callers, I think that `protected` is at best a rough approximation of the feature you actually want.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 29, 2016 at 04:00:00pm</p></header><div class="content"><p>&gt; You seem to be producing a convoluted solution to create a “sharps drawer” but Swift is supposed to be safe. You shouldn’t access the sharps drawer there and there are better ways for us to stop you than to simply “trust” the developer - it’s to do the right thing, and provide a protection level that stops the access where it’s not needed: “protected”.<br></p><p>The thing is, though, the contents of the sharps drawer are *still* sharp even if you&#39;re old enough to use a knife. And similarly, APIs like the `state` setter are *still* dangerous even if you&#39;ve subclassed `UIGestureRecognizer`. To be sure, it is more likely that you&#39;ll *need* to set `state`, but it&#39;s still not something you should do carelessly or without understanding the consequences.<br></p><p>`protected` fails to acknowledge this. It conflates the act of inheriting interface and implementation with the act of gaining access to dangerous operations. It would be  like a drawer which automatically mixed the knives in with the other utensils when an adult opened it.<br></p><p>This is a general problem with traditional OO: Inheritance bundles a whole bunch of separate semantics into a single operation. Obviously some of these are so ingrained in OO that they can&#39;t be separated; you&#39;re not going to separate inheritance of interface from inheritance of implementation. But the sharps drawer does not *have* to be part of the bundle, and there are compelling reasons to look for a different solution—one which fits this use case better, *and* simultaneously serves other use cases like non-subclassed types.<br></p><p>To give you an idea, here are a couple more potential &quot;sharps drawers&quot; in UIKit which `protected` would not serve well:<br></p><p>* View controller containment. There are very few view controllers which actually contain other view controllers; for most, these calls are a great way to mess things up. And yet some of these members, like `childViewControllers`, are definitely things you need to be able to access from outside a view controller, for instance to find a view controller to present an error message on. `protected` would expose these methods to vast amounts of code that doesn&#39;t need them, while hiding them from code that does.<br></p><p>* UIKeyInput and UITextInput methods should only be used by custom keyboards (either `inputView`s or keyboard extensions), but they&#39;re exposed to everybody, sitting right alongside methods intended for wide use. The intended clients for these APIs have no inheritance relationship whatsoever with the classes they would need to call them on, so `protected` would be of absolutely no help here.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 30, 2016 at 01:00:00am</p></header><div class="content"><p>&gt; On May 28, 2016, at 8:11 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; But `protected` is quite different from other access levels; it does not limit the visibility of the symbols, but rather their use. And protocols face the same sort of problem as classes, where certain members are essentially override hooks and shouldn&#39;t be called directly outside a particular scope.<br>&gt; <br>&gt; So I think we ought to allow `accesslevel(call)`, but not a plain `accesslevel`:<br>&gt; <br>&gt; 	public fileprivate(call) func layoutSubviews()<br>&gt; 	internal fileprivate(call) func privateSubclassingHook()<br>&gt; 	public internal(set: call) var x = 20<br>&gt; 	internal(call) func protocolConformanceHook()<br>&gt; 	fileprivate(set: call) var onlyProtocolSetsThis: Int { get set }<br></p><p><br>Given that this is almost identical to the pitch I floated to the list some months ago, all the way down to the fileprivate(call) syntax (well, back then “fileprivate” was “private”, so it was private(call)), I’m +1 on this.<br></p><p>&gt; On May 29, 2016, at 6:55 PM, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The thing is, though, the contents of the sharps drawer are *still* sharp even if you&#39;re old enough to use a knife. And similarly, APIs like the `state` setter are *still* dangerous even if you&#39;ve subclassed `UIGestureRecognizer`. To be sure, it is more likely that you&#39;ll *need* to set `state`, but it&#39;s still not something you should do carelessly or without understanding the consequences.<br></p><p><br>This, though, reads like “The 17-year-old might cut himself with a knife, even though he *needs* the knives to help with the cooking. So, let’s give knives to the newborn!”<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/accba957/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d8867167dba9b648c6d0746a67bbc721?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Goffredo Marocchi</string> &lt;panajev at gmail.com&gt;<p>May 29, 2016 at 12:00:00pm</p></header><div class="content"><p>Sent from my iPhone<br></p><p>&gt; On 29 May 2016, at 11:30, Brent Royal-Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; There is nothing magical about being a subclass that ought to grant access to those methods<br></p><p>Hello Brent,<br></p><p>You must admit that when thinking about the words inheritance and parent/child classes the mind wanders to suggest the contrary actually. I know it is a personal loaded opinion, but I think having private headers to expose properties, variables, and methods to subclasses as leading to poor looking code generally (one must also keep in mind teams composed of less than pure elite coders) and in itself I have never liked the concept. <br></p><p>Subclassing with abstract methods and protected access always felt natural and I think we should give that power to those who use Swift rather than tie OOP&#39;s arms a bit behind its back. It would be wrong if this were to happen in order to push people down to functional or POP approaches just because subclassing can be abused. <br>I have always felt that we should give better options rather than restricting what we feel it may be abused (yet useful if used correctly).<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 29, 2016 at 07:00:00pm</p></header><div class="content"><p>I&#39;m not opposed to the idea of finer-grained access levels in general, but if the current system is extended, the change imho should be more &quot;holistic&quot;:<br>Right now, class hierarchy has no effect on accessibility, and it feels odd to have access level that is different from the others.<br>Doing so would rise questions like &quot;why it is not possible to have a method that can be called from the current module, and from subclasses?&quot;.<br></p><p>There are several scenarios that can&#39;t be modeled in Swift now, and that still couldn&#39;t be modeled with a new &quot;protected&quot;-level (especially methods that can&#39;t be called from outside, but can be overridden by subclasses could be very useful).<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>May 29, 2016 at 06:00:00pm</p></header><div class="content"><p>Thank you all for your comments. :-)<br></p><p>Well... My goal is to keep the thing really simple and do not start a new<br>&quot;OOP x POP&quot; (or &quot;something&quot; x &quot;other thing&quot;) war.<br></p><p>&quot;Protected&quot; access level is not a new concept at all (except for the Swift<br>language), so I did not propose anything preposterous.<br></p><p>Of course in the Swift of my dreams we also have &quot;abstract&quot; access level<br>modifier, &quot;protected&quot; access level, *real* &quot;private&quot; access level and<br>&quot;file&quot; access level modifier (along with many, many other things, of<br>course). But this proposal is not about this. It is only about include the<br>&quot;protected&quot; access level.<br></p><p>There is, however, something that I need to get off my chest: I really<br>would like to have the freedom to go to the depths with protocols as well<br>with classes. I work in real apps everyday that uses Cocoa frameworks<br>(based on classes) and these apps must be shipped and I like them well<br>written. Maybe am I insane for proposing a better support for classes in<br>Swift? If so, this explains why every time I suggest better support for<br>classes in Swift there is an endless discussion and someone proclaims the<br>death of OOP and is it. OK... Maybe someday we will not have more classes<br>in Swift. Until there: the current language status is the best way to<br>handle OOP in Swift? Or is there a better way? I think there is.<br></p><p><br>Regards,<br></p><p>Vanderlei Martinelli<br></p><p><br></p><p><br>&gt;<br>&gt;<br></p><p>On Sat, May 28, 2016 at 7:52 PM, Vanderlei Martinelli &lt;<br>vmartinelli at alecrim.com&gt; wrote:<br></p><p>&gt; Hello.<br>&gt;<br>&gt;<br>&gt; This is the first draft. I&#39;d like to know your opinion about it.<br>&gt;<br>&gt; (I know that this subject could have been discussed before. If so, please<br>&gt; indicate me the correct thread to follow and interact.)<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Vanderlei Martinelli<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt;<br>&gt; Introduction<br>&gt;<br>&gt; Protected access level will enable entities to be used within the<br>&gt; container type and by derived types only.<br>&gt; Motivation<br>&gt;<br>&gt; Today Swift has three access levels (public, internal and private), but<br>&gt; lacks a way to describe a member that can be only visible to its type or<br>&gt; derived types.<br>&gt;<br>&gt; A common case is the UIView from UIKit. Many developers are tempted to<br>&gt; make this call:<br>&gt;<br>&gt; view.layoutSubviews()<br>&gt;<br>&gt; The documentation says: &quot;You should not call this method directly. If you<br>&gt; want to force a layout update, call the setNeedsLayoutmethod instead to<br>&gt; do so prior to the next drawing update. If you want to update the layout of<br>&gt; your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;<br>&gt; But yes, you should call this method directly if you are subclassing the<br>&gt; view and needs to perform additional layout to its subviews (&quot;subclasses<br>&gt; can override this method as needed&quot;):<br>&gt;<br>&gt; public override func layoutSubviews() {<br>&gt;     // We are calling the super method directly here.<br>&gt;     super.layoutSubviews()<br>&gt;<br>&gt;     // Do more adjustments to this view&#39;s subviews...}<br>&gt;<br>&gt; So, yes, we can call this method directly when subclassing, but the Swift<br>&gt; compiler will not prevent you from do this when not subclassing or from any<br>&gt; other foreign class. It will not even issue a warning.<br>&gt;<br>&gt; In Objective-C problems like this are usually &quot;solved&quot; my adding a kind of<br>&gt; &quot;protected&quot; header (.h) that is intended to be included only when the<br>&gt; developer is subclassing. In Swift we do not have headers, but we have the<br>&gt; new access level model. So, if the declaration of this method was...<br>&gt;<br>&gt; protected func layoutSubviews()<br>&gt;<br>&gt; ... no one outside the class or derived classes would be allowed to call<br>&gt; this method directly.<br>&gt;<br>&gt; Of course, there are other cases in the Cocoa frameworks and there are<br>&gt; many other cases when we are developing software in Swift that the<br>&gt; protected access level would be very usefull.<br>&gt; Proposed solution<br>&gt;<br>&gt; Create the protected access level.<br>&gt; Detailed designReference Types (classes)<br>&gt;<br>&gt; When declarated by a class the protected member will be visible to the<br>&gt; class itself and all the derived classes.<br>&gt;<br>&gt; // BaseClass.swiftpublic class BaseClass {<br>&gt;     public protected(set) var x = 20<br>&gt;     protected let y = 10<br>&gt;<br>&gt;     protected func doSomething() {<br>&gt;         // ...<br>&gt;     }}<br>&gt; // DerivedClass.swiftpublic class DerivedClass: BaseClass {<br>&gt;     protected override doSomething() {<br>&gt;         self.x = 10 * self.y<br>&gt;     }}<br>&gt;<br>&gt; If the member is declared as final then it will be visible but not can be<br>&gt; overrided by the derived classes. Just like it works with other access<br>&gt; levels.<br>&gt; Value Types (structs, enums, etc.)<br>&gt;<br>&gt; Value types cannot have derived types. In this case the protected access<br>&gt; level does not make sense and will not be allowed in their members.<br>&gt; Protocols<br>&gt;<br>&gt; Protocols do not declare access level for their members. So the protected access<br>&gt; level is not applicable here.<br>&gt; Extensions<br>&gt;<br>&gt; Extensions will not be able do be protected nor their members.<br>&gt; Special Note<br>&gt;<br>&gt; The protected access level can only be applied to classes, structs and<br>&gt; other types when nested inside other type. So the following code will not<br>&gt; compile:<br>&gt;<br>&gt; // ERROR: A first level class cannot be protected.<br>&gt; protected class MyProtectedClass {<br>&gt;     /// ...}<br>&gt;<br>&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;<br>&gt; // We can declare a protected class (or struct, enum, etc.) if// and only if they are nested inside other type.public class MyPublicClass {<br>&gt;     protected class MyProtectedClass {<br>&gt;         /// ...<br>&gt;     }}<br>&gt; // Since `MyProtectedClass` is nested and protected we// can have access to it here.public class MyDerivedClass: MyPublicClass {<br>&gt;     public func doSomething() {<br>&gt;         let c = MyProtectedClass()<br>&gt;<br>&gt;         /// ...<br>&gt;     }}<br>&gt;<br>&gt; Impact on existing code<br>&gt;<br>&gt; The imported Cocoa frameworks may have annotations on the &quot;Objective-C<br>&gt; side&quot; that will inform if one member is protected. If this will be case<br>&gt; (for the layoutSubviews method, as example), only code accessing these<br>&gt; now protected members outside the owner class and its derived classes will<br>&gt; have to change (currently this can be considered an error, anyway).<br>&gt;<br>&gt; Any other code will be not impacted by this feature as it is new to the<br>&gt; language.<br>&gt; Alternatives considered<br>&gt;<br>&gt; Do not add the protected access level to the current model.<br>&gt;<br>&gt;<br>&gt; ---<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/494ad820/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d02ed1b20fc3e0fa1592ce5982f24d2b?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Leonardo Pessoa</string> &lt;me at lmpessoa.com&gt;<p>May 29, 2016 at 07:00:00pm</p></header><div class="content"><p>Vanderlei, my point in bringing such topics to this discussion is to make everyone here think if we&#39;re trying to really enhance the language within its intended purpose or if we&#39;re trying to change the language into something else were familiar with from other languages we work/ed with just because we&#39;re used to work like that. I just started thinking about this today and just cannot stop now. No intention to start a war here but I think everyone should ask themselves this for every proposed change to the language.<br></p><p>About the topic at-hand, we have to remember Swift is bridged to Objective-C, which has no protected (or abstract). How do you propose these protected members be bridged should the proposal pass?<br></p><p><br>-----Original Message-----<br>From: &quot;Vanderlei Martinelli via swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Sent: ‎29/‎05/‎2016 06:56 PM<br>To: &quot;swift-evolution&quot; &lt;swift-evolution at swift.org&gt;<br>Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br></p><p>Thank you all for your comments. :-)<br></p><p><br>Well... My goal is to keep the thing really simple and do not start a new &quot;OOP x POP&quot; (or &quot;something&quot; x &quot;other thing&quot;) war.<br></p><p><br>&quot;Protected&quot; access level is not a new concept at all (except for the Swift language), so I did not propose anything preposterous.<br></p><p><br></p><p>Of course in the Swift of my dreams we also have &quot;abstract&quot; access level modifier, &quot;protected&quot; access level, *real* &quot;private&quot; access level and &quot;file&quot; access level modifier (along with many, many other things, of course). But this proposal is not about this. It is only about include the &quot;protected&quot; access level.<br></p><p><br>There is, however, something that I need to get off my chest: I really would like to have the freedom to go to the depths with protocols as well with classes. I work in real apps everyday that uses Cocoa frameworks (based on classes) and these apps must be shipped and I like them well written. Maybe am I insane for proposing a better support for classes in Swift? If so, this explains why every time I suggest better support for classes in Swift there is an endless discussion and someone proclaims the death of OOP and is it. OK... Maybe someday we will not have more classes in Swift. Until there: the current language status is the best way to handle OOP in Swift? Or is there a better way? I think there is.<br></p><p><br></p><p><br>Regards,<br></p><p><br>Vanderlei Martinelli<br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br>On Sat, May 28, 2016 at 7:52 PM, Vanderlei Martinelli &lt;vmartinelli at alecrim.com&gt; wrote:<br></p><p>Hello.<br></p><p><br></p><p><br>This is the first draft. I&#39;d like to know your opinion about it.<br></p><p><br>(I know that this subject could have been discussed before. If so, please indicate me the correct thread to follow and interact.)<br></p><p><br></p><p><br>Regards,<br></p><p><br>Vanderlei Martinelli<br></p><p><br></p><p><br>---<br></p><p><br></p><p><br>Introduction<br>Protected access level will enable entities to be used within the container type and by derived types only.<br>Motivation<br>Today Swift has three access levels (public, internal and private), but lacks a way to describe a member that can be only visible to its type or derived types.<br>A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>view.layoutSubviews()The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>But yes, you should call this method directly if you are subclassing the view and needs to perform additional layout to its subviews (&quot;subclasses can override this method as needed&quot;):<br>public override func layoutSubviews() {<br>    // We are calling the super method directly here.<br>    super.layoutSubviews()<br>    <br>    // Do more adjustments to this view&#39;s subviews...<br>}So, yes, we can call this method directly when subclassing, but the Swift compiler will not prevent you from do this when not subclassing or from any other foreign class. It will not even issue a warning.<br>In Objective-C problems like this are usually &quot;solved&quot; my adding a kind of &quot;protected&quot; header (.h) that is intended to be included only when the developer is subclassing. In Swift we do not have headers, but we have the new access level model. So, if the declaration of this method was...<br>protected func layoutSubviews()... no one outside the class or derived classes would be allowed to call this method directly.<br>Of course, there are other cases in the Cocoa frameworks and there are many other cases when we are developing software in Swift that the protected access level would be very usefull.<br>Proposed solution<br>Create the protected access level.<br>Detailed design<br>Reference Types (classes)<br>When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>// BaseClass.swift<br>public class BaseClass {<br>    public protected(set) var x = 20<br>    protected let y = 10<br>    <br>    protected func doSomething() {<br>        // ...<br>    }<br>}<br></p><p>// DerivedClass.swift<br>public class DerivedClass: BaseClass {<br>    protected override doSomething() {<br>        self.x = 10 * self.y<br>    }<br>}If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>Value Types (structs, enums, etc.)<br>Value types cannot have derived types. In this case the protected access level does not make sense and will not be allowed in their members.<br>Protocols<br>Protocols do not declare access level for their members. So the protected�<br></p><p>[The entire original message is not included.]<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/9d6a729b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 30, 2016 at 09:00:00am</p></header><div class="content"><p>I agree that we should be looking for what makes sense, not just what we’ve seen in other languages. That said, there seems a lot of hate for OOP in general that seems to be clouding people’s vision here.<br></p><p>I think that “protected” as a form of access control is exactly what we want: rights that subclasses should be allowed, but other classes should not. Generally they refer to internal state that only the class itself, or its subclass, has any business either updating or calling.<br></p><p>Lets drop the word “protected” for a second and actually examine the use cases for differing access control in classes. I think the best example of this in different contexts are:<br></p><p>1. Methods and properties that only subclasses must access, but other code has no business updating. An example of this UIGestureRecognizer. State machine type access is something where external items should not access, but internal state may require the rights to update.<br></p><p>2. Methods and properties that should be overridable, but are helper methods and shouldn’t be called by external methods, and perhaps shouldn’t be even called directly. This includes -layoutSubviews on UIView, a multitude of other methods in UIKit, etc. Thus I think Brent had a good point that calling a method might need to have different access rights to overriding it.<br></p><p>I think #1 shows specifically the need for access control for subclasses only, and thus a ‘protected’- style access control level.<br>I think #2 shows a need to differentiate the access rights of calling a method from access rights to see or override the method.<br></p><p>While we can find workarounds that obfuscate access, these aren’t access controls, they’re convoluted workarounds to avoid correcting our access control rules in the first place.<br></p><p>How do these things bridge into Objective-C?<br>Protected doesn’t make sense in Objective-C. You cannot subclass a Swift Class in Objective C, so overriding is irrelevant. I suspect the rule should be simple: Anything Protected should not be visible to Objective-C, much like private is hidden currently.<br></p><p>- Rod<br></p><p><br>&gt; On 30 May 2016, at 8:45 AM, Leonardo Pessoa via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Vanderlei, my point in bringing such topics to this discussion is to make everyone here think if we&#39;re trying to really enhance the language within its intended purpose or if we&#39;re trying to change the language into something else were familiar with from other languages we work/ed with just because we&#39;re used to work like that. I just started thinking about this today and just cannot stop now. No intention to start a war here but I think everyone should ask themselves this for every proposed change to the language.<br>&gt; <br>&gt; About the topic at-hand, we have to remember Swift is bridged to Objective-C, which has no protected (or abstract). How do you propose these protected members be bridged should the proposal pass?<br>&gt; From: Vanderlei Martinelli via swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Sent: ‎29/‎05/‎2016 06:56 PM<br>&gt; To: swift-evolution &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br>&gt; <br>&gt; Thank you all for your comments. :-)<br>&gt; <br>&gt; Well... My goal is to keep the thing really simple and do not start a new &quot;OOP x POP&quot; (or &quot;something&quot; x &quot;other thing&quot;) war.<br>&gt; <br>&gt; &quot;Protected&quot; access level is not a new concept at all (except for the Swift language), so I did not propose anything preposterous.<br>&gt; <br>&gt; Of course in the Swift of my dreams we also have &quot;abstract&quot; access level modifier, &quot;protected&quot; access level, *real* &quot;private&quot; access level and &quot;file&quot; access level modifier (along with many, many other things, of course). But this proposal is not about this. It is only about include the &quot;protected&quot; access level.<br>&gt; <br>&gt; There is, however, something that I need to get off my chest: I really would like to have the freedom to go to the depths with protocols as well with classes. I work in real apps everyday that uses Cocoa frameworks (based on classes) and these apps must be shipped and I like them well written. Maybe am I insane for proposing a better support for classes in Swift? If so, this explains why every time I suggest better support for classes in Swift there is an endless discussion and someone proclaims the death of OOP and is it. OK... Maybe someday we will not have more classes in Swift. Until there: the current language status is the best way to handle OOP in Swift? Or is there a better way? I think there is.<br>&gt; <br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; Vanderlei Martinelli<br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; <br>&gt; On Sat, May 28, 2016 at 7:52 PM, Vanderlei Martinelli &lt;vmartinelli at alecrim.com &lt;mailto:vmartinelli at alecrim.com&gt;&gt; wrote:<br>&gt; Hello.<br>&gt; <br>&gt; <br>&gt; This is the first draft. I&#39;d like to know your opinion about it.<br>&gt; <br>&gt; (I know that this subject could have been discussed before. If so, please indicate me the correct thread to follow and interact.)<br>&gt; <br>&gt; <br>&gt; Regards,<br>&gt; <br>&gt; Vanderlei Martinelli<br>&gt; <br>&gt; <br>&gt; ---<br>&gt; <br>&gt; <br>&gt; Introduction<br>&gt; Protected access level will enable entities to be used within the container type and by derived types only.<br>&gt; <br>&gt; Motivation<br>&gt; Today Swift has three access levels (public, internal and private), but lacks a way to describe a member that can be only visible to its type or derived types.<br>&gt; <br>&gt; A common case is the UIView from UIKit. Many developers are tempted to make this call:<br>&gt; <br>&gt; view.layoutSubviews()<br>&gt; The documentation says: &quot;You should not call this method directly. If you want to force a layout update, call the setNeedsLayoutmethod instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>&gt; <br>&gt; But yes, you should call this method directly if you are subclassing the view and needs to perform additional layout to its subviews (&quot;subclasses can override this method as needed&quot;):<br>&gt; <br>&gt; public override func layoutSubviews() {<br>&gt;     // We are calling the super method directly here.<br>&gt;     super.layoutSubviews()<br>&gt;     <br>&gt;     // Do more adjustments to this view&#39;s subviews...<br>&gt; }<br>&gt; So, yes, we can call this method directly when subclassing, but the Swift compiler will not prevent you from do this when not subclassing or from any other foreign class. It will not even issue a warning.<br>&gt; <br>&gt; In Objective-C problems like this are usually &quot;solved&quot; my adding a kind of &quot;protected&quot; header (.h) that is intended to be included only when the developer is subclassing. In Swift we do not have headers, but we have the new access level model. So, if the declaration of this method was...<br>&gt; <br>&gt; protected func layoutSubviews()<br>&gt; ... no one outside the class or derived classes would be allowed to call this method directly.<br>&gt; <br>&gt; Of course, there are other cases in the Cocoa frameworks and there are many other cases when we are developing software in Swift that the protected access level would be very usefull.<br>&gt; <br>&gt; Proposed solution<br>&gt; Create the protected access level.<br>&gt; <br>&gt; Detailed design<br>&gt; Reference Types (classes)<br>&gt; <br>&gt; When declarated by a class the protected member will be visible to the class itself and all the derived classes.<br>&gt; <br>&gt; // BaseClass.swift<br>&gt; public class BaseClass {<br>&gt;     public protected(set) var x = 20<br>&gt;     protected let y = 10<br>&gt;     <br>&gt;     protected func doSomething() {<br>&gt;         // ...<br>&gt;     }<br>&gt; }<br>&gt; <br>&gt; // DerivedClass.swift<br>&gt; public class DerivedClass: BaseClass {<br>&gt;     protected override doSomething() {<br>&gt;         self.x = 10 * self.y<br>&gt;     }<br>&gt; }<br>&gt; If the member is declared as final then it will be visible but not can be overrided by the derived classes. Just like it works with other access levels.<br>&gt; <br>&gt; Value Types (structs, enums, etc.)<br>&gt; <br>&gt; Value types cannot have derived types. In this case the protected access level does not make sense and will not be allowed in their members.<br>&gt; <br>&gt; Protocols<br>&gt; <br>&gt; Protocols do not declare access level for their members. So the protected�<br>&gt; <br>&gt; <br>&gt; [The entire original message is not included.]<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/08307ae9/attachment-0001.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>May 29, 2016 at 05:00:00pm</p></header><div class="content"><p>&gt; 1. Methods and properties that only subclasses must access, but other code has no business updating. An example of this UIGestureRecognizer. State machine type access is something where external items should not access, but internal state may require the rights to update.<br></p><p>But again, &quot;external&quot; does not necessarily mean &quot;non-subclass&quot;, and &quot;internal&quot; does not necessarily mean &quot;subclass&quot;. A particular subclass might not require access, and a helper type/function might require access.<br></p><p>This insight—that the type graph doesn&#39;t always reflect the boundaries of concerns—is the very basis of Swift&#39;s current access control design. It&#39;s the reason why `private` (soon to become `fileprivate`) doesn&#39;t grant visibility to extensions on the same type in different files, but *does* grant it to extensions on different types in the same file. This is an important innovation in Swift&#39;s access control design, and we shouldn&#39;t ignore it when we&#39;re thinking about `protected`.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 30, 2016 at 10:00:00am</p></header><div class="content"><p>Brent,<br></p><p>You make a very good point about the fact internal is not necessarily the same as subclass, something I hadn’t considered.<br></p><p>I think that the level of exposure these APIs then get - ultimately Public within frameworks - is too unrestricted. At least in Objective-C, we can vet the headers to break classes into separate sections where we don’t disclose certain headers to show something by default. Can we think of a way to allow opt-in access?<br></p><p>This ultimately gets into one of my major sore points with Swift: Framework Generated Headers suck. The Framework story for Swift seems shockingly ill conceived at this time. I could never imagine Apple shipping a framework with the current Framework setup… but I’m going into the weeds...<br></p><p>-Rod<br></p><p><br>&gt; On 30 May 2016, at 10:03 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; 1. Methods and properties that only subclasses must access, but other code has no business updating. An example of this UIGestureRecognizer. State machine type access is something where external items should not access, but internal state may require the rights to update.<br>&gt; <br>&gt; But again, &quot;external&quot; does not necessarily mean &quot;non-subclass&quot;, and &quot;internal&quot; does not necessarily mean &quot;subclass&quot;. A particular subclass might not require access, and a helper type/function might require access.<br>&gt; <br>&gt; This insight—that the type graph doesn&#39;t always reflect the boundaries of concerns—is the very basis of Swift&#39;s current access control design. It&#39;s the reason why `private` (soon to become `fileprivate`) doesn&#39;t grant visibility to extensions on the same type in different files, but *does* grant it to extensions on different types in the same file. This is an important innovation in Swift&#39;s access control design, and we shouldn&#39;t ignore it when we&#39;re thinking about `protected`.<br>&gt; <br>&gt; -- <br>&gt; Brent Royal-Gordon<br>&gt; Architechies<br>&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 29, 2016 at 09:00:00pm</p></header><div class="content"><p>I&#39;ve written up how to provide protected access control for Swift code<br>today here:<br></p><p>http://www.callionica.com/developer/#swift-protected<br></p><p>No compiler changes necessary for this technique and it distinguishes<br>between methods that can only be overridden and methods that can be both<br>called and overridden.<br>​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/cd4e61b0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>May 30, 2016 at 07:00:00am</p></header><div class="content"><p>Cool!<br></p><p>-Thorsten <br></p><p>&gt; Am 30.05.2016 um 06:49 schrieb Callionica (Swift) via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; I&#39;ve written up how to provide protected access control for Swift code today here:<br>&gt; <br>&gt; http://www.callionica.com/developer/#swift-protected<br>&gt; <br>&gt; No compiler changes necessary for this technique and it distinguishes between methods that can only be overridden and methods that can be both called and overridden.<br>&gt; ​<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/a3d253f5/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3b3f5abbe48b7127e20fd69808c714bf?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charlie Monroe</string> &lt;charlie at charliemonroe.net&gt;<p>May 30, 2016 at 07:00:00am</p></header><div class="content"><p>That&#39;s a nice workaround - but nice in a sense that that it&#39;s a hack, not a solution IMHO.<br></p><p><br>&gt; On May 30, 2016, at 6:49 AM, Callionica (Swift) via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I&#39;ve written up how to provide protected access control for Swift code today here:<br>&gt; <br>&gt; http://www.callionica.com/developer/#swift-protected &lt;http://www.callionica.com/developer/#swift-protected&gt;<br>&gt; <br>&gt; No compiler changes necessary for this technique and it distinguishes between methods that can only be overridden and methods that can be both called and overridden.<br>&gt; ​<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/48a41b31/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e9b374b9587bd8da1a1a027c8716ac0d?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Rod Brown</string> &lt;rodney.brown6 at icloud.com&gt;<p>May 30, 2016 at 03:00:00pm</p></header><div class="content"><p>I have to agree with Charlie Monroe that while this is doable, it&#39;s clear this is a workaround to a problem, not a viable long term language solution.<br></p><p>- Rod<br></p><p><br></p><p>Sent from my iPhone<br>&gt; On 30 May 2016, at 2:49 PM, Callionica (Swift) &lt;swift-callionica at callionica.com&gt; wrote:<br>&gt; <br>&gt; I&#39;ve written up how to provide protected access control for Swift code today here:<br>&gt; <br>&gt; http://www.callionica.com/developer/#swift-protected<br>&gt; <br>&gt; No compiler changes necessary for this technique and it distinguishes between methods that can only be overridden and methods that can be both called and overridden.<br>&gt; ​<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/9b765f53/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 30, 2016 at 01:00:00pm</p></header><div class="content"><p>It might be worth being more specific with your comparison between the<br>&quot;lock and key&quot; access control I described and the other techniques<br>described in this thread. Given that the designers of Swift were familiar<br>with protected access level from other languages and deliberately chose to<br>exclude it, it seems likely that you&#39;ll need to give some detailed pros and<br>cons to get a protected access level accepted I think.<br></p><p>I don&#39;t personally have an opinion on whether protected is a compelling<br>addition to the Swift language. It&#39;s in some of the languages that I use<br>and not others. I use it extensively where available, but it&#39;s not a<br>compelling enough feature on its own to make me choose one language over<br>another. I just wanted to make sure that people were aware of some other<br>techniques available for implementation hiding that are available in the<br>language today. (There are many more than just the one I presented if<br>you&#39;re willing to take a small runtime cost).<br></p><p>-- Callionica<br></p><p>On Sun, May 29, 2016 at 10:59 PM, Rod Brown &lt;rodney.brown6 at icloud.com&gt;<br>wrote:<br></p><p>&gt; I have to agree with Charlie Monroe that while this is doable, it&#39;s clear<br>&gt; this is a workaround to a problem, not a viable long term language solution.<br>&gt;<br>&gt; - Rod<br>&gt;<br>&gt;<br>&gt;<br>&gt; Sent from my iPhone<br>&gt; On 30 May 2016, at 2:49 PM, Callionica (Swift) &lt;<br>&gt; swift-callionica at callionica.com&gt; wrote:<br>&gt;<br>&gt; I&#39;ve written up how to provide protected access control for Swift code<br>&gt; today here:<br>&gt;<br>&gt; http://www.callionica.com/developer/#swift-protected<br>&gt;<br>&gt; No compiler changes necessary for this technique and it distinguishes<br>&gt; between methods that can only be overridden and methods that can be both<br>&gt; called and overridden.<br>&gt; ​<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/e2076364/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/e0a5152b275c43b493a94b5a6a868905?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Pyry Jahkola</string> &lt;pyry.jahkola at iki.fi&gt;<p>May 30, 2016 at 09:00:00am</p></header><div class="content"><p>That&#39;s a cool hack! For a lighter way to distinguish overridable methods that one shouldn&#39;t ordinarily call, did anyone consider approximating &quot;protected&quot; (or as called in Objective-C speak, &quot;private extension&quot;) methods with public class methods?<br></p><p>    public class UIView {<br>        public class func _layoutSubviews(_ view: UIView)<br>    }<br></p><p>This way, they become overridable, won&#39;t show up in the editor auto completion list for a given instance, and can be called… but definitely make you think twice before you do!<br></p><p>— Pyry<br></p><p>&gt; Callionica (Swift) via swift-evolution &lt;swift-evolution at swift.org&gt; kirjoitti 30.5.2016 kello 7.49:<br>&gt; <br>&gt; I&#39;ve written up how to provide protected access control for Swift code today here:<br>&gt; <br>&gt; http://www.callionica.com/developer/#swift-protected<br>&gt; <br>&gt; No compiler changes necessary for this technique and it distinguishes between methods that can only be overridden and methods that can be both called and overridden.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/e2e86e03/attachment.html&gt;<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/697f00e1b9be900f24cd1669cc931874?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>L. Mihalkovic</string> &lt;laurent.mihalkovic at gmail.com&gt;<p>May 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 2:46 AM, Rod Brown via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Brent,<br>&gt; <br>&gt; You make a very good point about the fact internal is not necessarily the same as subclass, something I hadn’t considered.<br>&gt; <br>&gt; I think that the level of exposure these APIs then get - ultimately Public within frameworks - is too unrestricted. At least in Objective-C, we can vet the headers to break classes into separate sections where we don’t disclose certain headers to show something by default. Can we think of a way to allow opt-in access?<br>&gt; <br>&gt; This ultimately gets into one of my major sore points with Swift: Framework Generated Headers suck. The Framework story for Swift seems shockingly ill conceived at this time. I could never imagine Apple shipping a framework with the current Framework setup… but I’m going into the weeds…<br></p><p>most Objc code out there is appalling when it comes to design enforcing clean API boundaries. It stems directly from the lack of scopes in the language to hide things. Over the years the language was drastically improved, but 99% of the code on github is still written like 20 years ago (minus the @synthesize). Unfortunately for swift, there is not much more choices than to have Framework = Module. A possible future improvement might be to have Framework = n-Module, but that is somehow doable if you make a multi dylib framework. The cost of creating several Swift modules inside a single framework is not light today (there would have to be one more level of section name mangling inside the dylib, something like  <br></p><p>	__xxxx__sectionA <br>	__xxxx__sectionB <br>	__xxxx__sectionC <br></p><p>	__yyyy__sectionA <br>	__yyyy__sectionB <br>	__yyyy__sectionC <br></p><p>where xxxx/yyyy are the names of the modules/namespaces sharing space inside a single dylib, compared to today&#39;s<br></p><p>	__sectionA <br>	__sectionB <br>	__sectionC <br></p><p>all things considered, it may not be that stupid… dunno it is would make lookup faster or slower if the sections were smaller. It would be backward compatible… because the current sections could be kept for the top level Module… hmmmmm… might be workable.<br></p><p>&gt; <br>&gt; -Rod<br>&gt; <br>&gt; <br>&gt;&gt; On 30 May 2016, at 10:03 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt;&gt; <br>&gt;&gt;&gt; 1. Methods and properties that only subclasses must access, but other code has no business updating. An example of this UIGestureRecognizer. State machine type access is something where external items should not access, but internal state may require the rights to update.<br>&gt;&gt; <br>&gt;&gt; But again, &quot;external&quot; does not necessarily mean &quot;non-subclass&quot;, and &quot;internal&quot; does not necessarily mean &quot;subclass&quot;. A particular subclass might not require access, and a helper type/function might require access.<br>&gt;&gt; <br>&gt;&gt; This insight—that the type graph doesn&#39;t always reflect the boundaries of concerns—is the very basis of Swift&#39;s current access control design. It&#39;s the reason why `private` (soon to become `fileprivate`) doesn&#39;t grant visibility to extensions on the same type in different files, but *does* grant it to extensions on different types in the same file. This is an important innovation in Swift&#39;s access control design, and we shouldn&#39;t ignore it when we&#39;re thinking about `protected`.<br>&gt;&gt; <br>&gt;&gt; -- <br>&gt;&gt; Brent Royal-Gordon<br>&gt;&gt; Architechies<br>&gt;&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>May 29, 2016 at 08:00:00pm</p></header><div class="content"><p>Hi Leonardo.<br></p><p>Thank you for your answer.<br></p><p>I understand your point of view and I agree that it is better to look<br>forward. But today we still have to deal with decades of legacy Cocoa code<br>written using classes. If tomorrow a new set of Cocoa frameworks written in<br>Swift using protocols appears, maybe we can forget all of this discussion.<br>But OOP is very important and don&#39;t think it is the &quot;past&quot;. I see future in<br>&quot;POP&quot; as I see in &quot;OOP&quot; and I think we can have OOP and POP living in<br>harmony in Swift. And since we have support to classes in Swift, I think it<br>shall have a full featured support for classes.<br></p><p>Perhaps my reaction in the last message sounds like I am overreacting when<br>seen in the context of this thread. But I am programming in Swift since the<br>first day it was publicly available (and I think that the first almost<br>usable version to create real world apps was the 1.2). Since the old<br>forums, when Swift was not yet open source, I have been insisting on<br>certain improvements.<br></p><p>About bridging member declarations from Objective-C, many of these classes<br>already have separated headers with the members intended to be overrided.<br>Exceptions to this rule could be &quot;annotated&quot; somehow. (I would like to<br>mention classes that are entirely intended to be subclassed and not used as<br>is in Cocoa frameworks, but this is about &quot;abstract&quot; access level modifier<br>and not part of this proposal.)<br></p><p>Regards,<br></p><p>Vanderlei Martinelli<br></p><p><br></p><p><br></p><p><br></p><p><br>On Sun, May 29, 2016 at 7:45 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br></p><p>&gt; Vanderlei, my point in bringing such topics to this discussion is to make<br>&gt; everyone here think if we&#39;re trying to really enhance the language within<br>&gt; its intended purpose or if we&#39;re trying to change the language into<br>&gt; something else were familiar with from other languages we work/ed with just<br>&gt; because we&#39;re used to work like that. I just started thinking about this<br>&gt; today and just cannot stop now. No intention to start a war here but I<br>&gt; think everyone should ask themselves this for every proposed change to the<br>&gt; language.<br>&gt;<br>&gt; About the topic at-hand, we have to remember Swift is bridged to<br>&gt; Objective-C, which has no protected (or abstract). How do you propose these<br>&gt; protected members be bridged should the proposal pass?<br>&gt; ------------------------------<br>&gt; From: Vanderlei Martinelli via swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Sent: ‎29/‎05/‎2016 06:56 PM<br>&gt; To: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt; Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br>&gt;<br>&gt; Thank you all for your comments. :-)<br>&gt;<br>&gt; Well... My goal is to keep the thing really simple and do not start a new<br>&gt; &quot;OOP x POP&quot; (or &quot;something&quot; x &quot;other thing&quot;) war.<br>&gt;<br>&gt; &quot;Protected&quot; access level is not a new concept at all (except for the Swift<br>&gt; language), so I did not propose anything preposterous.<br>&gt;<br>&gt; Of course in the Swift of my dreams we also have &quot;abstract&quot; access level<br>&gt; modifier, &quot;protected&quot; access level, *real* &quot;private&quot; access level and<br>&gt; &quot;file&quot; access level modifier (along with many, many other things, of<br>&gt; course). But this proposal is not about this. It is only about include the<br>&gt; &quot;protected&quot; access level.<br>&gt;<br>&gt; There is, however, something that I need to get off my chest: I really<br>&gt; would like to have the freedom to go to the depths with protocols as well<br>&gt; with classes. I work in real apps everyday that uses Cocoa frameworks<br>&gt; (based on classes) and these apps must be shipped and I like them well<br>&gt; written. Maybe am I insane for proposing a better support for classes in<br>&gt; Swift? If so, this explains why every time I suggest better support for<br>&gt; classes in Swift there is an endless discussion and someone proclaims the<br>&gt; death of OOP and is it. OK... Maybe someday we will not have more classes<br>&gt; in Swift. Until there: the current language status is the best way to<br>&gt; handle OOP in Swift? Or is there a better way? I think there is.<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Vanderlei Martinelli<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; On Sat, May 28, 2016 at 7:52 PM, Vanderlei Martinelli &lt;<br>&gt; vmartinelli at alecrim.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is the first draft. I&#39;d like to know your opinion about it.<br>&gt;&gt;<br>&gt;&gt; (I know that this subject could have been discussed before. If so, please<br>&gt;&gt; indicate me the correct thread to follow and interact.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt;<br>&gt;&gt; Vanderlei Martinelli<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ---<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Protected access level will enable entities to be used within the<br>&gt;&gt; container type and by derived types only.<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Today Swift has three access levels (public, internal and private), but<br>&gt;&gt; lacks a way to describe a member that can be only visible to its type or<br>&gt;&gt; derived types.<br>&gt;&gt;<br>&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to<br>&gt;&gt; make this call:<br>&gt;&gt;<br>&gt;&gt; view.layoutSubviews()<br>&gt;&gt;<br>&gt;&gt; The documentation says: &quot;You should not call this method directly. If you<br>&gt;&gt; want to force a layout update, call the setNeedsLayoutmethod instead to<br>&gt;&gt; do so prior to the next drawing update. If you want to update the layout of<br>&gt;&gt; your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;&gt;<br>&gt;&gt; But yes, you should call this method directly if you are subclassing the<br>&gt;&gt; view and needs to perform additional layout to its subviews (&quot;subclasses<br>&gt;&gt; can override this method as needed&quot;):<br>&gt;&gt;<br>&gt;&gt; public override func layoutSubviews() {<br>&gt;&gt;     // We are calling the super method directly here.<br>&gt;&gt;     super.layoutSubviews()<br>&gt;&gt;<br>&gt;&gt;     // Do more adjustments to this view&#39;s subviews...}<br>&gt;&gt;<br>&gt;&gt; So, yes, we can call this method directly when subclassing, but the Swift<br>&gt;&gt; compiler will not prevent you from do this when not subclassing or from any<br>&gt;&gt; other foreign class. It will not even issue a warning.<br>&gt;&gt;<br>&gt;&gt; In Objective-C problems like this are usually &quot;solved&quot; my adding a kind<br>&gt;&gt; of &quot;protected&quot; header (.h) that is intended to be included only when the<br>&gt;&gt; developer is subclassing. In Swift we do not have headers, but we have the<br>&gt;&gt; new access level model. So, if the declaration of this method was...<br>&gt;&gt;<br>&gt;&gt; protected func layoutSubviews()<br>&gt;&gt;<br>&gt;&gt; ... no one outside the class or derived classes would be allowed to call<br>&gt;&gt; this method directly.<br>&gt;&gt;<br>&gt;&gt; Of course, there are other cases in the Cocoa frameworks and there are<br>&gt;&gt; many other cases when we are developing software in Swift that the<br>&gt;&gt; protected access level would be very usefull.<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; Create the protected access level.<br>&gt;&gt; Detailed designReference Types (classes)<br>&gt;&gt;<br>&gt;&gt; When declarated by a class the protected member will be visible to the<br>&gt;&gt; class itself and all the derived classes.<br>&gt;&gt;<br>&gt;&gt; // BaseClass.swiftpublic class BaseClass {<br>&gt;&gt;     public protected(set) var x = 20<br>&gt;&gt;     protected let y = 10<br>&gt;&gt;<br>&gt;&gt;     protected func doSomething() {<br>&gt;&gt;         // ...<br>&gt;&gt;     }}<br>&gt;&gt; // DerivedClass.swiftpublic class DerivedClass: BaseClass {<br>&gt;&gt;     protected override doSomething() {<br>&gt;&gt;         self.x = 10 * self.y<br>&gt;&gt;     }}<br>&gt;&gt;<br>&gt;&gt; If the member is declared as final then it will be visible but not can<br>&gt;&gt; be overrided by the derived classes. Just like it works with other access<br>&gt;&gt; levels.<br>&gt;&gt; Value Types (structs, enums, etc.)<br>&gt;&gt;<br>&gt;&gt; Value types cannot have derived types. In this case the protected access<br>&gt;&gt; level does not make sense and will not be allowed in their members.<br>&gt;&gt; Protocols<br>&gt;&gt;<br>&gt;&gt; Protocols do not declare access level for their members. So the protected<br>&gt;&gt; �<br>&gt;&gt;<br>&gt;<br>&gt; [The entire original message is not included.]<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/fd2f3a92/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d0659d0725d0f35fa2b7d2cd23631502?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Vanderlei Martinelli</string> &lt;vmartinelli at alecrim.com&gt;<p>May 29, 2016 at 08:00:00pm</p></header><div class="content"><p>I missed the last part when you are talking about bridging TO Objective-C,<br>but Rod Brown answered that very well (thanks).<br></p><p>-Van<br></p><p>On Sun, May 29, 2016 at 8:50 PM, Vanderlei Martinelli &lt;<br>vmartinelli at alecrim.com&gt; wrote:<br></p><p>&gt; Hi Leonardo.<br>&gt;<br>&gt; Thank you for your answer.<br>&gt;<br>&gt; I understand your point of view and I agree that it is better to look<br>&gt; forward. But today we still have to deal with decades of legacy Cocoa code<br>&gt; written using classes. If tomorrow a new set of Cocoa frameworks written in<br>&gt; Swift using protocols appears, maybe we can forget all of this discussion.<br>&gt; But OOP is very important and don&#39;t think it is the &quot;past&quot;. I see future in<br>&gt; &quot;POP&quot; as I see in &quot;OOP&quot; and I think we can have OOP and POP living in<br>&gt; harmony in Swift. And since we have support to classes in Swift, I think it<br>&gt; shall have a full featured support for classes.<br>&gt;<br>&gt; Perhaps my reaction in the last message sounds like I am overreacting when<br>&gt; seen in the context of this thread. But I am programming in Swift since the<br>&gt; first day it was publicly available (and I think that the first almost<br>&gt; usable version to create real world apps was the 1.2). Since the old<br>&gt; forums, when Swift was not yet open source, I have been insisting on<br>&gt; certain improvements.<br>&gt;<br>&gt; About bridging member declarations from Objective-C, many of these classes<br>&gt; already have separated headers with the members intended to be overrided.<br>&gt; Exceptions to this rule could be &quot;annotated&quot; somehow. (I would like to<br>&gt; mention classes that are entirely intended to be subclassed and not used as<br>&gt; is in Cocoa frameworks, but this is about &quot;abstract&quot; access level modifier<br>&gt; and not part of this proposal.)<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Vanderlei Martinelli<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt; On Sun, May 29, 2016 at 7:45 PM, Leonardo Pessoa &lt;me at lmpessoa.com&gt; wrote:<br>&gt;<br>&gt;&gt; Vanderlei, my point in bringing such topics to this discussion is to make<br>&gt;&gt; everyone here think if we&#39;re trying to really enhance the language within<br>&gt;&gt; its intended purpose or if we&#39;re trying to change the language into<br>&gt;&gt; something else were familiar with from other languages we work/ed with just<br>&gt;&gt; because we&#39;re used to work like that. I just started thinking about this<br>&gt;&gt; today and just cannot stop now. No intention to start a war here but I<br>&gt;&gt; think everyone should ask themselves this for every proposed change to the<br>&gt;&gt; language.<br>&gt;&gt;<br>&gt;&gt; About the topic at-hand, we have to remember Swift is bridged to<br>&gt;&gt; Objective-C, which has no protected (or abstract). How do you propose these<br>&gt;&gt; protected members be bridged should the proposal pass?<br>&gt;&gt; ------------------------------<br>&gt;&gt; From: Vanderlei Martinelli via swift-evolution<br>&gt;&gt; &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; Sent: ‎29/‎05/‎2016 06:56 PM<br>&gt;&gt; To: swift-evolution &lt;swift-evolution at swift.org&gt;<br>&gt;&gt; Subject: Re: [swift-evolution] [Proposal] Protected Access Level<br>&gt;&gt;<br>&gt;&gt; Thank you all for your comments. :-)<br>&gt;&gt;<br>&gt;&gt; Well... My goal is to keep the thing really simple and do not start a new<br>&gt;&gt; &quot;OOP x POP&quot; (or &quot;something&quot; x &quot;other thing&quot;) war.<br>&gt;&gt;<br>&gt;&gt; &quot;Protected&quot; access level is not a new concept at all (except for the<br>&gt;&gt; Swift language), so I did not propose anything preposterous.<br>&gt;&gt;<br>&gt;&gt; Of course in the Swift of my dreams we also have &quot;abstract&quot; access level<br>&gt;&gt; modifier, &quot;protected&quot; access level, *real* &quot;private&quot; access level and<br>&gt;&gt; &quot;file&quot; access level modifier (along with many, many other things, of<br>&gt;&gt; course). But this proposal is not about this. It is only about include the<br>&gt;&gt; &quot;protected&quot; access level.<br>&gt;&gt;<br>&gt;&gt; There is, however, something that I need to get off my chest: I really<br>&gt;&gt; would like to have the freedom to go to the depths with protocols as well<br>&gt;&gt; with classes. I work in real apps everyday that uses Cocoa frameworks<br>&gt;&gt; (based on classes) and these apps must be shipped and I like them well<br>&gt;&gt; written. Maybe am I insane for proposing a better support for classes in<br>&gt;&gt; Swift? If so, this explains why every time I suggest better support for<br>&gt;&gt; classes in Swift there is an endless discussion and someone proclaims the<br>&gt;&gt; death of OOP and is it. OK... Maybe someday we will not have more classes<br>&gt;&gt; in Swift. Until there: the current language status is the best way to<br>&gt;&gt; handle OOP in Swift? Or is there a better way? I think there is.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt;<br>&gt;&gt; Vanderlei Martinelli<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; On Sat, May 28, 2016 at 7:52 PM, Vanderlei Martinelli &lt;<br>&gt;&gt; vmartinelli at alecrim.com&gt; wrote:<br>&gt;&gt;<br>&gt;&gt;&gt; Hello.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; This is the first draft. I&#39;d like to know your opinion about it.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; (I know that this subject could have been discussed before. If so,<br>&gt;&gt;&gt; please indicate me the correct thread to follow and interact.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Regards,<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Vanderlei Martinelli<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ---<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Introduction<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Protected access level will enable entities to be used within the<br>&gt;&gt;&gt; container type and by derived types only.<br>&gt;&gt;&gt; Motivation<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Today Swift has three access levels (public, internal and private), but<br>&gt;&gt;&gt; lacks a way to describe a member that can be only visible to its type or<br>&gt;&gt;&gt; derived types.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to<br>&gt;&gt;&gt; make this call:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; view.layoutSubviews()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; The documentation says: &quot;You should not call this method directly. If<br>&gt;&gt;&gt; you want to force a layout update, call the setNeedsLayoutmethod<br>&gt;&gt;&gt; instead to do so prior to the next drawing update. If you want to update<br>&gt;&gt;&gt; the layout of your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; But yes, you should call this method directly if you are subclassing the<br>&gt;&gt;&gt; view and needs to perform additional layout to its subviews (&quot;subclasses<br>&gt;&gt;&gt; can override this method as needed&quot;):<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; public override func layoutSubviews() {<br>&gt;&gt;&gt;     // We are calling the super method directly here.<br>&gt;&gt;&gt;     super.layoutSubviews()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     // Do more adjustments to this view&#39;s subviews...}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; So, yes, we can call this method directly when subclassing, but the<br>&gt;&gt;&gt; Swift compiler will not prevent you from do this when not subclassing or<br>&gt;&gt;&gt; from any other foreign class. It will not even issue a warning.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; In Objective-C problems like this are usually &quot;solved&quot; my adding a kind<br>&gt;&gt;&gt; of &quot;protected&quot; header (.h) that is intended to be included only when<br>&gt;&gt;&gt; the developer is subclassing. In Swift we do not have headers, but we have<br>&gt;&gt;&gt; the new access level model. So, if the declaration of this method was...<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; protected func layoutSubviews()<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; ... no one outside the class or derived classes would be allowed to call<br>&gt;&gt;&gt; this method directly.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Of course, there are other cases in the Cocoa frameworks and there are<br>&gt;&gt;&gt; many other cases when we are developing software in Swift that the<br>&gt;&gt;&gt; protected access level would be very usefull.<br>&gt;&gt;&gt; Proposed solution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Create the protected access level.<br>&gt;&gt;&gt; Detailed designReference Types (classes)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; When declarated by a class the protected member will be visible to the<br>&gt;&gt;&gt; class itself and all the derived classes.<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; // BaseClass.swiftpublic class BaseClass {<br>&gt;&gt;&gt;     public protected(set) var x = 20<br>&gt;&gt;&gt;     protected let y = 10<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;     protected func doSomething() {<br>&gt;&gt;&gt;         // ...<br>&gt;&gt;&gt;     }}<br>&gt;&gt;&gt; // DerivedClass.swiftpublic class DerivedClass: BaseClass {<br>&gt;&gt;&gt;     protected override doSomething() {<br>&gt;&gt;&gt;         self.x = 10 * self.y<br>&gt;&gt;&gt;     }}<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; If the member is declared as final then it will be visible but not can<br>&gt;&gt;&gt; be overrided by the derived classes. Just like it works with other access<br>&gt;&gt;&gt; levels.<br>&gt;&gt;&gt; Value Types (structs, enums, etc.)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Value types cannot have derived types. In this case the protected access<br>&gt;&gt;&gt; level does not make sense and will not be allowed in their members.<br>&gt;&gt;&gt; Protocols<br>&gt;&gt;&gt;<br>&gt;&gt;&gt; Protocols do not declare access level for their members. So the<br>&gt;&gt;&gt; protected�<br>&gt;&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; [The entire original message is not included.]<br>&gt;&gt;<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/407b6ee3/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 29, 2016 at 04:00:00pm</p></header><div class="content"><p>I can&#39;t reply directly to all the points in this thread, but I will just<br>say that there are ways of emulating protected in the language as it exists<br>today:<br></p><p>If the goal is to have functions that can be overridden by subclasses<br>without being called by external classes, you can create a parameter of a<br>public type with a private initializer and use it in all &quot;protected&quot; member<br>functions. No external code will be able to call such functions because<br>they cannot create an argument of the correct type.<br></p><p>If external classes need to both override and call the &quot;protected&quot; members,<br>you&#39;ll need to arrange to pass the key to derived classes which you can do<br>by taking a function as an argument to the base class initializer. The base<br>class then calls the function to pass the key to the derived class. This<br>way only parties that are able to control the function passed to the<br>initializer are able to obtain the key necessary to call the &quot;protected&quot;<br>member functions.<br></p><p>You can produce a lot of different access control mechanisms using the same<br>idea.<br></p><p>I&#39;ll write something up at http://www.callionica.com/developer in the next<br>day or so<br></p><p>-- Callionica<br></p><p>On Sun, May 29, 2016 at 2:55 PM, Vanderlei Martinelli via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Thank you all for your comments. :-)<br>&gt;<br>&gt; Well... My goal is to keep the thing really simple and do not start a new<br>&gt; &quot;OOP x POP&quot; (or &quot;something&quot; x &quot;other thing&quot;) war.<br>&gt;<br>&gt; &quot;Protected&quot; access level is not a new concept at all (except for the Swift<br>&gt; language), so I did not propose anything preposterous.<br>&gt;<br>&gt; Of course in the Swift of my dreams we also have &quot;abstract&quot; access level<br>&gt; modifier, &quot;protected&quot; access level, *real* &quot;private&quot; access level and<br>&gt; &quot;file&quot; access level modifier (along with many, many other things, of<br>&gt; course). But this proposal is not about this. It is only about include the<br>&gt; &quot;protected&quot; access level.<br>&gt;<br>&gt; There is, however, something that I need to get off my chest: I really<br>&gt; would like to have the freedom to go to the depths with protocols as well<br>&gt; with classes. I work in real apps everyday that uses Cocoa frameworks<br>&gt; (based on classes) and these apps must be shipped and I like them well<br>&gt; written. Maybe am I insane for proposing a better support for classes in<br>&gt; Swift? If so, this explains why every time I suggest better support for<br>&gt; classes in Swift there is an endless discussion and someone proclaims the<br>&gt; death of OOP and is it. OK... Maybe someday we will not have more classes<br>&gt; in Swift. Until there: the current language status is the best way to<br>&gt; handle OOP in Swift? Or is there a better way? I think there is.<br>&gt;<br>&gt;<br>&gt; Regards,<br>&gt;<br>&gt; Vanderlei Martinelli<br>&gt;<br>&gt;<br>&gt;<br>&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; On Sat, May 28, 2016 at 7:52 PM, Vanderlei Martinelli &lt;<br>&gt; vmartinelli at alecrim.com&gt; wrote:<br>&gt;<br>&gt;&gt; Hello.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; This is the first draft. I&#39;d like to know your opinion about it.<br>&gt;&gt;<br>&gt;&gt; (I know that this subject could have been discussed before. If so, please<br>&gt;&gt; indicate me the correct thread to follow and interact.)<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Regards,<br>&gt;&gt;<br>&gt;&gt; Vanderlei Martinelli<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ---<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; Introduction<br>&gt;&gt;<br>&gt;&gt; Protected access level will enable entities to be used within the<br>&gt;&gt; container type and by derived types only.<br>&gt;&gt; Motivation<br>&gt;&gt;<br>&gt;&gt; Today Swift has three access levels (public, internal and private), but<br>&gt;&gt; lacks a way to describe a member that can be only visible to its type or<br>&gt;&gt; derived types.<br>&gt;&gt;<br>&gt;&gt; A common case is the UIView from UIKit. Many developers are tempted to<br>&gt;&gt; make this call:<br>&gt;&gt;<br>&gt;&gt; view.layoutSubviews()<br>&gt;&gt;<br>&gt;&gt; The documentation says: &quot;You should not call this method directly. If you<br>&gt;&gt; want to force a layout update, call the setNeedsLayoutmethod instead to<br>&gt;&gt; do so prior to the next drawing update. If you want to update the layout of<br>&gt;&gt; your views immediately, call the layoutIfNeeded method.&quot;<br>&gt;&gt;<br>&gt;&gt; But yes, you should call this method directly if you are subclassing the<br>&gt;&gt; view and needs to perform additional layout to its subviews (&quot;subclasses<br>&gt;&gt; can override this method as needed&quot;):<br>&gt;&gt;<br>&gt;&gt; public override func layoutSubviews() {<br>&gt;&gt;     // We are calling the super method directly here.<br>&gt;&gt;     super.layoutSubviews()<br>&gt;&gt;<br>&gt;&gt;     // Do more adjustments to this view&#39;s subviews...}<br>&gt;&gt;<br>&gt;&gt; So, yes, we can call this method directly when subclassing, but the Swift<br>&gt;&gt; compiler will not prevent you from do this when not subclassing or from any<br>&gt;&gt; other foreign class. It will not even issue a warning.<br>&gt;&gt;<br>&gt;&gt; In Objective-C problems like this are usually &quot;solved&quot; my adding a kind<br>&gt;&gt; of &quot;protected&quot; header (.h) that is intended to be included only when the<br>&gt;&gt; developer is subclassing. In Swift we do not have headers, but we have the<br>&gt;&gt; new access level model. So, if the declaration of this method was...<br>&gt;&gt;<br>&gt;&gt; protected func layoutSubviews()<br>&gt;&gt;<br>&gt;&gt; ... no one outside the class or derived classes would be allowed to call<br>&gt;&gt; this method directly.<br>&gt;&gt;<br>&gt;&gt; Of course, there are other cases in the Cocoa frameworks and there are<br>&gt;&gt; many other cases when we are developing software in Swift that the<br>&gt;&gt; protected access level would be very usefull.<br>&gt;&gt; Proposed solution<br>&gt;&gt;<br>&gt;&gt; Create the protected access level.<br>&gt;&gt; Detailed designReference Types (classes)<br>&gt;&gt;<br>&gt;&gt; When declarated by a class the protected member will be visible to the<br>&gt;&gt; class itself and all the derived classes.<br>&gt;&gt;<br>&gt;&gt; // BaseClass.swiftpublic class BaseClass {<br>&gt;&gt;     public protected(set) var x = 20<br>&gt;&gt;     protected let y = 10<br>&gt;&gt;<br>&gt;&gt;     protected func doSomething() {<br>&gt;&gt;         // ...<br>&gt;&gt;     }}<br>&gt;&gt; // DerivedClass.swiftpublic class DerivedClass: BaseClass {<br>&gt;&gt;     protected override doSomething() {<br>&gt;&gt;         self.x = 10 * self.y<br>&gt;&gt;     }}<br>&gt;&gt;<br>&gt;&gt; If the member is declared as final then it will be visible but not can<br>&gt;&gt; be overrided by the derived classes. Just like it works with other access<br>&gt;&gt; levels.<br>&gt;&gt; Value Types (structs, enums, etc.)<br>&gt;&gt;<br>&gt;&gt; Value types cannot have derived types. In this case the protected access<br>&gt;&gt; level does not make sense and will not be allowed in their members.<br>&gt;&gt; Protocols<br>&gt;&gt;<br>&gt;&gt; Protocols do not declare access level for their members. So the protected access<br>&gt;&gt; level is not applicable here.<br>&gt;&gt; Extensions<br>&gt;&gt;<br>&gt;&gt; Extensions will not be able do be protected nor their members.<br>&gt;&gt; Special Note<br>&gt;&gt;<br>&gt;&gt; The protected access level can only be applied to classes, structs and<br>&gt;&gt; other types when nested inside other type. So the following code will not<br>&gt;&gt; compile:<br>&gt;&gt;<br>&gt;&gt; // ERROR: A first level class cannot be protected.<br>&gt;&gt; protected class MyProtectedClass {<br>&gt;&gt;     /// ...}<br>&gt;&gt;<br>&gt;&gt; But nested declarations will be allowed, so this code will compile:<br>&gt;&gt;<br>&gt;&gt; // We can declare a protected class (or struct, enum, etc.) if// and only if they are nested inside other type.public class MyPublicClass {<br>&gt;&gt;     protected class MyProtectedClass {<br>&gt;&gt;         /// ...<br>&gt;&gt;     }}<br>&gt;&gt; // Since `MyProtectedClass` is nested and protected we// can have access to it here.public class MyDerivedClass: MyPublicClass {<br>&gt;&gt;     public func doSomething() {<br>&gt;&gt;         let c = MyProtectedClass()<br>&gt;&gt;<br>&gt;&gt;         /// ...<br>&gt;&gt;     }}<br>&gt;&gt;<br>&gt;&gt; Impact on existing code<br>&gt;&gt;<br>&gt;&gt; The imported Cocoa frameworks may have annotations on the &quot;Objective-C<br>&gt;&gt; side&quot; that will inform if one member is protected. If this will be case<br>&gt;&gt; (for the layoutSubviews method, as example), only code accessing these<br>&gt;&gt; now protected members outside the owner class and its derived classes will<br>&gt;&gt; have to change (currently this can be considered an error, anyway).<br>&gt;&gt;<br>&gt;&gt; Any other code will be not impacted by this feature as it is new to the<br>&gt;&gt; language.<br>&gt;&gt; Alternatives considered<br>&gt;&gt;<br>&gt;&gt; Do not add the protected access level to the current model.<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; ---<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/bc5eeb3b/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/0411520c60ef1131670f84bb42dc8949?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Swift)</string> &lt;swift-callionica at callionica.com (Callionica&gt;<p>May 29, 2016 at 04:00:00pm</p></header><div class="content"><p>Here&#39;s demo code for emulating protected in Swift:<br>https://gist.github.com/callionica/19da0763c0b0b4c504fc5f46d07e8ee8<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160529/f0b2bebc/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 30, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; <br>&gt; I can&#39;t reply directly to all the points in this thread, but I will just say that there are ways of emulating protected in the language as it exists today:<br>&gt; <br>&gt; If the goal is to have functions that can be overridden by subclasses without being called by external classes, you can create a parameter of a public type with a private initializer and use it in all &quot;protected&quot; member functions. No external code will be able to call such functions because they cannot create an argument of the correct type.<br>As others stated before:<br>I agree it&#39;s a cool little hack, but a hack none the less — and imho it isn&#39;t useful in real life.<br>The focus should be documenting intend (&quot;this method should be used in a certain way&quot;). Creating clever countermeasures to stop users of a library to enforce limitations is imho the wrong way.<br>&lt;not serious&gt;<br>We could even use tools like public key cryptography to secure access to APIs — or is there any developer who doesn&#39;t want to deal with more certificates? ;-)<br>&lt;/not serious&gt;<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/6fd0fc83/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 30, 2016 at 04:00:00am</p></header><div class="content"><p>&gt; On May 30, 2016, at 3:42 AM, Tino Heth via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt;&gt; I can&#39;t reply directly to all the points in this thread, but I will just say that there are ways of emulating protected in the language as it exists today:<br>&gt;&gt; <br>&gt;&gt; If the goal is to have functions that can be overridden by subclasses without being called by external classes, you can create a parameter of a public type with a private initializer and use it in all &quot;protected&quot; member functions. No external code will be able to call such functions because they cannot create an argument of the correct type.<br>&gt; As others stated before:<br>&gt; I agree it&#39;s a cool little hack, but a hack none the less — and imho it isn&#39;t useful in real life.<br>&gt; The focus should be documenting intend (&quot;this method should be used in a certain way&quot;). Creating clever countermeasures to stop users of a library to enforce limitations is imho the wrong way.<br></p><p>Couldn’t you use the same reasoning to claim there shouldn’t be access control at all? Just add documention on methods you want to mark private telling users of the library not to call them!<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/fb83f552/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 30, 2016 at 06:00:00pm</p></header><div class="content"><p>&gt; Couldn’t you use the same reasoning to claim there shouldn’t be access control at all? Just add documention on methods you want to mark private telling users of the library not to call them!<br></p><p>I guess you are making fun, but actually, good old Objective-C messaging works just that way:<br>You can call all those dangerous and forbidden private methods easily...<br>Writing special comments is just one way to document APIs; having no (official) documentation at all is documentation as well (&quot;don&#39;t use this!&quot;).<br></p><p>Most technical limitations can be cracked by skilled hackers (working around &quot;protected&quot; is especially easy), so I really think that (for example) declaring a method &quot;final&quot; says &quot;I don&#39;t want this to be changed in a subclass&quot; in the first place, and the compiler error that is triggered when you try to break the limitation is little more but a remainder.<br></p><p>Enforcing limitations using hacks causes confusion, so I would never use such tricks in production code.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/6b97da13/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 30, 2016 at 12:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 11:23 AM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; Couldn’t you use the same reasoning to claim there shouldn’t be access control at all? Just add documention on methods you want to mark private telling users of the library not to call them!<br>&gt; <br>&gt; I guess you are making fun, but actually, good old Objective-C messaging works just that way:<br>&gt; You can call all those dangerous and forbidden private methods easily...<br>&gt; Writing special comments is just one way to document APIs; having no (official) documentation at all is documentation as well (&quot;don&#39;t use this!&quot;).<br>&gt; <br>&gt; Most technical limitations can be cracked by skilled hackers (working around &quot;protected&quot; is especially easy), so I really think that (for example) declaring a method &quot;final&quot; says &quot;I don&#39;t want this to be changed in a subclass&quot; in the first place, and the compiler error that is triggered when you try to break the limitation is little more but a remainder.<br>&gt; <br>&gt; Enforcing limitations using hacks causes confusion, so I would never use such tricks in production code.<br></p><p>The purpose of access control isn’t really to keep out malicious users, though, it’s to prevent accidental misuse and clarify the interface.<br></p><p>One nice vector for accidental misuse is autocomplete. Even if layoutSubviews() has a great big // DON’T USE!!! in the documentation, it’s possible that someone is trying to remember the name of the API they need to use to tell the OS something needs to update its layout, so they type “layout” into the code editor, and lo and behold! Here’s something called layoutSubviews() that sounds like the sort of thing we want. And so it goes. A protected modifier in the language would prevent things like this.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/5973d857/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/831ba6eb600af4a6587f263373921bb2?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Tino Heth</string> &lt;2th at gmx.de&gt;<p>May 30, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; The purpose of access control isn’t really to keep out malicious users, though, it’s to prevent accidental misuse and clarify the interface.<br>mh, I would call this a &quot;documenting intend&quot; ;-)<br></p><p>&gt; One nice vector for accidental misuse is autocomplete. Even if layoutSubviews() has a great big // DON’T USE!!! in the documentation, it’s possible that someone is trying to remember the name of the API they need to use to tell the OS something needs to update its layout, so they type “layout” into the code editor, and lo and behold! Here’s something called layoutSubviews() that sounds like the sort of thing we want. And so it goes. A protected modifier in the language would prevent things like this.<br>true — but even subclasses shouldn&#39;t call layoutSubviews unregulated, so I think this is a flawed example for the usefulness of protected.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/45de8cfe/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/fab081724d16d497369e46fe76f20e12?s=50"></div><header><strong>[Proposal] Protected Access Level</strong> from <string>Charles Srstka</string> &lt;cocoadev at charlessoft.com&gt;<p>May 30, 2016 at 02:00:00pm</p></header><div class="content"><p>&gt; On May 30, 2016, at 2:02 PM, Tino Heth &lt;2th at gmx.de&gt; wrote:<br>&gt; <br>&gt;&gt; The purpose of access control isn’t really to keep out malicious users, though, it’s to prevent accidental misuse and clarify the interface.<br>&gt; mh, I would call this a &quot;documenting intend&quot; ;-)<br></p><p>If you get the method as an autocomplete, you won’t see the documentation telling you not to use it.<br></p><p>&gt;&gt; One nice vector for accidental misuse is autocomplete. Even if layoutSubviews() has a great big // DON’T USE!!! in the documentation, it’s possible that someone is trying to remember the name of the API they need to use to tell the OS something needs to update its layout, so they type “layout” into the code editor, and lo and behold! Here’s something called layoutSubviews() that sounds like the sort of thing we want. And so it goes. A protected modifier in the language would prevent things like this.<br>&gt; true — but even subclasses shouldn&#39;t call layoutSubviews unregulated, so I think this is a flawed example for the usefulness of protected.<br></p><p><br>This is why I prefer fileprivate(call) over protected.<br></p><p>Charles<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160530/4e31684a/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
