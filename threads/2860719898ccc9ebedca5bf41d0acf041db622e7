<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3850855d848ee50444bf84ce8355f7f3?s=50"></div><header><strong>Equality is broken, isn&#39;t it?</strong> from <string>Alexey Komnin</string> &lt;interfere.work at gmail.com&gt;<p>July  6, 2016 at 07:00:00pm</p></header><div class="content"><p>Here is the code:<br></p><p>    let a: String = &quot;abc&quot;<br>    let b: NSString = &quot;abc&quot;<br></p><p>    assert(a == b)<br>    assert(a.hashValue == b.hashValue, &quot;a.hashValue(\(a.hashValue)) !=<br>b.hashValue(\(b.hashValue))&quot;)<br></p><p>It fails with error:<br>    assertion failed: a.hashValue(4799450059707601744) != b.hashValue(516202353)<br></p><p>Perhaps, there is an issue with the equality operator.<br></p><p>Alexey Komnin.<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d92e9730c561c120200f34e7e50ed46?s=50"></div><header><strong>Equality is broken, isn&#39;t it?</strong> from <string>Jeff Kelley</string> &lt;slaunchaman at gmail.com&gt;<p>July  6, 2016 at 12:00:00pm</p></header><div class="content"><p>I wouldn’t expect String and NSString to have identical implementations of hashValue(). Is there a problem you’re having that this example is meant to illustrate? I can see this being an issue if you’re building your own collection type for strings.<br></p><p><br>Jeff Kelley<br></p><p>SlaunchaMan at gmail.com | @SlaunchaMan &lt;https://twitter.com/SlaunchaMan&gt; | jeffkelley.org &lt;http://jeffkelley.org/&gt;<br>&gt; On Jul 6, 2016, at 12:54 PM, Alexey Komnin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is the code:<br>&gt; <br>&gt;    let a: String = &quot;abc&quot;<br>&gt;    let b: NSString = &quot;abc&quot;<br>&gt; <br>&gt;    assert(a == b)<br>&gt;    assert(a.hashValue == b.hashValue, &quot;a.hashValue(\(a.hashValue)) !=<br>&gt; b.hashValue(\(b.hashValue))&quot;)<br>&gt; <br>&gt; It fails with error:<br>&gt;    assertion failed: a.hashValue(4799450059707601744) != b.hashValue(516202353)<br>&gt; <br>&gt; Perhaps, there is an issue with the equality operator.<br>&gt; <br>&gt; Alexey Komnin.<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-users/attachments/20160706/e56d2674/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/969b04d28c02f951ccc03f615b9a92b3?s=50"></div><header><strong>Equality is broken, isn&#39;t it?</strong> from <string>Dmitri Gribenko</string> &lt;gribozavr at gmail.com&gt;<p>July  6, 2016 at 09:00:00am</p></header><div class="content"><p>On Wed, Jul 6, 2016 at 9:54 AM, Alexey Komnin via swift-users<br>&lt;swift-users at swift.org&gt; wrote:<br>&gt; Here is the code:<br>&gt;<br>&gt;     let a: String = &quot;abc&quot;<br>&gt;     let b: NSString = &quot;abc&quot;<br>&gt;<br>&gt;     assert(a == b)<br>&gt;     assert(a.hashValue == b.hashValue, &quot;a.hashValue(\(a.hashValue)) !=<br>&gt; b.hashValue(\(b.hashValue))&quot;)<br>&gt;<br>&gt; It fails with error:<br>&gt;     assertion failed: a.hashValue(4799450059707601744) != b.hashValue(516202353)<br>&gt;<br>&gt; Perhaps, there is an issue with the equality operator.<br></p><p>String and NSString use different comparison algorithms, and thus use<br>incompatible hash codes.<br></p><p>When you issue a mixed-type comparison, one is bridged to the other.<br></p><p>Dmitri<br></p><p>-- <br>main(i,j){for(i=2;;i++){for(j=2;j&lt;i;j++){if(!(i%j)){j=0;break;}}if<br>(j){printf(&quot;%d\n&quot;,i);}}} /*Dmitri Gribenko &lt;gribozavr at gmail.com&gt;*/<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/edbd5f1c2f535b14165ae883fa7c3f37?s=50"></div><header><strong>Equality is broken, isn&#39;t it?</strong> from <string>Jens Alfke</string> &lt;jens at mooseyard.com&gt;<p>July  6, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 9:54 AM, Alexey Komnin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is the code:<br>&gt; <br>&gt;    let a: String = &quot;abc&quot;<br>&gt;    let b: NSString = &quot;abc&quot;<br>&gt; <br>&gt;    assert(a == b)<br>&gt;    assert(a.hashValue == b.hashValue, &quot;a.hashValue(\(a.hashValue)) !=<br>&gt; b.hashValue(\(b.hashValue))”)<br></p><p>Try comparing<br>	(a as NSString).hashValue == b.hashValue<br>or<br>	a.hashValue == (b as String).hashValue<br></p><p>It’s true that equal objects should have equal hash codes, but that really only applies when the objects have the same type so there’s no implicit coercion going on. For example, in scripting languages where “1” == 1 (pretty sure this is true of JavaScript and Perl, for example) it’s probably not true that “1”.hashCode == 1.hashCode.<br></p><p>In a Swift Dictionary, if you give the item type as String or NSString then everything’s converted to the same type when added, so hashCode will work as you expect. And if you use a Dictionary&lt;AnyObject&gt;, there won’t be any implicit String&lt;-&gt;NSString conversions going on, so if you added both your ‘a’ and ‘b’ objects I believe they would be stored separately as distinct keys.<br></p><p>(The moral is that the distinction between String and NSString is kind of messy, unfortunately. But the implicit conversion has been pretty important for Swift adoption given how ubiquitous NSString is in Cocoa APIs and existing apps.)<br></p><p>—Jens<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Equality is broken, isn&#39;t it?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>July  6, 2016 at 09:00:00pm</p></header><div class="content"><p>&gt; On Jul 6, 2016, at 9:54 AM, Alexey Komnin via swift-users &lt;swift-users at swift.org&gt; wrote:<br>&gt; <br>&gt; Here is the code:<br>&gt; <br>&gt;    let a: String = &quot;abc&quot;<br>&gt;    let b: NSString = &quot;abc&quot;<br>&gt; <br>&gt;    assert(a == b)<br>&gt;    assert(a.hashValue == b.hashValue, &quot;a.hashValue(\(a.hashValue)) !=<br>&gt; b.hashValue(\(b.hashValue))&quot;)<br></p><p>There&#39;s no problem if you use generics to select a single Hashable implementation:<br></p><p>	import Foundation<br>	<br>	func assertHashableConsistent&lt;T: Hashable&gt;(a: T, b: T) {<br>	    assert(a == b, &quot;a and b are equal&quot;)<br>	    assert(a.hashValue == b.hashValue, &quot;a and b have the same hash value&quot;)<br>	}<br>	<br>	assertHashableConsistent(a: &quot;abc&quot; as String, b: &quot;abc&quot; as NSString)<br></p><p>The problem is that, in your case, `a` uses `NSString`&#39;s `Hashable` in the first line, but `String`&#39;s `Hashable` in the second line. The `assertHashableConsistent(a:b:)` function, on the other hand, ensures that `a` uses `NSString`&#39;s `Hashable` in both lines.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
