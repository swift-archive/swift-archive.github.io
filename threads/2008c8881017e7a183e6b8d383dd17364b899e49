<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 10, 2015 at 11:00:00am</p></header><div class="content"><p>The fact that Swift uses the exact same syntax (&quot;a&quot;) for String, Character, and UnicodeScalar can get annoying at times. When unconstrained it&#39;s always String, and the only way to disambiguate between the two when used in a context that takes both Character and UnicodeScalar is to explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial example of this in action is<br></p><p>var s = &quot;&quot;<br>s.append(&quot;c&quot;)<br></p><p>This code looks pretty straightforward, but it throws an ambiguity error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s resolved, the behavior is the same).<br></p><p>Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get pretty annoying if you have to do it a lot. It would be great to reduce this typing a bit.<br></p><p>My initial proposal here is to introduce string literal suffixes. Let me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default if unconstrained). AFAIK this is not ambiguous with the current syntax, as I don&#39;t believe it&#39;s ever legal to put an identifier like that after a string.<br></p><p>Ideally this could be extended by library code with new suffixes. The obvious way to do that is to allow for a new type of &quot;operator&quot; declaration, perhaps something like `literal operator c { type Character }` (where `literal` is a context-sensitive keyword), which declares the suffix and the type (the actual type construction will be done with StringLiteralConvertible, StringInterpolationConvertible, UnicodeScalarLiteralConvertible, or ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared in two different modules that are imported into the same program, they&#39;re unambiguous within their source modules, and within the parent module using the suffix operator will be ambiguous unless further constrained (e.g. similar to using a function that&#39;s overloaded on its return type).<br></p><p>One possible library use for this would be something like `&quot;^\s*foo&quot;r ` for a regular expression (although regular expressions probably also want some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s orthogonal to this proposal).<br></p><p>Syntax is up for debate. I picked postfix characters because I believe it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in C++11&#39;s user-defined literals (although C++11 has a required underscore before the literal, I believe this is just to allow C++11 to define its own new suffixes without ambiguity). This syntax could also work for numeric literals, come to think of it, with the same declaration and using IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work for array and dictionary literals too, though that&#39;s less likely to be useful.<br></p><p>FWIW, Playground color and image literals have the form [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve the original problem (of having to type out the full type name) so this syntax is not appropriate for this feature (but the syntax is fine for what Playgrounds use it for, which is to embed literal colors/images into the source code).<br></p><p>-Kevin Ballard<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 10, 2015 at 09:00:00pm</p></header><div class="content"><p>&gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String, Character, and UnicodeScalar can get annoying at times. When unconstrained it&#39;s always String, and the only way to disambiguate between the two when used in a context that takes both Character and UnicodeScalar is to explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial example of this in action is<br>&gt; <br>&gt; var s = &quot;&quot;<br>&gt; s.append(&quot;c&quot;)<br>&gt; <br>&gt; This code looks pretty straightforward, but it throws an ambiguity error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s resolved, the behavior is the same).<br>&gt; <br>&gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get pretty annoying if you have to do it a lot. It would be great to reduce this typing a bit.<br></p><p>In principle you should also be able to say “s.append(Character(“c”))” but I agree that isn’t much better.<br></p><p>&gt; My initial proposal here is to introduce string literal suffixes. Let me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default if unconstrained). AFAIK this is not ambiguous with the current syntax, as I don&#39;t believe it&#39;s ever legal to put an identifier like that after a string.<br></p><p>I’m not sure how I feel about this proposal :-).  <br></p><p>On the one hand, I totally agree that this can be an issue.<br>On the other hand: I haven’t heard this be a wide-spread complaint.  It smacks of the “123ull” sorts of suffixes in C, which are pretty grotty IMO.  It reduces clarity of code by introducing syntax magic.<br></p><p><br>If you’re interested in pursuing this, I’d ask you to think about a few different things:<br></p><p>1) How does this generalize to integer, FP and other literals we have?<br>2) How do we avoid baking these into the compiler?  We would want to allow the suffixes to be user extensible, and have the standard ones defined by the standard library.  For example, “a”c could be sugar for c(“a”) or something.<br>3) There are C extensions that support things like _128 as well, should we support numbers?  Keep in mind that integer literals in swift support 123_456_789 separators.<br>4) Exactly which ones would we add to Swift out of the box?  Do we go down the C path of only having them for large ones (but ignores “short”)?  <br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 11, 2015 at 01:00:00pm</p></header><div class="content"><p>On Thu, Dec 10, 2015, at 09:52 PM, Chris Lattner wrote:<br>&gt; If you’re interested in pursuing this, I’d ask you to think about a few different things:<br>&gt; <br>&gt; 1) How does this generalize to integer, FP and other literals we have?<br></p><p>I believe this same proposal should work for decimal integral and decimal FP literals, as those cannot end in a letter. It cannot work for hexadecimal numeric literals as those may end in a letter, unless we come up with an alternative syntax. My first thought for an alternative syntax is to put a # after the literal, e.g. 12#i32 or 0xABC#i32, but I&#39;m not sure if that&#39;s actually a good idea. Or we could just say this doesn&#39;t work for hexadecimal literals. The only other literals we have are true, false, and nil, and I&#39;m not convinced we need to support literal suffixes for those (although the #i32 suggestion would actually work there too).<br></p><p>&gt; 2) How do we avoid baking these into the compiler?  We would want to allow the suffixes to be user extensible, and have the standard ones defined by the standard library.  For example, “a”c could be sugar for c(“a”) or something.<br></p><p>We&#39;d re-use the existing FooLiteralConvertible protocols. As suggested in my original email, we can add a way to declare these literals, which could look like<br></p><p>literal operator c {<br>    type Character<br>}<br></p><p>Then when the compiler encounters the literal suffix c, e.g. &quot;a&quot;c, it would treat it the same as the literal &quot;a&quot; constrained to the type Character. Note that &quot;literal&quot; here is a declaration specifier, and not a full keyword.<br></p><p>This syntax does not distinguish between literal type. I think this is ok, because if you say `12c` you&#39;ll get the same error you would if you typed `let c: Character = 12`, although we could enhance this instead to say something like &quot;error: type Character does not conform to IntegerLiteralConvertible or FloatLiteralConvertible&quot; instead.<br></p><p>The only real reason to actually distinguish between literal types in this declaration is if we want to be able to reuse the same suffix for different types. My inclination is to say we don&#39;t expect there to be enough literal suffixes to bother doing that, and none of the suffixes the standard library wants to define will conflict. We could also explicitly allow this, as long as the declared types do not both conform to the same FooLiteralConvertible protocol (and if they do we&#39;d emit an ambiguity error when used with that literal type, just as we will if two different modules declare the same suffix with different types and a module that imports both uses that suffix). I don&#39;t know if it&#39;s worth the complication though, as it means we can&#39;t know what type the literal &quot;12&quot;x resolves to without knowing the protocol conformances of the set of possible types.<br></p><p>&gt; 3) There are C extensions that support things like _128 as well, should we support numbers?  Keep in mind that integer literals in swift support 123_456_789 separators.<br></p><p>I think we should require that all literal suffixes begin with a letter, and then may use letters and numbers (but not underscores). Or more generally, it should be the same rules used for identifiers except with underscore removed.<br></p><p>We might also establish a convention of using a trailing _ on numeric literals when using literal suffixes, because `12_i32` looks slightly nicer than `12i32`, but I&#39;m not proposing that as a rule (and it won&#39;t be legal for string literals because those can&#39;t end in _).<br></p><p>&gt; 4) Exactly which ones would we add to Swift out of the box?  Do we go down the C path of only having them for large ones (but ignores “short”)?<br></p><p>I&#39;d propose the following:<br></p><p>Character : c<br>UnicodeScalar : us<br>// skip String, an un-suffixed string literal will default to String already<br>Int : i // or int, or omitted<br>UInt : u // or uint<br>Int16 : i16<br>Int32 : i32<br>Int64 : i64<br>UInt16 : u16<br>UInt32 : u32<br>UInt64 : u64<br>Float : f<br>Float32 : f32<br>Double : f64 // or maybe d<br>Float80 : f80<br></p><p>I&#39;ve included Int but not String, because it feels a little weird to omit Int when all the other numeric types are included. String feels less weird to skip. But we could skip Int because integral literals default to Int if not otherwise constrained.<br></p><p>I don&#39;t think we need any more, but I&#39;ll list the following for discussion anyway:<br></p><p>Set : s // because array literals default to Array otherwise<br>// if we allow non-overlapping conflicts we can also do the following:<br>NSDictionary : ns<br>NSArray : ns<br>NSString : ns<br>// Possibly NSSet : nsset as well, but I feel like that&#39;s pushing it a bit<br></p><p>-Kevin Ballard<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/283bdc6ec76dd4d16b7a8234222e55d4?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Michel Fortin</string> &lt;michel.fortin at michelf.ca&gt;<p>December 12, 2015 at 07:00:00am</p></header><div class="content"><p>Le 11 déc. 2015 à 0:52, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; a écrit :<br></p><p>&gt; On the other hand: I haven’t heard this be a wide-spread complaint.  It smacks of the “123ull” sorts of suffixes in C, which are pretty grotty IMO.  It reduces clarity of code by introducing syntax magic.<br></p><p>Speaking of syntax magic, I can&#39;t say I really had a need for suffixes, but that&#39;s because I could to resort to this on occasion:<br></p><p>	extension UTF16Char : UnicodeScalarLiteralConvertible {<br>		public init(unicodeScalarLiteral value: UnicodeScalar) {<br>			assert(UTF16Char.isRepresentable(value))<br>			self.init(Int16(value.value))<br>		}<br>		public static func isRepresentable(unicodeScalar: UnicodeScalar) -&gt; Bool {<br>			switch unicodeScalar.value {<br>			case 0x0000 ... 0xD7FF: return true<br>			case 0xE000 ... 0xFFFF: return true<br>			default: return false<br>			}<br>		}<br>	}<br></p><p>... allowing me to do things of this sort in a way that isn&#39;t overly verbose:<br></p><p>	func hexvalue(digit: UTF16Char) -&gt; UInt16? {<br>		switch digit {<br>			case &quot;a&quot; ... &quot;f&quot;: return digit - &quot;a&quot; + 0xA<br>			case &quot;A&quot; ... &quot;F&quot;: return digit - &quot;A&quot; + 0xA<br>			case &quot;0&quot; ... &quot;9&quot;: return digit - &quot;0&quot;<br>			default:          return nil<br>		}<br>	}<br></p><p>I only wish I could keep that &quot;UnicodeScalarLiteralConvertible&quot; conformance extension private within the file instead of leaking it everywhere. I guess a prefix would improve things if it allowed me to keep it private.<br></p><p>-- <br>Michel Fortin<br>michel.fortin at michelf.ca<br>https://michelf.ca<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/661c58274e3f437234236553e2dc156f?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Martin Kühl</string> &lt;martin.kuehl at gmail.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>On 11 December 2015 at 06:52, Chris Lattner via swift-evolution<br>&lt;swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt;<br>&gt;&gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String, Character, and UnicodeScalar can get annoying at times. When unconstrained it&#39;s always String, and the only way to disambiguate between the two when used in a context that takes both Character and UnicodeScalar is to explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial example of this in action is<br>&gt;&gt;<br>&gt;&gt; var s = &quot;&quot;<br>&gt;&gt; s.append(&quot;c&quot;)<br>&gt;&gt;<br>&gt;&gt; This code looks pretty straightforward, but it throws an ambiguity error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s resolved, the behavior is the same).<br>&gt;&gt;<br>&gt;&gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get pretty annoying if you have to do it a lot. It would be great to reduce this typing a bit.<br>&gt;<br>&gt; In principle you should also be able to say “s.append(Character(“c”))” but I agree that isn’t much better.<br></p><p>You can also write<br></p><p>    s.append(c(&quot;c&quot;))<br></p><p>as long as you have a `typealias c = Character` in scope, and<br>typealiases can be block-scoped.<br></p><p>Of course, whether that helps depends on where and how you encounter<br>the ambiguity.<br></p><p>-Martin<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 14, 2015 at 03:00:00pm</p></header><div class="content"><p>Perhaps there simply should be two different functions, append(char:) and<br>append(unicode:)<br>On Mon, Dec 14, 2015 at 18:46 Martin Kühl &lt;swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; On 11 December 2015 at 06:52, Chris Lattner via swift-evolution<br>&gt; &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt;&gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String,<br>&gt; Character, and UnicodeScalar can get annoying at times. When unconstrained<br>&gt; it&#39;s always String, and the only way to disambiguate between the two when<br>&gt; used in a context that takes both Character and UnicodeScalar is to<br>&gt; explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial<br>&gt; example of this in action is<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; var s = &quot;&quot;<br>&gt; &gt;&gt; s.append(&quot;c&quot;)<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; This code looks pretty straightforward, but it throws an ambiguity<br>&gt; error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s<br>&gt; resolved, the behavior is the same).<br>&gt; &gt;&gt;<br>&gt; &gt;&gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get<br>&gt; pretty annoying if you have to do it a lot. It would be great to reduce<br>&gt; this typing a bit.<br>&gt; &gt;<br>&gt; &gt; In principle you should also be able to say “s.append(Character(“c”))”<br>&gt; but I agree that isn’t much better.<br>&gt;<br>&gt; You can also write<br>&gt;<br>&gt;     s.append(c(&quot;c&quot;))<br>&gt;<br>&gt; as long as you have a `typealias c = Character` in scope, and<br>&gt; typealiases can be block-scoped.<br>&gt;<br>&gt; Of course, whether that helps depends on where and how you encounter<br>&gt; the ambiguity.<br>&gt;<br>&gt; -Martin<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/e4658d5b/attachment.html&gt;<br></p></div></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>December 11, 2015 at 02:00:00pm</p></header><div class="content"><p>I was a little disappointed something like this didn&#39;t already work:<br></p><p>struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br></p><p>&quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&quot;y&quot;.b // same, for Bar<br></p><p>-Joe<br></p><p>&gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String, Character, and UnicodeScalar can get annoying at times. When unconstrained it&#39;s always String, and the only way to disambiguate between the two when used in a context that takes both Character and UnicodeScalar is to explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial example of this in action is<br>&gt; <br>&gt; var s = &quot;&quot;<br>&gt; s.append(&quot;c&quot;)<br>&gt; <br>&gt; This code looks pretty straightforward, but it throws an ambiguity error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s resolved, the behavior is the same).<br>&gt; <br>&gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get pretty annoying if you have to do it a lot. It would be great to reduce this typing a bit.<br>&gt; <br>&gt; My initial proposal here is to introduce string literal suffixes. Let me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default if unconstrained). AFAIK this is not ambiguous with the current syntax, as I don&#39;t believe it&#39;s ever legal to put an identifier like that after a string.<br>&gt; <br>&gt; Ideally this could be extended by library code with new suffixes. The obvious way to do that is to allow for a new type of &quot;operator&quot; declaration, perhaps something like `literal operator c { type Character }` (where `literal` is a context-sensitive keyword), which declares the suffix and the type (the actual type construction will be done with StringLiteralConvertible, StringInterpolationConvertible, UnicodeScalarLiteralConvertible, or ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared in two different modules that are imported into the same program, they&#39;re unambiguous within their source modules, and within the parent module using the suffix operator will be ambiguous unless further constrained (e.g. similar to using a function that&#39;s overloaded on its return type).<br>&gt; <br>&gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r ` for a regular expression (although regular expressions probably also want some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s orthogonal to this proposal).<br>&gt; <br>&gt; Syntax is up for debate. I picked postfix characters because I believe it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in C++11&#39;s user-defined literals (although C++11 has a required underscore before the literal, I believe this is just to allow C++11 to define its own new suffixes without ambiguity). This syntax could also work for numeric literals, come to think of it, with the same declaration and using IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work for array and dictionary literals too, though that&#39;s less likely to be useful.<br>&gt; <br>&gt; FWIW, Playground color and image literals have the form [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve the original problem (of having to type out the full type name) so this syntax is not appropriate for this feature (but the syntax is fine for what Playgrounds use it for, which is to embed literal colors/images into the source code).<br>&gt; <br>&gt; -Kevin Ballard<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/d47baf3a0f80c9fd13ece9c4b87c7fce?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Marc Knaup</string> &lt;marc at knaup.koeln&gt;<p>December 11, 2015 at 11:00:00pm</p></header><div class="content"><p>Too bad that string literals don&#39;t conform to a specific protocol.<br></p><p>This would also be a nice but doesn&#39;t work:<br></p><p>// StaticString: &quot;An simple string designed to represent text that is<br>&#39;knowable at compile-time&#39;.&quot;<br>extension StaticString {<br></p><p>    var x: Int {<br>        return 123<br>    }<br>}<br></p><p>print(&quot;abc&quot;.x)<br></p><p>On Fri, Dec 11, 2015 at 11:38 PM, Joe Groff via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I was a little disappointed something like this didn&#39;t already work:<br>&gt;<br>&gt; struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>&gt; struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br>&gt;<br>&gt; &quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&gt; &quot;y&quot;.b // same, for Bar<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String,<br>&gt; Character, and UnicodeScalar can get annoying at times. When unconstrained<br>&gt; it&#39;s always String, and the only way to disambiguate between the two when<br>&gt; used in a context that takes both Character and UnicodeScalar is to<br>&gt; explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial<br>&gt; example of this in action is<br>&gt; &gt;<br>&gt; &gt; var s = &quot;&quot;<br>&gt; &gt; s.append(&quot;c&quot;)<br>&gt; &gt;<br>&gt; &gt; This code looks pretty straightforward, but it throws an ambiguity error<br>&gt; (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s<br>&gt; resolved, the behavior is the same).<br>&gt; &gt;<br>&gt; &gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get<br>&gt; pretty annoying if you have to do it a lot. It would be great to reduce<br>&gt; this typing a bit.<br>&gt; &gt;<br>&gt; &gt; My initial proposal here is to introduce string literal suffixes. Let me<br>&gt; type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar<br>&gt; (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default<br>&gt; if unconstrained). AFAIK this is not ambiguous with the current syntax, as<br>&gt; I don&#39;t believe it&#39;s ever legal to put an identifier like that after a<br>&gt; string.<br>&gt; &gt;<br>&gt; &gt; Ideally this could be extended by library code with new suffixes. The<br>&gt; obvious way to do that is to allow for a new type of &quot;operator&quot;<br>&gt; declaration, perhaps something like `literal operator c { type Character }`<br>&gt; (where `literal` is a context-sensitive keyword), which declares the suffix<br>&gt; and the type (the actual type construction will be done with<br>&gt; StringLiteralConvertible, StringInterpolationConvertible,<br>&gt; UnicodeScalarLiteralConvertible, or<br>&gt; ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared<br>&gt; in two different modules that are imported into the same program, they&#39;re<br>&gt; unambiguous within their source modules, and within the parent module using<br>&gt; the suffix operator will be ambiguous unless further constrained (e.g.<br>&gt; similar to using a function that&#39;s overloaded on its return type).<br>&gt; &gt;<br>&gt; &gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r `<br>&gt; for a regular expression (although regular expressions probably also want<br>&gt; some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s<br>&gt; orthogonal to this proposal).<br>&gt; &gt;<br>&gt; &gt; Syntax is up for debate. I picked postfix characters because I believe<br>&gt; it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in<br>&gt; C++11&#39;s user-defined literals (although C++11 has a required underscore<br>&gt; before the literal, I believe this is just to allow C++11 to define its own<br>&gt; new suffixes without ambiguity). This syntax could also work for numeric<br>&gt; literals, come to think of it, with the same declaration and using<br>&gt; IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work<br>&gt; for array and dictionary literals too, though that&#39;s less likely to be<br>&gt; useful.<br>&gt; &gt;<br>&gt; &gt; FWIW, Playground color and image literals have the form<br>&gt; [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and<br>&gt; [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve<br>&gt; the original problem (of having to type out the full type name) so this<br>&gt; syntax is not appropriate for this feature (but the syntax is fine for what<br>&gt; Playgrounds use it for, which is to embed literal colors/images into the<br>&gt; source code).<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151211/5be93548/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/2861bfeb71de9de58206bb6ae750bc2f?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>ilya</string> &lt;ilya.nikokoshev at gmail.com&gt;<p>December 12, 2015 at 02:00:00pm</p></header><div class="content"><p>&gt; var s = &quot;&quot;<br>&gt; s.append(&quot;c&quot;)<br>&gt;<br>&gt; This code looks pretty straightforward,<br></p><p>This looks to me like you&#39;re adding a string, which can be done via<br></p><p>s += &quot;c&quot;<br></p><p>Yes, I know adding a character can theoretically be a bit more performant,<br>but why would that be a consideration for static strings? Compiler should<br>optimize both expressions above to the same result.<br></p><p>&gt; UInt : u // or uint<br>&gt; Int16 : i16<br>&gt; Int32 : i32<br></p><p>I think<br></p><p>let number = 56i32<br></p><p>is much less readable than<br></p><p>let number: Int32 = 56<br></p><p>so probably best not to encourage it.<br></p><p><br>On Sat, Dec 12, 2015 at 1:48 AM, Marc Knaup via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; Too bad that string literals don&#39;t conform to a specific protocol.<br>&gt;<br>&gt; This would also be a nice but doesn&#39;t work:<br>&gt;<br>&gt; // StaticString: &quot;An simple string designed to represent text that is<br>&gt; &#39;knowable at compile-time&#39;.&quot;<br>&gt; extension StaticString {<br>&gt;<br>&gt;     var x: Int {<br>&gt;         return 123<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; print(&quot;abc&quot;.x)<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 11:38 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt;&gt; I was a little disappointed something like this didn&#39;t already work:<br>&gt;&gt;<br>&gt;&gt; struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>&gt;&gt; struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br>&gt;&gt;<br>&gt;&gt; &quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&gt;&gt; &quot;y&quot;.b // same, for Bar<br>&gt;&gt;<br>&gt;&gt; -Joe<br>&gt;&gt;<br>&gt;&gt; &gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;<br>&gt;&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String,<br>&gt;&gt; Character, and UnicodeScalar can get annoying at times. When unconstrained<br>&gt;&gt; it&#39;s always String, and the only way to disambiguate between the two when<br>&gt;&gt; used in a context that takes both Character and UnicodeScalar is to<br>&gt;&gt; explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial<br>&gt;&gt; example of this in action is<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var s = &quot;&quot;<br>&gt;&gt; &gt; s.append(&quot;c&quot;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This code looks pretty straightforward, but it throws an ambiguity<br>&gt;&gt; error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s<br>&gt;&gt; resolved, the behavior is the same).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get<br>&gt;&gt; pretty annoying if you have to do it a lot. It would be great to reduce<br>&gt;&gt; this typing a bit.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My initial proposal here is to introduce string literal suffixes. Let<br>&gt;&gt; me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a<br>&gt;&gt; UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although<br>&gt;&gt; that&#39;s the default if unconstrained). AFAIK this is not ambiguous with the<br>&gt;&gt; current syntax, as I don&#39;t believe it&#39;s ever legal to put an identifier<br>&gt;&gt; like that after a string.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Ideally this could be extended by library code with new suffixes. The<br>&gt;&gt; obvious way to do that is to allow for a new type of &quot;operator&quot;<br>&gt;&gt; declaration, perhaps something like `literal operator c { type Character }`<br>&gt;&gt; (where `literal` is a context-sensitive keyword), which declares the suffix<br>&gt;&gt; and the type (the actual type construction will be done with<br>&gt;&gt; StringLiteralConvertible, StringInterpolationConvertible,<br>&gt;&gt; UnicodeScalarLiteralConvertible, or<br>&gt;&gt; ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared<br>&gt;&gt; in two different modules that are imported into the same program, they&#39;re<br>&gt;&gt; unambiguous within their source modules, and within the parent module using<br>&gt;&gt; the suffix operator will be ambiguous unless further constrained (e.g.<br>&gt;&gt; similar to using a function that&#39;s overloaded on its return type).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r `<br>&gt;&gt; for a regular expression (although regular expressions probably also want<br>&gt;&gt; some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s<br>&gt;&gt; orthogonal to this proposal).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Syntax is up for debate. I picked postfix characters because I believe<br>&gt;&gt; it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in<br>&gt;&gt; C++11&#39;s user-defined literals (although C++11 has a required underscore<br>&gt;&gt; before the literal, I believe this is just to allow C++11 to define its own<br>&gt;&gt; new suffixes without ambiguity). This syntax could also work for numeric<br>&gt;&gt; literals, come to think of it, with the same declaration and using<br>&gt;&gt; IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work<br>&gt;&gt; for array and dictionary literals too, though that&#39;s less likely to be<br>&gt;&gt; useful.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; FWIW, Playground color and image literals have the form<br>&gt;&gt; [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and<br>&gt;&gt; [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve<br>&gt;&gt; the original problem (of having to type out the full type name) so this<br>&gt;&gt; syntax is not appropriate for this feature (but the syntax is fine for what<br>&gt;&gt; Playgrounds use it for, which is to embed literal colors/images into the<br>&gt;&gt; source code).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/e2306a2e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/6451ee8093c9cedc94f6c813b4dde2c5?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Kevin Ballard</string> &lt;kevin at sb.org&gt;<p>December 12, 2015 at 01:00:00pm</p></header><div class="content"><p>I think you&#39;re reading too much into that one example. That was a<br>demonstration of where the ambiguity between Character and UnicodeScalar<br>matters, not the sole reason to use this. Suffice to say, I&#39;ve hit the<br>ambiguity error between Characters and UnicodeScalars often enough to<br>consider it worth addressing.<br></p><p>-Kevin<br></p><p>On Sat, Dec 12, 2015, at 03:26 AM, ilya via swift-evolution wrote:<br>&gt; &gt; var s = &quot;&quot;<br>&gt; &gt; s.append(&quot;c&quot;)<br>&gt; &gt;<br>&gt; &gt; This code looks pretty straightforward,<br>&gt;<br>&gt; This looks to me like you&#39;re adding a string, which can be done via<br>&gt;<br>&gt; s += &quot;c&quot;<br>&gt;<br>&gt; Yes, I know adding a character can theoretically be a bit more<br>&gt; performant, but why would that be a consideration for static strings?<br>&gt; Compiler should optimize both expressions above to the same result.<br>&gt;<br>&gt; &gt; UInt : u // or uint Int16 : i16 Int32 : i32<br>&gt;<br>&gt; I think<br>&gt;<br>&gt; let number = 56i32<br>&gt;<br>&gt; is much less readable than<br>&gt;<br>&gt; let number: Int32 = 56<br>&gt;<br>&gt; so probably best not to encourage it.<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 1:48 AM, Marc Knaup via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt; Too bad that string literals don&#39;t conform to a specific protocol.<br>&gt;&gt;<br>&gt;&gt; This would also be a nice but doesn&#39;t work: // StaticString:&quot;An<br>&gt;&gt; simple string designed to represent text that is &#39;knowable at compile-<br>&gt;&gt; time&#39;.&quot; extensionStaticString {<br></p><p>&gt;&gt; var x: Int {        return123    } }<br>&gt;&gt;<br>&gt;&gt; print(&quot;abc&quot;.x)<br></p><p>&gt;&gt;<br>&gt;&gt; On Fri, Dec 11, 2015 at 11:38 PM, Joe Groff via swift-evolution &lt;swift-<br>&gt;&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt; I was a little disappointed something like this didn&#39;t already work:<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>&gt;&gt;&gt;<br>struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&gt;&gt;&gt;<br>&quot;y&quot;.b // same, for Bar<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>-Joe<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>&gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;swift-<br>&gt; evolution at swift.org&gt; wrote:<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt; &gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String,<br>&gt;&gt;&gt; &gt; Character, and UnicodeScalar can get annoying at times. When<br>&gt;&gt;&gt; &gt; unconstrained it&#39;s always String, and the only way to disambiguate<br>&gt;&gt;&gt; &gt; between the two when used in a context that takes both Character<br>&gt;&gt;&gt; &gt; and UnicodeScalar is to explicitly constraint it further, e.g.<br>&gt;&gt;&gt; &gt; with `&quot;a&quot; as Character`. A trivial example of this in action is<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; var s = &quot;&quot;<br>&gt;&gt;&gt;<br>&gt; s.append(&quot;c&quot;)<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; This code looks pretty straightforward, but it throws an ambiguity<br>&gt; error (and the annoying part is, it doesn&#39;t actually matter which way<br>&gt; it&#39;s resolved, the behavior is the same).<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get<br>&gt; pretty annoying if you have to do it a lot. It would be great to<br>&gt; reduce this typing a bit.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; My initial proposal here is to introduce string literal suffixes. Let<br>&gt; me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a<br>&gt; UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although<br>&gt; that&#39;s the default if unconstrained). AFAIK this is not ambiguous with<br>&gt; the current syntax, as I don&#39;t believe it&#39;s ever legal to put an<br>&gt; identifier like that after a string.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; Ideally this could be extended by library code with new suffixes. The<br>&gt; obvious way to do that is to allow for a new type of &quot;operator&quot;<br>&gt; declaration, perhaps something like `literal operator c { type<br>&gt; Character }` (where `literal` is a context-sensitive keyword), which<br>&gt; declares the suffix and the type (the actual type construction will be<br>&gt; done with StringLiteralConvertible, StringInterpolationConvertible,<br>&gt; UnicodeScalarLiteralConvertible, or<br>&gt; ExtendedGraphemeClusterLiteralConvertible). If the same suffix is<br>&gt; declared in two different modules that are imported into the same<br>&gt; program, they&#39;re unambiguous within their source modules, and within<br>&gt; the parent module using the suffix operator will be ambiguous unless<br>&gt; further constrained (e.g. similar to using a function that&#39;s<br>&gt; overloaded on its return type).<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r<br>&gt; ` for a regular expression (although regular expressions probably also<br>&gt; want some sort of &quot;raw&quot; string literal syntax to deal with escapes,<br>&gt; but that&#39;s orthogonal to this proposal).<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; Syntax is up for debate. I picked postfix characters because I believe<br>&gt; it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and<br>&gt; in C++11&#39;s user-defined literals (although C++11 has a required<br>&gt; underscore before the literal, I believe this is just to allow C++11<br>&gt; to define its own new suffixes without ambiguity). This syntax could<br>&gt; also work for numeric literals, come to think of it, with the same<br>&gt; declaration and using IntegerLiteralConvertible or<br>&gt; FloatLiteralConvertible. Heck, it could work for array and dictionary<br>&gt; literals too, though that&#39;s less likely to be useful.<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; FWIW, Playground color and image literals have the form<br>&gt; [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and<br>&gt; [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t<br>&gt; solve the original problem (of having to type out the full type name)<br>&gt; so this syntax is not appropriate for this feature (but the syntax is<br>&gt; fine for what Playgrounds use it for, which is to embed literal<br>&gt; colors/images into the source code).<br>&gt;&gt;&gt;<br>&gt;<br>&gt;&gt;&gt;<br>&gt; -Kevin Ballard<br>&gt;&gt;&gt;<br>&gt; _______________________________________________<br>&gt;&gt;&gt;<br>&gt; swift-evolution mailing list<br>&gt;&gt;&gt;<br>&gt; swift-evolution at swift.org<br>&gt;&gt;&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;<br>_______________________________________________<br>&gt;&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt;&gt; swift-evolution at swift.org<br>&gt;&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;&gt;<br>&gt;&gt; _______________________________________________<br>&gt;&gt;<br>swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;&gt;<br>&gt;<br>&gt; _________________________________________________<br>&gt; swift-evolution mailing list swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151212/7443d316/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1cec0edd417a75c5809cae4cd1feaa7?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Alex Gordon</string> &lt;alextgordon at gmail.com&gt;<p>December 14, 2015 at 06:00:00am</p></header><div class="content"><p>If Swift is ever going to have multi-line string literals, type affixes<br>should be a prefix and not a suffix. Otherwise the suffix would get lost at<br>the end of a long string.<br></p><p>A nice extra use for affixes is as metadata so that your editor can do<br>syntax highlighting. When I write r&quot;...&quot; in Python (for a raw string), my<br>editor assumes that it is a regex and gives regex-specific highlighting.<br>For SQL, it can only take a guess from the content.<br></p><p>So I can see re&quot;[a-z0-9]+&quot; and sql&quot;select * from table&quot; adding value, even<br>if the latter is just a pass-through.<br></p><p>As far as raw strings go, the general feeling in the multi-line strings<br>thread was to either go for single quotes or backticks. If backticks, it<br>could married with this proposal as follows: any prefix + backticks = raw<br>string. e.g.<br></p><p>r`raw string &quot;quotes&quot;`    // raw string<br>re`&lt;a href=&quot;[^&quot;]+&quot;&gt;`       // raw regex literal<br></p><p>- Alex<br></p><p>On Sat, Dec 12, 2015 at 9:19 PM, Kevin Ballard via swift-evolution &lt;<br>swift-evolution at swift.org&gt; wrote:<br></p><p>&gt; I think you&#39;re reading too much into that one example. That was a<br>&gt; demonstration of where the ambiguity between Character and UnicodeScalar<br>&gt; matters, not the sole reason to use this. Suffice to say, I&#39;ve hit the<br>&gt; ambiguity error between Characters and UnicodeScalars often enough to<br>&gt; consider it worth addressing.<br>&gt;<br>&gt; -Kevin<br>&gt;<br>&gt; On Sat, Dec 12, 2015, at 03:26 AM, ilya via swift-evolution wrote:<br>&gt;<br>&gt; &gt; var s = &quot;&quot;<br>&gt; &gt; s.append(&quot;c&quot;)<br>&gt; &gt;<br>&gt; &gt; This code looks pretty straightforward,<br>&gt;<br>&gt; This looks to me like you&#39;re adding a string, which can be done via<br>&gt;<br>&gt; s += &quot;c&quot;<br>&gt;<br>&gt; Yes, I know adding a character can theoretically be a bit more performant,<br>&gt; but why would that be a consideration for static strings? Compiler should<br>&gt; optimize both expressions above to the same result.<br>&gt;<br>&gt; &gt; UInt : u // or uint<br>&gt; &gt; Int16 : i16<br>&gt; &gt; Int32 : i32<br>&gt;<br>&gt; I think<br>&gt;<br>&gt; let number = 56i32<br>&gt;<br>&gt; is much less readable than<br>&gt;<br>&gt; let number: Int32 = 56<br>&gt;<br>&gt; so probably best not to encourage it.<br>&gt;<br>&gt;<br>&gt; On Sat, Dec 12, 2015 at 1:48 AM, Marc Knaup via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; Too bad that string literals don&#39;t conform to a specific protocol.<br>&gt;<br>&gt; This would also be a nice but doesn&#39;t work:<br>&gt;<br>&gt; // StaticString:&quot;An simple string designed to represent text that is<br>&gt; &#39;knowable at compile-time&#39;.&quot;<br>&gt; extensionStaticString {<br>&gt;<br>&gt;     var x: Int {<br>&gt;         return123<br>&gt;     }<br>&gt; }<br>&gt;<br>&gt; print(&quot;abc&quot;.x)<br>&gt;<br>&gt; On Fri, Dec 11, 2015 at 11:38 PM, Joe Groff via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt;<br>&gt; I was a little disappointed something like this didn&#39;t already work:<br>&gt;<br>&gt; struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>&gt; struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br>&gt;<br>&gt; &quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&gt; &quot;y&quot;.b // same, for Bar<br>&gt;<br>&gt; -Joe<br>&gt;<br>&gt; &gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;<br>&gt; swift-evolution at swift.org&gt; wrote:<br>&gt; &gt;<br>&gt; &gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String,<br>&gt; Character, and UnicodeScalar can get annoying at times. When unconstrained<br>&gt; it&#39;s always String, and the only way to disambiguate between the two when<br>&gt; used in a context that takes both Character and UnicodeScalar is to<br>&gt; explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial<br>&gt; example of this in action is<br>&gt; &gt;<br>&gt; &gt; var s = &quot;&quot;<br>&gt; &gt; s.append(&quot;c&quot;)<br>&gt; &gt;<br>&gt; &gt; This code looks pretty straightforward, but it throws an ambiguity error<br>&gt; (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s<br>&gt; resolved, the behavior is the same).<br>&gt; &gt;<br>&gt; &gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get<br>&gt; pretty annoying if you have to do it a lot. It would be great to reduce<br>&gt; this typing a bit.<br>&gt; &gt;<br>&gt; &gt; My initial proposal here is to introduce string literal suffixes. Let me<br>&gt; type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar<br>&gt; (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default<br>&gt; if unconstrained). AFAIK this is not ambiguous with the current syntax, as<br>&gt; I don&#39;t believe it&#39;s ever legal to put an identifier like that after a<br>&gt; string.<br>&gt; &gt;<br>&gt; &gt; Ideally this could be extended by library code with new suffixes. The<br>&gt; obvious way to do that is to allow for a new type of &quot;operator&quot;<br>&gt; declaration, perhaps something like `literal operator c { type Character }`<br>&gt; (where `literal` is a context-sensitive keyword), which declares the suffix<br>&gt; and the type (the actual type construction will be done with<br>&gt; StringLiteralConvertible, StringInterpolationConvertible,<br>&gt; UnicodeScalarLiteralConvertible, or<br>&gt; ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared<br>&gt; in two different modules that are imported into the same program, they&#39;re<br>&gt; unambiguous within their source modules, and within the parent module using<br>&gt; the suffix operator will be ambiguous unless further constrained (e.g.<br>&gt; similar to using a function that&#39;s overloaded on its return type).<br>&gt; &gt;<br>&gt; &gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r `<br>&gt; for a regular expression (although regular expressions probably also want<br>&gt; some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s<br>&gt; orthogonal to this proposal).<br>&gt; &gt;<br>&gt; &gt; Syntax is up for debate. I picked postfix characters because I believe<br>&gt; it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in<br>&gt; C++11&#39;s user-defined literals (although C++11 has a required underscore<br>&gt; before the literal, I believe this is just to allow C++11 to define its own<br>&gt; new suffixes without ambiguity). This syntax could also work for numeric<br>&gt; literals, come to think of it, with the same declaration and using<br>&gt; IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work<br>&gt; for array and dictionary literals too, though that&#39;s less likely to be<br>&gt; useful.<br>&gt; &gt;<br>&gt; &gt; FWIW, Playground color and image literals have the form<br>&gt; [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and<br>&gt; [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve<br>&gt; the original problem (of having to type out the full type name) so this<br>&gt; syntax is not appropriate for this feature (but the syntax is fine for what<br>&gt; Playgrounds use it for, which is to embed literal colors/images into the<br>&gt; source code).<br>&gt; &gt;<br>&gt; &gt; -Kevin Ballard<br>&gt; &gt; _______________________________________________<br>&gt; &gt; swift-evolution mailing list<br>&gt; &gt; swift-evolution at swift.org<br>&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; *_______________________________________________*<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>&gt;<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt;<br>&gt;<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/dc6d3b9e/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>December 14, 2015 at 12:00:00pm</p></header><div class="content"><p>&gt; On Dec 13, 2015, at 10:31 PM, Alex Gordon via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; If Swift is ever going to have multi-line string literals, type affixes should be a prefix and not a suffix. Otherwise the suffix would get lost at the end of a long string.<br></p><p>Now that you mention it, I completely agree, great point.<br></p><p>-Chris<br></p><p>&gt; <br>&gt; A nice extra use for affixes is as metadata so that your editor can do syntax highlighting. When I write r&quot;...&quot; in Python (for a raw string), my editor assumes that it is a regex and gives regex-specific highlighting. For SQL, it can only take a guess from the content.<br>&gt; <br>&gt; So I can see re&quot;[a-z0-9]+&quot; and sql&quot;select * from table&quot; adding value, even if the latter is just a pass-through.<br>&gt; <br>&gt; As far as raw strings go, the general feeling in the multi-line strings thread was to either go for single quotes or backticks. If backticks, it could married with this proposal as follows: any prefix + backticks = raw string. e.g.<br>&gt; <br>&gt; r`raw string &quot;quotes&quot;`    // raw string<br>&gt; re`&lt;a href=&quot;[^&quot;]+&quot;&gt;`       // raw regex literal<br>&gt; <br>&gt; - Alex<br>&gt; <br>&gt; On Sat, Dec 12, 2015 at 9:19 PM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt; I think you&#39;re reading too much into that one example. That was a demonstration of where the ambiguity between Character and UnicodeScalar matters, not the sole reason to use this. Suffice to say, I&#39;ve hit the ambiguity error between Characters and UnicodeScalars often enough to consider it worth addressing.<br>&gt;  <br>&gt; -Kevin<br>&gt;  <br>&gt; On Sat, Dec 12, 2015, at 03:26 AM, ilya via swift-evolution wrote:<br>&gt;&gt; &gt; var s = &quot;&quot;<br>&gt;&gt; &gt; s.append(&quot;c&quot;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This code looks pretty straightforward,<br>&gt;&gt;  <br>&gt;&gt; This looks to me like you&#39;re adding a string, which can be done via <br>&gt;&gt;  <br>&gt;&gt; s += &quot;c&quot;<br>&gt;&gt;  <br>&gt;&gt; Yes, I know adding a character can theoretically be a bit more performant, but why would that be a consideration for static strings? Compiler should optimize both expressions above to the same result.<br>&gt;&gt;  <br>&gt;&gt; &gt; UInt : u // or uint<br>&gt;&gt; &gt; Int16 : i16<br>&gt;&gt; &gt; Int32 : i32<br>&gt;&gt;  <br>&gt;&gt; I think <br>&gt;&gt;  <br>&gt;&gt; let number = 56i32<br>&gt;&gt;  <br>&gt;&gt; is much less readable than <br>&gt;&gt;  <br>&gt;&gt; let number: Int32 = 56<br>&gt;&gt;  <br>&gt;&gt; so probably best not to encourage it.<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; On Sat, Dec 12, 2015 at 1:48 AM, Marc Knaup via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; Too bad that string literals don&#39;t conform to a specific protocol.<br>&gt;&gt;  <br>&gt;&gt; This would also be a nice but doesn&#39;t work:<br>&gt;&gt; // StaticString:&quot;An simple string designed to represent text that is &#39;knowable at compile-time&#39;.&quot;<br>&gt;&gt; extensionStaticString {<br>&gt;&gt; <br>&gt;&gt;     var x: Int {<br>&gt;&gt;         return123<br>&gt;&gt;     }<br>&gt;&gt; }<br>&gt;&gt; <br>&gt;&gt; print(&quot;abc&quot;.x)<br>&gt;&gt; <br>&gt;&gt;  <br>&gt;&gt; On Fri, Dec 11, 2015 at 11:38 PM, Joe Groff via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; I was a little disappointed something like this didn&#39;t already work:<br>&gt;&gt;  <br>&gt;&gt; struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>&gt;&gt; struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br>&gt;&gt;  <br>&gt;&gt; &quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&gt;&gt; &quot;y&quot;.b // same, for Bar<br>&gt;&gt;  <br>&gt;&gt; -Joe<br>&gt;&gt; <br>&gt;&gt; &gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String, Character, and UnicodeScalar can get annoying at times. When unconstrained it&#39;s always String, and the only way to disambiguate between the two when used in a context that takes both Character and UnicodeScalar is to explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial example of this in action is<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; var s = &quot;&quot;<br>&gt;&gt; &gt; s.append(&quot;c&quot;)<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; This code looks pretty straightforward, but it throws an ambiguity error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s resolved, the behavior is the same).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get pretty annoying if you have to do it a lot. It would be great to reduce this typing a bit.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; My initial proposal here is to introduce string literal suffixes. Let me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default if unconstrained). AFAIK this is not ambiguous with the current syntax, as I don&#39;t believe it&#39;s ever legal to put an identifier like that after a string.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Ideally this could be extended by library code with new suffixes. The obvious way to do that is to allow for a new type of &quot;operator&quot; declaration, perhaps something like `literal operator c { type Character }` (where `literal` is a context-sensitive keyword), which declares the suffix and the type (the actual type construction will be done with StringLiteralConvertible, StringInterpolationConvertible, UnicodeScalarLiteralConvertible, or ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared in two different modules that are imported into the same program, they&#39;re unambiguous within their source modules, and within the parent module using the suffix operator will be ambiguous unless further constrained (e.g. similar to using a function that&#39;s overloaded on its return type).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r ` for a regular expression (although regular expressions probably also want some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s orthogonal to this proposal).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; Syntax is up for debate. I picked postfix characters because I believe it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in C++11&#39;s user-defined literals (although C++11 has a required underscore before the literal, I believe this is just to allow C++11 to define its own new suffixes without ambiguity). This syntax could also work for numeric literals, come to think of it, with the same declaration and using IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work for array and dictionary literals too, though that&#39;s less likely to be useful.<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; FWIW, Playground color and image literals have the form [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve the original problem (of having to type out the full type name) so this syntax is not appropriate for this feature (but the syntax is fine for what Playgrounds use it for, which is to embed literal colors/images into the source code).<br>&gt;&gt; &gt;<br>&gt;&gt; &gt; -Kevin Ballard<br>&gt;&gt; &gt; _______________________________________________<br>&gt;&gt; &gt; swift-evolution mailing list<br>&gt;&gt; &gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; &gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt;  <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;&gt;  <br>&gt;&gt; <br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt;  <br>&gt; <br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution &lt;https://lists.swift.org/mailman/listinfo/swift-evolution&gt;<br>&gt; <br>&gt; <br>&gt;  _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20151214/b7e53949/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/c4fe988326eed161b989d0c5521cb105?s=50"></div><header><strong>Proposal: String literal suffixes for defining types</strong> from <string>Jordan Rose</string> &lt;jordan_rose at apple.com&gt;<p>December 14, 2015 at 04:00:00pm</p></header><div class="content"><p>We had this for a while. It made the type checker do ridiculous amounts of work trying every StringLiteralConvertible type when working on a large expression, especially one where the errors were elsewhere. That&#39;s at least partly a search order issue in the type checker, but still, magically picking a type based on the members of StringLiteralConvertible types currently in scope seems like a bad idea to me.<br></p><p>Jordan<br></p><p>&gt; On Dec 11, 2015, at 14:38, Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; I was a little disappointed something like this didn&#39;t already work:<br>&gt; <br>&gt; struct Foo: StringLiteralConvertible { var f: Foo { return self } }<br>&gt; struct Bar: StringLiteralConvertible { var b: Bar { return self } }<br>&gt; <br>&gt; &quot;x&quot;.f // currently a failed lookup in String; could produce a Foo<br>&gt; &quot;y&quot;.b // same, for Bar<br>&gt; <br>&gt; -Joe<br>&gt; <br>&gt;&gt; On Dec 10, 2015, at 11:07 AM, Kevin Ballard via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The fact that Swift uses the exact same syntax (&quot;a&quot;) for String, Character, and UnicodeScalar can get annoying at times. When unconstrained it&#39;s always String, and the only way to disambiguate between the two when used in a context that takes both Character and UnicodeScalar is to explicitly constraint it further, e.g. with `&quot;a&quot; as Character`. A trivial example of this in action is<br>&gt;&gt; <br>&gt;&gt; var s = &quot;&quot;<br>&gt;&gt; s.append(&quot;c&quot;)<br>&gt;&gt; <br>&gt;&gt; This code looks pretty straightforward, but it throws an ambiguity error (and the annoying part is, it doesn&#39;t actually matter which way it&#39;s resolved, the behavior is the same).<br>&gt;&gt; <br>&gt;&gt; Having to type `&quot;c&quot; as Character` and `&quot;c&quot; as UnicodeScalar` can get pretty annoying if you have to do it a lot. It would be great to reduce this typing a bit.<br>&gt;&gt; <br>&gt;&gt; My initial proposal here is to introduce string literal suffixes. Let me type something like `&quot;c&quot;c` for a Character and `&quot;c&quot;us` for a UnicodeScalar (and maybe `&quot;c&quot;s` to explicitly mean a String, although that&#39;s the default if unconstrained). AFAIK this is not ambiguous with the current syntax, as I don&#39;t believe it&#39;s ever legal to put an identifier like that after a string.<br>&gt;&gt; <br>&gt;&gt; Ideally this could be extended by library code with new suffixes. The obvious way to do that is to allow for a new type of &quot;operator&quot; declaration, perhaps something like `literal operator c { type Character }` (where `literal` is a context-sensitive keyword), which declares the suffix and the type (the actual type construction will be done with StringLiteralConvertible, StringInterpolationConvertible, UnicodeScalarLiteralConvertible, or ExtendedGraphemeClusterLiteralConvertible). If the same suffix is declared in two different modules that are imported into the same program, they&#39;re unambiguous within their source modules, and within the parent module using the suffix operator will be ambiguous unless further constrained (e.g. similar to using a function that&#39;s overloaded on its return type).<br>&gt;&gt; <br>&gt;&gt; One possible library use for this would be something like `&quot;^\s*foo&quot;r ` for a regular expression (although regular expressions probably also want some sort of &quot;raw&quot; string literal syntax to deal with escapes, but that&#39;s orthogonal to this proposal).<br>&gt;&gt; <br>&gt;&gt; Syntax is up for debate. I picked postfix characters because I believe it&#39;s ambiguous and it has precedent, both in C&#39;s numeric literals, and in C++11&#39;s user-defined literals (although C++11 has a required underscore before the literal, I believe this is just to allow C++11 to define its own new suffixes without ambiguity). This syntax could also work for numeric literals, come to think of it, with the same declaration and using IntegerLiteralConvertible or FloatLiteralConvertible. Heck, it could work for array and dictionary literals too, though that&#39;s less likely to be useful.<br>&gt;&gt; <br>&gt;&gt; FWIW, Playground color and image literals have the form [#Color(colorLiteralRed: 1, blue: 0, green: 0, alpha: 1)#] and [#Image(imageLiteral: &quot;hi.png&quot;)#]. These are interesting, but don&#39;t solve the original problem (of having to type out the full type name) so this syntax is not appropriate for this feature (but the syntax is fine for what Playgrounds use it for, which is to embed literal colors/images into the source code).<br>&gt;&gt; <br>&gt;&gt; -Kevin Ballard<br>&gt;&gt; _______________________________________________<br>&gt;&gt; swift-evolution mailing list<br>&gt;&gt; swift-evolution at swift.org<br>&gt;&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br>&gt; <br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
