<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1c0c53e85b99d85108a62b4de8e3067?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Yoann Gini</string> &lt;yoann.gini at gmail.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>Hi<br></p><p>I’m following Swift server side initiatives really closely. I’m a developer and sys admin, really interested in subjects linked to performance and security.<br></p><p>Swift look like a perfect language for server side, especially with Cocoa framework on the back.<br></p><p>Looking at all the current initiative, I’ve to say don’t understand something: why everyone start by creating a brand new HTTP server?<br></p><p>From a DevOps point of view, it looks like a waste of resources to start writing HTTP server framework in swift. No sys admin will ever allow a small custom HTTP server to be open to the Internet without a proxy before. Plus, we already have two really great HTTP servers in the UNIX world, Apache and NGINX. In no way a custom HTTP language related framework can cover as much as those two projects.<br></p><p>Even if I understand some people might want built-in HTTP handler in a client/server app, I don’t really understand why all existing initiatives take this road.<br></p><p>Looking at what currently exists, I found WSGI (or even old school CGI) way more interesting for production purpose.<br></p><p>If we are trying to deploy Swift on the server side, CGI alike solution look like the quick win. It avoid wasting dev time by reusing all HTTP server already existing, so developer from this community will have to concentrate only to create a bridge. And even more, this bridge can be created in the first version by simply porting WSGI behavior to Swift.<br></p><p>This is just a simple personal opinion. Just wondering why.<br></p><p>Best regards,<br>Yoann Gini<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-server-dev/attachments/20161026/8124b46d/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/8d23c2d6c1ccb724044f09d449772ff2?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Helge Heß</string> &lt;me at helgehess.eu&gt;<p>October 26, 2016 at 11:00:00am</p></header><div class="content"><p>Is there a need for a swift-server-users mailing list?<br></p><p>hh<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1c0c53e85b99d85108a62b4de8e3067?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Yoann Gini</string> &lt;yoann.gini at gmail.com&gt;<p>October 26, 2016 at 10:00:00am</p></header><div class="content"><p>&gt; Le 26 oct. 2016 à 10:25, Helge Heß via swift-server-dev &lt;swift-server-dev at swift.org&gt; a écrit :<br>&gt; <br>&gt; Is there a need for a swift-server-users mailing list?<br></p><p>It depends on whether you consider a language is made for the language itself or for production. Considering real case usage scenarios and constraints might be a good idea in any kind of software development.<br></p><p>In particular, advocating for WSGI alike integration isn’t a user consideration but a request for the server side app developers who would like to avoid coming back to the Stone Age of Tomcat.<br></p><p>Best regards,<br>Yoann Gini<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/76dd8f23593c1a1f5c57cc6a8982d726?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Brent Royal-Gordon</string> &lt;brent at architechies.com&gt;<p>October 26, 2016 at 02:00:00am</p></header><div class="content"><p>&gt; On Oct 26, 2016, at 2:00 AM, Yoann Gini via swift-server-dev &lt;swift-server-dev at swift.org&gt; wrote:<br>&gt; <br>&gt; Looking at all the current initiative, I’ve to say don’t understand something: why everyone start by creating a brand new HTTP server?<br>&gt; <br>&gt; From a DevOps point of view, it looks like a waste of resources to start writing HTTP server framework in swift. No sys admin will ever allow a small custom HTTP server to be open to the Internet without a proxy before. Plus, we already have two really great HTTP servers in the UNIX world, Apache and NGINX. In no way a custom HTTP language related framework can cover as much as those two projects.<br>&gt; <br>&gt; Even if I understand some people might want built-in HTTP handler in a client/server app, I don’t really understand why all existing initiatives take this road.<br></p><p>This trend seems to have started with Rails. It has a few advantages:<br></p><p>1. You can use the embedded server in development and testing. This is *way* easier than installing Apache on your development machine or CI setup and configuring it to point to your application.<br></p><p>2. In production, you can configure Apache or nginx to reverse proxy for the app; this configuration is almost entirely agnostic to the application itself, so you can modify the application&#39;s behavior without playing with the frontend web server.<br></p><p>3. The frontend proxy and backend web server communicate over a plain old socket, so they can run as different user accounts or even in separate VMs.<br></p><p>Basically, embedding a web server and reverse proxying for it isolates the application from the frontend server and simplifies the management of both.<br></p><p>-- <br>Brent Royal-Gordon<br>Architechies<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/a1c0c53e85b99d85108a62b4de8e3067?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Yoann Gini</string> &lt;yoann.gini at gmail.com&gt;<p>October 26, 2016 at 11:00:00am</p></header><div class="content"><p>&gt; Le 26 oct. 2016 à 10:59, Brent Royal-Gordon &lt;brent at architechies.com&gt; a écrit :<br>&gt; <br>&gt; This trend seems to have started with Rails. It has a few advantages:<br>&gt; <br>&gt; 1. You can use the embedded server in development and testing. This is *way* easier than installing Apache on your development machine or CI setup and configuring it to point to your application.<br></p><p>100% agree with that<br></p><p>&gt; 2. In production, you can configure Apache or nginx to reverse proxy for the app; this configuration is almost entirely agnostic to the application itself, so you can modify the application&#39;s behavior without playing with the frontend web server.<br>&gt; <br>&gt; 3. The frontend proxy and backend web server communicate over a plain old socket, so they can run as different user accounts or even in separate VMs.<br>&gt; <br>&gt; Basically, embedding a web server and reverse proxying for it isolates the application from the frontend server and simplifies the management of both.<br></p><p>I’m not really sure this is a pros or cons. Having to run multiple processes and use sockets increase code complexity and surface for attacks. It increase the number of services started so the number of processes to watch.<br></p><p>In some scenario, this is better, in some others, this is worst.<br></p><p>As I’ve said on my first e-mail, I don’t say standalone swift HTTP server must not exist. I’ve just said it could be interesting to think about others patterns.<br></p><p>Allowing behavior like WSGI where you can use both scenario is IMHO the best solution ever, so it can fit for all needs. <br></p><p>Best regards,<br>Yoann Gini<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/cd2919ebf2f35a905b24e5002b4dd836?s=50"></div><header><strong>Why not rely on existing models?</strong> from <string>Chris Hanson</string> &lt;chanson at apple.com&gt;<p>November  1, 2016 at 06:00:00pm</p></header><div class="content"><p>On Oct 26, 2016, at 2:59 AM, Brent Royal-Gordon &lt;brent at architechies.com&gt; wrote:<br>&gt; <br>&gt;&gt; Even if I understand some people might want built-in HTTP handler in a client/server app, I don’t really understand why all existing initiatives take this road.<br>&gt; <br>&gt; This trend seems to have started with Rails<br></p><p>Just as a point of history, WebObjects did this in the mid-1990s. The built-in web server was used primarily for development purposes.<br></p><p>WebObjects applications were generally deployed using a different WOAdapter entirely, rather than do something like reverse-proxy the built-in server.<br></p><p>  -- Chris<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
