<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Swift Mailing List Archive</title>
    <link rel="stylesheet" href="/css/app-13f065ae5e595562a5022c544e3b976c.css?vsn=d">
  </head>

  <body>
    <div class="container">
      <header class="header">
        <img src="/images/swift-d0237fc716ba0932a940049990beba1b.svg?vsn=d" height="70">
      </header>

      <p class="alert alert-info" role="alert"></p>
      <p class="alert alert-danger" role="alert"></p>

    </div> <!-- /container -->
    <main role="main">
<div class="comment-wrapper"><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Pitch: make class initialization complexity more progressively disclosed</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>February 29, 2016 at 10:00:00pm</p></header><div class="content"><p>Forward: This isn’t a concrete proposal, this an observation (originally from Joe Groff) of a problem that we hoped to have time to discuss and design in the Swift 3 timeframe, but which the core team won’t have time to drive.  If anyone is interested in picking up this as a project to scope, design, and drive, that would be great. :-)<br></p><p><br>Class initialization in Swift support a wide array of knobs and concepts, including things like designated initializers, required initializers, convenience initializers, etc.  These are all required by various common patterns in Cocoa and other OO systems, but has an unfortunate side effect: all of the complexity is foisted on you at once.    This typically happens because you subclass a system framework and start getting errors about not fulfilling the requirements that may not be fully defining the behavior that would be required if another class comes along and derives from you.<br></p><p>The simplifying observation here is that many classes (particularly in gui apps) are leaf classes that are not further derived from.  Wouldn’t it be great if you could freely define a new class and not have to know about required and convenience initializers?  It seems that we should only have to enforce these requirements if you a) further derive from this class within your module, or b) mark the class publicly-derivable-from.<br></p><p>This isn’t a full pitch because I haven’t done a survey of all of the simplifications we could offer, and getting the diagnostics messages right for this would take a significant amount of work (e.g. explaining why &quot;class X needs a required init because class Y started deriving from it”).<br></p><p>-Chris<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/3488bcf34d8c45d917ed27d67a0ffa45?s=50"></div><header><strong>Pitch: make class initialization complexity more progressively disclosed</strong> from <string>David Hart</string> &lt;david at hartbit.com&gt;<p>March  1, 2016 at 12:00:00pm</p></header><div class="content"><p>Really looking forward to this. Isn&#39;t part of the solution to make classes final by default?<br></p><p>&gt; On 01 Mar 2016, at 07:53, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Forward: This isn’t a concrete proposal, this an observation (originally from Joe Groff) of a problem that we hoped to have time to discuss and design in the Swift 3 timeframe, but which the core team won’t have time to drive.  If anyone is interested in picking up this as a project to scope, design, and drive, that would be great. :-)<br>&gt; <br>&gt; <br>&gt; Class initialization in Swift support a wide array of knobs and concepts, including things like designated initializers, required initializers, convenience initializers, etc.  These are all required by various common patterns in Cocoa and other OO systems, but has an unfortunate side effect: all of the complexity is foisted on you at once.    This typically happens because you subclass a system framework and start getting errors about not fulfilling the requirements that may not be fully defining the behavior that would be required if another class comes along and derives from you.<br>&gt; <br>&gt; The simplifying observation here is that many classes (particularly in gui apps) are leaf classes that are not further derived from.  Wouldn’t it be great if you could freely define a new class and not have to know about required and convenience initializers?  It seems that we should only have to enforce these requirements if you a) further derive from this class within your module, or b) mark the class publicly-derivable-from.<br>&gt; <br>&gt; This isn’t a full pitch because I haven’t done a survey of all of the simplifications we could offer, and getting the diagnostics messages right for this would take a significant amount of work (e.g. explaining why &quot;class X needs a required init because class Y started deriving from it”).<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/09b6a9b66eecf177910c8e47db78d8eb?s=50"></div><header><strong>Pitch: make class initialization complexity more progressively disclosed</strong> from <string>Chris Lattner</string> &lt;clattner at apple.com&gt;<p>March  1, 2016 at 09:00:00am</p></header><div class="content"><p>&gt; On Mar 1, 2016, at 3:10 AM, David Hart &lt;david at hartbit.com&gt; wrote:<br>&gt; <br>&gt; Really looking forward to this. Isn&#39;t part of the solution to make classes final by default?<br></p><p>I think that that is a separable issue.  Even without final-by-default, we can tell if there are no subclasses within the current module.<br></p><p>-Chris<br></p></div></li></ul></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/5451f7df31d36d0159a018706aec7adb?s=50"></div><header><strong>Pitch: make class initialization complexity more progressively disclosed</strong> from <string>Erica Sadun</string> &lt;erica at ericasadun.com&gt;<p>March  1, 2016 at 10:00:00am</p></header><div class="content"><p>Oh god yes.<br></p><p>On behalf of every descendant of UIViewController and SKScene, I thank you for this idea.<br></p><p>class MyViewController: UIViewController {<br>    let someNewThing: SomeType<br></p><p>    leaf init(someNewThing: SomeType) {<br>       // no calls to super, no calls to *anything*<br>        self.someNewThing = someNewThing<br>        // blah blah use self here blah<br>    }<br>}<br></p><p>@memberwise class MyScene: SKScene {<br>    let someNewThing: SomeType<br></p><p>    // boom. done. initless.<br>}<br></p><p>-- E<br></p><p><br>&gt; On Feb 29, 2016, at 11:53 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; Forward: This isn’t a concrete proposal, this an observation (originally from Joe Groff) of a problem that we hoped to have time to discuss and design in the Swift 3 timeframe, but which the core team won’t have time to drive.  If anyone is interested in picking up this as a project to scope, design, and drive, that would be great. :-)<br>&gt; <br>&gt; <br>&gt; Class initialization in Swift support a wide array of knobs and concepts, including things like designated initializers, required initializers, convenience initializers, etc.  These are all required by various common patterns in Cocoa and other OO systems, but has an unfortunate side effect: all of the complexity is foisted on you at once.    This typically happens because you subclass a system framework and start getting errors about not fulfilling the requirements that may not be fully defining the behavior that would be required if another class comes along and derives from you.<br>&gt; <br>&gt; The simplifying observation here is that many classes (particularly in gui apps) are leaf classes that are not further derived from.  Wouldn’t it be great if you could freely define a new class and not have to know about required and convenience initializers?  It seems that we should only have to enforce these requirements if you a) further derive from this class within your module, or b) mark the class publicly-derivable-from.<br>&gt; <br>&gt; This isn’t a full pitch because I haven’t done a survey of all of the simplifications we could offer, and getting the diagnostics messages right for this would take a significant amount of work (e.g. explaining why &quot;class X needs a required init because class Y started deriving from it”).<br>&gt; <br>&gt; -Chris<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/baf32590/attachment.html&gt;<br></p></div></li><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/06c1dcc7dce6a93d194b9c013376e3f0?s=50"></div><header><strong>Pitch: make class initialization complexity more progressively disclosed</strong> from <string>Joe Groff</string> &lt;jgroff at apple.com&gt;<p>March  1, 2016 at 12:00:00pm</p></header><div class="content"><p>On Feb 29, 2016, at 10:53 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org&gt; wrote:<br>&gt; <br>&gt; The simplifying observation here is that many classes (particularly in gui apps) are leaf classes that are not further derived from.  Wouldn’t it be great if you could freely define a new class and not have to know about required and convenience initializers?  It seems that we should only have to enforce these requirements if you a) further derive from this class within your module, or b) mark the class publicly-derivable-from.<br></p><p>I think we could avoid an explicit need for initializer decorations in most private or internal (a) cases too, since we have visibility into the entire class hierarchy. We could raise errors when specific subclasses don&#39;t provide `required` initializers, and infer the `convenience`-ness of each initializer from whether it `self.init` or `super.init` delegates. For non-publicly-subclassable classes there are no API liabilities to be concerned about.<br></p><p>-Joe<br>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160301/43fb03d0/attachment.html&gt;<br></p></div><ul class="comments"><li class="comment"><div class="avatar"><img src="https://www.gravatar.com/avatar/85a454a69ee2cf2ac4b990dc9e87b664?s=50"></div><header><strong>Pitch: make class initialization complexity more progressively disclosed</strong> from <string>Thorsten Seitz</string> &lt;tseitz42 at icloud.com&gt;<p>March  2, 2016 at 10:00:00pm</p></header><div class="content"><p>I actually like the `convenience`-ness being explicit.<br></p><p>-Thorsten<br></p><p><br>&gt; Am 01.03.2016 um 21:04 schrieb Joe Groff via swift-evolution &lt;swift-evolution at swift.org&gt;:<br>&gt; <br>&gt; On Feb 29, 2016, at 10:53 PM, Chris Lattner via swift-evolution &lt;swift-evolution at swift.org &lt;mailto:swift-evolution at swift.org&gt;&gt; wrote:<br>&gt;&gt; <br>&gt;&gt; The simplifying observation here is that many classes (particularly in gui apps) are leaf classes that are not further derived from.  Wouldn’t it be great if you could freely define a new class and not have to know about required and convenience initializers?  It seems that we should only have to enforce these requirements if you a) further derive from this class within your module, or b) mark the class publicly-derivable-from.<br>&gt; <br>&gt; I think we could avoid an explicit need for initializer decorations in most private or internal (a) cases too, since we have visibility into the entire class hierarchy. We could raise errors when specific subclasses don&#39;t provide `required` initializers, and infer the `convenience`-ness of each initializer from whether it `self.init` or `super.init` delegates. For non-publicly-subclassable classes there are no API liabilities to be concerned about.<br>&gt; <br>&gt; -Joe<br>&gt; _______________________________________________<br>&gt; swift-evolution mailing list<br>&gt; swift-evolution at swift.org<br>&gt; https://lists.swift.org/mailman/listinfo/swift-evolution<br></p><p>-------------- next part --------------<br>An HTML attachment was scrubbed...<br>URL: &lt;https://lists.swift.org/pipermail/swift-evolution/attachments/20160302/c8e44734/attachment.html&gt;<br></p></div></li></ul></li></ul></li></ul></div>    </main>
    <script src="/js/app-c283ee129de63ad743722e9511e67a5d.js?vsn=d"></script>
  </body>
  <footer>
    <p>Swift and the Swift logo are trademarks of Apple Inc.</p>
  </footer>
</html>
